<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - flate</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>flate</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"errors"
"fmt"
"io"
"math"
"math"
"io"
"math"
"math/bits"
"sort"
"bufio"
"io"
"math/bits"
"strconv"
"sync"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="BestCompression">
               <h3>
                  BestCompression 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const BestCompression = 9</code></pre>
            </article>
            
            <article class="global" data-name="BestSpeed">
               <h3>
                  BestSpeed 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const BestSpeed = 1</code></pre>
            </article>
            
            <article class="global" data-name="DefaultCompression">
               <h3>
                  DefaultCompression 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const DefaultCompression = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="HuffmanOnly">
               <h3>
                  HuffmanOnly 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>HuffmanOnly disables Lempel-Ziv match searching and only performs Huffman
entropy encoding. This mode is useful in compressing data that has
already been compressed with an LZ style algorithm (e.g. Snappy or LZ4)
that lacks an entropy encoder. Compression gains are achieved when
certain bytes in the input stream occur more frequently than others.
Note that HuffmanOnly produces a compressed output that is
RFC 1951 compliant. That is, any valid DEFLATE decompressor will
continue to be able to decompress this output.</p>
               
               <pre><code>const HuffmanOnly = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="NoCompression">
               <h3>
                  NoCompression 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NoCompression = 0</code></pre>
            </article>
            
            <article class="global" data-name="badCode">
               <h3>
                  badCode 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const badCode = 255</code></pre>
            </article>
            
            <article class="global" data-name="baseMatchLength">
               <h3>
                  baseMatchLength 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The LZ77 step produces a sequence of literal tokens and <length, offset>
pair tokens. The offset is also known as distance. The underlying wire
format limits the range of lengths and offsets. For example, there are
256 legitimate lengths: those in the range [3, 258]. This package's
compressor uses a higher minimum match length, enabling optimizations
such as finding matches via 32-bit loads and compares.</p>
               
               <pre><code>const baseMatchLength = 3</code></pre>
            </article>
            
            <article class="global" data-name="baseMatchOffset">
               <h3>
                  baseMatchOffset 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const baseMatchOffset = 1</code></pre>
            </article>
            
            <article class="global" data-name="bufferFlushSize">
               <h3>
                  bufferFlushSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bufferFlushSize indicates the buffer size
after which bytes are flushed to the writer.
Should preferably be a multiple of 6, since
we accumulate 6 bytes between writes to the buffer.</p>
               
               <pre><code>const bufferFlushSize = 240</code></pre>
            </article>
            
            <article class="global" data-name="bufferReset">
               <h3>
                  bufferReset 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Reset the buffer offset when reaching this.
Offsets are stored between blocks as int32 values.
Since the offset we are checking against is at the beginning
of the buffer, we need to subtract the current and input
buffer to not risk overflowing the int32.</p>
               
               <pre><code>const bufferReset = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="bufferSize">
               <h3>
                  bufferSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bufferSize is the actual output byte buffer size.
It must have additional headroom for a flush
which can contain up to 8 bytes.</p>
               
               <pre><code>const bufferSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="codeOrder">
               <h3>
                  codeOrder 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var codeOrder = [...]int{...}</code></pre>
            </article>
            
            <article class="global" data-name="codegenCodeCount">
               <h3>
                  codegenCodeCount 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The number of codegen codes.</p>
               
               <pre><code>const codegenCodeCount = 19</code></pre>
            </article>
            
            <article class="global" data-name="codegenOrder">
               <h3>
                  codegenOrder 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>The odd order in which the codegen code sizes are written.</p>
               
               <pre><code>var codegenOrder = []uint32{...}</code></pre>
            </article>
            
            <article class="global" data-name="endBlockMarker">
               <h3>
                  endBlockMarker 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The special code used to mark the end of a block.</p>
               
               <pre><code>const endBlockMarker = 256</code></pre>
            </article>
            
            <article class="global" data-name="errWriterClosed">
               <h3>
                  errWriterClosed 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errWriterClosed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="fixedHuffmanDecoder">
               <h3>
                  fixedHuffmanDecoder 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var fixedHuffmanDecoder huffmanDecoder</code></pre>
            </article>
            
            <article class="global" data-name="fixedLiteralEncoding">
               <h3>
                  fixedLiteralEncoding 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var fixedLiteralEncoding *huffmanEncoder = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="fixedOffsetEncoding">
               <h3>
                  fixedOffsetEncoding 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var fixedOffsetEncoding *huffmanEncoder = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="fixedOnce">
               <h3>
                  fixedOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Initialize the fixedHuffmanDecoder only once upon first use.</p>
               
               <pre><code>var fixedOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="hashBits">
               <h3>
                  hashBits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hashBits = 17</code></pre>
            </article>
            
            <article class="global" data-name="hashMask">
               <h3>
                  hashMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hashMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="hashSize">
               <h3>
                  hashSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hashSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="hashmul">
               <h3>
                  hashmul 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hashmul = 0x1e35a7bd</code></pre>
            </article>
            
            <article class="global" data-name="huffOffset">
               <h3>
                  huffOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>huffOffset is a static offset encoder used for huffman only encoding.
It can be reused since we will not be encoding offset values.</p>
               
               <pre><code>var huffOffset *huffmanEncoder</code></pre>
            </article>
            
            <article class="global" data-name="huffmanChunkBits">
               <h3>
                  huffmanChunkBits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const huffmanChunkBits = 9</code></pre>
            </article>
            
            <article class="global" data-name="huffmanCountMask">
               <h3>
                  huffmanCountMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const huffmanCountMask = 15</code></pre>
            </article>
            
            <article class="global" data-name="huffmanNumChunks">
               <h3>
                  huffmanNumChunks 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const huffmanNumChunks = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="huffmanValueShift">
               <h3>
                  huffmanValueShift 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const huffmanValueShift = 4</code></pre>
            </article>
            
            <article class="global" data-name="inputMargin">
               <h3>
                  inputMargin 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants are defined by the Snappy implementation so that its
assembly implementation can fast-path some 16-bytes-at-a-time copies. They
aren't necessary in the pure Go implementation, as we don't use those same
optimizations, but using the same thresholds doesn't really hurt.</p>
               
               <pre><code>const inputMargin = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="lengthBase">
               <h3>
                  lengthBase 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>The length indicated by length code X - LENGTH_CODES_START.</p>
               
               <pre><code>var lengthBase = []uint32{...}</code></pre>
            </article>
            
            <article class="global" data-name="lengthCodes">
               <h3>
                  lengthCodes 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>The length code for length X (MIN_MATCH_LENGTH <= X <= MAX_MATCH_LENGTH)
is lengthCodes[length - MIN_MATCH_LENGTH]</p>
               
               <pre><code>var lengthCodes = [...]uint32{...}</code></pre>
            </article>
            
            <article class="global" data-name="lengthCodesStart">
               <h3>
                  lengthCodesStart 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The first length code.</p>
               
               <pre><code>const lengthCodesStart = 257</code></pre>
            </article>
            
            <article class="global" data-name="lengthExtraBits">
               <h3>
                  lengthExtraBits 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>The number of extra bits needed by length code X - LENGTH_CODES_START.</p>
               
               <pre><code>var lengthExtraBits = []int8{...}</code></pre>
            </article>
            
            <article class="global" data-name="lengthShift">
               <h3>
                  lengthShift 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>2 bits:   type   0 = literal  1=EOF  2=Match   3=Unused
8 bits:   xlength = length - MIN_MATCH_LENGTH
22 bits   xoffset = offset - MIN_OFFSET_SIZE, or literal</p>
               
               <pre><code>const lengthShift = 22</code></pre>
            </article>
            
            <article class="global" data-name="levels">
               <h3>
                  levels 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var levels = []compressionLevel{...}</code></pre>
            </article>
            
            <article class="global" data-name="literalType">
               <h3>
                  literalType 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const literalType = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="logWindowSize">
               <h3>
                  logWindowSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const logWindowSize = 15</code></pre>
            </article>
            
            <article class="global" data-name="matchType">
               <h3>
                  matchType 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const matchType = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxBitsLimit">
               <h3>
                  maxBitsLimit 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxBitsLimit = 16</code></pre>
            </article>
            
            <article class="global" data-name="maxCodeLen">
               <h3>
                  maxCodeLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxCodeLen = 16</code></pre>
            </article>
            
            <article class="global" data-name="maxFlateBlockTokens">
               <h3>
                  maxFlateBlockTokens 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The maximum number of tokens we put into a single flate block, just to
stop things from getting too large.</p>
               
               <pre><code>const maxFlateBlockTokens = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxHashOffset">
               <h3>
                  maxHashOffset 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxHashOffset = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxMatchLength">
               <h3>
                  maxMatchLength 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxMatchLength = 258</code></pre>
            </article>
            
            <article class="global" data-name="maxMatchOffset">
               <h3>
                  maxMatchOffset 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxMatchOffset = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxNumDist">
               <h3>
                  maxNumDist 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxNumDist = 30</code></pre>
            </article>
            
            <article class="global" data-name="maxNumLit">
               <h3>
                  maxNumLit 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The next three numbers come from the RFC section 3.2.7, with the
additional proviso in section 3.2.5 which implies that distance codes
30 and 31 should never occur in compressed data.</p>
               
               <pre><code>const maxNumLit = 286</code></pre>
            </article>
            
            <article class="global" data-name="maxStoreBlockSize">
               <h3>
                  maxStoreBlockSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxStoreBlockSize = 65535</code></pre>
            </article>
            
            <article class="global" data-name="minMatchLength">
               <h3>
                  minMatchLength 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const minMatchLength = 4</code></pre>
            </article>
            
            <article class="global" data-name="minNonLiteralBlockSize">
               <h3>
                  minNonLiteralBlockSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants are defined by the Snappy implementation so that its
assembly implementation can fast-path some 16-bytes-at-a-time copies. They
aren't necessary in the pure Go implementation, as we don't use those same
optimizations, but using the same thresholds doesn't really hurt.</p>
               
               <pre><code>const minNonLiteralBlockSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="numCodes">
               <h3>
                  numCodes 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const numCodes = 19</code></pre>
            </article>
            
            <article class="global" data-name="offsetBase">
               <h3>
                  offsetBase 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var offsetBase = []uint32{...}</code></pre>
            </article>
            
            <article class="global" data-name="offsetCodeCount">
               <h3>
                  offsetCodeCount 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The largest offset code.</p>
               
               <pre><code>const offsetCodeCount = 30</code></pre>
            </article>
            
            <article class="global" data-name="offsetCodes">
               <h3>
                  offsetCodes 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var offsetCodes = [...]uint32{...}</code></pre>
            </article>
            
            <article class="global" data-name="offsetExtraBits">
               <h3>
                  offsetExtraBits 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>offset code word extra bits.</p>
               
               <pre><code>var offsetExtraBits = []int8{...}</code></pre>
            </article>
            
            <article class="global" data-name="offsetMask">
               <h3>
                  offsetMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const offsetMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="skipNever">
               <h3>
                  skipNever 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const skipNever = math.MaxInt32</code></pre>
            </article>
            
            <article class="global" data-name="tableBits">
               <h3>
                  tableBits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const tableBits = 14</code></pre>
            </article>
            
            <article class="global" data-name="tableMask">
               <h3>
                  tableMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const tableMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="tableShift">
               <h3>
                  tableShift 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const tableShift = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="tableSize">
               <h3>
                  tableSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const tableSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="typeMask">
               <h3>
                  typeMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const typeMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="windowMask">
               <h3>
                  windowMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const windowMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="windowSize">
               <h3>
                  windowSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const windowSize = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="CorruptInputError">
               <h3>
                  CorruptInputError
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A CorruptInputError reports the presence of corrupt input at a given offset.</p>
               
               <pre><code>type CorruptInputError int64</code></pre>
            </article>
            
            <article class="type" data-name="InternalError">
               <h3>
                  InternalError
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An InternalError reports an error in the flate code itself.</p>
               
               <pre><code>type InternalError string</code></pre>
            </article>
            
            <article class="type" data-name="byFreq">
               <h3>
                  byFreq
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type byFreq []literalNode</code></pre>
            </article>
            
            <article class="type" data-name="byLiteral">
               <h3>
                  byLiteral
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type byLiteral []literalNode</code></pre>
            </article>
            
            <article class="type" data-name="token">
               <h3>
                  token
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type token uint32</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Reader">
               <h3>
                  Reader
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>The actual read interface needed by [NewReader].
If the passed in io.Reader does not also have ReadByte,
the [NewReader] will introduce its own buffering.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Reader interface {
io.Reader
io.ByteReader
}</code></pre>
            </article>
            
            <article class="interface" data-name="Resetter">
               <h3>
                  Resetter
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Resetter resets a ReadCloser returned by [NewReader] or [NewReaderDict]
to switch to a new underlying [Reader]. This permits reusing a ReadCloser
instead of allocating a new one.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Resetter interface {
Reset(r io.Reader, dict []byte) error
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="ReadError">
               <h3>
                  ReadError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ReadError reports an error encountered while reading input.
Deprecated: No longer returned.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ReadError struct {
Offset int64
Err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="WriteError">
               <h3>
                  WriteError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A WriteError reports an error encountered while writing output.
Deprecated: No longer returned.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type WriteError struct {
Offset int64
Err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="Writer">
               <h3>
                  Writer
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Writer takes data written to it and writes the compressed
form of that data to an underlying writer (see [NewWriter]).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Writer struct {
d compressor
dict []byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="compressionLevel">
               <h3>
                  compressionLevel
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type compressionLevel struct {
level int
good int
lazy int
nice int
chain int
fastSkipHashing int
}</code></pre>
            </article>
            
            <article class="struct" data-name="compressor">
               <h3>
                  compressor
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type compressor struct {
compressionLevel
w *huffmanBitWriter
bulkHasher func([]byte, []uint32)
fill func(*compressor, []byte) int
step func(*compressor)
bestSpeed *deflateFast
chainHead int
hashHead [hashSize]uint32
hashPrev [windowSize]uint32
hashOffset int
index int
window []byte
windowEnd int
blockStart int
byteAvailable bool
sync bool
tokens []token
length int
offset int
maxInsertIndex int
err error
hashMatch [*ast.BinaryExpr]uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="decompressor">
               <h3>
                  decompressor
                  <span class="badge">struct</span>
               </h3>
               
               <p>Decompress state.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type decompressor struct {
r Reader
rBuf *bufio.Reader
roffset int64
b uint32
nb uint
h1 huffmanDecoder
h2 huffmanDecoder
bits *[*ast.BinaryExpr]int
codebits *[numCodes]int
dict dictDecoder
buf [4]byte
step func(*decompressor)
stepState int
final bool
err error
toRead []byte
hl *huffmanDecoder
hd *huffmanDecoder
copyLen int
copyDist int
}</code></pre>
            </article>
            
            <article class="struct" data-name="deflateFast">
               <h3>
                  deflateFast
                  <span class="badge">struct</span>
               </h3>
               
               <p>deflateFast maintains the table for matches,
and the previous byte block for cross block matching.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type deflateFast struct {
table [tableSize]tableEntry
prev []byte
cur int32
}</code></pre>
            </article>
            
            <article class="struct" data-name="dictDecoder">
               <h3>
                  dictDecoder
                  <span class="badge">struct</span>
               </h3>
               
               <p>dictDecoder implements the LZ77 sliding dictionary as used in decompression.
LZ77 decompresses data through sequences of two forms of commands:
- Literal insertions: Runs of one or more symbols are inserted into the data
stream as is. This is accomplished through the writeByte method for a
single symbol, or combinations of writeSlice/writeMark for multiple symbols.
Any valid stream must start with a literal insertion if no preset dictionary
is used.
- Backward copies: Runs of one or more symbols are copied from previously
emitted data. Backward copies come as the tuple (dist, length) where dist
determines how far back in the stream to copy from and length determines how
many bytes to copy. Note that it is valid for the length to be greater than
the distance. Since LZ77 uses forward copies, that situation is used to
perform a form of run-length encoding on repeated runs of symbols.
The writeCopy and tryWriteCopy are used to implement this command.
For performance reasons, this implementation performs little to no sanity
checks about the arguments. As such, the invariants documented for each
method call must be respected.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dictDecoder struct {
hist []byte
wrPos int
rdPos int
full bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="dictWriter">
               <h3>
                  dictWriter
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dictWriter struct {
w io.Writer
}</code></pre>
            </article>
            
            <article class="struct" data-name="hcode">
               <h3>
                  hcode
                  <span class="badge">struct</span>
               </h3>
               
               <p>hcode is a huffman code with a bit code and bit length.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type hcode struct {
code uint16
len uint16
}</code></pre>
            </article>
            
            <article class="struct" data-name="huffmanBitWriter">
               <h3>
                  huffmanBitWriter
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type huffmanBitWriter struct {
writer io.Writer
bits uint64
nbits uint
bytes [bufferSize]byte
codegenFreq [codegenCodeCount]int32
nbytes int
literalFreq []int32
offsetFreq []int32
codegen []uint8
literalEncoding *huffmanEncoder
offsetEncoding *huffmanEncoder
codegenEncoding *huffmanEncoder
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="huffmanDecoder">
               <h3>
                  huffmanDecoder
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type huffmanDecoder struct {
min int
chunks [huffmanNumChunks]uint32
links [][]uint32
linkMask uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="huffmanEncoder">
               <h3>
                  huffmanEncoder
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type huffmanEncoder struct {
codes []hcode
freqcache []literalNode
bitCount [17]int32
lns byLiteral
lfs byFreq
}</code></pre>
            </article>
            
            <article class="struct" data-name="levelInfo">
               <h3>
                  levelInfo
                  <span class="badge">struct</span>
               </h3>
               
               <p>A levelInfo describes the state of the constructed tree for a given depth.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type levelInfo struct {
level int32
lastFreq int32
nextCharFreq int32
nextPairFreq int32
needed int32
}</code></pre>
            </article>
            
            <article class="struct" data-name="literalNode">
               <h3>
                  literalNode
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type literalNode struct {
literal uint16
freq int32
}</code></pre>
            </article>
            
            <article class="struct" data-name="tableEntry">
               <h3>
                  tableEntry
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type tableEntry struct {
val uint32
offset int32
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close flushes and closes the writer.</p>
               
               <pre><code>func (w *Writer) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *decompressor) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e CorruptInputError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ReadError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e InternalError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *WriteError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Flush">
               <h3>
                  Flush 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Flush flushes any pending data to the underlying writer.
It is useful mainly in compressed network protocols, to ensure that
a remote reader has enough data to reconstruct a packet.
Flush does not return until the data has been written.
Calling Flush when there is no pending data still causes the [Writer]
to emit a sync marker of at least 4 bytes.
If the underlying writer returns an error, Flush returns that error.
In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH.</p>
               
               <pre><code>func (w *Writer) Flush() error</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s byFreq) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s byLiteral) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s byLiteral) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s byFreq) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="NewReader">
               <h3>
                  NewReader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewReader returns a new ReadCloser that can be used
to read the uncompressed version of r.
If r does not also implement [io.ByteReader],
the decompressor may read more data than necessary from r.
The reader returns [io.EOF] after the final block in the DEFLATE stream has
been encountered. Any trailing data after the final block is ignored.
The [io.ReadCloser] returned by NewReader also implements [Resetter].</p>
               
               <pre><code>func NewReader(r io.Reader) io.ReadCloser</code></pre>
            </article>
            
            <article class="function" data-name="NewReaderDict">
               <h3>
                  NewReaderDict 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewReaderDict is like [NewReader] but initializes the reader
with a preset dictionary. The returned [Reader] behaves as if
the uncompressed data stream started with the given dictionary,
which has already been read. NewReaderDict is typically used
to read data compressed by NewWriterDict.
The ReadCloser returned by NewReaderDict also implements [Resetter].</p>
               
               <pre><code>func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser</code></pre>
            </article>
            
            <article class="function" data-name="NewWriter">
               <h3>
                  NewWriter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewWriter returns a new [Writer] compressing data at the given level.
Following zlib, levels range from 1 ([BestSpeed]) to 9 ([BestCompression]);
higher levels typically run slower but compress more. Level 0
([NoCompression]) does not attempt any compression; it only adds the
necessary DEFLATE framing.
Level -1 ([DefaultCompression]) uses the default compression level.
Level -2 ([HuffmanOnly]) will use Huffman compression only, giving
a very fast compression for all types of input, but sacrificing considerable
compression efficiency.
If level is in the range [-2, 9] then the error returned will be nil.
Otherwise the error returned will be non-nil.</p>
               
               <pre><code>func NewWriter(w io.Writer, level int) (*Writer, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewWriterDict">
               <h3>
                  NewWriterDict 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewWriterDict is like [NewWriter] but initializes the new
[Writer] with a preset dictionary. The returned [Writer] behaves
as if the dictionary had been written to it without producing
any compressed output. The compressed data written to w
can only be decompressed by a [Reader] initialized with the
same dictionary.</p>
               
               <pre><code>func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *decompressor) Read(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *decompressor) Reset(r io.Reader, dict []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reset discards the writer's state and makes it equivalent to
the result of [NewWriter] or [NewWriterDict] called with dst
and w's level and dictionary.</p>
               
               <pre><code>func (w *Writer) Reset(dst io.Writer)</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s byFreq) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s byLiteral) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *dictWriter) Write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write writes data to w, which will eventually write the
compressed form of data to its underlying writer.</p>
               
               <pre><code>func (w *Writer) Write(data []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="assignEncodingAndSize">
               <h3>
                  assignEncodingAndSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Look at the leaves and assign them a bit count and an encoding as specified
in RFC 1951 3.2.2</p>
               
               <pre><code>func (h *huffmanEncoder) assignEncodingAndSize(bitCount []int32, list []literalNode)</code></pre>
            </article>
            
            <article class="function" data-name="availRead">
               <h3>
                  availRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>availRead reports the number of bytes that can be flushed by readFlush.</p>
               
               <pre><code>func (dd *dictDecoder) availRead() int</code></pre>
            </article>
            
            <article class="function" data-name="availWrite">
               <h3>
                  availWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>availWrite reports the available amount of output buffer space.</p>
               
               <pre><code>func (dd *dictDecoder) availWrite() int</code></pre>
            </article>
            
            <article class="function" data-name="bitCounts">
               <h3>
                  bitCounts 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>bitCounts computes the number of literals assigned to each bit size in the Huffman encoding.
It is only called when list.length >= 3.
The cases of 0, 1, and 2 literals are handled by special case code.
list is an array of the literals with non-zero frequencies
and their associated frequencies. The array is in order of increasing
frequency and has as its last element a special element with frequency
MaxInt32.
maxBits is the maximum number of bits that should be used to encode any literal.
It must be less than 16.
bitCounts returns an integer slice in which slice[i] indicates the number of literals
that should be encoded in i bits.</p>
               
               <pre><code>func (h *huffmanEncoder) bitCounts(list []literalNode, maxBits int32) []int32</code></pre>
            </article>
            
            <article class="function" data-name="bitLength">
               <h3>
                  bitLength 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *huffmanEncoder) bitLength(freq []int32) int</code></pre>
            </article>
            
            <article class="function" data-name="bulkHash4">
               <h3>
                  bulkHash4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>bulkHash4 will compute hashes using the same
algorithm as hash4.</p>
               
               <pre><code>func bulkHash4(b []byte, dst []uint32)</code></pre>
            </article>
            
            <article class="function" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *compressor) close() error</code></pre>
            </article>
            
            <article class="function" data-name="copyData">
               <h3>
                  copyData 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>copyData copies f.copyLen bytes from the underlying reader into f.hist.
It pauses for reads when f.hist is full.</p>
               
               <pre><code>func (f *decompressor) copyData()</code></pre>
            </article>
            
            <article class="function" data-name="dataBlock">
               <h3>
                  dataBlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Copy a single uncompressed data block from input to output.</p>
               
               <pre><code>func (f *decompressor) dataBlock()</code></pre>
            </article>
            
            <article class="function" data-name="deflate">
               <h3>
                  deflate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *compressor) deflate()</code></pre>
            </article>
            
            <article class="function" data-name="dynamicSize">
               <h3>
                  dynamicSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>dynamicSize returns the size of dynamically encoded data in bits.</p>
               
               <pre><code>func (w *huffmanBitWriter) dynamicSize(litEnc *huffmanEncoder, offEnc *huffmanEncoder, extraBits int) (size int, numCodegens int)</code></pre>
            </article>
            
            <article class="function" data-name="emitLiteral">
               <h3>
                  emitLiteral 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func emitLiteral(dst []token, lit []byte) []token</code></pre>
            </article>
            
            <article class="function" data-name="encSpeed">
               <h3>
                  encSpeed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>encSpeed will compress and store the currently added data,
if enough has been accumulated or we at the end of the stream.
Any error that occurred will be in d.err</p>
               
               <pre><code>func (d *compressor) encSpeed()</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>encode encodes a block given in src and appends tokens
to dst and returns the result.</p>
               
               <pre><code>func (e *deflateFast) encode(dst []token, src []byte) []token</code></pre>
            </article>
            
            <article class="function" data-name="fillDeflate">
               <h3>
                  fillDeflate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *compressor) fillDeflate(b []byte) int</code></pre>
            </article>
            
            <article class="function" data-name="fillStore">
               <h3>
                  fillStore 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *compressor) fillStore(b []byte) int</code></pre>
            </article>
            
            <article class="function" data-name="fillWindow">
               <h3>
                  fillWindow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fillWindow will fill the current window with the supplied
dictionary and calculate all hashes.
This is much faster than doing a full encode.
Should only be used after a reset.</p>
               
               <pre><code>func (d *compressor) fillWindow(b []byte)</code></pre>
            </article>
            
            <article class="function" data-name="findMatch">
               <h3>
                  findMatch 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Try to find a match starting at index whose length is greater than prevSize.
We only look at chainCount possibilities before giving up.</p>
               
               <pre><code>func (d *compressor) findMatch(pos int, prevHead int, prevLength int, lookahead int) (length int, offset int, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="finishBlock">
               <h3>
                  finishBlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *decompressor) finishBlock()</code></pre>
            </article>
            
            <article class="function" data-name="fixedHuffmanDecoderInit">
               <h3>
                  fixedHuffmanDecoderInit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fixedHuffmanDecoderInit()</code></pre>
            </article>
            
            <article class="function" data-name="fixedSize">
               <h3>
                  fixedSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fixedSize returns the size of dynamically encoded data in bits.</p>
               
               <pre><code>func (w *huffmanBitWriter) fixedSize(extraBits int) int</code></pre>
            </article>
            
            <article class="function" data-name="flush">
               <h3>
                  flush 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *huffmanBitWriter) flush()</code></pre>
            </article>
            
            <article class="function" data-name="generate">
               <h3>
                  generate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Update this Huffman Code object to be the minimum code for the specified frequency count.
freq is an array of frequencies, in which freq[i] gives the frequency of literal i.
maxBits  The maximum number of bits to use for any literal.</p>
               
               <pre><code>func (h *huffmanEncoder) generate(freq []int32, maxBits int32)</code></pre>
            </article>
            
            <article class="function" data-name="generateCodegen">
               <h3>
                  generateCodegen 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RFC 1951 3.2.7 specifies a special run-length encoding for specifying
the literal and offset lengths arrays (which are concatenated into a single
array).  This method generates that run-length encoding.
The result is written into the codegen array, and the frequencies
of each code is written into the codegenFreq array.
Codes 0-15 are single byte codes. Codes 16-18 are followed by additional
information. Code badCode is an end marker
numLiterals      The number of literals in literalEncoding
numOffsets       The number of offsets in offsetEncoding
litenc, offenc   The literal and offset encoder to use</p>
               
               <pre><code>func (w *huffmanBitWriter) generateCodegen(numLiterals int, numOffsets int, litEnc *huffmanEncoder, offEnc *huffmanEncoder)</code></pre>
            </article>
            
            <article class="function" data-name="generateFixedLiteralEncoding">
               <h3>
                  generateFixedLiteralEncoding 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Generates a HuffmanCode corresponding to the fixed literal table.</p>
               
               <pre><code>func generateFixedLiteralEncoding() *huffmanEncoder</code></pre>
            </article>
            
            <article class="function" data-name="generateFixedOffsetEncoding">
               <h3>
                  generateFixedOffsetEncoding 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func generateFixedOffsetEncoding() *huffmanEncoder</code></pre>
            </article>
            
            <article class="function" data-name="hash">
               <h3>
                  hash 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func hash(u uint32) uint32</code></pre>
            </article>
            
            <article class="function" data-name="hash4">
               <h3>
                  hash4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hash4 returns a hash representation of the first 4 bytes
of the supplied slice.
The caller must ensure that len(b) >= 4.</p>
               
               <pre><code>func hash4(b []byte) uint32</code></pre>
            </article>
            
            <article class="function" data-name="histSize">
               <h3>
                  histSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>histSize reports the total amount of historical data in the dictionary.</p>
               
               <pre><code>func (dd *dictDecoder) histSize() int</code></pre>
            </article>
            
            <article class="function" data-name="histogram">
               <h3>
                  histogram 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>histogram accumulates a histogram of b in h.
len(h) must be >= 256, and h's elements must be all zeroes.</p>
               
               <pre><code>func histogram(b []byte, h []int32)</code></pre>
            </article>
            
            <article class="function" data-name="huffSym">
               <h3>
                  huffSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Read the next Huffman-encoded symbol from f according to h.</p>
               
               <pre><code>func (f *decompressor) huffSym(h *huffmanDecoder) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="huffmanBlock">
               <h3>
                  huffmanBlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Decode a single Huffman block from f.
hl and hd are the Huffman states for the lit/length values
and the distance values, respectively. If hd == nil, using the
fixed distance encoding associated with fixed Huffman blocks.</p>
               
               <pre><code>func (f *decompressor) huffmanBlock()</code></pre>
            </article>
            
            <article class="function" data-name="indexTokens">
               <h3>
                  indexTokens 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>indexTokens indexes a slice of tokens, and updates
literalFreq and offsetFreq, and generates literalEncoding
and offsetEncoding.
The number of literal and offset tokens is returned.</p>
               
               <pre><code>func (w *huffmanBitWriter) indexTokens(tokens []token) (numLiterals int, numOffsets int)</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>init initializes dictDecoder to have a sliding window dictionary of the given
size. If a preset dict is provided, it will initialize the dictionary with
the contents of dict.</p>
               
               <pre><code>func (dd *dictDecoder) init(size int, dict []byte)</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *compressor) init(w io.Writer, level int) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Initialize Huffman decoding tables from array of code lengths.
Following this function, h is guaranteed to be initialized into a complete
tree (i.e., neither over-subscribed nor under-subscribed). The exception is a
degenerate case where the tree has only a single symbol with length 1. Empty
trees are permitted.</p>
               
               <pre><code>func (h *huffmanDecoder) init(lengths []int) bool</code></pre>
            </article>
            
            <article class="function" data-name="initDeflate">
               <h3>
                  initDeflate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *compressor) initDeflate()</code></pre>
            </article>
            
            <article class="function" data-name="length">
               <h3>
                  length 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t token) length() uint32</code></pre>
            </article>
            
            <article class="function" data-name="lengthCode">
               <h3>
                  lengthCode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func lengthCode(len uint32) uint32</code></pre>
            </article>
            
            <article class="function" data-name="literal">
               <h3>
                  literal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns the literal of a literal token.</p>
               
               <pre><code>func (t token) literal() uint32</code></pre>
            </article>
            
            <article class="function" data-name="literalToken">
               <h3>
                  literalToken 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Convert a literal into a literal token.</p>
               
               <pre><code>func literalToken(literal uint32) token</code></pre>
            </article>
            
            <article class="function" data-name="load32">
               <h3>
                  load32 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func load32(b []byte, i int32) uint32</code></pre>
            </article>
            
            <article class="function" data-name="load64">
               <h3>
                  load64 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func load64(b []byte, i int32) uint64</code></pre>
            </article>
            
            <article class="function" data-name="makeReader">
               <h3>
                  makeReader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *decompressor) makeReader(r io.Reader)</code></pre>
            </article>
            
            <article class="function" data-name="matchLen">
               <h3>
                  matchLen 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>matchLen returns the number of matching bytes in a and b
up to length 'max'. Both slices must be at least 'max'
bytes in size.</p>
               
               <pre><code>func matchLen(a []byte, b []byte, max int) int</code></pre>
            </article>
            
            <article class="function" data-name="matchLen">
               <h3>
                  matchLen 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>matchLen returns the match length between src[s:] and src[t:].
t can be negative to indicate the match is starting in e.prev.
We assume that src[s-4:s] and src[t-4:t] already match.</p>
               
               <pre><code>func (e *deflateFast) matchLen(s int32, t int32, src []byte) int32</code></pre>
            </article>
            
            <article class="function" data-name="matchToken">
               <h3>
                  matchToken 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Convert a < xlength, xoffset > pair into a match token.</p>
               
               <pre><code>func matchToken(xlength uint32, xoffset uint32) token</code></pre>
            </article>
            
            <article class="function" data-name="maxNode">
               <h3>
                  maxNode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func maxNode() literalNode</code></pre>
            </article>
            
            <article class="function" data-name="moreBits">
               <h3>
                  moreBits 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *decompressor) moreBits() error</code></pre>
            </article>
            
            <article class="function" data-name="newDeflateFast">
               <h3>
                  newDeflateFast 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newDeflateFast() *deflateFast</code></pre>
            </article>
            
            <article class="function" data-name="newHuffmanBitWriter">
               <h3>
                  newHuffmanBitWriter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newHuffmanBitWriter(w io.Writer) *huffmanBitWriter</code></pre>
            </article>
            
            <article class="function" data-name="newHuffmanEncoder">
               <h3>
                  newHuffmanEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newHuffmanEncoder(size int) *huffmanEncoder</code></pre>
            </article>
            
            <article class="function" data-name="nextBlock">
               <h3>
                  nextBlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *decompressor) nextBlock()</code></pre>
            </article>
            
            <article class="function" data-name="noEOF">
               <h3>
                  noEOF 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>noEOF returns err, unless err == io.EOF, in which case it returns io.ErrUnexpectedEOF.</p>
               
               <pre><code>func noEOF(e error) error</code></pre>
            </article>
            
            <article class="function" data-name="offset">
               <h3>
                  offset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Returns the extra offset of a match token.</p>
               
               <pre><code>func (t token) offset() uint32</code></pre>
            </article>
            
            <article class="function" data-name="offsetCode">
               <h3>
                  offsetCode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Returns the offset code corresponding to a specific offset.</p>
               
               <pre><code>func offsetCode(off uint32) uint32</code></pre>
            </article>
            
            <article class="function" data-name="readFlush">
               <h3>
                  readFlush 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>readFlush returns a slice of the historical buffer that is ready to be
emitted to the user. The data returned by readFlush must be fully consumed
before calling any other dictDecoder methods.</p>
               
               <pre><code>func (dd *dictDecoder) readFlush() []byte</code></pre>
            </article>
            
            <article class="function" data-name="readHuffman">
               <h3>
                  readHuffman 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *decompressor) readHuffman() error</code></pre>
            </article>
            
            <article class="function" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reset resets the encoding history.
This ensures that no matches are made to the previous block.</p>
               
               <pre><code>func (e *deflateFast) reset()</code></pre>
            </article>
            
            <article class="function" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *huffmanBitWriter) reset(writer io.Writer)</code></pre>
            </article>
            
            <article class="function" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *compressor) reset(w io.Writer)</code></pre>
            </article>
            
            <article class="function" data-name="reverseBits">
               <h3>
                  reverseBits 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func reverseBits(number uint16, bitLength byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>set sets the code and length of an hcode.</p>
               
               <pre><code>func (h *hcode) set(code uint16, length uint16)</code></pre>
            </article>
            
            <article class="function" data-name="shiftOffsets">
               <h3>
                  shiftOffsets 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>shiftOffsets will shift down all match offset.
This is only called in rare situations to prevent integer overflow.
See https://golang.org/issue/18636 and https://github.com/golang/go/issues/34121.</p>
               
               <pre><code>func (e *deflateFast) shiftOffsets()</code></pre>
            </article>
            
            <article class="function" data-name="sort">
               <h3>
                  sort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *byLiteral) sort(a []literalNode)</code></pre>
            </article>
            
            <article class="function" data-name="sort">
               <h3>
                  sort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *byFreq) sort(a []literalNode)</code></pre>
            </article>
            
            <article class="function" data-name="store">
               <h3>
                  store 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *compressor) store()</code></pre>
            </article>
            
            <article class="function" data-name="storeHuff">
               <h3>
                  storeHuff 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>storeHuff compresses and stores the currently added data
when the d.window is full or we are at the end of the stream.
Any error that occurred will be in d.err</p>
               
               <pre><code>func (d *compressor) storeHuff()</code></pre>
            </article>
            
            <article class="function" data-name="storedSize">
               <h3>
                  storedSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>storedSize calculates the stored size, including header.
The function returns the size in bits and whether the block
fits inside a single block.</p>
               
               <pre><code>func (w *huffmanBitWriter) storedSize(in []byte) (int, bool)</code></pre>
            </article>
            
            <article class="function" data-name="syncFlush">
               <h3>
                  syncFlush 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *compressor) syncFlush() error</code></pre>
            </article>
            
            <article class="function" data-name="tryWriteCopy">
               <h3>
                  tryWriteCopy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>tryWriteCopy tries to copy a string at a given (distance, length) to the
output. This specialized version is optimized for short distances.
This method is designed to be inlined for performance reasons.
This invariant must be kept: 0 < dist <= histSize()</p>
               
               <pre><code>func (dd *dictDecoder) tryWriteCopy(dist int, length int) int</code></pre>
            </article>
            
            <article class="function" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *compressor) write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *huffmanBitWriter) write(b []byte)</code></pre>
            </article>
            
            <article class="function" data-name="writeBits">
               <h3>
                  writeBits 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *huffmanBitWriter) writeBits(b int32, nb uint)</code></pre>
            </article>
            
            <article class="function" data-name="writeBlock">
               <h3>
                  writeBlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *compressor) writeBlock(tokens []token, index int) error</code></pre>
            </article>
            
            <article class="function" data-name="writeBlock">
               <h3>
                  writeBlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeBlock will write a block of tokens with the smallest encoding.
The original input can be supplied, and if the huffman encoded data
is larger than the original bytes, the data will be written as a
stored block.
If the input is nil, the tokens will always be Huffman encoded.</p>
               
               <pre><code>func (w *huffmanBitWriter) writeBlock(tokens []token, eof bool, input []byte)</code></pre>
            </article>
            
            <article class="function" data-name="writeBlockDynamic">
               <h3>
                  writeBlockDynamic 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeBlockDynamic encodes a block using a dynamic Huffman table.
This should be used if the symbols used have a disproportionate
histogram distribution.
If input is supplied and the compression savings are below 1/16th of the
input size the block is stored.</p>
               
               <pre><code>func (w *huffmanBitWriter) writeBlockDynamic(tokens []token, eof bool, input []byte)</code></pre>
            </article>
            
            <article class="function" data-name="writeBlockHuff">
               <h3>
                  writeBlockHuff 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeBlockHuff encodes a block of bytes as either
Huffman encoded literals or uncompressed bytes if the
results only gains very little from compression.</p>
               
               <pre><code>func (w *huffmanBitWriter) writeBlockHuff(eof bool, input []byte)</code></pre>
            </article>
            
            <article class="function" data-name="writeByte">
               <h3>
                  writeByte 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeByte writes a single byte to the dictionary.
This invariant must be kept: 0 < availWrite()</p>
               
               <pre><code>func (dd *dictDecoder) writeByte(c byte)</code></pre>
            </article>
            
            <article class="function" data-name="writeBytes">
               <h3>
                  writeBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *huffmanBitWriter) writeBytes(bytes []byte)</code></pre>
            </article>
            
            <article class="function" data-name="writeCode">
               <h3>
                  writeCode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *huffmanBitWriter) writeCode(c hcode)</code></pre>
            </article>
            
            <article class="function" data-name="writeCopy">
               <h3>
                  writeCopy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeCopy copies a string at a given (dist, length) to the output.
This returns the number of bytes copied and may be less than the requested
length if the available space in the output buffer is too small.
This invariant must be kept: 0 < dist <= histSize()</p>
               
               <pre><code>func (dd *dictDecoder) writeCopy(dist int, length int) int</code></pre>
            </article>
            
            <article class="function" data-name="writeDynamicHeader">
               <h3>
                  writeDynamicHeader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write the header of a dynamic Huffman block to the output stream.
numLiterals  The number of literals specified in codegen
numOffsets   The number of offsets specified in codegen
numCodegens  The number of codegens used in codegen</p>
               
               <pre><code>func (w *huffmanBitWriter) writeDynamicHeader(numLiterals int, numOffsets int, numCodegens int, isEof bool)</code></pre>
            </article>
            
            <article class="function" data-name="writeFixedHeader">
               <h3>
                  writeFixedHeader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *huffmanBitWriter) writeFixedHeader(isEof bool)</code></pre>
            </article>
            
            <article class="function" data-name="writeMark">
               <h3>
                  writeMark 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeMark advances the writer pointer by cnt.
This invariant must be kept: 0 <= cnt <= availWrite()</p>
               
               <pre><code>func (dd *dictDecoder) writeMark(cnt int)</code></pre>
            </article>
            
            <article class="function" data-name="writeSlice">
               <h3>
                  writeSlice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeSlice returns a slice of the available buffer to write data to.
This invariant will be kept: len(s) <= availWrite()</p>
               
               <pre><code>func (dd *dictDecoder) writeSlice() []byte</code></pre>
            </article>
            
            <article class="function" data-name="writeStoredBlock">
               <h3>
                  writeStoredBlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *compressor) writeStoredBlock(buf []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="writeStoredHeader">
               <h3>
                  writeStoredHeader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *huffmanBitWriter) writeStoredHeader(length int, isEof bool)</code></pre>
            </article>
            
            <article class="function" data-name="writeTokens">
               <h3>
                  writeTokens 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeTokens writes a slice of tokens to the output.
codes for literal and offset encoding must be supplied.</p>
               
               <pre><code>func (w *huffmanBitWriter) writeTokens(tokens []token, leCodes []hcode, oeCodes []hcode)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
