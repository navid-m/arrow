<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - elliptic</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                 
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>elliptic</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"crypto/internal/fips140/nistec"
"errors"
"math/big"
"crypto/internal/fips140/nistec"
"math/big"
"math/big"
"io"
"math/big"
"sync"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <p>Assert that the known curves implement unmarshaler.</p>
               
               <pre><code>var _ = []unmarshaler{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initonce" data-name="initonce">
               <h3>
                  initonce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#initonce" class="anchor" title="Link to initonce">#</a>
               </h3>
               
               <pre><code>var initonce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mask" data-name="mask">
               <h3>
                  mask 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#mask" class="anchor" title="Link to mask">#</a>
               </h3>
               
               <pre><code>var mask = []byte{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p224" data-name="p224">
               <h3>
                  p224 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p224" class="anchor" title="Link to p224">#</a>
               </h3>
               
               <pre><code>var p224 = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p256" data-name="p256">
               <h3>
                  p256 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p256" class="anchor" title="Link to p256">#</a>
               </h3>
               
               <pre><code>var p256 = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p384" data-name="p384">
               <h3>
                  p384 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p384" class="anchor" title="Link to p384">#</a>
               </h3>
               
               <pre><code>var p384 = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p521" data-name="p521">
               <h3>
                  p521 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p521" class="anchor" title="Link to p521">#</a>
               </h3>
               
               <pre><code>var p521 = *ast.UnaryExpr</code></pre>
            </article>
            
         </section>
           
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Curve" data-name="Curve">
               <h3>
                  Curve
                  <span class="badge interface-badge">interface</span>
                  <a href="#Curve" class="anchor" title="Link to Curve">#</a>
               </h3>
               
               <p>A Curve represents a short-form Weierstrass curve with a=-3.
The behavior of Add, Double, and ScalarMult when the input is not a point on
the curve is undefined.
Note that the conventional point at infinity (0, 0) is not considered on the
curve, although it can be returned by Add, Double, ScalarMult, or
ScalarBaseMult (but not the [Unmarshal] or [UnmarshalCompressed] functions).
Using Curve implementations besides those returned by [P224], [P256], [P384],
and [P521] is deprecated.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Curve interface {
Params() *CurveParams
IsOnCurve(x *big.Int, y *big.Int) bool
Add(x1 *big.Int, y1 *big.Int, x2 *big.Int, y2 *big.Int) (x *big.Int, y *big.Int)
Double(x1 *big.Int, y1 *big.Int) (x *big.Int, y *big.Int)
ScalarMult(x1 *big.Int, y1 *big.Int, k []byte) (x *big.Int, y *big.Int)
ScalarBaseMult(k []byte) (x *big.Int, y *big.Int)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="nistPoint" data-name="nistPoint">
               <h3>
                  nistPoint
                  <span class="badge interface-badge">interface</span>
                  <a href="#nistPoint" class="anchor" title="Link to nistPoint">#</a>
               </h3>
               
               <p>nistPoint is a generic constraint for the nistec Point types.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type nistPoint interface {
Bytes() []byte
SetBytes([]byte) (T, error)
Add(T, T) T
Double(T) T
ScalarMult(T, []byte) (T, error)
ScalarBaseMult([]byte) (T, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="unmarshaler" data-name="unmarshaler">
               <h3>
                  unmarshaler
                  <span class="badge interface-badge">interface</span>
                  <a href="#unmarshaler" class="anchor" title="Link to unmarshaler">#</a>
               </h3>
               
               <p>unmarshaler is implemented by curves with their own constant-time Unmarshal.
There isn't an equivalent interface for Marshal/MarshalCompressed because
that doesn't involve any mathematical operations, only FillBytes and Bit.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type unmarshaler interface {
Unmarshal([]byte) (x *big.Int, y *big.Int)
UnmarshalCompressed([]byte) (x *big.Int, y *big.Int)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="CurveParams" data-name="CurveParams">
               <h3>
                  CurveParams
                  <span class="badge">struct</span>
                  <a href="#CurveParams" class="anchor" title="Link to CurveParams">#</a>
               </h3>
               
               <p>CurveParams contains the parameters of an elliptic curve and also provides
a generic, non-constant time implementation of [Curve].
The generic Curve implementation is deprecated, and using custom curves
(those not returned by [P224], [P256], [P384], and [P521]) is not guaranteed
to provide any security property.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CurveParams struct {
P *big.Int
N *big.Int
B *big.Int
Gx *big.Int
Gy *big.Int
BitSize int
Name string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="nistCurve" data-name="nistCurve">
               <h3>
                  nistCurve
                  <span class="badge">struct</span>
                  <a href="#nistCurve" class="anchor" title="Link to nistCurve">#</a>
               </h3>
               
               <p>nistCurve is a Curve implementation based on a nistec Point.
It's a wrapper that exposes the big.Int-based Curve interface and encodes the
legacy idiosyncrasies it requires, such as invalid and infinity point
handling.
To interact with the nistec package, points are encoded into and decoded from
properly formatted byte slices. All big.Int use is limited to this package.
Encoding and decoding is 1/1000th of the runtime of a scalar multiplication,
so the overhead is acceptable.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nistCurve struct {
newPoint func() Point
params *CurveParams
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="p256Curve" data-name="p256Curve">
               <h3>
                  p256Curve
                  <span class="badge">struct</span>
                  <a href="#p256Curve" class="anchor" title="Link to p256Curve">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type p256Curve struct {
*ast.IndexExpr
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <pre><code>func (curve **ast.IndexExpr) Add(x1 *big.Int, y1 *big.Int, x2 *big.Int, y2 *big.Int) (*big.Int, *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add implements [Curve.Add].
Deprecated: the [CurveParams] methods are deprecated and are not guaranteed to
provide any security property. For ECDH, use the [crypto/ecdh] package.
For ECDSA, use the [crypto/ecdsa] package with a [Curve] value returned directly
from [P224], [P256], [P384], or [P521].</p>
               
               <pre><code>func (curve *CurveParams) Add(x1 *big.Int, y1 *big.Int, x2 *big.Int, y2 *big.Int) (*big.Int, *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CombinedMult" data-name="CombinedMult">
               <h3>
                  CombinedMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CombinedMult" class="anchor" title="Link to CombinedMult">#</a>
               </h3>
               
               <p>CombinedMult returns [s1]G + [s2]P where G is the generator. It's used
through an interface upgrade in crypto/ecdsa.</p>
               
               <pre><code>func (curve **ast.IndexExpr) CombinedMult(Px *big.Int, Py *big.Int, s1 []byte, s2 []byte) (x *big.Int, y *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Double" data-name="Double">
               <h3>
                  Double 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Double" class="anchor" title="Link to Double">#</a>
               </h3>
               
               <p>Double implements [Curve.Double].
Deprecated: the [CurveParams] methods are deprecated and are not guaranteed to
provide any security property. For ECDH, use the [crypto/ecdh] package.
For ECDSA, use the [crypto/ecdsa] package with a [Curve] value returned directly
from [P224], [P256], [P384], or [P521].</p>
               
               <pre><code>func (curve *CurveParams) Double(x1 *big.Int, y1 *big.Int) (*big.Int, *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Double" data-name="Double">
               <h3>
                  Double 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Double" class="anchor" title="Link to Double">#</a>
               </h3>
               
               <pre><code>func (curve **ast.IndexExpr) Double(x1 *big.Int, y1 *big.Int) (*big.Int, *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GenerateKey" data-name="GenerateKey">
               <h3>
                  GenerateKey 
                  <span class="badge">function</span>
                  
                  <a href="#GenerateKey" class="anchor" title="Link to GenerateKey">#</a>
               </h3>
               
               <p>GenerateKey returns a public/private key pair. The private key is
generated using the given reader, which must return random data.
Deprecated: for ECDH, use the GenerateKey methods of the [crypto/ecdh] package;
for ECDSA, use the GenerateKey function of the crypto/ecdsa package.</p>
               
               <pre><code>func GenerateKey(curve Curve, rand io.Reader) (priv []byte, x *big.Int, y *big.Int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Inverse" data-name="Inverse">
               <h3>
                  Inverse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Inverse" class="anchor" title="Link to Inverse">#</a>
               </h3>
               
               <pre><code>func (c p256Curve) Inverse(k *big.Int) *big.Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsOnCurve" data-name="IsOnCurve">
               <h3>
                  IsOnCurve 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsOnCurve" class="anchor" title="Link to IsOnCurve">#</a>
               </h3>
               
               <pre><code>func (curve **ast.IndexExpr) IsOnCurve(x *big.Int, y *big.Int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsOnCurve" data-name="IsOnCurve">
               <h3>
                  IsOnCurve 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsOnCurve" class="anchor" title="Link to IsOnCurve">#</a>
               </h3>
               
               <p>IsOnCurve implements [Curve.IsOnCurve].
Deprecated: the [CurveParams] methods are deprecated and are not guaranteed to
provide any security property. For ECDH, use the [crypto/ecdh] package.
For ECDSA, use the [crypto/ecdsa] package with a [Curve] value returned directly
from [P224], [P256], [P384], or [P521].</p>
               
               <pre><code>func (curve *CurveParams) IsOnCurve(x *big.Int, y *big.Int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Marshal" data-name="Marshal">
               <h3>
                  Marshal 
                  <span class="badge">function</span>
                  
                  <a href="#Marshal" class="anchor" title="Link to Marshal">#</a>
               </h3>
               
               <p>Marshal converts a point on the curve into the uncompressed form specified in
SEC 1, Version 2.0, Section 2.3.3. If the point is not on the curve (or is
the conventional point at infinity), the behavior is undefined.
Deprecated: for ECDH, use the crypto/ecdh package. This function returns an
encoding equivalent to that of PublicKey.Bytes in crypto/ecdh.</p>
               
               <pre><code>func Marshal(curve Curve, x *big.Int, y *big.Int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalCompressed" data-name="MarshalCompressed">
               <h3>
                  MarshalCompressed 
                  <span class="badge">function</span>
                  
                  <a href="#MarshalCompressed" class="anchor" title="Link to MarshalCompressed">#</a>
               </h3>
               
               <p>MarshalCompressed converts a point on the curve into the compressed form
specified in SEC 1, Version 2.0, Section 2.3.3. If the point is not on the
curve (or is the conventional point at infinity), the behavior is undefined.</p>
               
               <pre><code>func MarshalCompressed(curve Curve, x *big.Int, y *big.Int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="P224" data-name="P224">
               <h3>
                  P224 
                  <span class="badge">function</span>
                  
                  <a href="#P224" class="anchor" title="Link to P224">#</a>
               </h3>
               
               <p>P224 returns a [Curve] which implements NIST P-224 (FIPS 186-3, section D.2.2),
also known as secp224r1. The CurveParams.Name of this [Curve] is "P-224".
Multiple invocations of this function will return the same value, so it can
be used for equality checks and switch statements.
The cryptographic operations are implemented using constant-time algorithms.</p>
               
               <pre><code>func P224() Curve</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="P256" data-name="P256">
               <h3>
                  P256 
                  <span class="badge">function</span>
                  
                  <a href="#P256" class="anchor" title="Link to P256">#</a>
               </h3>
               
               <p>P256 returns a [Curve] which implements NIST P-256 (FIPS 186-3, section D.2.3),
also known as secp256r1 or prime256v1. The CurveParams.Name of this [Curve] is
"P-256".
Multiple invocations of this function will return the same value, so it can
be used for equality checks and switch statements.
The cryptographic operations are implemented using constant-time algorithms.</p>
               
               <pre><code>func P256() Curve</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="P384" data-name="P384">
               <h3>
                  P384 
                  <span class="badge">function</span>
                  
                  <a href="#P384" class="anchor" title="Link to P384">#</a>
               </h3>
               
               <p>P384 returns a [Curve] which implements NIST P-384 (FIPS 186-3, section D.2.4),
also known as secp384r1. The CurveParams.Name of this [Curve] is "P-384".
Multiple invocations of this function will return the same value, so it can
be used for equality checks and switch statements.
The cryptographic operations are implemented using constant-time algorithms.</p>
               
               <pre><code>func P384() Curve</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="P521" data-name="P521">
               <h3>
                  P521 
                  <span class="badge">function</span>
                  
                  <a href="#P521" class="anchor" title="Link to P521">#</a>
               </h3>
               
               <p>P521 returns a [Curve] which implements NIST P-521 (FIPS 186-3, section D.2.5),
also known as secp521r1. The CurveParams.Name of this [Curve] is "P-521".
Multiple invocations of this function will return the same value, so it can
be used for equality checks and switch statements.
The cryptographic operations are implemented using constant-time algorithms.</p>
               
               <pre><code>func P521() Curve</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Params" data-name="Params">
               <h3>
                  Params 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Params" class="anchor" title="Link to Params">#</a>
               </h3>
               
               <pre><code>func (curve *CurveParams) Params() *CurveParams</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Params" data-name="Params">
               <h3>
                  Params 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Params" class="anchor" title="Link to Params">#</a>
               </h3>
               
               <pre><code>func (curve **ast.IndexExpr) Params() *CurveParams</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScalarBaseMult" data-name="ScalarBaseMult">
               <h3>
                  ScalarBaseMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ScalarBaseMult" class="anchor" title="Link to ScalarBaseMult">#</a>
               </h3>
               
               <pre><code>func (curve **ast.IndexExpr) ScalarBaseMult(scalar []byte) (*big.Int, *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScalarBaseMult" data-name="ScalarBaseMult">
               <h3>
                  ScalarBaseMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ScalarBaseMult" class="anchor" title="Link to ScalarBaseMult">#</a>
               </h3>
               
               <p>ScalarBaseMult implements [Curve.ScalarBaseMult].
Deprecated: the [CurveParams] methods are deprecated and are not guaranteed to
provide any security property. For ECDH, use the [crypto/ecdh] package.
For ECDSA, use the [crypto/ecdsa] package with a [Curve] value returned directly
from [P224], [P256], [P384], or [P521].</p>
               
               <pre><code>func (curve *CurveParams) ScalarBaseMult(k []byte) (*big.Int, *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScalarMult" data-name="ScalarMult">
               <h3>
                  ScalarMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ScalarMult" class="anchor" title="Link to ScalarMult">#</a>
               </h3>
               
               <p>ScalarMult implements [Curve.ScalarMult].
Deprecated: the [CurveParams] methods are deprecated and are not guaranteed to
provide any security property. For ECDH, use the [crypto/ecdh] package.
For ECDSA, use the [crypto/ecdsa] package with a [Curve] value returned directly
from [P224], [P256], [P384], or [P521].</p>
               
               <pre><code>func (curve *CurveParams) ScalarMult(Bx *big.Int, By *big.Int, k []byte) (*big.Int, *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScalarMult" data-name="ScalarMult">
               <h3>
                  ScalarMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ScalarMult" class="anchor" title="Link to ScalarMult">#</a>
               </h3>
               
               <pre><code>func (curve **ast.IndexExpr) ScalarMult(Bx *big.Int, By *big.Int, scalar []byte) (*big.Int, *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unmarshal" data-name="Unmarshal">
               <h3>
                  Unmarshal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unmarshal" class="anchor" title="Link to Unmarshal">#</a>
               </h3>
               
               <pre><code>func (curve **ast.IndexExpr) Unmarshal(data []byte) (x *big.Int, y *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unmarshal" data-name="Unmarshal">
               <h3>
                  Unmarshal 
                  <span class="badge">function</span>
                  
                  <a href="#Unmarshal" class="anchor" title="Link to Unmarshal">#</a>
               </h3>
               
               <p>Unmarshal converts a point, serialized by [Marshal], into an x, y pair. It is
an error if the point is not in uncompressed form, is not on the curve, or is
the point at infinity. On error, x = nil.
Deprecated: for ECDH, use the crypto/ecdh package. This function accepts an
encoding equivalent to that of the NewPublicKey methods in crypto/ecdh.</p>
               
               <pre><code>func Unmarshal(curve Curve, data []byte) (x *big.Int, y *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalCompressed" data-name="UnmarshalCompressed">
               <h3>
                  UnmarshalCompressed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnmarshalCompressed" class="anchor" title="Link to UnmarshalCompressed">#</a>
               </h3>
               
               <pre><code>func (curve **ast.IndexExpr) UnmarshalCompressed(data []byte) (x *big.Int, y *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalCompressed" data-name="UnmarshalCompressed">
               <h3>
                  UnmarshalCompressed 
                  <span class="badge">function</span>
                  
                  <a href="#UnmarshalCompressed" class="anchor" title="Link to UnmarshalCompressed">#</a>
               </h3>
               
               <p>UnmarshalCompressed converts a point, serialized by [MarshalCompressed], into
an x, y pair. It is an error if the point is not in compressed form, is not
on the curve, or is the point at infinity. On error, x = nil.</p>
               
               <pre><code>func UnmarshalCompressed(curve Curve, data []byte) (x *big.Int, y *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addJacobian" data-name="addJacobian">
               <h3>
                  addJacobian 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addJacobian" class="anchor" title="Link to addJacobian">#</a>
               </h3>
               
               <p>addJacobian takes two points in Jacobian coordinates, (x1, y1, z1) and
(x2, y2, z2) and returns their sum, also in Jacobian form.</p>
               
               <pre><code>func (curve *CurveParams) addJacobian(x1 *big.Int, y1 *big.Int, z1 *big.Int, x2 *big.Int, y2 *big.Int, z2 *big.Int) (*big.Int, *big.Int, *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="affineFromJacobian" data-name="affineFromJacobian">
               <h3>
                  affineFromJacobian 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#affineFromJacobian" class="anchor" title="Link to affineFromJacobian">#</a>
               </h3>
               
               <p>affineFromJacobian reverses the Jacobian transform. See the comment at the
top of the file. If the point is ∞ it returns 0, 0.</p>
               
               <pre><code>func (curve *CurveParams) affineFromJacobian(x *big.Int, y *big.Int, z *big.Int) (xOut *big.Int, yOut *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bigFromDecimal" data-name="bigFromDecimal">
               <h3>
                  bigFromDecimal 
                  <span class="badge">function</span>
                  
                  <a href="#bigFromDecimal" class="anchor" title="Link to bigFromDecimal">#</a>
               </h3>
               
               <pre><code>func bigFromDecimal(s string) *big.Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bigFromHex" data-name="bigFromHex">
               <h3>
                  bigFromHex 
                  <span class="badge">function</span>
                  
                  <a href="#bigFromHex" class="anchor" title="Link to bigFromHex">#</a>
               </h3>
               
               <pre><code>func bigFromHex(s string) *big.Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doubleJacobian" data-name="doubleJacobian">
               <h3>
                  doubleJacobian 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doubleJacobian" class="anchor" title="Link to doubleJacobian">#</a>
               </h3>
               
               <p>doubleJacobian takes a point in Jacobian coordinates, (x, y, z), and
returns its double, also in Jacobian form.</p>
               
               <pre><code>func (curve *CurveParams) doubleJacobian(x *big.Int, y *big.Int, z *big.Int) (*big.Int, *big.Int, *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initAll" data-name="initAll">
               <h3>
                  initAll 
                  <span class="badge">function</span>
                  
                  <a href="#initAll" class="anchor" title="Link to initAll">#</a>
               </h3>
               
               <pre><code>func initAll()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initP224" data-name="initP224">
               <h3>
                  initP224 
                  <span class="badge">function</span>
                  
                  <a href="#initP224" class="anchor" title="Link to initP224">#</a>
               </h3>
               
               <pre><code>func initP224()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initP256" data-name="initP256">
               <h3>
                  initP256 
                  <span class="badge">function</span>
                  
                  <a href="#initP256" class="anchor" title="Link to initP256">#</a>
               </h3>
               
               <pre><code>func initP256()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initP384" data-name="initP384">
               <h3>
                  initP384 
                  <span class="badge">function</span>
                  
                  <a href="#initP384" class="anchor" title="Link to initP384">#</a>
               </h3>
               
               <pre><code>func initP384()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initP521" data-name="initP521">
               <h3>
                  initP521 
                  <span class="badge">function</span>
                  
                  <a href="#initP521" class="anchor" title="Link to initP521">#</a>
               </h3>
               
               <pre><code>func initP521()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchesSpecificCurve" data-name="matchesSpecificCurve">
               <h3>
                  matchesSpecificCurve 
                  <span class="badge">function</span>
                  
                  <a href="#matchesSpecificCurve" class="anchor" title="Link to matchesSpecificCurve">#</a>
               </h3>
               
               <pre><code>func matchesSpecificCurve(params *CurveParams) (Curve, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="normalizeScalar" data-name="normalizeScalar">
               <h3>
                  normalizeScalar 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#normalizeScalar" class="anchor" title="Link to normalizeScalar">#</a>
               </h3>
               
               <p>normalizeScalar brings the scalar within the byte size of the order of the
curve, as expected by the nistec scalar multiplication functions.</p>
               
               <pre><code>func (curve **ast.IndexExpr) normalizeScalar(scalar []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="panicIfNotOnCurve" data-name="panicIfNotOnCurve">
               <h3>
                  panicIfNotOnCurve 
                  <span class="badge">function</span>
                  
                  <a href="#panicIfNotOnCurve" class="anchor" title="Link to panicIfNotOnCurve">#</a>
               </h3>
               
               <pre><code>func panicIfNotOnCurve(curve Curve, x *big.Int, y *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pointFromAffine" data-name="pointFromAffine">
               <h3>
                  pointFromAffine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pointFromAffine" class="anchor" title="Link to pointFromAffine">#</a>
               </h3>
               
               <pre><code>func (curve **ast.IndexExpr) pointFromAffine(x *big.Int, y *big.Int) (p Point, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pointToAffine" data-name="pointToAffine">
               <h3>
                  pointToAffine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pointToAffine" class="anchor" title="Link to pointToAffine">#</a>
               </h3>
               
               <pre><code>func (curve **ast.IndexExpr) pointToAffine(p Point) (x *big.Int, y *big.Int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="polynomial" data-name="polynomial">
               <h3>
                  polynomial 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#polynomial" class="anchor" title="Link to polynomial">#</a>
               </h3>
               
               <p>polynomial returns x³ - 3x + b.</p>
               
               <pre><code>func (curve *CurveParams) polynomial(x *big.Int) *big.Int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="zForAffine" data-name="zForAffine">
               <h3>
                  zForAffine 
                  <span class="badge">function</span>
                  
                  <a href="#zForAffine" class="anchor" title="Link to zForAffine">#</a>
               </h3>
               
               <p>zForAffine returns a Jacobian Z value for the affine point (x, y). If x and
y are zero, it assumes that they represent the point at infinity because (0,
0) is not on the any of the curves handled here.</p>
               
               <pre><code>func zForAffine(x *big.Int, y *big.Int) *big.Int</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>