<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - elliptic</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>elliptic</code>
         </h1>
         <hr />
         
         <article class="global" data-name="p224BaseMultTests">
            <h2>p224BaseMultTests</h2>
            <hr />
            
            <pre><code>p224BaseMultTests</code></pre>
         </article>
         
         <article class="global" data-name="p256MultTests">
            <h2>p256MultTests</h2>
            <hr />
            
            <pre><code>p256MultTests</code></pre>
         </article>
         
         <article class="global" data-name="mask">
            <h2>mask</h2>
            <hr />
            
            <pre><code>mask</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <p>Assert that the known curves implement unmarshaler.</p>
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="initonce">
            <h2>initonce</h2>
            <hr />
            
            <pre><code>initonce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="p224">
            <h2>p224</h2>
            <hr />
            
            <pre><code>p224</code></pre>
         </article>
         
         <article class="global" data-name="p256">
            <h2>p256</h2>
            <hr />
            
            <pre><code>p256</code></pre>
         </article>
         
         <article class="global" data-name="p384">
            <h2>p384</h2>
            <hr />
            
            <pre><code>p384</code></pre>
         </article>
         
         <article class="global" data-name="p521">
            <h2>p521</h2>
            <hr />
            
            <pre><code>p521</code></pre>
         </article>
          
         <article class="struct" data-name="baseMultTest">
            <h2>type baseMultTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">k string
x string
y string</code></pre>
         </article>
         
         <article class="struct" data-name="scalarMultTest">
            <h2>type scalarMultTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">k string
xIn string
yIn string
xOut string
yOut string</code></pre>
         </article>
         
         <article class="struct" data-name="synthCombinedMult">
            <h2>type synthCombinedMult struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Curve</code></pre>
         </article>
         
         <article class="struct" data-name="CurveParams">
            <h2>type CurveParams struct</h2>
            <hr />
            
            <p>CurveParams contains the parameters of an elliptic curve and also provides
a generic, non-constant time implementation of [Curve].

The generic Curve implementation is deprecated, and using custom curves
(those not returned by [P224], [P256], [P384], and [P521]) is not guaranteed
to provide any security property.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">P *big.Int
N *big.Int
B *big.Int
Gx *big.Int
Gy *big.Int
BitSize int
Name string</code></pre>
         </article>
         
         <article class="struct" data-name="p256Curve">
            <h2>type p256Curve struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">*ast.IndexExpr</code></pre>
         </article>
         
         <article class="struct" data-name="nistCurve">
            <h2>type nistCurve struct</h2>
            <hr />
            
            <p>nistCurve is a Curve implementation based on a nistec Point.

It's a wrapper that exposes the big.Int-based Curve interface and encodes the
legacy idiosyncrasies it requires, such as invalid and infinity point
handling.

To interact with the nistec package, points are encoded into and decoded from
properly formatted byte slices. All big.Int use is limited to this package.
Encoding and decoding is 1/1000th of the runtime of a scalar multiplication,
so the overhead is acceptable.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">newPoint func
params *CurveParams</code></pre>
         </article>
          
         <article class="function" data-name="Inverse">
            <h2>Inverse</h2>
            <hr />
            
            <pre><code>func Inverse(k *big.Int) *big.Int</code></pre>
         </article>
         
         <article class="function" data-name="TestP224BaseMult">
            <h2>TestP224BaseMult</h2>
            <hr />
            
            <pre><code>func TestP224BaseMult(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestP224GenericBaseMult">
            <h2>TestP224GenericBaseMult</h2>
            <hr />
            
            <pre><code>func TestP224GenericBaseMult(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestP224Overflow">
            <h2>TestP224Overflow</h2>
            <hr />
            
            <pre><code>func TestP224Overflow(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestP256BaseMult">
            <h2>TestP256BaseMult</h2>
            <hr />
            
            <pre><code>func TestP256BaseMult(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestP256Mult">
            <h2>TestP256Mult</h2>
            <hr />
            
            <pre><code>func TestP256Mult(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="CombinedMult">
            <h2>CombinedMult</h2>
            <hr />
            
            <pre><code>func CombinedMult(bigX *big.Int, bigY *big.Int, baseScalar []byte, scalar []byte) (x *big.Int, y *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="TestP256CombinedMult">
            <h2>TestP256CombinedMult</h2>
            <hr />
            
            <pre><code>func TestP256CombinedMult(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue52075">
            <h2>TestIssue52075</h2>
            <hr />
            
            <pre><code>func TestIssue52075(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Params">
            <h2>Params</h2>
            <hr />
            
            <pre><code>func Params() *CurveParams</code></pre>
         </article>
         
         <article class="function" data-name="polynomial">
            <h2>polynomial</h2>
            <hr />
            
            <p>polynomial returns x³ - 3x + b.</p>
            
            <pre><code>func polynomial(x *big.Int) *big.Int</code></pre>
         </article>
         
         <article class="function" data-name="IsOnCurve">
            <h2>IsOnCurve</h2>
            <hr />
            
            <p>IsOnCurve implements [Curve.IsOnCurve].

Deprecated: the [CurveParams] methods are deprecated and are not guaranteed to
provide any security property. For ECDH, use the [crypto/ecdh] package.
For ECDSA, use the [crypto/ecdsa] package with a [Curve] value returned directly
from [P224], [P256], [P384], or [P521].</p>
            
            <pre><code>func IsOnCurve(x *big.Int, y *big.Int) bool</code></pre>
         </article>
         
         <article class="function" data-name="zForAffine">
            <h2>zForAffine</h2>
            <hr />
            
            <p>zForAffine returns a Jacobian Z value for the affine point (x, y). If x and
y are zero, it assumes that they represent the point at infinity because (0,
0) is not on the any of the curves handled here.</p>
            
            <pre><code>func zForAffine(x *big.Int, y *big.Int) *big.Int</code></pre>
         </article>
         
         <article class="function" data-name="affineFromJacobian">
            <h2>affineFromJacobian</h2>
            <hr />
            
            <p>affineFromJacobian reverses the Jacobian transform. See the comment at the
top of the file. If the point is ∞ it returns 0, 0.</p>
            
            <pre><code>func affineFromJacobian(x *big.Int, y *big.Int, z *big.Int) (xOut *big.Int, yOut *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add implements [Curve.Add].

Deprecated: the [CurveParams] methods are deprecated and are not guaranteed to
provide any security property. For ECDH, use the [crypto/ecdh] package.
For ECDSA, use the [crypto/ecdsa] package with a [Curve] value returned directly
from [P224], [P256], [P384], or [P521].</p>
            
            <pre><code>func Add(x1 *big.Int, y1 *big.Int, x2 *big.Int, y2 *big.Int) (*big.Int, *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="addJacobian">
            <h2>addJacobian</h2>
            <hr />
            
            <p>addJacobian takes two points in Jacobian coordinates, (x1, y1, z1) and
(x2, y2, z2) and returns their sum, also in Jacobian form.</p>
            
            <pre><code>func addJacobian(x1 *big.Int, y1 *big.Int, z1 *big.Int, x2 *big.Int, y2 *big.Int, z2 *big.Int) (*big.Int, *big.Int, *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="Double">
            <h2>Double</h2>
            <hr />
            
            <p>Double implements [Curve.Double].

Deprecated: the [CurveParams] methods are deprecated and are not guaranteed to
provide any security property. For ECDH, use the [crypto/ecdh] package.
For ECDSA, use the [crypto/ecdsa] package with a [Curve] value returned directly
from [P224], [P256], [P384], or [P521].</p>
            
            <pre><code>func Double(x1 *big.Int, y1 *big.Int) (*big.Int, *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="doubleJacobian">
            <h2>doubleJacobian</h2>
            <hr />
            
            <p>doubleJacobian takes a point in Jacobian coordinates, (x, y, z), and
returns its double, also in Jacobian form.</p>
            
            <pre><code>func doubleJacobian(x *big.Int, y *big.Int, z *big.Int) (*big.Int, *big.Int, *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="ScalarMult">
            <h2>ScalarMult</h2>
            <hr />
            
            <p>ScalarMult implements [Curve.ScalarMult].

Deprecated: the [CurveParams] methods are deprecated and are not guaranteed to
provide any security property. For ECDH, use the [crypto/ecdh] package.
For ECDSA, use the [crypto/ecdsa] package with a [Curve] value returned directly
from [P224], [P256], [P384], or [P521].</p>
            
            <pre><code>func ScalarMult(Bx *big.Int, By *big.Int, k []byte) (*big.Int, *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="ScalarBaseMult">
            <h2>ScalarBaseMult</h2>
            <hr />
            
            <p>ScalarBaseMult implements [Curve.ScalarBaseMult].

Deprecated: the [CurveParams] methods are deprecated and are not guaranteed to
provide any security property. For ECDH, use the [crypto/ecdh] package.
For ECDSA, use the [crypto/ecdsa] package with a [Curve] value returned directly
from [P224], [P256], [P384], or [P521].</p>
            
            <pre><code>func ScalarBaseMult(k []byte) (*big.Int, *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="matchesSpecificCurve">
            <h2>matchesSpecificCurve</h2>
            <hr />
            
            <pre><code>func matchesSpecificCurve(params *CurveParams) (Curve, bool)</code></pre>
         </article>
         
         <article class="function" data-name="GenerateKey">
            <h2>GenerateKey</h2>
            <hr />
            
            <p>GenerateKey returns a public/private key pair. The private key is
generated using the given reader, which must return random data.

Deprecated: for ECDH, use the GenerateKey methods of the [crypto/ecdh] package;
for ECDSA, use the GenerateKey function of the crypto/ecdsa package.</p>
            
            <pre><code>func GenerateKey(curve Curve, rand io.Reader) (priv []byte, x *big.Int, y *big.Int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Marshal">
            <h2>Marshal</h2>
            <hr />
            
            <p>Marshal converts a point on the curve into the uncompressed form specified in
SEC 1, Version 2.0, Section 2.3.3. If the point is not on the curve (or is
the conventional point at infinity), the behavior is undefined.

Deprecated: for ECDH, use the crypto/ecdh package. This function returns an
encoding equivalent to that of PublicKey.Bytes in crypto/ecdh.</p>
            
            <pre><code>func Marshal(curve Curve, x *big.Int, y *big.Int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="MarshalCompressed">
            <h2>MarshalCompressed</h2>
            <hr />
            
            <p>MarshalCompressed converts a point on the curve into the compressed form
specified in SEC 1, Version 2.0, Section 2.3.3. If the point is not on the
curve (or is the conventional point at infinity), the behavior is undefined.</p>
            
            <pre><code>func MarshalCompressed(curve Curve, x *big.Int, y *big.Int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Unmarshal">
            <h2>Unmarshal</h2>
            <hr />
            
            <p>Unmarshal converts a point, serialized by [Marshal], into an x, y pair. It is
an error if the point is not in uncompressed form, is not on the curve, or is
the point at infinity. On error, x = nil.

Deprecated: for ECDH, use the crypto/ecdh package. This function accepts an
encoding equivalent to that of the NewPublicKey methods in crypto/ecdh.</p>
            
            <pre><code>func Unmarshal(curve Curve, data []byte) (x *big.Int, y *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="UnmarshalCompressed">
            <h2>UnmarshalCompressed</h2>
            <hr />
            
            <p>UnmarshalCompressed converts a point, serialized by [MarshalCompressed], into
an x, y pair. It is an error if the point is not in compressed form, is not
on the curve, or is the point at infinity. On error, x = nil.</p>
            
            <pre><code>func UnmarshalCompressed(curve Curve, data []byte) (x *big.Int, y *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="panicIfNotOnCurve">
            <h2>panicIfNotOnCurve</h2>
            <hr />
            
            <pre><code>func panicIfNotOnCurve(curve Curve, x *big.Int, y *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="initAll">
            <h2>initAll</h2>
            <hr />
            
            <pre><code>func initAll()</code></pre>
         </article>
         
         <article class="function" data-name="P224">
            <h2>P224</h2>
            <hr />
            
            <p>P224 returns a [Curve] which implements NIST P-224 (FIPS 186-3, section D.2.2),
also known as secp224r1. The CurveParams.Name of this [Curve] is "P-224".

Multiple invocations of this function will return the same value, so it can
be used for equality checks and switch statements.

The cryptographic operations are implemented using constant-time algorithms.</p>
            
            <pre><code>func P224() Curve</code></pre>
         </article>
         
         <article class="function" data-name="P256">
            <h2>P256</h2>
            <hr />
            
            <p>P256 returns a [Curve] which implements NIST P-256 (FIPS 186-3, section D.2.3),
also known as secp256r1 or prime256v1. The CurveParams.Name of this [Curve] is
"P-256".

Multiple invocations of this function will return the same value, so it can
be used for equality checks and switch statements.

The cryptographic operations are implemented using constant-time algorithms.</p>
            
            <pre><code>func P256() Curve</code></pre>
         </article>
         
         <article class="function" data-name="P384">
            <h2>P384</h2>
            <hr />
            
            <p>P384 returns a [Curve] which implements NIST P-384 (FIPS 186-3, section D.2.4),
also known as secp384r1. The CurveParams.Name of this [Curve] is "P-384".

Multiple invocations of this function will return the same value, so it can
be used for equality checks and switch statements.

The cryptographic operations are implemented using constant-time algorithms.</p>
            
            <pre><code>func P384() Curve</code></pre>
         </article>
         
         <article class="function" data-name="P521">
            <h2>P521</h2>
            <hr />
            
            <p>P521 returns a [Curve] which implements NIST P-521 (FIPS 186-3, section D.2.5),
also known as secp521r1. The CurveParams.Name of this [Curve] is "P-521".

Multiple invocations of this function will return the same value, so it can
be used for equality checks and switch statements.

The cryptographic operations are implemented using constant-time algorithms.</p>
            
            <pre><code>func P521() Curve</code></pre>
         </article>
         
         <article class="function" data-name="genericParamsForCurve">
            <h2>genericParamsForCurve</h2>
            <hr />
            
            <p>genericParamsForCurve returns the dereferenced CurveParams for
the specified curve. This is used to avoid the logic for
upgrading a curve to its specific implementation, forcing
usage of the generic implementation.</p>
            
            <pre><code>func genericParamsForCurve(c Curve) *CurveParams</code></pre>
         </article>
         
         <article class="function" data-name="testAllCurves">
            <h2>testAllCurves</h2>
            <hr />
            
            <pre><code>func testAllCurves(t *testing.T, f func)</code></pre>
         </article>
         
         <article class="function" data-name="TestOnCurve">
            <h2>TestOnCurve</h2>
            <hr />
            
            <pre><code>func TestOnCurve(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestOffCurve">
            <h2>TestOffCurve</h2>
            <hr />
            
            <pre><code>func TestOffCurve(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInfinity">
            <h2>TestInfinity</h2>
            <hr />
            
            <pre><code>func TestInfinity(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="isInfinity">
            <h2>isInfinity</h2>
            <hr />
            
            <pre><code>func isInfinity(x *big.Int, y *big.Int) bool</code></pre>
         </article>
         
         <article class="function" data-name="testInfinity">
            <h2>testInfinity</h2>
            <hr />
            
            <pre><code>func testInfinity(t *testing.T, curve Curve)</code></pre>
         </article>
         
         <article class="function" data-name="TestMarshal">
            <h2>TestMarshal</h2>
            <hr />
            
            <pre><code>func TestMarshal(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshalToLargeCoordinates">
            <h2>TestUnmarshalToLargeCoordinates</h2>
            <hr />
            
            <pre><code>func TestUnmarshalToLargeCoordinates(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testUnmarshalToLargeCoordinates">
            <h2>testUnmarshalToLargeCoordinates</h2>
            <hr />
            
            <pre><code>func testUnmarshalToLargeCoordinates(t *testing.T, curve Curve)</code></pre>
         </article>
         
         <article class="function" data-name="TestInvalidCoordinates">
            <h2>TestInvalidCoordinates</h2>
            <hr />
            
            <p>TestInvalidCoordinates tests big.Int values that are not valid field elements
(negative or bigger than P). They are expected to return false from
IsOnCurve, all other behavior is undefined.</p>
            
            <pre><code>func TestInvalidCoordinates(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testInvalidCoordinates">
            <h2>testInvalidCoordinates</h2>
            <hr />
            
            <pre><code>func testInvalidCoordinates(t *testing.T, curve Curve)</code></pre>
         </article>
         
         <article class="function" data-name="TestMarshalCompressed">
            <h2>TestMarshalCompressed</h2>
            <hr />
            
            <pre><code>func TestMarshalCompressed(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testMarshalCompressed">
            <h2>testMarshalCompressed</h2>
            <hr />
            
            <pre><code>func testMarshalCompressed(t *testing.T, curve Curve, x *big.Int, y *big.Int, want []byte)</code></pre>
         </article>
         
         <article class="function" data-name="TestLargeIsOnCurve">
            <h2>TestLargeIsOnCurve</h2>
            <hr />
            
            <pre><code>func TestLargeIsOnCurve(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="benchmarkAllCurves">
            <h2>benchmarkAllCurves</h2>
            <hr />
            
            <pre><code>func benchmarkAllCurves(b *testing.B, f func)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkScalarBaseMult">
            <h2>BenchmarkScalarBaseMult</h2>
            <hr />
            
            <pre><code>func BenchmarkScalarBaseMult(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkScalarMult">
            <h2>BenchmarkScalarMult</h2>
            <hr />
            
            <pre><code>func BenchmarkScalarMult(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkMarshalUnmarshal">
            <h2>BenchmarkMarshalUnmarshal</h2>
            <hr />
            
            <pre><code>func BenchmarkMarshalUnmarshal(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="initP224">
            <h2>initP224</h2>
            <hr />
            
            <pre><code>func initP224()</code></pre>
         </article>
         
         <article class="function" data-name="initP256">
            <h2>initP256</h2>
            <hr />
            
            <pre><code>func initP256()</code></pre>
         </article>
         
         <article class="function" data-name="initP384">
            <h2>initP384</h2>
            <hr />
            
            <pre><code>func initP384()</code></pre>
         </article>
         
         <article class="function" data-name="initP521">
            <h2>initP521</h2>
            <hr />
            
            <pre><code>func initP521()</code></pre>
         </article>
         
         <article class="function" data-name="Params">
            <h2>Params</h2>
            <hr />
            
            <pre><code>func Params() *CurveParams</code></pre>
         </article>
         
         <article class="function" data-name="IsOnCurve">
            <h2>IsOnCurve</h2>
            <hr />
            
            <pre><code>func IsOnCurve(x *big.Int, y *big.Int) bool</code></pre>
         </article>
         
         <article class="function" data-name="pointFromAffine">
            <h2>pointFromAffine</h2>
            <hr />
            
            <pre><code>func pointFromAffine(x *big.Int, y *big.Int) (p Point, err error)</code></pre>
         </article>
         
         <article class="function" data-name="pointToAffine">
            <h2>pointToAffine</h2>
            <hr />
            
            <pre><code>func pointToAffine(p Point) (x *big.Int, y *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <pre><code>func Add(x1 *big.Int, y1 *big.Int, x2 *big.Int, y2 *big.Int) (*big.Int, *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="Double">
            <h2>Double</h2>
            <hr />
            
            <pre><code>func Double(x1 *big.Int, y1 *big.Int) (*big.Int, *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="normalizeScalar">
            <h2>normalizeScalar</h2>
            <hr />
            
            <p>normalizeScalar brings the scalar within the byte size of the order of the
curve, as expected by the nistec scalar multiplication functions.</p>
            
            <pre><code>func normalizeScalar(scalar []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="ScalarMult">
            <h2>ScalarMult</h2>
            <hr />
            
            <pre><code>func ScalarMult(Bx *big.Int, By *big.Int, scalar []byte) (*big.Int, *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="ScalarBaseMult">
            <h2>ScalarBaseMult</h2>
            <hr />
            
            <pre><code>func ScalarBaseMult(scalar []byte) (*big.Int, *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="CombinedMult">
            <h2>CombinedMult</h2>
            <hr />
            
            <p>CombinedMult returns [s1]G + [s2]P where G is the generator. It's used
through an interface upgrade in crypto/ecdsa.</p>
            
            <pre><code>func CombinedMult(Px *big.Int, Py *big.Int, s1 []byte, s2 []byte) (x *big.Int, y *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="Unmarshal">
            <h2>Unmarshal</h2>
            <hr />
            
            <pre><code>func Unmarshal(data []byte) (x *big.Int, y *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="UnmarshalCompressed">
            <h2>UnmarshalCompressed</h2>
            <hr />
            
            <pre><code>func UnmarshalCompressed(data []byte) (x *big.Int, y *big.Int)</code></pre>
         </article>
         
         <article class="function" data-name="bigFromDecimal">
            <h2>bigFromDecimal</h2>
            <hr />
            
            <pre><code>func bigFromDecimal(s string) *big.Int</code></pre>
         </article>
         
         <article class="function" data-name="bigFromHex">
            <h2>bigFromHex</h2>
            <hr />
            
            <pre><code>func bigFromHex(s string) *big.Int</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
