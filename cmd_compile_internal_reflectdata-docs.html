<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - reflectdata</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>reflectdata</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"fmt"
"cmd/compile/internal/base"
"cmd/compile/internal/compare"
"cmd/compile/internal/ir"
"cmd/compile/internal/objw"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/src"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/internal/src"
"internal/abi"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/rttype"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/rttype"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
"internal/abi"
"encoding/binary"
"fmt"
"internal/abi"
"internal/buildcfg"
"slices"
"sort"
"strings"
"sync"
"cmd/compile/internal/base"
"cmd/compile/internal/bitvec"
"cmd/compile/internal/compare"
"cmd/compile/internal/ir"
"cmd/compile/internal/objw"
"cmd/compile/internal/rttype"
"cmd/compile/internal/staticdata"
"cmd/compile/internal/typebits"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="ZeroSize">
               <h3>
                  ZeroSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ZeroSize int64</code></pre>
            </article>
            
            <article class="global" data-name="cachedSwissIterType">
               <h3>
                  cachedSwissIterType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var cachedSwissIterType *types.Type</code></pre>
            </article>
            
            <article class="global" data-name="cachedSwissMapType">
               <h3>
                  cachedSwissMapType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var cachedSwissMapType *types.Type</code></pre>
            </article>
            
            <article class="global" data-name="cachedSwissTableType">
               <h3>
                  cachedSwissTableType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var cachedSwissTableType *types.Type</code></pre>
            </article>
            
            <article class="global" data-name="dnameCount">
               <h3>
                  dnameCount 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var dnameCount int</code></pre>
            </article>
            
            <article class="global" data-name="gcsymmu">
               <h3>
                  gcsymmu 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>runtime interface and reflection data structures</p>
               
               <pre><code>var gcsymmu sync.Mutex</code></pre>
            </article>
            
            <article class="global" data-name="gcsymset">
               <h3>
                  gcsymset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>runtime interface and reflection data structures</p>
               
               <pre><code>var gcsymset = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="kinds">
               <h3>
                  kinds 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var kinds = []abi.Kind{...}</code></pre>
            </article>
            
            <article class="global" data-name="memequalvarlen">
               <h3>
                  memequalvarlen 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var memequalvarlen *obj.LSym</code></pre>
            </article>
            
            <article class="global" data-name="memhashvarlen">
               <h3>
                  memhashvarlen 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var memhashvarlen *obj.LSym</code></pre>
            </article>
            
            <article class="global" data-name="oldHiterType">
               <h3>
                  oldHiterType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var oldHiterType *types.Type</code></pre>
            </article>
            
            <article class="global" data-name="oldHmapType">
               <h3>
                  oldHmapType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var oldHmapType *types.Type</code></pre>
            </article>
            
            <article class="global" data-name="signatmu">
               <h3>
                  signatmu 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>protects signatset and signatslice</p>
               
               <pre><code>var signatmu sync.Mutex</code></pre>
            </article>
            
            <article class="global" data-name="signatset">
               <h3>
                  signatset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Tracking which types need runtime type descriptor</p>
               
               <pre><code>var signatset = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="signatslice">
               <h3>
                  signatslice 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Queue of types wait to be generated runtime type descriptor</p>
               
               <pre><code>var signatslice []typeAndStr</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="ptabEntry">
               <h3>
                  ptabEntry
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ptabEntry struct {
s *types.Sym
t *types.Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="typeAndStr">
               <h3>
                  typeAndStr
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type typeAndStr struct {
t *types.Type
short string
regular string
}</code></pre>
            </article>
            
            <article class="struct" data-name="typeSig">
               <h3>
                  typeSig
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type typeSig struct {
name *types.Sym
isym *obj.LSym
tsym *obj.LSym
type_ *types.Type
mtype *types.Type
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="AlgType">
               <h3>
                  AlgType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AlgType returns the fixed-width AMEMxx variants instead of the general
AMEM kind when possible.</p>
               
               <pre><code>func AlgType(t *types.Type) types.AlgKind</code></pre>
            </article>
            
            <article class="function" data-name="AppendElemRType">
               <h3>
                  AppendElemRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AppendElemRType asserts that n is an "append" operation, and
returns an expression that yields the *runtime._type value
representing the result slice type's element type.</p>
               
               <pre><code>func AppendElemRType(pos src.XPos, n *ir.CallExpr) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="CompareRType">
               <h3>
                  CompareRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CompareRType asserts that n is a comparison (== or !=) operation
between expressions of interface and non-interface type, and
returns an expression that yields the *runtime._type value
representing the non-interface type.</p>
               
               <pre><code>func CompareRType(pos src.XPos, n *ir.BinaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="ConvIfaceSrcRType">
               <h3>
                  ConvIfaceSrcRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ConvIfaceSrcRType asserts that n is a conversion from
non-interface type to interface type, and
returns an expression that yields the *runtime._type for copying
the convertee value to the heap.</p>
               
               <pre><code>func ConvIfaceSrcRType(pos src.XPos, n *ir.ConvExpr) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="ConvIfaceTypeWord">
               <h3>
                  ConvIfaceTypeWord 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ConvIfaceTypeWord asserts that n is conversion to interface type,
and returns an expression that yields the *runtime._type or
*runtime.itab value necessary for implementing the conversion.
- *runtime._type for the destination type, for I2I conversions
- *runtime.itab, for T2I conversions
- *runtime._type for the source type, for T2E conversions</p>
               
               <pre><code>func ConvIfaceTypeWord(pos src.XPos, n *ir.ConvExpr) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="CopyElemRType">
               <h3>
                  CopyElemRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CopyElemRType asserts that n is a "copy" operation, and returns an
expression that yields the *runtime._type value representing the
destination slice type's element type.</p>
               
               <pre><code>func CopyElemRType(pos src.XPos, n *ir.BinaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="DeleteMapRType">
               <h3>
                  DeleteMapRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DeleteMapRType asserts that n is a "delete" operation, and returns
an expression that yields the *runtime._type value representing the
map type.</p>
               
               <pre><code>func DeleteMapRType(pos src.XPos, n *ir.CallExpr) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="EqFor">
               <h3>
                  EqFor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>EqFor returns ONAME node represents type t's equal function, and a boolean
to indicates whether a length needs to be passed when calling the function.</p>
               
               <pre><code>func EqFor(t *types.Type) (ir.Node, bool)</code></pre>
            </article>
            
            <article class="function" data-name="GCSym">
               <h3>
                  GCSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>GCSym returns a data symbol containing GC information for type t.
GC information is always a bitmask, never a gc program.
GCSym may be called in concurrent backend, so it does not emit the symbol
content.</p>
               
               <pre><code>func GCSym(t *types.Type) (lsym *obj.LSym, ptrdata int64)</code></pre>
            </article>
            
            <article class="function" data-name="ITabAddrAt">
               <h3>
                  ITabAddrAt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ITabAddrAt returns an expression that evaluates to the
*runtime.itab value for concrete type typ implementing interface
iface.</p>
               
               <pre><code>func ITabAddrAt(pos src.XPos, typ *types.Type, iface *types.Type) *ir.AddrExpr</code></pre>
            </article>
            
            <article class="function" data-name="ITabLsym">
               <h3>
                  ITabLsym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ITabLsym returns the LSym representing the itab for concrete type typ implementing
interface iface. A dummy tab will be created in the unusual case where typ doesn't
implement iface. Normally, this wouldn't happen, because the typechecker would
have reported a compile-time error. This situation can only happen when the
destination type of a type assert or a type in a type switch is parameterized, so
it may sometimes, but not always, be a type that can't implement the specified
interface.</p>
               
               <pre><code>func ITabLsym(typ *types.Type, iface *types.Type) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="IndexMapRType">
               <h3>
                  IndexMapRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IndexMapRType asserts that n is a map index operation, and returns
an expression that yields the *runtime._type value representing the
map type.</p>
               
               <pre><code>func IndexMapRType(pos src.XPos, n *ir.IndexExpr) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="InterfaceMethodOffset">
               <h3>
                  InterfaceMethodOffset 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>InterfaceMethodOffset returns the offset of the i-th method in the interface
type descriptor, ityp.</p>
               
               <pre><code>func InterfaceMethodOffset(ityp *types.Type, i int64) int64</code></pre>
            </article>
            
            <article class="function" data-name="MakeChanRType">
               <h3>
                  MakeChanRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MakeChanRType asserts that n is a "make" operation for a channel
type, and returns an expression that yields the *runtime._type
value representing that channel type.</p>
               
               <pre><code>func MakeChanRType(pos src.XPos, n *ir.MakeExpr) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="MakeMapRType">
               <h3>
                  MakeMapRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MakeMapRType asserts that n is a "make" operation for a map type,
and returns an expression that yields the *runtime._type value
representing that map type.</p>
               
               <pre><code>func MakeMapRType(pos src.XPos, n *ir.MakeExpr) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="MakeSliceElemRType">
               <h3>
                  MakeSliceElemRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MakeSliceElemRType asserts that n is a "make" operation for a slice
type, and returns an expression that yields the *runtime._type
value representing that slice type's element type.</p>
               
               <pre><code>func MakeSliceElemRType(pos src.XPos, n *ir.MakeExpr) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="MarkTypeSymUsedInInterface">
               <h3>
                  MarkTypeSymUsedInInterface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func MarkTypeSymUsedInInterface(tsym *obj.LSym, from *obj.LSym)</code></pre>
            </article>
            
            <article class="function" data-name="MarkTypeUsedInInterface">
               <h3>
                  MarkTypeUsedInInterface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MarkTypeUsedInInterface marks that type t is converted to an interface.
This information is used in the linker in dead method elimination.</p>
               
               <pre><code>func MarkTypeUsedInInterface(t *types.Type, from *obj.LSym)</code></pre>
            </article>
            
            <article class="function" data-name="MarkUsedIfaceMethod">
               <h3>
                  MarkUsedIfaceMethod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MarkUsedIfaceMethod marks that an interface method is used in the current
function. n is OCALLINTER node.</p>
               
               <pre><code>func MarkUsedIfaceMethod(n *ir.CallExpr)</code></pre>
            </article>
            
            <article class="function" data-name="NeedEmit">
               <h3>
                  NeedEmit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NeedEmit reports whether typ is a type that we need to emit code
for (e.g., runtime type descriptors, method wrappers).</p>
               
               <pre><code>func NeedEmit(typ *types.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="NeedRuntimeType">
               <h3>
                  NeedRuntimeType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NeedRuntimeType ensures that a runtime type descriptor is emitted for t.</p>
               
               <pre><code>func NeedRuntimeType(t *types.Type)</code></pre>
            </article>
            
            <article class="function" data-name="OldMapBucketType">
               <h3>
                  OldMapBucketType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>OldMapBucketType makes the map bucket type given the type of the map.</p>
               
               <pre><code>func OldMapBucketType(t *types.Type) *types.Type</code></pre>
            </article>
            
            <article class="function" data-name="OldMapIterType">
               <h3>
                  OldMapIterType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>OldMapIterType returns a type interchangeable with runtime.hiter.
Make sure this stays in sync with runtime/map.go.</p>
               
               <pre><code>func OldMapIterType() *types.Type</code></pre>
            </article>
            
            <article class="function" data-name="OldMapType">
               <h3>
                  OldMapType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>OldMapType returns a type interchangeable with runtime.hmap.
Make sure this stays in sync with runtime/map.go.</p>
               
               <pre><code>func OldMapType() *types.Type</code></pre>
            </article>
            
            <article class="function" data-name="RangeMapRType">
               <h3>
                  RangeMapRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RangeMapRType asserts that n is a "range" loop over a map value,
and returns an expression that yields the *runtime._type value
representing that map type.</p>
               
               <pre><code>func RangeMapRType(pos src.XPos, n *ir.RangeStmt) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="SwissMapGroupType">
               <h3>
                  SwissMapGroupType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SwissMapGroupType makes the map slot group type given the type of the map.</p>
               
               <pre><code>func SwissMapGroupType(t *types.Type) *types.Type</code></pre>
            </article>
            
            <article class="function" data-name="SwissMapIterType">
               <h3>
                  SwissMapIterType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SwissMapIterType returns a type interchangeable with runtime.hiter.
Make sure this stays in sync with runtime/map.go.</p>
               
               <pre><code>func SwissMapIterType() *types.Type</code></pre>
            </article>
            
            <article class="function" data-name="SwissMapType">
               <h3>
                  SwissMapType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SwissMapType returns a type interchangeable with internal/runtime/maps.Map.
Make sure this stays in sync with internal/runtime/maps/map.go.</p>
               
               <pre><code>func SwissMapType() *types.Type</code></pre>
            </article>
            
            <article class="function" data-name="TrackSym">
               <h3>
                  TrackSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TrackSym returns the symbol for tracking use of field/method f, assumed
to be a member of struct/interface type t.</p>
               
               <pre><code>func TrackSym(t *types.Type, f *types.Field) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="TypeLinksym">
               <h3>
                  TypeLinksym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func TypeLinksym(t *types.Type) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="TypeLinksymLookup">
               <h3>
                  TypeLinksymLookup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func TypeLinksymLookup(name string) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="TypeLinksymPrefix">
               <h3>
                  TypeLinksymPrefix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func TypeLinksymPrefix(prefix string, t *types.Type) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="TypePtrAt">
               <h3>
                  TypePtrAt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TypePtrAt returns an expression that evaluates to the
*runtime._type value for t.</p>
               
               <pre><code>func TypePtrAt(pos src.XPos, t *types.Type) *ir.AddrExpr</code></pre>
            </article>
            
            <article class="function" data-name="TypeSym">
               <h3>
                  TypeSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func TypeSym(t *types.Type) *types.Sym</code></pre>
            </article>
            
            <article class="function" data-name="TypeSymPrefix">
               <h3>
                  TypeSymPrefix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func TypeSymPrefix(prefix string, t *types.Type) *types.Sym</code></pre>
            </article>
            
            <article class="function" data-name="UnsafeSliceElemRType">
               <h3>
                  UnsafeSliceElemRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>UnsafeSliceElemRType asserts that n is an "unsafe.Slice" operation,
and returns an expression that yields the *runtime._type value
representing the result slice type's element type.</p>
               
               <pre><code>func UnsafeSliceElemRType(pos src.XPos, n *ir.BinaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="WriteBasicTypes">
               <h3>
                  WriteBasicTypes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func WriteBasicTypes()</code></pre>
            </article>
            
            <article class="function" data-name="WriteGCSymbols">
               <h3>
                  WriteGCSymbols 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func WriteGCSymbols()</code></pre>
            </article>
            
            <article class="function" data-name="WritePluginTable">
               <h3>
                  WritePluginTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func WritePluginTable()</code></pre>
            </article>
            
            <article class="function" data-name="WriteRuntimeTypes">
               <h3>
                  WriteRuntimeTypes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func WriteRuntimeTypes()</code></pre>
            </article>
            
            <article class="function" data-name="ZeroAddr">
               <h3>
                  ZeroAddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ZeroAddr returns the address of a symbol with at least
size bytes of zeros.</p>
               
               <pre><code>func ZeroAddr(size int64) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="anyCall">
               <h3>
                  anyCall 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func anyCall(fn *ir.Func) bool</code></pre>
            </article>
            
            <article class="function" data-name="assertOp">
               <h3>
                  assertOp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>assertOp asserts that n is an op.</p>
               
               <pre><code>func assertOp(n ir.Node, op ir.Op)</code></pre>
            </article>
            
            <article class="function" data-name="assertOp2">
               <h3>
                  assertOp2 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>assertOp2 asserts that n is an op1 or op2.</p>
               
               <pre><code>func assertOp2(n ir.Node, op1 ir.Op, op2 ir.Op)</code></pre>
            </article>
            
            <article class="function" data-name="chanRType">
               <h3>
                  chanRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>chanRType asserts that typ is a map type, and returns an expression
that yields the *runtime._type value representing typ.</p>
               
               <pre><code>func chanRType(pos src.XPos, typ *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="commonSize">
               <h3>
                  commonSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func commonSize() int</code></pre>
            </article>
            
            <article class="function" data-name="concreteRType">
               <h3>
                  concreteRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>concreteRType asserts that typ is not an interface type, and
returns an expression that yields the *runtime._type value
representing typ.</p>
               
               <pre><code>func concreteRType(pos src.XPos, typ *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="dcommontype">
               <h3>
                  dcommontype 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dcommontype dumps the contents of a reflect.rtype (runtime._type) to c.</p>
               
               <pre><code>func dcommontype(c rttype.Cursor, t *types.Type)</code></pre>
            </article>
            
            <article class="function" data-name="deref">
               <h3>
                  deref 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func deref(t *types.Type) *types.Type</code></pre>
            </article>
            
            <article class="function" data-name="dextratype">
               <h3>
                  dextratype 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dextratype dumps the fields of a runtime.uncommontype.
dataAdd is the offset in bytes after the header where the
backing array of the []method field should be written.</p>
               
               <pre><code>func dextratype(lsym *obj.LSym, off int64, t *types.Type, dataAdd int)</code></pre>
            </article>
            
            <article class="function" data-name="dgcptrmask">
               <h3>
                  dgcptrmask 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dgcptrmask emits and returns the symbol containing a pointer mask for type t.</p>
               
               <pre><code>func dgcptrmask(t *types.Type, write bool) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="dgcptrmaskOnDemand">
               <h3>
                  dgcptrmaskOnDemand 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dgcptrmaskOnDemand emits and returns the symbol that should be referenced by
the GCData field of a type, for large types.</p>
               
               <pre><code>func dgcptrmaskOnDemand(t *types.Type, write bool) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="dgcsym">
               <h3>
                  dgcsym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dgcsym returns a data symbol containing GC information for type t, along
with a boolean reporting whether the gc mask should be computed on demand
at runtime, and the ptrdata field to record in the reflect type information.
When write is true, it writes the symbol data.</p>
               
               <pre><code>func dgcsym(t *types.Type, write bool, onDemandAllowed bool) (lsym *obj.LSym, onDemand bool, ptrdata int64)</code></pre>
            </article>
            
            <article class="function" data-name="dgopkgpath">
               <h3>
                  dgopkgpath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dgopkgpath(c rttype.Cursor, pkg *types.Pkg)</code></pre>
            </article>
            
            <article class="function" data-name="dgopkgpathOff">
               <h3>
                  dgopkgpathOff 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dgopkgpathOff writes an offset relocation to the pkg path symbol to c.</p>
               
               <pre><code>func dgopkgpathOff(c rttype.Cursor, pkg *types.Pkg)</code></pre>
            </article>
            
            <article class="function" data-name="dimportpath">
               <h3>
                  dimportpath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dimportpath(p *types.Pkg)</code></pre>
            </article>
            
            <article class="function" data-name="dmethodptrOff">
               <h3>
                  dmethodptrOff 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dmethodptrOff(c rttype.Cursor, x *obj.LSym)</code></pre>
            </article>
            
            <article class="function" data-name="dname">
               <h3>
                  dname 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dname creates a reflect.name for a struct field or method.</p>
               
               <pre><code>func dname(name string, tag string, pkg *types.Pkg, exported bool, embedded bool) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="dnameData">
               <h3>
                  dnameData 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dnameData writes the contents of a reflect.name into s at offset ot.</p>
               
               <pre><code>func dnameData(s *obj.LSym, ot int, name string, tag string, pkg *types.Pkg, exported bool, embedded bool) int</code></pre>
            </article>
            
            <article class="function" data-name="dnameField">
               <h3>
                  dnameField 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dnameField dumps a reflect.name for a struct field.</p>
               
               <pre><code>func dnameField(c rttype.Cursor, spkg *types.Pkg, ft *types.Field)</code></pre>
            </article>
            
            <article class="function" data-name="eqFunc">
               <h3>
                  eqFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func eqFunc(t *types.Type) *ir.Func</code></pre>
            </article>
            
            <article class="function" data-name="fillptrmask">
               <h3>
                  fillptrmask 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fillptrmask fills in ptrmask with 1s corresponding to the
word offsets in t that hold pointers.
ptrmask is assumed to fit at least types.PtrDataSize(t)/PtrSize bits.</p>
               
               <pre><code>func fillptrmask(t *types.Type, ptrmask []byte)</code></pre>
            </article>
            
            <article class="function" data-name="formalType">
               <h3>
                  formalType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>formalType replaces predeclared aliases with real types.
They've been separate internally to make error messages
better, but we have to merge them in the reflect tables.</p>
               
               <pre><code>func formalType(t *types.Type) *types.Type</code></pre>
            </article>
            
            <article class="function" data-name="geneq">
               <h3>
                  geneq 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>geneq returns a symbol which is the closure used to compute
equality for two objects of type t.</p>
               
               <pre><code>func geneq(t *types.Type) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="genhash">
               <h3>
                  genhash 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>genhash returns a symbol which is the closure used to compute
the hash of a value of type t.
Note: the generated function must match runtime.typehash exactly.</p>
               
               <pre><code>func genhash(t *types.Type) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="hasRType">
               <h3>
                  hasRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func hasRType(n ir.Node, rtype ir.Node, fieldName string) bool</code></pre>
            </article>
            
            <article class="function" data-name="hashFunc">
               <h3>
                  hashFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func hashFunc(t *types.Type) *ir.Func</code></pre>
            </article>
            
            <article class="function" data-name="hashMightPanic">
               <h3>
                  hashMightPanic 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hashMightPanic reports whether the hash of a map key of type t might panic.</p>
               
               <pre><code>func hashMightPanic(t *types.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="hashfor">
               <h3>
                  hashfor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hashfor returns the function to compute the hash of a value of type t.</p>
               
               <pre><code>func hashfor(t *types.Type) *ir.Name</code></pre>
            </article>
            
            <article class="function" data-name="hashmem">
               <h3>
                  hashmem 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func hashmem(t *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="imethods">
               <h3>
                  imethods 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>imethods returns the methods of the interface type t, sorted by name.</p>
               
               <pre><code>func imethods(t *types.Type) []*typeSig</code></pre>
            </article>
            
            <article class="function" data-name="kindRType">
               <h3>
                  kindRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>kindRType asserts that typ has the given kind, and returns an
expression that yields the *runtime._type value representing typ.</p>
               
               <pre><code>func kindRType(pos src.XPos, typ *types.Type, k types.Kind) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="makefield">
               <h3>
                  makefield 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makefield(name string, t *types.Type) *types.Field</code></pre>
            </article>
            
            <article class="function" data-name="mapRType">
               <h3>
                  mapRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>mapRType asserts that typ is a map type, and returns an expression
that yields the *runtime._type value representing typ.</p>
               
               <pre><code>func mapRType(pos src.XPos, typ *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="methodWrapper">
               <h3>
                  methodWrapper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Generate a wrapper function to convert from
a receiver of type T to a receiver of type U.
That is,
func (t T) M() {
...
}
already exists; this function generates
func (u U) M() {
u.M()
}
where the types T and U are such that u.M() is valid
and calls the T.M method.
The resulting function is for use in method tables.
rcvr - U
method - M func (t T)(), a TFIELD type struct
Also wraps methods on instantiated generic types for use in itab entries.
For an instantiated generic type G[int], we generate wrappers like:
G[int] pointer shaped:
func (x G[int]) f(arg) {
.inst.G[int].f(dictionary, x, arg)
}
G[int] not pointer shaped:
func (x *G[int]) f(arg) {
.inst.G[int].f(dictionary, *x, arg)
}
These wrappers are always fully stenciled.</p>
               
               <pre><code>func methodWrapper(rcvr *types.Type, method *types.Field, forItab bool) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="methods">
               <h3>
                  methods 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>methods returns the methods of the non-interface type t, sorted by name.
Generates stub functions as needed.</p>
               
               <pre><code>func methods(t *types.Type) []*typeSig</code></pre>
            </article>
            
            <article class="function" data-name="needkeyupdate">
               <h3>
                  needkeyupdate 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>needkeyupdate reports whether map updates with t as a key
need the key to be updated.</p>
               
               <pre><code>func needkeyupdate(t *types.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="runtimeHashFor">
               <h3>
                  runtimeHashFor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runtimeHashFor(name string, t *types.Type) *ir.Name</code></pre>
            </article>
            
            <article class="function" data-name="sliceElemRType">
               <h3>
                  sliceElemRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>sliceElemRType asserts that typ is a slice type, and returns an
expression that yields the *runtime._type value representing typ's
element type.</p>
               
               <pre><code>func sliceElemRType(pos src.XPos, typ *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="swissTableType">
               <h3>
                  swissTableType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>swissTableType returns a type interchangeable with internal/runtime/maps.table.
Make sure this stays in sync with internal/runtime/maps/table.go.</p>
               
               <pre><code>func swissTableType() *types.Type</code></pre>
            </article>
            
            <article class="function" data-name="sysClosure">
               <h3>
                  sysClosure 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>sysClosure returns a closure which will call the
given runtime function (with no closed-over variables).</p>
               
               <pre><code>func sysClosure(name string) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="typePkg">
               <h3>
                  typePkg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func typePkg(t *types.Type) *types.Pkg</code></pre>
            </article>
            
            <article class="function" data-name="typesStrCmp">
               <h3>
                  typesStrCmp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func typesStrCmp(a typeAndStr, b typeAndStr) int</code></pre>
            </article>
            
            <article class="function" data-name="uncommonSize">
               <h3>
                  uncommonSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func uncommonSize(t *types.Type) int</code></pre>
            </article>
            
            <article class="function" data-name="writeITab">
               <h3>
                  writeITab 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>writeITab writes the itab for concrete type typ implementing interface iface. If
allowNonImplement is true, allow the case where typ does not implement iface, and just
create a dummy itab with zeroed-out method entries.</p>
               
               <pre><code>func writeITab(lsym *obj.LSym, typ *types.Type, iface *types.Type, allowNonImplement bool)</code></pre>
            </article>
            
            <article class="function" data-name="writeOldMapType">
               <h3>
                  writeOldMapType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func writeOldMapType(t *types.Type, lsym *obj.LSym, c rttype.Cursor)</code></pre>
            </article>
            
            <article class="function" data-name="writeSwissMapType">
               <h3>
                  writeSwissMapType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func writeSwissMapType(t *types.Type, lsym *obj.LSym, c rttype.Cursor)</code></pre>
            </article>
            
            <article class="function" data-name="writeType">
               <h3>
                  writeType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func writeType(t *types.Type) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="writtenByWriteBasicTypes">
               <h3>
                  writtenByWriteBasicTypes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>writtenByWriteBasicTypes reports whether typ is written by WriteBasicTypes.
WriteBasicTypes always writes pointer types; any pointer has been stripped off typ already.</p>
               
               <pre><code>func writtenByWriteBasicTypes(typ *types.Type) bool</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
