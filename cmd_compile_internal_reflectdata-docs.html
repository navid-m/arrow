<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - reflectdata</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>reflectdata</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"fmt"
"cmd/compile/internal/base"
"cmd/compile/internal/compare"
"cmd/compile/internal/ir"
"cmd/compile/internal/objw"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/src"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/internal/src"
"internal/abi"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/rttype"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/rttype"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
"internal/abi"
"encoding/binary"
"fmt"
"internal/abi"
"internal/buildcfg"
"slices"
"sort"
"strings"
"sync"
"cmd/compile/internal/base"
"cmd/compile/internal/bitvec"
"cmd/compile/internal/compare"
"cmd/compile/internal/ir"
"cmd/compile/internal/objw"
"cmd/compile/internal/rttype"
"cmd/compile/internal/staticdata"
"cmd/compile/internal/typebits"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ZeroSize" data-name="ZeroSize">
               <h3>
                  ZeroSize 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ZeroSize" class="anchor" title="Link to ZeroSize">#</a>
               </h3>
               
               <pre><code>var ZeroSize int64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cachedSwissIterType" data-name="cachedSwissIterType">
               <h3>
                  cachedSwissIterType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cachedSwissIterType" class="anchor" title="Link to cachedSwissIterType">#</a>
               </h3>
               
               <pre><code>var cachedSwissIterType *types.Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cachedSwissMapType" data-name="cachedSwissMapType">
               <h3>
                  cachedSwissMapType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cachedSwissMapType" class="anchor" title="Link to cachedSwissMapType">#</a>
               </h3>
               
               <pre><code>var cachedSwissMapType *types.Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cachedSwissTableType" data-name="cachedSwissTableType">
               <h3>
                  cachedSwissTableType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cachedSwissTableType" class="anchor" title="Link to cachedSwissTableType">#</a>
               </h3>
               
               <pre><code>var cachedSwissTableType *types.Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dnameCount" data-name="dnameCount">
               <h3>
                  dnameCount 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dnameCount" class="anchor" title="Link to dnameCount">#</a>
               </h3>
               
               <pre><code>var dnameCount int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gcsymmu" data-name="gcsymmu">
               <h3>
                  gcsymmu 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gcsymmu" class="anchor" title="Link to gcsymmu">#</a>
               </h3>
               
               <p>runtime interface and reflection data structures</p>
               
               <pre><code>var gcsymmu sync.Mutex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gcsymset" data-name="gcsymset">
               <h3>
                  gcsymset 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gcsymset" class="anchor" title="Link to gcsymset">#</a>
               </h3>
               
               <p>runtime interface and reflection data structures</p>
               
               <pre><code>var gcsymset = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="kinds" data-name="kinds">
               <h3>
                  kinds 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#kinds" class="anchor" title="Link to kinds">#</a>
               </h3>
               
               <pre><code>var kinds = []abi.Kind{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="memequalvarlen" data-name="memequalvarlen">
               <h3>
                  memequalvarlen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#memequalvarlen" class="anchor" title="Link to memequalvarlen">#</a>
               </h3>
               
               <pre><code>var memequalvarlen *obj.LSym</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="memhashvarlen" data-name="memhashvarlen">
               <h3>
                  memhashvarlen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#memhashvarlen" class="anchor" title="Link to memhashvarlen">#</a>
               </h3>
               
               <pre><code>var memhashvarlen *obj.LSym</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="oldHiterType" data-name="oldHiterType">
               <h3>
                  oldHiterType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#oldHiterType" class="anchor" title="Link to oldHiterType">#</a>
               </h3>
               
               <pre><code>var oldHiterType *types.Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="oldHmapType" data-name="oldHmapType">
               <h3>
                  oldHmapType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#oldHmapType" class="anchor" title="Link to oldHmapType">#</a>
               </h3>
               
               <pre><code>var oldHmapType *types.Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="signatmu" data-name="signatmu">
               <h3>
                  signatmu 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#signatmu" class="anchor" title="Link to signatmu">#</a>
               </h3>
               
               <p>protects signatset and signatslice</p>
               
               <pre><code>var signatmu sync.Mutex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="signatset" data-name="signatset">
               <h3>
                  signatset 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#signatset" class="anchor" title="Link to signatset">#</a>
               </h3>
               
               <p>Tracking which types need runtime type descriptor</p>
               
               <pre><code>var signatset = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="signatslice" data-name="signatslice">
               <h3>
                  signatslice 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#signatslice" class="anchor" title="Link to signatslice">#</a>
               </h3>
               
               <p>Queue of types wait to be generated runtime type descriptor</p>
               
               <pre><code>var signatslice []typeAndStr</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="ptabEntry" data-name="ptabEntry">
               <h3>
                  ptabEntry
                  <span class="badge">struct</span>
                  <a href="#ptabEntry" class="anchor" title="Link to ptabEntry">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ptabEntry struct {
s *types.Sym
t *types.Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="typeAndStr" data-name="typeAndStr">
               <h3>
                  typeAndStr
                  <span class="badge">struct</span>
                  <a href="#typeAndStr" class="anchor" title="Link to typeAndStr">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type typeAndStr struct {
t *types.Type
short string
regular string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="typeSig" data-name="typeSig">
               <h3>
                  typeSig
                  <span class="badge">struct</span>
                  <a href="#typeSig" class="anchor" title="Link to typeSig">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type typeSig struct {
name *types.Sym
isym *obj.LSym
tsym *obj.LSym
type_ *types.Type
mtype *types.Type
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AlgType" data-name="AlgType">
               <h3>
                  AlgType 
                  <span class="badge">function</span>
                  
                  <a href="#AlgType" class="anchor" title="Link to AlgType">#</a>
               </h3>
               
               <p>AlgType returns the fixed-width AMEMxx variants instead of the general
AMEM kind when possible.</p>
               
               <pre><code>func AlgType(t *types.Type) types.AlgKind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendElemRType" data-name="AppendElemRType">
               <h3>
                  AppendElemRType 
                  <span class="badge">function</span>
                  
                  <a href="#AppendElemRType" class="anchor" title="Link to AppendElemRType">#</a>
               </h3>
               
               <p>AppendElemRType asserts that n is an "append" operation, and
returns an expression that yields the *runtime._type value
representing the result slice type's element type.</p>
               
               <pre><code>func AppendElemRType(pos src.XPos, n *ir.CallExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CompareRType" data-name="CompareRType">
               <h3>
                  CompareRType 
                  <span class="badge">function</span>
                  
                  <a href="#CompareRType" class="anchor" title="Link to CompareRType">#</a>
               </h3>
               
               <p>CompareRType asserts that n is a comparison (== or !=) operation
between expressions of interface and non-interface type, and
returns an expression that yields the *runtime._type value
representing the non-interface type.</p>
               
               <pre><code>func CompareRType(pos src.XPos, n *ir.BinaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ConvIfaceSrcRType" data-name="ConvIfaceSrcRType">
               <h3>
                  ConvIfaceSrcRType 
                  <span class="badge">function</span>
                  
                  <a href="#ConvIfaceSrcRType" class="anchor" title="Link to ConvIfaceSrcRType">#</a>
               </h3>
               
               <p>ConvIfaceSrcRType asserts that n is a conversion from
non-interface type to interface type, and
returns an expression that yields the *runtime._type for copying
the convertee value to the heap.</p>
               
               <pre><code>func ConvIfaceSrcRType(pos src.XPos, n *ir.ConvExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ConvIfaceTypeWord" data-name="ConvIfaceTypeWord">
               <h3>
                  ConvIfaceTypeWord 
                  <span class="badge">function</span>
                  
                  <a href="#ConvIfaceTypeWord" class="anchor" title="Link to ConvIfaceTypeWord">#</a>
               </h3>
               
               <p>ConvIfaceTypeWord asserts that n is conversion to interface type,
and returns an expression that yields the *runtime._type or
*runtime.itab value necessary for implementing the conversion.
- *runtime._type for the destination type, for I2I conversions
- *runtime.itab, for T2I conversions
- *runtime._type for the source type, for T2E conversions</p>
               
               <pre><code>func ConvIfaceTypeWord(pos src.XPos, n *ir.ConvExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CopyElemRType" data-name="CopyElemRType">
               <h3>
                  CopyElemRType 
                  <span class="badge">function</span>
                  
                  <a href="#CopyElemRType" class="anchor" title="Link to CopyElemRType">#</a>
               </h3>
               
               <p>CopyElemRType asserts that n is a "copy" operation, and returns an
expression that yields the *runtime._type value representing the
destination slice type's element type.</p>
               
               <pre><code>func CopyElemRType(pos src.XPos, n *ir.BinaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DeleteMapRType" data-name="DeleteMapRType">
               <h3>
                  DeleteMapRType 
                  <span class="badge">function</span>
                  
                  <a href="#DeleteMapRType" class="anchor" title="Link to DeleteMapRType">#</a>
               </h3>
               
               <p>DeleteMapRType asserts that n is a "delete" operation, and returns
an expression that yields the *runtime._type value representing the
map type.</p>
               
               <pre><code>func DeleteMapRType(pos src.XPos, n *ir.CallExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EqFor" data-name="EqFor">
               <h3>
                  EqFor 
                  <span class="badge">function</span>
                  
                  <a href="#EqFor" class="anchor" title="Link to EqFor">#</a>
               </h3>
               
               <p>EqFor returns ONAME node represents type t's equal function, and a boolean
to indicates whether a length needs to be passed when calling the function.</p>
               
               <pre><code>func EqFor(t *types.Type) (ir.Node, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GCSym" data-name="GCSym">
               <h3>
                  GCSym 
                  <span class="badge">function</span>
                  
                  <a href="#GCSym" class="anchor" title="Link to GCSym">#</a>
               </h3>
               
               <p>GCSym returns a data symbol containing GC information for type t.
GC information is always a bitmask, never a gc program.
GCSym may be called in concurrent backend, so it does not emit the symbol
content.</p>
               
               <pre><code>func GCSym(t *types.Type) (lsym *obj.LSym, ptrdata int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ITabAddrAt" data-name="ITabAddrAt">
               <h3>
                  ITabAddrAt 
                  <span class="badge">function</span>
                  
                  <a href="#ITabAddrAt" class="anchor" title="Link to ITabAddrAt">#</a>
               </h3>
               
               <p>ITabAddrAt returns an expression that evaluates to the
*runtime.itab value for concrete type typ implementing interface
iface.</p>
               
               <pre><code>func ITabAddrAt(pos src.XPos, typ *types.Type, iface *types.Type) *ir.AddrExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ITabLsym" data-name="ITabLsym">
               <h3>
                  ITabLsym 
                  <span class="badge">function</span>
                  
                  <a href="#ITabLsym" class="anchor" title="Link to ITabLsym">#</a>
               </h3>
               
               <p>ITabLsym returns the LSym representing the itab for concrete type typ implementing
interface iface. A dummy tab will be created in the unusual case where typ doesn't
implement iface. Normally, this wouldn't happen, because the typechecker would
have reported a compile-time error. This situation can only happen when the
destination type of a type assert or a type in a type switch is parameterized, so
it may sometimes, but not always, be a type that can't implement the specified
interface.</p>
               
               <pre><code>func ITabLsym(typ *types.Type, iface *types.Type) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IndexMapRType" data-name="IndexMapRType">
               <h3>
                  IndexMapRType 
                  <span class="badge">function</span>
                  
                  <a href="#IndexMapRType" class="anchor" title="Link to IndexMapRType">#</a>
               </h3>
               
               <p>IndexMapRType asserts that n is a map index operation, and returns
an expression that yields the *runtime._type value representing the
map type.</p>
               
               <pre><code>func IndexMapRType(pos src.XPos, n *ir.IndexExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InterfaceMethodOffset" data-name="InterfaceMethodOffset">
               <h3>
                  InterfaceMethodOffset 
                  <span class="badge">function</span>
                  
                  <a href="#InterfaceMethodOffset" class="anchor" title="Link to InterfaceMethodOffset">#</a>
               </h3>
               
               <p>InterfaceMethodOffset returns the offset of the i-th method in the interface
type descriptor, ityp.</p>
               
               <pre><code>func InterfaceMethodOffset(ityp *types.Type, i int64) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MakeChanRType" data-name="MakeChanRType">
               <h3>
                  MakeChanRType 
                  <span class="badge">function</span>
                  
                  <a href="#MakeChanRType" class="anchor" title="Link to MakeChanRType">#</a>
               </h3>
               
               <p>MakeChanRType asserts that n is a "make" operation for a channel
type, and returns an expression that yields the *runtime._type
value representing that channel type.</p>
               
               <pre><code>func MakeChanRType(pos src.XPos, n *ir.MakeExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MakeMapRType" data-name="MakeMapRType">
               <h3>
                  MakeMapRType 
                  <span class="badge">function</span>
                  
                  <a href="#MakeMapRType" class="anchor" title="Link to MakeMapRType">#</a>
               </h3>
               
               <p>MakeMapRType asserts that n is a "make" operation for a map type,
and returns an expression that yields the *runtime._type value
representing that map type.</p>
               
               <pre><code>func MakeMapRType(pos src.XPos, n *ir.MakeExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MakeSliceElemRType" data-name="MakeSliceElemRType">
               <h3>
                  MakeSliceElemRType 
                  <span class="badge">function</span>
                  
                  <a href="#MakeSliceElemRType" class="anchor" title="Link to MakeSliceElemRType">#</a>
               </h3>
               
               <p>MakeSliceElemRType asserts that n is a "make" operation for a slice
type, and returns an expression that yields the *runtime._type
value representing that slice type's element type.</p>
               
               <pre><code>func MakeSliceElemRType(pos src.XPos, n *ir.MakeExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarkTypeSymUsedInInterface" data-name="MarkTypeSymUsedInInterface">
               <h3>
                  MarkTypeSymUsedInInterface 
                  <span class="badge">function</span>
                  
                  <a href="#MarkTypeSymUsedInInterface" class="anchor" title="Link to MarkTypeSymUsedInInterface">#</a>
               </h3>
               
               <pre><code>func MarkTypeSymUsedInInterface(tsym *obj.LSym, from *obj.LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarkTypeUsedInInterface" data-name="MarkTypeUsedInInterface">
               <h3>
                  MarkTypeUsedInInterface 
                  <span class="badge">function</span>
                  
                  <a href="#MarkTypeUsedInInterface" class="anchor" title="Link to MarkTypeUsedInInterface">#</a>
               </h3>
               
               <p>MarkTypeUsedInInterface marks that type t is converted to an interface.
This information is used in the linker in dead method elimination.</p>
               
               <pre><code>func MarkTypeUsedInInterface(t *types.Type, from *obj.LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarkUsedIfaceMethod" data-name="MarkUsedIfaceMethod">
               <h3>
                  MarkUsedIfaceMethod 
                  <span class="badge">function</span>
                  
                  <a href="#MarkUsedIfaceMethod" class="anchor" title="Link to MarkUsedIfaceMethod">#</a>
               </h3>
               
               <p>MarkUsedIfaceMethod marks that an interface method is used in the current
function. n is OCALLINTER node.</p>
               
               <pre><code>func MarkUsedIfaceMethod(n *ir.CallExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NeedEmit" data-name="NeedEmit">
               <h3>
                  NeedEmit 
                  <span class="badge">function</span>
                  
                  <a href="#NeedEmit" class="anchor" title="Link to NeedEmit">#</a>
               </h3>
               
               <p>NeedEmit reports whether typ is a type that we need to emit code
for (e.g., runtime type descriptors, method wrappers).</p>
               
               <pre><code>func NeedEmit(typ *types.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NeedRuntimeType" data-name="NeedRuntimeType">
               <h3>
                  NeedRuntimeType 
                  <span class="badge">function</span>
                  
                  <a href="#NeedRuntimeType" class="anchor" title="Link to NeedRuntimeType">#</a>
               </h3>
               
               <p>NeedRuntimeType ensures that a runtime type descriptor is emitted for t.</p>
               
               <pre><code>func NeedRuntimeType(t *types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OldMapBucketType" data-name="OldMapBucketType">
               <h3>
                  OldMapBucketType 
                  <span class="badge">function</span>
                  
                  <a href="#OldMapBucketType" class="anchor" title="Link to OldMapBucketType">#</a>
               </h3>
               
               <p>OldMapBucketType makes the map bucket type given the type of the map.</p>
               
               <pre><code>func OldMapBucketType(t *types.Type) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OldMapIterType" data-name="OldMapIterType">
               <h3>
                  OldMapIterType 
                  <span class="badge">function</span>
                  
                  <a href="#OldMapIterType" class="anchor" title="Link to OldMapIterType">#</a>
               </h3>
               
               <p>OldMapIterType returns a type interchangeable with runtime.hiter.
Make sure this stays in sync with runtime/map.go.</p>
               
               <pre><code>func OldMapIterType() *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OldMapType" data-name="OldMapType">
               <h3>
                  OldMapType 
                  <span class="badge">function</span>
                  
                  <a href="#OldMapType" class="anchor" title="Link to OldMapType">#</a>
               </h3>
               
               <p>OldMapType returns a type interchangeable with runtime.hmap.
Make sure this stays in sync with runtime/map.go.</p>
               
               <pre><code>func OldMapType() *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RangeMapRType" data-name="RangeMapRType">
               <h3>
                  RangeMapRType 
                  <span class="badge">function</span>
                  
                  <a href="#RangeMapRType" class="anchor" title="Link to RangeMapRType">#</a>
               </h3>
               
               <p>RangeMapRType asserts that n is a "range" loop over a map value,
and returns an expression that yields the *runtime._type value
representing that map type.</p>
               
               <pre><code>func RangeMapRType(pos src.XPos, n *ir.RangeStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SwissMapGroupType" data-name="SwissMapGroupType">
               <h3>
                  SwissMapGroupType 
                  <span class="badge">function</span>
                  
                  <a href="#SwissMapGroupType" class="anchor" title="Link to SwissMapGroupType">#</a>
               </h3>
               
               <p>SwissMapGroupType makes the map slot group type given the type of the map.</p>
               
               <pre><code>func SwissMapGroupType(t *types.Type) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SwissMapIterType" data-name="SwissMapIterType">
               <h3>
                  SwissMapIterType 
                  <span class="badge">function</span>
                  
                  <a href="#SwissMapIterType" class="anchor" title="Link to SwissMapIterType">#</a>
               </h3>
               
               <p>SwissMapIterType returns a type interchangeable with runtime.hiter.
Make sure this stays in sync with runtime/map.go.</p>
               
               <pre><code>func SwissMapIterType() *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SwissMapType" data-name="SwissMapType">
               <h3>
                  SwissMapType 
                  <span class="badge">function</span>
                  
                  <a href="#SwissMapType" class="anchor" title="Link to SwissMapType">#</a>
               </h3>
               
               <p>SwissMapType returns a type interchangeable with internal/runtime/maps.Map.
Make sure this stays in sync with internal/runtime/maps/map.go.</p>
               
               <pre><code>func SwissMapType() *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrackSym" data-name="TrackSym">
               <h3>
                  TrackSym 
                  <span class="badge">function</span>
                  
                  <a href="#TrackSym" class="anchor" title="Link to TrackSym">#</a>
               </h3>
               
               <p>TrackSym returns the symbol for tracking use of field/method f, assumed
to be a member of struct/interface type t.</p>
               
               <pre><code>func TrackSym(t *types.Type, f *types.Field) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeLinksym" data-name="TypeLinksym">
               <h3>
                  TypeLinksym 
                  <span class="badge">function</span>
                  
                  <a href="#TypeLinksym" class="anchor" title="Link to TypeLinksym">#</a>
               </h3>
               
               <pre><code>func TypeLinksym(t *types.Type) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeLinksymLookup" data-name="TypeLinksymLookup">
               <h3>
                  TypeLinksymLookup 
                  <span class="badge">function</span>
                  
                  <a href="#TypeLinksymLookup" class="anchor" title="Link to TypeLinksymLookup">#</a>
               </h3>
               
               <pre><code>func TypeLinksymLookup(name string) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeLinksymPrefix" data-name="TypeLinksymPrefix">
               <h3>
                  TypeLinksymPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#TypeLinksymPrefix" class="anchor" title="Link to TypeLinksymPrefix">#</a>
               </h3>
               
               <pre><code>func TypeLinksymPrefix(prefix string, t *types.Type) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypePtrAt" data-name="TypePtrAt">
               <h3>
                  TypePtrAt 
                  <span class="badge">function</span>
                  
                  <a href="#TypePtrAt" class="anchor" title="Link to TypePtrAt">#</a>
               </h3>
               
               <p>TypePtrAt returns an expression that evaluates to the
*runtime._type value for t.</p>
               
               <pre><code>func TypePtrAt(pos src.XPos, t *types.Type) *ir.AddrExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeSym" data-name="TypeSym">
               <h3>
                  TypeSym 
                  <span class="badge">function</span>
                  
                  <a href="#TypeSym" class="anchor" title="Link to TypeSym">#</a>
               </h3>
               
               <pre><code>func TypeSym(t *types.Type) *types.Sym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeSymPrefix" data-name="TypeSymPrefix">
               <h3>
                  TypeSymPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#TypeSymPrefix" class="anchor" title="Link to TypeSymPrefix">#</a>
               </h3>
               
               <pre><code>func TypeSymPrefix(prefix string, t *types.Type) *types.Sym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnsafeSliceElemRType" data-name="UnsafeSliceElemRType">
               <h3>
                  UnsafeSliceElemRType 
                  <span class="badge">function</span>
                  
                  <a href="#UnsafeSliceElemRType" class="anchor" title="Link to UnsafeSliceElemRType">#</a>
               </h3>
               
               <p>UnsafeSliceElemRType asserts that n is an "unsafe.Slice" operation,
and returns an expression that yields the *runtime._type value
representing the result slice type's element type.</p>
               
               <pre><code>func UnsafeSliceElemRType(pos src.XPos, n *ir.BinaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteBasicTypes" data-name="WriteBasicTypes">
               <h3>
                  WriteBasicTypes 
                  <span class="badge">function</span>
                  
                  <a href="#WriteBasicTypes" class="anchor" title="Link to WriteBasicTypes">#</a>
               </h3>
               
               <pre><code>func WriteBasicTypes()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteGCSymbols" data-name="WriteGCSymbols">
               <h3>
                  WriteGCSymbols 
                  <span class="badge">function</span>
                  
                  <a href="#WriteGCSymbols" class="anchor" title="Link to WriteGCSymbols">#</a>
               </h3>
               
               <pre><code>func WriteGCSymbols()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WritePluginTable" data-name="WritePluginTable">
               <h3>
                  WritePluginTable 
                  <span class="badge">function</span>
                  
                  <a href="#WritePluginTable" class="anchor" title="Link to WritePluginTable">#</a>
               </h3>
               
               <pre><code>func WritePluginTable()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteRuntimeTypes" data-name="WriteRuntimeTypes">
               <h3>
                  WriteRuntimeTypes 
                  <span class="badge">function</span>
                  
                  <a href="#WriteRuntimeTypes" class="anchor" title="Link to WriteRuntimeTypes">#</a>
               </h3>
               
               <pre><code>func WriteRuntimeTypes()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ZeroAddr" data-name="ZeroAddr">
               <h3>
                  ZeroAddr 
                  <span class="badge">function</span>
                  
                  <a href="#ZeroAddr" class="anchor" title="Link to ZeroAddr">#</a>
               </h3>
               
               <p>ZeroAddr returns the address of a symbol with at least
size bytes of zeros.</p>
               
               <pre><code>func ZeroAddr(size int64) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="anyCall" data-name="anyCall">
               <h3>
                  anyCall 
                  <span class="badge">function</span>
                  
                  <a href="#anyCall" class="anchor" title="Link to anyCall">#</a>
               </h3>
               
               <pre><code>func anyCall(fn *ir.Func) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assertOp" data-name="assertOp">
               <h3>
                  assertOp 
                  <span class="badge">function</span>
                  
                  <a href="#assertOp" class="anchor" title="Link to assertOp">#</a>
               </h3>
               
               <p>assertOp asserts that n is an op.</p>
               
               <pre><code>func assertOp(n ir.Node, op ir.Op)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assertOp2" data-name="assertOp2">
               <h3>
                  assertOp2 
                  <span class="badge">function</span>
                  
                  <a href="#assertOp2" class="anchor" title="Link to assertOp2">#</a>
               </h3>
               
               <p>assertOp2 asserts that n is an op1 or op2.</p>
               
               <pre><code>func assertOp2(n ir.Node, op1 ir.Op, op2 ir.Op)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chanRType" data-name="chanRType">
               <h3>
                  chanRType 
                  <span class="badge">function</span>
                  
                  <a href="#chanRType" class="anchor" title="Link to chanRType">#</a>
               </h3>
               
               <p>chanRType asserts that typ is a map type, and returns an expression
that yields the *runtime._type value representing typ.</p>
               
               <pre><code>func chanRType(pos src.XPos, typ *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="commonSize" data-name="commonSize">
               <h3>
                  commonSize 
                  <span class="badge">function</span>
                  
                  <a href="#commonSize" class="anchor" title="Link to commonSize">#</a>
               </h3>
               
               <pre><code>func commonSize() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="concreteRType" data-name="concreteRType">
               <h3>
                  concreteRType 
                  <span class="badge">function</span>
                  
                  <a href="#concreteRType" class="anchor" title="Link to concreteRType">#</a>
               </h3>
               
               <p>concreteRType asserts that typ is not an interface type, and
returns an expression that yields the *runtime._type value
representing typ.</p>
               
               <pre><code>func concreteRType(pos src.XPos, typ *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dcommontype" data-name="dcommontype">
               <h3>
                  dcommontype 
                  <span class="badge">function</span>
                  
                  <a href="#dcommontype" class="anchor" title="Link to dcommontype">#</a>
               </h3>
               
               <p>dcommontype dumps the contents of a reflect.rtype (runtime._type) to c.</p>
               
               <pre><code>func dcommontype(c rttype.Cursor, t *types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="deref" data-name="deref">
               <h3>
                  deref 
                  <span class="badge">function</span>
                  
                  <a href="#deref" class="anchor" title="Link to deref">#</a>
               </h3>
               
               <pre><code>func deref(t *types.Type) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dextratype" data-name="dextratype">
               <h3>
                  dextratype 
                  <span class="badge">function</span>
                  
                  <a href="#dextratype" class="anchor" title="Link to dextratype">#</a>
               </h3>
               
               <p>dextratype dumps the fields of a runtime.uncommontype.
dataAdd is the offset in bytes after the header where the
backing array of the []method field should be written.</p>
               
               <pre><code>func dextratype(lsym *obj.LSym, off int64, t *types.Type, dataAdd int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dgcptrmask" data-name="dgcptrmask">
               <h3>
                  dgcptrmask 
                  <span class="badge">function</span>
                  
                  <a href="#dgcptrmask" class="anchor" title="Link to dgcptrmask">#</a>
               </h3>
               
               <p>dgcptrmask emits and returns the symbol containing a pointer mask for type t.</p>
               
               <pre><code>func dgcptrmask(t *types.Type, write bool) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dgcptrmaskOnDemand" data-name="dgcptrmaskOnDemand">
               <h3>
                  dgcptrmaskOnDemand 
                  <span class="badge">function</span>
                  
                  <a href="#dgcptrmaskOnDemand" class="anchor" title="Link to dgcptrmaskOnDemand">#</a>
               </h3>
               
               <p>dgcptrmaskOnDemand emits and returns the symbol that should be referenced by
the GCData field of a type, for large types.</p>
               
               <pre><code>func dgcptrmaskOnDemand(t *types.Type, write bool) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dgcsym" data-name="dgcsym">
               <h3>
                  dgcsym 
                  <span class="badge">function</span>
                  
                  <a href="#dgcsym" class="anchor" title="Link to dgcsym">#</a>
               </h3>
               
               <p>dgcsym returns a data symbol containing GC information for type t, along
with a boolean reporting whether the gc mask should be computed on demand
at runtime, and the ptrdata field to record in the reflect type information.
When write is true, it writes the symbol data.</p>
               
               <pre><code>func dgcsym(t *types.Type, write bool, onDemandAllowed bool) (lsym *obj.LSym, onDemand bool, ptrdata int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dgopkgpath" data-name="dgopkgpath">
               <h3>
                  dgopkgpath 
                  <span class="badge">function</span>
                  
                  <a href="#dgopkgpath" class="anchor" title="Link to dgopkgpath">#</a>
               </h3>
               
               <pre><code>func dgopkgpath(c rttype.Cursor, pkg *types.Pkg)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dgopkgpathOff" data-name="dgopkgpathOff">
               <h3>
                  dgopkgpathOff 
                  <span class="badge">function</span>
                  
                  <a href="#dgopkgpathOff" class="anchor" title="Link to dgopkgpathOff">#</a>
               </h3>
               
               <p>dgopkgpathOff writes an offset relocation to the pkg path symbol to c.</p>
               
               <pre><code>func dgopkgpathOff(c rttype.Cursor, pkg *types.Pkg)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dimportpath" data-name="dimportpath">
               <h3>
                  dimportpath 
                  <span class="badge">function</span>
                  
                  <a href="#dimportpath" class="anchor" title="Link to dimportpath">#</a>
               </h3>
               
               <pre><code>func dimportpath(p *types.Pkg)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dmethodptrOff" data-name="dmethodptrOff">
               <h3>
                  dmethodptrOff 
                  <span class="badge">function</span>
                  
                  <a href="#dmethodptrOff" class="anchor" title="Link to dmethodptrOff">#</a>
               </h3>
               
               <pre><code>func dmethodptrOff(c rttype.Cursor, x *obj.LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dname" data-name="dname">
               <h3>
                  dname 
                  <span class="badge">function</span>
                  
                  <a href="#dname" class="anchor" title="Link to dname">#</a>
               </h3>
               
               <p>dname creates a reflect.name for a struct field or method.</p>
               
               <pre><code>func dname(name string, tag string, pkg *types.Pkg, exported bool, embedded bool) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dnameData" data-name="dnameData">
               <h3>
                  dnameData 
                  <span class="badge">function</span>
                  
                  <a href="#dnameData" class="anchor" title="Link to dnameData">#</a>
               </h3>
               
               <p>dnameData writes the contents of a reflect.name into s at offset ot.</p>
               
               <pre><code>func dnameData(s *obj.LSym, ot int, name string, tag string, pkg *types.Pkg, exported bool, embedded bool) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dnameField" data-name="dnameField">
               <h3>
                  dnameField 
                  <span class="badge">function</span>
                  
                  <a href="#dnameField" class="anchor" title="Link to dnameField">#</a>
               </h3>
               
               <p>dnameField dumps a reflect.name for a struct field.</p>
               
               <pre><code>func dnameField(c rttype.Cursor, spkg *types.Pkg, ft *types.Field)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="eqFunc" data-name="eqFunc">
               <h3>
                  eqFunc 
                  <span class="badge">function</span>
                  
                  <a href="#eqFunc" class="anchor" title="Link to eqFunc">#</a>
               </h3>
               
               <pre><code>func eqFunc(t *types.Type) *ir.Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fillptrmask" data-name="fillptrmask">
               <h3>
                  fillptrmask 
                  <span class="badge">function</span>
                  
                  <a href="#fillptrmask" class="anchor" title="Link to fillptrmask">#</a>
               </h3>
               
               <p>fillptrmask fills in ptrmask with 1s corresponding to the
word offsets in t that hold pointers.
ptrmask is assumed to fit at least types.PtrDataSize(t)/PtrSize bits.</p>
               
               <pre><code>func fillptrmask(t *types.Type, ptrmask []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formalType" data-name="formalType">
               <h3>
                  formalType 
                  <span class="badge">function</span>
                  
                  <a href="#formalType" class="anchor" title="Link to formalType">#</a>
               </h3>
               
               <p>formalType replaces predeclared aliases with real types.
They've been separate internally to make error messages
better, but we have to merge them in the reflect tables.</p>
               
               <pre><code>func formalType(t *types.Type) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="geneq" data-name="geneq">
               <h3>
                  geneq 
                  <span class="badge">function</span>
                  
                  <a href="#geneq" class="anchor" title="Link to geneq">#</a>
               </h3>
               
               <p>geneq returns a symbol which is the closure used to compute
equality for two objects of type t.</p>
               
               <pre><code>func geneq(t *types.Type) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="genhash" data-name="genhash">
               <h3>
                  genhash 
                  <span class="badge">function</span>
                  
                  <a href="#genhash" class="anchor" title="Link to genhash">#</a>
               </h3>
               
               <p>genhash returns a symbol which is the closure used to compute
the hash of a value of type t.
Note: the generated function must match runtime.typehash exactly.</p>
               
               <pre><code>func genhash(t *types.Type) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasRType" data-name="hasRType">
               <h3>
                  hasRType 
                  <span class="badge">function</span>
                  
                  <a href="#hasRType" class="anchor" title="Link to hasRType">#</a>
               </h3>
               
               <pre><code>func hasRType(n ir.Node, rtype ir.Node, fieldName string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashFunc" data-name="hashFunc">
               <h3>
                  hashFunc 
                  <span class="badge">function</span>
                  
                  <a href="#hashFunc" class="anchor" title="Link to hashFunc">#</a>
               </h3>
               
               <pre><code>func hashFunc(t *types.Type) *ir.Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashMightPanic" data-name="hashMightPanic">
               <h3>
                  hashMightPanic 
                  <span class="badge">function</span>
                  
                  <a href="#hashMightPanic" class="anchor" title="Link to hashMightPanic">#</a>
               </h3>
               
               <p>hashMightPanic reports whether the hash of a map key of type t might panic.</p>
               
               <pre><code>func hashMightPanic(t *types.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashfor" data-name="hashfor">
               <h3>
                  hashfor 
                  <span class="badge">function</span>
                  
                  <a href="#hashfor" class="anchor" title="Link to hashfor">#</a>
               </h3>
               
               <p>hashfor returns the function to compute the hash of a value of type t.</p>
               
               <pre><code>func hashfor(t *types.Type) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashmem" data-name="hashmem">
               <h3>
                  hashmem 
                  <span class="badge">function</span>
                  
                  <a href="#hashmem" class="anchor" title="Link to hashmem">#</a>
               </h3>
               
               <pre><code>func hashmem(t *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="imethods" data-name="imethods">
               <h3>
                  imethods 
                  <span class="badge">function</span>
                  
                  <a href="#imethods" class="anchor" title="Link to imethods">#</a>
               </h3>
               
               <p>imethods returns the methods of the interface type t, sorted by name.</p>
               
               <pre><code>func imethods(t *types.Type) []*typeSig</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="kindRType" data-name="kindRType">
               <h3>
                  kindRType 
                  <span class="badge">function</span>
                  
                  <a href="#kindRType" class="anchor" title="Link to kindRType">#</a>
               </h3>
               
               <p>kindRType asserts that typ has the given kind, and returns an
expression that yields the *runtime._type value representing typ.</p>
               
               <pre><code>func kindRType(pos src.XPos, typ *types.Type, k types.Kind) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makefield" data-name="makefield">
               <h3>
                  makefield 
                  <span class="badge">function</span>
                  
                  <a href="#makefield" class="anchor" title="Link to makefield">#</a>
               </h3>
               
               <pre><code>func makefield(name string, t *types.Type) *types.Field</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapRType" data-name="mapRType">
               <h3>
                  mapRType 
                  <span class="badge">function</span>
                  
                  <a href="#mapRType" class="anchor" title="Link to mapRType">#</a>
               </h3>
               
               <p>mapRType asserts that typ is a map type, and returns an expression
that yields the *runtime._type value representing typ.</p>
               
               <pre><code>func mapRType(pos src.XPos, typ *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="methodWrapper" data-name="methodWrapper">
               <h3>
                  methodWrapper 
                  <span class="badge">function</span>
                  
                  <a href="#methodWrapper" class="anchor" title="Link to methodWrapper">#</a>
               </h3>
               
               <p>Generate a wrapper function to convert from
a receiver of type T to a receiver of type U.
That is,
func (t T) M() {
...
}
already exists; this function generates
func (u U) M() {
u.M()
}
where the types T and U are such that u.M() is valid
and calls the T.M method.
The resulting function is for use in method tables.
rcvr - U
method - M func (t T)(), a TFIELD type struct
Also wraps methods on instantiated generic types for use in itab entries.
For an instantiated generic type G[int], we generate wrappers like:
G[int] pointer shaped:
func (x G[int]) f(arg) {
.inst.G[int].f(dictionary, x, arg)
}
G[int] not pointer shaped:
func (x *G[int]) f(arg) {
.inst.G[int].f(dictionary, *x, arg)
}
These wrappers are always fully stenciled.</p>
               
               <pre><code>func methodWrapper(rcvr *types.Type, method *types.Field, forItab bool) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="methods" data-name="methods">
               <h3>
                  methods 
                  <span class="badge">function</span>
                  
                  <a href="#methods" class="anchor" title="Link to methods">#</a>
               </h3>
               
               <p>methods returns the methods of the non-interface type t, sorted by name.
Generates stub functions as needed.</p>
               
               <pre><code>func methods(t *types.Type) []*typeSig</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="needkeyupdate" data-name="needkeyupdate">
               <h3>
                  needkeyupdate 
                  <span class="badge">function</span>
                  
                  <a href="#needkeyupdate" class="anchor" title="Link to needkeyupdate">#</a>
               </h3>
               
               <p>needkeyupdate reports whether map updates with t as a key
need the key to be updated.</p>
               
               <pre><code>func needkeyupdate(t *types.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtimeHashFor" data-name="runtimeHashFor">
               <h3>
                  runtimeHashFor 
                  <span class="badge">function</span>
                  
                  <a href="#runtimeHashFor" class="anchor" title="Link to runtimeHashFor">#</a>
               </h3>
               
               <pre><code>func runtimeHashFor(name string, t *types.Type) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sliceElemRType" data-name="sliceElemRType">
               <h3>
                  sliceElemRType 
                  <span class="badge">function</span>
                  
                  <a href="#sliceElemRType" class="anchor" title="Link to sliceElemRType">#</a>
               </h3>
               
               <p>sliceElemRType asserts that typ is a slice type, and returns an
expression that yields the *runtime._type value representing typ's
element type.</p>
               
               <pre><code>func sliceElemRType(pos src.XPos, typ *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="swissTableType" data-name="swissTableType">
               <h3>
                  swissTableType 
                  <span class="badge">function</span>
                  
                  <a href="#swissTableType" class="anchor" title="Link to swissTableType">#</a>
               </h3>
               
               <p>swissTableType returns a type interchangeable with internal/runtime/maps.table.
Make sure this stays in sync with internal/runtime/maps/table.go.</p>
               
               <pre><code>func swissTableType() *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sysClosure" data-name="sysClosure">
               <h3>
                  sysClosure 
                  <span class="badge">function</span>
                  
                  <a href="#sysClosure" class="anchor" title="Link to sysClosure">#</a>
               </h3>
               
               <p>sysClosure returns a closure which will call the
given runtime function (with no closed-over variables).</p>
               
               <pre><code>func sysClosure(name string) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typePkg" data-name="typePkg">
               <h3>
                  typePkg 
                  <span class="badge">function</span>
                  
                  <a href="#typePkg" class="anchor" title="Link to typePkg">#</a>
               </h3>
               
               <pre><code>func typePkg(t *types.Type) *types.Pkg</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typesStrCmp" data-name="typesStrCmp">
               <h3>
                  typesStrCmp 
                  <span class="badge">function</span>
                  
                  <a href="#typesStrCmp" class="anchor" title="Link to typesStrCmp">#</a>
               </h3>
               
               <pre><code>func typesStrCmp(a typeAndStr, b typeAndStr) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uncommonSize" data-name="uncommonSize">
               <h3>
                  uncommonSize 
                  <span class="badge">function</span>
                  
                  <a href="#uncommonSize" class="anchor" title="Link to uncommonSize">#</a>
               </h3>
               
               <pre><code>func uncommonSize(t *types.Type) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeITab" data-name="writeITab">
               <h3>
                  writeITab 
                  <span class="badge">function</span>
                  
                  <a href="#writeITab" class="anchor" title="Link to writeITab">#</a>
               </h3>
               
               <p>writeITab writes the itab for concrete type typ implementing interface iface. If
allowNonImplement is true, allow the case where typ does not implement iface, and just
create a dummy itab with zeroed-out method entries.</p>
               
               <pre><code>func writeITab(lsym *obj.LSym, typ *types.Type, iface *types.Type, allowNonImplement bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeOldMapType" data-name="writeOldMapType">
               <h3>
                  writeOldMapType 
                  <span class="badge">function</span>
                  
                  <a href="#writeOldMapType" class="anchor" title="Link to writeOldMapType">#</a>
               </h3>
               
               <pre><code>func writeOldMapType(t *types.Type, lsym *obj.LSym, c rttype.Cursor)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeSwissMapType" data-name="writeSwissMapType">
               <h3>
                  writeSwissMapType 
                  <span class="badge">function</span>
                  
                  <a href="#writeSwissMapType" class="anchor" title="Link to writeSwissMapType">#</a>
               </h3>
               
               <pre><code>func writeSwissMapType(t *types.Type, lsym *obj.LSym, c rttype.Cursor)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeType" data-name="writeType">
               <h3>
                  writeType 
                  <span class="badge">function</span>
                  
                  <a href="#writeType" class="anchor" title="Link to writeType">#</a>
               </h3>
               
               <pre><code>func writeType(t *types.Type) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writtenByWriteBasicTypes" data-name="writtenByWriteBasicTypes">
               <h3>
                  writtenByWriteBasicTypes 
                  <span class="badge">function</span>
                  
                  <a href="#writtenByWriteBasicTypes" class="anchor" title="Link to writtenByWriteBasicTypes">#</a>
               </h3>
               
               <p>writtenByWriteBasicTypes reports whether typ is written by WriteBasicTypes.
WriteBasicTypes always writes pointer types; any pointer has been stripped off typ already.</p>
               
               <pre><code>func writtenByWriteBasicTypes(typ *types.Type) bool</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>