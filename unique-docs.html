<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - unique</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>unique</code>
         </h1>
         <hr />
         
         <article class="global" data-name="singleStringClone">
            <h2>singleStringClone</h2>
            <hr />
            
            <p>singleStringClone describes how to clone a single string.</p>
            
            <pre><code>singleStringClone</code></pre>
         </article>
         
         <article class="global" data-name="zero">
            <h2>zero</h2>
            <hr />
            
            <pre><code>zero uintptr</code></pre>
         </article>
         
         <article class="global" data-name="uniqueMaps">
            <h2>uniqueMaps</h2>
            <hr />
            
            <p>uniqueMaps is an index of type-specific concurrent maps used for unique.Make.

The two-level map might seem odd at first since the HashTrieMap could have "any"
as its key type, but the issue is escape analysis. We do not want to force lookups
to escape the argument, and using a type-specific map allows us to avoid that where
possible (for example, for strings and plain-ol'-data structs). We also get the
benefit of not cramming every different type into a single map, but that's certainly
not enough to outweigh the cost of two map lookups. What is worth it though, is saving
on those allocations.</p>
            
            <pre><code>uniqueMaps *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="cleanupMu">
            <h2>cleanupMu</h2>
            <hr />
            
            <p>cleanupFuncs are functions that clean up dead weak pointers in type-specific
maps in uniqueMaps. We express cleanup this way because there's no way to iterate
over the sync.Map and call functions on the type-specific data structures otherwise.
These cleanup funcs each close over one of these type-specific maps.

cleanupMu protects cleanupNotify and is held across the entire cleanup. Used for testing.
cleanupNotify is a test-only mechanism that allow tests to wait for the cleanup to run.</p>
            
            <pre><code>cleanupMu sync.Mutex</code></pre>
         </article>
         
         <article class="global" data-name="cleanupFuncsMu">
            <h2>cleanupFuncsMu</h2>
            <hr />
            
            <pre><code>cleanupFuncsMu sync.Mutex</code></pre>
         </article>
         
         <article class="global" data-name="cleanupFuncs">
            <h2>cleanupFuncs</h2>
            <hr />
            
            <pre><code>cleanupFuncs []func</code></pre>
         </article>
         
         <article class="global" data-name="cleanupNotify">
            <h2>cleanupNotify</h2>
            <hr />
            
            <pre><code>cleanupNotify []func</code></pre>
         </article>
         
         <article class="global" data-name="setupMake">
            <h2>setupMake</h2>
            <hr />
            
            <p>setupMake is used to perform initial setup for unique.Make.</p>
            
            <pre><code>setupMake sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="testData">
            <h2>testData</h2>
            <hr />
            
            <pre><code>testData []string</code></pre>
         </article>
         
         <article class="global" data-name="testDataLarge">
            <h2>testDataLarge</h2>
            <hr />
            
            <pre><code>testDataLarge []string</code></pre>
         </article>
          
         <article class="struct" data-name="testStringStruct">
            <h2>type testStringStruct struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">a string</code></pre>
         </article>
         
         <article class="struct" data-name="testStringStructArrayStruct">
            <h2>type testStringStructArrayStruct struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">s []testStringStruct</code></pre>
         </article>
         
         <article class="struct" data-name="testStruct">
            <h2>type testStruct struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">z float64
b string</code></pre>
         </article>
         
         <article class="struct" data-name="testZeroSize">
            <h2>type testZeroSize struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="cloneSeq">
            <h2>type cloneSeq struct</h2>
            <hr />
            
            <p>cloneSeq describes how to clone a value of a particular type.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">stringOffsets []uintptr</code></pre>
         </article>
         
         <article class="struct" data-name="Handle">
            <h2>type Handle struct</h2>
            <hr />
            
            <p>Handle is a globally unique identity for some value of type T.

Two handles compare equal exactly if the two values used to create the handles
would have also compared equal. The comparison of two handles is trivial and
typically much more efficient than comparing the values used to create them.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">value *T</code></pre>
         </article>
         
         <article class="struct" data-name="uniqueMap">
            <h2>type uniqueMap struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">*ast.IndexListExpr
cloneSeq</code></pre>
         </article>
          
         <article class="function" data-name="TestHandle">
            <h2>TestHandle</h2>
            <hr />
            
            <pre><code>func TestHandle(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testHandle">
            <h2>testHandle</h2>
            <hr />
            
            <pre><code>func testHandle(t *testing.T, value T)</code></pre>
         </article>
         
         <article class="function" data-name="drainMaps">
            <h2>drainMaps</h2>
            <hr />
            
            <p>drainMaps ensures that the internal maps are drained.</p>
            
            <pre><code>func drainMaps(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="checkMapsFor">
            <h2>checkMapsFor</h2>
            <hr />
            
            <pre><code>func checkMapsFor(t *testing.T, value T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMakeClonesStrings">
            <h2>TestMakeClonesStrings</h2>
            <hr />
            
            <pre><code>func TestMakeClonesStrings(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestHandleUnsafeString">
            <h2>TestHandleUnsafeString</h2>
            <hr />
            
            <pre><code>func TestHandleUnsafeString(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="clone">
            <h2>clone</h2>
            <hr />
            
            <p>clone makes a copy of value, and may update string values found in value
with a cloned version of those strings. The purpose of explicitly cloning
strings is to avoid accidentally giving a large string a long lifetime.

Note that this will clone strings in structs and arrays found in value,
and will clone value if it itself is a string. It will not, however, clone
strings if value is of interface or slice type (that is, found via an
indirection).</p>
            
            <pre><code>func clone(value T, seq *cloneSeq) T</code></pre>
         </article>
         
         <article class="function" data-name="makeCloneSeq">
            <h2>makeCloneSeq</h2>
            <hr />
            
            <p>makeCloneSeq creates a cloneSeq for a type.</p>
            
            <pre><code>func makeCloneSeq(typ *abi.Type) cloneSeq</code></pre>
         </article>
         
         <article class="function" data-name="buildStructCloneSeq">
            <h2>buildStructCloneSeq</h2>
            <hr />
            
            <p>buildStructCloneSeq populates a cloneSeq for an abi.Type that has Kind abi.Struct.</p>
            
            <pre><code>func buildStructCloneSeq(typ *abi.Type, seq *cloneSeq, baseOffset uintptr)</code></pre>
         </article>
         
         <article class="function" data-name="buildArrayCloneSeq">
            <h2>buildArrayCloneSeq</h2>
            <hr />
            
            <p>buildArrayCloneSeq populates a cloneSeq for an abi.Type that has Kind abi.Array.</p>
            
            <pre><code>func buildArrayCloneSeq(typ *abi.Type, seq *cloneSeq, baseOffset uintptr)</code></pre>
         </article>
         
         <article class="function" data-name="TestMakeCloneSeq">
            <h2>TestMakeCloneSeq</h2>
            <hr />
            
            <pre><code>func TestMakeCloneSeq(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="cSeq">
            <h2>cSeq</h2>
            <hr />
            
            <pre><code>func cSeq(stringOffsets ...uintptr) cloneSeq</code></pre>
         </article>
         
         <article class="function" data-name="testCloneSeq">
            <h2>testCloneSeq</h2>
            <hr />
            
            <pre><code>func testCloneSeq(t *testing.T, want cloneSeq)</code></pre>
         </article>
         
         <article class="function" data-name="Value">
            <h2>Value</h2>
            <hr />
            
            <p>Value returns a shallow copy of the T value that produced the Handle.
Value is safe for concurrent use by multiple goroutines.</p>
            
            <pre><code>func Value() T</code></pre>
         </article>
         
         <article class="function" data-name="Make">
            <h2>Make</h2>
            <hr />
            
            <p>Make returns a globally unique handle for a value of type T. Handles
are equal if and only if the values used to produce them are equal.
Make is safe for concurrent use by multiple goroutines.</p>
            
            <pre><code>func Make(value T) *ast.IndexExpr</code></pre>
         </article>
         
         <article class="function" data-name="addUniqueMap">
            <h2>addUniqueMap</h2>
            <hr />
            
            <pre><code>func addUniqueMap(typ *abi.Type) **ast.IndexExpr</code></pre>
         </article>
         
         <article class="function" data-name="registerCleanup">
            <h2>registerCleanup</h2>
            <hr />
            
            <p>startBackgroundCleanup sets up a background goroutine to occasionally call cleanupFuncs.</p>
            
            <pre><code>func registerCleanup()</code></pre>
         </article>
         
         <article class="function" data-name="runtime_registerUniqueMapCleanup">
            <h2>runtime_registerUniqueMapCleanup</h2>
            <hr />
            
            <pre><code>func runtime_registerUniqueMapCleanup(cleanup func)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkMake">
            <h2>BenchmarkMake</h2>
            <hr />
            
            <pre><code>func BenchmarkMake(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkMakeMany">
            <h2>BenchmarkMakeMany</h2>
            <hr />
            
            <pre><code>func BenchmarkMakeMany(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkMakeManyMany">
            <h2>BenchmarkMakeManyMany</h2>
            <hr />
            
            <pre><code>func BenchmarkMakeManyMany(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="benchmarkMake">
            <h2>benchmarkMake</h2>
            <hr />
            
            <pre><code>func benchmarkMake(b *testing.B, testData []string)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
