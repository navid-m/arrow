<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - staticinit</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>staticinit</code>
         </h1>
         <hr />
         
         <article class="global" data-name="varToMapInit">
            <h2>varToMapInit</h2>
            <hr />
            
            <p>varToMapInit holds book-keeping state for global map initialization;
it records the init function created by the compiler to host the
initialization code for the map in question.</p>
            
            <pre><code>varToMapInit *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="MapInitToVar">
            <h2>MapInitToVar</h2>
            <hr />
            
            <p>MapInitToVar is the inverse of VarToMapInit; it maintains a mapping
from a compiler-generated init function to the map the function is
initializing.</p>
            
            <pre><code>MapInitToVar *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="statuniqgen">
            <h2>statuniqgen</h2>
            <hr />
            
            <pre><code>statuniqgen int</code></pre>
         </article>
         
         <article class="global" data-name="wrapGlobalMapInitSizeThreshold">
            <h2>wrapGlobalMapInitSizeThreshold</h2>
            <hr />
            
            <pre><code>wrapGlobalMapInitSizeThreshold</code></pre>
         </article>
         
         <article class="global" data-name="mapinitgen">
            <h2>mapinitgen</h2>
            <hr />
            
            <p>mapinitgen is a counter used to uniquify compiler-generated
map init functions.</p>
            
            <pre><code>mapinitgen int</code></pre>
         </article>
          
         <article class="struct" data-name="Entry">
            <h2>type Entry struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Xoffset int64
Expr ir.Node</code></pre>
         </article>
         
         <article class="struct" data-name="Plan">
            <h2>type Plan struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">E []Entry</code></pre>
         </article>
         
         <article class="struct" data-name="Schedule">
            <h2>type Schedule struct</h2>
            <hr />
            
            <p>An Schedule is used to decompose assignment statements into
static and dynamic initialization parts. Static initializations are
handled by populating variables' linker symbol data, while dynamic
initializations are accumulated to be executed in order.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Out []ir.Node
Plans *ast.MapType
Temps *ast.MapType
seenMutation bool</code></pre>
         </article>
          
         <article class="function" data-name="append">
            <h2>append</h2>
            <hr />
            
            <pre><code>func append(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="StaticInit">
            <h2>StaticInit</h2>
            <hr />
            
            <p>StaticInit adds an initialization statement n to the schedule.</p>
            
            <pre><code>func StaticInit(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="recordFuncForVar">
            <h2>recordFuncForVar</h2>
            <hr />
            
            <p>recordFuncForVar establishes a mapping between global map var "v" and
outlined init function "fn" (and vice versa); so that we can use
the mappings later on to update relocations.</p>
            
            <pre><code>func recordFuncForVar(v *ir.Name, fn *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="allBlank">
            <h2>allBlank</h2>
            <hr />
            
            <p>allBlank reports whether every node in exprs is blank.</p>
            
            <pre><code>func allBlank(exprs []ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="tryStaticInit">
            <h2>tryStaticInit</h2>
            <hr />
            
            <p>tryStaticInit attempts to statically execute an initialization
statement and reports whether it succeeded.</p>
            
            <pre><code>func tryStaticInit(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="staticcopy">
            <h2>staticcopy</h2>
            <hr />
            
            <p>like staticassign but we are copying an already
initialized value r.</p>
            
            <pre><code>func staticcopy(l *ir.Name, loff int64, rn *ir.Name, typ *types.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="StaticAssign">
            <h2>StaticAssign</h2>
            <hr />
            
            <pre><code>func StaticAssign(l *ir.Name, loff int64, r ir.Node, typ *types.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="initplan">
            <h2>initplan</h2>
            <hr />
            
            <pre><code>func initplan(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="addvalue">
            <h2>addvalue</h2>
            <hr />
            
            <pre><code>func addvalue(p *Plan, xoffset int64, n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="staticAssignInlinedCall">
            <h2>staticAssignInlinedCall</h2>
            <hr />
            
            <pre><code>func staticAssignInlinedCall(l *ir.Name, loff int64, call *ir.InlinedCallExpr, typ *types.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="StaticName">
            <h2>StaticName</h2>
            <hr />
            
            <p>StaticName returns a name backed by a (writable) static data symbol.</p>
            
            <pre><code>func StaticName(t *types.Type) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="StaticLoc">
            <h2>StaticLoc</h2>
            <hr />
            
            <p>StaticLoc returns the static address of n, if n has one, or else nil.</p>
            
            <pre><code>func StaticLoc(n ir.Node) (name *ir.Name, offset int64, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="isSideEffect">
            <h2>isSideEffect</h2>
            <hr />
            
            <pre><code>func isSideEffect(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="AnySideEffects">
            <h2>AnySideEffects</h2>
            <hr />
            
            <p>AnySideEffects reports whether n contains any operations that could have observable side effects.</p>
            
            <pre><code>func AnySideEffects(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="mayModifyPkgVar">
            <h2>mayModifyPkgVar</h2>
            <hr />
            
            <p>mayModifyPkgVar reports whether expression n may modify any
package-scope variables declared within the current package.</p>
            
            <pre><code>func mayModifyPkgVar(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="canRepeat">
            <h2>canRepeat</h2>
            <hr />
            
            <p>canRepeat reports whether executing n multiple times has the same effect as
assigning n to a single variable and using that variable multiple times.</p>
            
            <pre><code>func canRepeat(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="getlit">
            <h2>getlit</h2>
            <hr />
            
            <pre><code>func getlit(lit ir.Node) int</code></pre>
         </article>
         
         <article class="function" data-name="isvaluelit">
            <h2>isvaluelit</h2>
            <hr />
            
            <pre><code>func isvaluelit(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="subst">
            <h2>subst</h2>
            <hr />
            
            <pre><code>func subst(n ir.Node, m *ast.MapType) (ir.Node, bool)</code></pre>
         </article>
         
         <article class="function" data-name="truncate">
            <h2>truncate</h2>
            <hr />
            
            <p>truncate returns the result of force converting c to type t,
truncating its value as needed, like a conversion of a variable.
If the conversion is too difficult, truncate returns nil, false.</p>
            
            <pre><code>func truncate(c ir.Node, t *types.Type) (ir.Node, bool)</code></pre>
         </article>
         
         <article class="function" data-name="addStr">
            <h2>addStr</h2>
            <hr />
            
            <pre><code>func addStr(n *ir.AddStringExpr) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="tryWrapGlobalInit">
            <h2>tryWrapGlobalInit</h2>
            <hr />
            
            <p>tryWrapGlobalInit returns a new outlined function to contain global
initializer statement n, if possible and worthwhile. Otherwise, it
returns nil.

Currently, it outlines map assignment statements with large,
side-effect-free RHS expressions.</p>
            
            <pre><code>func tryWrapGlobalInit(n ir.Node) *ir.Func</code></pre>
         </article>
         
         <article class="function" data-name="AddKeepRelocations">
            <h2>AddKeepRelocations</h2>
            <hr />
            
            <p>AddKeepRelocations adds a dummy "R_KEEP" relocation from each
global map variable V to its associated outlined init function.
These relocation ensure that if the map var itself is determined to
be reachable at link time, we also mark the init function as
reachable.</p>
            
            <pre><code>func AddKeepRelocations()</code></pre>
         </article>
         
         <article class="function" data-name="OutlineMapInits">
            <h2>OutlineMapInits</h2>
            <hr />
            
            <p>OutlineMapInits replaces global map initializers with outlined
calls to separate "map init" functions (where possible and
profitable), to facilitate better dead-code elimination by the
linker.</p>
            
            <pre><code>func OutlineMapInits(fn *ir.Func)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
