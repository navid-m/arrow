<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - staticinit</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>staticinit</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"fmt"
"go/constant"
"go/token"
"os"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/staticdata"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="MapInitToVar" data-name="MapInitToVar">
               <h3>
                  MapInitToVar 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#MapInitToVar" class="anchor" title="Link to MapInitToVar">#</a>
               </h3>
               
               <p>MapInitToVar is the inverse of VarToMapInit; it maintains a mapping
from a compiler-generated init function to the map the function is
initializing.</p>
               
               <pre><code>var MapInitToVar map[*ir.Func]*ir.Name</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapinitgen" data-name="mapinitgen">
               <h3>
                  mapinitgen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#mapinitgen" class="anchor" title="Link to mapinitgen">#</a>
               </h3>
               
               <p>mapinitgen is a counter used to uniquify compiler-generated
map init functions.</p>
               
               <pre><code>var mapinitgen int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="statuniqgen" data-name="statuniqgen">
               <h3>
                  statuniqgen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#statuniqgen" class="anchor" title="Link to statuniqgen">#</a>
               </h3>
               
               <pre><code>var statuniqgen int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="varToMapInit" data-name="varToMapInit">
               <h3>
                  varToMapInit 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#varToMapInit" class="anchor" title="Link to varToMapInit">#</a>
               </h3>
               
               <p>varToMapInit holds book-keeping state for global map initialization;
it records the init function created by the compiler to host the
initialization code for the map in question.</p>
               
               <pre><code>var varToMapInit map[*ir.Name]*ir.Func</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="wrapGlobalMapInitSizeThreshold" data-name="wrapGlobalMapInitSizeThreshold">
               <h3>
                  wrapGlobalMapInitSizeThreshold 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#wrapGlobalMapInitSizeThreshold" class="anchor" title="Link to wrapGlobalMapInitSizeThreshold">#</a>
               </h3>
               
               <pre><code>const wrapGlobalMapInitSizeThreshold = 20</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Entry" data-name="Entry">
               <h3>
                  Entry
                  <span class="badge">struct</span>
                  <a href="#Entry" class="anchor" title="Link to Entry">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Entry struct {
Xoffset int64
Expr ir.Node
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Plan" data-name="Plan">
               <h3>
                  Plan
                  <span class="badge">struct</span>
                  <a href="#Plan" class="anchor" title="Link to Plan">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Plan struct {
E []Entry
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Schedule" data-name="Schedule">
               <h3>
                  Schedule
                  <span class="badge">struct</span>
                  <a href="#Schedule" class="anchor" title="Link to Schedule">#</a>
               </h3>
               
               <p>An Schedule is used to decompose assignment statements into
static and dynamic initialization parts. Static initializations are
handled by populating variables' linker symbol data, while dynamic
initializations are accumulated to be executed in order.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Schedule struct {
Out []ir.Node
Plans map[ir.Node]*Plan
Temps map[ir.Node]*ir.Name
seenMutation bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AddKeepRelocations" data-name="AddKeepRelocations">
               <h3>
                  AddKeepRelocations 
                  <span class="badge">function</span>
                  
                  <a href="#AddKeepRelocations" class="anchor" title="Link to AddKeepRelocations">#</a>
               </h3>
               
               <p>AddKeepRelocations adds a dummy "R_KEEP" relocation from each
global map variable V to its associated outlined init function.
These relocation ensure that if the map var itself is determined to
be reachable at link time, we also mark the init function as
reachable.</p>
               
               <pre><code>func AddKeepRelocations()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AnySideEffects" data-name="AnySideEffects">
               <h3>
                  AnySideEffects 
                  <span class="badge">function</span>
                  
                  <a href="#AnySideEffects" class="anchor" title="Link to AnySideEffects">#</a>
               </h3>
               
               <p>AnySideEffects reports whether n contains any operations that could have observable side effects.</p>
               
               <pre><code>func AnySideEffects(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OutlineMapInits" data-name="OutlineMapInits">
               <h3>
                  OutlineMapInits 
                  <span class="badge">function</span>
                  
                  <a href="#OutlineMapInits" class="anchor" title="Link to OutlineMapInits">#</a>
               </h3>
               
               <p>OutlineMapInits replaces global map initializers with outlined
calls to separate "map init" functions (where possible and
profitable), to facilitate better dead-code elimination by the
linker.</p>
               
               <pre><code>func OutlineMapInits(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StaticAssign" data-name="StaticAssign">
               <h3>
                  StaticAssign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StaticAssign" class="anchor" title="Link to StaticAssign">#</a>
               </h3>
               
               <pre><code>func (s *Schedule) StaticAssign(l *ir.Name, loff int64, r ir.Node, typ *types.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StaticInit" data-name="StaticInit">
               <h3>
                  StaticInit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StaticInit" class="anchor" title="Link to StaticInit">#</a>
               </h3>
               
               <p>StaticInit adds an initialization statement n to the schedule.</p>
               
               <pre><code>func (s *Schedule) StaticInit(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StaticLoc" data-name="StaticLoc">
               <h3>
                  StaticLoc 
                  <span class="badge">function</span>
                  
                  <a href="#StaticLoc" class="anchor" title="Link to StaticLoc">#</a>
               </h3>
               
               <p>StaticLoc returns the static address of n, if n has one, or else nil.</p>
               
               <pre><code>func StaticLoc(n ir.Node) (name *ir.Name, offset int64, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StaticName" data-name="StaticName">
               <h3>
                  StaticName 
                  <span class="badge">function</span>
                  
                  <a href="#StaticName" class="anchor" title="Link to StaticName">#</a>
               </h3>
               
               <p>StaticName returns a name backed by a (writable) static data symbol.</p>
               
               <pre><code>func StaticName(t *types.Type) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addStr" data-name="addStr">
               <h3>
                  addStr 
                  <span class="badge">function</span>
                  
                  <a href="#addStr" class="anchor" title="Link to addStr">#</a>
               </h3>
               
               <pre><code>func addStr(n *ir.AddStringExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addvalue" data-name="addvalue">
               <h3>
                  addvalue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addvalue" class="anchor" title="Link to addvalue">#</a>
               </h3>
               
               <pre><code>func (s *Schedule) addvalue(p *Plan, xoffset int64, n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allBlank" data-name="allBlank">
               <h3>
                  allBlank 
                  <span class="badge">function</span>
                  
                  <a href="#allBlank" class="anchor" title="Link to allBlank">#</a>
               </h3>
               
               <p>allBlank reports whether every node in exprs is blank.</p>
               
               <pre><code>func allBlank(exprs []ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="append" data-name="append">
               <h3>
                  append 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#append" class="anchor" title="Link to append">#</a>
               </h3>
               
               <pre><code>func (s *Schedule) append(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canRepeat" data-name="canRepeat">
               <h3>
                  canRepeat 
                  <span class="badge">function</span>
                  
                  <a href="#canRepeat" class="anchor" title="Link to canRepeat">#</a>
               </h3>
               
               <p>canRepeat reports whether executing n multiple times has the same effect as
assigning n to a single variable and using that variable multiple times.</p>
               
               <pre><code>func canRepeat(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getlit" data-name="getlit">
               <h3>
                  getlit 
                  <span class="badge">function</span>
                  
                  <a href="#getlit" class="anchor" title="Link to getlit">#</a>
               </h3>
               
               <pre><code>func getlit(lit ir.Node) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initplan" data-name="initplan">
               <h3>
                  initplan 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initplan" class="anchor" title="Link to initplan">#</a>
               </h3>
               
               <pre><code>func (s *Schedule) initplan(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isSideEffect" data-name="isSideEffect">
               <h3>
                  isSideEffect 
                  <span class="badge">function</span>
                  
                  <a href="#isSideEffect" class="anchor" title="Link to isSideEffect">#</a>
               </h3>
               
               <pre><code>func isSideEffect(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isvaluelit" data-name="isvaluelit">
               <h3>
                  isvaluelit 
                  <span class="badge">function</span>
                  
                  <a href="#isvaluelit" class="anchor" title="Link to isvaluelit">#</a>
               </h3>
               
               <pre><code>func isvaluelit(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mayModifyPkgVar" data-name="mayModifyPkgVar">
               <h3>
                  mayModifyPkgVar 
                  <span class="badge">function</span>
                  
                  <a href="#mayModifyPkgVar" class="anchor" title="Link to mayModifyPkgVar">#</a>
               </h3>
               
               <p>mayModifyPkgVar reports whether expression n may modify any
package-scope variables declared within the current package.</p>
               
               <pre><code>func mayModifyPkgVar(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordFuncForVar" data-name="recordFuncForVar">
               <h3>
                  recordFuncForVar 
                  <span class="badge">function</span>
                  
                  <a href="#recordFuncForVar" class="anchor" title="Link to recordFuncForVar">#</a>
               </h3>
               
               <p>recordFuncForVar establishes a mapping between global map var "v" and
outlined init function "fn" (and vice versa); so that we can use
the mappings later on to update relocations.</p>
               
               <pre><code>func recordFuncForVar(v *ir.Name, fn *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staticAssignInlinedCall" data-name="staticAssignInlinedCall">
               <h3>
                  staticAssignInlinedCall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staticAssignInlinedCall" class="anchor" title="Link to staticAssignInlinedCall">#</a>
               </h3>
               
               <pre><code>func (s *Schedule) staticAssignInlinedCall(l *ir.Name, loff int64, call *ir.InlinedCallExpr, typ *types.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staticcopy" data-name="staticcopy">
               <h3>
                  staticcopy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staticcopy" class="anchor" title="Link to staticcopy">#</a>
               </h3>
               
               <p>like staticassign but we are copying an already
initialized value r.</p>
               
               <pre><code>func (s *Schedule) staticcopy(l *ir.Name, loff int64, rn *ir.Name, typ *types.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subst" data-name="subst">
               <h3>
                  subst 
                  <span class="badge">function</span>
                  
                  <a href="#subst" class="anchor" title="Link to subst">#</a>
               </h3>
               
               <pre><code>func subst(n ir.Node, m map[*ir.Name]ir.Node) (ir.Node, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="truncate" data-name="truncate">
               <h3>
                  truncate 
                  <span class="badge">function</span>
                  
                  <a href="#truncate" class="anchor" title="Link to truncate">#</a>
               </h3>
               
               <p>truncate returns the result of force converting c to type t,
truncating its value as needed, like a conversion of a variable.
If the conversion is too difficult, truncate returns nil, false.</p>
               
               <pre><code>func truncate(c ir.Node, t *types.Type) (ir.Node, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tryStaticInit" data-name="tryStaticInit">
               <h3>
                  tryStaticInit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tryStaticInit" class="anchor" title="Link to tryStaticInit">#</a>
               </h3>
               
               <p>tryStaticInit attempts to statically execute an initialization
statement and reports whether it succeeded.</p>
               
               <pre><code>func (s *Schedule) tryStaticInit(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tryWrapGlobalInit" data-name="tryWrapGlobalInit">
               <h3>
                  tryWrapGlobalInit 
                  <span class="badge">function</span>
                  
                  <a href="#tryWrapGlobalInit" class="anchor" title="Link to tryWrapGlobalInit">#</a>
               </h3>
               
               <p>tryWrapGlobalInit returns a new outlined function to contain global
initializer statement n, if possible and worthwhile. Otherwise, it
returns nil.
Currently, it outlines map assignment statements with large,
side-effect-free RHS expressions.</p>
               
               <pre><code>func tryWrapGlobalInit(n ir.Node) *ir.Func</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>