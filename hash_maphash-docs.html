<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>maphash - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>maphash</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"crypto/rand"
"errors"
"internal/byteorder"
"math/bits"
"reflect"
"internal/abi"
"internal/goarch"
"internal/goexperiment"
"unsafe"
"internal/byteorder"
"math"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="bufSize" data-name="bufSize">
               <h3>
                  bufSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bufSize" class="anchor" title="Link to bufSize">#</a>
               </h3>
               
                  <p class="doc-comment">bufSize is the size of the Hash write buffer.
The buffer ensures that writes depend only on the sequence of bytes,
not the sequence of WriteByte/Write/WriteString calls,
by always calling rthash with a full buffer (except for the tail).</p>
               
               <pre><code class="language-go">const bufSize = 128</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hashkey" data-name="hashkey">
               <h3>
                  hashkey 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#hashkey" class="anchor" title="Link to hashkey">#</a>
               </h3>
               
               <pre><code class="language-go">var hashkey [4]uint64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="m5" data-name="m5">
               <h3>
                  m5 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#m5" class="anchor" title="Link to m5">#</a>
               </h3>
               
               <pre><code class="language-go">const m5 = 0x1d8e4e27c47d124f</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="purego" data-name="purego">
               <h3>
                  purego 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#purego" class="anchor" title="Link to purego">#</a>
               </h3>
               
               <pre><code class="language-go">const purego = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="purego" data-name="purego">
               <h3>
                  purego 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#purego" class="anchor" title="Link to purego">#</a>
               </h3>
               
               <pre><code class="language-go">const purego = false</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Hash" data-name="Hash">
               <h3>
                  Hash
                  <span class="badge">struct</span>
                  <a href="#Hash" class="anchor" title="Link to Hash">#</a>
               </h3>
               
               <p>A Hash computes a seeded hash of a byte sequence.
The zero Hash is a valid Hash ready to use.
A zero Hash chooses a random seed for itself during
the first call to a Reset, Write, Seed, or Sum64 method.
For control over the seed, use SetSeed.
The computed hash values depend only on the initial seed and
the sequence of bytes provided to the Hash object, not on the way
in which the bytes are provided. For example, the three sequences
h.Write([]byte{'f','o','o'})
h.WriteByte('f'); h.WriteByte('o'); h.WriteByte('o')
h.WriteString("foo")
all have the same effect.
Hashes are intended to be collision-resistant, even for situations
where an adversary controls the byte sequences being hashed.
A Hash is not safe for concurrent use by multiple goroutines, but a Seed is.
If multiple goroutines must compute the same seeded hash,
each can declare its own Hash and call SetSeed with a common Seed.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Hash struct {
_ [0]func()
seed Seed
state Seed
buf [bufSize]byte
n int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Seed" data-name="Seed">
               <h3>
                  Seed
                  <span class="badge">struct</span>
                  <a href="#Seed" class="anchor" title="Link to Seed">#</a>
               </h3>
               
               <p>A Seed is a random value that selects the specific hash function
computed by a [Hash]. If two Hashes use the same Seeds, they
will compute the same hash values for any given input.
If two Hashes use different Seeds, they are very likely to compute
distinct hash values for any given input.
A Seed must be initialized by calling [MakeSeed].
The zero seed is uninitialized and not valid for use with [Hash]'s SetSeed method.
Each Seed value is local to a single process and cannot be serialized
or otherwise recreated in a different process.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Seed struct {
s uint64
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="BlockSize" data-name="BlockSize">
               <h3>
                  BlockSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BlockSize" class="anchor" title="Link to BlockSize">#</a>
               </h3>
               
               <p>BlockSize returns h's block size.</p>
               
               <pre><code class="language-go">func (h *Hash) BlockSize() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bytes" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge">function</span>
                  
                  <a href="#Bytes" class="anchor" title="Link to Bytes">#</a>
               </h3>
               
               <p>Bytes returns the hash of b with the given seed.
Bytes is equivalent to, but more convenient and efficient than:
var h Hash
h.SetSeed(seed)
h.Write(b)
return h.Sum64()</p>
               
               <pre><code class="language-go">func Bytes(seed Seed, b []byte) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Comparable" data-name="Comparable">
               <h3>
                  Comparable 
                  <span class="badge">function</span>
                  
                  <a href="#Comparable" class="anchor" title="Link to Comparable">#</a>
               </h3>
               
               <p>Comparable returns the hash of comparable value v with the given seed
such that Comparable(s, v1) == Comparable(s, v2) if v1 == v2.
If v != v, then the resulting hash is randomly distributed.</p>
               
               <pre><code class="language-go">func Comparable(seed Seed, v T) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MakeSeed" data-name="MakeSeed">
               <h3>
                  MakeSeed 
                  <span class="badge">function</span>
                  
                  <a href="#MakeSeed" class="anchor" title="Link to MakeSeed">#</a>
               </h3>
               
               <p>MakeSeed returns a new random seed.</p>
               
               <pre><code class="language-go">func MakeSeed() Seed</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset discards all bytes added to h.
(The seed remains the same.)</p>
               
               <pre><code class="language-go">func (h *Hash) Reset()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Seed" data-name="Seed">
               <h3>
                  Seed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Seed" class="anchor" title="Link to Seed">#</a>
               </h3>
               
               <p>Seed returns h's seed value.</p>
               
               <pre><code class="language-go">func (h *Hash) Seed() Seed</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetSeed" data-name="SetSeed">
               <h3>
                  SetSeed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetSeed" class="anchor" title="Link to SetSeed">#</a>
               </h3>
               
               <p>SetSeed sets h to use seed, which must have been returned by [MakeSeed]
or by another [Hash.Seed] method.
Two [Hash] objects with the same seed behave identically.
Two [Hash] objects with different seeds will very likely behave differently.
Any bytes added to h before this call will be discarded.</p>
               
               <pre><code class="language-go">func (h *Hash) SetSeed(seed Seed)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <p>Size returns h's hash value size, 8 bytes.</p>
               
               <pre><code class="language-go">func (h *Hash) Size() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge">function</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns the hash of s with the given seed.
String is equivalent to, but more convenient and efficient than:
var h Hash
h.SetSeed(seed)
h.WriteString(s)
return h.Sum64()</p>
               
               <pre><code class="language-go">func String(seed Seed, s string) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sum" data-name="Sum">
               <h3>
                  Sum 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sum" class="anchor" title="Link to Sum">#</a>
               </h3>
               
               <p>Sum appends the hash's current 64-bit value to b.
It exists for implementing [hash.Hash].
For direct calls, it is more efficient to use [Hash.Sum64].</p>
               
               <pre><code class="language-go">func (h *Hash) Sum(b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sum64" data-name="Sum64">
               <h3>
                  Sum64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sum64" class="anchor" title="Link to Sum64">#</a>
               </h3>
               
               <p>Sum64 returns h's current 64-bit value, which depends on
h's seed and the sequence of bytes added to h since the
last call to [Hash.Reset] or [Hash.SetSeed].
All bits of the Sum64 result are close to uniformly and
independently distributed, so it can be safely reduced
by using bit masking, shifting, or modular arithmetic.</p>
               
               <pre><code class="language-go">func (h *Hash) Sum64() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write adds b to the sequence of bytes hashed by h.
It always writes all of b and never fails; the count and error result are for implementing [io.Writer].</p>
               
               <pre><code class="language-go">func (h *Hash) Write(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteByte" data-name="WriteByte">
               <h3>
                  WriteByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteByte" class="anchor" title="Link to WriteByte">#</a>
               </h3>
               
               <p>WriteByte adds b to the sequence of bytes hashed by h.
It never fails; the error result is for implementing [io.ByteWriter].</p>
               
               <pre><code class="language-go">func (h *Hash) WriteByte(b byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteComparable" data-name="WriteComparable">
               <h3>
                  WriteComparable 
                  <span class="badge">function</span>
                  
                  <a href="#WriteComparable" class="anchor" title="Link to WriteComparable">#</a>
               </h3>
               
               <p>WriteComparable adds x to the data hashed by h.</p>
               
               <pre><code class="language-go">func WriteComparable(h *Hash, x T)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteString" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteString" class="anchor" title="Link to WriteString">#</a>
               </h3>
               
               <p>WriteString adds the bytes of s to the sequence of bytes hashed by h.
It always writes all of s and never fails; the count and error result are for implementing [io.StringWriter].</p>
               
               <pre><code class="language-go">func (h *Hash) WriteString(s string) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendT" data-name="appendT">
               <h3>
                  appendT 
                  <span class="badge">function</span>
                  
                  <a href="#appendT" class="anchor" title="Link to appendT">#</a>
               </h3>
               
               <p>appendT hash a value.</p>
               
               <pre><code class="language-go">func appendT(h *Hash, v reflect.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="btoi" data-name="btoi">
               <h3>
                  btoi 
                  <span class="badge">function</span>
                  
                  <a href="#btoi" class="anchor" title="Link to btoi">#</a>
               </h3>
               
               <pre><code class="language-go">func btoi(b bool) byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="comparableHash" data-name="comparableHash">
               <h3>
                  comparableHash 
                  <span class="badge">function</span>
                  
                  <a href="#comparableHash" class="anchor" title="Link to comparableHash">#</a>
               </h3>
               
               <pre><code class="language-go">func comparableHash(v T, seed Seed) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="comparableHash" data-name="comparableHash">
               <h3>
                  comparableHash 
                  <span class="badge">function</span>
                  
                  <a href="#comparableHash" class="anchor" title="Link to comparableHash">#</a>
               </h3>
               
               <pre><code class="language-go">func comparableHash(v T, seed Seed) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="escapeForHash" data-name="escapeForHash">
               <h3>
                  escapeForHash 
                  <span class="badge">function</span>
                  
                  <a href="#escapeForHash" class="anchor" title="Link to escapeForHash">#</a>
               </h3>
               
               <p>escapeForHash forces v to be on the heap, if v contains a
non-string pointer. We cannot hash pointers to local variables,
as the address of the local variable might change on stack growth.
Strings are okay as the hash depends on only the content, not
the pointer.
This is essentially
if hasNonStringPointers(T) { abi.Escape(v) }
Implemented as a compiler intrinsic.</p>
               
               <pre><code class="language-go">func escapeForHash(v T)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="float64" data-name="float64">
               <h3>
                  float64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#float64" class="anchor" title="Link to float64">#</a>
               </h3>
               
               <pre><code class="language-go">func (h *Hash) float64(f float64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flush" data-name="flush">
               <h3>
                  flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flush" class="anchor" title="Link to flush">#</a>
               </h3>
               
               <p>precondition: buffer is full.</p>
               
               <pre><code class="language-go">func (h *Hash) flush()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initSeed" data-name="initSeed">
               <h3>
                  initSeed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initSeed" class="anchor" title="Link to initSeed">#</a>
               </h3>
               
               <p>initSeed seeds the hash if necessary.
initSeed is called lazily before any operation that actually uses h.seed/h.state.
Note that this does not include Write/WriteByte/WriteString in the case
where they only add to h.buf. (If they write too much, they call h.flush,
which does call h.initSeed.)</p>
               
               <pre><code class="language-go">func (h *Hash) initSeed()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mix" data-name="mix">
               <h3>
                  mix 
                  <span class="badge">function</span>
                  
                  <a href="#mix" class="anchor" title="Link to mix">#</a>
               </h3>
               
               <pre><code class="language-go">func mix(a uint64, b uint64) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="r3" data-name="r3">
               <h3>
                  r3 
                  <span class="badge">function</span>
                  
                  <a href="#r3" class="anchor" title="Link to r3">#</a>
               </h3>
               
               <pre><code class="language-go">func r3(p []byte, k uint64) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="r4" data-name="r4">
               <h3>
                  r4 
                  <span class="badge">function</span>
                  
                  <a href="#r4" class="anchor" title="Link to r4">#</a>
               </h3>
               
               <pre><code class="language-go">func r4(p []byte) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="r8" data-name="r8">
               <h3>
                  r8 
                  <span class="badge">function</span>
                  
                  <a href="#r8" class="anchor" title="Link to r8">#</a>
               </h3>
               
               <pre><code class="language-go">func r8(p []byte) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="randUint64" data-name="randUint64">
               <h3>
                  randUint64 
                  <span class="badge">function</span>
                  
                  <a href="#randUint64" class="anchor" title="Link to randUint64">#</a>
               </h3>
               
               <pre><code class="language-go">func randUint64() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="randUint64" data-name="randUint64">
               <h3>
                  randUint64 
                  <span class="badge">function</span>
                  
                  <a href="#randUint64" class="anchor" title="Link to randUint64">#</a>
               </h3>
               
               <pre><code class="language-go">func randUint64() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rthash" data-name="rthash">
               <h3>
                  rthash 
                  <span class="badge">function</span>
                  
                  <a href="#rthash" class="anchor" title="Link to rthash">#</a>
               </h3>
               
               <pre><code class="language-go">func rthash(buf []byte, seed uint64) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rthash" data-name="rthash">
               <h3>
                  rthash 
                  <span class="badge">function</span>
                  
                  <a href="#rthash" class="anchor" title="Link to rthash">#</a>
               </h3>
               
               <pre><code class="language-go">func rthash(buf []byte, seed uint64) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rthashString" data-name="rthashString">
               <h3>
                  rthashString 
                  <span class="badge">function</span>
                  
                  <a href="#rthashString" class="anchor" title="Link to rthashString">#</a>
               </h3>
               
               <pre><code class="language-go">func rthashString(s string, state uint64) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rthashString" data-name="rthashString">
               <h3>
                  rthashString 
                  <span class="badge">function</span>
                  
                  <a href="#rthashString" class="anchor" title="Link to rthashString">#</a>
               </h3>
               
               <pre><code class="language-go">func rthashString(s string, state uint64) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_memhash" data-name="runtime_memhash">
               <h3>
                  runtime_memhash 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_memhash" class="anchor" title="Link to runtime_memhash">#</a>
               </h3>
               
               <p>go:linkname runtime_memhash runtime.memhash
go:noescape</p>
               
               <pre><code class="language-go">func runtime_memhash(p unsafe.Pointer, seed uintptr, s uintptr) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_rand" data-name="runtime_rand">
               <h3>
                  runtime_rand 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_rand" class="anchor" title="Link to runtime_rand">#</a>
               </h3>
               
               <p>go:linkname runtime_rand runtime.rand</p>
               
               <pre><code class="language-go">func runtime_rand() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeComparable" data-name="writeComparable">
               <h3>
                  writeComparable 
                  <span class="badge">function</span>
                  
                  <a href="#writeComparable" class="anchor" title="Link to writeComparable">#</a>
               </h3>
               
               <pre><code class="language-go">func writeComparable(h *Hash, v T)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeComparable" data-name="writeComparable">
               <h3>
                  writeComparable 
                  <span class="badge">function</span>
                  
                  <a href="#writeComparable" class="anchor" title="Link to writeComparable">#</a>
               </h3>
               
               <pre><code class="language-go">func writeComparable(h *Hash, v T)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wyhash" data-name="wyhash">
               <h3>
                  wyhash 
                  <span class="badge">function</span>
                  
                  <a href="#wyhash" class="anchor" title="Link to wyhash">#</a>
               </h3>
               
               <pre><code class="language-go">func wyhash(key []byte, seed uint64, len uint64) uint64</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>