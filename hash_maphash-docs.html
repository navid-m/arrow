<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - maphash</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>maphash</code>
         </h1>
         <hr />
         
         <article class="global" data-name="bufSize">
            <h2>bufSize</h2>
            <hr />
            
            <p>bufSize is the size of the Hash write buffer.
The buffer ensures that writes depend only on the sequence of bytes,
not the sequence of WriteByte/Write/WriteString calls,
by always calling rthash with a full buffer (except for the tail).</p>
            
            <pre><code>bufSize</code></pre>
         </article>
         
         <article class="global" data-name="purego">
            <h2>purego</h2>
            <hr />
            
            <pre><code>purego</code></pre>
         </article>
         
         <article class="global" data-name="hashkey">
            <h2>hashkey</h2>
            <hr />
            
            <pre><code>hashkey []uint64</code></pre>
         </article>
         
         <article class="global" data-name="m5">
            <h2>m5</h2>
            <hr />
            
            <pre><code>m5</code></pre>
         </article>
         
         <article class="global" data-name="purego">
            <h2>purego</h2>
            <hr />
            
            <pre><code>purego</code></pre>
         </article>
         
         <article class="global" data-name="heapStrValue">
            <h2>heapStrValue</h2>
            <hr />
            
            <pre><code>heapStrValue</code></pre>
         </article>
         
         <article class="global" data-name="use">
            <h2>use</h2>
            <hr />
            
            <pre><code>use byte</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <p>Make sure a Hash implements the hash.Hash and hash.Hash64 interfaces.</p>
            
            <pre><code>_ hash.Hash</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ hash.Hash64</code></pre>
         </article>
         
         <article class="global" data-name="fixedSeed">
            <h2>fixedSeed</h2>
            <hr />
            
            <pre><code>fixedSeed</code></pre>
         </article>
         
         <article class="global" data-name="hashSize">
            <h2>hashSize</h2>
            <hr />
            
            <pre><code>hashSize</code></pre>
         </article>
          
         <article class="struct" data-name="Seed">
            <h2>type Seed struct</h2>
            <hr />
            
            <p>A Seed is a random value that selects the specific hash function
computed by a [Hash]. If two Hashes use the same Seeds, they
will compute the same hash values for any given input.
If two Hashes use different Seeds, they are very likely to compute
distinct hash values for any given input.

A Seed must be initialized by calling [MakeSeed].
The zero seed is uninitialized and not valid for use with [Hash]'s SetSeed method.

Each Seed value is local to a single process and cannot be serialized
or otherwise recreated in a different process.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">s uint64</code></pre>
         </article>
         
         <article class="struct" data-name="Hash">
            <h2>type Hash struct</h2>
            <hr />
            
            <p>A Hash computes a seeded hash of a byte sequence.

The zero Hash is a valid Hash ready to use.
A zero Hash chooses a random seed for itself during
the first call to a Reset, Write, Seed, or Sum64 method.
For control over the seed, use SetSeed.

The computed hash values depend only on the initial seed and
the sequence of bytes provided to the Hash object, not on the way
in which the bytes are provided. For example, the three sequences

	h.Write([]byte{'f','o','o'})
	h.WriteByte('f'); h.WriteByte('o'); h.WriteByte('o')
	h.WriteString("foo")

all have the same effect.

Hashes are intended to be collision-resistant, even for situations
where an adversary controls the byte sequences being hashed.

A Hash is not safe for concurrent use by multiple goroutines, but a Seed is.
If multiple goroutines must compute the same seeded hash,
each can declare its own Hash and call SetSeed with a common Seed.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">_ []func
seed Seed
state Seed
buf []byte
n int</code></pre>
         </article>
         
         <article class="struct" data-name="hashSet">
            <h2>type hashSet struct</h2>
            <hr />
            
            <p>A hashSet measures the frequency of hash collisions.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">list []uint64</code></pre>
         </article>
         
         <article class="struct" data-name="bytesKey">
            <h2>type bytesKey struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">b []byte</code></pre>
         </article>
          
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <p>Bytes returns the hash of b with the given seed.

Bytes is equivalent to, but more convenient and efficient than:

	var h Hash
	h.SetSeed(seed)
	h.Write(b)
	return h.Sum64()</p>
            
            <pre><code>func Bytes(seed Seed, b []byte) uint64</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns the hash of s with the given seed.

String is equivalent to, but more convenient and efficient than:

	var h Hash
	h.SetSeed(seed)
	h.WriteString(s)
	return h.Sum64()</p>
            
            <pre><code>func String(seed Seed, s string) uint64</code></pre>
         </article>
         
         <article class="function" data-name="initSeed">
            <h2>initSeed</h2>
            <hr />
            
            <p>initSeed seeds the hash if necessary.
initSeed is called lazily before any operation that actually uses h.seed/h.state.
Note that this does not include Write/WriteByte/WriteString in the case
where they only add to h.buf. (If they write too much, they call h.flush,
which does call h.initSeed.)</p>
            
            <pre><code>func initSeed()</code></pre>
         </article>
         
         <article class="function" data-name="WriteByte">
            <h2>WriteByte</h2>
            <hr />
            
            <p>WriteByte adds b to the sequence of bytes hashed by h.
It never fails; the error result is for implementing [io.ByteWriter].</p>
            
            <pre><code>func WriteByte(b byte) error</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write adds b to the sequence of bytes hashed by h.
It always writes all of b and never fails; the count and error result are for implementing [io.Writer].</p>
            
            <pre><code>func Write(b []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteString">
            <h2>WriteString</h2>
            <hr />
            
            <p>WriteString adds the bytes of s to the sequence of bytes hashed by h.
It always writes all of s and never fails; the count and error result are for implementing [io.StringWriter].</p>
            
            <pre><code>func WriteString(s string) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Seed">
            <h2>Seed</h2>
            <hr />
            
            <p>Seed returns h's seed value.</p>
            
            <pre><code>func Seed() Seed</code></pre>
         </article>
         
         <article class="function" data-name="SetSeed">
            <h2>SetSeed</h2>
            <hr />
            
            <p>SetSeed sets h to use seed, which must have been returned by [MakeSeed]
or by another [Hash.Seed] method.
Two [Hash] objects with the same seed behave identically.
Two [Hash] objects with different seeds will very likely behave differently.
Any bytes added to h before this call will be discarded.</p>
            
            <pre><code>func SetSeed(seed Seed)</code></pre>
         </article>
         
         <article class="function" data-name="Reset">
            <h2>Reset</h2>
            <hr />
            
            <p>Reset discards all bytes added to h.
(The seed remains the same.)</p>
            
            <pre><code>func Reset()</code></pre>
         </article>
         
         <article class="function" data-name="flush">
            <h2>flush</h2>
            <hr />
            
            <p>precondition: buffer is full.</p>
            
            <pre><code>func flush()</code></pre>
         </article>
         
         <article class="function" data-name="Sum64">
            <h2>Sum64</h2>
            <hr />
            
            <p>Sum64 returns h's current 64-bit value, which depends on
h's seed and the sequence of bytes added to h since the
last call to [Hash.Reset] or [Hash.SetSeed].

All bits of the Sum64 result are close to uniformly and
independently distributed, so it can be safely reduced
by using bit masking, shifting, or modular arithmetic.</p>
            
            <pre><code>func Sum64() uint64</code></pre>
         </article>
         
         <article class="function" data-name="MakeSeed">
            <h2>MakeSeed</h2>
            <hr />
            
            <p>MakeSeed returns a new random seed.</p>
            
            <pre><code>func MakeSeed() Seed</code></pre>
         </article>
         
         <article class="function" data-name="Sum">
            <h2>Sum</h2>
            <hr />
            
            <p>Sum appends the hash's current 64-bit value to b.
It exists for implementing [hash.Hash].
For direct calls, it is more efficient to use [Hash.Sum64].</p>
            
            <pre><code>func Sum(b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Size">
            <h2>Size</h2>
            <hr />
            
            <p>Size returns h's hash value size, 8 bytes.</p>
            
            <pre><code>func Size() int</code></pre>
         </article>
         
         <article class="function" data-name="BlockSize">
            <h2>BlockSize</h2>
            <hr />
            
            <p>BlockSize returns h's block size.</p>
            
            <pre><code>func BlockSize() int</code></pre>
         </article>
         
         <article class="function" data-name="Comparable">
            <h2>Comparable</h2>
            <hr />
            
            <p>Comparable returns the hash of comparable value v with the given seed
such that Comparable(s, v1) == Comparable(s, v2) if v1 == v2.
If v != v, then the resulting hash is randomly distributed.</p>
            
            <pre><code>func Comparable(seed Seed, v T) uint64</code></pre>
         </article>
         
         <article class="function" data-name="escapeForHash">
            <h2>escapeForHash</h2>
            <hr />
            
            <p>escapeForHash forces v to be on the heap, if v contains a
non-string pointer. We cannot hash pointers to local variables,
as the address of the local variable might change on stack growth.
Strings are okay as the hash depends on only the content, not
the pointer.

This is essentially

	if hasNonStringPointers(T) { abi.Escape(v) }

Implemented as a compiler intrinsic.</p>
            
            <pre><code>func escapeForHash(v T)</code></pre>
         </article>
         
         <article class="function" data-name="WriteComparable">
            <h2>WriteComparable</h2>
            <hr />
            
            <p>WriteComparable adds x to the data hashed by h.</p>
            
            <pre><code>func WriteComparable(h *Hash, x T)</code></pre>
         </article>
         
         <article class="function" data-name="float64">
            <h2>float64</h2>
            <hr />
            
            <pre><code>func float64(f float64)</code></pre>
         </article>
         
         <article class="function" data-name="btoi">
            <h2>btoi</h2>
            <hr />
            
            <pre><code>func btoi(b bool) byte</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="rthash">
            <h2>rthash</h2>
            <hr />
            
            <pre><code>func rthash(buf []byte, seed uint64) uint64</code></pre>
         </article>
         
         <article class="function" data-name="rthashString">
            <h2>rthashString</h2>
            <hr />
            
            <pre><code>func rthashString(s string, state uint64) uint64</code></pre>
         </article>
         
         <article class="function" data-name="randUint64">
            <h2>randUint64</h2>
            <hr />
            
            <pre><code>func randUint64() uint64</code></pre>
         </article>
         
         <article class="function" data-name="wyhash">
            <h2>wyhash</h2>
            <hr />
            
            <pre><code>func wyhash(key []byte, seed uint64, len uint64) uint64</code></pre>
         </article>
         
         <article class="function" data-name="r3">
            <h2>r3</h2>
            <hr />
            
            <pre><code>func r3(p []byte, k uint64) uint64</code></pre>
         </article>
         
         <article class="function" data-name="r4">
            <h2>r4</h2>
            <hr />
            
            <pre><code>func r4(p []byte) uint64</code></pre>
         </article>
         
         <article class="function" data-name="r8">
            <h2>r8</h2>
            <hr />
            
            <pre><code>func r8(p []byte) uint64</code></pre>
         </article>
         
         <article class="function" data-name="mix">
            <h2>mix</h2>
            <hr />
            
            <pre><code>func mix(a uint64, b uint64) uint64</code></pre>
         </article>
         
         <article class="function" data-name="comparableHash">
            <h2>comparableHash</h2>
            <hr />
            
            <pre><code>func comparableHash(v T, seed Seed) uint64</code></pre>
         </article>
         
         <article class="function" data-name="writeComparable">
            <h2>writeComparable</h2>
            <hr />
            
            <pre><code>func writeComparable(h *Hash, v T)</code></pre>
         </article>
         
         <article class="function" data-name="appendT">
            <h2>appendT</h2>
            <hr />
            
            <p>appendT hash a value.</p>
            
            <pre><code>func appendT(h *Hash, v reflect.Value)</code></pre>
         </article>
         
         <article class="function" data-name="runtime_rand">
            <h2>runtime_rand</h2>
            <hr />
            
            <pre><code>func runtime_rand() uint64</code></pre>
         </article>
         
         <article class="function" data-name="runtime_memhash">
            <h2>runtime_memhash</h2>
            <hr />
            
            <pre><code>func runtime_memhash(p unsafe.Pointer, seed uintptr, s uintptr) uintptr</code></pre>
         </article>
         
         <article class="function" data-name="rthash">
            <h2>rthash</h2>
            <hr />
            
            <pre><code>func rthash(buf []byte, seed uint64) uint64</code></pre>
         </article>
         
         <article class="function" data-name="rthashString">
            <h2>rthashString</h2>
            <hr />
            
            <pre><code>func rthashString(s string, state uint64) uint64</code></pre>
         </article>
         
         <article class="function" data-name="randUint64">
            <h2>randUint64</h2>
            <hr />
            
            <pre><code>func randUint64() uint64</code></pre>
         </article>
         
         <article class="function" data-name="comparableHash">
            <h2>comparableHash</h2>
            <hr />
            
            <pre><code>func comparableHash(v T, seed Seed) uint64</code></pre>
         </article>
         
         <article class="function" data-name="writeComparable">
            <h2>writeComparable</h2>
            <hr />
            
            <pre><code>func writeComparable(h *Hash, v T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnseededHash">
            <h2>TestUnseededHash</h2>
            <hr />
            
            <pre><code>func TestUnseededHash(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSeededHash">
            <h2>TestSeededHash</h2>
            <hr />
            
            <pre><code>func TestSeededHash(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestHashGrouping">
            <h2>TestHashGrouping</h2>
            <hr />
            
            <pre><code>func TestHashGrouping(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestHashBytesVsString">
            <h2>TestHashBytesVsString</h2>
            <hr />
            
            <pre><code>func TestHashBytesVsString(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestHashHighBytes">
            <h2>TestHashHighBytes</h2>
            <hr />
            
            <pre><code>func TestHashHighBytes(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestRepeat">
            <h2>TestRepeat</h2>
            <hr />
            
            <pre><code>func TestRepeat(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSeedFromSum64">
            <h2>TestSeedFromSum64</h2>
            <hr />
            
            <pre><code>func TestSeedFromSum64(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSeedFromSeed">
            <h2>TestSeedFromSeed</h2>
            <hr />
            
            <pre><code>func TestSeedFromSeed(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSeedFromFlush">
            <h2>TestSeedFromFlush</h2>
            <hr />
            
            <pre><code>func TestSeedFromFlush(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSeedFromReset">
            <h2>TestSeedFromReset</h2>
            <hr />
            
            <pre><code>func TestSeedFromReset(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="negativeZero">
            <h2>negativeZero</h2>
            <hr />
            
            <pre><code>func negativeZero() T</code></pre>
         </article>
         
         <article class="function" data-name="TestComparable">
            <h2>TestComparable</h2>
            <hr />
            
            <pre><code>func TestComparable(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testComparableNoEqual">
            <h2>testComparableNoEqual</h2>
            <hr />
            
            <pre><code>func testComparableNoEqual(t *testing.T, v1 T, v2 T)</code></pre>
         </article>
         
         <article class="function" data-name="heapStr">
            <h2>heapStr</h2>
            <hr />
            
            <pre><code>func heapStr(t *testing.T) string</code></pre>
         </article>
         
         <article class="function" data-name="testComparable">
            <h2>testComparable</h2>
            <hr />
            
            <pre><code>func testComparable(t *testing.T, v T, v2 ...T)</code></pre>
         </article>
         
         <article class="function" data-name="stackGrow">
            <h2>stackGrow</h2>
            <hr />
            
            <pre><code>func stackGrow(dep int)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriteComparable">
            <h2>TestWriteComparable</h2>
            <hr />
            
            <pre><code>func TestWriteComparable(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testWriteComparableNoEqual">
            <h2>testWriteComparableNoEqual</h2>
            <hr />
            
            <pre><code>func testWriteComparableNoEqual(t *testing.T, v1 T, v2 T)</code></pre>
         </article>
         
         <article class="function" data-name="testWriteComparable">
            <h2>testWriteComparable</h2>
            <hr />
            
            <pre><code>func testWriteComparable(t *testing.T, v T, v2 ...T)</code></pre>
         </article>
         
         <article class="function" data-name="TestComparableShouldPanic">
            <h2>TestComparableShouldPanic</h2>
            <hr />
            
            <pre><code>func TestComparableShouldPanic(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriteComparableNoncommute">
            <h2>TestWriteComparableNoncommute</h2>
            <hr />
            
            <pre><code>func TestWriteComparableNoncommute(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestComparableAllocations">
            <h2>TestComparableAllocations</h2>
            <hr />
            
            <pre><code>func TestComparableAllocations(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="benchmarkSize">
            <h2>benchmarkSize</h2>
            <hr />
            
            <pre><code>func benchmarkSize(b *testing.B, size int)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkHash">
            <h2>BenchmarkHash</h2>
            <hr />
            
            <pre><code>func BenchmarkHash(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="benchmarkComparable">
            <h2>benchmarkComparable</h2>
            <hr />
            
            <pre><code>func benchmarkComparable(b *testing.B, v T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkComparable">
            <h2>BenchmarkComparable</h2>
            <hr />
            
            <pre><code>func BenchmarkComparable(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="TestSmhasherSanity">
            <h2>TestSmhasherSanity</h2>
            <hr />
            
            <p>Sanity checks.
hash should not depend on values outside key.
hash should not depend on alignment.</p>
            
            <pre><code>func TestSmhasherSanity(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="bytesHash">
            <h2>bytesHash</h2>
            <hr />
            
            <pre><code>func bytesHash(b []byte) uint64</code></pre>
         </article>
         
         <article class="function" data-name="stringHash">
            <h2>stringHash</h2>
            <hr />
            
            <pre><code>func stringHash(s string) uint64</code></pre>
         </article>
         
         <article class="function" data-name="randBytes">
            <h2>randBytes</h2>
            <hr />
            
            <pre><code>func randBytes(r *rand.Rand, b []byte)</code></pre>
         </article>
         
         <article class="function" data-name="newHashSet">
            <h2>newHashSet</h2>
            <hr />
            
            <pre><code>func newHashSet() *hashSet</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <pre><code>func add(h uint64)</code></pre>
         </article>
         
         <article class="function" data-name="addS">
            <h2>addS</h2>
            <hr />
            
            <pre><code>func addS(x string)</code></pre>
         </article>
         
         <article class="function" data-name="addB">
            <h2>addB</h2>
            <hr />
            
            <pre><code>func addB(x []byte)</code></pre>
         </article>
         
         <article class="function" data-name="addS_seed">
            <h2>addS_seed</h2>
            <hr />
            
            <pre><code>func addS_seed(x string, seed Seed)</code></pre>
         </article>
         
         <article class="function" data-name="check">
            <h2>check</h2>
            <hr />
            
            <pre><code>func check(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSmhasherAppendedZeros">
            <h2>TestSmhasherAppendedZeros</h2>
            <hr />
            
            <p>a string plus adding zeros must make distinct hashes</p>
            
            <pre><code>func TestSmhasherAppendedZeros(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSmhasherSmallKeys">
            <h2>TestSmhasherSmallKeys</h2>
            <hr />
            
            <p>All 0-3 byte strings have distinct hashes.</p>
            
            <pre><code>func TestSmhasherSmallKeys(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSmhasherZeros">
            <h2>TestSmhasherZeros</h2>
            <hr />
            
            <p>Different length strings of all zeros have distinct hashes.</p>
            
            <pre><code>func TestSmhasherZeros(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSmhasherTwoNonzero">
            <h2>TestSmhasherTwoNonzero</h2>
            <hr />
            
            <p>Strings with up to two nonzero bytes all have distinct hashes.</p>
            
            <pre><code>func TestSmhasherTwoNonzero(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="twoNonZero">
            <h2>twoNonZero</h2>
            <hr />
            
            <pre><code>func twoNonZero(h *hashSet, n int)</code></pre>
         </article>
         
         <article class="function" data-name="TestSmhasherCyclic">
            <h2>TestSmhasherCyclic</h2>
            <hr />
            
            <p>Test strings with repeats, like "abcdabcdabcdabcd..."</p>
            
            <pre><code>func TestSmhasherCyclic(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSmhasherSparse">
            <h2>TestSmhasherSparse</h2>
            <hr />
            
            <p>Test strings with only a few bits set</p>
            
            <pre><code>func TestSmhasherSparse(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="sparse">
            <h2>sparse</h2>
            <hr />
            
            <pre><code>func sparse(t *testing.T, h *hashSet, n int, k int)</code></pre>
         </article>
         
         <article class="function" data-name="setbits">
            <h2>setbits</h2>
            <hr />
            
            <p>set up to k bits at index i and greater</p>
            
            <pre><code>func setbits(h *hashSet, b []byte, i int, k int)</code></pre>
         </article>
         
         <article class="function" data-name="TestSmhasherPermutation">
            <h2>TestSmhasherPermutation</h2>
            <hr />
            
            <p>Test all possible combinations of n blocks from the set s.
"permutation" is a bad name here, but it is what Smhasher uses.</p>
            
            <pre><code>func TestSmhasherPermutation(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="permutation">
            <h2>permutation</h2>
            <hr />
            
            <pre><code>func permutation(t *testing.T, h *hashSet, s []uint32, n int)</code></pre>
         </article>
         
         <article class="function" data-name="genPerm">
            <h2>genPerm</h2>
            <hr />
            
            <pre><code>func genPerm(h *hashSet, b []byte, s []uint32, n int)</code></pre>
         </article>
         
         <article class="function" data-name="clear">
            <h2>clear</h2>
            <hr />
            
            <pre><code>func clear()</code></pre>
         </article>
         
         <article class="function" data-name="random">
            <h2>random</h2>
            <hr />
            
            <pre><code>func random(r *rand.Rand)</code></pre>
         </article>
         
         <article class="function" data-name="bits">
            <h2>bits</h2>
            <hr />
            
            <pre><code>func bits() int</code></pre>
         </article>
         
         <article class="function" data-name="flipBit">
            <h2>flipBit</h2>
            <hr />
            
            <pre><code>func flipBit(i int)</code></pre>
         </article>
         
         <article class="function" data-name="hash">
            <h2>hash</h2>
            <hr />
            
            <pre><code>func hash() uint64</code></pre>
         </article>
         
         <article class="function" data-name="name">
            <h2>name</h2>
            <hr />
            
            <pre><code>func name() string</code></pre>
         </article>
         
         <article class="function" data-name="TestSmhasherAvalanche">
            <h2>TestSmhasherAvalanche</h2>
            <hr />
            
            <p>Flipping a single bit of a key should flip each output bit with 50% probability.</p>
            
            <pre><code>func TestSmhasherAvalanche(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="avalancheTest1">
            <h2>avalancheTest1</h2>
            <hr />
            
            <pre><code>func avalancheTest1(t *testing.T, k key)</code></pre>
         </article>
         
         <article class="function" data-name="TestSmhasherWindowed">
            <h2>TestSmhasherWindowed</h2>
            <hr />
            
            <p>All bit rotations of a set of distinct keys</p>
            
            <pre><code>func TestSmhasherWindowed(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="windowed">
            <h2>windowed</h2>
            <hr />
            
            <pre><code>func windowed(t *testing.T, k key)</code></pre>
         </article>
         
         <article class="function" data-name="TestSmhasherText">
            <h2>TestSmhasherText</h2>
            <hr />
            
            <p>All keys of the form prefix + [A-Za-z0-9]*N + suffix.</p>
            
            <pre><code>func TestSmhasherText(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="text">
            <h2>text</h2>
            <hr />
            
            <pre><code>func text(t *testing.T, h *hashSet, prefix string, suffix string)</code></pre>
         </article>
         
         <article class="function" data-name="TestSmhasherSeed">
            <h2>TestSmhasherSeed</h2>
            <hr />
            
            <p>Make sure different seed values generate different hashes.</p>
            
            <pre><code>func TestSmhasherSeed(t *testing.T)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
