<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>sync - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>sync</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"internal/race"
"sync/atomic"
"unsafe"
_ "unsafe"
"internal/abi"
"internal/goarch"
"sync/atomic"
"unsafe"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="mutexLocked" data-name="mutexLocked">
               <h3>
                  mutexLocked 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mutexLocked" class="anchor" title="Link to mutexLocked">#</a>
               </h3>
               
               <pre><code class="language-go">const mutexLocked = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mutexStarving" data-name="mutexStarving">
               <h3>
                  mutexStarving 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mutexStarving" class="anchor" title="Link to mutexStarving">#</a>
               </h3>
               
               <pre><code class="language-go">const mutexStarving</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mutexWaiterShift" data-name="mutexWaiterShift">
               <h3>
                  mutexWaiterShift 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mutexWaiterShift" class="anchor" title="Link to mutexWaiterShift">#</a>
               </h3>
               
               <pre><code class="language-go">const mutexWaiterShift = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mutexWoken" data-name="mutexWoken">
               <h3>
                  mutexWoken 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mutexWoken" class="anchor" title="Link to mutexWoken">#</a>
               </h3>
               
               <pre><code class="language-go">const mutexWoken</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nChildren" data-name="nChildren">
               <h3>
                  nChildren 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#nChildren" class="anchor" title="Link to nChildren">#</a>
               </h3>
               
               <pre><code class="language-go">const nChildren = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nChildrenLog2" data-name="nChildrenLog2">
               <h3>
                  nChildrenLog2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#nChildrenLog2" class="anchor" title="Link to nChildrenLog2">#</a>
               </h3>
               
                  <p class="doc-comment">16 children. This seems to be the sweet spot for
load performance: any smaller and we lose out on
50% or more in CPU performance. Any larger and the
returns are minuscule (~1% improvement for 32 children).</p>
               
               <pre><code class="language-go">const nChildrenLog2 = 4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nChildrenMask" data-name="nChildrenMask">
               <h3>
                  nChildrenMask 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#nChildrenMask" class="anchor" title="Link to nChildrenMask">#</a>
               </h3>
               
               <pre><code class="language-go">const nChildrenMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="starvationThresholdNs" data-name="starvationThresholdNs">
               <h3>
                  starvationThresholdNs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#starvationThresholdNs" class="anchor" title="Link to starvationThresholdNs">#</a>
               </h3>
               
                  <p class="doc-comment">Mutex fairness.
Mutex can be in 2 modes of operations: normal and starvation.
In normal mode waiters are queued in FIFO order, but a woken up waiter
does not own the mutex and competes with new arriving goroutines over
the ownership. New arriving goroutines have an advantage -- they are
already running on CPU and there can be lots of them, so a woken up
waiter has good chances of losing. In such case it is queued at front
of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,
it switches mutex to the starvation mode.
In starvation mode ownership of the mutex is directly handed off from
the unlocking goroutine to the waiter at the front of the queue.
New arriving goroutines don't try to acquire the mutex even if it appears
to be unlocked, and don't try to spin. Instead they queue themselves at
the tail of the wait queue.
If a waiter receives ownership of the mutex and sees that either
(1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,
it switches mutex back to normal operation mode.
Normal mode has considerably better performance as a goroutine can acquire
a mutex several times in a row even if there are blocked waiters.
Starvation mode is important to prevent pathological cases of tail latency.</p>
               
               <pre><code class="language-go">const starvationThresholdNs = 1e6</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="equalFunc" data-name="equalFunc">
               <h3>
                  equalFunc
                  <span class="badge type-badge">type</span>
                  <a href="#equalFunc" class="anchor" title="Link to equalFunc">#</a>
               </h3>
               
               <pre><code class="language-go">type equalFunc func(unsafe.Pointer, unsafe.Pointer) bool</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="hashFunc" data-name="hashFunc">
               <h3>
                  hashFunc
                  <span class="badge type-badge">type</span>
                  <a href="#hashFunc" class="anchor" title="Link to hashFunc">#</a>
               </h3>
               
               <pre><code class="language-go">type hashFunc func(unsafe.Pointer, uintptr) uintptr</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="HashTrieMap" data-name="HashTrieMap">
               <h3>
                  HashTrieMap
                  <span class="badge">struct</span>
                  <a href="#HashTrieMap" class="anchor" title="Link to HashTrieMap">#</a>
               </h3>
               
               <p>HashTrieMap is an implementation of a concurrent hash-trie. The implementation
is designed around frequent loads, but offers decent performance for stores
and deletes as well, especially if the map is larger. Its primary use-case is
the unique package, but can be used elsewhere as well.
The zero HashTrieMap is empty and ready to use.
It must not be copied after first use.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type HashTrieMap struct {
inited atomic.Uint32
initMu Mutex
root *ast.IndexExpr
keyHash hashFunc
valEqual equalFunc
seed uintptr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Mutex" data-name="Mutex">
               <h3>
                  Mutex
                  <span class="badge">struct</span>
                  <a href="#Mutex" class="anchor" title="Link to Mutex">#</a>
               </h3>
               
               <p>A Mutex is a mutual exclusion lock.
See package [sync.Mutex] documentation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Mutex struct {
state int32
sema uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="entry" data-name="entry">
               <h3>
                  entry
                  <span class="badge">struct</span>
                  <a href="#entry" class="anchor" title="Link to entry">#</a>
               </h3>
               
               <p>entry is a leaf node in the hash-trie.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type entry struct {
*ast.IndexListExpr
overflow *ast.IndexExpr
key K
value V
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="indirect" data-name="indirect">
               <h3>
                  indirect
                  <span class="badge">struct</span>
                  <a href="#indirect" class="anchor" title="Link to indirect">#</a>
               </h3>
               
               <p>indirect is an internal node in the hash-trie.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type indirect struct {
*ast.IndexListExpr
dead atomic.Bool
mu Mutex
parent **ast.IndexListExpr
children [nChildren]*ast.IndexExpr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="node" data-name="node">
               <h3>
                  node
                  <span class="badge">struct</span>
                  <a href="#node" class="anchor" title="Link to node">#</a>
               </h3>
               
               <p>node is the header for a node. It's polymorphic and
is actually either an entry or an indirect.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type node struct {
isEntry bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="All" data-name="All">
               <h3>
                  All 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#All" class="anchor" title="Link to All">#</a>
               </h3>
               
               <p>All returns an iterator over each key and value present in the map.
The iterator does not necessarily correspond to any consistent snapshot of the
HashTrieMap's contents: no key will be visited more than once, but if the value
for any key is stored or deleted concurrently (including by yield), the iterator
may reflect any mapping for that key from any point during iteration. The iterator
does not block other methods on the receiver; even yield itself may call any
method on the HashTrieMap.</p>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) All() (func(yield func(K, V) bool))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Clear" data-name="Clear">
               <h3>
                  Clear 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Clear" class="anchor" title="Link to Clear">#</a>
               </h3>
               
               <p>Clear deletes all the entries, resulting in an empty HashTrieMap.</p>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) Clear()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CompareAndDelete" data-name="CompareAndDelete">
               <h3>
                  CompareAndDelete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CompareAndDelete" class="anchor" title="Link to CompareAndDelete">#</a>
               </h3>
               
               <p>CompareAndDelete deletes the entry for key if its value is equal to old.
The value type must be comparable, otherwise this CompareAndDelete will panic.
If there is no current value for key in the map, CompareAndDelete returns false
(even if the old value is the nil interface value).</p>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) CompareAndDelete(key K, old V) (deleted bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CompareAndSwap" data-name="CompareAndSwap">
               <h3>
                  CompareAndSwap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CompareAndSwap" class="anchor" title="Link to CompareAndSwap">#</a>
               </h3>
               
               <p>CompareAndSwap swaps the old and new values for key
if the value stored in the map is equal to old.
The value type must be of a comparable type, otherwise CompareAndSwap will panic.</p>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) CompareAndSwap(key K, old V, new V) (swapped bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Delete" data-name="Delete">
               <h3>
                  Delete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Delete" class="anchor" title="Link to Delete">#</a>
               </h3>
               
               <p>Delete deletes the value for a key.</p>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) Delete(key K)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Load" data-name="Load">
               <h3>
                  Load 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Load" class="anchor" title="Link to Load">#</a>
               </h3>
               
               <p>Load returns the value stored in the map for a key, or nil if no
value is present.
The ok result indicates whether value was found in the map.</p>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) Load(key K) (value V, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LoadAndDelete" data-name="LoadAndDelete">
               <h3>
                  LoadAndDelete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LoadAndDelete" class="anchor" title="Link to LoadAndDelete">#</a>
               </h3>
               
               <p>LoadAndDelete deletes the value for a key, returning the previous value if any.
The loaded result reports whether the key was present.</p>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) LoadAndDelete(key K) (value V, loaded bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LoadOrStore" data-name="LoadOrStore">
               <h3>
                  LoadOrStore 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LoadOrStore" class="anchor" title="Link to LoadOrStore">#</a>
               </h3>
               
               <p>LoadOrStore returns the existing value for the key if present.
Otherwise, it stores and returns the given value.
The loaded result is true if the value was loaded, false if stored.</p>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) LoadOrStore(key K, value V) (result V, loaded bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lock" data-name="Lock">
               <h3>
                  Lock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lock" class="anchor" title="Link to Lock">#</a>
               </h3>
               
               <p>Lock locks m.
See package [sync.Mutex] documentation.</p>
               
               <pre><code class="language-go">func (m *Mutex) Lock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Range" data-name="Range">
               <h3>
                  Range 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Range" class="anchor" title="Link to Range">#</a>
               </h3>
               
               <p>Range calls f sequentially for each key and value present in the map.
If f returns false, range stops the iteration.
This exists for compatibility with sync.Map; All should be preferred.
It provides the same guarantees as sync.Map, and All.</p>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) Range(yield func(K, V) bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Store" data-name="Store">
               <h3>
                  Store 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Store" class="anchor" title="Link to Store">#</a>
               </h3>
               
               <p>Store sets the value for a key.</p>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) Store(key K, old V)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <p>Swap swaps the value for a key and returns the previous value if any.
The loaded result reports whether the key was present.</p>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) Swap(key K, new V) (previous V, loaded bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TryLock" data-name="TryLock">
               <h3>
                  TryLock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TryLock" class="anchor" title="Link to TryLock">#</a>
               </h3>
               
               <p>TryLock tries to lock m and reports whether it succeeded.
See package [sync.Mutex] documentation.</p>
               
               <pre><code class="language-go">func (m *Mutex) TryLock() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unlock" data-name="Unlock">
               <h3>
                  Unlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unlock" class="anchor" title="Link to Unlock">#</a>
               </h3>
               
               <p>Unlock unlocks m.
See package [sync.Mutex] documentation.</p>
               
               <pre><code class="language-go">func (m *Mutex) Unlock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compareAndDelete" data-name="compareAndDelete">
               <h3>
                  compareAndDelete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#compareAndDelete" class="anchor" title="Link to compareAndDelete">#</a>
               </h3>
               
               <p>compareAndDelete deletes an entry in the overflow chain if both the key and value compare
equal. Returns the new entry chain and whether or not anything was deleted.
compareAndDelete must be called under the mutex of the indirect node which e is a child of.</p>
               
               <pre><code class="language-go">func (head **ast.IndexListExpr) compareAndDelete(key K, value V, valEqual equalFunc) (**ast.IndexListExpr, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compareAndSwap" data-name="compareAndSwap">
               <h3>
                  compareAndSwap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#compareAndSwap" class="anchor" title="Link to compareAndSwap">#</a>
               </h3>
               
               <p>compareAndSwap replaces an entry in the overflow chain if both the key and value compare
equal. Returns the new entry chain and whether or not anything was swapped.
compareAndSwap must be called under the mutex of the indirect node which e is a child of.</p>
               
               <pre><code class="language-go">func (head **ast.IndexListExpr) compareAndSwap(key K, old V, new V, valEqual equalFunc) (**ast.IndexListExpr, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="empty" data-name="empty">
               <h3>
                  empty 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#empty" class="anchor" title="Link to empty">#</a>
               </h3>
               
               <pre><code class="language-go">func (i **ast.IndexListExpr) empty() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="entry" data-name="entry">
               <h3>
                  entry 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#entry" class="anchor" title="Link to entry">#</a>
               </h3>
               
               <pre><code class="language-go">func (n **ast.IndexListExpr) entry() **ast.IndexListExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expand" data-name="expand">
               <h3>
                  expand 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expand" class="anchor" title="Link to expand">#</a>
               </h3>
               
               <p>expand takes oldEntry and newEntry whose hashes conflict from bit 64 down to hashShift and
produces a subtree of indirect nodes to hold the two new entries.</p>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) expand(oldEntry **ast.IndexListExpr, newEntry **ast.IndexListExpr, newHash uintptr, hashShift uint, parent **ast.IndexListExpr) **ast.IndexListExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fatal" data-name="fatal">
               <h3>
                  fatal 
                  <span class="badge">function</span>
                  
                  <a href="#fatal" class="anchor" title="Link to fatal">#</a>
               </h3>
               
               <p>go:linkname fatal</p>
               
               <pre><code class="language-go">func fatal(string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="find" data-name="find">
               <h3>
                  find 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#find" class="anchor" title="Link to find">#</a>
               </h3>
               
               <p>find searches the tree for a node that contains key (hash must be the hash of key).
If valEqual != nil, then it will also enforce that the values are equal as well.
Returns a non-nil node, which will always be an entry, if found.
If i != nil then i.mu is locked, and it is the caller's responsibility to unlock it.</p>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) find(key K, hash uintptr, valEqual equalFunc, value V) (i **ast.IndexListExpr, hashShift uint, slot **ast.IndexExpr, n **ast.IndexListExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indirect" data-name="indirect">
               <h3>
                  indirect 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#indirect" class="anchor" title="Link to indirect">#</a>
               </h3>
               
               <pre><code class="language-go">func (n **ast.IndexListExpr) indirect() **ast.IndexListExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initSlow" data-name="initSlow">
               <h3>
                  initSlow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initSlow" class="anchor" title="Link to initSlow">#</a>
               </h3>
               
               <p>go:noinline</p>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) initSlow()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="iter" data-name="iter">
               <h3>
                  iter 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#iter" class="anchor" title="Link to iter">#</a>
               </h3>
               
               <pre><code class="language-go">func (ht **ast.IndexListExpr) iter(i **ast.IndexListExpr, yield func(key K, value V) bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadAndDelete" data-name="loadAndDelete">
               <h3>
                  loadAndDelete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#loadAndDelete" class="anchor" title="Link to loadAndDelete">#</a>
               </h3>
               
               <p>loadAndDelete deletes an entry in the overflow chain by key. Returns the value for the key, the new
entry chain and whether or not anything was loaded (and deleted).
loadAndDelete must be called under the mutex of the indirect node which e is a child of.</p>
               
               <pre><code class="language-go">func (head **ast.IndexListExpr) loadAndDelete(key K) (V, **ast.IndexListExpr, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lockSlow" data-name="lockSlow">
               <h3>
                  lockSlow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lockSlow" class="anchor" title="Link to lockSlow">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *Mutex) lockSlow()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookup" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookup" class="anchor" title="Link to lookup">#</a>
               </h3>
               
               <pre><code class="language-go">func (e **ast.IndexListExpr) lookup(key K) (V, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupWithValue" data-name="lookupWithValue">
               <h3>
                  lookupWithValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookupWithValue" class="anchor" title="Link to lookupWithValue">#</a>
               </h3>
               
               <pre><code class="language-go">func (e **ast.IndexListExpr) lookupWithValue(key K, value V, valEqual equalFunc) (V, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newEntryNode" data-name="newEntryNode">
               <h3>
                  newEntryNode 
                  <span class="badge">function</span>
                  
                  <a href="#newEntryNode" class="anchor" title="Link to newEntryNode">#</a>
               </h3>
               
               <pre><code class="language-go">func newEntryNode(key K, value V) **ast.IndexListExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newIndirectNode" data-name="newIndirectNode">
               <h3>
                  newIndirectNode 
                  <span class="badge">function</span>
                  
                  <a href="#newIndirectNode" class="anchor" title="Link to newIndirectNode">#</a>
               </h3>
               
               <pre><code class="language-go">func newIndirectNode(parent **ast.IndexListExpr) **ast.IndexListExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_SemacquireMutex" data-name="runtime_SemacquireMutex">
               <h3>
                  runtime_SemacquireMutex 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_SemacquireMutex" class="anchor" title="Link to runtime_SemacquireMutex">#</a>
               </h3>
               
               <p>SemacquireMutex is like Semacquire, but for profiling contended
Mutexes and RWMutexes.
If lifo is true, queue waiter at the head of wait queue.
skipframes is the number of frames to omit during tracing, counting from
runtime_SemacquireMutex's caller.
The different forms of this function just tell the runtime how to present
the reason for waiting in a backtrace, and is used to compute some metrics.
Otherwise they're functionally identical.
go:linkname runtime_SemacquireMutex</p>
               
               <pre><code class="language-go">func runtime_SemacquireMutex(s *uint32, lifo bool, skipframes int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_Semrelease" data-name="runtime_Semrelease">
               <h3>
                  runtime_Semrelease 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_Semrelease" class="anchor" title="Link to runtime_Semrelease">#</a>
               </h3>
               
               <p>Semrelease atomically increments *s and notifies a waiting goroutine
if one is blocked in Semacquire.
It is intended as a simple wakeup primitive for use by the synchronization
library and should not be used directly.
If handoff is true, pass count directly to the first waiter.
skipframes is the number of frames to omit during tracing, counting from
runtime_Semrelease's caller.
go:linkname runtime_Semrelease</p>
               
               <pre><code class="language-go">func runtime_Semrelease(s *uint32, handoff bool, skipframes int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_canSpin" data-name="runtime_canSpin">
               <h3>
                  runtime_canSpin 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_canSpin" class="anchor" title="Link to runtime_canSpin">#</a>
               </h3>
               
               <p>Active spinning runtime support.
runtime_canSpin reports whether spinning makes sense at the moment.
go:linkname runtime_canSpin</p>
               
               <pre><code class="language-go">func runtime_canSpin(i int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_doSpin" data-name="runtime_doSpin">
               <h3>
                  runtime_doSpin 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_doSpin" class="anchor" title="Link to runtime_doSpin">#</a>
               </h3>
               
               <p>runtime_doSpin does active spinning.
go:linkname runtime_doSpin</p>
               
               <pre><code class="language-go">func runtime_doSpin()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_nanotime" data-name="runtime_nanotime">
               <h3>
                  runtime_nanotime 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_nanotime" class="anchor" title="Link to runtime_nanotime">#</a>
               </h3>
               
               <p>go:linkname runtime_nanotime</p>
               
               <pre><code class="language-go">func runtime_nanotime() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_rand" data-name="runtime_rand">
               <h3>
                  runtime_rand 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_rand" class="anchor" title="Link to runtime_rand">#</a>
               </h3>
               
               <p>Pull in runtime.rand so that we don't need to take a dependency
on math/rand/v2.
go:linkname runtime_rand runtime.rand</p>
               
               <pre><code class="language-go">func runtime_rand() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="swap" data-name="swap">
               <h3>
                  swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#swap" class="anchor" title="Link to swap">#</a>
               </h3>
               
               <p>swap replaces an entry in the overflow chain if keys compare equal. Returns the new entry chain,
the old value, and whether or not anything was swapped.
swap must be called under the mutex of the indirect node which e is a child of.</p>
               
               <pre><code class="language-go">func (head **ast.IndexListExpr) swap(key K, new V) (**ast.IndexListExpr, V, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="throw" data-name="throw">
               <h3>
                  throw 
                  <span class="badge">function</span>
                  
                  <a href="#throw" class="anchor" title="Link to throw">#</a>
               </h3>
               
               <p>go:linkname throw</p>
               
               <pre><code class="language-go">func throw(string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unlockSlow" data-name="unlockSlow">
               <h3>
                  unlockSlow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unlockSlow" class="anchor" title="Link to unlockSlow">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *Mutex) unlockSlow(new int32)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>