<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>cfg - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>cfg</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"fmt"
"go/ast"
"go/token"
"bytes"
"fmt"
"go/ast"
"go/format"
"go/token"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="KindBody" data-name="KindBody">
               <h3>
                  KindBody 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindBody" class="anchor" title="Link to KindBody">#</a>
               </h3>
               
               <pre><code class="language-go">const KindBody</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindForBody" data-name="KindForBody">
               <h3>
                  KindForBody 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindForBody" class="anchor" title="Link to KindForBody">#</a>
               </h3>
               
               <pre><code class="language-go">const KindForBody</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindForDone" data-name="KindForDone">
               <h3>
                  KindForDone 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindForDone" class="anchor" title="Link to KindForDone">#</a>
               </h3>
               
               <pre><code class="language-go">const KindForDone</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindForLoop" data-name="KindForLoop">
               <h3>
                  KindForLoop 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindForLoop" class="anchor" title="Link to KindForLoop">#</a>
               </h3>
               
               <pre><code class="language-go">const KindForLoop</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindForPost" data-name="KindForPost">
               <h3>
                  KindForPost 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindForPost" class="anchor" title="Link to KindForPost">#</a>
               </h3>
               
               <pre><code class="language-go">const KindForPost</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindIfDone" data-name="KindIfDone">
               <h3>
                  KindIfDone 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindIfDone" class="anchor" title="Link to KindIfDone">#</a>
               </h3>
               
               <pre><code class="language-go">const KindIfDone</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindIfElse" data-name="KindIfElse">
               <h3>
                  KindIfElse 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindIfElse" class="anchor" title="Link to KindIfElse">#</a>
               </h3>
               
               <pre><code class="language-go">const KindIfElse</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindIfThen" data-name="KindIfThen">
               <h3>
                  KindIfThen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindIfThen" class="anchor" title="Link to KindIfThen">#</a>
               </h3>
               
               <pre><code class="language-go">const KindIfThen</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindInvalid" data-name="KindInvalid">
               <h3>
                  KindInvalid 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindInvalid" class="anchor" title="Link to KindInvalid">#</a>
               </h3>
               
               <pre><code class="language-go">const KindInvalid BlockKind = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindLabel" data-name="KindLabel">
               <h3>
                  KindLabel 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindLabel" class="anchor" title="Link to KindLabel">#</a>
               </h3>
               
               <pre><code class="language-go">const KindLabel</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindRangeBody" data-name="KindRangeBody">
               <h3>
                  KindRangeBody 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindRangeBody" class="anchor" title="Link to KindRangeBody">#</a>
               </h3>
               
               <pre><code class="language-go">const KindRangeBody</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindRangeDone" data-name="KindRangeDone">
               <h3>
                  KindRangeDone 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindRangeDone" class="anchor" title="Link to KindRangeDone">#</a>
               </h3>
               
               <pre><code class="language-go">const KindRangeDone</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindRangeLoop" data-name="KindRangeLoop">
               <h3>
                  KindRangeLoop 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindRangeLoop" class="anchor" title="Link to KindRangeLoop">#</a>
               </h3>
               
               <pre><code class="language-go">const KindRangeLoop</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindSelectAfterCase" data-name="KindSelectAfterCase">
               <h3>
                  KindSelectAfterCase 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindSelectAfterCase" class="anchor" title="Link to KindSelectAfterCase">#</a>
               </h3>
               
               <pre><code class="language-go">const KindSelectAfterCase</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindSelectCaseBody" data-name="KindSelectCaseBody">
               <h3>
                  KindSelectCaseBody 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindSelectCaseBody" class="anchor" title="Link to KindSelectCaseBody">#</a>
               </h3>
               
               <pre><code class="language-go">const KindSelectCaseBody</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindSelectDone" data-name="KindSelectDone">
               <h3>
                  KindSelectDone 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindSelectDone" class="anchor" title="Link to KindSelectDone">#</a>
               </h3>
               
               <pre><code class="language-go">const KindSelectDone</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindSwitchCaseBody" data-name="KindSwitchCaseBody">
               <h3>
                  KindSwitchCaseBody 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindSwitchCaseBody" class="anchor" title="Link to KindSwitchCaseBody">#</a>
               </h3>
               
               <pre><code class="language-go">const KindSwitchCaseBody</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindSwitchDone" data-name="KindSwitchDone">
               <h3>
                  KindSwitchDone 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindSwitchDone" class="anchor" title="Link to KindSwitchDone">#</a>
               </h3>
               
               <pre><code class="language-go">const KindSwitchDone</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindSwitchNextCase" data-name="KindSwitchNextCase">
               <h3>
                  KindSwitchNextCase 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindSwitchNextCase" class="anchor" title="Link to KindSwitchNextCase">#</a>
               </h3>
               
               <pre><code class="language-go">const KindSwitchNextCase</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindUnreachable" data-name="KindUnreachable">
               <h3>
                  KindUnreachable 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindUnreachable" class="anchor" title="Link to KindUnreachable">#</a>
               </h3>
               
               <pre><code class="language-go">const KindUnreachable</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="BlockKind" data-name="BlockKind">
               <h3>
                  BlockKind
                  <span class="badge type-badge">type</span>
                  <a href="#BlockKind" class="anchor" title="Link to BlockKind">#</a>
               </h3>
               
               <p>A BlockKind identifies the purpose of a block.
It also determines the possible types of its Stmt field.</p>
               
               <pre><code class="language-go">type BlockKind uint8</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Block" data-name="Block">
               <h3>
                  Block
                  <span class="badge">struct</span>
                  <a href="#Block" class="anchor" title="Link to Block">#</a>
               </h3>
               
               <p>A Block represents a basic block: a list of statements and
expressions that are always evaluated sequentially.
A block may have 0-2 successors: zero for a return block or a block
that calls a function such as panic that never returns; one for a
normal (jump) block; and two for a conditional (if) block.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Block struct {
Nodes []ast.Node
Succs []*Block
Index int32
Live bool
Kind BlockKind
Stmt ast.Stmt
succs2 [2]*Block
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="CFG" data-name="CFG">
               <h3>
                  CFG
                  <span class="badge">struct</span>
                  <a href="#CFG" class="anchor" title="Link to CFG">#</a>
               </h3>
               
               <p>A CFG represents the control-flow graph of a single function.
The entry point is Blocks[0]; there may be multiple return blocks.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type CFG struct {
fset *token.FileSet
Blocks []*Block
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="builder" data-name="builder">
               <h3>
                  builder
                  <span class="badge">struct</span>
                  <a href="#builder" class="anchor" title="Link to builder">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type builder struct {
cfg *CFG
mayReturn func(*ast.CallExpr) bool
current *Block
lblocks map[string]*lblock
targets *targets
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="lblock" data-name="lblock">
               <h3>
                  lblock
                  <span class="badge">struct</span>
                  <a href="#lblock" class="anchor" title="Link to lblock">#</a>
               </h3>
               
               <p>Destinations associated with a labeled block.
We populate these as labels are encountered in forward gotos or
labeled statements.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type lblock struct {
_goto *Block
_break *Block
_continue *Block
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="targets" data-name="targets">
               <h3>
                  targets
                  <span class="badge">struct</span>
                  <a href="#targets" class="anchor" title="Link to targets">#</a>
               </h3>
               
               <p>Destinations associated with unlabeled for/switch/select stmts.
We push/pop one of these as we enter/leave each construct and for
each BranchStmt we scan for the innermost target of the right type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type targets struct {
tail *targets
_break *Block
_continue *Block
_fallthrough *Block
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Dot" data-name="Dot">
               <h3>
                  Dot 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Dot" class="anchor" title="Link to Dot">#</a>
               </h3>
               
               <p>Dot returns the control-flow graph in the [Dot graph description language].
Use a command such as 'dot -Tsvg' to render it in a form viewable in a browser.
This method is provided as a debugging aid; the details of the
output are unspecified and may change.
[Dot graph description language]: ​​https://en.wikipedia.org/wiki/DOT_(graph_description_language)</p>
               
               <pre><code class="language-go">func (g *CFG) Dot(fset *token.FileSet) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Format" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Format" class="anchor" title="Link to Format">#</a>
               </h3>
               
               <p>Format formats the control-flow graph for ease of debugging.</p>
               
               <pre><code class="language-go">func (g *CFG) Format(fset *token.FileSet) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="New" data-name="New">
               <h3>
                  New 
                  <span class="badge">function</span>
                  
                  <a href="#New" class="anchor" title="Link to New">#</a>
               </h3>
               
               <p>New returns a new control-flow graph for the specified function body,
which must be non-nil.
The CFG builder calls mayReturn to determine whether a given function
call may return.  For example, calls to panic, os.Exit, and log.Fatal
do not return, so the builder can remove infeasible graph edges
following such calls.  The builder calls mayReturn only for a
CallExpr beneath an ExprStmt.</p>
               
               <pre><code class="language-go">func New(body *ast.BlockStmt, mayReturn func(*ast.CallExpr) bool) *CFG</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Return" data-name="Return">
               <h3>
                  Return 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Return" class="anchor" title="Link to Return">#</a>
               </h3>
               
               <p>Return returns the return statement at the end of this block if present, nil
otherwise.
When control falls off the end of the function, the ReturnStmt is synthetic
and its [ast.Node.End] position may be beyond the end of the file.</p>
               
               <pre><code class="language-go">func (b *Block) Return() (ret *ast.ReturnStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Block) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (kind BlockKind) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *builder) add(n ast.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="branchStmt" data-name="branchStmt">
               <h3>
                  branchStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#branchStmt" class="anchor" title="Link to branchStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *builder) branchStmt(s *ast.BranchStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="comment" data-name="comment">
               <h3>
                  comment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#comment" class="anchor" title="Link to comment">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Block) comment(fset *token.FileSet) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="forStmt" data-name="forStmt">
               <h3>
                  forStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#forStmt" class="anchor" title="Link to forStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *builder) forStmt(s *ast.ForStmt, label *lblock)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formatNode" data-name="formatNode">
               <h3>
                  formatNode 
                  <span class="badge">function</span>
                  
                  <a href="#formatNode" class="anchor" title="Link to formatNode">#</a>
               </h3>
               
               <pre><code class="language-go">func formatNode(fset *token.FileSet, n ast.Node) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ifelse" data-name="ifelse">
               <h3>
                  ifelse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ifelse" class="anchor" title="Link to ifelse">#</a>
               </h3>
               
               <p>ifelse emits edges from the current block to the t and f blocks,
and sets b.current to nil.</p>
               
               <pre><code class="language-go">func (b *builder) ifelse(t *Block, f *Block)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="jump" data-name="jump">
               <h3>
                  jump 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#jump" class="anchor" title="Link to jump">#</a>
               </h3>
               
               <p>jump adds an edge from the current block to the target block,
and sets b.current to nil.</p>
               
               <pre><code class="language-go">func (b *builder) jump(target *Block)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="labeledBlock" data-name="labeledBlock">
               <h3>
                  labeledBlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#labeledBlock" class="anchor" title="Link to labeledBlock">#</a>
               </h3>
               
               <p>labeledBlock returns the branch target associated with the
specified label, creating it if needed.</p>
               
               <pre><code class="language-go">func (b *builder) labeledBlock(label *ast.Ident, stmt *ast.LabeledStmt) *lblock</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newBlock" data-name="newBlock">
               <h3>
                  newBlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newBlock" class="anchor" title="Link to newBlock">#</a>
               </h3>
               
               <p>newBlock appends a new unconnected basic block to b.cfg's block
slice and returns it.
It does not automatically become the current block.
comment is an optional string for more readable debugging output.</p>
               
               <pre><code class="language-go">func (b *builder) newBlock(kind BlockKind, stmt ast.Stmt) *Block</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rangeStmt" data-name="rangeStmt">
               <h3>
                  rangeStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rangeStmt" class="anchor" title="Link to rangeStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *builder) rangeStmt(s *ast.RangeStmt, label *lblock)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="selectStmt" data-name="selectStmt">
               <h3>
                  selectStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#selectStmt" class="anchor" title="Link to selectStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *builder) selectStmt(s *ast.SelectStmt, label *lblock)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmt" data-name="stmt">
               <h3>
                  stmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmt" class="anchor" title="Link to stmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *builder) stmt(_s ast.Stmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmtList" data-name="stmtList">
               <h3>
                  stmtList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmtList" class="anchor" title="Link to stmtList">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *builder) stmtList(list []ast.Stmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="switchStmt" data-name="switchStmt">
               <h3>
                  switchStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#switchStmt" class="anchor" title="Link to switchStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *builder) switchStmt(s *ast.SwitchStmt, label *lblock)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeCaseBody" data-name="typeCaseBody">
               <h3>
                  typeCaseBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeCaseBody" class="anchor" title="Link to typeCaseBody">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *builder) typeCaseBody(cc *ast.CaseClause, done *Block)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeSwitchStmt" data-name="typeSwitchStmt">
               <h3>
                  typeSwitchStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeSwitchStmt" class="anchor" title="Link to typeSwitchStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *builder) typeSwitchStmt(s *ast.TypeSwitchStmt, label *lblock)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>