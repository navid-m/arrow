<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - rand</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>rand</code>
         </h1>
         <hr />
         
         <article class="global" data-name="Reader">
            <h2>Reader</h2>
            <hr />
            
            <p>Reader is a global, shared instance of a cryptographically
secure random number generator. It is safe for concurrent use.

  - On Linux, FreeBSD, Dragonfly, and Solaris, Reader uses getrandom(2).
  - On legacy Linux (< 3.17), Reader opens /dev/urandom on first use.
  - On macOS, iOS, and OpenBSD Reader, uses arc4random_buf(3).
  - On NetBSD, Reader uses the kern.arandom sysctl.
  - On Windows, Reader uses the ProcessPrng API.
  - On js/wasm, Reader uses the Web Crypto API.
  - On wasip1/wasm, Reader uses random_get.

In FIPS 140-3 mode, the output passes through an SP 800-90A Rev. 1
Deterministric Random Bit Generator (DRBG).</p>
            
            <pre><code>Reader io.Reader</code></pre>
         </article>
         
         <article class="global" data-name="sink">
            <h2>sink</h2>
            <hr />
            
            <pre><code>sink byte</code></pre>
         </article>
         
         <article class="global" data-name="base32alphabet">
            <h2>base32alphabet</h2>
            <hr />
            
            <pre><code>base32alphabet</code></pre>
         </article>
          
         <article class="struct" data-name="reader">
            <h2>type reader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">drbg.DefaultReader</code></pre>
         </article>
          
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="fatal">
            <h2>fatal</h2>
            <hr />
            
            <p>fatal is [runtime.fatal], pushed via linkname.</p>
            
            <pre><code>func fatal(string)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <p>Read fills b with cryptographically secure random bytes. It never returns an
error, and always fills b entirely.

Read calls [io.ReadFull] on [Reader] and crashes the program irrecoverably if
an error is returned. The default Reader uses operating system APIs that are
documented to never return an error on all but legacy Linux systems.</p>
            
            <pre><code>func Read(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="testReadAndReader">
            <h2>testReadAndReader</h2>
            <hr />
            
            <pre><code>func testReadAndReader(t *testing.T, f func)</code></pre>
         </article>
         
         <article class="function" data-name="TestRead">
            <h2>TestRead</h2>
            <hr />
            
            <pre><code>func TestRead(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testRead">
            <h2>testRead</h2>
            <hr />
            
            <pre><code>func testRead(t *testing.T, Read func)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadByteValues">
            <h2>TestReadByteValues</h2>
            <hr />
            
            <pre><code>func TestReadByteValues(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testReadByteValues">
            <h2>testReadByteValues</h2>
            <hr />
            
            <pre><code>func testReadByteValues(t *testing.T, Read func)</code></pre>
         </article>
         
         <article class="function" data-name="TestLargeRead">
            <h2>TestLargeRead</h2>
            <hr />
            
            <pre><code>func TestLargeRead(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testLargeRead">
            <h2>testLargeRead</h2>
            <hr />
            
            <pre><code>func testLargeRead(t *testing.T, Read func)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadEmpty">
            <h2>TestReadEmpty</h2>
            <hr />
            
            <pre><code>func TestReadEmpty(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testReadEmpty">
            <h2>testReadEmpty</h2>
            <hr />
            
            <pre><code>func testReadEmpty(t *testing.T, Read func)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(b []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadUsesReader">
            <h2>TestReadUsesReader</h2>
            <hr />
            
            <pre><code>func TestReadUsesReader(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestConcurrentRead">
            <h2>TestConcurrentRead</h2>
            <hr />
            
            <pre><code>func TestConcurrentRead(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testConcurrentRead">
            <h2>testConcurrentRead</h2>
            <hr />
            
            <pre><code>func testConcurrentRead(t *testing.T, Read func)</code></pre>
         </article>
         
         <article class="function" data-name="TestAllocations">
            <h2>TestAllocations</h2>
            <hr />
            
            <pre><code>func TestAllocations(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReadError">
            <h2>TestReadError</h2>
            <hr />
            
            <pre><code>func TestReadError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkRead">
            <h2>BenchmarkRead</h2>
            <hr />
            
            <pre><code>func BenchmarkRead(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="benchmarkRead">
            <h2>benchmarkRead</h2>
            <hr />
            
            <pre><code>func benchmarkRead(b *testing.B, size int)</code></pre>
         </article>
         
         <article class="function" data-name="Text">
            <h2>Text</h2>
            <hr />
            
            <p>Text returns a cryptographically random string using the standard RFC 4648 base32 alphabet
for use when a secret string, token, password, or other text is needed.
The result contains at least 128 bits of randomness, enough to prevent brute force
guessing attacks and to make the likelihood of collisions vanishingly small.
A future version may return longer texts as needed to maintain those properties.</p>
            
            <pre><code>func Text() string</code></pre>
         </article>
         
         <article class="function" data-name="Prime">
            <h2>Prime</h2>
            <hr />
            
            <p>Prime returns a number of the given bit length that is prime with high probability.
Prime will return error for any error returned by rand.Read or if bits < 2.</p>
            
            <pre><code>func Prime(rand io.Reader, bits int) (*big.Int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Int">
            <h2>Int</h2>
            <hr />
            
            <p>Int returns a uniform random value in [0, max). It panics if max <= 0, and
returns an error if rand.Read returns one.</p>
            
            <pre><code>func Int(rand io.Reader, max *big.Int) (n *big.Int, err error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
