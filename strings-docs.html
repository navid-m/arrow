<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - strings</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>strings</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"internal/bytealg"
"internal/stringslite"
"math/bits"
"unicode"
"unicode/utf8"
"internal/abi"
"internal/bytealg"
"unicode/utf8"
"unsafe"
"internal/stringslite"
"internal/bytealg"
"iter"
"unicode"
"unicode/utf8"
"errors"
"io"
"unicode/utf8"
"io"
"sync"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="asciiSpace">
               <h3>
                  asciiSpace 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var asciiSpace = [256]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="countCutOff">
               <h3>
                  countCutOff 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>countCutOff controls the ratio of a string length to a number of replacements
at which (*byteStringReplacer).Replace switches algorithms.
For strings with higher ration of length to replacements than that value,
we call Count, for each replacement from toReplace.
For strings, with a lower ratio we use simple loop, because of Count overhead.
countCutOff is an empirically determined overhead multiplier.
TODO(tocarip) revisit once we have register-based abi/mid-stack inlining.</p>
               
               <pre><code>const countCutOff = 8</code></pre>
            </article>
            
            <article class="global" data-name="maxInt">
               <h3>
                  maxInt 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxInt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="repeatedDashes">
               <h3>
                  repeatedDashes 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>According to static analysis, spaces, dashes, zeros, equals, and tabs
are the most commonly repeated string literal,
often used for display on fixed-width terminal windows.
Pre-declare constants for these for O(1) repetition in the common-case.</p>
               
               <pre><code>const repeatedDashes = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="repeatedEquals">
               <h3>
                  repeatedEquals 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>According to static analysis, spaces, dashes, zeros, equals, and tabs
are the most commonly repeated string literal,
often used for display on fixed-width terminal windows.
Pre-declare constants for these for O(1) repetition in the common-case.</p>
               
               <pre><code>const repeatedEquals = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="repeatedSpaces">
               <h3>
                  repeatedSpaces 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>According to static analysis, spaces, dashes, zeros, equals, and tabs
are the most commonly repeated string literal,
often used for display on fixed-width terminal windows.
Pre-declare constants for these for O(1) repetition in the common-case.</p>
               
               <pre><code>const repeatedSpaces = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="repeatedTabs">
               <h3>
                  repeatedTabs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>According to static analysis, spaces, dashes, zeros, equals, and tabs
are the most commonly repeated string literal,
often used for display on fixed-width terminal windows.
Pre-declare constants for these for O(1) repetition in the common-case.</p>
               
               <pre><code>const repeatedTabs = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="repeatedZeroes">
               <h3>
                  repeatedZeroes 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>According to static analysis, spaces, dashes, zeros, equals, and tabs
are the most commonly repeated string literal,
often used for display on fixed-width terminal windows.
Pre-declare constants for these for O(1) repetition in the common-case.</p>
               
               <pre><code>const repeatedZeroes = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="appendSliceWriter">
               <h3>
                  appendSliceWriter
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type appendSliceWriter []byte</code></pre>
            </article>
            
            <article class="type" data-name="asciiSet">
               <h3>
                  asciiSet
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>asciiSet is a 32-byte value, where each bit represents the presence of a
given ASCII character in the set. The 128-bits of the lower 16 bytes,
starting with the least-significant bit of the lowest word to the
most-significant bit of the highest word, map to the full range of all
128 ASCII characters. The 128-bits of the upper 16 bytes will be zeroed,
ensuring that any non-ASCII character will be reported as not in the set.
This allocates a total of 32 bytes even though the upper half
is unused to avoid bounds checks in asciiSet.contains.</p>
               
               <pre><code>type asciiSet [8]uint32</code></pre>
            </article>
            
            <article class="type" data-name="byteReplacer">
               <h3>
                  byteReplacer
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>byteReplacer is the implementation that's used when all the "old"
and "new" values are single ASCII bytes.
The array contains replacement bytes indexed by old byte.</p>
               
               <pre><code>type byteReplacer [256]byte</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="replacer">
               <h3>
                  replacer
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>replacer is the interface that a replacement algorithm needs to implement.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type replacer interface {
Replace(s string) string
WriteString(w io.Writer, s string) (n int, err error)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Builder">
               <h3>
                  Builder
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Builder is used to efficiently build a string using [Builder.Write] methods.
It minimizes memory copying. The zero value is ready to use.
Do not copy a non-zero Builder.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Builder struct {
addr *Builder
buf []byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="Reader">
               <h3>
                  Reader
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Reader implements the [io.Reader], [io.ReaderAt], [io.ByteReader], [io.ByteScanner],
[io.RuneReader], [io.RuneScanner], [io.Seeker], and [io.WriterTo] interfaces by reading
from a string.
The zero value for Reader operates like a Reader of an empty string.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Reader struct {
s string
i int64
prevRune int
}</code></pre>
            </article>
            
            <article class="struct" data-name="Replacer">
               <h3>
                  Replacer
                  <span class="badge">struct</span>
               </h3>
               
               <p>Replacer replaces a list of strings with replacements.
It is safe for concurrent use by multiple goroutines.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Replacer struct {
once sync.Once
r replacer
oldnew []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="byteStringReplacer">
               <h3>
                  byteStringReplacer
                  <span class="badge">struct</span>
               </h3>
               
               <p>byteStringReplacer is the implementation that's used when all the
"old" values are single ASCII bytes but the "new" values vary in size.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type byteStringReplacer struct {
replacements [256][]byte
toReplace []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="genericReplacer">
               <h3>
                  genericReplacer
                  <span class="badge">struct</span>
               </h3>
               
               <p>genericReplacer is the fully generic algorithm.
It's used as a fallback when nothing faster can be used.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type genericReplacer struct {
root trieNode
tableSize int
mapping [256]byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="singleStringReplacer">
               <h3>
                  singleStringReplacer
                  <span class="badge">struct</span>
               </h3>
               
               <p>singleStringReplacer is the implementation that's used when there is only
one string to replace (and that string has more than one byte).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type singleStringReplacer struct {
finder *stringFinder
value string
}</code></pre>
            </article>
            
            <article class="struct" data-name="stringFinder">
               <h3>
                  stringFinder
                  <span class="badge">struct</span>
               </h3>
               
               <p>stringFinder efficiently finds strings in a source text. It's implemented
using the Boyer-Moore string search algorithm:
https://en.wikipedia.org/wiki/Boyer-Moore_string_search_algorithm
https://www.cs.utexas.edu/~moore/publications/fstrpos.pdf (note: this aged
document uses 1-based indexing)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type stringFinder struct {
pattern string
badCharSkip [256]int
goodSuffixSkip []int
}</code></pre>
            </article>
            
            <article class="struct" data-name="stringWriter">
               <h3>
                  stringWriter
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type stringWriter struct {
w io.Writer
}</code></pre>
            </article>
            
            <article class="struct" data-name="trieNode">
               <h3>
                  trieNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>trieNode is a node in a lookup trie for prioritized key/value pairs. Keys
and values may be empty. For example, the trie containing keys "ax", "ay",
"bcbc", "x" and "xy" could have eight nodes:
n0  -
n1  a-
n2  .x+
n3  .y+
n4  b-
n5  .cbc+
n6  x+
n7  .y+
n0 is the root node, and its children are n1, n4 and n6; n1's children are
n2 and n3; n4's child is n5; n6's child is n7. Nodes n0, n1 and n4 (marked
with a trailing "-") are partial keys, and nodes n2, n3, n5, n6 and n7
(marked with a trailing "+") are complete keys.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type trieNode struct {
value string
priority int
prefix string
next *trieNode
table []*trieNode
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Cap">
               <h3>
                  Cap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Cap returns the capacity of the builder's underlying byte slice. It is the
total space allocated for the string being built and includes any bytes
already written.</p>
               
               <pre><code>func (b *Builder) Cap() int</code></pre>
            </article>
            
            <article class="function" data-name="Clone">
               <h3>
                  Clone 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Clone returns a fresh copy of s.
It guarantees to make a copy of s into a new allocation,
which can be important when retaining only a small substring
of a much larger string. Using Clone can help such programs
use less memory. Of course, since using Clone makes a copy,
overuse of Clone can make programs use more memory.
Clone should typically be used only rarely, and only when
profiling indicates that it is needed.
For strings of length zero the string "" will be returned
and no allocation is made.</p>
               
               <pre><code>func Clone(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="Compare">
               <h3>
                  Compare 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Compare returns an integer comparing two strings lexicographically.
The result will be 0 if a == b, -1 if a < b, and +1 if a > b.
Use Compare when you need to perform a three-way comparison (with
[slices.SortFunc], for example). It is usually clearer and always faster
to use the built-in string comparison operators ==, <, >, and so on.</p>
               
               <pre><code>func Compare(a string, b string) int</code></pre>
            </article>
            
            <article class="function" data-name="Contains">
               <h3>
                  Contains 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Contains reports whether substr is within s.</p>
               
               <pre><code>func Contains(s string, substr string) bool</code></pre>
            </article>
            
            <article class="function" data-name="ContainsAny">
               <h3>
                  ContainsAny 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ContainsAny reports whether any Unicode code points in chars are within s.</p>
               
               <pre><code>func ContainsAny(s string, chars string) bool</code></pre>
            </article>
            
            <article class="function" data-name="ContainsFunc">
               <h3>
                  ContainsFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ContainsFunc reports whether any Unicode code points r within s satisfy f(r).</p>
               
               <pre><code>func ContainsFunc(s string, f func(rune) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="ContainsRune">
               <h3>
                  ContainsRune 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ContainsRune reports whether the Unicode code point r is within s.</p>
               
               <pre><code>func ContainsRune(s string, r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="Count">
               <h3>
                  Count 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Count counts the number of non-overlapping instances of substr in s.
If substr is an empty string, Count returns 1 + the number of Unicode code points in s.</p>
               
               <pre><code>func Count(s string, substr string) int</code></pre>
            </article>
            
            <article class="function" data-name="Cut">
               <h3>
                  Cut 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Cut slices s around the first instance of sep,
returning the text before and after sep.
The found result reports whether sep appears in s.
If sep does not appear in s, cut returns s, "", false.</p>
               
               <pre><code>func Cut(s string, sep string) (before string, after string, found bool)</code></pre>
            </article>
            
            <article class="function" data-name="CutPrefix">
               <h3>
                  CutPrefix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CutPrefix returns s without the provided leading prefix string
and reports whether it found the prefix.
If s doesn't start with prefix, CutPrefix returns s, false.
If prefix is the empty string, CutPrefix returns s, true.</p>
               
               <pre><code>func CutPrefix(s string, prefix string) (after string, found bool)</code></pre>
            </article>
            
            <article class="function" data-name="CutSuffix">
               <h3>
                  CutSuffix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CutSuffix returns s without the provided ending suffix string
and reports whether it found the suffix.
If s doesn't end with suffix, CutSuffix returns s, false.
If suffix is the empty string, CutSuffix returns s, true.</p>
               
               <pre><code>func CutSuffix(s string, suffix string) (before string, found bool)</code></pre>
            </article>
            
            <article class="function" data-name="EqualFold">
               <h3>
                  EqualFold 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>EqualFold reports whether s and t, interpreted as UTF-8 strings,
are equal under simple Unicode case-folding, which is a more general
form of case-insensitivity.</p>
               
               <pre><code>func EqualFold(s string, t string) bool</code></pre>
            </article>
            
            <article class="function" data-name="Fields">
               <h3>
                  Fields 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Fields splits the string s around each instance of one or more consecutive white space
characters, as defined by [unicode.IsSpace], returning a slice of substrings of s or an
empty slice if s contains only white space.</p>
               
               <pre><code>func Fields(s string) []string</code></pre>
            </article>
            
            <article class="function" data-name="FieldsFunc">
               <h3>
                  FieldsFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)
and returns an array of slices of s. If all code points in s satisfy f(c) or the
string is empty, an empty slice is returned.
FieldsFunc makes no guarantees about the order in which it calls f(c)
and assumes that f always returns the same value for a given c.</p>
               
               <pre><code>func FieldsFunc(s string, f func(rune) bool) []string</code></pre>
            </article>
            
            <article class="function" data-name="FieldsFuncSeq">
               <h3>
                  FieldsFuncSeq 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FieldsFuncSeq returns an iterator over substrings of s split around runs of
Unicode code points satisfying f(c).
The iterator yields the same strings that would be returned by [FieldsFunc](s),
but without constructing the slice.</p>
               
               <pre><code>func FieldsFuncSeq(s string, f func(rune) bool) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function" data-name="FieldsSeq">
               <h3>
                  FieldsSeq 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FieldsSeq returns an iterator over substrings of s split around runs of
whitespace characters, as defined by [unicode.IsSpace].
The iterator yields the same strings that would be returned by [Fields](s),
but without constructing the slice.</p>
               
               <pre><code>func FieldsSeq(s string) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function" data-name="Grow">
               <h3>
                  Grow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Grow grows b's capacity, if necessary, to guarantee space for
another n bytes. After Grow(n), at least n bytes can be written to b
without another allocation. If n is negative, Grow panics.</p>
               
               <pre><code>func (b *Builder) Grow(n int)</code></pre>
            </article>
            
            <article class="function" data-name="HasPrefix">
               <h3>
                  HasPrefix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>HasPrefix reports whether the string s begins with prefix.</p>
               
               <pre><code>func HasPrefix(s string, prefix string) bool</code></pre>
            </article>
            
            <article class="function" data-name="HasSuffix">
               <h3>
                  HasSuffix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>HasSuffix reports whether the string s ends with suffix.</p>
               
               <pre><code>func HasSuffix(s string, suffix string) bool</code></pre>
            </article>
            
            <article class="function" data-name="Index">
               <h3>
                  Index 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.</p>
               
               <pre><code>func Index(s string, substr string) int</code></pre>
            </article>
            
            <article class="function" data-name="IndexAny">
               <h3>
                  IndexAny 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IndexAny returns the index of the first instance of any Unicode code point
from chars in s, or -1 if no Unicode code point from chars is present in s.</p>
               
               <pre><code>func IndexAny(s string, chars string) int</code></pre>
            </article>
            
            <article class="function" data-name="IndexByte">
               <h3>
                  IndexByte 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.</p>
               
               <pre><code>func IndexByte(s string, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="IndexFunc">
               <h3>
                  IndexFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IndexFunc returns the index into s of the first Unicode
code point satisfying f(c), or -1 if none do.</p>
               
               <pre><code>func IndexFunc(s string, f func(rune) bool) int</code></pre>
            </article>
            
            <article class="function" data-name="IndexRune">
               <h3>
                  IndexRune 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IndexRune returns the index of the first instance of the Unicode code point
r, or -1 if rune is not present in s.
If r is [utf8.RuneError], it returns the first instance of any
invalid UTF-8 byte sequence.</p>
               
               <pre><code>func IndexRune(s string, r rune) int</code></pre>
            </article>
            
            <article class="function" data-name="Join">
               <h3>
                  Join 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Join concatenates the elements of its first argument to create a single string. The separator
string sep is placed between elements in the resulting string.</p>
               
               <pre><code>func Join(elems []string, sep string) string</code></pre>
            </article>
            
            <article class="function" data-name="LastIndex">
               <h3>
                  LastIndex 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.</p>
               
               <pre><code>func LastIndex(s string, substr string) int</code></pre>
            </article>
            
            <article class="function" data-name="LastIndexAny">
               <h3>
                  LastIndexAny 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LastIndexAny returns the index of the last instance of any Unicode code
point from chars in s, or -1 if no Unicode code point from chars is
present in s.</p>
               
               <pre><code>func LastIndexAny(s string, chars string) int</code></pre>
            </article>
            
            <article class="function" data-name="LastIndexByte">
               <h3>
                  LastIndexByte 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.</p>
               
               <pre><code>func LastIndexByte(s string, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="LastIndexFunc">
               <h3>
                  LastIndexFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LastIndexFunc returns the index into s of the last
Unicode code point satisfying f(c), or -1 if none do.</p>
               
               <pre><code>func LastIndexFunc(s string, f func(rune) bool) int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Len returns the number of accumulated bytes; b.Len() == len(b.String()).</p>
               
               <pre><code>func (b *Builder) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Len returns the number of bytes of the unread portion of the
string.</p>
               
               <pre><code>func (r *Reader) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Lines">
               <h3>
                  Lines 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Lines returns an iterator over the newline-terminated lines in the string s.
The lines yielded by the iterator include their terminating newlines.
If s is empty, the iterator yields no lines at all.
If s does not end in a newline, the final yielded line will not end in a newline.
It returns a single-use iterator.</p>
               
               <pre><code>func Lines(s string) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function" data-name="Map">
               <h3>
                  Map 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Map returns a copy of the string s with all its characters modified
according to the mapping function. If mapping returns a negative value, the character is
dropped from the string with no replacement.</p>
               
               <pre><code>func Map(mapping func(rune) rune, s string) string</code></pre>
            </article>
            
            <article class="function" data-name="NewReader">
               <h3>
                  NewReader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewReader returns a new [Reader] reading from s.
It is similar to [bytes.NewBufferString] but more efficient and non-writable.</p>
               
               <pre><code>func NewReader(s string) *Reader</code></pre>
            </article>
            
            <article class="function" data-name="NewReplacer">
               <h3>
                  NewReplacer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewReplacer returns a new [Replacer] from a list of old, new string
pairs. Replacements are performed in the order they appear in the
target string, without overlapping matches. The old string
comparisons are done in argument order.
NewReplacer panics if given an odd number of arguments.</p>
               
               <pre><code>func NewReplacer(oldnew ...string) *Replacer</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Read implements the [io.Reader] interface.</p>
               
               <pre><code>func (r *Reader) Read(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadAt">
               <h3>
                  ReadAt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadAt implements the [io.ReaderAt] interface.</p>
               
               <pre><code>func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadByte">
               <h3>
                  ReadByte 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadByte implements the [io.ByteReader] interface.</p>
               
               <pre><code>func (r *Reader) ReadByte() (byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadRune">
               <h3>
                  ReadRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadRune implements the [io.RuneReader] interface.</p>
               
               <pre><code>func (r *Reader) ReadRune() (ch rune, size int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Repeat">
               <h3>
                  Repeat 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Repeat returns a new string consisting of count copies of the string s.
It panics if count is negative or if the result of (len(s) * count)
overflows.</p>
               
               <pre><code>func Repeat(s string, count int) string</code></pre>
            </article>
            
            <article class="function" data-name="Replace">
               <h3>
                  Replace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Replace returns a copy of the string s with the first n
non-overlapping instances of old replaced by new.
If old is empty, it matches at the beginning of the string
and after each UTF-8 sequence, yielding up to k+1 replacements
for a k-rune string.
If n < 0, there is no limit on the number of replacements.</p>
               
               <pre><code>func Replace(s string, old string, new string, n int) string</code></pre>
            </article>
            
            <article class="function" data-name="Replace">
               <h3>
                  Replace 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *byteReplacer) Replace(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="Replace">
               <h3>
                  Replace 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Replace returns a copy of s with all replacements performed.</p>
               
               <pre><code>func (r *Replacer) Replace(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="Replace">
               <h3>
                  Replace 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *byteStringReplacer) Replace(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="Replace">
               <h3>
                  Replace 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *genericReplacer) Replace(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="Replace">
               <h3>
                  Replace 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *singleStringReplacer) Replace(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="ReplaceAll">
               <h3>
                  ReplaceAll 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ReplaceAll returns a copy of the string s with all
non-overlapping instances of old replaced by new.
If old is empty, it matches at the beginning of the string
and after each UTF-8 sequence, yielding up to k+1 replacements
for a k-rune string.</p>
               
               <pre><code>func ReplaceAll(s string, old string, new string) string</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reset resets the [Builder] to be empty.</p>
               
               <pre><code>func (b *Builder) Reset()</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reset resets the [Reader] to be reading from s.</p>
               
               <pre><code>func (r *Reader) Reset(s string)</code></pre>
            </article>
            
            <article class="function" data-name="Seek">
               <h3>
                  Seek 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Seek implements the [io.Seeker] interface.</p>
               
               <pre><code>func (r *Reader) Seek(offset int64, whence int) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Size returns the original length of the underlying string.
Size is the number of bytes available for reading via [Reader.ReadAt].
The returned value is always the same and is not affected by calls
to any other method.</p>
               
               <pre><code>func (r *Reader) Size() int64</code></pre>
            </article>
            
            <article class="function" data-name="Split">
               <h3>
                  Split 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Split slices s into all substrings separated by sep and returns a slice of
the substrings between those separators.
If s does not contain sep and sep is not empty, Split returns a
slice of length 1 whose only element is s.
If sep is empty, Split splits after each UTF-8 sequence. If both s
and sep are empty, Split returns an empty slice.
It is equivalent to [SplitN] with a count of -1.
To split around the first instance of a separator, see [Cut].</p>
               
               <pre><code>func Split(s string, sep string) []string</code></pre>
            </article>
            
            <article class="function" data-name="SplitAfter">
               <h3>
                  SplitAfter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SplitAfter slices s into all substrings after each instance of sep and
returns a slice of those substrings.
If s does not contain sep and sep is not empty, SplitAfter returns
a slice of length 1 whose only element is s.
If sep is empty, SplitAfter splits after each UTF-8 sequence. If
both s and sep are empty, SplitAfter returns an empty slice.
It is equivalent to [SplitAfterN] with a count of -1.</p>
               
               <pre><code>func SplitAfter(s string, sep string) []string</code></pre>
            </article>
            
            <article class="function" data-name="SplitAfterN">
               <h3>
                  SplitAfterN 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SplitAfterN slices s into substrings after each instance of sep and
returns a slice of those substrings.
The count determines the number of substrings to return:
- n > 0: at most n substrings; the last substring will be the unsplit remainder;
- n == 0: the result is nil (zero substrings);
- n < 0: all substrings.
Edge cases for s and sep (for example, empty strings) are handled
as described in the documentation for [SplitAfter].</p>
               
               <pre><code>func SplitAfterN(s string, sep string, n int) []string</code></pre>
            </article>
            
            <article class="function" data-name="SplitAfterSeq">
               <h3>
                  SplitAfterSeq 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SplitAfterSeq returns an iterator over substrings of s split after each instance of sep.
The iterator yields the same strings that would be returned by [SplitAfter](s, sep),
but without constructing the slice.
It returns a single-use iterator.</p>
               
               <pre><code>func SplitAfterSeq(s string, sep string) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function" data-name="SplitN">
               <h3>
                  SplitN 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SplitN slices s into substrings separated by sep and returns a slice of
the substrings between those separators.
The count determines the number of substrings to return:
- n > 0: at most n substrings; the last substring will be the unsplit remainder;
- n == 0: the result is nil (zero substrings);
- n < 0: all substrings.
Edge cases for s and sep (for example, empty strings) are handled
as described in the documentation for [Split].
To split around the first instance of a separator, see [Cut].</p>
               
               <pre><code>func SplitN(s string, sep string, n int) []string</code></pre>
            </article>
            
            <article class="function" data-name="SplitSeq">
               <h3>
                  SplitSeq 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SplitSeq returns an iterator over all substrings of s separated by sep.
The iterator yields the same strings that would be returned by [Split](s, sep),
but without constructing the slice.
It returns a single-use iterator.</p>
               
               <pre><code>func SplitSeq(s string, sep string) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the accumulated string.</p>
               
               <pre><code>func (b *Builder) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Title">
               <h3>
                  Title 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Title returns a copy of the string s with all Unicode letters that begin words
mapped to their Unicode title case.
Deprecated: The rule Title uses for word boundaries does not handle Unicode
punctuation properly. Use golang.org/x/text/cases instead.</p>
               
               <pre><code>func Title(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="ToLower">
               <h3>
                  ToLower 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ToLower returns s with all Unicode letters mapped to their lower case.</p>
               
               <pre><code>func ToLower(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="ToLowerSpecial">
               <h3>
                  ToLowerSpecial 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their
lower case using the case mapping specified by c.</p>
               
               <pre><code>func ToLowerSpecial(c unicode.SpecialCase, s string) string</code></pre>
            </article>
            
            <article class="function" data-name="ToTitle">
               <h3>
                  ToTitle 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ToTitle returns a copy of the string s with all Unicode letters mapped to
their Unicode title case.</p>
               
               <pre><code>func ToTitle(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="ToTitleSpecial">
               <h3>
                  ToTitleSpecial 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their
Unicode title case, giving priority to the special casing rules.</p>
               
               <pre><code>func ToTitleSpecial(c unicode.SpecialCase, s string) string</code></pre>
            </article>
            
            <article class="function" data-name="ToUpper">
               <h3>
                  ToUpper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ToUpper returns s with all Unicode letters mapped to their upper case.</p>
               
               <pre><code>func ToUpper(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="ToUpperSpecial">
               <h3>
                  ToUpperSpecial 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their
upper case using the case mapping specified by c.</p>
               
               <pre><code>func ToUpperSpecial(c unicode.SpecialCase, s string) string</code></pre>
            </article>
            
            <article class="function" data-name="ToValidUTF8">
               <h3>
                  ToValidUTF8 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences
replaced by the replacement string, which may be empty.</p>
               
               <pre><code>func ToValidUTF8(s string, replacement string) string</code></pre>
            </article>
            
            <article class="function" data-name="Trim">
               <h3>
                  Trim 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Trim returns a slice of the string s with all leading and
trailing Unicode code points contained in cutset removed.</p>
               
               <pre><code>func Trim(s string, cutset string) string</code></pre>
            </article>
            
            <article class="function" data-name="TrimFunc">
               <h3>
                  TrimFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TrimFunc returns a slice of the string s with all leading
and trailing Unicode code points c satisfying f(c) removed.</p>
               
               <pre><code>func TrimFunc(s string, f func(rune) bool) string</code></pre>
            </article>
            
            <article class="function" data-name="TrimLeft">
               <h3>
                  TrimLeft 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TrimLeft returns a slice of the string s with all leading
Unicode code points contained in cutset removed.
To remove a prefix, use [TrimPrefix] instead.</p>
               
               <pre><code>func TrimLeft(s string, cutset string) string</code></pre>
            </article>
            
            <article class="function" data-name="TrimLeftFunc">
               <h3>
                  TrimLeftFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TrimLeftFunc returns a slice of the string s with all leading
Unicode code points c satisfying f(c) removed.</p>
               
               <pre><code>func TrimLeftFunc(s string, f func(rune) bool) string</code></pre>
            </article>
            
            <article class="function" data-name="TrimPrefix">
               <h3>
                  TrimPrefix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TrimPrefix returns s without the provided leading prefix string.
If s doesn't start with prefix, s is returned unchanged.</p>
               
               <pre><code>func TrimPrefix(s string, prefix string) string</code></pre>
            </article>
            
            <article class="function" data-name="TrimRight">
               <h3>
                  TrimRight 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TrimRight returns a slice of the string s, with all trailing
Unicode code points contained in cutset removed.
To remove a suffix, use [TrimSuffix] instead.</p>
               
               <pre><code>func TrimRight(s string, cutset string) string</code></pre>
            </article>
            
            <article class="function" data-name="TrimRightFunc">
               <h3>
                  TrimRightFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TrimRightFunc returns a slice of the string s with all trailing
Unicode code points c satisfying f(c) removed.</p>
               
               <pre><code>func TrimRightFunc(s string, f func(rune) bool) string</code></pre>
            </article>
            
            <article class="function" data-name="TrimSpace">
               <h3>
                  TrimSpace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TrimSpace returns a slice of the string s, with all leading
and trailing white space removed, as defined by Unicode.</p>
               
               <pre><code>func TrimSpace(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="TrimSuffix">
               <h3>
                  TrimSuffix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TrimSuffix returns s without the provided trailing suffix string.
If s doesn't end with suffix, s is returned unchanged.</p>
               
               <pre><code>func TrimSuffix(s string, suffix string) string</code></pre>
            </article>
            
            <article class="function" data-name="UnreadByte">
               <h3>
                  UnreadByte 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnreadByte implements the [io.ByteScanner] interface.</p>
               
               <pre><code>func (r *Reader) UnreadByte() error</code></pre>
            </article>
            
            <article class="function" data-name="UnreadRune">
               <h3>
                  UnreadRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnreadRune implements the [io.RuneScanner] interface.</p>
               
               <pre><code>func (r *Reader) UnreadRune() error</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write appends the contents of p to b's buffer.
Write always returns len(p), nil.</p>
               
               <pre><code>func (b *Builder) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write writes to the buffer to satisfy [io.Writer].</p>
               
               <pre><code>func (w *appendSliceWriter) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteByte">
               <h3>
                  WriteByte 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteByte appends the byte c to b's buffer.
The returned error is always nil.</p>
               
               <pre><code>func (b *Builder) WriteByte(c byte) error</code></pre>
            </article>
            
            <article class="function" data-name="WriteRune">
               <h3>
                  WriteRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteRune appends the UTF-8 encoding of Unicode code point r to b's buffer.
It returns the length of r and a nil error.</p>
               
               <pre><code>func (b *Builder) WriteRune(r rune) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteString writes to the buffer without string->[]byte->string allocations.</p>
               
               <pre><code>func (w *appendSliceWriter) WriteString(s string) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w stringWriter) WriteString(s string) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *genericReplacer) WriteString(w io.Writer, s string) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteString appends the contents of s to b's buffer.
It returns the length of s and a nil error.</p>
               
               <pre><code>func (b *Builder) WriteString(s string) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *singleStringReplacer) WriteString(w io.Writer, s string) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteString writes s to w with all replacements performed.</p>
               
               <pre><code>func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *byteReplacer) WriteString(w io.Writer, s string) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *byteStringReplacer) WriteString(w io.Writer, s string) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteTo implements the [io.WriterTo] interface.</p>
               
               <pre><code>func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *trieNode) add(key string, val string, priority int, r *genericReplacer)</code></pre>
            </article>
            
            <article class="function" data-name="build">
               <h3>
                  build 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Replacer) build() replacer</code></pre>
            </article>
            
            <article class="function" data-name="buildOnce">
               <h3>
                  buildOnce 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Replacer) buildOnce()</code></pre>
            </article>
            
            <article class="function" data-name="contains">
               <h3>
                  contains 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>contains reports whether c is inside the set.</p>
               
               <pre><code>func (as *asciiSet) contains(c byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="copyCheck">
               <h3>
                  copyCheck 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) copyCheck()</code></pre>
            </article>
            
            <article class="function" data-name="explode">
               <h3>
                  explode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>explode splits s into a slice of UTF-8 strings,
one string per Unicode character up to a maximum of n (n < 0 means no limit).
Invalid UTF-8 bytes are sliced individually.</p>
               
               <pre><code>func explode(s string, n int) []string</code></pre>
            </article>
            
            <article class="function" data-name="explodeSeq">
               <h3>
                  explodeSeq 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>explodeSeq returns an iterator over the runes in s.</p>
               
               <pre><code>func explodeSeq(s string) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function" data-name="genSplit">
               <h3>
                  genSplit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Generic split: splits after each instance of sep,
including sepSave bytes of sep in the subarrays.</p>
               
               <pre><code>func genSplit(s string, sep string, sepSave int, n int) []string</code></pre>
            </article>
            
            <article class="function" data-name="getStringWriter">
               <h3>
                  getStringWriter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func getStringWriter(w io.Writer) io.StringWriter</code></pre>
            </article>
            
            <article class="function" data-name="grow">
               <h3>
                  grow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>grow copies the buffer to a new, larger buffer so that there are at least n
bytes of capacity beyond len(b.buf).</p>
               
               <pre><code>func (b *Builder) grow(n int)</code></pre>
            </article>
            
            <article class="function" data-name="indexFunc">
               <h3>
                  indexFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>indexFunc is the same as IndexFunc except that if
truth==false, the sense of the predicate function is
inverted.</p>
               
               <pre><code>func indexFunc(s string, f func(rune) bool, truth bool) int</code></pre>
            </article>
            
            <article class="function" data-name="isSeparator">
               <h3>
                  isSeparator 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isSeparator reports whether the rune could mark a word boundary.
TODO: update when package unicode captures more of the properties.</p>
               
               <pre><code>func isSeparator(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="lastIndexFunc">
               <h3>
                  lastIndexFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lastIndexFunc is the same as LastIndexFunc except that if
truth==false, the sense of the predicate function is
inverted.</p>
               
               <pre><code>func lastIndexFunc(s string, f func(rune) bool, truth bool) int</code></pre>
            </article>
            
            <article class="function" data-name="longestCommonSuffix">
               <h3>
                  longestCommonSuffix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func longestCommonSuffix(a string, b string) (i int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *genericReplacer) lookup(s string, ignoreRoot bool) (val string, keylen int, found bool)</code></pre>
            </article>
            
            <article class="function" data-name="makeASCIISet">
               <h3>
                  makeASCIISet 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeASCIISet creates a set of ASCII characters and reports whether all
characters in chars are ASCII.</p>
               
               <pre><code>func makeASCIISet(chars string) (as asciiSet, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="makeGenericReplacer">
               <h3>
                  makeGenericReplacer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeGenericReplacer(oldnew []string) *genericReplacer</code></pre>
            </article>
            
            <article class="function" data-name="makeSingleStringReplacer">
               <h3>
                  makeSingleStringReplacer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeSingleStringReplacer(pattern string, value string) *singleStringReplacer</code></pre>
            </article>
            
            <article class="function" data-name="makeStringFinder">
               <h3>
                  makeStringFinder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeStringFinder(pattern string) *stringFinder</code></pre>
            </article>
            
            <article class="function" data-name="next">
               <h3>
                  next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>next returns the index in text of the first occurrence of the pattern. If
the pattern is not found, it returns -1.</p>
               
               <pre><code>func (f *stringFinder) next(text string) int</code></pre>
            </article>
            
            <article class="function" data-name="splitSeq">
               <h3>
                  splitSeq 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>splitSeq is SplitSeq or SplitAfterSeq, configured by how many
bytes of sep to include in the results (none or all).</p>
               
               <pre><code>func splitSeq(s string, sep string, sepSave int) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function" data-name="trimLeftASCII">
               <h3>
                  trimLeftASCII 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func trimLeftASCII(s string, as *asciiSet) string</code></pre>
            </article>
            
            <article class="function" data-name="trimLeftByte">
               <h3>
                  trimLeftByte 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func trimLeftByte(s string, c byte) string</code></pre>
            </article>
            
            <article class="function" data-name="trimLeftUnicode">
               <h3>
                  trimLeftUnicode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func trimLeftUnicode(s string, cutset string) string</code></pre>
            </article>
            
            <article class="function" data-name="trimRightASCII">
               <h3>
                  trimRightASCII 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func trimRightASCII(s string, as *asciiSet) string</code></pre>
            </article>
            
            <article class="function" data-name="trimRightByte">
               <h3>
                  trimRightByte 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func trimRightByte(s string, c byte) string</code></pre>
            </article>
            
            <article class="function" data-name="trimRightUnicode">
               <h3>
                  trimRightUnicode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func trimRightUnicode(s string, cutset string) string</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
