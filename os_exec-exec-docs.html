<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>exec - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>exec</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"errors"
"errors"
"io/fs"
"os"
"path/filepath"
"strings"
"bytes"
"context"
"errors"
"internal/godebug"
"internal/syscall/execenv"
"io"
"os"
"path/filepath"
"runtime"
"strconv"
"strings"
"syscall"
"time"
"io/fs"
"io/fs"
"syscall"
"io/fs"
"syscall"
"errors"
"io/fs"
"os"
"path/filepath"
"strings"
"errors"
"internal/syscall/unix"
"io/fs"
"os"
"path/filepath"
"strings"
"syscall"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ErrDot" data-name="ErrDot">
               <h3>
                  ErrDot 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrDot" class="anchor" title="Link to ErrDot">#</a>
               </h3>
               
                  <p class="doc-comment">ErrDot indicates that a path lookup resolved to an executable
in the current directory due to ‘.’ being in the path, either
implicitly or explicitly. See the package documentation for details.
Note that functions in this package do not return ErrDot directly.
Code should use errors.Is(err, ErrDot), not err == ErrDot,
to test whether a returned error err is due to this condition.</p>
               
               <pre><code class="language-go">var ErrDot = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNotFound" data-name="ErrNotFound">
               <h3>
                  ErrNotFound 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNotFound" class="anchor" title="Link to ErrNotFound">#</a>
               </h3>
               
                  <p class="doc-comment">ErrNotFound is the error resulting if a path search failed to find an executable file.</p>
               
               <pre><code class="language-go">var ErrNotFound = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNotFound" data-name="ErrNotFound">
               <h3>
                  ErrNotFound 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNotFound" class="anchor" title="Link to ErrNotFound">#</a>
               </h3>
               
                  <p class="doc-comment">ErrNotFound is the error resulting if a path search failed to find an executable file.</p>
               
               <pre><code class="language-go">var ErrNotFound = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNotFound" data-name="ErrNotFound">
               <h3>
                  ErrNotFound 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNotFound" class="anchor" title="Link to ErrNotFound">#</a>
               </h3>
               
                  <p class="doc-comment">ErrNotFound is the error resulting if a path search failed to find an executable file.</p>
               
               <pre><code class="language-go">var ErrNotFound = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNotFound" data-name="ErrNotFound">
               <h3>
                  ErrNotFound 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNotFound" class="anchor" title="Link to ErrNotFound">#</a>
               </h3>
               
                  <p class="doc-comment">ErrNotFound is the error resulting if a path search failed to find an executable file.</p>
               
               <pre><code class="language-go">var ErrNotFound = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrWaitDelay" data-name="ErrWaitDelay">
               <h3>
                  ErrWaitDelay 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrWaitDelay" class="anchor" title="Link to ErrWaitDelay">#</a>
               </h3>
               
                  <p class="doc-comment">ErrWaitDelay is returned by [Cmd.Wait] if the process exits with a
successful status code but its output pipes are not closed before the
command's WaitDelay expires.</p>
               
               <pre><code class="language-go">var ErrWaitDelay = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="execerrdot" data-name="execerrdot">
               <h3>
                  execerrdot 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#execerrdot" class="anchor" title="Link to execerrdot">#</a>
               </h3>
               
               <pre><code class="language-go">var execerrdot = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="execwait" data-name="execwait">
               <h3>
                  execwait 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#execwait" class="anchor" title="Link to execwait">#</a>
               </h3>
               
               <pre><code class="language-go">var execwait = *ast.CallExpr</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Cmd" data-name="Cmd">
               <h3>
                  Cmd
                  <span class="badge">struct</span>
                  <a href="#Cmd" class="anchor" title="Link to Cmd">#</a>
               </h3>
               
               <p>Cmd represents an external command being prepared or run.
A Cmd cannot be reused after calling its [Cmd.Run], [Cmd.Output] or [Cmd.CombinedOutput]
methods.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Cmd struct {
Path string
Args []string
Env []string
Dir string
Stdin io.Reader
Stdout io.Writer
Stderr io.Writer
ExtraFiles []*os.File
SysProcAttr *syscall.SysProcAttr
Process *os.Process
ProcessState *os.ProcessState
ctx context.Context
Err error
Cancel func() error
WaitDelay time.Duration
childIOFiles []io.Closer
parentIOPipes []io.Closer
goroutine []func() error
goroutineErr <-chan error
ctxResult <-chan ctxResult
createdByStack []byte
lookPathErr error
cachedLookExtensions struct{...}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error
                  <span class="badge">struct</span>
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <p>Error is returned by [LookPath] when it fails to classify a file as an
executable.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Error struct {
Name string
Err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ExitError" data-name="ExitError">
               <h3>
                  ExitError
                  <span class="badge">struct</span>
                  <a href="#ExitError" class="anchor" title="Link to ExitError">#</a>
               </h3>
               
               <p>An ExitError reports an unsuccessful exit by a command.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ExitError struct {
*os.ProcessState
Stderr []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ctxResult" data-name="ctxResult">
               <h3>
                  ctxResult
                  <span class="badge">struct</span>
                  <a href="#ctxResult" class="anchor" title="Link to ctxResult">#</a>
               </h3>
               
               <p>A ctxResult reports the result of watching the Context associated with a
running command (and sending corresponding signals if needed).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ctxResult struct {
err error
timer *time.Timer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="prefixSuffixSaver" data-name="prefixSuffixSaver">
               <h3>
                  prefixSuffixSaver
                  <span class="badge">struct</span>
                  <a href="#prefixSuffixSaver" class="anchor" title="Link to prefixSuffixSaver">#</a>
               </h3>
               
               <p>prefixSuffixSaver is an io.Writer which retains the first N bytes
and the last N bytes written to it. The Bytes() methods reconstructs
it with a pretty error message.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type prefixSuffixSaver struct {
N int
prefix []byte
suffix []byte
suffixOff int
skipped int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="wrappedError" data-name="wrappedError">
               <h3>
                  wrappedError
                  <span class="badge">struct</span>
                  <a href="#wrappedError" class="anchor" title="Link to wrappedError">#</a>
               </h3>
               
               <p>wrappedError wraps an error without relying on fmt.Errorf.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type wrappedError struct {
prefix string
err error
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Bytes" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bytes" class="anchor" title="Link to Bytes">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *prefixSuffixSaver) Bytes() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CombinedOutput" data-name="CombinedOutput">
               <h3>
                  CombinedOutput 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CombinedOutput" class="anchor" title="Link to CombinedOutput">#</a>
               </h3>
               
               <p>CombinedOutput runs the command and returns its combined standard
output and standard error.</p>
               
               <pre><code class="language-go">func (c *Cmd) CombinedOutput() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Command" data-name="Command">
               <h3>
                  Command 
                  <span class="badge">function</span>
                  
                  <a href="#Command" class="anchor" title="Link to Command">#</a>
               </h3>
               
               <p>Command returns the [Cmd] struct to execute the named program with
the given arguments.
It sets only the Path and Args in the returned structure.
If name contains no path separators, Command uses [LookPath] to
resolve name to a complete path if possible. Otherwise it uses name
directly as Path.
The returned Cmd's Args field is constructed from the command name
followed by the elements of arg, so arg should not include the
command name itself. For example, Command("echo", "hello").
Args[0] is always name, not the possibly resolved Path.
On Windows, processes receive the whole command line as a single string
and do their own parsing. Command combines and quotes Args into a command
line string with an algorithm compatible with applications using
CommandLineToArgvW (which is the most common way). Notable exceptions are
msiexec.exe and cmd.exe (and thus, all batch files), which have a different
unquoting algorithm. In these or other similar cases, you can do the
quoting yourself and provide the full command line in SysProcAttr.CmdLine,
leaving Args empty.</p>
               
               <pre><code class="language-go">func Command(name string, arg ...string) *Cmd</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CommandContext" data-name="CommandContext">
               <h3>
                  CommandContext 
                  <span class="badge">function</span>
                  
                  <a href="#CommandContext" class="anchor" title="Link to CommandContext">#</a>
               </h3>
               
               <p>CommandContext is like [Command] but includes a context.
The provided context is used to interrupt the process
(by calling cmd.Cancel or [os.Process.Kill])
if the context becomes done before the command completes on its own.
CommandContext sets the command's Cancel function to invoke the Kill method
on its Process, and leaves its WaitDelay unset. The caller may change the
cancellation behavior by modifying those fields before starting the command.</p>
               
               <pre><code class="language-go">func CommandContext(ctx context.Context, name string, arg ...string) *Cmd</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Environ" data-name="Environ">
               <h3>
                  Environ 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Environ" class="anchor" title="Link to Environ">#</a>
               </h3>
               
               <p>Environ returns a copy of the environment in which the command would be run
as it is currently configured.</p>
               
               <pre><code class="language-go">func (c *Cmd) Environ() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ExitError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *Error) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (w wrappedError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookPath" data-name="LookPath">
               <h3>
                  LookPath 
                  <span class="badge">function</span>
                  
                  <a href="#LookPath" class="anchor" title="Link to LookPath">#</a>
               </h3>
               
               <p>LookPath searches for an executable named file in the
directories named by the PATH environment variable.
LookPath also uses PATHEXT environment variable to match
a suitable candidate.
If file contains a slash, it is tried directly and the PATH is not consulted.
Otherwise, on success, the result is an absolute path.
In older versions of Go, LookPath could return a path relative to the current directory.
As of Go 1.19, LookPath will instead return that path along with an error satisfying
[errors.Is](err, [ErrDot]). See the package documentation for more details.</p>
               
               <pre><code class="language-go">func LookPath(file string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookPath" data-name="LookPath">
               <h3>
                  LookPath 
                  <span class="badge">function</span>
                  
                  <a href="#LookPath" class="anchor" title="Link to LookPath">#</a>
               </h3>
               
               <p>LookPath searches for an executable named file in the
directories named by the path environment variable.
If file begins with "/", "#", "./", or "../", it is tried
directly and the path is not consulted.
On success, the result is an absolute path.
In older versions of Go, LookPath could return a path relative to the current directory.
As of Go 1.19, LookPath will instead return that path along with an error satisfying
[errors.Is](err, [ErrDot]). See the package documentation for more details.</p>
               
               <pre><code class="language-go">func LookPath(file string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookPath" data-name="LookPath">
               <h3>
                  LookPath 
                  <span class="badge">function</span>
                  
                  <a href="#LookPath" class="anchor" title="Link to LookPath">#</a>
               </h3>
               
               <p>LookPath searches for an executable named file in the
directories named by the PATH environment variable.
If file contains a slash, it is tried directly and the PATH is not consulted.
The result may be an absolute path or a path relative to the current directory.</p>
               
               <pre><code class="language-go">func LookPath(file string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookPath" data-name="LookPath">
               <h3>
                  LookPath 
                  <span class="badge">function</span>
                  
                  <a href="#LookPath" class="anchor" title="Link to LookPath">#</a>
               </h3>
               
               <p>LookPath searches for an executable named file in the
directories named by the PATH environment variable.
If file contains a slash, it is tried directly and the PATH is not consulted.
Otherwise, on success, the result is an absolute path.
In older versions of Go, LookPath could return a path relative to the current directory.
As of Go 1.19, LookPath will instead return that path along with an error satisfying
[errors.Is](err, [ErrDot]). See the package documentation for more details.</p>
               
               <pre><code class="language-go">func LookPath(file string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Output" data-name="Output">
               <h3>
                  Output 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Output" class="anchor" title="Link to Output">#</a>
               </h3>
               
               <p>Output runs the command and returns its standard output.
Any returned error will usually be of type [*ExitError].
If c.Stderr was nil and the returned error is of type
[*ExitError], Output populates the Stderr field of the
returned error.</p>
               
               <pre><code class="language-go">func (c *Cmd) Output() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Run" data-name="Run">
               <h3>
                  Run 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Run" class="anchor" title="Link to Run">#</a>
               </h3>
               
               <p>Run starts the specified command and waits for it to complete.
The returned error is nil if the command runs, has no problems
copying stdin, stdout, and stderr, and exits with a zero exit
status.
If the command starts but does not complete successfully, the error is of
type [*ExitError]. Other error types may be returned for other situations.
If the calling goroutine has locked the operating system thread
with [runtime.LockOSThread] and modified any inheritable OS-level
thread state (for example, Linux or Plan 9 name spaces), the new
process will inherit the caller's thread state.</p>
               
               <pre><code class="language-go">func (c *Cmd) Run() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Start" data-name="Start">
               <h3>
                  Start 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Start" class="anchor" title="Link to Start">#</a>
               </h3>
               
               <p>Start starts the specified command but does not wait for it to complete.
If Start returns successfully, the c.Process field will be set.
After a successful call to Start the [Cmd.Wait] method must be called in
order to release associated system resources.</p>
               
               <pre><code class="language-go">func (c *Cmd) Start() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StderrPipe" data-name="StderrPipe">
               <h3>
                  StderrPipe 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StderrPipe" class="anchor" title="Link to StderrPipe">#</a>
               </h3>
               
               <p>StderrPipe returns a pipe that will be connected to the command's
standard error when the command starts.
[Cmd.Wait] will close the pipe after seeing the command exit, so most callers
need not close the pipe themselves. It is thus incorrect to call Wait
before all reads from the pipe have completed.
For the same reason, it is incorrect to use [Cmd.Run] when using StderrPipe.
See the StdoutPipe example for idiomatic usage.</p>
               
               <pre><code class="language-go">func (c *Cmd) StderrPipe() (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StdinPipe" data-name="StdinPipe">
               <h3>
                  StdinPipe 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StdinPipe" class="anchor" title="Link to StdinPipe">#</a>
               </h3>
               
               <p>StdinPipe returns a pipe that will be connected to the command's
standard input when the command starts.
The pipe will be closed automatically after [Cmd.Wait] sees the command exit.
A caller need only call Close to force the pipe to close sooner.
For example, if the command being run will not exit until standard input
is closed, the caller must close the pipe.</p>
               
               <pre><code class="language-go">func (c *Cmd) StdinPipe() (io.WriteCloser, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StdoutPipe" data-name="StdoutPipe">
               <h3>
                  StdoutPipe 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StdoutPipe" class="anchor" title="Link to StdoutPipe">#</a>
               </h3>
               
               <p>StdoutPipe returns a pipe that will be connected to the command's
standard output when the command starts.
[Cmd.Wait] will close the pipe after seeing the command exit, so most callers
need not close the pipe themselves. It is thus incorrect to call Wait
before all reads from the pipe have completed.
For the same reason, it is incorrect to call [Cmd.Run] when using StdoutPipe.
See the example for idiomatic usage.</p>
               
               <pre><code class="language-go">func (c *Cmd) StdoutPipe() (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns a human-readable description of c.
It is intended only for debugging.
In particular, it is not suitable for use as input to a shell.
The output of String may vary across Go releases.</p>
               
               <pre><code class="language-go">func (c *Cmd) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *Error) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (w wrappedError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Wait" data-name="Wait">
               <h3>
                  Wait 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Wait" class="anchor" title="Link to Wait">#</a>
               </h3>
               
               <p>Wait waits for the command to exit and waits for any copying to
stdin or copying from stdout or stderr to complete.
The command must have been started by [Cmd.Start].
The returned error is nil if the command runs, has no problems
copying stdin, stdout, and stderr, and exits with a zero exit
status.
If the command fails to run or doesn't complete successfully, the
error is of type [*ExitError]. Other error types may be
returned for I/O problems.
If any of c.Stdin, c.Stdout or c.Stderr are not an [*os.File], Wait also waits
for the respective I/O loop copying to or from the process to complete.
Wait releases any resources associated with the [Cmd].</p>
               
               <pre><code class="language-go">func (c *Cmd) Wait() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *prefixSuffixSaver) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addCriticalEnv" data-name="addCriticalEnv">
               <h3>
                  addCriticalEnv 
                  <span class="badge">function</span>
                  
                  <a href="#addCriticalEnv" class="anchor" title="Link to addCriticalEnv">#</a>
               </h3>
               
               <p>addCriticalEnv adds any critical environment variables that are required
(or at least almost always required) on the operating system.
Currently this is only used for Windows.</p>
               
               <pre><code class="language-go">func addCriticalEnv(env []string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="argv" data-name="argv">
               <h3>
                  argv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#argv" class="anchor" title="Link to argv">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *Cmd) argv() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="awaitGoroutines" data-name="awaitGoroutines">
               <h3>
                  awaitGoroutines 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#awaitGoroutines" class="anchor" title="Link to awaitGoroutines">#</a>
               </h3>
               
               <p>awaitGoroutines waits for the results of the goroutines copying data to or
from the command's I/O pipes.
If c.WaitDelay elapses before the goroutines complete, awaitGoroutines
forcibly closes their pipes and returns ErrWaitDelay.
If timer is non-nil, it must send to timer.C at the end of c.WaitDelay.</p>
               
               <pre><code class="language-go">func (c *Cmd) awaitGoroutines(timer *time.Timer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="childStderr" data-name="childStderr">
               <h3>
                  childStderr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#childStderr" class="anchor" title="Link to childStderr">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *Cmd) childStderr(childStdout *os.File) (*os.File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="childStdin" data-name="childStdin">
               <h3>
                  childStdin 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#childStdin" class="anchor" title="Link to childStdin">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *Cmd) childStdin() (*os.File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="childStdout" data-name="childStdout">
               <h3>
                  childStdout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#childStdout" class="anchor" title="Link to childStdout">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *Cmd) childStdout() (*os.File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chkStat" data-name="chkStat">
               <h3>
                  chkStat 
                  <span class="badge">function</span>
                  
                  <a href="#chkStat" class="anchor" title="Link to chkStat">#</a>
               </h3>
               
               <pre><code class="language-go">func chkStat(file string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeDescriptors" data-name="closeDescriptors">
               <h3>
                  closeDescriptors 
                  <span class="badge">function</span>
                  
                  <a href="#closeDescriptors" class="anchor" title="Link to closeDescriptors">#</a>
               </h3>
               
               <pre><code class="language-go">func closeDescriptors(closers []io.Closer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dedupEnv" data-name="dedupEnv">
               <h3>
                  dedupEnv 
                  <span class="badge">function</span>
                  
                  <a href="#dedupEnv" class="anchor" title="Link to dedupEnv">#</a>
               </h3>
               
               <p>dedupEnv returns a copy of env with any duplicates removed, in favor of
later values.
Items not of the normal environment "key=value" form are preserved unchanged.
Except on Plan 9, items containing NUL characters are removed, and
an error is returned along with the remaining values.</p>
               
               <pre><code class="language-go">func dedupEnv(env []string) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dedupEnvCase" data-name="dedupEnvCase">
               <h3>
                  dedupEnvCase 
                  <span class="badge">function</span>
                  
                  <a href="#dedupEnvCase" class="anchor" title="Link to dedupEnvCase">#</a>
               </h3>
               
               <p>dedupEnvCase is dedupEnv with a case option for testing.
If caseInsensitive is true, the case of keys is ignored.
If nulOK is false, items containing NUL characters are allowed.</p>
               
               <pre><code class="language-go">func dedupEnvCase(caseInsensitive bool, nulOK bool, env []string) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="environ" data-name="environ">
               <h3>
                  environ 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#environ" class="anchor" title="Link to environ">#</a>
               </h3>
               
               <p>environ returns a best-effort copy of the environment in which the command
would be run as it is currently configured. If an error occurs in computing
the environment, it is returned alongside the best-effort copy.</p>
               
               <pre><code class="language-go">func (c *Cmd) environ() ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fill" data-name="fill">
               <h3>
                  fill 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fill" class="anchor" title="Link to fill">#</a>
               </h3>
               
               <p>fill appends up to len(p) bytes of p to *dst, such that *dst does not
grow larger than w.N. It returns the un-appended suffix of p.</p>
               
               <pre><code class="language-go">func (w *prefixSuffixSaver) fill(dst *[]byte, p []byte) (pRemain []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findExecutable" data-name="findExecutable">
               <h3>
                  findExecutable 
                  <span class="badge">function</span>
                  
                  <a href="#findExecutable" class="anchor" title="Link to findExecutable">#</a>
               </h3>
               
               <pre><code class="language-go">func findExecutable(file string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findExecutable" data-name="findExecutable">
               <h3>
                  findExecutable 
                  <span class="badge">function</span>
                  
                  <a href="#findExecutable" class="anchor" title="Link to findExecutable">#</a>
               </h3>
               
               <pre><code class="language-go">func findExecutable(file string, exts []string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findExecutable" data-name="findExecutable">
               <h3>
                  findExecutable 
                  <span class="badge">function</span>
                  
                  <a href="#findExecutable" class="anchor" title="Link to findExecutable">#</a>
               </h3>
               
               <pre><code class="language-go">func findExecutable(file string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasExt" data-name="hasExt">
               <h3>
                  hasExt 
                  <span class="badge">function</span>
                  
                  <a href="#hasExt" class="anchor" title="Link to hasExt">#</a>
               </h3>
               
               <pre><code class="language-go">func hasExt(file string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="interfaceEqual" data-name="interfaceEqual">
               <h3>
                  interfaceEqual 
                  <span class="badge">function</span>
                  
                  <a href="#interfaceEqual" class="anchor" title="Link to interfaceEqual">#</a>
               </h3>
               
               <p>interfaceEqual protects against panics from doing equality tests on
two interfaces with non-comparable underlying types.</p>
               
               <pre><code class="language-go">func interfaceEqual(a any, b any) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookExtensions" data-name="lookExtensions">
               <h3>
                  lookExtensions 
                  <span class="badge">function</span>
                  
                  <a href="#lookExtensions" class="anchor" title="Link to lookExtensions">#</a>
               </h3>
               
               <p>lookExtensions finds windows executable by its dir and path.
It uses LookPath to try appropriate extensions.
lookExtensions does not search PATH, instead it converts `prog` into `.\prog`.
If the path already has an extension found in PATHEXT,
lookExtensions returns it directly without searching
for additional extensions. For example,
"C:\foo\example.com" would be returned as-is even if the
program is actually "C:\foo\example.com.exe".</p>
               
               <pre><code class="language-go">func lookExtensions(path string, dir string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookExtensions" data-name="lookExtensions">
               <h3>
                  lookExtensions 
                  <span class="badge">function</span>
                  
                  <a href="#lookExtensions" class="anchor" title="Link to lookExtensions">#</a>
               </h3>
               
               <p>lookExtensions is a no-op on non-Windows platforms, since
they do not restrict executables to specific extensions.</p>
               
               <pre><code class="language-go">func lookExtensions(path string, dir string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookExtensions" data-name="lookExtensions">
               <h3>
                  lookExtensions 
                  <span class="badge">function</span>
                  
                  <a href="#lookExtensions" class="anchor" title="Link to lookExtensions">#</a>
               </h3>
               
               <p>lookExtensions is a no-op on non-Windows platforms, since
they do not restrict executables to specific extensions.</p>
               
               <pre><code class="language-go">func lookExtensions(path string, dir string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookExtensions" data-name="lookExtensions">
               <h3>
                  lookExtensions 
                  <span class="badge">function</span>
                  
                  <a href="#lookExtensions" class="anchor" title="Link to lookExtensions">#</a>
               </h3>
               
               <p>lookExtensions is a no-op on non-Windows platforms, since
they do not restrict executables to specific extensions.</p>
               
               <pre><code class="language-go">func lookExtensions(path string, dir string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookPath" data-name="lookPath">
               <h3>
                  lookPath 
                  <span class="badge">function</span>
                  
                  <a href="#lookPath" class="anchor" title="Link to lookPath">#</a>
               </h3>
               
               <p>lookPath implements LookPath for the given PATHEXT list.</p>
               
               <pre><code class="language-go">func lookPath(file string, exts []string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathExt" data-name="pathExt">
               <h3>
                  pathExt 
                  <span class="badge">function</span>
                  
                  <a href="#pathExt" class="anchor" title="Link to pathExt">#</a>
               </h3>
               
               <pre><code class="language-go">func pathExt() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="skipStdinCopyError" data-name="skipStdinCopyError">
               <h3>
                  skipStdinCopyError 
                  <span class="badge">function</span>
                  
                  <a href="#skipStdinCopyError" class="anchor" title="Link to skipStdinCopyError">#</a>
               </h3>
               
               <p>skipStdinCopyError optionally specifies a function which reports
whether the provided stdin copy error should be ignored.</p>
               
               <pre><code class="language-go">func skipStdinCopyError(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="skipStdinCopyError" data-name="skipStdinCopyError">
               <h3>
                  skipStdinCopyError 
                  <span class="badge">function</span>
                  
                  <a href="#skipStdinCopyError" class="anchor" title="Link to skipStdinCopyError">#</a>
               </h3>
               
               <p>skipStdinCopyError optionally specifies a function which reports
whether the provided stdin copy error should be ignored.</p>
               
               <pre><code class="language-go">func skipStdinCopyError(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="skipStdinCopyError" data-name="skipStdinCopyError">
               <h3>
                  skipStdinCopyError 
                  <span class="badge">function</span>
                  
                  <a href="#skipStdinCopyError" class="anchor" title="Link to skipStdinCopyError">#</a>
               </h3>
               
               <p>skipStdinCopyError optionally specifies a function which reports
whether the provided stdin copy error should be ignored.</p>
               
               <pre><code class="language-go">func skipStdinCopyError(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="watchCtx" data-name="watchCtx">
               <h3>
                  watchCtx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#watchCtx" class="anchor" title="Link to watchCtx">#</a>
               </h3>
               
               <p>watchCtx watches c.ctx until it is able to send a result to resultc.
If c.ctx is done before a result can be sent, watchCtx calls c.Cancel,
and/or kills cmd.Process it after c.WaitDelay has elapsed.
watchCtx manipulates c.goroutineErr, so its result must be received before
c.awaitGoroutines is called.</p>
               
               <pre><code class="language-go">func (c *Cmd) watchCtx(resultc chan<- ctxResult)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writerDescriptor" data-name="writerDescriptor">
               <h3>
                  writerDescriptor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writerDescriptor" class="anchor" title="Link to writerDescriptor">#</a>
               </h3>
               
               <p>writerDescriptor returns an os.File to which the child process
can write to send data to w.
If w is nil, writerDescriptor returns a File that writes to os.DevNull.</p>
               
               <pre><code class="language-go">func (c *Cmd) writerDescriptor(w io.Writer) (*os.File, error)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>