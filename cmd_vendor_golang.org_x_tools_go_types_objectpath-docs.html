<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - objectpath</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>objectpath</code>
         </h1>
         <hr />
         
         <article class="global" data-name="opType">
            <h2>opType</h2>
            <hr />
            
            <p>object->type operators</p>
            
            <pre><code>opType</code></pre>
         </article>
         
         <article class="global" data-name="opElem">
            <h2>opElem</h2>
            <hr />
            
            <p>type->type operators</p>
            
            <pre><code>opElem</code></pre>
         </article>
         
         <article class="global" data-name="opKey">
            <h2>opKey</h2>
            <hr />
            
            <p>Encoding

An object path is a textual and (with training) human-readable encoding
of a sequence of destructuring operators, starting from a types.Package.
The sequences represent a path through the package/object/type graph.
We classify these operators by their type:

	PO package->object	Package.Scope.Lookup
	OT  object->type 	Object.Type
	TT    type->type 	Type.{Elem,Key,{,{,Recv}Type}Params,Results,Underlying,Rhs} [EKPRUTrCa]
	TO   type->object	Type.{At,Field,Method,Obj} [AFMO]

All valid paths start with a package and end at an object
and thus may be defined by the regular language:

	objectpath = PO (OT TT* TO)*

The concrete encoding follows directly:
  - The only PO operator is Package.Scope.Lookup, which requires an identifier.
  - The only OT operator is Object.Type,
    which we encode as '.' because dot cannot appear in an identifier.
  - The TT operators are encoded as [EKPRUTrCa];
    two of these ({,Recv}TypeParams) require an integer operand,
    which is encoded as a string of decimal digits.
  - The TO operators are encoded as [AFMO];
    three of these (At,Field,Method) require an integer operand,
    which is encoded as a string of decimal digits.
    These indices are stable across different representations
    of the same package, even source and export data.
    The indices used are implementation specific and may not correspond to
    the argument to the go/types function.

In the example below,

	package p

	type T interface {
		f() (a string, b struct{ X int })
	}

field X has the path "T.UM0.RA1.F0",
representing the following sequence of operations:

	p.Lookup("T")					T
	.Type().Underlying().Method(0).			f
	.Type().Results().At(1)				b
	.Type().Field(0)					X

The encoding is not maximally compact---every R or P is
followed by an A, for example---but this simplifies the
encoder and decoder.</p>
            
            <pre><code>opKey</code></pre>
         </article>
         
         <article class="global" data-name="opParams">
            <h2>opParams</h2>
            <hr />
            
            <p>Encoding

An object path is a textual and (with training) human-readable encoding
of a sequence of destructuring operators, starting from a types.Package.
The sequences represent a path through the package/object/type graph.
We classify these operators by their type:

	PO package->object	Package.Scope.Lookup
	OT  object->type 	Object.Type
	TT    type->type 	Type.{Elem,Key,{,{,Recv}Type}Params,Results,Underlying,Rhs} [EKPRUTrCa]
	TO   type->object	Type.{At,Field,Method,Obj} [AFMO]

All valid paths start with a package and end at an object
and thus may be defined by the regular language:

	objectpath = PO (OT TT* TO)*

The concrete encoding follows directly:
  - The only PO operator is Package.Scope.Lookup, which requires an identifier.
  - The only OT operator is Object.Type,
    which we encode as '.' because dot cannot appear in an identifier.
  - The TT operators are encoded as [EKPRUTrCa];
    two of these ({,Recv}TypeParams) require an integer operand,
    which is encoded as a string of decimal digits.
  - The TO operators are encoded as [AFMO];
    three of these (At,Field,Method) require an integer operand,
    which is encoded as a string of decimal digits.
    These indices are stable across different representations
    of the same package, even source and export data.
    The indices used are implementation specific and may not correspond to
    the argument to the go/types function.

In the example below,

	package p

	type T interface {
		f() (a string, b struct{ X int })
	}

field X has the path "T.UM0.RA1.F0",
representing the following sequence of operations:

	p.Lookup("T")					T
	.Type().Underlying().Method(0).			f
	.Type().Results().At(1)				b
	.Type().Field(0)					X

The encoding is not maximally compact---every R or P is
followed by an A, for example---but this simplifies the
encoder and decoder.</p>
            
            <pre><code>opParams</code></pre>
         </article>
         
         <article class="global" data-name="opResults">
            <h2>opResults</h2>
            <hr />
            
            <p>Encoding

An object path is a textual and (with training) human-readable encoding
of a sequence of destructuring operators, starting from a types.Package.
The sequences represent a path through the package/object/type graph.
We classify these operators by their type:

	PO package->object	Package.Scope.Lookup
	OT  object->type 	Object.Type
	TT    type->type 	Type.{Elem,Key,{,{,Recv}Type}Params,Results,Underlying,Rhs} [EKPRUTrCa]
	TO   type->object	Type.{At,Field,Method,Obj} [AFMO]

All valid paths start with a package and end at an object
and thus may be defined by the regular language:

	objectpath = PO (OT TT* TO)*

The concrete encoding follows directly:
  - The only PO operator is Package.Scope.Lookup, which requires an identifier.
  - The only OT operator is Object.Type,
    which we encode as '.' because dot cannot appear in an identifier.
  - The TT operators are encoded as [EKPRUTrCa];
    two of these ({,Recv}TypeParams) require an integer operand,
    which is encoded as a string of decimal digits.
  - The TO operators are encoded as [AFMO];
    three of these (At,Field,Method) require an integer operand,
    which is encoded as a string of decimal digits.
    These indices are stable across different representations
    of the same package, even source and export data.
    The indices used are implementation specific and may not correspond to
    the argument to the go/types function.

In the example below,

	package p

	type T interface {
		f() (a string, b struct{ X int })
	}

field X has the path "T.UM0.RA1.F0",
representing the following sequence of operations:

	p.Lookup("T")					T
	.Type().Underlying().Method(0).			f
	.Type().Results().At(1)				b
	.Type().Field(0)					X

The encoding is not maximally compact---every R or P is
followed by an A, for example---but this simplifies the
encoder and decoder.</p>
            
            <pre><code>opResults</code></pre>
         </article>
         
         <article class="global" data-name="opUnderlying">
            <h2>opUnderlying</h2>
            <hr />
            
            <p>Encoding

An object path is a textual and (with training) human-readable encoding
of a sequence of destructuring operators, starting from a types.Package.
The sequences represent a path through the package/object/type graph.
We classify these operators by their type:

	PO package->object	Package.Scope.Lookup
	OT  object->type 	Object.Type
	TT    type->type 	Type.{Elem,Key,{,{,Recv}Type}Params,Results,Underlying,Rhs} [EKPRUTrCa]
	TO   type->object	Type.{At,Field,Method,Obj} [AFMO]

All valid paths start with a package and end at an object
and thus may be defined by the regular language:

	objectpath = PO (OT TT* TO)*

The concrete encoding follows directly:
  - The only PO operator is Package.Scope.Lookup, which requires an identifier.
  - The only OT operator is Object.Type,
    which we encode as '.' because dot cannot appear in an identifier.
  - The TT operators are encoded as [EKPRUTrCa];
    two of these ({,Recv}TypeParams) require an integer operand,
    which is encoded as a string of decimal digits.
  - The TO operators are encoded as [AFMO];
    three of these (At,Field,Method) require an integer operand,
    which is encoded as a string of decimal digits.
    These indices are stable across different representations
    of the same package, even source and export data.
    The indices used are implementation specific and may not correspond to
    the argument to the go/types function.

In the example below,

	package p

	type T interface {
		f() (a string, b struct{ X int })
	}

field X has the path "T.UM0.RA1.F0",
representing the following sequence of operations:

	p.Lookup("T")					T
	.Type().Underlying().Method(0).			f
	.Type().Results().At(1)				b
	.Type().Field(0)					X

The encoding is not maximally compact---every R or P is
followed by an A, for example---but this simplifies the
encoder and decoder.</p>
            
            <pre><code>opUnderlying</code></pre>
         </article>
         
         <article class="global" data-name="opTypeParam">
            <h2>opTypeParam</h2>
            <hr />
            
            <p>Encoding

An object path is a textual and (with training) human-readable encoding
of a sequence of destructuring operators, starting from a types.Package.
The sequences represent a path through the package/object/type graph.
We classify these operators by their type:

	PO package->object	Package.Scope.Lookup
	OT  object->type 	Object.Type
	TT    type->type 	Type.{Elem,Key,{,{,Recv}Type}Params,Results,Underlying,Rhs} [EKPRUTrCa]
	TO   type->object	Type.{At,Field,Method,Obj} [AFMO]

All valid paths start with a package and end at an object
and thus may be defined by the regular language:

	objectpath = PO (OT TT* TO)*

The concrete encoding follows directly:
  - The only PO operator is Package.Scope.Lookup, which requires an identifier.
  - The only OT operator is Object.Type,
    which we encode as '.' because dot cannot appear in an identifier.
  - The TT operators are encoded as [EKPRUTrCa];
    two of these ({,Recv}TypeParams) require an integer operand,
    which is encoded as a string of decimal digits.
  - The TO operators are encoded as [AFMO];
    three of these (At,Field,Method) require an integer operand,
    which is encoded as a string of decimal digits.
    These indices are stable across different representations
    of the same package, even source and export data.
    The indices used are implementation specific and may not correspond to
    the argument to the go/types function.

In the example below,

	package p

	type T interface {
		f() (a string, b struct{ X int })
	}

field X has the path "T.UM0.RA1.F0",
representing the following sequence of operations:

	p.Lookup("T")					T
	.Type().Underlying().Method(0).			f
	.Type().Results().At(1)				b
	.Type().Field(0)					X

The encoding is not maximally compact---every R or P is
followed by an A, for example---but this simplifies the
encoder and decoder.</p>
            
            <pre><code>opTypeParam</code></pre>
         </article>
         
         <article class="global" data-name="opRecvTypeParam">
            <h2>opRecvTypeParam</h2>
            <hr />
            
            <p>Encoding

An object path is a textual and (with training) human-readable encoding
of a sequence of destructuring operators, starting from a types.Package.
The sequences represent a path through the package/object/type graph.
We classify these operators by their type:

	PO package->object	Package.Scope.Lookup
	OT  object->type 	Object.Type
	TT    type->type 	Type.{Elem,Key,{,{,Recv}Type}Params,Results,Underlying,Rhs} [EKPRUTrCa]
	TO   type->object	Type.{At,Field,Method,Obj} [AFMO]

All valid paths start with a package and end at an object
and thus may be defined by the regular language:

	objectpath = PO (OT TT* TO)*

The concrete encoding follows directly:
  - The only PO operator is Package.Scope.Lookup, which requires an identifier.
  - The only OT operator is Object.Type,
    which we encode as '.' because dot cannot appear in an identifier.
  - The TT operators are encoded as [EKPRUTrCa];
    two of these ({,Recv}TypeParams) require an integer operand,
    which is encoded as a string of decimal digits.
  - The TO operators are encoded as [AFMO];
    three of these (At,Field,Method) require an integer operand,
    which is encoded as a string of decimal digits.
    These indices are stable across different representations
    of the same package, even source and export data.
    The indices used are implementation specific and may not correspond to
    the argument to the go/types function.

In the example below,

	package p

	type T interface {
		f() (a string, b struct{ X int })
	}

field X has the path "T.UM0.RA1.F0",
representing the following sequence of operations:

	p.Lookup("T")					T
	.Type().Underlying().Method(0).			f
	.Type().Results().At(1)				b
	.Type().Field(0)					X

The encoding is not maximally compact---every R or P is
followed by an A, for example---but this simplifies the
encoder and decoder.</p>
            
            <pre><code>opRecvTypeParam</code></pre>
         </article>
         
         <article class="global" data-name="opConstraint">
            <h2>opConstraint</h2>
            <hr />
            
            <p>Encoding

An object path is a textual and (with training) human-readable encoding
of a sequence of destructuring operators, starting from a types.Package.
The sequences represent a path through the package/object/type graph.
We classify these operators by their type:

	PO package->object	Package.Scope.Lookup
	OT  object->type 	Object.Type
	TT    type->type 	Type.{Elem,Key,{,{,Recv}Type}Params,Results,Underlying,Rhs} [EKPRUTrCa]
	TO   type->object	Type.{At,Field,Method,Obj} [AFMO]

All valid paths start with a package and end at an object
and thus may be defined by the regular language:

	objectpath = PO (OT TT* TO)*

The concrete encoding follows directly:
  - The only PO operator is Package.Scope.Lookup, which requires an identifier.
  - The only OT operator is Object.Type,
    which we encode as '.' because dot cannot appear in an identifier.
  - The TT operators are encoded as [EKPRUTrCa];
    two of these ({,Recv}TypeParams) require an integer operand,
    which is encoded as a string of decimal digits.
  - The TO operators are encoded as [AFMO];
    three of these (At,Field,Method) require an integer operand,
    which is encoded as a string of decimal digits.
    These indices are stable across different representations
    of the same package, even source and export data.
    The indices used are implementation specific and may not correspond to
    the argument to the go/types function.

In the example below,

	package p

	type T interface {
		f() (a string, b struct{ X int })
	}

field X has the path "T.UM0.RA1.F0",
representing the following sequence of operations:

	p.Lookup("T")					T
	.Type().Underlying().Method(0).			f
	.Type().Results().At(1)				b
	.Type().Field(0)					X

The encoding is not maximally compact---every R or P is
followed by an A, for example---but this simplifies the
encoder and decoder.</p>
            
            <pre><code>opConstraint</code></pre>
         </article>
         
         <article class="global" data-name="opRhs">
            <h2>opRhs</h2>
            <hr />
            
            <p>Encoding

An object path is a textual and (with training) human-readable encoding
of a sequence of destructuring operators, starting from a types.Package.
The sequences represent a path through the package/object/type graph.
We classify these operators by their type:

	PO package->object	Package.Scope.Lookup
	OT  object->type 	Object.Type
	TT    type->type 	Type.{Elem,Key,{,{,Recv}Type}Params,Results,Underlying,Rhs} [EKPRUTrCa]
	TO   type->object	Type.{At,Field,Method,Obj} [AFMO]

All valid paths start with a package and end at an object
and thus may be defined by the regular language:

	objectpath = PO (OT TT* TO)*

The concrete encoding follows directly:
  - The only PO operator is Package.Scope.Lookup, which requires an identifier.
  - The only OT operator is Object.Type,
    which we encode as '.' because dot cannot appear in an identifier.
  - The TT operators are encoded as [EKPRUTrCa];
    two of these ({,Recv}TypeParams) require an integer operand,
    which is encoded as a string of decimal digits.
  - The TO operators are encoded as [AFMO];
    three of these (At,Field,Method) require an integer operand,
    which is encoded as a string of decimal digits.
    These indices are stable across different representations
    of the same package, even source and export data.
    The indices used are implementation specific and may not correspond to
    the argument to the go/types function.

In the example below,

	package p

	type T interface {
		f() (a string, b struct{ X int })
	}

field X has the path "T.UM0.RA1.F0",
representing the following sequence of operations:

	p.Lookup("T")					T
	.Type().Underlying().Method(0).			f
	.Type().Results().At(1)				b
	.Type().Field(0)					X

The encoding is not maximally compact---every R or P is
followed by an A, for example---but this simplifies the
encoder and decoder.</p>
            
            <pre><code>opRhs</code></pre>
         </article>
         
         <article class="global" data-name="opAt">
            <h2>opAt</h2>
            <hr />
            
            <p>type->object operators</p>
            
            <pre><code>opAt</code></pre>
         </article>
         
         <article class="global" data-name="opField">
            <h2>opField</h2>
            <hr />
            
            <p>Encoding

An object path is a textual and (with training) human-readable encoding
of a sequence of destructuring operators, starting from a types.Package.
The sequences represent a path through the package/object/type graph.
We classify these operators by their type:

	PO package->object	Package.Scope.Lookup
	OT  object->type 	Object.Type
	TT    type->type 	Type.{Elem,Key,{,{,Recv}Type}Params,Results,Underlying,Rhs} [EKPRUTrCa]
	TO   type->object	Type.{At,Field,Method,Obj} [AFMO]

All valid paths start with a package and end at an object
and thus may be defined by the regular language:

	objectpath = PO (OT TT* TO)*

The concrete encoding follows directly:
  - The only PO operator is Package.Scope.Lookup, which requires an identifier.
  - The only OT operator is Object.Type,
    which we encode as '.' because dot cannot appear in an identifier.
  - The TT operators are encoded as [EKPRUTrCa];
    two of these ({,Recv}TypeParams) require an integer operand,
    which is encoded as a string of decimal digits.
  - The TO operators are encoded as [AFMO];
    three of these (At,Field,Method) require an integer operand,
    which is encoded as a string of decimal digits.
    These indices are stable across different representations
    of the same package, even source and export data.
    The indices used are implementation specific and may not correspond to
    the argument to the go/types function.

In the example below,

	package p

	type T interface {
		f() (a string, b struct{ X int })
	}

field X has the path "T.UM0.RA1.F0",
representing the following sequence of operations:

	p.Lookup("T")					T
	.Type().Underlying().Method(0).			f
	.Type().Results().At(1)				b
	.Type().Field(0)					X

The encoding is not maximally compact---every R or P is
followed by an A, for example---but this simplifies the
encoder and decoder.</p>
            
            <pre><code>opField</code></pre>
         </article>
         
         <article class="global" data-name="opMethod">
            <h2>opMethod</h2>
            <hr />
            
            <p>Encoding

An object path is a textual and (with training) human-readable encoding
of a sequence of destructuring operators, starting from a types.Package.
The sequences represent a path through the package/object/type graph.
We classify these operators by their type:

	PO package->object	Package.Scope.Lookup
	OT  object->type 	Object.Type
	TT    type->type 	Type.{Elem,Key,{,{,Recv}Type}Params,Results,Underlying,Rhs} [EKPRUTrCa]
	TO   type->object	Type.{At,Field,Method,Obj} [AFMO]

All valid paths start with a package and end at an object
and thus may be defined by the regular language:

	objectpath = PO (OT TT* TO)*

The concrete encoding follows directly:
  - The only PO operator is Package.Scope.Lookup, which requires an identifier.
  - The only OT operator is Object.Type,
    which we encode as '.' because dot cannot appear in an identifier.
  - The TT operators are encoded as [EKPRUTrCa];
    two of these ({,Recv}TypeParams) require an integer operand,
    which is encoded as a string of decimal digits.
  - The TO operators are encoded as [AFMO];
    three of these (At,Field,Method) require an integer operand,
    which is encoded as a string of decimal digits.
    These indices are stable across different representations
    of the same package, even source and export data.
    The indices used are implementation specific and may not correspond to
    the argument to the go/types function.

In the example below,

	package p

	type T interface {
		f() (a string, b struct{ X int })
	}

field X has the path "T.UM0.RA1.F0",
representing the following sequence of operations:

	p.Lookup("T")					T
	.Type().Underlying().Method(0).			f
	.Type().Results().At(1)				b
	.Type().Field(0)					X

The encoding is not maximally compact---every R or P is
followed by an A, for example---but this simplifies the
encoder and decoder.</p>
            
            <pre><code>opMethod</code></pre>
         </article>
         
         <article class="global" data-name="opObj">
            <h2>opObj</h2>
            <hr />
            
            <p>Encoding

An object path is a textual and (with training) human-readable encoding
of a sequence of destructuring operators, starting from a types.Package.
The sequences represent a path through the package/object/type graph.
We classify these operators by their type:

	PO package->object	Package.Scope.Lookup
	OT  object->type 	Object.Type
	TT    type->type 	Type.{Elem,Key,{,{,Recv}Type}Params,Results,Underlying,Rhs} [EKPRUTrCa]
	TO   type->object	Type.{At,Field,Method,Obj} [AFMO]

All valid paths start with a package and end at an object
and thus may be defined by the regular language:

	objectpath = PO (OT TT* TO)*

The concrete encoding follows directly:
  - The only PO operator is Package.Scope.Lookup, which requires an identifier.
  - The only OT operator is Object.Type,
    which we encode as '.' because dot cannot appear in an identifier.
  - The TT operators are encoded as [EKPRUTrCa];
    two of these ({,Recv}TypeParams) require an integer operand,
    which is encoded as a string of decimal digits.
  - The TO operators are encoded as [AFMO];
    three of these (At,Field,Method) require an integer operand,
    which is encoded as a string of decimal digits.
    These indices are stable across different representations
    of the same package, even source and export data.
    The indices used are implementation specific and may not correspond to
    the argument to the go/types function.

In the example below,

	package p

	type T interface {
		f() (a string, b struct{ X int })
	}

field X has the path "T.UM0.RA1.F0",
representing the following sequence of operations:

	p.Lookup("T")					T
	.Type().Underlying().Method(0).			f
	.Type().Results().At(1)				b
	.Type().Field(0)					X

The encoding is not maximally compact---every R or P is
followed by an A, for example---but this simplifies the
encoder and decoder.</p>
            
            <pre><code>opObj</code></pre>
         </article>
          
         <article class="struct" data-name="Encoder">
            <h2>type Encoder struct</h2>
            <hr />
            
            <p>An Encoder amortizes the cost of encoding the paths of multiple objects.
The zero value of an Encoder is ready to use.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">scopeMemo *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="finder">
            <h2>type finder struct</h2>
            <hr />
            
            <p>finder closes over search state for a call to find.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">obj types.Object
seenTParamNames *ast.MapType
seenMethods *ast.MapType</code></pre>
         </article>
          
         <article class="function" data-name="For">
            <h2>For</h2>
            <hr />
            
            <p>For is equivalent to new(Encoder).For(obj).

It may be more efficient to reuse a single Encoder across several calls.</p>
            
            <pre><code>func For(obj types.Object) (Path, error)</code></pre>
         </article>
         
         <article class="function" data-name="For">
            <h2>For</h2>
            <hr />
            
            <p>For returns the path to an object relative to its package,
or an error if the object is not accessible from the package's Scope.

The For function guarantees to return a path only for the following objects:
- package-level types
- exported package-level non-types
- methods
- parameter and result variables
- struct fields
These objects are sufficient to define the API of their package.
The objects described by a package's export data are drawn from this set.

The set of objects accessible from a package's Scope depends on
whether the package was produced by type-checking syntax, or
reading export data; the latter may have a smaller Scope since
export data trims objects that are not reachable from an exported
declaration. For example, the For function will return a path for
an exported method of an unexported type that is not reachable
from any public declaration; this path will cause the Object
function to fail if called on a package loaded from export data.
TODO(adonovan): is this a bug or feature? Should this package
compute accessibility in the same way?

For does not return a path for predeclared names, imported package
names, local names, and unexported package-level names (except
types).

Example: given this definition,

	package p

	type T interface {
		f() (a string, b struct{ X int })
	}

For(X) would return a path that denotes the following sequence of operations:

	p.Scope().Lookup("T")				(TypeName T)
	.Type().Underlying().Method(0).			(method Func f)
	.Type().Results().At(1)				(field Var b)
	.Type().Field(0)					(field Var X)

where p is the package (*types.Package) to which X belongs.</p>
            
            <pre><code>func For(obj types.Object) (Path, error)</code></pre>
         </article>
         
         <article class="function" data-name="appendOpArg">
            <h2>appendOpArg</h2>
            <hr />
            
            <pre><code>func appendOpArg(path []byte, op byte, arg int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="concreteMethod">
            <h2>concreteMethod</h2>
            <hr />
            
            <p>concreteMethod returns the path for meth, which must have a non-nil receiver.
The second return value indicates success and may be false if the method is
an interface method or if it is an instantiated method.

This function is just an optimization that avoids the general scope walking
approach. You are expected to fall back to the general approach if this
function fails.</p>
            
            <pre><code>func concreteMethod(meth *types.Func) (Path, bool)</code></pre>
         </article>
         
         <article class="function" data-name="find">
            <h2>find</h2>
            <hr />
            
            <p>find finds obj within type T, returning the path to it, or nil if not found.

The seen map is used to short circuit cycles through type parameters. If
nil, it will be allocated as necessary.

The seenMethods map is used internally to short circuit cycles through
interface methods, such as occur in the following example:

	type I interface { f() interface{I} }

See golang/go#68046 for details.</p>
            
            <pre><code>func find(obj types.Object, T types.Type, path []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="find">
            <h2>find</h2>
            <hr />
            
            <pre><code>func find(T types.Type, path []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="findTypeParam">
            <h2>findTypeParam</h2>
            <hr />
            
            <pre><code>func findTypeParam(obj types.Object, list *types.TypeParamList, path []byte, op byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="findTypeParam">
            <h2>findTypeParam</h2>
            <hr />
            
            <pre><code>func findTypeParam(list *types.TypeParamList, path []byte, op byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Object">
            <h2>Object</h2>
            <hr />
            
            <p>Object returns the object denoted by path p within the package pkg.</p>
            
            <pre><code>func Object(pkg *types.Package, p Path) (types.Object, error)</code></pre>
         </article>
         
         <article class="function" data-name="scopeObjects">
            <h2>scopeObjects</h2>
            <hr />
            
            <p>scopeObjects is a memoization of scope objects.
Callers must not modify the result.</p>
            
            <pre><code>func scopeObjects(scope *types.Scope) []types.Object</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
