<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>rpc - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="net_rpc_jsonrpc-docs.html">jsonrpc</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>rpc</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"bufio"
"encoding/gob"
"errors"
"io"
"log"
"net"
"net/http"
"sync"
"fmt"
"html/template"
"net/http"
"slices"
"strings"
"bufio"
"encoding/gob"
"errors"
"go/token"
"io"
"log"
"net"
"net/http"
"reflect"
"strings"
"sync"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="DefaultDebugPath" data-name="DefaultDebugPath">
               <h3>
                  DefaultDebugPath 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DefaultDebugPath" class="anchor" title="Link to DefaultDebugPath">#</a>
               </h3>
               
               <pre><code class="language-go">const DefaultDebugPath = "/debug/rpc"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DefaultRPCPath" data-name="DefaultRPCPath">
               <h3>
                  DefaultRPCPath 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DefaultRPCPath" class="anchor" title="Link to DefaultRPCPath">#</a>
               </h3>
               
                  <p class="doc-comment">Defaults used by HandleHTTP</p>
               
               <pre><code class="language-go">const DefaultRPCPath = "/_goRPC_"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DefaultServer" data-name="DefaultServer">
               <h3>
                  DefaultServer 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#DefaultServer" class="anchor" title="Link to DefaultServer">#</a>
               </h3>
               
                  <p class="doc-comment">DefaultServer is the default instance of [*Server].</p>
               
               <pre><code class="language-go">var DefaultServer = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrShutdown" data-name="ErrShutdown">
               <h3>
                  ErrShutdown 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrShutdown" class="anchor" title="Link to ErrShutdown">#</a>
               </h3>
               
               <pre><code class="language-go">var ErrShutdown = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="connected" data-name="connected">
               <h3>
                  connected 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#connected" class="anchor" title="Link to connected">#</a>
               </h3>
               
                  <p class="doc-comment">Can connect to RPC service using HTTP CONNECT to rpcPath.</p>
               
               <pre><code class="language-go">var connected = "200 Connected to Go RPC"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debug" data-name="debug">
               <h3>
                  debug 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#debug" class="anchor" title="Link to debug">#</a>
               </h3>
               
               <pre><code class="language-go">var debug = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugLog" data-name="debugLog">
               <h3>
                  debugLog 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#debugLog" class="anchor" title="Link to debugLog">#</a>
               </h3>
               
                  <p class="doc-comment">If set, print log statements for internal and I/O errors.</p>
               
               <pre><code class="language-go">var debugLog = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugText" data-name="debugText">
               <h3>
                  debugText 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debugText" class="anchor" title="Link to debugText">#</a>
               </h3>
               
               <pre><code class="language-go">const debugText = `<html>
	<body>
	<title>Services</title>
	{{range .}}
	<hr>
	Service {{.Name}}
	<hr>
		<table>
		<th align=center>Method</th><th align=center>Calls</th>
		{{range .Method}}
			<tr>
			<td align=left font=fixed>{{.Name}}({{.Type.ArgType}}, {{.Type.ReplyType}}) error</td>
			<td align=center>{{.Type.NumCalls}}</td>
			</tr>
		{{end}}
		</table>
	{{end}}
	</body>
	</html>`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="invalidRequest" data-name="invalidRequest">
               <h3>
                  invalidRequest 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#invalidRequest" class="anchor" title="Link to invalidRequest">#</a>
               </h3>
               
                  <p class="doc-comment">A value sent as a placeholder for the server's response value when the server
receives an invalid request. It is never decoded by the client since the Response
contains an error when it is used.</p>
               
               <pre><code class="language-go">var invalidRequest = struct{...}{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="logRegisterError" data-name="logRegisterError">
               <h3>
                  logRegisterError 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#logRegisterError" class="anchor" title="Link to logRegisterError">#</a>
               </h3>
               
                  <p class="doc-comment">logRegisterError specifies whether to log problems during method registration.
To debug registration, recompile the package with this set to true.</p>
               
               <pre><code class="language-go">const logRegisterError = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="typeOfError" data-name="typeOfError">
               <h3>
                  typeOfError 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#typeOfError" class="anchor" title="Link to typeOfError">#</a>
               </h3>
               
                  <p class="doc-comment">Precompute the reflect type for error.</p>
               
               <pre><code class="language-go">var typeOfError = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="ServerError" data-name="ServerError">
               <h3>
                  ServerError
                  <span class="badge type-badge">type</span>
                  <a href="#ServerError" class="anchor" title="Link to ServerError">#</a>
               </h3>
               
               <p>ServerError represents an error that has been returned from
the remote side of the RPC connection.</p>
               
               <pre><code class="language-go">type ServerError string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="methodArray" data-name="methodArray">
               <h3>
                  methodArray
                  <span class="badge type-badge">type</span>
                  <a href="#methodArray" class="anchor" title="Link to methodArray">#</a>
               </h3>
               
               <pre><code class="language-go">type methodArray []debugMethod</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="serviceArray" data-name="serviceArray">
               <h3>
                  serviceArray
                  <span class="badge type-badge">type</span>
                  <a href="#serviceArray" class="anchor" title="Link to serviceArray">#</a>
               </h3>
               
               <pre><code class="language-go">type serviceArray []debugService</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="ClientCodec" data-name="ClientCodec">
               <h3>
                  ClientCodec
                  <span class="badge interface-badge">interface</span>
                  <a href="#ClientCodec" class="anchor" title="Link to ClientCodec">#</a>
               </h3>
               
               <p>A ClientCodec implements writing of RPC requests and
reading of RPC responses for the client side of an RPC session.
The client calls [ClientCodec.WriteRequest] to write a request to the connection
and calls [ClientCodec.ReadResponseHeader] and [ClientCodec.ReadResponseBody] in pairs
to read responses. The client calls [ClientCodec.Close] when finished with the
connection. ReadResponseBody may be called with a nil
argument to force the body of the response to be read and then
discarded.
See [NewClient]'s comment for information about concurrent access.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type ClientCodec interface {
WriteRequest(*Request, any) error
ReadResponseHeader(*Response) error
ReadResponseBody(any) error
Close() error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="ServerCodec" data-name="ServerCodec">
               <h3>
                  ServerCodec
                  <span class="badge interface-badge">interface</span>
                  <a href="#ServerCodec" class="anchor" title="Link to ServerCodec">#</a>
               </h3>
               
               <p>A ServerCodec implements reading of RPC requests and writing of
RPC responses for the server side of an RPC session.
The server calls [ServerCodec.ReadRequestHeader] and [ServerCodec.ReadRequestBody] in pairs
to read requests from the connection, and it calls [ServerCodec.WriteResponse] to
write a response back. The server calls [ServerCodec.Close] when finished with the
connection. ReadRequestBody may be called with a nil
argument to force the body of the request to be read and discarded.
See [NewClient]'s comment for information about concurrent access.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type ServerCodec interface {
ReadRequestHeader(*Request) error
ReadRequestBody(any) error
WriteResponse(*Response, any) error
Close() error
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Call" data-name="Call">
               <h3>
                  Call
                  <span class="badge">struct</span>
                  <a href="#Call" class="anchor" title="Link to Call">#</a>
               </h3>
               
               <p>Call represents an active RPC.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Call struct {
ServiceMethod string
Args any
Reply any
Error error
Done chan *Call
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Client" data-name="Client">
               <h3>
                  Client
                  <span class="badge">struct</span>
                  <a href="#Client" class="anchor" title="Link to Client">#</a>
               </h3>
               
               <p>Client represents an RPC Client.
There may be multiple outstanding Calls associated
with a single Client, and a Client may be used by
multiple goroutines simultaneously.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Client struct {
codec ClientCodec
reqMutex sync.Mutex
request Request
mutex sync.Mutex
seq uint64
pending map[uint64]*Call
closing bool
shutdown bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Request" data-name="Request">
               <h3>
                  Request
                  <span class="badge">struct</span>
                  <a href="#Request" class="anchor" title="Link to Request">#</a>
               </h3>
               
               <p>Request is a header written before every RPC call. It is used internally
but documented here as an aid to debugging, such as when analyzing
network traffic.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Request struct {
ServiceMethod string
Seq uint64
next *Request
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Response" data-name="Response">
               <h3>
                  Response
                  <span class="badge">struct</span>
                  <a href="#Response" class="anchor" title="Link to Response">#</a>
               </h3>
               
               <p>Response is a header written before every RPC return. It is used internally
but documented here as an aid to debugging, such as when analyzing
network traffic.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Response struct {
ServiceMethod string
Seq uint64
Error string
next *Response
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Server" data-name="Server">
               <h3>
                  Server
                  <span class="badge">struct</span>
                  <a href="#Server" class="anchor" title="Link to Server">#</a>
               </h3>
               
               <p>Server represents an RPC Server.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Server struct {
serviceMap sync.Map
reqLock sync.Mutex
freeReq *Request
respLock sync.Mutex
freeResp *Response
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="debugHTTP" data-name="debugHTTP">
               <h3>
                  debugHTTP
                  <span class="badge">struct</span>
                  <a href="#debugHTTP" class="anchor" title="Link to debugHTTP">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type debugHTTP struct {
*Server
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="debugMethod" data-name="debugMethod">
               <h3>
                  debugMethod
                  <span class="badge">struct</span>
                  <a href="#debugMethod" class="anchor" title="Link to debugMethod">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type debugMethod struct {
Type *methodType
Name string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="debugService" data-name="debugService">
               <h3>
                  debugService
                  <span class="badge">struct</span>
                  <a href="#debugService" class="anchor" title="Link to debugService">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type debugService struct {
Service *service
Name string
Method []debugMethod
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="gobClientCodec" data-name="gobClientCodec">
               <h3>
                  gobClientCodec
                  <span class="badge">struct</span>
                  <a href="#gobClientCodec" class="anchor" title="Link to gobClientCodec">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type gobClientCodec struct {
rwc io.ReadWriteCloser
dec *gob.Decoder
enc *gob.Encoder
encBuf *bufio.Writer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="gobServerCodec" data-name="gobServerCodec">
               <h3>
                  gobServerCodec
                  <span class="badge">struct</span>
                  <a href="#gobServerCodec" class="anchor" title="Link to gobServerCodec">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type gobServerCodec struct {
rwc io.ReadWriteCloser
dec *gob.Decoder
enc *gob.Encoder
encBuf *bufio.Writer
closed bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="methodType" data-name="methodType">
               <h3>
                  methodType
                  <span class="badge">struct</span>
                  <a href="#methodType" class="anchor" title="Link to methodType">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type methodType struct {
sync.Mutex
method reflect.Method
ArgType reflect.Type
ReplyType reflect.Type
numCalls uint
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="service" data-name="service">
               <h3>
                  service
                  <span class="badge">struct</span>
                  <a href="#service" class="anchor" title="Link to service">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type service struct {
name string
rcvr reflect.Value
typ reflect.Type
method map[string]*methodType
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Accept" data-name="Accept">
               <h3>
                  Accept 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Accept" class="anchor" title="Link to Accept">#</a>
               </h3>
               
               <p>Accept accepts connections on the listener and serves requests
for each incoming connection. Accept blocks until the listener
returns a non-nil error. The caller typically invokes Accept in a
go statement.</p>
               
               <pre><code class="language-go">func (server *Server) Accept(lis net.Listener)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Accept" data-name="Accept">
               <h3>
                  Accept 
                  <span class="badge">function</span>
                  
                  <a href="#Accept" class="anchor" title="Link to Accept">#</a>
               </h3>
               
               <p>Accept accepts connections on the listener and serves requests
to [DefaultServer] for each incoming connection.
Accept blocks; the caller typically invokes it in a go statement.</p>
               
               <pre><code class="language-go">func Accept(lis net.Listener)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Call" data-name="Call">
               <h3>
                  Call 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Call" class="anchor" title="Link to Call">#</a>
               </h3>
               
               <p>Call invokes the named function, waits for it to complete, and returns its error status.</p>
               
               <pre><code class="language-go">func (client *Client) Call(serviceMethod string, args any, reply any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *gobClientCodec) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *gobServerCodec) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close calls the underlying codec's Close method. If the connection is already
shutting down, [ErrShutdown] is returned.</p>
               
               <pre><code class="language-go">func (client *Client) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Dial" data-name="Dial">
               <h3>
                  Dial 
                  <span class="badge">function</span>
                  
                  <a href="#Dial" class="anchor" title="Link to Dial">#</a>
               </h3>
               
               <p>Dial connects to an RPC server at the specified network address.</p>
               
               <pre><code class="language-go">func Dial(network string, address string) (*Client, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DialHTTP" data-name="DialHTTP">
               <h3>
                  DialHTTP 
                  <span class="badge">function</span>
                  
                  <a href="#DialHTTP" class="anchor" title="Link to DialHTTP">#</a>
               </h3>
               
               <p>DialHTTP connects to an HTTP RPC server at the specified network address
listening on the default HTTP RPC path.</p>
               
               <pre><code class="language-go">func DialHTTP(network string, address string) (*Client, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DialHTTPPath" data-name="DialHTTPPath">
               <h3>
                  DialHTTPPath 
                  <span class="badge">function</span>
                  
                  <a href="#DialHTTPPath" class="anchor" title="Link to DialHTTPPath">#</a>
               </h3>
               
               <p>DialHTTPPath connects to an HTTP RPC server
at the specified network address and path.</p>
               
               <pre><code class="language-go">func DialHTTPPath(network string, address string, path string) (*Client, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e ServerError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Go" data-name="Go">
               <h3>
                  Go 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Go" class="anchor" title="Link to Go">#</a>
               </h3>
               
               <p>Go invokes the function asynchronously. It returns the [Call] structure representing
the invocation. The done channel will signal when the call is complete by returning
the same Call object. If done is nil, Go will allocate a new channel.
If non-nil, done must be buffered or Go will deliberately crash.</p>
               
               <pre><code class="language-go">func (client *Client) Go(serviceMethod string, args any, reply any, done chan *Call) *Call</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HandleHTTP" data-name="HandleHTTP">
               <h3>
                  HandleHTTP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HandleHTTP" class="anchor" title="Link to HandleHTTP">#</a>
               </h3>
               
               <p>HandleHTTP registers an HTTP handler for RPC messages on rpcPath,
and a debugging handler on debugPath.
It is still necessary to invoke [http.Serve](), typically in a go statement.</p>
               
               <pre><code class="language-go">func (server *Server) HandleHTTP(rpcPath string, debugPath string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HandleHTTP" data-name="HandleHTTP">
               <h3>
                  HandleHTTP 
                  <span class="badge">function</span>
                  
                  <a href="#HandleHTTP" class="anchor" title="Link to HandleHTTP">#</a>
               </h3>
               
               <p>HandleHTTP registers an HTTP handler for RPC messages to [DefaultServer]
on [DefaultRPCPath] and a debugging handler on [DefaultDebugPath].
It is still necessary to invoke [http.Serve](), typically in a go statement.</p>
               
               <pre><code class="language-go">func HandleHTTP()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code class="language-go">func (s serviceArray) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code class="language-go">func (m methodArray) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Less" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Less" class="anchor" title="Link to Less">#</a>
               </h3>
               
               <pre><code class="language-go">func (m methodArray) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Less" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Less" class="anchor" title="Link to Less">#</a>
               </h3>
               
               <pre><code class="language-go">func (s serviceArray) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewClient" data-name="NewClient">
               <h3>
                  NewClient 
                  <span class="badge">function</span>
                  
                  <a href="#NewClient" class="anchor" title="Link to NewClient">#</a>
               </h3>
               
               <p>NewClient returns a new [Client] to handle requests to the
set of services at the other end of the connection.
It adds a buffer to the write side of the connection so
the header and payload are sent as a unit.
The read and write halves of the connection are serialized independently,
so no interlocking is required. However each half may be accessed
concurrently so the implementation of conn should protect against
concurrent reads or concurrent writes.</p>
               
               <pre><code class="language-go">func NewClient(conn io.ReadWriteCloser) *Client</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewClientWithCodec" data-name="NewClientWithCodec">
               <h3>
                  NewClientWithCodec 
                  <span class="badge">function</span>
                  
                  <a href="#NewClientWithCodec" class="anchor" title="Link to NewClientWithCodec">#</a>
               </h3>
               
               <p>NewClientWithCodec is like [NewClient] but uses the specified
codec to encode requests and decode responses.</p>
               
               <pre><code class="language-go">func NewClientWithCodec(codec ClientCodec) *Client</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewServer" data-name="NewServer">
               <h3>
                  NewServer 
                  <span class="badge">function</span>
                  
                  <a href="#NewServer" class="anchor" title="Link to NewServer">#</a>
               </h3>
               
               <p>NewServer returns a new [Server].</p>
               
               <pre><code class="language-go">func NewServer() *Server</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumCalls" data-name="NumCalls">
               <h3>
                  NumCalls 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumCalls" class="anchor" title="Link to NumCalls">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *methodType) NumCalls() (n uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadRequestBody" data-name="ReadRequestBody">
               <h3>
                  ReadRequestBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadRequestBody" class="anchor" title="Link to ReadRequestBody">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *gobServerCodec) ReadRequestBody(body any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadRequestHeader" data-name="ReadRequestHeader">
               <h3>
                  ReadRequestHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadRequestHeader" class="anchor" title="Link to ReadRequestHeader">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *gobServerCodec) ReadRequestHeader(r *Request) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadResponseBody" data-name="ReadResponseBody">
               <h3>
                  ReadResponseBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadResponseBody" class="anchor" title="Link to ReadResponseBody">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *gobClientCodec) ReadResponseBody(body any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadResponseHeader" data-name="ReadResponseHeader">
               <h3>
                  ReadResponseHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadResponseHeader" class="anchor" title="Link to ReadResponseHeader">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *gobClientCodec) ReadResponseHeader(r *Response) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Register" data-name="Register">
               <h3>
                  Register 
                  <span class="badge">function</span>
                  
                  <a href="#Register" class="anchor" title="Link to Register">#</a>
               </h3>
               
               <p>Register publishes the receiver's methods in the [DefaultServer].</p>
               
               <pre><code class="language-go">func Register(rcvr any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Register" data-name="Register">
               <h3>
                  Register 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Register" class="anchor" title="Link to Register">#</a>
               </h3>
               
               <p>Register publishes in the server the set of methods of the
receiver value that satisfy the following conditions:
- exported method of exported type
- two arguments, both of exported type
- the second argument is a pointer
- one return value, of type error
It returns an error if the receiver is not an exported type or has
no suitable methods. It also logs the error using package log.
The client accesses each method using a string of the form "Type.Method",
where Type is the receiver's concrete type.</p>
               
               <pre><code class="language-go">func (server *Server) Register(rcvr any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RegisterName" data-name="RegisterName">
               <h3>
                  RegisterName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RegisterName" class="anchor" title="Link to RegisterName">#</a>
               </h3>
               
               <p>RegisterName is like [Register] but uses the provided name for the type
instead of the receiver's concrete type.</p>
               
               <pre><code class="language-go">func (server *Server) RegisterName(name string, rcvr any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RegisterName" data-name="RegisterName">
               <h3>
                  RegisterName 
                  <span class="badge">function</span>
                  
                  <a href="#RegisterName" class="anchor" title="Link to RegisterName">#</a>
               </h3>
               
               <p>RegisterName is like [Register] but uses the provided name for the type
instead of the receiver's concrete type.</p>
               
               <pre><code class="language-go">func RegisterName(name string, rcvr any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeCodec" data-name="ServeCodec">
               <h3>
                  ServeCodec 
                  <span class="badge">function</span>
                  
                  <a href="#ServeCodec" class="anchor" title="Link to ServeCodec">#</a>
               </h3>
               
               <p>ServeCodec is like [ServeConn] but uses the specified codec to
decode requests and encode responses.</p>
               
               <pre><code class="language-go">func ServeCodec(codec ServerCodec)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeCodec" data-name="ServeCodec">
               <h3>
                  ServeCodec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeCodec" class="anchor" title="Link to ServeCodec">#</a>
               </h3>
               
               <p>ServeCodec is like [ServeConn] but uses the specified codec to
decode requests and encode responses.</p>
               
               <pre><code class="language-go">func (server *Server) ServeCodec(codec ServerCodec)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeConn" data-name="ServeConn">
               <h3>
                  ServeConn 
                  <span class="badge">function</span>
                  
                  <a href="#ServeConn" class="anchor" title="Link to ServeConn">#</a>
               </h3>
               
               <p>ServeConn runs the [DefaultServer] on a single connection.
ServeConn blocks, serving the connection until the client hangs up.
The caller typically invokes ServeConn in a go statement.
ServeConn uses the gob wire format (see package gob) on the
connection. To use an alternate codec, use [ServeCodec].
See [NewClient]'s comment for information about concurrent access.</p>
               
               <pre><code class="language-go">func ServeConn(conn io.ReadWriteCloser)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeConn" data-name="ServeConn">
               <h3>
                  ServeConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeConn" class="anchor" title="Link to ServeConn">#</a>
               </h3>
               
               <p>ServeConn runs the server on a single connection.
ServeConn blocks, serving the connection until the client hangs up.
The caller typically invokes ServeConn in a go statement.
ServeConn uses the gob wire format (see package gob) on the
connection. To use an alternate codec, use [ServeCodec].
See [NewClient]'s comment for information about concurrent access.</p>
               
               <pre><code class="language-go">func (server *Server) ServeConn(conn io.ReadWriteCloser)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeHTTP" data-name="ServeHTTP">
               <h3>
                  ServeHTTP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeHTTP" class="anchor" title="Link to ServeHTTP">#</a>
               </h3>
               
               <p>ServeHTTP implements an [http.Handler] that answers RPC requests.</p>
               
               <pre><code class="language-go">func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeHTTP" data-name="ServeHTTP">
               <h3>
                  ServeHTTP 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeHTTP" class="anchor" title="Link to ServeHTTP">#</a>
               </h3>
               
               <p>Runs at /debug/rpc</p>
               
               <pre><code class="language-go">func (server debugHTTP) ServeHTTP(w http.ResponseWriter, req *http.Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeRequest" data-name="ServeRequest">
               <h3>
                  ServeRequest 
                  <span class="badge">function</span>
                  
                  <a href="#ServeRequest" class="anchor" title="Link to ServeRequest">#</a>
               </h3>
               
               <p>ServeRequest is like [ServeCodec] but synchronously serves a single request.
It does not close the codec upon completion.</p>
               
               <pre><code class="language-go">func ServeRequest(codec ServerCodec) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ServeRequest" data-name="ServeRequest">
               <h3>
                  ServeRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ServeRequest" class="anchor" title="Link to ServeRequest">#</a>
               </h3>
               
               <p>ServeRequest is like [ServeCodec] but synchronously serves a single request.
It does not close the codec upon completion.</p>
               
               <pre><code class="language-go">func (server *Server) ServeRequest(codec ServerCodec) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <pre><code class="language-go">func (s serviceArray) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <pre><code class="language-go">func (m methodArray) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteRequest" data-name="WriteRequest">
               <h3>
                  WriteRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteRequest" class="anchor" title="Link to WriteRequest">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *gobClientCodec) WriteRequest(r *Request, body any) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteResponse" data-name="WriteResponse">
               <h3>
                  WriteResponse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteResponse" class="anchor" title="Link to WriteResponse">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *gobServerCodec) WriteResponse(r *Response, body any) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="call" data-name="call">
               <h3>
                  call 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#call" class="anchor" title="Link to call">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *service) call(server *Server, sending *sync.Mutex, wg *sync.WaitGroup, mtype *methodType, req *Request, argv reflect.Value, replyv reflect.Value, codec ServerCodec)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="done" data-name="done">
               <h3>
                  done 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#done" class="anchor" title="Link to done">#</a>
               </h3>
               
               <pre><code class="language-go">func (call *Call) done()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="freeRequest" data-name="freeRequest">
               <h3>
                  freeRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#freeRequest" class="anchor" title="Link to freeRequest">#</a>
               </h3>
               
               <pre><code class="language-go">func (server *Server) freeRequest(req *Request)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="freeResponse" data-name="freeResponse">
               <h3>
                  freeResponse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#freeResponse" class="anchor" title="Link to freeResponse">#</a>
               </h3>
               
               <pre><code class="language-go">func (server *Server) freeResponse(resp *Response)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getRequest" data-name="getRequest">
               <h3>
                  getRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getRequest" class="anchor" title="Link to getRequest">#</a>
               </h3>
               
               <pre><code class="language-go">func (server *Server) getRequest() *Request</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getResponse" data-name="getResponse">
               <h3>
                  getResponse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getResponse" class="anchor" title="Link to getResponse">#</a>
               </h3>
               
               <pre><code class="language-go">func (server *Server) getResponse() *Response</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="input" data-name="input">
               <h3>
                  input 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#input" class="anchor" title="Link to input">#</a>
               </h3>
               
               <pre><code class="language-go">func (client *Client) input()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isExportedOrBuiltinType" data-name="isExportedOrBuiltinType">
               <h3>
                  isExportedOrBuiltinType 
                  <span class="badge">function</span>
                  
                  <a href="#isExportedOrBuiltinType" class="anchor" title="Link to isExportedOrBuiltinType">#</a>
               </h3>
               
               <p>Is this type exported or a builtin?</p>
               
               <pre><code class="language-go">func isExportedOrBuiltinType(t reflect.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readRequest" data-name="readRequest">
               <h3>
                  readRequest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readRequest" class="anchor" title="Link to readRequest">#</a>
               </h3>
               
               <pre><code class="language-go">func (server *Server) readRequest(codec ServerCodec) (service *service, mtype *methodType, req *Request, argv reflect.Value, replyv reflect.Value, keepReading bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readRequestHeader" data-name="readRequestHeader">
               <h3>
                  readRequestHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readRequestHeader" class="anchor" title="Link to readRequestHeader">#</a>
               </h3>
               
               <pre><code class="language-go">func (server *Server) readRequestHeader(codec ServerCodec) (svc *service, mtype *methodType, req *Request, keepReading bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="register" data-name="register">
               <h3>
                  register 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#register" class="anchor" title="Link to register">#</a>
               </h3>
               
               <pre><code class="language-go">func (server *Server) register(rcvr any, name string, useName bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="send" data-name="send">
               <h3>
                  send 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#send" class="anchor" title="Link to send">#</a>
               </h3>
               
               <pre><code class="language-go">func (client *Client) send(call *Call)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sendResponse" data-name="sendResponse">
               <h3>
                  sendResponse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sendResponse" class="anchor" title="Link to sendResponse">#</a>
               </h3>
               
               <pre><code class="language-go">func (server *Server) sendResponse(sending *sync.Mutex, req *Request, reply any, codec ServerCodec, errmsg string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="suitableMethods" data-name="suitableMethods">
               <h3>
                  suitableMethods 
                  <span class="badge">function</span>
                  
                  <a href="#suitableMethods" class="anchor" title="Link to suitableMethods">#</a>
               </h3>
               
               <p>suitableMethods returns suitable Rpc methods of typ. It will log
errors if logErr is true.</p>
               
               <pre><code class="language-go">func suitableMethods(typ reflect.Type, logErr bool) map[string]*methodType</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>