<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - rpc</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="net_rpc_jsonrpc-docs.html">jsonrpc</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>rpc</code>
         </h1>
         <hr />
         
         <article class="global" data-name="newServer">
            <h2>newServer</h2>
            <hr />
            
            <pre><code>newServer *Server</code></pre>
         </article>
         
         <article class="global" data-name="serverAddr">
            <h2>serverAddr</h2>
            <hr />
            
            <pre><code>serverAddr string</code></pre>
         </article>
         
         <article class="global" data-name="newServerAddr">
            <h2>newServerAddr</h2>
            <hr />
            
            <pre><code>newServerAddr string</code></pre>
         </article>
         
         <article class="global" data-name="httpServerAddr">
            <h2>httpServerAddr</h2>
            <hr />
            
            <pre><code>httpServerAddr string</code></pre>
         </article>
         
         <article class="global" data-name="once">
            <h2>once</h2>
            <hr />
            
            <pre><code>once sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="newOnce">
            <h2>newOnce</h2>
            <hr />
            
            <pre><code>newOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="httpOnce">
            <h2>httpOnce</h2>
            <hr />
            
            <pre><code>httpOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="newHttpPath">
            <h2>newHttpPath</h2>
            <hr />
            
            <pre><code>newHttpPath</code></pre>
         </article>
         
         <article class="global" data-name="ErrShutdown">
            <h2>ErrShutdown</h2>
            <hr />
            
            <pre><code>ErrShutdown</code></pre>
         </article>
         
         <article class="global" data-name="debugText">
            <h2>debugText</h2>
            <hr />
            
            <pre><code>debugText</code></pre>
         </article>
         
         <article class="global" data-name="debug">
            <h2>debug</h2>
            <hr />
            
            <pre><code>debug</code></pre>
         </article>
         
         <article class="global" data-name="debugLog">
            <h2>debugLog</h2>
            <hr />
            
            <p>If set, print log statements for internal and I/O errors.</p>
            
            <pre><code>debugLog</code></pre>
         </article>
         
         <article class="global" data-name="DefaultRPCPath">
            <h2>DefaultRPCPath</h2>
            <hr />
            
            <p>Defaults used by HandleHTTP</p>
            
            <pre><code>DefaultRPCPath</code></pre>
         </article>
         
         <article class="global" data-name="DefaultDebugPath">
            <h2>DefaultDebugPath</h2>
            <hr />
            
            <pre><code>DefaultDebugPath</code></pre>
         </article>
         
         <article class="global" data-name="typeOfError">
            <h2>typeOfError</h2>
            <hr />
            
            <p>Precompute the reflect type for error.</p>
            
            <pre><code>typeOfError</code></pre>
         </article>
         
         <article class="global" data-name="DefaultServer">
            <h2>DefaultServer</h2>
            <hr />
            
            <p>DefaultServer is the default instance of [*Server].</p>
            
            <pre><code>DefaultServer</code></pre>
         </article>
         
         <article class="global" data-name="logRegisterError">
            <h2>logRegisterError</h2>
            <hr />
            
            <p>logRegisterError specifies whether to log problems during method registration.
To debug registration, recompile the package with this set to true.</p>
            
            <pre><code>logRegisterError</code></pre>
         </article>
         
         <article class="global" data-name="invalidRequest">
            <h2>invalidRequest</h2>
            <hr />
            
            <p>A value sent as a placeholder for the server's response value when the server
receives an invalid request. It is never decoded by the client since the Response
contains an error when it is used.</p>
            
            <pre><code>invalidRequest</code></pre>
         </article>
         
         <article class="global" data-name="connected">
            <h2>connected</h2>
            <hr />
            
            <p>Can connect to RPC service using HTTP CONNECT to rpcPath.</p>
            
            <pre><code>connected</code></pre>
         </article>
          
         <article class="struct" data-name="Args">
            <h2>type Args struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">A int
B int</code></pre>
         </article>
         
         <article class="struct" data-name="Reply">
            <h2>type Reply struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">C int</code></pre>
         </article>
         
         <article class="struct" data-name="Embed">
            <h2>type Embed struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">hidden</code></pre>
         </article>
         
         <article class="struct" data-name="BuiltinTypes">
            <h2>type BuiltinTypes struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="CodecEmulator">
            <h2>type CodecEmulator struct</h2>
            <hr />
            
            <p>CodecEmulator provides a client-like api and a ServerCodec interface.
Can be used to test ServeRequest.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">server *Server
serviceMethod string
args *Args
reply *Reply
err error</code></pre>
         </article>
         
         <article class="struct" data-name="local">
            <h2>type local struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="writeCrasher">
            <h2>type writeCrasher struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">done *ast.ChanType</code></pre>
         </article>
         
         <article class="struct" data-name="Call">
            <h2>type Call struct</h2>
            <hr />
            
            <p>Call represents an active RPC.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ServiceMethod string
Args any
Reply any
Error error
Done *ast.ChanType</code></pre>
         </article>
         
         <article class="struct" data-name="Client">
            <h2>type Client struct</h2>
            <hr />
            
            <p>Client represents an RPC Client.
There may be multiple outstanding Calls associated
with a single Client, and a Client may be used by
multiple goroutines simultaneously.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">codec ClientCodec
reqMutex sync.Mutex
request Request
mutex sync.Mutex
seq uint64
pending *ast.MapType
closing bool
shutdown bool</code></pre>
         </article>
         
         <article class="struct" data-name="gobClientCodec">
            <h2>type gobClientCodec struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">rwc io.ReadWriteCloser
dec *gob.Decoder
enc *gob.Encoder
encBuf *bufio.Writer</code></pre>
         </article>
         
         <article class="struct" data-name="shutdownCodec">
            <h2>type shutdownCodec struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">responded *ast.ChanType
closed bool</code></pre>
         </article>
         
         <article class="struct" data-name="R">
            <h2>type R struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">msg []byte</code></pre>
         </article>
         
         <article class="struct" data-name="S">
            <h2>type S struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="debugMethod">
            <h2>type debugMethod struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Type *methodType
Name string</code></pre>
         </article>
         
         <article class="struct" data-name="debugService">
            <h2>type debugService struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Service *service
Name string
Method []debugMethod</code></pre>
         </article>
         
         <article class="struct" data-name="debugHTTP">
            <h2>type debugHTTP struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">*Server</code></pre>
         </article>
         
         <article class="struct" data-name="methodType">
            <h2>type methodType struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">sync.Mutex
method reflect.Method
ArgType reflect.Type
ReplyType reflect.Type
numCalls uint</code></pre>
         </article>
         
         <article class="struct" data-name="service">
            <h2>type service struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
rcvr reflect.Value
typ reflect.Type
method *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="Request">
            <h2>type Request struct</h2>
            <hr />
            
            <p>Request is a header written before every RPC call. It is used internally
but documented here as an aid to debugging, such as when analyzing
network traffic.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ServiceMethod string
Seq uint64
next *Request</code></pre>
         </article>
         
         <article class="struct" data-name="Response">
            <h2>type Response struct</h2>
            <hr />
            
            <p>Response is a header written before every RPC return. It is used internally
but documented here as an aid to debugging, such as when analyzing
network traffic.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ServiceMethod string
Seq uint64
Error string
next *Response</code></pre>
         </article>
         
         <article class="struct" data-name="Server">
            <h2>type Server struct</h2>
            <hr />
            
            <p>Server represents an RPC Server.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">serviceMap sync.Map
reqLock sync.Mutex
freeReq *Request
respLock sync.Mutex
freeResp *Response</code></pre>
         </article>
         
         <article class="struct" data-name="gobServerCodec">
            <h2>type gobServerCodec struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">rwc io.ReadWriteCloser
dec *gob.Decoder
enc *gob.Encoder
encBuf *bufio.Writer
closed bool</code></pre>
         </article>
          
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <pre><code>func Add(args Args, reply *Reply) error</code></pre>
         </article>
         
         <article class="function" data-name="Mul">
            <h2>Mul</h2>
            <hr />
            
            <pre><code>func Mul(args *Args, reply *Reply) error</code></pre>
         </article>
         
         <article class="function" data-name="Div">
            <h2>Div</h2>
            <hr />
            
            <pre><code>func Div(args Args, reply *Reply) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String(args *Args, reply *string) error</code></pre>
         </article>
         
         <article class="function" data-name="Scan">
            <h2>Scan</h2>
            <hr />
            
            <pre><code>func Scan(args string, reply *Reply) err error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error(args *Args, reply *Reply) error</code></pre>
         </article>
         
         <article class="function" data-name="SleepMilli">
            <h2>SleepMilli</h2>
            <hr />
            
            <pre><code>func SleepMilli(args *Args, reply *Reply) error</code></pre>
         </article>
         
         <article class="function" data-name="Exported">
            <h2>Exported</h2>
            <hr />
            
            <pre><code>func Exported(args Args, reply *Reply) error</code></pre>
         </article>
         
         <article class="function" data-name="Map">
            <h2>Map</h2>
            <hr />
            
            <pre><code>func Map(args *Args, reply **ast.MapType) error</code></pre>
         </article>
         
         <article class="function" data-name="Slice">
            <h2>Slice</h2>
            <hr />
            
            <pre><code>func Slice(args *Args, reply *[]int) error</code></pre>
         </article>
         
         <article class="function" data-name="Array">
            <h2>Array</h2>
            <hr />
            
            <pre><code>func Array(args *Args, reply *[]int) error</code></pre>
         </article>
         
         <article class="function" data-name="listenTCP">
            <h2>listenTCP</h2>
            <hr />
            
            <pre><code>func listenTCP() (net.Listener, string)</code></pre>
         </article>
         
         <article class="function" data-name="startServer">
            <h2>startServer</h2>
            <hr />
            
            <pre><code>func startServer()</code></pre>
         </article>
         
         <article class="function" data-name="startNewServer">
            <h2>startNewServer</h2>
            <hr />
            
            <pre><code>func startNewServer()</code></pre>
         </article>
         
         <article class="function" data-name="startHttpServer">
            <h2>startHttpServer</h2>
            <hr />
            
            <pre><code>func startHttpServer()</code></pre>
         </article>
         
         <article class="function" data-name="TestRPC">
            <h2>TestRPC</h2>
            <hr />
            
            <pre><code>func TestRPC(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testRPC">
            <h2>testRPC</h2>
            <hr />
            
            <pre><code>func testRPC(t *testing.T, addr string)</code></pre>
         </article>
         
         <article class="function" data-name="testNewServerRPC">
            <h2>testNewServerRPC</h2>
            <hr />
            
            <pre><code>func testNewServerRPC(t *testing.T, addr string)</code></pre>
         </article>
         
         <article class="function" data-name="TestHTTP">
            <h2>TestHTTP</h2>
            <hr />
            
            <pre><code>func TestHTTP(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testHTTPRPC">
            <h2>testHTTPRPC</h2>
            <hr />
            
            <pre><code>func testHTTPRPC(t *testing.T, path string)</code></pre>
         </article>
         
         <article class="function" data-name="TestBuiltinTypes">
            <h2>TestBuiltinTypes</h2>
            <hr />
            
            <pre><code>func TestBuiltinTypes(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Call">
            <h2>Call</h2>
            <hr />
            
            <pre><code>func Call(serviceMethod string, args *Args, reply *Reply) error</code></pre>
         </article>
         
         <article class="function" data-name="ReadRequestHeader">
            <h2>ReadRequestHeader</h2>
            <hr />
            
            <pre><code>func ReadRequestHeader(req *Request) error</code></pre>
         </article>
         
         <article class="function" data-name="ReadRequestBody">
            <h2>ReadRequestBody</h2>
            <hr />
            
            <pre><code>func ReadRequestBody(argv any) error</code></pre>
         </article>
         
         <article class="function" data-name="WriteResponse">
            <h2>WriteResponse</h2>
            <hr />
            
            <pre><code>func WriteResponse(resp *Response, reply any) error</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="TestServeRequest">
            <h2>TestServeRequest</h2>
            <hr />
            
            <pre><code>func TestServeRequest(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testServeRequest">
            <h2>testServeRequest</h2>
            <hr />
            
            <pre><code>func testServeRequest(t *testing.T, server *Server)</code></pre>
         </article>
         
         <article class="function" data-name="ReplyNotPointer">
            <h2>ReplyNotPointer</h2>
            <hr />
            
            <pre><code>func ReplyNotPointer(args *Args, reply Reply) error</code></pre>
         </article>
         
         <article class="function" data-name="ArgNotPublic">
            <h2>ArgNotPublic</h2>
            <hr />
            
            <pre><code>func ArgNotPublic(args *local, reply *Reply) error</code></pre>
         </article>
         
         <article class="function" data-name="ReplyNotPublic">
            <h2>ReplyNotPublic</h2>
            <hr />
            
            <pre><code>func ReplyNotPublic(args *Args, reply *local) error</code></pre>
         </article>
         
         <article class="function" data-name="NeedsPtrType">
            <h2>NeedsPtrType</h2>
            <hr />
            
            <pre><code>func NeedsPtrType(args *Args, reply *Reply) error</code></pre>
         </article>
         
         <article class="function" data-name="TestRegistrationError">
            <h2>TestRegistrationError</h2>
            <hr />
            
            <p>Check that registration handles lots of bad methods and a type with no suitable methods.</p>
            
            <pre><code>func TestRegistrationError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="WriteRequest">
            <h2>WriteRequest</h2>
            <hr />
            
            <pre><code>func WriteRequest(*Request, any) error</code></pre>
         </article>
         
         <article class="function" data-name="ReadResponseHeader">
            <h2>ReadResponseHeader</h2>
            <hr />
            
            <pre><code>func ReadResponseHeader(*Response) error</code></pre>
         </article>
         
         <article class="function" data-name="ReadResponseBody">
            <h2>ReadResponseBody</h2>
            <hr />
            
            <pre><code>func ReadResponseBody(any) error</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="TestSendDeadlock">
            <h2>TestSendDeadlock</h2>
            <hr />
            
            <pre><code>func TestSendDeadlock(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testSendDeadlock">
            <h2>testSendDeadlock</h2>
            <hr />
            
            <pre><code>func testSendDeadlock(client *Client)</code></pre>
         </article>
         
         <article class="function" data-name="dialDirect">
            <h2>dialDirect</h2>
            <hr />
            
            <pre><code>func dialDirect() (*Client, error)</code></pre>
         </article>
         
         <article class="function" data-name="dialHTTP">
            <h2>dialHTTP</h2>
            <hr />
            
            <pre><code>func dialHTTP() (*Client, error)</code></pre>
         </article>
         
         <article class="function" data-name="countMallocs">
            <h2>countMallocs</h2>
            <hr />
            
            <pre><code>func countMallocs(dial func, t *testing.T) float64</code></pre>
         </article>
         
         <article class="function" data-name="TestCountMallocs">
            <h2>TestCountMallocs</h2>
            <hr />
            
            <pre><code>func TestCountMallocs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCountMallocsOverHTTP">
            <h2>TestCountMallocsOverHTTP</h2>
            <hr />
            
            <pre><code>func TestCountMallocsOverHTTP(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestClientWriteError">
            <h2>TestClientWriteError</h2>
            <hr />
            
            <pre><code>func TestClientWriteError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestTCPClose">
            <h2>TestTCPClose</h2>
            <hr />
            
            <pre><code>func TestTCPClose(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestErrorAfterClientClose">
            <h2>TestErrorAfterClientClose</h2>
            <hr />
            
            <pre><code>func TestErrorAfterClientClose(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAcceptExitAfterListenerClose">
            <h2>TestAcceptExitAfterListenerClose</h2>
            <hr />
            
            <p>Tests the fix to issue 11221. Without the fix, this loops forever or crashes.</p>
            
            <pre><code>func TestAcceptExitAfterListenerClose(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestShutdown">
            <h2>TestShutdown</h2>
            <hr />
            
            <pre><code>func TestShutdown(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="benchmarkEndToEnd">
            <h2>benchmarkEndToEnd</h2>
            <hr />
            
            <pre><code>func benchmarkEndToEnd(dial func, b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="benchmarkEndToEndAsync">
            <h2>benchmarkEndToEndAsync</h2>
            <hr />
            
            <pre><code>func benchmarkEndToEndAsync(dial func, b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEndToEnd">
            <h2>BenchmarkEndToEnd</h2>
            <hr />
            
            <pre><code>func BenchmarkEndToEnd(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEndToEndHTTP">
            <h2>BenchmarkEndToEndHTTP</h2>
            <hr />
            
            <pre><code>func BenchmarkEndToEndHTTP(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEndToEndAsync">
            <h2>BenchmarkEndToEndAsync</h2>
            <hr />
            
            <pre><code>func BenchmarkEndToEndAsync(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEndToEndAsyncHTTP">
            <h2>BenchmarkEndToEndAsyncHTTP</h2>
            <hr />
            
            <pre><code>func BenchmarkEndToEndAsyncHTTP(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="send">
            <h2>send</h2>
            <hr />
            
            <pre><code>func send(call *Call)</code></pre>
         </article>
         
         <article class="function" data-name="input">
            <h2>input</h2>
            <hr />
            
            <pre><code>func input()</code></pre>
         </article>
         
         <article class="function" data-name="done">
            <h2>done</h2>
            <hr />
            
            <pre><code>func done()</code></pre>
         </article>
         
         <article class="function" data-name="NewClient">
            <h2>NewClient</h2>
            <hr />
            
            <p>NewClient returns a new [Client] to handle requests to the
set of services at the other end of the connection.
It adds a buffer to the write side of the connection so
the header and payload are sent as a unit.

The read and write halves of the connection are serialized independently,
so no interlocking is required. However each half may be accessed
concurrently so the implementation of conn should protect against
concurrent reads or concurrent writes.</p>
            
            <pre><code>func NewClient(conn io.ReadWriteCloser) *Client</code></pre>
         </article>
         
         <article class="function" data-name="NewClientWithCodec">
            <h2>NewClientWithCodec</h2>
            <hr />
            
            <p>NewClientWithCodec is like [NewClient] but uses the specified
codec to encode requests and decode responses.</p>
            
            <pre><code>func NewClientWithCodec(codec ClientCodec) *Client</code></pre>
         </article>
         
         <article class="function" data-name="WriteRequest">
            <h2>WriteRequest</h2>
            <hr />
            
            <pre><code>func WriteRequest(r *Request, body any) err error</code></pre>
         </article>
         
         <article class="function" data-name="ReadResponseHeader">
            <h2>ReadResponseHeader</h2>
            <hr />
            
            <pre><code>func ReadResponseHeader(r *Response) error</code></pre>
         </article>
         
         <article class="function" data-name="ReadResponseBody">
            <h2>ReadResponseBody</h2>
            <hr />
            
            <pre><code>func ReadResponseBody(body any) error</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="DialHTTP">
            <h2>DialHTTP</h2>
            <hr />
            
            <p>DialHTTP connects to an HTTP RPC server at the specified network address
listening on the default HTTP RPC path.</p>
            
            <pre><code>func DialHTTP(network string, address string) (*Client, error)</code></pre>
         </article>
         
         <article class="function" data-name="DialHTTPPath">
            <h2>DialHTTPPath</h2>
            <hr />
            
            <p>DialHTTPPath connects to an HTTP RPC server
at the specified network address and path.</p>
            
            <pre><code>func DialHTTPPath(network string, address string, path string) (*Client, error)</code></pre>
         </article>
         
         <article class="function" data-name="Dial">
            <h2>Dial</h2>
            <hr />
            
            <p>Dial connects to an RPC server at the specified network address.</p>
            
            <pre><code>func Dial(network string, address string) (*Client, error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close calls the underlying codec's Close method. If the connection is already
shutting down, [ErrShutdown] is returned.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="Go">
            <h2>Go</h2>
            <hr />
            
            <p>Go invokes the function asynchronously. It returns the [Call] structure representing
the invocation. The done channel will signal when the call is complete by returning
the same Call object. If done is nil, Go will allocate a new channel.
If non-nil, done must be buffered or Go will deliberately crash.</p>
            
            <pre><code>func Go(serviceMethod string, args any, reply any, done *ast.ChanType) *Call</code></pre>
         </article>
         
         <article class="function" data-name="Call">
            <h2>Call</h2>
            <hr />
            
            <p>Call invokes the named function, waits for it to complete, and returns its error status.</p>
            
            <pre><code>func Call(serviceMethod string, args any, reply any) error</code></pre>
         </article>
         
         <article class="function" data-name="WriteRequest">
            <h2>WriteRequest</h2>
            <hr />
            
            <pre><code>func WriteRequest(*Request, any) error</code></pre>
         </article>
         
         <article class="function" data-name="ReadResponseBody">
            <h2>ReadResponseBody</h2>
            <hr />
            
            <pre><code>func ReadResponseBody(any) error</code></pre>
         </article>
         
         <article class="function" data-name="ReadResponseHeader">
            <h2>ReadResponseHeader</h2>
            <hr />
            
            <pre><code>func ReadResponseHeader(*Response) error</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="TestCloseCodec">
            <h2>TestCloseCodec</h2>
            <hr />
            
            <pre><code>func TestCloseCodec(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Recv">
            <h2>Recv</h2>
            <hr />
            
            <pre><code>func Recv(nul **ast.StructType, reply *R) error</code></pre>
         </article>
         
         <article class="function" data-name="TestGobError">
            <h2>TestGobError</h2>
            <hr />
            
            <pre><code>func TestGobError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="ServeHTTP">
            <h2>ServeHTTP</h2>
            <hr />
            
            <p>Runs at /debug/rpc</p>
            
            <pre><code>func ServeHTTP(w http.ResponseWriter, req *http.Request)</code></pre>
         </article>
         
         <article class="function" data-name="NewServer">
            <h2>NewServer</h2>
            <hr />
            
            <p>NewServer returns a new [Server].</p>
            
            <pre><code>func NewServer() *Server</code></pre>
         </article>
         
         <article class="function" data-name="isExportedOrBuiltinType">
            <h2>isExportedOrBuiltinType</h2>
            <hr />
            
            <p>Is this type exported or a builtin?</p>
            
            <pre><code>func isExportedOrBuiltinType(t reflect.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="Register">
            <h2>Register</h2>
            <hr />
            
            <p>Register publishes in the server the set of methods of the
receiver value that satisfy the following conditions:
  - exported method of exported type
  - two arguments, both of exported type
  - the second argument is a pointer
  - one return value, of type error

It returns an error if the receiver is not an exported type or has
no suitable methods. It also logs the error using package log.
The client accesses each method using a string of the form "Type.Method",
where Type is the receiver's concrete type.</p>
            
            <pre><code>func Register(rcvr any) error</code></pre>
         </article>
         
         <article class="function" data-name="RegisterName">
            <h2>RegisterName</h2>
            <hr />
            
            <p>RegisterName is like [Register] but uses the provided name for the type
instead of the receiver's concrete type.</p>
            
            <pre><code>func RegisterName(name string, rcvr any) error</code></pre>
         </article>
         
         <article class="function" data-name="register">
            <h2>register</h2>
            <hr />
            
            <pre><code>func register(rcvr any, name string, useName bool) error</code></pre>
         </article>
         
         <article class="function" data-name="suitableMethods">
            <h2>suitableMethods</h2>
            <hr />
            
            <p>suitableMethods returns suitable Rpc methods of typ. It will log
errors if logErr is true.</p>
            
            <pre><code>func suitableMethods(typ reflect.Type, logErr bool) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="sendResponse">
            <h2>sendResponse</h2>
            <hr />
            
            <pre><code>func sendResponse(sending *sync.Mutex, req *Request, reply any, codec ServerCodec, errmsg string)</code></pre>
         </article>
         
         <article class="function" data-name="NumCalls">
            <h2>NumCalls</h2>
            <hr />
            
            <pre><code>func NumCalls() n uint</code></pre>
         </article>
         
         <article class="function" data-name="call">
            <h2>call</h2>
            <hr />
            
            <pre><code>func call(server *Server, sending *sync.Mutex, wg *sync.WaitGroup, mtype *methodType, req *Request, argv reflect.Value, replyv reflect.Value, codec ServerCodec)</code></pre>
         </article>
         
         <article class="function" data-name="ReadRequestHeader">
            <h2>ReadRequestHeader</h2>
            <hr />
            
            <pre><code>func ReadRequestHeader(r *Request) error</code></pre>
         </article>
         
         <article class="function" data-name="ReadRequestBody">
            <h2>ReadRequestBody</h2>
            <hr />
            
            <pre><code>func ReadRequestBody(body any) error</code></pre>
         </article>
         
         <article class="function" data-name="WriteResponse">
            <h2>WriteResponse</h2>
            <hr />
            
            <pre><code>func WriteResponse(r *Response, body any) err error</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="ServeConn">
            <h2>ServeConn</h2>
            <hr />
            
            <p>ServeConn runs the server on a single connection.
ServeConn blocks, serving the connection until the client hangs up.
The caller typically invokes ServeConn in a go statement.
ServeConn uses the gob wire format (see package gob) on the
connection. To use an alternate codec, use [ServeCodec].
See [NewClient]'s comment for information about concurrent access.</p>
            
            <pre><code>func ServeConn(conn io.ReadWriteCloser)</code></pre>
         </article>
         
         <article class="function" data-name="ServeCodec">
            <h2>ServeCodec</h2>
            <hr />
            
            <p>ServeCodec is like [ServeConn] but uses the specified codec to
decode requests and encode responses.</p>
            
            <pre><code>func ServeCodec(codec ServerCodec)</code></pre>
         </article>
         
         <article class="function" data-name="ServeRequest">
            <h2>ServeRequest</h2>
            <hr />
            
            <p>ServeRequest is like [ServeCodec] but synchronously serves a single request.
It does not close the codec upon completion.</p>
            
            <pre><code>func ServeRequest(codec ServerCodec) error</code></pre>
         </article>
         
         <article class="function" data-name="getRequest">
            <h2>getRequest</h2>
            <hr />
            
            <pre><code>func getRequest() *Request</code></pre>
         </article>
         
         <article class="function" data-name="freeRequest">
            <h2>freeRequest</h2>
            <hr />
            
            <pre><code>func freeRequest(req *Request)</code></pre>
         </article>
         
         <article class="function" data-name="getResponse">
            <h2>getResponse</h2>
            <hr />
            
            <pre><code>func getResponse() *Response</code></pre>
         </article>
         
         <article class="function" data-name="freeResponse">
            <h2>freeResponse</h2>
            <hr />
            
            <pre><code>func freeResponse(resp *Response)</code></pre>
         </article>
         
         <article class="function" data-name="readRequest">
            <h2>readRequest</h2>
            <hr />
            
            <pre><code>func readRequest(codec ServerCodec) (service *service, mtype *methodType, req *Request, argv reflect.Value, replyv reflect.Value, keepReading bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readRequestHeader">
            <h2>readRequestHeader</h2>
            <hr />
            
            <pre><code>func readRequestHeader(codec ServerCodec) (svc *service, mtype *methodType, req *Request, keepReading bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Accept">
            <h2>Accept</h2>
            <hr />
            
            <p>Accept accepts connections on the listener and serves requests
for each incoming connection. Accept blocks until the listener
returns a non-nil error. The caller typically invokes Accept in a
go statement.</p>
            
            <pre><code>func Accept(lis net.Listener)</code></pre>
         </article>
         
         <article class="function" data-name="Register">
            <h2>Register</h2>
            <hr />
            
            <p>Register publishes the receiver's methods in the [DefaultServer].</p>
            
            <pre><code>func Register(rcvr any) error</code></pre>
         </article>
         
         <article class="function" data-name="RegisterName">
            <h2>RegisterName</h2>
            <hr />
            
            <p>RegisterName is like [Register] but uses the provided name for the type
instead of the receiver's concrete type.</p>
            
            <pre><code>func RegisterName(name string, rcvr any) error</code></pre>
         </article>
         
         <article class="function" data-name="ServeConn">
            <h2>ServeConn</h2>
            <hr />
            
            <p>ServeConn runs the [DefaultServer] on a single connection.
ServeConn blocks, serving the connection until the client hangs up.
The caller typically invokes ServeConn in a go statement.
ServeConn uses the gob wire format (see package gob) on the
connection. To use an alternate codec, use [ServeCodec].
See [NewClient]'s comment for information about concurrent access.</p>
            
            <pre><code>func ServeConn(conn io.ReadWriteCloser)</code></pre>
         </article>
         
         <article class="function" data-name="ServeCodec">
            <h2>ServeCodec</h2>
            <hr />
            
            <p>ServeCodec is like [ServeConn] but uses the specified codec to
decode requests and encode responses.</p>
            
            <pre><code>func ServeCodec(codec ServerCodec)</code></pre>
         </article>
         
         <article class="function" data-name="ServeRequest">
            <h2>ServeRequest</h2>
            <hr />
            
            <p>ServeRequest is like [ServeCodec] but synchronously serves a single request.
It does not close the codec upon completion.</p>
            
            <pre><code>func ServeRequest(codec ServerCodec) error</code></pre>
         </article>
         
         <article class="function" data-name="Accept">
            <h2>Accept</h2>
            <hr />
            
            <p>Accept accepts connections on the listener and serves requests
to [DefaultServer] for each incoming connection.
Accept blocks; the caller typically invokes it in a go statement.</p>
            
            <pre><code>func Accept(lis net.Listener)</code></pre>
         </article>
         
         <article class="function" data-name="ServeHTTP">
            <h2>ServeHTTP</h2>
            <hr />
            
            <p>ServeHTTP implements an [http.Handler] that answers RPC requests.</p>
            
            <pre><code>func ServeHTTP(w http.ResponseWriter, req *http.Request)</code></pre>
         </article>
         
         <article class="function" data-name="HandleHTTP">
            <h2>HandleHTTP</h2>
            <hr />
            
            <p>HandleHTTP registers an HTTP handler for RPC messages on rpcPath,
and a debugging handler on debugPath.
It is still necessary to invoke [http.Serve](), typically in a go statement.</p>
            
            <pre><code>func HandleHTTP(rpcPath string, debugPath string)</code></pre>
         </article>
         
         <article class="function" data-name="HandleHTTP">
            <h2>HandleHTTP</h2>
            <hr />
            
            <p>HandleHTTP registers an HTTP handler for RPC messages to [DefaultServer]
on [DefaultRPCPath] and a debugging handler on [DefaultDebugPath].
It is still necessary to invoke [http.Serve](), typically in a go statement.</p>
            
            <pre><code>func HandleHTTP()</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
