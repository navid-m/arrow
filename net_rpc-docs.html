<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - rpc</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="net_rpc_jsonrpc-docs.html">jsonrpc</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>rpc</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bufio"
"encoding/gob"
"errors"
"io"
"log"
"net"
"net/http"
"sync"
"fmt"
"html/template"
"net/http"
"slices"
"strings"
"bufio"
"encoding/gob"
"errors"
"go/token"
"io"
"log"
"net"
"net/http"
"reflect"
"strings"
"sync"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="DefaultDebugPath">
               <h3>
                  DefaultDebugPath 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const DefaultDebugPath = "/debug/rpc"</code></pre>
            </article>
            
            <article class="global" data-name="DefaultRPCPath">
               <h3>
                  DefaultRPCPath 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Defaults used by HandleHTTP</p>
               
               <pre><code>const DefaultRPCPath = "/_goRPC_"</code></pre>
            </article>
            
            <article class="global" data-name="DefaultServer">
               <h3>
                  DefaultServer 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>DefaultServer is the default instance of [*Server].</p>
               
               <pre><code>var DefaultServer = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrShutdown">
               <h3>
                  ErrShutdown 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ErrShutdown = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="connected">
               <h3>
                  connected 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Can connect to RPC service using HTTP CONNECT to rpcPath.</p>
               
               <pre><code>var connected = "200 Connected to Go RPC"</code></pre>
            </article>
            
            <article class="global" data-name="debug">
               <h3>
                  debug 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var debug = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="debugLog">
               <h3>
                  debugLog 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>If set, print log statements for internal and I/O errors.</p>
               
               <pre><code>var debugLog = false</code></pre>
            </article>
            
            <article class="global" data-name="debugText">
               <h3>
                  debugText 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const debugText = `<html>
	<body>
	<title>Services</title>
	{{range .}}
	<hr>
	Service {{.Name}}
	<hr>
		<table>
		<th align=center>Method</th><th align=center>Calls</th>
		{{range .Method}}
			<tr>
			<td align=left font=fixed>{{.Name}}({{.Type.ArgType}}, {{.Type.ReplyType}}) error</td>
			<td align=center>{{.Type.NumCalls}}</td>
			</tr>
		{{end}}
		</table>
	{{end}}
	</body>
	</html>`</code></pre>
            </article>
            
            <article class="global" data-name="invalidRequest">
               <h3>
                  invalidRequest 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>A value sent as a placeholder for the server's response value when the server
receives an invalid request. It is never decoded by the client since the Response
contains an error when it is used.</p>
               
               <pre><code>var invalidRequest = struct{...}{...}</code></pre>
            </article>
            
            <article class="global" data-name="logRegisterError">
               <h3>
                  logRegisterError 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>logRegisterError specifies whether to log problems during method registration.
To debug registration, recompile the package with this set to true.</p>
               
               <pre><code>const logRegisterError = false</code></pre>
            </article>
            
            <article class="global" data-name="typeOfError">
               <h3>
                  typeOfError 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Precompute the reflect type for error.</p>
               
               <pre><code>var typeOfError = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="ServerError">
               <h3>
                  ServerError
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>ServerError represents an error that has been returned from
the remote side of the RPC connection.</p>
               
               <pre><code>type ServerError string</code></pre>
            </article>
            
            <article class="type" data-name="methodArray">
               <h3>
                  methodArray
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type methodArray []debugMethod</code></pre>
            </article>
            
            <article class="type" data-name="serviceArray">
               <h3>
                  serviceArray
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type serviceArray []debugService</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="ClientCodec">
               <h3>
                  ClientCodec
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A ClientCodec implements writing of RPC requests and
reading of RPC responses for the client side of an RPC session.
The client calls [ClientCodec.WriteRequest] to write a request to the connection
and calls [ClientCodec.ReadResponseHeader] and [ClientCodec.ReadResponseBody] in pairs
to read responses. The client calls [ClientCodec.Close] when finished with the
connection. ReadResponseBody may be called with a nil
argument to force the body of the response to be read and then
discarded.
See [NewClient]'s comment for information about concurrent access.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ClientCodec interface {
WriteRequest(*Request, any) error
ReadResponseHeader(*Response) error
ReadResponseBody(any) error
Close() error
}</code></pre>
            </article>
            
            <article class="interface" data-name="ServerCodec">
               <h3>
                  ServerCodec
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A ServerCodec implements reading of RPC requests and writing of
RPC responses for the server side of an RPC session.
The server calls [ServerCodec.ReadRequestHeader] and [ServerCodec.ReadRequestBody] in pairs
to read requests from the connection, and it calls [ServerCodec.WriteResponse] to
write a response back. The server calls [ServerCodec.Close] when finished with the
connection. ReadRequestBody may be called with a nil
argument to force the body of the request to be read and discarded.
See [NewClient]'s comment for information about concurrent access.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ServerCodec interface {
ReadRequestHeader(*Request) error
ReadRequestBody(any) error
WriteResponse(*Response, any) error
Close() error
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Call">
               <h3>
                  Call
                  <span class="badge">struct</span>
               </h3>
               
               <p>Call represents an active RPC.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Call struct {
ServiceMethod string
Args any
Reply any
Error error
Done chan *Call
}</code></pre>
            </article>
            
            <article class="struct" data-name="Client">
               <h3>
                  Client
                  <span class="badge">struct</span>
               </h3>
               
               <p>Client represents an RPC Client.
There may be multiple outstanding Calls associated
with a single Client, and a Client may be used by
multiple goroutines simultaneously.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Client struct {
codec ClientCodec
reqMutex sync.Mutex
request Request
mutex sync.Mutex
seq uint64
pending map[uint64]*Call
closing bool
shutdown bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="Request">
               <h3>
                  Request
                  <span class="badge">struct</span>
               </h3>
               
               <p>Request is a header written before every RPC call. It is used internally
but documented here as an aid to debugging, such as when analyzing
network traffic.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Request struct {
ServiceMethod string
Seq uint64
next *Request
}</code></pre>
            </article>
            
            <article class="struct" data-name="Response">
               <h3>
                  Response
                  <span class="badge">struct</span>
               </h3>
               
               <p>Response is a header written before every RPC return. It is used internally
but documented here as an aid to debugging, such as when analyzing
network traffic.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Response struct {
ServiceMethod string
Seq uint64
Error string
next *Response
}</code></pre>
            </article>
            
            <article class="struct" data-name="Server">
               <h3>
                  Server
                  <span class="badge">struct</span>
               </h3>
               
               <p>Server represents an RPC Server.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Server struct {
serviceMap sync.Map
reqLock sync.Mutex
freeReq *Request
respLock sync.Mutex
freeResp *Response
}</code></pre>
            </article>
            
            <article class="struct" data-name="debugHTTP">
               <h3>
                  debugHTTP
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type debugHTTP struct {
*Server
}</code></pre>
            </article>
            
            <article class="struct" data-name="debugMethod">
               <h3>
                  debugMethod
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type debugMethod struct {
Type *methodType
Name string
}</code></pre>
            </article>
            
            <article class="struct" data-name="debugService">
               <h3>
                  debugService
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type debugService struct {
Service *service
Name string
Method []debugMethod
}</code></pre>
            </article>
            
            <article class="struct" data-name="gobClientCodec">
               <h3>
                  gobClientCodec
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gobClientCodec struct {
rwc io.ReadWriteCloser
dec *gob.Decoder
enc *gob.Encoder
encBuf *bufio.Writer
}</code></pre>
            </article>
            
            <article class="struct" data-name="gobServerCodec">
               <h3>
                  gobServerCodec
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gobServerCodec struct {
rwc io.ReadWriteCloser
dec *gob.Decoder
enc *gob.Encoder
encBuf *bufio.Writer
closed bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="methodType">
               <h3>
                  methodType
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type methodType struct {
sync.Mutex
method reflect.Method
ArgType reflect.Type
ReplyType reflect.Type
numCalls uint
}</code></pre>
            </article>
            
            <article class="struct" data-name="service">
               <h3>
                  service
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type service struct {
name string
rcvr reflect.Value
typ reflect.Type
method map[string]*methodType
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Accept">
               <h3>
                  Accept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Accept accepts connections on the listener and serves requests
for each incoming connection. Accept blocks until the listener
returns a non-nil error. The caller typically invokes Accept in a
go statement.</p>
               
               <pre><code>func (server *Server) Accept(lis net.Listener)</code></pre>
            </article>
            
            <article class="function" data-name="Accept">
               <h3>
                  Accept 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Accept accepts connections on the listener and serves requests
to [DefaultServer] for each incoming connection.
Accept blocks; the caller typically invokes it in a go statement.</p>
               
               <pre><code>func Accept(lis net.Listener)</code></pre>
            </article>
            
            <article class="function" data-name="Call">
               <h3>
                  Call 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Call invokes the named function, waits for it to complete, and returns its error status.</p>
               
               <pre><code>func (client *Client) Call(serviceMethod string, args any, reply any) error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *gobClientCodec) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *gobServerCodec) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close calls the underlying codec's Close method. If the connection is already
shutting down, [ErrShutdown] is returned.</p>
               
               <pre><code>func (client *Client) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Dial">
               <h3>
                  Dial 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Dial connects to an RPC server at the specified network address.</p>
               
               <pre><code>func Dial(network string, address string) (*Client, error)</code></pre>
            </article>
            
            <article class="function" data-name="DialHTTP">
               <h3>
                  DialHTTP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DialHTTP connects to an HTTP RPC server at the specified network address
listening on the default HTTP RPC path.</p>
               
               <pre><code>func DialHTTP(network string, address string) (*Client, error)</code></pre>
            </article>
            
            <article class="function" data-name="DialHTTPPath">
               <h3>
                  DialHTTPPath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DialHTTPPath connects to an HTTP RPC server
at the specified network address and path.</p>
               
               <pre><code>func DialHTTPPath(network string, address string, path string) (*Client, error)</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e ServerError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Go">
               <h3>
                  Go 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Go invokes the function asynchronously. It returns the [Call] structure representing
the invocation. The done channel will signal when the call is complete by returning
the same Call object. If done is nil, Go will allocate a new channel.
If non-nil, done must be buffered or Go will deliberately crash.</p>
               
               <pre><code>func (client *Client) Go(serviceMethod string, args any, reply any, done chan *Call) *Call</code></pre>
            </article>
            
            <article class="function" data-name="HandleHTTP">
               <h3>
                  HandleHTTP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>HandleHTTP registers an HTTP handler for RPC messages on rpcPath,
and a debugging handler on debugPath.
It is still necessary to invoke [http.Serve](), typically in a go statement.</p>
               
               <pre><code>func (server *Server) HandleHTTP(rpcPath string, debugPath string)</code></pre>
            </article>
            
            <article class="function" data-name="HandleHTTP">
               <h3>
                  HandleHTTP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>HandleHTTP registers an HTTP handler for RPC messages to [DefaultServer]
on [DefaultRPCPath] and a debugging handler on [DefaultDebugPath].
It is still necessary to invoke [http.Serve](), typically in a go statement.</p>
               
               <pre><code>func HandleHTTP()</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s serviceArray) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m methodArray) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m methodArray) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s serviceArray) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="NewClient">
               <h3>
                  NewClient 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewClient returns a new [Client] to handle requests to the
set of services at the other end of the connection.
It adds a buffer to the write side of the connection so
the header and payload are sent as a unit.
The read and write halves of the connection are serialized independently,
so no interlocking is required. However each half may be accessed
concurrently so the implementation of conn should protect against
concurrent reads or concurrent writes.</p>
               
               <pre><code>func NewClient(conn io.ReadWriteCloser) *Client</code></pre>
            </article>
            
            <article class="function" data-name="NewClientWithCodec">
               <h3>
                  NewClientWithCodec 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewClientWithCodec is like [NewClient] but uses the specified
codec to encode requests and decode responses.</p>
               
               <pre><code>func NewClientWithCodec(codec ClientCodec) *Client</code></pre>
            </article>
            
            <article class="function" data-name="NewServer">
               <h3>
                  NewServer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewServer returns a new [Server].</p>
               
               <pre><code>func NewServer() *Server</code></pre>
            </article>
            
            <article class="function" data-name="NumCalls">
               <h3>
                  NumCalls 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m *methodType) NumCalls() (n uint)</code></pre>
            </article>
            
            <article class="function" data-name="ReadRequestBody">
               <h3>
                  ReadRequestBody 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *gobServerCodec) ReadRequestBody(body any) error</code></pre>
            </article>
            
            <article class="function" data-name="ReadRequestHeader">
               <h3>
                  ReadRequestHeader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *gobServerCodec) ReadRequestHeader(r *Request) error</code></pre>
            </article>
            
            <article class="function" data-name="ReadResponseBody">
               <h3>
                  ReadResponseBody 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *gobClientCodec) ReadResponseBody(body any) error</code></pre>
            </article>
            
            <article class="function" data-name="ReadResponseHeader">
               <h3>
                  ReadResponseHeader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *gobClientCodec) ReadResponseHeader(r *Response) error</code></pre>
            </article>
            
            <article class="function" data-name="Register">
               <h3>
                  Register 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Register publishes the receiver's methods in the [DefaultServer].</p>
               
               <pre><code>func Register(rcvr any) error</code></pre>
            </article>
            
            <article class="function" data-name="Register">
               <h3>
                  Register 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Register publishes in the server the set of methods of the
receiver value that satisfy the following conditions:
- exported method of exported type
- two arguments, both of exported type
- the second argument is a pointer
- one return value, of type error
It returns an error if the receiver is not an exported type or has
no suitable methods. It also logs the error using package log.
The client accesses each method using a string of the form "Type.Method",
where Type is the receiver's concrete type.</p>
               
               <pre><code>func (server *Server) Register(rcvr any) error</code></pre>
            </article>
            
            <article class="function" data-name="RegisterName">
               <h3>
                  RegisterName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RegisterName is like [Register] but uses the provided name for the type
instead of the receiver's concrete type.</p>
               
               <pre><code>func (server *Server) RegisterName(name string, rcvr any) error</code></pre>
            </article>
            
            <article class="function" data-name="RegisterName">
               <h3>
                  RegisterName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RegisterName is like [Register] but uses the provided name for the type
instead of the receiver's concrete type.</p>
               
               <pre><code>func RegisterName(name string, rcvr any) error</code></pre>
            </article>
            
            <article class="function" data-name="ServeCodec">
               <h3>
                  ServeCodec 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ServeCodec is like [ServeConn] but uses the specified codec to
decode requests and encode responses.</p>
               
               <pre><code>func ServeCodec(codec ServerCodec)</code></pre>
            </article>
            
            <article class="function" data-name="ServeCodec">
               <h3>
                  ServeCodec 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ServeCodec is like [ServeConn] but uses the specified codec to
decode requests and encode responses.</p>
               
               <pre><code>func (server *Server) ServeCodec(codec ServerCodec)</code></pre>
            </article>
            
            <article class="function" data-name="ServeConn">
               <h3>
                  ServeConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ServeConn runs the [DefaultServer] on a single connection.
ServeConn blocks, serving the connection until the client hangs up.
The caller typically invokes ServeConn in a go statement.
ServeConn uses the gob wire format (see package gob) on the
connection. To use an alternate codec, use [ServeCodec].
See [NewClient]'s comment for information about concurrent access.</p>
               
               <pre><code>func ServeConn(conn io.ReadWriteCloser)</code></pre>
            </article>
            
            <article class="function" data-name="ServeConn">
               <h3>
                  ServeConn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ServeConn runs the server on a single connection.
ServeConn blocks, serving the connection until the client hangs up.
The caller typically invokes ServeConn in a go statement.
ServeConn uses the gob wire format (see package gob) on the
connection. To use an alternate codec, use [ServeCodec].
See [NewClient]'s comment for information about concurrent access.</p>
               
               <pre><code>func (server *Server) ServeConn(conn io.ReadWriteCloser)</code></pre>
            </article>
            
            <article class="function" data-name="ServeHTTP">
               <h3>
                  ServeHTTP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ServeHTTP implements an [http.Handler] that answers RPC requests.</p>
               
               <pre><code>func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request)</code></pre>
            </article>
            
            <article class="function" data-name="ServeHTTP">
               <h3>
                  ServeHTTP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Runs at /debug/rpc</p>
               
               <pre><code>func (server debugHTTP) ServeHTTP(w http.ResponseWriter, req *http.Request)</code></pre>
            </article>
            
            <article class="function" data-name="ServeRequest">
               <h3>
                  ServeRequest 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ServeRequest is like [ServeCodec] but synchronously serves a single request.
It does not close the codec upon completion.</p>
               
               <pre><code>func ServeRequest(codec ServerCodec) error</code></pre>
            </article>
            
            <article class="function" data-name="ServeRequest">
               <h3>
                  ServeRequest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ServeRequest is like [ServeCodec] but synchronously serves a single request.
It does not close the codec upon completion.</p>
               
               <pre><code>func (server *Server) ServeRequest(codec ServerCodec) error</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s serviceArray) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m methodArray) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="WriteRequest">
               <h3>
                  WriteRequest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *gobClientCodec) WriteRequest(r *Request, body any) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteResponse">
               <h3>
                  WriteResponse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *gobServerCodec) WriteResponse(r *Response, body any) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="call">
               <h3>
                  call 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *service) call(server *Server, sending *sync.Mutex, wg *sync.WaitGroup, mtype *methodType, req *Request, argv reflect.Value, replyv reflect.Value, codec ServerCodec)</code></pre>
            </article>
            
            <article class="function" data-name="done">
               <h3>
                  done 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (call *Call) done()</code></pre>
            </article>
            
            <article class="function" data-name="freeRequest">
               <h3>
                  freeRequest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (server *Server) freeRequest(req *Request)</code></pre>
            </article>
            
            <article class="function" data-name="freeResponse">
               <h3>
                  freeResponse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (server *Server) freeResponse(resp *Response)</code></pre>
            </article>
            
            <article class="function" data-name="getRequest">
               <h3>
                  getRequest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (server *Server) getRequest() *Request</code></pre>
            </article>
            
            <article class="function" data-name="getResponse">
               <h3>
                  getResponse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (server *Server) getResponse() *Response</code></pre>
            </article>
            
            <article class="function" data-name="input">
               <h3>
                  input 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (client *Client) input()</code></pre>
            </article>
            
            <article class="function" data-name="isExportedOrBuiltinType">
               <h3>
                  isExportedOrBuiltinType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Is this type exported or a builtin?</p>
               
               <pre><code>func isExportedOrBuiltinType(t reflect.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="readRequest">
               <h3>
                  readRequest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (server *Server) readRequest(codec ServerCodec) (service *service, mtype *methodType, req *Request, argv reflect.Value, replyv reflect.Value, keepReading bool, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readRequestHeader">
               <h3>
                  readRequestHeader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (server *Server) readRequestHeader(codec ServerCodec) (svc *service, mtype *methodType, req *Request, keepReading bool, err error)</code></pre>
            </article>
            
            <article class="function" data-name="register">
               <h3>
                  register 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (server *Server) register(rcvr any, name string, useName bool) error</code></pre>
            </article>
            
            <article class="function" data-name="send">
               <h3>
                  send 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (client *Client) send(call *Call)</code></pre>
            </article>
            
            <article class="function" data-name="sendResponse">
               <h3>
                  sendResponse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (server *Server) sendResponse(sending *sync.Mutex, req *Request, reply any, codec ServerCodec, errmsg string)</code></pre>
            </article>
            
            <article class="function" data-name="suitableMethods">
               <h3>
                  suitableMethods 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>suitableMethods returns suitable Rpc methods of typ. It will log
errors if logErr is true.</p>
               
               <pre><code>func suitableMethods(typ reflect.Type, logErr bool) map[string]*methodType</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
