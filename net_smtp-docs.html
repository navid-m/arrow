<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - smtp</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                 
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>smtp</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"crypto/hmac"
"crypto/md5"
"errors"
"fmt"
"crypto/tls"
"encoding/base64"
"errors"
"fmt"
"io"
"net"
"net/textproto"
"strings"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="testHookStartTLS">
               <h3>
                  testHookStartTLS 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var testHookStartTLS func(*tls.Config)</code></pre>
            </article>
            
         </section>
           
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Auth">
               <h3>
                  Auth
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Auth is implemented by an SMTP authentication mechanism.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Auth interface {
Start(server *ServerInfo) (proto string, toServer []byte, err error)
Next(fromServer []byte, more bool) (toServer []byte, err error)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Client">
               <h3>
                  Client
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Client represents a client connection to an SMTP server.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Client struct {
Text *textproto.Conn
conn net.Conn
tls bool
serverName string
ext map[string]string
auth []string
localName string
didHello bool
helloError error
}</code></pre>
            </article>
            
            <article class="struct" data-name="ServerInfo">
               <h3>
                  ServerInfo
                  <span class="badge">struct</span>
               </h3>
               
               <p>ServerInfo records information about an SMTP server.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ServerInfo struct {
Name string
TLS bool
Auth []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="cramMD5Auth">
               <h3>
                  cramMD5Auth
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type cramMD5Auth struct {
username string
secret string
}</code></pre>
            </article>
            
            <article class="struct" data-name="dataCloser">
               <h3>
                  dataCloser
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dataCloser struct {
c *Client
io.WriteCloser
}</code></pre>
            </article>
            
            <article class="struct" data-name="plainAuth">
               <h3>
                  plainAuth
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type plainAuth struct {
identity string
username string
password string
host string
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Auth">
               <h3>
                  Auth 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Auth authenticates a client using the provided authentication mechanism.
A failed authentication closes the connection.
Only servers that advertise the AUTH extension support this function.</p>
               
               <pre><code>func (c *Client) Auth(a Auth) error</code></pre>
            </article>
            
            <article class="function" data-name="CRAMMD5Auth">
               <h3>
                  CRAMMD5Auth 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CRAMMD5Auth returns an [Auth] that implements the CRAM-MD5 authentication
mechanism as defined in RFC 2195.
The returned Auth uses the given username and secret to authenticate
to the server using the challenge-response mechanism.</p>
               
               <pre><code>func CRAMMD5Auth(username string, secret string) Auth</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close closes the connection.</p>
               
               <pre><code>func (c *Client) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dataCloser) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Data">
               <h3>
                  Data 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Data issues a DATA command to the server and returns a writer that
can be used to write the mail headers and body. The caller should
close the writer before calling any more methods on c. A call to
Data must be preceded by one or more calls to [Client.Rcpt].</p>
               
               <pre><code>func (c *Client) Data() (io.WriteCloser, error)</code></pre>
            </article>
            
            <article class="function" data-name="Dial">
               <h3>
                  Dial 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Dial returns a new [Client] connected to an SMTP server at addr.
The addr must include a port, as in "mail.example.com:smtp".</p>
               
               <pre><code>func Dial(addr string) (*Client, error)</code></pre>
            </article>
            
            <article class="function" data-name="Extension">
               <h3>
                  Extension 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Extension reports whether an extension is support by the server.
The extension name is case-insensitive. If the extension is supported,
Extension also returns a string that contains any parameters the
server specifies for the extension.</p>
               
               <pre><code>func (c *Client) Extension(ext string) (bool, string)</code></pre>
            </article>
            
            <article class="function" data-name="Hello">
               <h3>
                  Hello 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Hello sends a HELO or EHLO to the server as the given host name.
Calling this method is only necessary if the client needs control
over the host name used. The client will introduce itself as "localhost"
automatically otherwise. If Hello is called, it must be called before
any of the other methods.</p>
               
               <pre><code>func (c *Client) Hello(localName string) error</code></pre>
            </article>
            
            <article class="function" data-name="Mail">
               <h3>
                  Mail 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Mail issues a MAIL command to the server using the provided email address.
If the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME
parameter. If the server supports the SMTPUTF8 extension, Mail adds the
SMTPUTF8 parameter.
This initiates a mail transaction and is followed by one or more [Client.Rcpt] calls.</p>
               
               <pre><code>func (c *Client) Mail(from string) error</code></pre>
            </article>
            
            <article class="function" data-name="NewClient">
               <h3>
                  NewClient 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewClient returns a new [Client] using an existing connection and host as a
server name to be used when authenticating.</p>
               
               <pre><code>func NewClient(conn net.Conn, host string) (*Client, error)</code></pre>
            </article>
            
            <article class="function" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *plainAuth) Next(fromServer []byte, more bool) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *cramMD5Auth) Next(fromServer []byte, more bool) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Noop">
               <h3>
                  Noop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Noop sends the NOOP command to the server. It does nothing but check
that the connection to the server is okay.</p>
               
               <pre><code>func (c *Client) Noop() error</code></pre>
            </article>
            
            <article class="function" data-name="PlainAuth">
               <h3>
                  PlainAuth 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PlainAuth returns an [Auth] that implements the PLAIN authentication
mechanism as defined in RFC 4616. The returned Auth uses the given
username and password to authenticate to host and act as identity.
Usually identity should be the empty string, to act as username.
PlainAuth will only send the credentials if the connection is using TLS
or is connected to localhost. Otherwise authentication will fail with an
error, without sending the credentials.</p>
               
               <pre><code>func PlainAuth(identity string, username string, password string, host string) Auth</code></pre>
            </article>
            
            <article class="function" data-name="Quit">
               <h3>
                  Quit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Quit sends the QUIT command and closes the connection to the server.</p>
               
               <pre><code>func (c *Client) Quit() error</code></pre>
            </article>
            
            <article class="function" data-name="Rcpt">
               <h3>
                  Rcpt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Rcpt issues a RCPT command to the server using the provided email address.
A call to Rcpt must be preceded by a call to [Client.Mail] and may be followed by
a [Client.Data] call or another Rcpt call.</p>
               
               <pre><code>func (c *Client) Rcpt(to string) error</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reset sends the RSET command to the server, aborting the current mail
transaction.</p>
               
               <pre><code>func (c *Client) Reset() error</code></pre>
            </article>
            
            <article class="function" data-name="SendMail">
               <h3>
                  SendMail 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SendMail connects to the server at addr, switches to TLS if
possible, authenticates with the optional mechanism a if possible,
and then sends an email from address from, to addresses to, with
message msg.
The addr must include a port, as in "mail.example.com:smtp".
The addresses in the to parameter are the SMTP RCPT addresses.
The msg parameter should be an RFC 822-style email with headers
first, a blank line, and then the message body. The lines of msg
should be CRLF terminated. The msg headers should usually include
fields such as "From", "To", "Subject", and "Cc".  Sending "Bcc"
messages is accomplished by including an email address in the to
parameter but not including it in the msg headers.
The SendMail function and the net/smtp package are low-level
mechanisms and provide no support for DKIM signing, MIME
attachments (see the mime/multipart package), or other mail
functionality. Higher-level packages exist outside of the standard
library.</p>
               
               <pre><code>func SendMail(addr string, a Auth, from string, to []string, msg []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="Start">
               <h3>
                  Start 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *plainAuth) Start(server *ServerInfo) (string, []byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Start">
               <h3>
                  Start 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *cramMD5Auth) Start(server *ServerInfo) (string, []byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="StartTLS">
               <h3>
                  StartTLS 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>StartTLS sends the STARTTLS command and encrypts all further communication.
Only servers that advertise the STARTTLS extension support this function.</p>
               
               <pre><code>func (c *Client) StartTLS(config *tls.Config) error</code></pre>
            </article>
            
            <article class="function" data-name="TLSConnectionState">
               <h3>
                  TLSConnectionState 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TLSConnectionState returns the client's TLS connection state.
The return values are their zero values if [Client.StartTLS] did
not succeed.</p>
               
               <pre><code>func (c *Client) TLSConnectionState() (state tls.ConnectionState, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Verify">
               <h3>
                  Verify 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Verify checks the validity of an email address on the server.
If Verify returns nil, the address is valid. A non-nil return
does not necessarily indicate an invalid address. Many servers
will not verify addresses for security reasons.</p>
               
               <pre><code>func (c *Client) Verify(addr string) error</code></pre>
            </article>
            
            <article class="function" data-name="cmd">
               <h3>
                  cmd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>cmd is a convenience function that sends a command and returns the response</p>
               
               <pre><code>func (c *Client) cmd(expectCode int, format string, args ...any) (int, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="ehlo">
               <h3>
                  ehlo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ehlo sends the EHLO (extended hello) greeting to the server. It
should be the preferred greeting for servers that support it.</p>
               
               <pre><code>func (c *Client) ehlo() error</code></pre>
            </article>
            
            <article class="function" data-name="hello">
               <h3>
                  hello 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>hello runs a hello exchange if needed.</p>
               
               <pre><code>func (c *Client) hello() error</code></pre>
            </article>
            
            <article class="function" data-name="helo">
               <h3>
                  helo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>helo sends the HELO greeting to the server. It should be used only when the
server does not support ehlo.</p>
               
               <pre><code>func (c *Client) helo() error</code></pre>
            </article>
            
            <article class="function" data-name="isLocalhost">
               <h3>
                  isLocalhost 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isLocalhost(name string) bool</code></pre>
            </article>
            
            <article class="function" data-name="validateLine">
               <h3>
                  validateLine 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>validateLine checks to see if a line has CR or LF as per RFC 5321.</p>
               
               <pre><code>func validateLine(line string) error</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
