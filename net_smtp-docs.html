<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>smtp - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                 
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>smtp</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"crypto/hmac"
"crypto/md5"
"errors"
"fmt"
"crypto/tls"
"encoding/base64"
"errors"
"fmt"
"io"
"net"
"net/textproto"
"strings"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="testHookStartTLS" data-name="testHookStartTLS">
               <h3>
                  testHookStartTLS 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testHookStartTLS" class="anchor" title="Link to testHookStartTLS">#</a>
               </h3>
               
               <pre><code class="language-go">var testHookStartTLS func(*tls.Config)</code></pre>
            </article>
            
         </section>
           
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Auth" data-name="Auth">
               <h3>
                  Auth
                  <span class="badge interface-badge">interface</span>
                  <a href="#Auth" class="anchor" title="Link to Auth">#</a>
               </h3>
               
               <p>Auth is implemented by an SMTP authentication mechanism.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Auth interface {
Start(server *ServerInfo) (proto string, toServer []byte, err error)
Next(fromServer []byte, more bool) (toServer []byte, err error)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Client" data-name="Client">
               <h3>
                  Client
                  <span class="badge">struct</span>
                  <a href="#Client" class="anchor" title="Link to Client">#</a>
               </h3>
               
               <p>A Client represents a client connection to an SMTP server.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Client struct {
Text *textproto.Conn
conn net.Conn
tls bool
serverName string
ext map[string]string
auth []string
localName string
didHello bool
helloError error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ServerInfo" data-name="ServerInfo">
               <h3>
                  ServerInfo
                  <span class="badge">struct</span>
                  <a href="#ServerInfo" class="anchor" title="Link to ServerInfo">#</a>
               </h3>
               
               <p>ServerInfo records information about an SMTP server.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ServerInfo struct {
Name string
TLS bool
Auth []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cramMD5Auth" data-name="cramMD5Auth">
               <h3>
                  cramMD5Auth
                  <span class="badge">struct</span>
                  <a href="#cramMD5Auth" class="anchor" title="Link to cramMD5Auth">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type cramMD5Auth struct {
username string
secret string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dataCloser" data-name="dataCloser">
               <h3>
                  dataCloser
                  <span class="badge">struct</span>
                  <a href="#dataCloser" class="anchor" title="Link to dataCloser">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type dataCloser struct {
c *Client
io.WriteCloser
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="plainAuth" data-name="plainAuth">
               <h3>
                  plainAuth
                  <span class="badge">struct</span>
                  <a href="#plainAuth" class="anchor" title="Link to plainAuth">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type plainAuth struct {
identity string
username string
password string
host string
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Auth" data-name="Auth">
               <h3>
                  Auth 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Auth" class="anchor" title="Link to Auth">#</a>
               </h3>
               
               <p>Auth authenticates a client using the provided authentication mechanism.
A failed authentication closes the connection.
Only servers that advertise the AUTH extension support this function.</p>
               
               <pre><code class="language-go">func (c *Client) Auth(a Auth) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CRAMMD5Auth" data-name="CRAMMD5Auth">
               <h3>
                  CRAMMD5Auth 
                  <span class="badge">function</span>
                  
                  <a href="#CRAMMD5Auth" class="anchor" title="Link to CRAMMD5Auth">#</a>
               </h3>
               
               <p>CRAMMD5Auth returns an [Auth] that implements the CRAM-MD5 authentication
mechanism as defined in RFC 2195.
The returned Auth uses the given username and secret to authenticate
to the server using the challenge-response mechanism.</p>
               
               <pre><code class="language-go">func CRAMMD5Auth(username string, secret string) Auth</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close closes the connection.</p>
               
               <pre><code class="language-go">func (c *Client) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *dataCloser) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Data" data-name="Data">
               <h3>
                  Data 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Data" class="anchor" title="Link to Data">#</a>
               </h3>
               
               <p>Data issues a DATA command to the server and returns a writer that
can be used to write the mail headers and body. The caller should
close the writer before calling any more methods on c. A call to
Data must be preceded by one or more calls to [Client.Rcpt].</p>
               
               <pre><code class="language-go">func (c *Client) Data() (io.WriteCloser, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Dial" data-name="Dial">
               <h3>
                  Dial 
                  <span class="badge">function</span>
                  
                  <a href="#Dial" class="anchor" title="Link to Dial">#</a>
               </h3>
               
               <p>Dial returns a new [Client] connected to an SMTP server at addr.
The addr must include a port, as in "mail.example.com:smtp".</p>
               
               <pre><code class="language-go">func Dial(addr string) (*Client, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Extension" data-name="Extension">
               <h3>
                  Extension 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Extension" class="anchor" title="Link to Extension">#</a>
               </h3>
               
               <p>Extension reports whether an extension is support by the server.
The extension name is case-insensitive. If the extension is supported,
Extension also returns a string that contains any parameters the
server specifies for the extension.</p>
               
               <pre><code class="language-go">func (c *Client) Extension(ext string) (bool, string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Hello" data-name="Hello">
               <h3>
                  Hello 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Hello" class="anchor" title="Link to Hello">#</a>
               </h3>
               
               <p>Hello sends a HELO or EHLO to the server as the given host name.
Calling this method is only necessary if the client needs control
over the host name used. The client will introduce itself as "localhost"
automatically otherwise. If Hello is called, it must be called before
any of the other methods.</p>
               
               <pre><code class="language-go">func (c *Client) Hello(localName string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mail" data-name="Mail">
               <h3>
                  Mail 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mail" class="anchor" title="Link to Mail">#</a>
               </h3>
               
               <p>Mail issues a MAIL command to the server using the provided email address.
If the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME
parameter. If the server supports the SMTPUTF8 extension, Mail adds the
SMTPUTF8 parameter.
This initiates a mail transaction and is followed by one or more [Client.Rcpt] calls.</p>
               
               <pre><code class="language-go">func (c *Client) Mail(from string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewClient" data-name="NewClient">
               <h3>
                  NewClient 
                  <span class="badge">function</span>
                  
                  <a href="#NewClient" class="anchor" title="Link to NewClient">#</a>
               </h3>
               
               <p>NewClient returns a new [Client] using an existing connection and host as a
server name to be used when authenticating.</p>
               
               <pre><code class="language-go">func NewClient(conn net.Conn, host string) (*Client, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Next" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Next" class="anchor" title="Link to Next">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *plainAuth) Next(fromServer []byte, more bool) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Next" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Next" class="anchor" title="Link to Next">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *cramMD5Auth) Next(fromServer []byte, more bool) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Noop" data-name="Noop">
               <h3>
                  Noop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Noop" class="anchor" title="Link to Noop">#</a>
               </h3>
               
               <p>Noop sends the NOOP command to the server. It does nothing but check
that the connection to the server is okay.</p>
               
               <pre><code class="language-go">func (c *Client) Noop() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PlainAuth" data-name="PlainAuth">
               <h3>
                  PlainAuth 
                  <span class="badge">function</span>
                  
                  <a href="#PlainAuth" class="anchor" title="Link to PlainAuth">#</a>
               </h3>
               
               <p>PlainAuth returns an [Auth] that implements the PLAIN authentication
mechanism as defined in RFC 4616. The returned Auth uses the given
username and password to authenticate to host and act as identity.
Usually identity should be the empty string, to act as username.
PlainAuth will only send the credentials if the connection is using TLS
or is connected to localhost. Otherwise authentication will fail with an
error, without sending the credentials.</p>
               
               <pre><code class="language-go">func PlainAuth(identity string, username string, password string, host string) Auth</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Quit" data-name="Quit">
               <h3>
                  Quit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Quit" class="anchor" title="Link to Quit">#</a>
               </h3>
               
               <p>Quit sends the QUIT command and closes the connection to the server.</p>
               
               <pre><code class="language-go">func (c *Client) Quit() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Rcpt" data-name="Rcpt">
               <h3>
                  Rcpt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Rcpt" class="anchor" title="Link to Rcpt">#</a>
               </h3>
               
               <p>Rcpt issues a RCPT command to the server using the provided email address.
A call to Rcpt must be preceded by a call to [Client.Mail] and may be followed by
a [Client.Data] call or another Rcpt call.</p>
               
               <pre><code class="language-go">func (c *Client) Rcpt(to string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset sends the RSET command to the server, aborting the current mail
transaction.</p>
               
               <pre><code class="language-go">func (c *Client) Reset() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SendMail" data-name="SendMail">
               <h3>
                  SendMail 
                  <span class="badge">function</span>
                  
                  <a href="#SendMail" class="anchor" title="Link to SendMail">#</a>
               </h3>
               
               <p>SendMail connects to the server at addr, switches to TLS if
possible, authenticates with the optional mechanism a if possible,
and then sends an email from address from, to addresses to, with
message msg.
The addr must include a port, as in "mail.example.com:smtp".
The addresses in the to parameter are the SMTP RCPT addresses.
The msg parameter should be an RFC 822-style email with headers
first, a blank line, and then the message body. The lines of msg
should be CRLF terminated. The msg headers should usually include
fields such as "From", "To", "Subject", and "Cc".  Sending "Bcc"
messages is accomplished by including an email address in the to
parameter but not including it in the msg headers.
The SendMail function and the net/smtp package are low-level
mechanisms and provide no support for DKIM signing, MIME
attachments (see the mime/multipart package), or other mail
functionality. Higher-level packages exist outside of the standard
library.</p>
               
               <pre><code class="language-go">func SendMail(addr string, a Auth, from string, to []string, msg []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Start" data-name="Start">
               <h3>
                  Start 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Start" class="anchor" title="Link to Start">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *plainAuth) Start(server *ServerInfo) (string, []byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Start" data-name="Start">
               <h3>
                  Start 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Start" class="anchor" title="Link to Start">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *cramMD5Auth) Start(server *ServerInfo) (string, []byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StartTLS" data-name="StartTLS">
               <h3>
                  StartTLS 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StartTLS" class="anchor" title="Link to StartTLS">#</a>
               </h3>
               
               <p>StartTLS sends the STARTTLS command and encrypts all further communication.
Only servers that advertise the STARTTLS extension support this function.</p>
               
               <pre><code class="language-go">func (c *Client) StartTLS(config *tls.Config) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TLSConnectionState" data-name="TLSConnectionState">
               <h3>
                  TLSConnectionState 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TLSConnectionState" class="anchor" title="Link to TLSConnectionState">#</a>
               </h3>
               
               <p>TLSConnectionState returns the client's TLS connection state.
The return values are their zero values if [Client.StartTLS] did
not succeed.</p>
               
               <pre><code class="language-go">func (c *Client) TLSConnectionState() (state tls.ConnectionState, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Verify" data-name="Verify">
               <h3>
                  Verify 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Verify" class="anchor" title="Link to Verify">#</a>
               </h3>
               
               <p>Verify checks the validity of an email address on the server.
If Verify returns nil, the address is valid. A non-nil return
does not necessarily indicate an invalid address. Many servers
will not verify addresses for security reasons.</p>
               
               <pre><code class="language-go">func (c *Client) Verify(addr string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cmd" data-name="cmd">
               <h3>
                  cmd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cmd" class="anchor" title="Link to cmd">#</a>
               </h3>
               
               <p>cmd is a convenience function that sends a command and returns the response</p>
               
               <pre><code class="language-go">func (c *Client) cmd(expectCode int, format string, args ...any) (int, string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ehlo" data-name="ehlo">
               <h3>
                  ehlo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ehlo" class="anchor" title="Link to ehlo">#</a>
               </h3>
               
               <p>ehlo sends the EHLO (extended hello) greeting to the server. It
should be the preferred greeting for servers that support it.</p>
               
               <pre><code class="language-go">func (c *Client) ehlo() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hello" data-name="hello">
               <h3>
                  hello 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hello" class="anchor" title="Link to hello">#</a>
               </h3>
               
               <p>hello runs a hello exchange if needed.</p>
               
               <pre><code class="language-go">func (c *Client) hello() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="helo" data-name="helo">
               <h3>
                  helo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#helo" class="anchor" title="Link to helo">#</a>
               </h3>
               
               <p>helo sends the HELO greeting to the server. It should be used only when the
server does not support ehlo.</p>
               
               <pre><code class="language-go">func (c *Client) helo() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isLocalhost" data-name="isLocalhost">
               <h3>
                  isLocalhost 
                  <span class="badge">function</span>
                  
                  <a href="#isLocalhost" class="anchor" title="Link to isLocalhost">#</a>
               </h3>
               
               <pre><code class="language-go">func isLocalhost(name string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validateLine" data-name="validateLine">
               <h3>
                  validateLine 
                  <span class="badge">function</span>
                  
                  <a href="#validateLine" class="anchor" title="Link to validateLine">#</a>
               </h3>
               
               <p>validateLine checks to see if a line has CR or LF as per RFC 5321.</p>
               
               <pre><code class="language-go">func validateLine(line string) error</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>