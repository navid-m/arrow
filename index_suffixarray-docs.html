<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - suffixarray</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>suffixarray</code>
         </h1>
         <hr />
         
         <article class="global" data-name="maxData32">
            <h2>maxData32</h2>
            <hr />
            
            <p>Can change for testing</p>
            
            <pre><code>maxData32 int</code></pre>
         </article>
         
         <article class="global" data-name="realMaxData32">
            <h2>realMaxData32</h2>
            <hr />
            
            <pre><code>realMaxData32</code></pre>
         </article>
         
         <article class="global" data-name="errTooBig">
            <h2>errTooBig</h2>
            <hr />
            
            <pre><code>errTooBig</code></pre>
         </article>
         
         <article class="global" data-name="bufSize">
            <h2>bufSize</h2>
            <hr />
            
            <pre><code>bufSize</code></pre>
         </article>
         
         <article class="global" data-name="testCases">
            <h2>testCases</h2>
            <hr />
            
            <pre><code>testCases</code></pre>
         </article>
         
         <article class="global" data-name="benchdata">
            <h2>benchdata</h2>
            <hr />
            
            <pre><code>benchdata</code></pre>
         </article>
         
         <article class="global" data-name="benchrand">
            <h2>benchrand</h2>
            <hr />
            
            <pre><code>benchrand</code></pre>
         </article>
          
         <article class="struct" data-name="Index">
            <h2>type Index struct</h2>
            <hr />
            
            <p>Index implements a suffix array for fast substring search.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">data []byte
sa ints</code></pre>
         </article>
         
         <article class="struct" data-name="ints">
            <h2>type ints struct</h2>
            <hr />
            
            <p>An ints is either an []int32 or an []int64.
That is, one of them is empty, and one is the real data.
The int64 form is used when len(data) > maxData32</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">int32 []int32
int64 []int64</code></pre>
         </article>
         
         <article class="struct" data-name="testCase">
            <h2>type testCase struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
source string
patterns []string</code></pre>
         </article>
          
         <article class="function" data-name="text_32">
            <h2>text_32</h2>
            <hr />
            
            <p>text_32 returns the suffix array for the input text.
It requires that len(text) fit in an int32
and that the caller zero sa.</p>
            
            <pre><code>func text_32(text []byte, sa []int32)</code></pre>
         </article>
         
         <article class="function" data-name="sais_8_32">
            <h2>sais_8_32</h2>
            <hr />
            
            <p>sais_8_32 computes the suffix array of text.
The text must contain only values in [0, textMax).
The suffix array is stored in sa, which the caller
must ensure is already zeroed.
The caller must also provide temporary space tmp
with len(tmp) ≥ textMax. If len(tmp) ≥ 2*textMax
then the algorithm runs a little faster.
If sais_8_32 modifies tmp, it sets tmp[0] = -1 on return.</p>
            
            <pre><code>func sais_8_32(text []byte, textMax int, sa []int32, tmp []int32)</code></pre>
         </article>
         
         <article class="function" data-name="freq_8_32">
            <h2>freq_8_32</h2>
            <hr />
            
            <p>freq_8_32 returns the character frequencies
for text, as a slice indexed by character value.
If freq is nil, freq_8_32 uses and returns bucket.
If freq is non-nil, freq_8_32 assumes that freq[0] >= 0
means the frequencies are already computed.
If the frequency data is overwritten or uninitialized,
the caller must set freq[0] = -1 to force recomputation
the next time it is needed.</p>
            
            <pre><code>func freq_8_32(text []byte, freq []int32, bucket []int32) []int32</code></pre>
         </article>
         
         <article class="function" data-name="bucketMin_8_32">
            <h2>bucketMin_8_32</h2>
            <hr />
            
            <p>bucketMin_8_32 stores into bucket[c] the minimum index
in the bucket for character c in a bucket-sort of text.</p>
            
            <pre><code>func bucketMin_8_32(text []byte, freq []int32, bucket []int32)</code></pre>
         </article>
         
         <article class="function" data-name="bucketMax_8_32">
            <h2>bucketMax_8_32</h2>
            <hr />
            
            <p>bucketMax_8_32 stores into bucket[c] the maximum index
in the bucket for character c in a bucket-sort of text.
The bucket indexes for c are [min, max).
That is, max is one past the final index in that bucket.</p>
            
            <pre><code>func bucketMax_8_32(text []byte, freq []int32, bucket []int32)</code></pre>
         </article>
         
         <article class="function" data-name="placeLMS_8_32">
            <h2>placeLMS_8_32</h2>
            <hr />
            
            <p>placeLMS_8_32 places into sa the indexes of the
final characters of the LMS substrings of text,
sorted into the rightmost ends of their correct buckets
in the suffix array.

The imaginary sentinel character at the end of the text
is the final character of the final LMS substring, but there
is no bucket for the imaginary sentinel character,
which has a smaller value than any real character.
The caller must therefore pretend that sa[-1] == len(text).

The text indexes of LMS-substring characters are always ≥ 1
(the first LMS-substring must be preceded by one or more L-type
characters that are not part of any LMS-substring),
so using 0 as a “not present” suffix array entry is safe,
both in this function and in most later functions
(until induceL_8_32 below).</p>
            
            <pre><code>func placeLMS_8_32(text []byte, sa []int32, freq []int32, bucket []int32) int</code></pre>
         </article>
         
         <article class="function" data-name="induceSubL_8_32">
            <h2>induceSubL_8_32</h2>
            <hr />
            
            <p>induceSubL_8_32 inserts the L-type text indexes of LMS-substrings
into sa, assuming that the final characters of the LMS-substrings
are already inserted into sa, sorted by final character, and at the
right (not left) end of the corresponding character bucket.
Each LMS-substring has the form (as a regexp) /S+L+S/:
one or more S-type, one or more L-type, final S-type.
induceSubL_8_32 leaves behind only the leftmost L-type text
index for each LMS-substring. That is, it removes the final S-type
indexes that are present on entry, and it inserts but then removes
the interior L-type indexes too.
(Only the leftmost L-type index is needed by induceSubS_8_32.)</p>
            
            <pre><code>func induceSubL_8_32(text []byte, sa []int32, freq []int32, bucket []int32)</code></pre>
         </article>
         
         <article class="function" data-name="induceSubS_8_32">
            <h2>induceSubS_8_32</h2>
            <hr />
            
            <p>induceSubS_8_32 inserts the S-type text indexes of LMS-substrings
into sa, assuming that the leftmost L-type text indexes are already
inserted into sa, sorted by LMS-substring suffix, and at the
left end of the corresponding character bucket.
Each LMS-substring has the form (as a regexp) /S+L+S/:
one or more S-type, one or more L-type, final S-type.
induceSubS_8_32 leaves behind only the leftmost S-type text
index for each LMS-substring, in sorted order, at the right end of sa.
That is, it removes the L-type indexes that are present on entry,
and it inserts but then removes the interior S-type indexes too,
leaving the LMS-substring start indexes packed into sa[len(sa)-numLMS:].
(Only the LMS-substring start indexes are processed by the recursion.)</p>
            
            <pre><code>func induceSubS_8_32(text []byte, sa []int32, freq []int32, bucket []int32)</code></pre>
         </article>
         
         <article class="function" data-name="length_8_32">
            <h2>length_8_32</h2>
            <hr />
            
            <p>length_8_32 computes and records the length of each LMS-substring in text.
The length of the LMS-substring at index j is stored at sa[j/2],
avoiding the LMS-substring indexes already stored in the top half of sa.
(If index j is an LMS-substring start, then index j-1 is type L and cannot be.)
There are two exceptions, made for optimizations in name_8_32 below.

First, the final LMS-substring is recorded as having length 0, which is otherwise
impossible, instead of giving it a length that includes the implicit sentinel.
This ensures the final LMS-substring has length unequal to all others
and therefore can be detected as different without text comparison
(it is unequal because it is the only one that ends in the implicit sentinel,
and the text comparison would be problematic since the implicit sentinel
is not actually present at text[len(text)]).

Second, to avoid text comparison entirely, if an LMS-substring is very short,
sa[j/2] records its actual text instead of its length, so that if two such
substrings have matching “length,” the text need not be read at all.
The definition of “very short” is that the text bytes must pack into a uint32,
and the unsigned encoding e must be ≥ len(text), so that it can be
distinguished from a valid length.</p>
            
            <pre><code>func length_8_32(text []byte, sa []int32, numLMS int)</code></pre>
         </article>
         
         <article class="function" data-name="assignID_8_32">
            <h2>assignID_8_32</h2>
            <hr />
            
            <p>assignID_8_32 assigns a dense ID numbering to the
set of LMS-substrings respecting string ordering and equality,
returning the maximum assigned ID.
For example given the input "ababab", the LMS-substrings
are "aba", "aba", and "ab", renumbered as 2 2 1.
sa[len(sa)-numLMS:] holds the LMS-substring indexes
sorted in string order, so to assign numbers we can
consider each in turn, removing adjacent duplicates.
The new ID for the LMS-substring at index j is written to sa[j/2],
overwriting the length previously stored there (by length_8_32 above).</p>
            
            <pre><code>func assignID_8_32(text []byte, sa []int32, numLMS int) int</code></pre>
         </article>
         
         <article class="function" data-name="map_32">
            <h2>map_32</h2>
            <hr />
            
            <p>map_32 maps the LMS-substrings in text to their new IDs,
producing the subproblem for the recursion.
The mapping itself was mostly applied by assignID_8_32:
sa[i] is either 0, the ID for the LMS-substring at index 2*i,
or the ID for the LMS-substring at index 2*i+1.
To produce the subproblem we need only remove the zeros
and change ID into ID-1 (our IDs start at 1, but text chars start at 0).

map_32 packs the result, which is the input to the recursion,
into the top of sa, so that the recursion result can be stored
in the bottom of sa, which sets up for expand_8_32 well.</p>
            
            <pre><code>func map_32(sa []int32, numLMS int)</code></pre>
         </article>
         
         <article class="function" data-name="recurse_32">
            <h2>recurse_32</h2>
            <hr />
            
            <p>recurse_32 calls sais_32 recursively to solve the subproblem we've built.
The subproblem is at the right end of sa, the suffix array result will be
written at the left end of sa, and the middle of sa is available for use as
temporary frequency and bucket storage.</p>
            
            <pre><code>func recurse_32(sa []int32, oldTmp []int32, numLMS int, maxID int)</code></pre>
         </article>
         
         <article class="function" data-name="unmap_8_32">
            <h2>unmap_8_32</h2>
            <hr />
            
            <p>unmap_8_32 unmaps the subproblem back to the original.
sa[:numLMS] is the LMS-substring numbers, which don't matter much anymore.
sa[len(sa)-numLMS:] is the sorted list of those LMS-substring numbers.
The key part is that if the list says K that means the K'th substring.
We can replace sa[:numLMS] with the indexes of the LMS-substrings.
Then if the list says K it really means sa[K].
Having mapped the list back to LMS-substring indexes,
we can place those into the right buckets.</p>
            
            <pre><code>func unmap_8_32(text []byte, sa []int32, numLMS int)</code></pre>
         </article>
         
         <article class="function" data-name="expand_8_32">
            <h2>expand_8_32</h2>
            <hr />
            
            <p>expand_8_32 distributes the compacted, sorted LMS-suffix indexes
from sa[:numLMS] into the tops of the appropriate buckets in sa,
preserving the sorted order and making room for the L-type indexes
to be slotted into the sorted sequence by induceL_8_32.</p>
            
            <pre><code>func expand_8_32(text []byte, freq []int32, bucket []int32, sa []int32, numLMS int)</code></pre>
         </article>
         
         <article class="function" data-name="induceL_8_32">
            <h2>induceL_8_32</h2>
            <hr />
            
            <p>induceL_8_32 inserts L-type text indexes into sa,
assuming that the leftmost S-type indexes are inserted
into sa, in sorted order, in the right bucket halves.
It leaves all the L-type indexes in sa, but the
leftmost L-type indexes are negated, to mark them
for processing by induceS_8_32.</p>
            
            <pre><code>func induceL_8_32(text []byte, sa []int32, freq []int32, bucket []int32)</code></pre>
         </article>
         
         <article class="function" data-name="induceS_8_32">
            <h2>induceS_8_32</h2>
            <hr />
            
            <pre><code>func induceS_8_32(text []byte, sa []int32, freq []int32, bucket []int32)</code></pre>
         </article>
         
         <article class="function" data-name="text_64">
            <h2>text_64</h2>
            <hr />
            
            <pre><code>func text_64(text []byte, sa []int64)</code></pre>
         </article>
         
         <article class="function" data-name="sais_8_64">
            <h2>sais_8_64</h2>
            <hr />
            
            <pre><code>func sais_8_64(text []byte, textMax int, sa []int64, tmp []int64)</code></pre>
         </article>
         
         <article class="function" data-name="sais_32">
            <h2>sais_32</h2>
            <hr />
            
            <pre><code>func sais_32(text []int32, textMax int, sa []int32, tmp []int32)</code></pre>
         </article>
         
         <article class="function" data-name="sais_64">
            <h2>sais_64</h2>
            <hr />
            
            <pre><code>func sais_64(text []int64, textMax int, sa []int64, tmp []int64)</code></pre>
         </article>
         
         <article class="function" data-name="freq_8_64">
            <h2>freq_8_64</h2>
            <hr />
            
            <pre><code>func freq_8_64(text []byte, freq []int64, bucket []int64) []int64</code></pre>
         </article>
         
         <article class="function" data-name="freq_32">
            <h2>freq_32</h2>
            <hr />
            
            <pre><code>func freq_32(text []int32, freq []int32, bucket []int32) []int32</code></pre>
         </article>
         
         <article class="function" data-name="freq_64">
            <h2>freq_64</h2>
            <hr />
            
            <pre><code>func freq_64(text []int64, freq []int64, bucket []int64) []int64</code></pre>
         </article>
         
         <article class="function" data-name="bucketMin_8_64">
            <h2>bucketMin_8_64</h2>
            <hr />
            
            <pre><code>func bucketMin_8_64(text []byte, freq []int64, bucket []int64)</code></pre>
         </article>
         
         <article class="function" data-name="bucketMin_32">
            <h2>bucketMin_32</h2>
            <hr />
            
            <pre><code>func bucketMin_32(text []int32, freq []int32, bucket []int32)</code></pre>
         </article>
         
         <article class="function" data-name="bucketMin_64">
            <h2>bucketMin_64</h2>
            <hr />
            
            <pre><code>func bucketMin_64(text []int64, freq []int64, bucket []int64)</code></pre>
         </article>
         
         <article class="function" data-name="bucketMax_8_64">
            <h2>bucketMax_8_64</h2>
            <hr />
            
            <pre><code>func bucketMax_8_64(text []byte, freq []int64, bucket []int64)</code></pre>
         </article>
         
         <article class="function" data-name="bucketMax_32">
            <h2>bucketMax_32</h2>
            <hr />
            
            <pre><code>func bucketMax_32(text []int32, freq []int32, bucket []int32)</code></pre>
         </article>
         
         <article class="function" data-name="bucketMax_64">
            <h2>bucketMax_64</h2>
            <hr />
            
            <pre><code>func bucketMax_64(text []int64, freq []int64, bucket []int64)</code></pre>
         </article>
         
         <article class="function" data-name="placeLMS_8_64">
            <h2>placeLMS_8_64</h2>
            <hr />
            
            <pre><code>func placeLMS_8_64(text []byte, sa []int64, freq []int64, bucket []int64) int</code></pre>
         </article>
         
         <article class="function" data-name="placeLMS_32">
            <h2>placeLMS_32</h2>
            <hr />
            
            <pre><code>func placeLMS_32(text []int32, sa []int32, freq []int32, bucket []int32) int</code></pre>
         </article>
         
         <article class="function" data-name="placeLMS_64">
            <h2>placeLMS_64</h2>
            <hr />
            
            <pre><code>func placeLMS_64(text []int64, sa []int64, freq []int64, bucket []int64) int</code></pre>
         </article>
         
         <article class="function" data-name="induceSubL_8_64">
            <h2>induceSubL_8_64</h2>
            <hr />
            
            <pre><code>func induceSubL_8_64(text []byte, sa []int64, freq []int64, bucket []int64)</code></pre>
         </article>
         
         <article class="function" data-name="induceSubL_32">
            <h2>induceSubL_32</h2>
            <hr />
            
            <pre><code>func induceSubL_32(text []int32, sa []int32, freq []int32, bucket []int32)</code></pre>
         </article>
         
         <article class="function" data-name="induceSubL_64">
            <h2>induceSubL_64</h2>
            <hr />
            
            <pre><code>func induceSubL_64(text []int64, sa []int64, freq []int64, bucket []int64)</code></pre>
         </article>
         
         <article class="function" data-name="induceSubS_8_64">
            <h2>induceSubS_8_64</h2>
            <hr />
            
            <pre><code>func induceSubS_8_64(text []byte, sa []int64, freq []int64, bucket []int64)</code></pre>
         </article>
         
         <article class="function" data-name="induceSubS_32">
            <h2>induceSubS_32</h2>
            <hr />
            
            <pre><code>func induceSubS_32(text []int32, sa []int32, freq []int32, bucket []int32)</code></pre>
         </article>
         
         <article class="function" data-name="induceSubS_64">
            <h2>induceSubS_64</h2>
            <hr />
            
            <pre><code>func induceSubS_64(text []int64, sa []int64, freq []int64, bucket []int64)</code></pre>
         </article>
         
         <article class="function" data-name="length_8_64">
            <h2>length_8_64</h2>
            <hr />
            
            <pre><code>func length_8_64(text []byte, sa []int64, numLMS int)</code></pre>
         </article>
         
         <article class="function" data-name="length_32">
            <h2>length_32</h2>
            <hr />
            
            <pre><code>func length_32(text []int32, sa []int32, numLMS int)</code></pre>
         </article>
         
         <article class="function" data-name="length_64">
            <h2>length_64</h2>
            <hr />
            
            <pre><code>func length_64(text []int64, sa []int64, numLMS int)</code></pre>
         </article>
         
         <article class="function" data-name="assignID_8_64">
            <h2>assignID_8_64</h2>
            <hr />
            
            <pre><code>func assignID_8_64(text []byte, sa []int64, numLMS int) int</code></pre>
         </article>
         
         <article class="function" data-name="assignID_32">
            <h2>assignID_32</h2>
            <hr />
            
            <pre><code>func assignID_32(text []int32, sa []int32, numLMS int) int</code></pre>
         </article>
         
         <article class="function" data-name="assignID_64">
            <h2>assignID_64</h2>
            <hr />
            
            <pre><code>func assignID_64(text []int64, sa []int64, numLMS int) int</code></pre>
         </article>
         
         <article class="function" data-name="map_64">
            <h2>map_64</h2>
            <hr />
            
            <pre><code>func map_64(sa []int64, numLMS int)</code></pre>
         </article>
         
         <article class="function" data-name="recurse_64">
            <h2>recurse_64</h2>
            <hr />
            
            <pre><code>func recurse_64(sa []int64, oldTmp []int64, numLMS int, maxID int)</code></pre>
         </article>
         
         <article class="function" data-name="unmap_8_64">
            <h2>unmap_8_64</h2>
            <hr />
            
            <pre><code>func unmap_8_64(text []byte, sa []int64, numLMS int)</code></pre>
         </article>
         
         <article class="function" data-name="unmap_32">
            <h2>unmap_32</h2>
            <hr />
            
            <pre><code>func unmap_32(text []int32, sa []int32, numLMS int)</code></pre>
         </article>
         
         <article class="function" data-name="unmap_64">
            <h2>unmap_64</h2>
            <hr />
            
            <pre><code>func unmap_64(text []int64, sa []int64, numLMS int)</code></pre>
         </article>
         
         <article class="function" data-name="expand_8_64">
            <h2>expand_8_64</h2>
            <hr />
            
            <pre><code>func expand_8_64(text []byte, freq []int64, bucket []int64, sa []int64, numLMS int)</code></pre>
         </article>
         
         <article class="function" data-name="expand_32">
            <h2>expand_32</h2>
            <hr />
            
            <pre><code>func expand_32(text []int32, freq []int32, bucket []int32, sa []int32, numLMS int)</code></pre>
         </article>
         
         <article class="function" data-name="expand_64">
            <h2>expand_64</h2>
            <hr />
            
            <pre><code>func expand_64(text []int64, freq []int64, bucket []int64, sa []int64, numLMS int)</code></pre>
         </article>
         
         <article class="function" data-name="induceL_8_64">
            <h2>induceL_8_64</h2>
            <hr />
            
            <pre><code>func induceL_8_64(text []byte, sa []int64, freq []int64, bucket []int64)</code></pre>
         </article>
         
         <article class="function" data-name="induceL_32">
            <h2>induceL_32</h2>
            <hr />
            
            <pre><code>func induceL_32(text []int32, sa []int32, freq []int32, bucket []int32)</code></pre>
         </article>
         
         <article class="function" data-name="induceL_64">
            <h2>induceL_64</h2>
            <hr />
            
            <pre><code>func induceL_64(text []int64, sa []int64, freq []int64, bucket []int64)</code></pre>
         </article>
         
         <article class="function" data-name="induceS_8_64">
            <h2>induceS_8_64</h2>
            <hr />
            
            <pre><code>func induceS_8_64(text []byte, sa []int64, freq []int64, bucket []int64)</code></pre>
         </article>
         
         <article class="function" data-name="induceS_32">
            <h2>induceS_32</h2>
            <hr />
            
            <pre><code>func induceS_32(text []int32, sa []int32, freq []int32, bucket []int32)</code></pre>
         </article>
         
         <article class="function" data-name="induceS_64">
            <h2>induceS_64</h2>
            <hr />
            
            <pre><code>func induceS_64(text []int64, sa []int64, freq []int64, bucket []int64)</code></pre>
         </article>
         
         <article class="function" data-name="len">
            <h2>len</h2>
            <hr />
            
            <pre><code>func len() int</code></pre>
         </article>
         
         <article class="function" data-name="get">
            <h2>get</h2>
            <hr />
            
            <pre><code>func get(i int) int64</code></pre>
         </article>
         
         <article class="function" data-name="set">
            <h2>set</h2>
            <hr />
            
            <pre><code>func set(i int, v int64)</code></pre>
         </article>
         
         <article class="function" data-name="slice">
            <h2>slice</h2>
            <hr />
            
            <pre><code>func slice(i int, j int) ints</code></pre>
         </article>
         
         <article class="function" data-name="New">
            <h2>New</h2>
            <hr />
            
            <p>New creates a new [Index] for data.
[Index] creation time is O(N) for N = len(data).</p>
            
            <pre><code>func New(data []byte) *Index</code></pre>
         </article>
         
         <article class="function" data-name="writeInt">
            <h2>writeInt</h2>
            <hr />
            
            <p>writeInt writes an int x to w using buf to buffer the write.</p>
            
            <pre><code>func writeInt(w io.Writer, buf []byte, x int) error</code></pre>
         </article>
         
         <article class="function" data-name="readInt">
            <h2>readInt</h2>
            <hr />
            
            <p>readInt reads an int x from r using buf to buffer the read and returns x.</p>
            
            <pre><code>func readInt(r io.Reader, buf []byte) (int64, error)</code></pre>
         </article>
         
         <article class="function" data-name="writeSlice">
            <h2>writeSlice</h2>
            <hr />
            
            <p>writeSlice writes data[:n] to w and returns n.
It uses buf to buffer the write.</p>
            
            <pre><code>func writeSlice(w io.Writer, buf []byte, data ints) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readSlice">
            <h2>readSlice</h2>
            <hr />
            
            <p>readSlice reads data[:n] from r and returns n.
It uses buf to buffer the read.</p>
            
            <pre><code>func readSlice(r io.Reader, buf []byte, data ints) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <p>Read reads the index from r into x; x must not be nil.</p>
            
            <pre><code>func Read(r io.Reader) error</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write writes the index x to w.</p>
            
            <pre><code>func Write(w io.Writer) error</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <p>Bytes returns the data over which the index was created.
It must not be modified.</p>
            
            <pre><code>func Bytes() []byte</code></pre>
         </article>
         
         <article class="function" data-name="at">
            <h2>at</h2>
            <hr />
            
            <pre><code>func at(i int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="lookupAll">
            <h2>lookupAll</h2>
            <hr />
            
            <p>lookupAll returns a slice into the matching region of the index.
The runtime is O(log(N)*len(s)).</p>
            
            <pre><code>func lookupAll(s []byte) ints</code></pre>
         </article>
         
         <article class="function" data-name="Lookup">
            <h2>Lookup</h2>
            <hr />
            
            <p>Lookup returns an unsorted list of at most n indices where the byte string s
occurs in the indexed data. If n < 0, all occurrences are returned.
The result is nil if s is empty, s is not found, or n == 0.
Lookup time is O(log(N)*len(s) + len(result)) where N is the
size of the indexed data.</p>
            
            <pre><code>func Lookup(s []byte, n int) result []int</code></pre>
         </article>
         
         <article class="function" data-name="FindAllIndex">
            <h2>FindAllIndex</h2>
            <hr />
            
            <p>FindAllIndex returns a sorted list of non-overlapping matches of the
regular expression r, where a match is a pair of indices specifying
the matched slice of x.Bytes(). If n < 0, all matches are returned
in successive order. Otherwise, at most n matches are returned and
they may not be successive. The result is nil if there are no matches,
or if n == 0.</p>
            
            <pre><code>func FindAllIndex(r *regexp.Regexp, n int) result [][]int</code></pre>
         </article>
         
         <article class="function" data-name="find">
            <h2>find</h2>
            <hr />
            
            <p>find all occurrences of s in source; report at most n occurrences</p>
            
            <pre><code>func find(src string, s string, n int) []int</code></pre>
         </article>
         
         <article class="function" data-name="testLookup">
            <h2>testLookup</h2>
            <hr />
            
            <pre><code>func testLookup(t *testing.T, tc *testCase, x *Index, s string, n int)</code></pre>
         </article>
         
         <article class="function" data-name="testFindAllIndex">
            <h2>testFindAllIndex</h2>
            <hr />
            
            <pre><code>func testFindAllIndex(t *testing.T, tc *testCase, x *Index, rx *regexp.Regexp, n int)</code></pre>
         </article>
         
         <article class="function" data-name="testLookups">
            <h2>testLookups</h2>
            <hr />
            
            <pre><code>func testLookups(t *testing.T, tc *testCase, x *Index, n int)</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="at">
            <h2>at</h2>
            <hr />
            
            <pre><code>func at(i int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="testConstruction">
            <h2>testConstruction</h2>
            <hr />
            
            <pre><code>func testConstruction(t *testing.T, tc *testCase, x *Index)</code></pre>
         </article>
         
         <article class="function" data-name="equal">
            <h2>equal</h2>
            <hr />
            
            <pre><code>func equal(x *Index, y *Index) bool</code></pre>
         </article>
         
         <article class="function" data-name="testSaveRestore">
            <h2>testSaveRestore</h2>
            <hr />
            
            <p>returns the serialized index size</p>
            
            <pre><code>func testSaveRestore(t *testing.T, tc *testCase, x *Index) int</code></pre>
         </article>
         
         <article class="function" data-name="testIndex">
            <h2>testIndex</h2>
            <hr />
            
            <pre><code>func testIndex(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIndex32">
            <h2>TestIndex32</h2>
            <hr />
            
            <pre><code>func TestIndex32(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIndex64">
            <h2>TestIndex64</h2>
            <hr />
            
            <pre><code>func TestIndex64(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNew32">
            <h2>TestNew32</h2>
            <hr />
            
            <pre><code>func TestNew32(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNew64">
            <h2>TestNew64</h2>
            <hr />
            
            <pre><code>func TestNew64(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="test">
            <h2>test</h2>
            <hr />
            
            <p>test tests an arbitrary suffix array construction function.
Generates many inputs, builds and checks suffix arrays.</p>
            
            <pre><code>func test(t *testing.T, build func)</code></pre>
         </article>
         
         <article class="function" data-name="testRec">
            <h2>testRec</h2>
            <hr />
            
            <p>testRec fills x[i:] with all possible combinations of values in [1,max]
and then calls testSA(t, x, build) for each one.</p>
            
            <pre><code>func testRec(t *testing.T, x []byte, i int, max int, numFail *int, build func)</code></pre>
         </article>
         
         <article class="function" data-name="testSA">
            <h2>testSA</h2>
            <hr />
            
            <p>testSA tests the suffix array build function on the input x.
It constructs the suffix array and then checks that it is correct.</p>
            
            <pre><code>func testSA(t *testing.T, x []byte, build func) bool</code></pre>
         </article>
         
         <article class="function" data-name="benchmarkNew">
            <h2>benchmarkNew</h2>
            <hr />
            
            <p>Of all possible inputs, the random bytes have the least amount of substring
repetition, and the repeated bytes have the most. For most algorithms,
the running time of every input will be between these two.</p>
            
            <pre><code>func benchmarkNew(b *testing.B, random bool)</code></pre>
         </article>
         
         <article class="function" data-name="makeText">
            <h2>makeText</h2>
            <hr />
            
            <pre><code>func makeText(name string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="setBits">
            <h2>setBits</h2>
            <hr />
            
            <pre><code>func setBits(bits int) cleanup func</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkNew">
            <h2>BenchmarkNew</h2>
            <hr />
            
            <pre><code>func BenchmarkNew(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkSaveRestore">
            <h2>BenchmarkSaveRestore</h2>
            <hr />
            
            <pre><code>func BenchmarkSaveRestore(b *testing.B)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
