<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - dwarfgen</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>dwarfgen</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bytes"
"flag"
"fmt"
"internal/buildcfg"
"slices"
"sort"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/ssa"
"cmd/compile/internal/ssagen"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/dwarf"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
"fmt"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/internal/dwarf"
"cmd/internal/obj"
"cmd/internal/src"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/internal/src"
"sort"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/internal/dwarf"
"cmd/internal/obj"
"cmd/internal/src"
</code></pre>
            </article>
         </section>
             
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="ScopeMarker">
               <h3>
                  ScopeMarker
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ScopeMarker tracks scope nesting and boundaries for later use
during DWARF generation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ScopeMarker struct {
parents []ir.ScopeID
marks []ir.Mark
}</code></pre>
            </article>
            
            <article class="struct" data-name="varPos">
               <h3>
                  varPos
                  <span class="badge">struct</span>
               </h3>
               
               <p>To identify variables by original source position.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type varPos struct {
DeclName string
DeclFile string
DeclLine uint
DeclCol uint
}</code></pre>
            </article>
            
            <article class="struct" data-name="varsAndDecls">
               <h3>
                  varsAndDecls
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type varsAndDecls struct {
decls []*ir.Name
vars []*dwarf.Var
paramOrder map[*ir.Name]int
}</code></pre>
            </article>
            
            <article class="struct" data-name="varsByScope">
               <h3>
                  varsByScope
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type varsByScope struct {
vars []*dwarf.Var
scopes []ir.ScopeID
}</code></pre>
            </article>
            
            <article class="struct" data-name="varsByScopeAndOffset">
               <h3>
                  varsByScopeAndOffset
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type varsByScopeAndOffset struct {
vars []*dwarf.Var
scopes []ir.ScopeID
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="AbstractFunc">
               <h3>
                  AbstractFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Secondary hook for DWARF inlined subroutine generation. This is called
late in the compilation when it is determined that we need an
abstract function DIE for an inlined routine imported from a
previously compiled package.</p>
               
               <pre><code>func AbstractFunc(fn *obj.LSym)</code></pre>
            </article>
            
            <article class="function" data-name="Info">
               <h3>
                  Info 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func Info(ctxt *obj.Link, fnsym *obj.LSym, infosym *obj.LSym, curfn obj.Func) (scopes []dwarf.Scope, inlcalls dwarf.InlCalls)</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v varsByScope) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v varsAndDecls) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v varsByScopeAndOffset) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v varsByScope) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v varsAndDecls) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v varsByScopeAndOffset) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="Pop">
               <h3>
                  Pop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Pop records a transition back to the current scope's parent.</p>
               
               <pre><code>func (m *ScopeMarker) Pop(pos src.XPos)</code></pre>
            </article>
            
            <article class="function" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Push records a transition to a new child scope of the current scope.</p>
               
               <pre><code>func (m *ScopeMarker) Push(pos src.XPos)</code></pre>
            </article>
            
            <article class="function" data-name="RecordFlags">
               <h3>
                  RecordFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RecordFlags records the specified command-line flags to be placed
in the DWARF info.</p>
               
               <pre><code>func RecordFlags(flags ...string)</code></pre>
            </article>
            
            <article class="function" data-name="RecordPackageName">
               <h3>
                  RecordPackageName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RecordPackageName records the name of the package being
compiled, so that the linker can save it in the compile unit's DIE.</p>
               
               <pre><code>func RecordPackageName()</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v varsAndDecls) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v varsByScopeAndOffset) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v varsByScope) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="Unpush">
               <h3>
                  Unpush 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Unpush removes the current scope, which must be empty.</p>
               
               <pre><code>func (m *ScopeMarker) Unpush()</code></pre>
            </article>
            
            <article class="function" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteTo writes the recorded scope marks to the given function,
and resets the marker for reuse.</p>
               
               <pre><code>func (m *ScopeMarker) WriteTo(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function" data-name="addRange">
               <h3>
                  addRange 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addRange(calls []dwarf.InlCall, start int64, end int64, ii int, imap map[int]int)</code></pre>
            </article>
            
            <article class="function" data-name="assembleInlines">
               <h3>
                  assembleInlines 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>This is the main entry point for collection of raw material to
drive generation of DWARF "inlined subroutine" DIEs. See proposal
22080 for more details and background info.</p>
               
               <pre><code>func assembleInlines(fnsym *obj.LSym, dwVars []*dwarf.Var) dwarf.InlCalls</code></pre>
            </article>
            
            <article class="function" data-name="assembleScopes">
               <h3>
                  assembleScopes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func assembleScopes(fnsym *obj.LSym, fn *ir.Func, dwarfVars []*dwarf.Var, varScopes []ir.ScopeID) []dwarf.Scope</code></pre>
            </article>
            
            <article class="function" data-name="checkInlCall">
               <h3>
                  checkInlCall 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkInlCall verifies that the PC ranges for inline info 'idx' are
enclosed/contained within the ranges of its parent inline (or if
this is a root/toplevel inline, checks that the ranges fall within
the extent of the top level function). A panic is issued if a
malformed range is found.</p>
               
               <pre><code>func checkInlCall(funcName string, inlCalls dwarf.InlCalls, funcSize int64, idx int, parentIdx int)</code></pre>
            </article>
            
            <article class="function" data-name="checkPos">
               <h3>
                  checkPos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>checkPos validates the given position and returns the current scope.</p>
               
               <pre><code>func (m *ScopeMarker) checkPos(pos src.XPos) ir.ScopeID</code></pre>
            </article>
            
            <article class="function" data-name="closureOffset">
               <h3>
                  closureOffset 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func closureOffset(n *ir.Name, closureVars map[*ir.Name]int64) int64</code></pre>
            </article>
            
            <article class="function" data-name="compactMarks">
               <h3>
                  compactMarks 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m *ScopeMarker) compactMarks()</code></pre>
            </article>
            
            <article class="function" data-name="compactScopes">
               <h3>
                  compactScopes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func compactScopes(dwarfScopes []dwarf.Scope) []dwarf.Scope</code></pre>
            </article>
            
            <article class="function" data-name="createABIVars">
               <h3>
                  createABIVars 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>createABIVars creates DWARF variables for functions in which the
register ABI is enabled but optimization is turned off. It uses a
hybrid approach in which register-resident input params are
captured with location lists, and all other vars use the "simple"
strategy.</p>
               
               <pre><code>func createABIVars(fnsym *obj.LSym, fn *ir.Func, apDecls []*ir.Name, closureVars map[*ir.Name]int64) ([]*ir.Name, []*dwarf.Var, ir.NameSet)</code></pre>
            </article>
            
            <article class="function" data-name="createComplexVar">
               <h3>
                  createComplexVar 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>createComplexVar builds a single DWARF variable entry and location list.</p>
               
               <pre><code>func createComplexVar(fnsym *obj.LSym, fn *ir.Func, varID ssa.VarID, closureVars map[*ir.Name]int64) *dwarf.Var</code></pre>
            </article>
            
            <article class="function" data-name="createComplexVars">
               <h3>
                  createComplexVars 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>createComplexVars creates recomposed DWARF vars with location lists,
suitable for describing optimized code.</p>
               
               <pre><code>func createComplexVars(fnsym *obj.LSym, fn *ir.Func, closureVars map[*ir.Name]int64) ([]*ir.Name, []*dwarf.Var, ir.NameSet)</code></pre>
            </article>
            
            <article class="function" data-name="createDwarfVars">
               <h3>
                  createDwarfVars 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>createDwarfVars process fn, returning a list of DWARF variables and the
Nodes they represent.</p>
               
               <pre><code>func createDwarfVars(fnsym *obj.LSym, complexOK bool, fn *ir.Func, apDecls []*ir.Name, closureVars map[*ir.Name]int64) ([]*ir.Name, []*dwarf.Var)</code></pre>
            </article>
            
            <article class="function" data-name="createSimpleVar">
               <h3>
                  createSimpleVar 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func createSimpleVar(fnsym *obj.LSym, n *ir.Name, closureVars map[*ir.Name]int64) *dwarf.Var</code></pre>
            </article>
            
            <article class="function" data-name="createSimpleVars">
               <h3>
                  createSimpleVars 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>createSimpleVars creates a DWARF entry for every variable declared in the
function, claiming that they are permanently on the stack.</p>
               
               <pre><code>func createSimpleVars(fnsym *obj.LSym, apDecls []*ir.Name, closureVars map[*ir.Name]int64) ([]*ir.Name, []*dwarf.Var, ir.NameSet)</code></pre>
            </article>
            
            <article class="function" data-name="declPos">
               <h3>
                  declPos 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func declPos(decl *ir.Name) src.XPos</code></pre>
            </article>
            
            <article class="function" data-name="dumpInlCall">
               <h3>
                  dumpInlCall 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dumpInlCall(inlcalls dwarf.InlCalls, idx int, ilevel int)</code></pre>
            </article>
            
            <article class="function" data-name="dumpInlCalls">
               <h3>
                  dumpInlCalls 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dumpInlCalls(inlcalls dwarf.InlCalls)</code></pre>
            </article>
            
            <article class="function" data-name="dumpInlVars">
               <h3>
                  dumpInlVars 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dumpInlVars(dwvars []*dwarf.Var)</code></pre>
            </article>
            
            <article class="function" data-name="findScope">
               <h3>
                  findScope 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func findScope(marks []ir.Mark, pos src.XPos) ir.ScopeID</code></pre>
            </article>
            
            <article class="function" data-name="insertInlCall">
               <h3>
                  insertInlCall 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func insertInlCall(dwcalls *dwarf.InlCalls, inlIdx int, imap map[int]int) int</code></pre>
            </article>
            
            <article class="function" data-name="makePreinlineDclMap">
               <h3>
                  makePreinlineDclMap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Given a function that was inlined as part of the compilation, dig
up the pre-inlining DCL list for the function and create a map that
supports lookup of pre-inline dcl index, based on variable
position/name. NB: the recipe for computing variable pos/file/line
needs to be kept in sync with the similar code in gc.createSimpleVars
and related functions.</p>
               
               <pre><code>func makePreinlineDclMap(fnsym *obj.LSym) map[varPos]int</code></pre>
            </article>
            
            <article class="function" data-name="posInlIndex">
               <h3>
                  posInlIndex 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Given a src.XPos, return its associated inlining index if it
corresponds to something created as a result of an inline, or -1 if
there is no inline info. Note that the index returned will refer to
the deepest call in the inlined stack, e.g. if you have "A calls B
calls C calls D" and all three callees are inlined (B, C, and D),
the index for a node from the inlined body of D will refer to the
call to D from C. Whew.</p>
               
               <pre><code>func posInlIndex(xpos src.XPos) int</code></pre>
            </article>
            
            <article class="function" data-name="preInliningDcls">
               <h3>
                  preInliningDcls 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Given a function that was inlined at some point during the
compilation, return a sorted list of nodes corresponding to the
autos/locals in that function prior to inlining. If this is a
function that is not local to the package being compiled, then the
names of the variables may have been "versioned" to avoid conflicts
with local vars; disregard this versioning when sorting.</p>
               
               <pre><code>func preInliningDcls(fnsym *obj.LSym) []*ir.Name</code></pre>
            </article>
            
            <article class="function" data-name="rangesContains">
               <h3>
                  rangesContains 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func rangesContains(par []dwarf.Range, rng dwarf.Range) (bool, string)</code></pre>
            </article>
            
            <article class="function" data-name="rangesContainsAll">
               <h3>
                  rangesContainsAll 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func rangesContainsAll(parent []dwarf.Range, child []dwarf.Range) (bool, string)</code></pre>
            </article>
            
            <article class="function" data-name="scopePCs">
               <h3>
                  scopePCs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>scopePCs assigns PC ranges to their scopes.</p>
               
               <pre><code>func scopePCs(fnsym *obj.LSym, marks []ir.Mark, dwarfScopes []dwarf.Scope)</code></pre>
            </article>
            
            <article class="function" data-name="scopeVariables">
               <h3>
                  scopeVariables 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>scopeVariables assigns DWARF variable records to their scopes.</p>
               
               <pre><code>func scopeVariables(dwarfVars []*dwarf.Var, varScopes []ir.ScopeID, dwarfScopes []dwarf.Scope, regabi bool)</code></pre>
            </article>
            
            <article class="function" data-name="sortDeclsAndVars">
               <h3>
                  sortDeclsAndVars 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>sortDeclsAndVars sorts the decl and dwarf var lists according to
parameter declaration order, so as to insure that when a subprogram
DIE is emitted, its parameter children appear in declaration order.
Prior to the advent of the register ABI, sorting by frame offset
would achieve this; with the register we now need to go back to the
original function signature.</p>
               
               <pre><code>func sortDeclsAndVars(fn *ir.Func, decls []*ir.Name, vars []*dwarf.Var)</code></pre>
            </article>
            
            <article class="function" data-name="unifyCallRanges">
               <h3>
                  unifyCallRanges 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>unifyCallRanges ensures that the ranges for a given inline
transitively include all of the ranges for its child inlines.</p>
               
               <pre><code>func unifyCallRanges(inlcalls dwarf.InlCalls, idx int)</code></pre>
            </article>
            
            <article class="function" data-name="xposBefore">
               <h3>
                  xposBefore 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>See golang.org/issue/20390.</p>
               
               <pre><code>func xposBefore(p src.XPos, q src.XPos) bool</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
