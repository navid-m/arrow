<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - dwarfgen</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>dwarfgen</code>
         </h1>
         <hr />
         
         <article class="global" data-name="testfile">
            <h2>testfile</h2>
            <hr />
            
            <pre><code>testfile</code></pre>
         </article>
         
         <article class="global" data-name="detailOutput">
            <h2>detailOutput</h2>
            <hr />
            
            <pre><code>detailOutput</code></pre>
         </article>
          
         <article class="struct" data-name="varsAndDecls">
            <h2>type varsAndDecls struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">decls []*ir.Name
vars []*dwarf.Var
paramOrder *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="varPos">
            <h2>type varPos struct</h2>
            <hr />
            
            <p>To identify variables by original source position.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">DeclName string
DeclFile string
DeclLine uint
DeclCol uint</code></pre>
         </article>
         
         <article class="struct" data-name="ScopeMarker">
            <h2>type ScopeMarker struct</h2>
            <hr />
            
            <p>A ScopeMarker tracks scope nesting and boundaries for later use
during DWARF generation.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">parents []ir.ScopeID
marks []ir.Mark</code></pre>
         </article>
         
         <article class="struct" data-name="varsByScopeAndOffset">
            <h2>type varsByScopeAndOffset struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">vars []*dwarf.Var
scopes []ir.ScopeID</code></pre>
         </article>
         
         <article class="struct" data-name="varsByScope">
            <h2>type varsByScope struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">vars []*dwarf.Var
scopes []ir.ScopeID</code></pre>
         </article>
         
         <article class="struct" data-name="testline">
            <h2>type testline struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">line string
scopes []int
vars []string
decl []string
declBefore []string</code></pre>
         </article>
         
         <article class="struct" data-name="lexblock">
            <h2>type lexblock struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">id int
ranges [][]uint64
vars []variable
scopes []lexblock</code></pre>
         </article>
         
         <article class="struct" data-name="variable">
            <h2>type variable struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">expr string
declLine int</code></pre>
         </article>
         
         <article class="struct" data-name="line">
            <h2>type line struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">file string
lineno int</code></pre>
         </article>
         
         <article class="struct" data-name="scopexplainContext">
            <h2>type scopexplainContext struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">dwarfData *dwarf.Data
dwarfReader *dwarf.Reader
scopegen int</code></pre>
         </article>
          
         <article class="function" data-name="Info">
            <h2>Info</h2>
            <hr />
            
            <pre><code>func Info(ctxt *obj.Link, fnsym *obj.LSym, infosym *obj.LSym, curfn obj.Func) (scopes []dwarf.Scope, inlcalls dwarf.InlCalls)</code></pre>
         </article>
         
         <article class="function" data-name="declPos">
            <h2>declPos</h2>
            <hr />
            
            <pre><code>func declPos(decl *ir.Name) src.XPos</code></pre>
         </article>
         
         <article class="function" data-name="createDwarfVars">
            <h2>createDwarfVars</h2>
            <hr />
            
            <p>createDwarfVars process fn, returning a list of DWARF variables and the
Nodes they represent.</p>
            
            <pre><code>func createDwarfVars(fnsym *obj.LSym, complexOK bool, fn *ir.Func, apDecls []*ir.Name, closureVars *ast.MapType) ([]*ir.Name, []*dwarf.Var)</code></pre>
         </article>
         
         <article class="function" data-name="sortDeclsAndVars">
            <h2>sortDeclsAndVars</h2>
            <hr />
            
            <p>sortDeclsAndVars sorts the decl and dwarf var lists according to
parameter declaration order, so as to insure that when a subprogram
DIE is emitted, its parameter children appear in declaration order.
Prior to the advent of the register ABI, sorting by frame offset
would achieve this; with the register we now need to go back to the
original function signature.</p>
            
            <pre><code>func sortDeclsAndVars(fn *ir.Func, decls []*ir.Name, vars []*dwarf.Var)</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="preInliningDcls">
            <h2>preInliningDcls</h2>
            <hr />
            
            <p>Given a function that was inlined at some point during the
compilation, return a sorted list of nodes corresponding to the
autos/locals in that function prior to inlining. If this is a
function that is not local to the package being compiled, then the
names of the variables may have been "versioned" to avoid conflicts
with local vars; disregard this versioning when sorting.</p>
            
            <pre><code>func preInliningDcls(fnsym *obj.LSym) []*ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="createSimpleVars">
            <h2>createSimpleVars</h2>
            <hr />
            
            <p>createSimpleVars creates a DWARF entry for every variable declared in the
function, claiming that they are permanently on the stack.</p>
            
            <pre><code>func createSimpleVars(fnsym *obj.LSym, apDecls []*ir.Name, closureVars *ast.MapType) ([]*ir.Name, []*dwarf.Var, ir.NameSet)</code></pre>
         </article>
         
         <article class="function" data-name="createSimpleVar">
            <h2>createSimpleVar</h2>
            <hr />
            
            <pre><code>func createSimpleVar(fnsym *obj.LSym, n *ir.Name, closureVars *ast.MapType) *dwarf.Var</code></pre>
         </article>
         
         <article class="function" data-name="createABIVars">
            <h2>createABIVars</h2>
            <hr />
            
            <p>createABIVars creates DWARF variables for functions in which the
register ABI is enabled but optimization is turned off. It uses a
hybrid approach in which register-resident input params are
captured with location lists, and all other vars use the "simple"
strategy.</p>
            
            <pre><code>func createABIVars(fnsym *obj.LSym, fn *ir.Func, apDecls []*ir.Name, closureVars *ast.MapType) ([]*ir.Name, []*dwarf.Var, ir.NameSet)</code></pre>
         </article>
         
         <article class="function" data-name="createComplexVars">
            <h2>createComplexVars</h2>
            <hr />
            
            <p>createComplexVars creates recomposed DWARF vars with location lists,
suitable for describing optimized code.</p>
            
            <pre><code>func createComplexVars(fnsym *obj.LSym, fn *ir.Func, closureVars *ast.MapType) ([]*ir.Name, []*dwarf.Var, ir.NameSet)</code></pre>
         </article>
         
         <article class="function" data-name="createComplexVar">
            <h2>createComplexVar</h2>
            <hr />
            
            <p>createComplexVar builds a single DWARF variable entry and location list.</p>
            
            <pre><code>func createComplexVar(fnsym *obj.LSym, fn *ir.Func, varID ssa.VarID, closureVars *ast.MapType) *dwarf.Var</code></pre>
         </article>
         
         <article class="function" data-name="RecordFlags">
            <h2>RecordFlags</h2>
            <hr />
            
            <p>RecordFlags records the specified command-line flags to be placed
in the DWARF info.</p>
            
            <pre><code>func RecordFlags(flags ...string)</code></pre>
         </article>
         
         <article class="function" data-name="RecordPackageName">
            <h2>RecordPackageName</h2>
            <hr />
            
            <p>RecordPackageName records the name of the package being
compiled, so that the linker can save it in the compile unit's DIE.</p>
            
            <pre><code>func RecordPackageName()</code></pre>
         </article>
         
         <article class="function" data-name="closureOffset">
            <h2>closureOffset</h2>
            <hr />
            
            <pre><code>func closureOffset(n *ir.Name, closureVars *ast.MapType) int64</code></pre>
         </article>
         
         <article class="function" data-name="assembleInlines">
            <h2>assembleInlines</h2>
            <hr />
            
            <p>This is the main entry point for collection of raw material to
drive generation of DWARF "inlined subroutine" DIEs. See proposal
22080 for more details and background info.</p>
            
            <pre><code>func assembleInlines(fnsym *obj.LSym, dwVars []*dwarf.Var) dwarf.InlCalls</code></pre>
         </article>
         
         <article class="function" data-name="AbstractFunc">
            <h2>AbstractFunc</h2>
            <hr />
            
            <p>Secondary hook for DWARF inlined subroutine generation. This is called
late in the compilation when it is determined that we need an
abstract function DIE for an inlined routine imported from a
previously compiled package.</p>
            
            <pre><code>func AbstractFunc(fn *obj.LSym)</code></pre>
         </article>
         
         <article class="function" data-name="makePreinlineDclMap">
            <h2>makePreinlineDclMap</h2>
            <hr />
            
            <p>Given a function that was inlined as part of the compilation, dig
up the pre-inlining DCL list for the function and create a map that
supports lookup of pre-inline dcl index, based on variable
position/name. NB: the recipe for computing variable pos/file/line
needs to be kept in sync with the similar code in gc.createSimpleVars
and related functions.</p>
            
            <pre><code>func makePreinlineDclMap(fnsym *obj.LSym) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="insertInlCall">
            <h2>insertInlCall</h2>
            <hr />
            
            <pre><code>func insertInlCall(dwcalls *dwarf.InlCalls, inlIdx int, imap *ast.MapType) int</code></pre>
         </article>
         
         <article class="function" data-name="posInlIndex">
            <h2>posInlIndex</h2>
            <hr />
            
            <p>Given a src.XPos, return its associated inlining index if it
corresponds to something created as a result of an inline, or -1 if
there is no inline info. Note that the index returned will refer to
the deepest call in the inlined stack, e.g. if you have "A calls B
calls C calls D" and all three callees are inlined (B, C, and D),
the index for a node from the inlined body of D will refer to the
call to D from C. Whew.</p>
            
            <pre><code>func posInlIndex(xpos src.XPos) int</code></pre>
         </article>
         
         <article class="function" data-name="addRange">
            <h2>addRange</h2>
            <hr />
            
            <pre><code>func addRange(calls []dwarf.InlCall, start int64, end int64, ii int, imap *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="dumpInlCall">
            <h2>dumpInlCall</h2>
            <hr />
            
            <pre><code>func dumpInlCall(inlcalls dwarf.InlCalls, idx int, ilevel int)</code></pre>
         </article>
         
         <article class="function" data-name="dumpInlCalls">
            <h2>dumpInlCalls</h2>
            <hr />
            
            <pre><code>func dumpInlCalls(inlcalls dwarf.InlCalls)</code></pre>
         </article>
         
         <article class="function" data-name="dumpInlVars">
            <h2>dumpInlVars</h2>
            <hr />
            
            <pre><code>func dumpInlVars(dwvars []*dwarf.Var)</code></pre>
         </article>
         
         <article class="function" data-name="rangesContains">
            <h2>rangesContains</h2>
            <hr />
            
            <pre><code>func rangesContains(par []dwarf.Range, rng dwarf.Range) (bool, string)</code></pre>
         </article>
         
         <article class="function" data-name="rangesContainsAll">
            <h2>rangesContainsAll</h2>
            <hr />
            
            <pre><code>func rangesContainsAll(parent []dwarf.Range, child []dwarf.Range) (bool, string)</code></pre>
         </article>
         
         <article class="function" data-name="checkInlCall">
            <h2>checkInlCall</h2>
            <hr />
            
            <p>checkInlCall verifies that the PC ranges for inline info 'idx' are
enclosed/contained within the ranges of its parent inline (or if
this is a root/toplevel inline, checks that the ranges fall within
the extent of the top level function). A panic is issued if a
malformed range is found.</p>
            
            <pre><code>func checkInlCall(funcName string, inlCalls dwarf.InlCalls, funcSize int64, idx int, parentIdx int)</code></pre>
         </article>
         
         <article class="function" data-name="unifyCallRanges">
            <h2>unifyCallRanges</h2>
            <hr />
            
            <p>unifyCallRanges ensures that the ranges for a given inline
transitively include all of the ranges for its child inlines.</p>
            
            <pre><code>func unifyCallRanges(inlcalls dwarf.InlCalls, idx int)</code></pre>
         </article>
         
         <article class="function" data-name="checkPos">
            <h2>checkPos</h2>
            <hr />
            
            <p>checkPos validates the given position and returns the current scope.</p>
            
            <pre><code>func checkPos(pos src.XPos) ir.ScopeID</code></pre>
         </article>
         
         <article class="function" data-name="Push">
            <h2>Push</h2>
            <hr />
            
            <p>Push records a transition to a new child scope of the current scope.</p>
            
            <pre><code>func Push(pos src.XPos)</code></pre>
         </article>
         
         <article class="function" data-name="Pop">
            <h2>Pop</h2>
            <hr />
            
            <p>Pop records a transition back to the current scope's parent.</p>
            
            <pre><code>func Pop(pos src.XPos)</code></pre>
         </article>
         
         <article class="function" data-name="Unpush">
            <h2>Unpush</h2>
            <hr />
            
            <p>Unpush removes the current scope, which must be empty.</p>
            
            <pre><code>func Unpush()</code></pre>
         </article>
         
         <article class="function" data-name="WriteTo">
            <h2>WriteTo</h2>
            <hr />
            
            <p>WriteTo writes the recorded scope marks to the given function,
and resets the marker for reuse.</p>
            
            <pre><code>func WriteTo(fn *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="compactMarks">
            <h2>compactMarks</h2>
            <hr />
            
            <pre><code>func compactMarks()</code></pre>
         </article>
         
         <article class="function" data-name="xposBefore">
            <h2>xposBefore</h2>
            <hr />
            
            <p>See golang.org/issue/20390.</p>
            
            <pre><code>func xposBefore(p src.XPos, q src.XPos) bool</code></pre>
         </article>
         
         <article class="function" data-name="findScope">
            <h2>findScope</h2>
            <hr />
            
            <pre><code>func findScope(marks []ir.Mark, pos src.XPos) ir.ScopeID</code></pre>
         </article>
         
         <article class="function" data-name="assembleScopes">
            <h2>assembleScopes</h2>
            <hr />
            
            <pre><code>func assembleScopes(fnsym *obj.LSym, fn *ir.Func, dwarfVars []*dwarf.Var, varScopes []ir.ScopeID) []dwarf.Scope</code></pre>
         </article>
         
         <article class="function" data-name="scopeVariables">
            <h2>scopeVariables</h2>
            <hr />
            
            <p>scopeVariables assigns DWARF variable records to their scopes.</p>
            
            <pre><code>func scopeVariables(dwarfVars []*dwarf.Var, varScopes []ir.ScopeID, dwarfScopes []dwarf.Scope, regabi bool)</code></pre>
         </article>
         
         <article class="function" data-name="scopePCs">
            <h2>scopePCs</h2>
            <hr />
            
            <p>scopePCs assigns PC ranges to their scopes.</p>
            
            <pre><code>func scopePCs(fnsym *obj.LSym, marks []ir.Mark, dwarfScopes []dwarf.Scope)</code></pre>
         </article>
         
         <article class="function" data-name="compactScopes">
            <h2>compactScopes</h2>
            <hr />
            
            <pre><code>func compactScopes(dwarfScopes []dwarf.Scope) []dwarf.Scope</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="TestScopeRanges">
            <h2>TestScopeRanges</h2>
            <hr />
            
            <p>Compiles testfile checks that the description of lexical blocks emitted
by the linker in debug_info, for each function in the main package,
corresponds to what we expect it to be.</p>
            
            <pre><code>func TestScopeRanges(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="scopesToString">
            <h2>scopesToString</h2>
            <hr />
            
            <pre><code>func scopesToString(v []*lexblock) string</code></pre>
         </article>
         
         <article class="function" data-name="checkScopes">
            <h2>checkScopes</h2>
            <hr />
            
            <pre><code>func checkScopes(tgt []int, out []*lexblock) bool</code></pre>
         </article>
         
         <article class="function" data-name="checkVars">
            <h2>checkVars</h2>
            <hr />
            
            <pre><code>func checkVars(tgt []string, out []variable) bool</code></pre>
         </article>
         
         <article class="function" data-name="declLineForVar">
            <h2>declLineForVar</h2>
            <hr />
            
            <pre><code>func declLineForVar(scope []variable, name string) int</code></pre>
         </article>
         
         <article class="function" data-name="name">
            <h2>name</h2>
            <hr />
            
            <pre><code>func name() string</code></pre>
         </article>
         
         <article class="function" data-name="readScope">
            <h2>readScope</h2>
            <hr />
            
            <p>readScope reads the DW_TAG_lexical_block or the DW_TAG_subprogram in
entry and writes a description in scope.
Nested DW_TAG_lexical_block entries are read recursively.</p>
            
            <pre><code>func readScope(ctxt *scopexplainContext, scope *lexblock, entry *dwarf.Entry)</code></pre>
         </article>
         
         <article class="function" data-name="entryToVar">
            <h2>entryToVar</h2>
            <hr />
            
            <pre><code>func entryToVar(e *dwarf.Entry, kind string, typ dwarf.Type) variable</code></pre>
         </article>
         
         <article class="function" data-name="markLines">
            <h2>markLines</h2>
            <hr />
            
            <p>markLines marks all lines that belong to this scope with this scope
Recursively calls markLines for all children scopes.</p>
            
            <pre><code>func markLines(pcln objfile.Liner, lines *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="gobuild">
            <h2>gobuild</h2>
            <hr />
            
            <pre><code>func gobuild(t *testing.T, dir string, optimized bool, testfile []testline) (string, *objfile.File)</code></pre>
         </article>
         
         <article class="function" data-name="TestEmptyDwarfRanges">
            <h2>TestEmptyDwarfRanges</h2>
            <hr />
            
            <p>TestEmptyDwarfRanges tests that no list entry in debug_ranges has start == end.
See issue #23928.</p>
            
            <pre><code>func TestEmptyDwarfRanges(t *testing.T)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
