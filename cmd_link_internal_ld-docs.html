<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - ld</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>ld</code>
         </h1>
         <hr />
         
         <article class="global" data-name="DefaultOpt">
            <h2>DefaultOpt</h2>
            <hr />
            
            <pre><code>DefaultOpt</code></pre>
         </article>
         
         <article class="global" data-name="NoOpt">
            <h2>NoOpt</h2>
            <hr />
            
            <pre><code>NoOpt</code></pre>
         </article>
         
         <article class="global" data-name="OptInl4">
            <h2>OptInl4</h2>
            <hr />
            
            <pre><code>OptInl4</code></pre>
         </article>
         
         <article class="global" data-name="OptAllInl4">
            <h2>OptAllInl4</h2>
            <hr />
            
            <pre><code>OptAllInl4</code></pre>
         </article>
         
         <article class="global" data-name="zeroSizedVarProg">
            <h2>zeroSizedVarProg</h2>
            <hr />
            
            <pre><code>zeroSizedVarProg</code></pre>
         </article>
         
         <article class="global" data-name="seenlib">
            <h2>seenlib</h2>
            <hr />
            
            <pre><code>seenlib</code></pre>
         </article>
         
         <article class="global" data-name="stackCheckCycle">
            <h2>stackCheckCycle</h2>
            <hr />
            
            <p>stackCheckCycle is a sentinel stored in the height map to detect if
we've found a cycle. This is effectively an "infinite" stack
height, so we use the closest value to infinity that we can.</p>
            
            <pre><code>stackCheckCycle int16</code></pre>
         </article>
         
         <article class="global" data-name="stackCheckIndirect">
            <h2>stackCheckIndirect</h2>
            <hr />
            
            <p>stackCheckIndirect is a sentinel Sym value used to represent the
target of an indirect/closure call.</p>
            
            <pre><code>stackCheckIndirect loader.Sym</code></pre>
         </article>
         
         <article class="global" data-name="syscallExecSupported">
            <h2>syscallExecSupported</h2>
            <hr />
            
            <pre><code>syscallExecSupported</code></pre>
         </article>
         
         <article class="global" data-name="prog">
            <h2>prog</h2>
            <hr />
            
            <pre><code>prog</code></pre>
         </article>
         
         <article class="global" data-name="carchiveSrcText">
            <h2>carchiveSrcText</h2>
            <hr />
            
            <pre><code>carchiveSrcText</code></pre>
         </article>
         
         <article class="global" data-name="CarrierSymByType">
            <h2>CarrierSymByType</h2>
            <hr />
            
            <p>CarrierSymByType tracks carrier symbols and their sizes.</p>
            
            <pre><code>CarrierSymByType []*ast.StructType</code></pre>
         </article>
         
         <article class="global" data-name="BuildModeUnset">
            <h2>BuildModeUnset</h2>
            <hr />
            
            <pre><code>BuildModeUnset BuildMode</code></pre>
         </article>
         
         <article class="global" data-name="BuildModeExe">
            <h2>BuildModeExe</h2>
            <hr />
            
            <pre><code>BuildModeExe</code></pre>
         </article>
         
         <article class="global" data-name="BuildModePIE">
            <h2>BuildModePIE</h2>
            <hr />
            
            <pre><code>BuildModePIE</code></pre>
         </article>
         
         <article class="global" data-name="BuildModeCArchive">
            <h2>BuildModeCArchive</h2>
            <hr />
            
            <pre><code>BuildModeCArchive</code></pre>
         </article>
         
         <article class="global" data-name="BuildModeCShared">
            <h2>BuildModeCShared</h2>
            <hr />
            
            <pre><code>BuildModeCShared</code></pre>
         </article>
         
         <article class="global" data-name="BuildModeShared">
            <h2>BuildModeShared</h2>
            <hr />
            
            <pre><code>BuildModeShared</code></pre>
         </article>
         
         <article class="global" data-name="BuildModePlugin">
            <h2>BuildModePlugin</h2>
            <hr />
            
            <pre><code>BuildModePlugin</code></pre>
         </article>
         
         <article class="global" data-name="LinkAuto">
            <h2>LinkAuto</h2>
            <hr />
            
            <pre><code>LinkAuto LinkMode</code></pre>
         </article>
         
         <article class="global" data-name="LinkInternal">
            <h2>LinkInternal</h2>
            <hr />
            
            <pre><code>LinkInternal</code></pre>
         </article>
         
         <article class="global" data-name="LinkExternal">
            <h2>LinkExternal</h2>
            <hr />
            
            <pre><code>LinkExternal</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="ARM_MAGIC_TRAMP_NUMBER">
            <h2>ARM_MAGIC_TRAMP_NUMBER</h2>
            <hr />
            
            <p>* Relocation types.</p>
            
            <pre><code>ARM_MAGIC_TRAMP_NUMBER</code></pre>
         </article>
         
         <article class="global" data-name="ELF64HDRSIZE">
            <h2>ELF64HDRSIZE</h2>
            <hr />
            
            <p>* Go linker interface</p>
            
            <pre><code>ELF64HDRSIZE</code></pre>
         </article>
         
         <article class="global" data-name="ELF64PHDRSIZE">
            <h2>ELF64PHDRSIZE</h2>
            <hr />
            
            <p>* Go linker interface</p>
            
            <pre><code>ELF64PHDRSIZE</code></pre>
         </article>
         
         <article class="global" data-name="ELF64SHDRSIZE">
            <h2>ELF64SHDRSIZE</h2>
            <hr />
            
            <p>* Go linker interface</p>
            
            <pre><code>ELF64SHDRSIZE</code></pre>
         </article>
         
         <article class="global" data-name="ELF64RELSIZE">
            <h2>ELF64RELSIZE</h2>
            <hr />
            
            <p>* Go linker interface</p>
            
            <pre><code>ELF64RELSIZE</code></pre>
         </article>
         
         <article class="global" data-name="ELF64RELASIZE">
            <h2>ELF64RELASIZE</h2>
            <hr />
            
            <p>* Go linker interface</p>
            
            <pre><code>ELF64RELASIZE</code></pre>
         </article>
         
         <article class="global" data-name="ELF64SYMSIZE">
            <h2>ELF64SYMSIZE</h2>
            <hr />
            
            <p>* Go linker interface</p>
            
            <pre><code>ELF64SYMSIZE</code></pre>
         </article>
         
         <article class="global" data-name="ELF32HDRSIZE">
            <h2>ELF32HDRSIZE</h2>
            <hr />
            
            <p>* Go linker interface</p>
            
            <pre><code>ELF32HDRSIZE</code></pre>
         </article>
         
         <article class="global" data-name="ELF32PHDRSIZE">
            <h2>ELF32PHDRSIZE</h2>
            <hr />
            
            <p>* Go linker interface</p>
            
            <pre><code>ELF32PHDRSIZE</code></pre>
         </article>
         
         <article class="global" data-name="ELF32SHDRSIZE">
            <h2>ELF32SHDRSIZE</h2>
            <hr />
            
            <p>* Go linker interface</p>
            
            <pre><code>ELF32SHDRSIZE</code></pre>
         </article>
         
         <article class="global" data-name="ELF32SYMSIZE">
            <h2>ELF32SYMSIZE</h2>
            <hr />
            
            <p>* Go linker interface</p>
            
            <pre><code>ELF32SYMSIZE</code></pre>
         </article>
         
         <article class="global" data-name="ELF32RELSIZE">
            <h2>ELF32RELSIZE</h2>
            <hr />
            
            <p>* Go linker interface</p>
            
            <pre><code>ELF32RELSIZE</code></pre>
         </article>
         
         <article class="global" data-name="elfstrdat">
            <h2>elfstrdat</h2>
            <hr />
            
            <pre><code>elfstrdat []byte</code></pre>
         </article>
         
         <article class="global" data-name="elfshstrdat">
            <h2>elfshstrdat</h2>
            <hr />
            
            <pre><code>elfshstrdat []byte</code></pre>
         </article>
         
         <article class="global" data-name="ELFRESERVE">
            <h2>ELFRESERVE</h2>
            <hr />
            
            <p>* Total amount of space to reserve at the start of the file
 * for Header, PHeaders, SHeaders, and interp.
 * May waste some.
 * On FreeBSD, cannot be larger than a page.</p>
            
            <pre><code>ELFRESERVE</code></pre>
         </article>
         
         <article class="global" data-name="NSECT">
            <h2>NSECT</h2>
            <hr />
            
            <p>* We use the 64-bit data structures on both 32- and 64-bit machines
 * in order to write the code just once.  The 64-bit data structure is
 * written in the 32-bit format on the 32-bit machines.</p>
            
            <pre><code>NSECT</code></pre>
         </article>
         
         <article class="global" data-name="Nelfsym">
            <h2>Nelfsym</h2>
            <hr />
            
            <pre><code>Nelfsym</code></pre>
         </article>
         
         <article class="global" data-name="elf64">
            <h2>elf64</h2>
            <hr />
            
            <pre><code>elf64 bool</code></pre>
         </article>
         
         <article class="global" data-name="elfRelType">
            <h2>elfRelType</h2>
            <hr />
            
            <p>Either ".rel" or ".rela" depending on which type of relocation the
target platform uses.</p>
            
            <pre><code>elfRelType string</code></pre>
         </article>
         
         <article class="global" data-name="ehdr">
            <h2>ehdr</h2>
            <hr />
            
            <pre><code>ehdr ElfEhdr</code></pre>
         </article>
         
         <article class="global" data-name="phdr">
            <h2>phdr</h2>
            <hr />
            
            <pre><code>phdr []*ElfPhdr</code></pre>
         </article>
         
         <article class="global" data-name="shdr">
            <h2>shdr</h2>
            <hr />
            
            <pre><code>shdr []*ElfShdr</code></pre>
         </article>
         
         <article class="global" data-name="interp">
            <h2>interp</h2>
            <hr />
            
            <pre><code>interp string</code></pre>
         </article>
         
         <article class="global" data-name="elfstr">
            <h2>elfstr</h2>
            <hr />
            
            <pre><code>elfstr []Elfstring</code></pre>
         </article>
         
         <article class="global" data-name="nelfstr">
            <h2>nelfstr</h2>
            <hr />
            
            <pre><code>nelfstr int</code></pre>
         </article>
         
         <article class="global" data-name="buildinfo">
            <h2>buildinfo</h2>
            <hr />
            
            <pre><code>buildinfo []byte</code></pre>
         </article>
         
         <article class="global" data-name="MIPS_FPABI_NONE">
            <h2>MIPS_FPABI_NONE</h2>
            <hr />
            
            <p>No floating point is present in the module (default)</p>
            
            <pre><code>MIPS_FPABI_NONE</code></pre>
         </article>
         
         <article class="global" data-name="MIPS_FPABI_ANY">
            <h2>MIPS_FPABI_ANY</h2>
            <hr />
            
            <p>FP code in the module uses the FP32 ABI for a 32-bit ABI</p>
            
            <pre><code>MIPS_FPABI_ANY</code></pre>
         </article>
         
         <article class="global" data-name="MIPS_FPABI_SINGLE">
            <h2>MIPS_FPABI_SINGLE</h2>
            <hr />
            
            <p>FP code in the module only uses single precision ABI</p>
            
            <pre><code>MIPS_FPABI_SINGLE</code></pre>
         </article>
         
         <article class="global" data-name="MIPS_FPABI_SOFT">
            <h2>MIPS_FPABI_SOFT</h2>
            <hr />
            
            <p>FP code in the module uses soft-float ABI</p>
            
            <pre><code>MIPS_FPABI_SOFT</code></pre>
         </article>
         
         <article class="global" data-name="MIPS_FPABI_HIST">
            <h2>MIPS_FPABI_HIST</h2>
            <hr />
            
            <p>FP code in the module assumes an FPU with FR=1 and has 12
callee-saved doubles. Historic, no longer supported.</p>
            
            <pre><code>MIPS_FPABI_HIST</code></pre>
         </article>
         
         <article class="global" data-name="MIPS_FPABI_FPXX">
            <h2>MIPS_FPABI_FPXX</h2>
            <hr />
            
            <p>FP code in the module uses the FPXX  ABI</p>
            
            <pre><code>MIPS_FPABI_FPXX</code></pre>
         </article>
         
         <article class="global" data-name="MIPS_FPABI_FP64">
            <h2>MIPS_FPABI_FP64</h2>
            <hr />
            
            <p>FP code in the module uses the FP64  ABI</p>
            
            <pre><code>MIPS_FPABI_FP64</code></pre>
         </article>
         
         <article class="global" data-name="MIPS_FPABI_FP64A">
            <h2>MIPS_FPABI_FP64A</h2>
            <hr />
            
            <p>FP code in the module uses the FP64A ABI</p>
            
            <pre><code>MIPS_FPABI_FP64A</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_NETBSD_NAMESZ">
            <h2>ELF_NOTE_NETBSD_NAMESZ</h2>
            <hr />
            
            <p>NetBSD Signature (as per sys/exec_elf.h)</p>
            
            <pre><code>ELF_NOTE_NETBSD_NAMESZ</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_NETBSD_DESCSZ">
            <h2>ELF_NOTE_NETBSD_DESCSZ</h2>
            <hr />
            
            <p>NetBSD Signature (as per sys/exec_elf.h)</p>
            
            <pre><code>ELF_NOTE_NETBSD_DESCSZ</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_NETBSD_TAG">
            <h2>ELF_NOTE_NETBSD_TAG</h2>
            <hr />
            
            <p>NetBSD Signature (as per sys/exec_elf.h)</p>
            
            <pre><code>ELF_NOTE_NETBSD_TAG</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_NETBSD_VERSION">
            <h2>ELF_NOTE_NETBSD_VERSION</h2>
            <hr />
            
            <p>NetBSD Signature (as per sys/exec_elf.h)</p>
            
            <pre><code>ELF_NOTE_NETBSD_VERSION</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_NETBSD_NAME">
            <h2>ELF_NOTE_NETBSD_NAME</h2>
            <hr />
            
            <pre><code>ELF_NOTE_NETBSD_NAME</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_OPENBSD_NAMESZ">
            <h2>ELF_NOTE_OPENBSD_NAMESZ</h2>
            <hr />
            
            <p>OpenBSD Signature</p>
            
            <pre><code>ELF_NOTE_OPENBSD_NAMESZ</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_OPENBSD_DESCSZ">
            <h2>ELF_NOTE_OPENBSD_DESCSZ</h2>
            <hr />
            
            <p>OpenBSD Signature</p>
            
            <pre><code>ELF_NOTE_OPENBSD_DESCSZ</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_OPENBSD_TAG">
            <h2>ELF_NOTE_OPENBSD_TAG</h2>
            <hr />
            
            <p>OpenBSD Signature</p>
            
            <pre><code>ELF_NOTE_OPENBSD_TAG</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_OPENBSD_VERSION">
            <h2>ELF_NOTE_OPENBSD_VERSION</h2>
            <hr />
            
            <p>OpenBSD Signature</p>
            
            <pre><code>ELF_NOTE_OPENBSD_VERSION</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_OPENBSD_NAME">
            <h2>ELF_NOTE_OPENBSD_NAME</h2>
            <hr />
            
            <pre><code>ELF_NOTE_OPENBSD_NAME</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_FREEBSD_NAMESZ">
            <h2>ELF_NOTE_FREEBSD_NAMESZ</h2>
            <hr />
            
            <p>FreeBSD Signature (as per sys/elf_common.h)</p>
            
            <pre><code>ELF_NOTE_FREEBSD_NAMESZ</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_FREEBSD_DESCSZ">
            <h2>ELF_NOTE_FREEBSD_DESCSZ</h2>
            <hr />
            
            <p>FreeBSD Signature (as per sys/elf_common.h)</p>
            
            <pre><code>ELF_NOTE_FREEBSD_DESCSZ</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_FREEBSD_ABI_TAG">
            <h2>ELF_NOTE_FREEBSD_ABI_TAG</h2>
            <hr />
            
            <p>FreeBSD Signature (as per sys/elf_common.h)</p>
            
            <pre><code>ELF_NOTE_FREEBSD_ABI_TAG</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_FREEBSD_NOINIT_TAG">
            <h2>ELF_NOTE_FREEBSD_NOINIT_TAG</h2>
            <hr />
            
            <p>FreeBSD Signature (as per sys/elf_common.h)</p>
            
            <pre><code>ELF_NOTE_FREEBSD_NOINIT_TAG</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_FREEBSD_FEATURE_CTL_TAG">
            <h2>ELF_NOTE_FREEBSD_FEATURE_CTL_TAG</h2>
            <hr />
            
            <p>FreeBSD Signature (as per sys/elf_common.h)</p>
            
            <pre><code>ELF_NOTE_FREEBSD_FEATURE_CTL_TAG</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_FREEBSD_VERSION">
            <h2>ELF_NOTE_FREEBSD_VERSION</h2>
            <hr />
            
            <p>FreeBSD Signature (as per sys/elf_common.h)</p>
            
            <pre><code>ELF_NOTE_FREEBSD_VERSION</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_FREEBSD_FCTL_ASLR_DISABLE">
            <h2>ELF_NOTE_FREEBSD_FCTL_ASLR_DISABLE</h2>
            <hr />
            
            <p>FreeBSD Signature (as per sys/elf_common.h)</p>
            
            <pre><code>ELF_NOTE_FREEBSD_FCTL_ASLR_DISABLE</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_FREEBSD_NAME">
            <h2>ELF_NOTE_FREEBSD_NAME</h2>
            <hr />
            
            <pre><code>ELF_NOTE_FREEBSD_NAME</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_BUILDINFO_NAMESZ">
            <h2>ELF_NOTE_BUILDINFO_NAMESZ</h2>
            <hr />
            
            <p>Build info note</p>
            
            <pre><code>ELF_NOTE_BUILDINFO_NAMESZ</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_BUILDINFO_TAG">
            <h2>ELF_NOTE_BUILDINFO_TAG</h2>
            <hr />
            
            <p>Build info note</p>
            
            <pre><code>ELF_NOTE_BUILDINFO_TAG</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_BUILDINFO_NAME">
            <h2>ELF_NOTE_BUILDINFO_NAME</h2>
            <hr />
            
            <pre><code>ELF_NOTE_BUILDINFO_NAME</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_GOPKGLIST_TAG">
            <h2>ELF_NOTE_GOPKGLIST_TAG</h2>
            <hr />
            
            <p>Go specific notes</p>
            
            <pre><code>ELF_NOTE_GOPKGLIST_TAG</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_GOABIHASH_TAG">
            <h2>ELF_NOTE_GOABIHASH_TAG</h2>
            <hr />
            
            <p>Go specific notes</p>
            
            <pre><code>ELF_NOTE_GOABIHASH_TAG</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_GODEPS_TAG">
            <h2>ELF_NOTE_GODEPS_TAG</h2>
            <hr />
            
            <p>Go specific notes</p>
            
            <pre><code>ELF_NOTE_GODEPS_TAG</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_GOBUILDID_TAG">
            <h2>ELF_NOTE_GOBUILDID_TAG</h2>
            <hr />
            
            <p>Go specific notes</p>
            
            <pre><code>ELF_NOTE_GOBUILDID_TAG</code></pre>
         </article>
         
         <article class="global" data-name="ELF_NOTE_GO_NAME">
            <h2>ELF_NOTE_GO_NAME</h2>
            <hr />
            
            <pre><code>ELF_NOTE_GO_NAME</code></pre>
         </article>
         
         <article class="global" data-name="elfverneed">
            <h2>elfverneed</h2>
            <hr />
            
            <pre><code>elfverneed int</code></pre>
         </article>
         
         <article class="global" data-name="ifacecallsProg">
            <h2>ifacecallsProg</h2>
            <hr />
            
            <p>This program is intended to be just big/complicated enough that
we wind up with decent-sized .data.rel.ro.{typelink,itablink,gopclntab}
sections.</p>
            
            <pre><code>ifacecallsProg</code></pre>
         </article>
         
         <article class="global" data-name="pkglistfornote">
            <h2>pkglistfornote</h2>
            <hr />
            
            <pre><code>pkglistfornote []byte</code></pre>
         </article>
         
         <article class="global" data-name="windowsgui">
            <h2>windowsgui</h2>
            <hr />
            
            <pre><code>windowsgui bool</code></pre>
         </article>
         
         <article class="global" data-name="ownTmpDir">
            <h2>ownTmpDir</h2>
            <hr />
            
            <pre><code>ownTmpDir bool</code></pre>
         </article>
         
         <article class="global" data-name="flagBuildid">
            <h2>flagBuildid</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagBuildid</code></pre>
         </article>
         
         <article class="global" data-name="flagBindNow">
            <h2>flagBindNow</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagBindNow</code></pre>
         </article>
         
         <article class="global" data-name="flagOutfile">
            <h2>flagOutfile</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagOutfile</code></pre>
         </article>
         
         <article class="global" data-name="flagPluginPath">
            <h2>flagPluginPath</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagPluginPath</code></pre>
         </article>
         
         <article class="global" data-name="flagFipso">
            <h2>flagFipso</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagFipso</code></pre>
         </article>
         
         <article class="global" data-name="flagInstallSuffix">
            <h2>flagInstallSuffix</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagInstallSuffix</code></pre>
         </article>
         
         <article class="global" data-name="flagDumpDep">
            <h2>flagDumpDep</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagDumpDep</code></pre>
         </article>
         
         <article class="global" data-name="flagRace">
            <h2>flagRace</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagRace</code></pre>
         </article>
         
         <article class="global" data-name="flagMsan">
            <h2>flagMsan</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagMsan</code></pre>
         </article>
         
         <article class="global" data-name="flagAsan">
            <h2>flagAsan</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagAsan</code></pre>
         </article>
         
         <article class="global" data-name="flagAslr">
            <h2>flagAslr</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagAslr</code></pre>
         </article>
         
         <article class="global" data-name="flagFieldTrack">
            <h2>flagFieldTrack</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagFieldTrack</code></pre>
         </article>
         
         <article class="global" data-name="flagLibGCC">
            <h2>flagLibGCC</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagLibGCC</code></pre>
         </article>
         
         <article class="global" data-name="flagTmpdir">
            <h2>flagTmpdir</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagTmpdir</code></pre>
         </article>
         
         <article class="global" data-name="flagExtld">
            <h2>flagExtld</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagExtld quoted.Flag</code></pre>
         </article>
         
         <article class="global" data-name="flagExtldflags">
            <h2>flagExtldflags</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagExtldflags quoted.Flag</code></pre>
         </article>
         
         <article class="global" data-name="flagExtar">
            <h2>flagExtar</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagExtar</code></pre>
         </article>
         
         <article class="global" data-name="flagCaptureHostObjs">
            <h2>flagCaptureHostObjs</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagCaptureHostObjs</code></pre>
         </article>
         
         <article class="global" data-name="flagA">
            <h2>flagA</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagA</code></pre>
         </article>
         
         <article class="global" data-name="FlagC">
            <h2>FlagC</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>FlagC</code></pre>
         </article>
         
         <article class="global" data-name="FlagD">
            <h2>FlagD</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>FlagD</code></pre>
         </article>
         
         <article class="global" data-name="flagF">
            <h2>flagF</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagF</code></pre>
         </article>
         
         <article class="global" data-name="flagG">
            <h2>flagG</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagG</code></pre>
         </article>
         
         <article class="global" data-name="flagH">
            <h2>flagH</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagH</code></pre>
         </article>
         
         <article class="global" data-name="flagN">
            <h2>flagN</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagN</code></pre>
         </article>
         
         <article class="global" data-name="FlagS">
            <h2>FlagS</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>FlagS</code></pre>
         </article>
         
         <article class="global" data-name="flag8">
            <h2>flag8</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flag8 bool</code></pre>
         </article>
         
         <article class="global" data-name="flagHostBuildid">
            <h2>flagHostBuildid</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagHostBuildid</code></pre>
         </article>
         
         <article class="global" data-name="flagInterpreter">
            <h2>flagInterpreter</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagInterpreter</code></pre>
         </article>
         
         <article class="global" data-name="flagCheckLinkname">
            <h2>flagCheckLinkname</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagCheckLinkname</code></pre>
         </article>
         
         <article class="global" data-name="FlagDebugTramp">
            <h2>FlagDebugTramp</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>FlagDebugTramp</code></pre>
         </article>
         
         <article class="global" data-name="FlagDebugTextSize">
            <h2>FlagDebugTextSize</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>FlagDebugTextSize</code></pre>
         </article>
         
         <article class="global" data-name="flagDebugNosplit">
            <h2>flagDebugNosplit</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagDebugNosplit</code></pre>
         </article>
         
         <article class="global" data-name="FlagStrictDups">
            <h2>FlagStrictDups</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>FlagStrictDups</code></pre>
         </article>
         
         <article class="global" data-name="FlagRound">
            <h2>FlagRound</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>FlagRound</code></pre>
         </article>
         
         <article class="global" data-name="FlagTextAddr">
            <h2>FlagTextAddr</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>FlagTextAddr</code></pre>
         </article>
         
         <article class="global" data-name="flagEntrySymbol">
            <h2>flagEntrySymbol</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagEntrySymbol</code></pre>
         </article>
         
         <article class="global" data-name="flagPruneWeakMap">
            <h2>flagPruneWeakMap</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagPruneWeakMap</code></pre>
         </article>
         
         <article class="global" data-name="flagRandLayout">
            <h2>flagRandLayout</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagRandLayout</code></pre>
         </article>
         
         <article class="global" data-name="cpuprofile">
            <h2>cpuprofile</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>cpuprofile</code></pre>
         </article>
         
         <article class="global" data-name="memprofile">
            <h2>memprofile</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>memprofile</code></pre>
         </article>
         
         <article class="global" data-name="memprofilerate">
            <h2>memprofilerate</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>memprofilerate</code></pre>
         </article>
         
         <article class="global" data-name="benchmarkFlag">
            <h2>benchmarkFlag</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>benchmarkFlag</code></pre>
         </article>
         
         <article class="global" data-name="benchmarkFileFlag">
            <h2>benchmarkFileFlag</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>benchmarkFileFlag</code></pre>
         </article>
         
         <article class="global" data-name="flagW">
            <h2>flagW</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>flagW ternaryFlag</code></pre>
         </article>
         
         <article class="global" data-name="FlagW">
            <h2>FlagW</h2>
            <hr />
            
            <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
            
            <pre><code>FlagW</code></pre>
         </article>
         
         <article class="global" data-name="ternaryFlagUnset">
            <h2>ternaryFlagUnset</h2>
            <hr />
            
            <pre><code>ternaryFlagUnset ternaryFlag</code></pre>
         </article>
         
         <article class="global" data-name="ternaryFlagFalse">
            <h2>ternaryFlagFalse</h2>
            <hr />
            
            <pre><code>ternaryFlagFalse</code></pre>
         </article>
         
         <article class="global" data-name="ternaryFlagTrue">
            <h2>ternaryFlagTrue</h2>
            <hr />
            
            <pre><code>ternaryFlagTrue</code></pre>
         </article>
         
         <article class="global" data-name="enableFIPS">
            <h2>enableFIPS</h2>
            <hr />
            
            <pre><code>enableFIPS</code></pre>
         </article>
         
         <article class="global" data-name="fipsSyms">
            <h2>fipsSyms</h2>
            <hr />
            
            <p>fipsSyms are the special FIPS section bracketing symbols.</p>
            
            <pre><code>fipsSyms</code></pre>
         </article>
         
         <article class="global" data-name="fipsinfo">
            <h2>fipsinfo</h2>
            <hr />
            
            <p>fipsinfo is the loader symbol for go:fipsinfo.</p>
            
            <pre><code>fipsinfo loader.Sym</code></pre>
         </article>
         
         <article class="global" data-name="fipsMagic">
            <h2>fipsMagic</h2>
            <hr />
            
            <pre><code>fipsMagic</code></pre>
         </article>
         
         <article class="global" data-name="fipsMagicLen">
            <h2>fipsMagicLen</h2>
            <hr />
            
            <pre><code>fipsMagicLen</code></pre>
         </article>
         
         <article class="global" data-name="fipsSumLen">
            <h2>fipsSumLen</h2>
            <hr />
            
            <pre><code>fipsSumLen</code></pre>
         </article>
         
         <article class="global" data-name="errNoFallocate">
            <h2>errNoFallocate</h2>
            <hr />
            
            <p>If fallocate is not supported on this platform, return this error. The error
is ignored where needed, and OutBuf writes to heap memory.</p>
            
            <pre><code>errNoFallocate</code></pre>
         </article>
         
         <article class="global" data-name="outbufMode">
            <h2>outbufMode</h2>
            <hr />
            
            <pre><code>outbufMode</code></pre>
         </article>
         
         <article class="global" data-name="viewError">
            <h2>viewError</h2>
            <hr />
            
            <pre><code>viewError</code></pre>
         </article>
         
         <article class="global" data-name="viewCloseError">
            <h2>viewCloseError</h2>
            <hr />
            
            <pre><code>viewCloseError</code></pre>
         </article>
         
         <article class="global" data-name="maxOutBufHeapLen">
            <h2>maxOutBufHeapLen</h2>
            <hr />
            
            <p>maxOutBufHeapLen limits the growth of the heap area.</p>
            
            <pre><code>maxOutBufHeapLen</code></pre>
         </article>
         
         <article class="global" data-name="funcSize">
            <h2>funcSize</h2>
            <hr />
            
            <pre><code>funcSize</code></pre>
         </article>
         
         <article class="global" data-name="SUBBUCKETS">
            <h2>SUBBUCKETS</h2>
            <hr />
            
            <pre><code>SUBBUCKETS</code></pre>
         </article>
         
         <article class="global" data-name="SUBBUCKETSIZE">
            <h2>SUBBUCKETSIZE</h2>
            <hr />
            
            <pre><code>SUBBUCKETSIZE</code></pre>
         </article>
         
         <article class="global" data-name="NOIDX">
            <h2>NOIDX</h2>
            <hr />
            
            <pre><code>NOIDX</code></pre>
         </article>
         
         <article class="global" data-name="XCOFFHDRRESERVE">
            <h2>XCOFFHDRRESERVE</h2>
            <hr />
            
            <p>Total amount of space to reserve at the start of the file
for File Header, Auxiliary Header, and Section Headers.
May waste some.</p>
            
            <pre><code>XCOFFHDRRESERVE</code></pre>
         </article>
         
         <article class="global" data-name="XCOFFSECTALIGN">
            <h2>XCOFFSECTALIGN</h2>
            <hr />
            
            <p>base on dump -o, then rounded from 32B to 64B to
match worst case elf text section alignment on ppc64.</p>
            
            <pre><code>XCOFFSECTALIGN int64</code></pre>
         </article>
         
         <article class="global" data-name="XCOFFTEXTBASE">
            <h2>XCOFFTEXTBASE</h2>
            <hr />
            
            <p>XCOFF binaries should normally have all its sections position-independent.
However, this is not yet possible for .text because of some R_ADDR relocations
inside RODATA symbols.
.data and .bss are position-independent so their address start inside an unreachable
segment during execution to force segfault if something is wrong.</p>
            
            <pre><code>XCOFFTEXTBASE</code></pre>
         </article>
         
         <article class="global" data-name="XCOFFDATABASE">
            <h2>XCOFFDATABASE</h2>
            <hr />
            
            <pre><code>XCOFFDATABASE</code></pre>
         </article>
         
         <article class="global" data-name="U64_TOCMAGIC">
            <h2>U64_TOCMAGIC</h2>
            <hr />
            
            <pre><code>U64_TOCMAGIC</code></pre>
         </article>
         
         <article class="global" data-name="F_RELFLG">
            <h2>F_RELFLG</h2>
            <hr />
            
            <p>Flags that describe the type of the object file.</p>
            
            <pre><code>F_RELFLG</code></pre>
         </article>
         
         <article class="global" data-name="F_EXEC">
            <h2>F_EXEC</h2>
            <hr />
            
            <p>Flags that describe the type of the object file.</p>
            
            <pre><code>F_EXEC</code></pre>
         </article>
         
         <article class="global" data-name="F_LNNO">
            <h2>F_LNNO</h2>
            <hr />
            
            <p>Flags that describe the type of the object file.</p>
            
            <pre><code>F_LNNO</code></pre>
         </article>
         
         <article class="global" data-name="F_FDPR_PROF">
            <h2>F_FDPR_PROF</h2>
            <hr />
            
            <p>Flags that describe the type of the object file.</p>
            
            <pre><code>F_FDPR_PROF</code></pre>
         </article>
         
         <article class="global" data-name="F_FDPR_OPTI">
            <h2>F_FDPR_OPTI</h2>
            <hr />
            
            <p>Flags that describe the type of the object file.</p>
            
            <pre><code>F_FDPR_OPTI</code></pre>
         </article>
         
         <article class="global" data-name="F_DSA">
            <h2>F_DSA</h2>
            <hr />
            
            <p>Flags that describe the type of the object file.</p>
            
            <pre><code>F_DSA</code></pre>
         </article>
         
         <article class="global" data-name="F_VARPG">
            <h2>F_VARPG</h2>
            <hr />
            
            <p>Flags that describe the type of the object file.</p>
            
            <pre><code>F_VARPG</code></pre>
         </article>
         
         <article class="global" data-name="F_DYNLOAD">
            <h2>F_DYNLOAD</h2>
            <hr />
            
            <p>Flags that describe the type of the object file.</p>
            
            <pre><code>F_DYNLOAD</code></pre>
         </article>
         
         <article class="global" data-name="F_SHROBJ">
            <h2>F_SHROBJ</h2>
            <hr />
            
            <p>Flags that describe the type of the object file.</p>
            
            <pre><code>F_SHROBJ</code></pre>
         </article>
         
         <article class="global" data-name="F_LOADONLY">
            <h2>F_LOADONLY</h2>
            <hr />
            
            <p>Flags that describe the type of the object file.</p>
            
            <pre><code>F_LOADONLY</code></pre>
         </article>
         
         <article class="global" data-name="STYP_DWARF">
            <h2>STYP_DWARF</h2>
            <hr />
            
            <p>Flags defining the section type.</p>
            
            <pre><code>STYP_DWARF</code></pre>
         </article>
         
         <article class="global" data-name="STYP_TEXT">
            <h2>STYP_TEXT</h2>
            <hr />
            
            <p>Flags defining the section type.</p>
            
            <pre><code>STYP_TEXT</code></pre>
         </article>
         
         <article class="global" data-name="STYP_DATA">
            <h2>STYP_DATA</h2>
            <hr />
            
            <p>Flags defining the section type.</p>
            
            <pre><code>STYP_DATA</code></pre>
         </article>
         
         <article class="global" data-name="STYP_BSS">
            <h2>STYP_BSS</h2>
            <hr />
            
            <p>Flags defining the section type.</p>
            
            <pre><code>STYP_BSS</code></pre>
         </article>
         
         <article class="global" data-name="STYP_EXCEPT">
            <h2>STYP_EXCEPT</h2>
            <hr />
            
            <p>Flags defining the section type.</p>
            
            <pre><code>STYP_EXCEPT</code></pre>
         </article>
         
         <article class="global" data-name="STYP_INFO">
            <h2>STYP_INFO</h2>
            <hr />
            
            <p>Flags defining the section type.</p>
            
            <pre><code>STYP_INFO</code></pre>
         </article>
         
         <article class="global" data-name="STYP_TDATA">
            <h2>STYP_TDATA</h2>
            <hr />
            
            <p>Flags defining the section type.</p>
            
            <pre><code>STYP_TDATA</code></pre>
         </article>
         
         <article class="global" data-name="STYP_TBSS">
            <h2>STYP_TBSS</h2>
            <hr />
            
            <p>Flags defining the section type.</p>
            
            <pre><code>STYP_TBSS</code></pre>
         </article>
         
         <article class="global" data-name="STYP_LOADER">
            <h2>STYP_LOADER</h2>
            <hr />
            
            <p>Flags defining the section type.</p>
            
            <pre><code>STYP_LOADER</code></pre>
         </article>
         
         <article class="global" data-name="STYP_DEBUG">
            <h2>STYP_DEBUG</h2>
            <hr />
            
            <p>Flags defining the section type.</p>
            
            <pre><code>STYP_DEBUG</code></pre>
         </article>
         
         <article class="global" data-name="STYP_TYPCHK">
            <h2>STYP_TYPCHK</h2>
            <hr />
            
            <p>Flags defining the section type.</p>
            
            <pre><code>STYP_TYPCHK</code></pre>
         </article>
         
         <article class="global" data-name="STYP_OVRFLO">
            <h2>STYP_OVRFLO</h2>
            <hr />
            
            <p>Flags defining the section type.</p>
            
            <pre><code>STYP_OVRFLO</code></pre>
         </article>
         
         <article class="global" data-name="SSUBTYP_DWINFO">
            <h2>SSUBTYP_DWINFO</h2>
            <hr />
            
            <pre><code>SSUBTYP_DWINFO</code></pre>
         </article>
         
         <article class="global" data-name="SSUBTYP_DWLINE">
            <h2>SSUBTYP_DWLINE</h2>
            <hr />
            
            <pre><code>SSUBTYP_DWLINE</code></pre>
         </article>
         
         <article class="global" data-name="SSUBTYP_DWPBNMS">
            <h2>SSUBTYP_DWPBNMS</h2>
            <hr />
            
            <pre><code>SSUBTYP_DWPBNMS</code></pre>
         </article>
         
         <article class="global" data-name="SSUBTYP_DWPBTYP">
            <h2>SSUBTYP_DWPBTYP</h2>
            <hr />
            
            <pre><code>SSUBTYP_DWPBTYP</code></pre>
         </article>
         
         <article class="global" data-name="SSUBTYP_DWARNGE">
            <h2>SSUBTYP_DWARNGE</h2>
            <hr />
            
            <pre><code>SSUBTYP_DWARNGE</code></pre>
         </article>
         
         <article class="global" data-name="SSUBTYP_DWABREV">
            <h2>SSUBTYP_DWABREV</h2>
            <hr />
            
            <pre><code>SSUBTYP_DWABREV</code></pre>
         </article>
         
         <article class="global" data-name="SSUBTYP_DWSTR">
            <h2>SSUBTYP_DWSTR</h2>
            <hr />
            
            <pre><code>SSUBTYP_DWSTR</code></pre>
         </article>
         
         <article class="global" data-name="SSUBTYP_DWRNGES">
            <h2>SSUBTYP_DWRNGES</h2>
            <hr />
            
            <pre><code>SSUBTYP_DWRNGES</code></pre>
         </article>
         
         <article class="global" data-name="SSUBTYP_DWLOC">
            <h2>SSUBTYP_DWLOC</h2>
            <hr />
            
            <pre><code>SSUBTYP_DWLOC</code></pre>
         </article>
         
         <article class="global" data-name="SSUBTYP_DWFRAME">
            <h2>SSUBTYP_DWFRAME</h2>
            <hr />
            
            <pre><code>SSUBTYP_DWFRAME</code></pre>
         </article>
         
         <article class="global" data-name="SSUBTYP_DWMAC">
            <h2>SSUBTYP_DWMAC</h2>
            <hr />
            
            <pre><code>SSUBTYP_DWMAC</code></pre>
         </article>
         
         <article class="global" data-name="FILHSZ_32">
            <h2>FILHSZ_32</h2>
            <hr />
            
            <p>Headers size</p>
            
            <pre><code>FILHSZ_32</code></pre>
         </article>
         
         <article class="global" data-name="FILHSZ_64">
            <h2>FILHSZ_64</h2>
            <hr />
            
            <p>Headers size</p>
            
            <pre><code>FILHSZ_64</code></pre>
         </article>
         
         <article class="global" data-name="AOUTHSZ_EXEC32">
            <h2>AOUTHSZ_EXEC32</h2>
            <hr />
            
            <p>Headers size</p>
            
            <pre><code>AOUTHSZ_EXEC32</code></pre>
         </article>
         
         <article class="global" data-name="AOUTHSZ_EXEC64">
            <h2>AOUTHSZ_EXEC64</h2>
            <hr />
            
            <p>Headers size</p>
            
            <pre><code>AOUTHSZ_EXEC64</code></pre>
         </article>
         
         <article class="global" data-name="SCNHSZ_32">
            <h2>SCNHSZ_32</h2>
            <hr />
            
            <p>Headers size</p>
            
            <pre><code>SCNHSZ_32</code></pre>
         </article>
         
         <article class="global" data-name="SCNHSZ_64">
            <h2>SCNHSZ_64</h2>
            <hr />
            
            <p>Headers size</p>
            
            <pre><code>SCNHSZ_64</code></pre>
         </article>
         
         <article class="global" data-name="LDHDRSZ_32">
            <h2>LDHDRSZ_32</h2>
            <hr />
            
            <p>Headers size</p>
            
            <pre><code>LDHDRSZ_32</code></pre>
         </article>
         
         <article class="global" data-name="LDHDRSZ_64">
            <h2>LDHDRSZ_64</h2>
            <hr />
            
            <p>Headers size</p>
            
            <pre><code>LDHDRSZ_64</code></pre>
         </article>
         
         <article class="global" data-name="LDSYMSZ_64">
            <h2>LDSYMSZ_64</h2>
            <hr />
            
            <p>Headers size</p>
            
            <pre><code>LDSYMSZ_64</code></pre>
         </article>
         
         <article class="global" data-name="RELSZ_64">
            <h2>RELSZ_64</h2>
            <hr />
            
            <p>Headers size</p>
            
            <pre><code>RELSZ_64</code></pre>
         </article>
         
         <article class="global" data-name="SYMESZ">
            <h2>SYMESZ</h2>
            <hr />
            
            <pre><code>SYMESZ</code></pre>
         </article>
         
         <article class="global" data-name="N_DEBUG">
            <h2>N_DEBUG</h2>
            <hr />
            
            <p>Nscnum</p>
            
            <pre><code>N_DEBUG</code></pre>
         </article>
         
         <article class="global" data-name="N_ABS">
            <h2>N_ABS</h2>
            <hr />
            
            <pre><code>N_ABS</code></pre>
         </article>
         
         <article class="global" data-name="N_UNDEF">
            <h2>N_UNDEF</h2>
            <hr />
            
            <pre><code>N_UNDEF</code></pre>
         </article>
         
         <article class="global" data-name="SYM_V_INTERNAL">
            <h2>SYM_V_INTERNAL</h2>
            <hr />
            
            <p>Ntype</p>
            
            <pre><code>SYM_V_INTERNAL</code></pre>
         </article>
         
         <article class="global" data-name="SYM_V_HIDDEN">
            <h2>SYM_V_HIDDEN</h2>
            <hr />
            
            <pre><code>SYM_V_HIDDEN</code></pre>
         </article>
         
         <article class="global" data-name="SYM_V_PROTECTED">
            <h2>SYM_V_PROTECTED</h2>
            <hr />
            
            <pre><code>SYM_V_PROTECTED</code></pre>
         </article>
         
         <article class="global" data-name="SYM_V_EXPORTED">
            <h2>SYM_V_EXPORTED</h2>
            <hr />
            
            <pre><code>SYM_V_EXPORTED</code></pre>
         </article>
         
         <article class="global" data-name="SYM_TYPE_FUNC">
            <h2>SYM_TYPE_FUNC</h2>
            <hr />
            
            <pre><code>SYM_TYPE_FUNC</code></pre>
         </article>
         
         <article class="global" data-name="C_NULL">
            <h2>C_NULL</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_NULL</code></pre>
         </article>
         
         <article class="global" data-name="C_EXT">
            <h2>C_EXT</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_EXT</code></pre>
         </article>
         
         <article class="global" data-name="C_STAT">
            <h2>C_STAT</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_STAT</code></pre>
         </article>
         
         <article class="global" data-name="C_BLOCK">
            <h2>C_BLOCK</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_BLOCK</code></pre>
         </article>
         
         <article class="global" data-name="C_FCN">
            <h2>C_FCN</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_FCN</code></pre>
         </article>
         
         <article class="global" data-name="C_FILE">
            <h2>C_FILE</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_FILE</code></pre>
         </article>
         
         <article class="global" data-name="C_HIDEXT">
            <h2>C_HIDEXT</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_HIDEXT</code></pre>
         </article>
         
         <article class="global" data-name="C_BINCL">
            <h2>C_BINCL</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_BINCL</code></pre>
         </article>
         
         <article class="global" data-name="C_EINCL">
            <h2>C_EINCL</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_EINCL</code></pre>
         </article>
         
         <article class="global" data-name="C_WEAKEXT">
            <h2>C_WEAKEXT</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_WEAKEXT</code></pre>
         </article>
         
         <article class="global" data-name="C_DWARF">
            <h2>C_DWARF</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_DWARF</code></pre>
         </article>
         
         <article class="global" data-name="C_GSYM">
            <h2>C_GSYM</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_GSYM</code></pre>
         </article>
         
         <article class="global" data-name="C_LSYM">
            <h2>C_LSYM</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_LSYM</code></pre>
         </article>
         
         <article class="global" data-name="C_PSYM">
            <h2>C_PSYM</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_PSYM</code></pre>
         </article>
         
         <article class="global" data-name="C_RSYM">
            <h2>C_RSYM</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_RSYM</code></pre>
         </article>
         
         <article class="global" data-name="C_RPSYM">
            <h2>C_RPSYM</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_RPSYM</code></pre>
         </article>
         
         <article class="global" data-name="C_STSYM">
            <h2>C_STSYM</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_STSYM</code></pre>
         </article>
         
         <article class="global" data-name="C_BCOMM">
            <h2>C_BCOMM</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_BCOMM</code></pre>
         </article>
         
         <article class="global" data-name="C_ECOML">
            <h2>C_ECOML</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_ECOML</code></pre>
         </article>
         
         <article class="global" data-name="C_ECOMM">
            <h2>C_ECOMM</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_ECOMM</code></pre>
         </article>
         
         <article class="global" data-name="C_DECL">
            <h2>C_DECL</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_DECL</code></pre>
         </article>
         
         <article class="global" data-name="C_ENTRY">
            <h2>C_ENTRY</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_ENTRY</code></pre>
         </article>
         
         <article class="global" data-name="C_FUN">
            <h2>C_FUN</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_FUN</code></pre>
         </article>
         
         <article class="global" data-name="C_BSTAT">
            <h2>C_BSTAT</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_BSTAT</code></pre>
         </article>
         
         <article class="global" data-name="C_ESTAT">
            <h2>C_ESTAT</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_ESTAT</code></pre>
         </article>
         
         <article class="global" data-name="C_GTLS">
            <h2>C_GTLS</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_GTLS</code></pre>
         </article>
         
         <article class="global" data-name="C_STTLS">
            <h2>C_STTLS</h2>
            <hr />
            
            <p>Storage Class.</p>
            
            <pre><code>C_STTLS</code></pre>
         </article>
         
         <article class="global" data-name="_AUX_EXCEPT">
            <h2>_AUX_EXCEPT</h2>
            <hr />
            
            <p>Auxiliary type</p>
            
            <pre><code>_AUX_EXCEPT</code></pre>
         </article>
         
         <article class="global" data-name="_AUX_FCN">
            <h2>_AUX_FCN</h2>
            <hr />
            
            <p>Auxiliary type</p>
            
            <pre><code>_AUX_FCN</code></pre>
         </article>
         
         <article class="global" data-name="_AUX_SYM">
            <h2>_AUX_SYM</h2>
            <hr />
            
            <p>Auxiliary type</p>
            
            <pre><code>_AUX_SYM</code></pre>
         </article>
         
         <article class="global" data-name="_AUX_FILE">
            <h2>_AUX_FILE</h2>
            <hr />
            
            <p>Auxiliary type</p>
            
            <pre><code>_AUX_FILE</code></pre>
         </article>
         
         <article class="global" data-name="_AUX_CSECT">
            <h2>_AUX_CSECT</h2>
            <hr />
            
            <p>Auxiliary type</p>
            
            <pre><code>_AUX_CSECT</code></pre>
         </article>
         
         <article class="global" data-name="_AUX_SECT">
            <h2>_AUX_SECT</h2>
            <hr />
            
            <p>Auxiliary type</p>
            
            <pre><code>_AUX_SECT</code></pre>
         </article>
         
         <article class="global" data-name="XFT_FN">
            <h2>XFT_FN</h2>
            <hr />
            
            <p>Xftype field</p>
            
            <pre><code>XFT_FN</code></pre>
         </article>
         
         <article class="global" data-name="XFT_CT">
            <h2>XFT_CT</h2>
            <hr />
            
            <p>Xftype field</p>
            
            <pre><code>XFT_CT</code></pre>
         </article>
         
         <article class="global" data-name="XFT_CV">
            <h2>XFT_CV</h2>
            <hr />
            
            <p>Xftype field</p>
            
            <pre><code>XFT_CV</code></pre>
         </article>
         
         <article class="global" data-name="XFT_CD">
            <h2>XFT_CD</h2>
            <hr />
            
            <p>Xftype field</p>
            
            <pre><code>XFT_CD</code></pre>
         </article>
         
         <article class="global" data-name="XTY_ER">
            <h2>XTY_ER</h2>
            <hr />
            
            <p>Symbol type field.</p>
            
            <pre><code>XTY_ER</code></pre>
         </article>
         
         <article class="global" data-name="XTY_SD">
            <h2>XTY_SD</h2>
            <hr />
            
            <p>Symbol type field.</p>
            
            <pre><code>XTY_SD</code></pre>
         </article>
         
         <article class="global" data-name="XTY_LD">
            <h2>XTY_LD</h2>
            <hr />
            
            <p>Symbol type field.</p>
            
            <pre><code>XTY_LD</code></pre>
         </article>
         
         <article class="global" data-name="XTY_CM">
            <h2>XTY_CM</h2>
            <hr />
            
            <p>Symbol type field.</p>
            
            <pre><code>XTY_CM</code></pre>
         </article>
         
         <article class="global" data-name="XTY_WK">
            <h2>XTY_WK</h2>
            <hr />
            
            <p>Symbol type field.</p>
            
            <pre><code>XTY_WK</code></pre>
         </article>
         
         <article class="global" data-name="XTY_EXP">
            <h2>XTY_EXP</h2>
            <hr />
            
            <p>Symbol type field.</p>
            
            <pre><code>XTY_EXP</code></pre>
         </article>
         
         <article class="global" data-name="XTY_ENT">
            <h2>XTY_ENT</h2>
            <hr />
            
            <p>Symbol type field.</p>
            
            <pre><code>XTY_ENT</code></pre>
         </article>
         
         <article class="global" data-name="XTY_IMP">
            <h2>XTY_IMP</h2>
            <hr />
            
            <p>Symbol type field.</p>
            
            <pre><code>XTY_IMP</code></pre>
         </article>
         
         <article class="global" data-name="XMC_PR">
            <h2>XMC_PR</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_PR</code></pre>
         </article>
         
         <article class="global" data-name="XMC_RO">
            <h2>XMC_RO</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_RO</code></pre>
         </article>
         
         <article class="global" data-name="XMC_DB">
            <h2>XMC_DB</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_DB</code></pre>
         </article>
         
         <article class="global" data-name="XMC_TC">
            <h2>XMC_TC</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_TC</code></pre>
         </article>
         
         <article class="global" data-name="XMC_UA">
            <h2>XMC_UA</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_UA</code></pre>
         </article>
         
         <article class="global" data-name="XMC_RW">
            <h2>XMC_RW</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_RW</code></pre>
         </article>
         
         <article class="global" data-name="XMC_GL">
            <h2>XMC_GL</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_GL</code></pre>
         </article>
         
         <article class="global" data-name="XMC_XO">
            <h2>XMC_XO</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_XO</code></pre>
         </article>
         
         <article class="global" data-name="XMC_SV">
            <h2>XMC_SV</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_SV</code></pre>
         </article>
         
         <article class="global" data-name="XMC_BS">
            <h2>XMC_BS</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_BS</code></pre>
         </article>
         
         <article class="global" data-name="XMC_DS">
            <h2>XMC_DS</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_DS</code></pre>
         </article>
         
         <article class="global" data-name="XMC_UC">
            <h2>XMC_UC</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_UC</code></pre>
         </article>
         
         <article class="global" data-name="XMC_TC0">
            <h2>XMC_TC0</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_TC0</code></pre>
         </article>
         
         <article class="global" data-name="XMC_TD">
            <h2>XMC_TD</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_TD</code></pre>
         </article>
         
         <article class="global" data-name="XMC_SV64">
            <h2>XMC_SV64</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_SV64</code></pre>
         </article>
         
         <article class="global" data-name="XMC_SV3264">
            <h2>XMC_SV3264</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_SV3264</code></pre>
         </article>
         
         <article class="global" data-name="XMC_TL">
            <h2>XMC_TL</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_TL</code></pre>
         </article>
         
         <article class="global" data-name="XMC_UL">
            <h2>XMC_UL</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_UL</code></pre>
         </article>
         
         <article class="global" data-name="XMC_TE">
            <h2>XMC_TE</h2>
            <hr />
            
            <p>Storage-mapping class.</p>
            
            <pre><code>XMC_TE</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_POS">
            <h2>XCOFF_R_POS</h2>
            <hr />
            
            <pre><code>XCOFF_R_POS</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_NEG">
            <h2>XCOFF_R_NEG</h2>
            <hr />
            
            <pre><code>XCOFF_R_NEG</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_REL">
            <h2>XCOFF_R_REL</h2>
            <hr />
            
            <pre><code>XCOFF_R_REL</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_TOC">
            <h2>XCOFF_R_TOC</h2>
            <hr />
            
            <pre><code>XCOFF_R_TOC</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_TRL">
            <h2>XCOFF_R_TRL</h2>
            <hr />
            
            <pre><code>XCOFF_R_TRL</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_TRLA">
            <h2>XCOFF_R_TRLA</h2>
            <hr />
            
            <pre><code>XCOFF_R_TRLA</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_GL">
            <h2>XCOFF_R_GL</h2>
            <hr />
            
            <pre><code>XCOFF_R_GL</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_TCL">
            <h2>XCOFF_R_TCL</h2>
            <hr />
            
            <pre><code>XCOFF_R_TCL</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_RL">
            <h2>XCOFF_R_RL</h2>
            <hr />
            
            <pre><code>XCOFF_R_RL</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_RLA">
            <h2>XCOFF_R_RLA</h2>
            <hr />
            
            <pre><code>XCOFF_R_RLA</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_REF">
            <h2>XCOFF_R_REF</h2>
            <hr />
            
            <pre><code>XCOFF_R_REF</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_BA">
            <h2>XCOFF_R_BA</h2>
            <hr />
            
            <pre><code>XCOFF_R_BA</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_RBA">
            <h2>XCOFF_R_RBA</h2>
            <hr />
            
            <pre><code>XCOFF_R_RBA</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_BR">
            <h2>XCOFF_R_BR</h2>
            <hr />
            
            <pre><code>XCOFF_R_BR</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_RBR">
            <h2>XCOFF_R_RBR</h2>
            <hr />
            
            <pre><code>XCOFF_R_RBR</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_TLS">
            <h2>XCOFF_R_TLS</h2>
            <hr />
            
            <pre><code>XCOFF_R_TLS</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_TLS_IE">
            <h2>XCOFF_R_TLS_IE</h2>
            <hr />
            
            <pre><code>XCOFF_R_TLS_IE</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_TLS_LD">
            <h2>XCOFF_R_TLS_LD</h2>
            <hr />
            
            <pre><code>XCOFF_R_TLS_LD</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_TLS_LE">
            <h2>XCOFF_R_TLS_LE</h2>
            <hr />
            
            <pre><code>XCOFF_R_TLS_LE</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_TLSM">
            <h2>XCOFF_R_TLSM</h2>
            <hr />
            
            <pre><code>XCOFF_R_TLSM</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_TLSML">
            <h2>XCOFF_R_TLSML</h2>
            <hr />
            
            <pre><code>XCOFF_R_TLSML</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_TOCU">
            <h2>XCOFF_R_TOCU</h2>
            <hr />
            
            <pre><code>XCOFF_R_TOCU</code></pre>
         </article>
         
         <article class="global" data-name="XCOFF_R_TOCL">
            <h2>XCOFF_R_TOCL</h2>
            <hr />
            
            <pre><code>XCOFF_R_TOCL</code></pre>
         </article>
         
         <article class="global" data-name="xfile">
            <h2>xfile</h2>
            <hr />
            
            <p>Var used by XCOFF Generation algorithms</p>
            
            <pre><code>xfile xcoffFile</code></pre>
         </article>
         
         <article class="global" data-name="currDwscnoff">
            <h2>currDwscnoff</h2>
            <hr />
            
            <pre><code>currDwscnoff</code></pre>
         </article>
         
         <article class="global" data-name="currSymSrcFile">
            <h2>currSymSrcFile</h2>
            <hr />
            
            <pre><code>currSymSrcFile xcoffSymSrcFile</code></pre>
         </article>
         
         <article class="global" data-name="outerSymSize">
            <h2>outerSymSize</h2>
            <hr />
            
            <pre><code>outerSymSize</code></pre>
         </article>
         
         <article class="global" data-name="SARMAG">
            <h2>SARMAG</h2>
            <hr />
            
            <pre><code>SARMAG</code></pre>
         </article>
         
         <article class="global" data-name="SAR_HDR">
            <h2>SAR_HDR</h2>
            <hr />
            
            <pre><code>SAR_HDR</code></pre>
         </article>
         
         <article class="global" data-name="ARMAG">
            <h2>ARMAG</h2>
            <hr />
            
            <pre><code>ARMAG</code></pre>
         </article>
         
         <article class="global" data-name="sehp">
            <h2>sehp</h2>
            <hr />
            
            <pre><code>sehp *ast.StructType</code></pre>
         </article>
         
         <article class="global" data-name="atExitFuncs">
            <h2>atExitFuncs</h2>
            <hr />
            
            <pre><code>atExitFuncs []func</code></pre>
         </article>
         
         <article class="global" data-name="thearch">
            <h2>thearch</h2>
            <hr />
            
            <pre><code>thearch Arch</code></pre>
         </article>
         
         <article class="global" data-name="lcSize">
            <h2>lcSize</h2>
            <hr />
            
            <pre><code>lcSize int32</code></pre>
         </article>
         
         <article class="global" data-name="rpath">
            <h2>rpath</h2>
            <hr />
            
            <pre><code>rpath Rpath</code></pre>
         </article>
         
         <article class="global" data-name="spSize">
            <h2>spSize</h2>
            <hr />
            
            <pre><code>spSize int32</code></pre>
         </article>
         
         <article class="global" data-name="symSize">
            <h2>symSize</h2>
            <hr />
            
            <pre><code>symSize int32</code></pre>
         </article>
         
         <article class="global" data-name="abiInternalVer">
            <h2>abiInternalVer</h2>
            <hr />
            
            <p>Symbol version of ABIInternal symbols. It is sym.SymVerABIInternal if ABI wrappers
are used, 0 otherwise.</p>
            
            <pre><code>abiInternalVer</code></pre>
         </article>
         
         <article class="global" data-name="dynlib">
            <h2>dynlib</h2>
            <hr />
            
            <pre><code>dynlib []string</code></pre>
         </article>
         
         <article class="global" data-name="ldflag">
            <h2>ldflag</h2>
            <hr />
            
            <pre><code>ldflag []string</code></pre>
         </article>
         
         <article class="global" data-name="havedynamic">
            <h2>havedynamic</h2>
            <hr />
            
            <pre><code>havedynamic int</code></pre>
         </article>
         
         <article class="global" data-name="Funcalign">
            <h2>Funcalign</h2>
            <hr />
            
            <pre><code>Funcalign int</code></pre>
         </article>
         
         <article class="global" data-name="iscgo">
            <h2>iscgo</h2>
            <hr />
            
            <pre><code>iscgo bool</code></pre>
         </article>
         
         <article class="global" data-name="elfglobalsymndx">
            <h2>elfglobalsymndx</h2>
            <hr />
            
            <pre><code>elfglobalsymndx int</code></pre>
         </article>
         
         <article class="global" data-name="interpreter">
            <h2>interpreter</h2>
            <hr />
            
            <pre><code>interpreter string</code></pre>
         </article>
         
         <article class="global" data-name="debug_s">
            <h2>debug_s</h2>
            <hr />
            
            <pre><code>debug_s bool</code></pre>
         </article>
         
         <article class="global" data-name="HEADR">
            <h2>HEADR</h2>
            <hr />
            
            <pre><code>HEADR int32</code></pre>
         </article>
         
         <article class="global" data-name="nerrors">
            <h2>nerrors</h2>
            <hr />
            
            <pre><code>nerrors int</code></pre>
         </article>
         
         <article class="global" data-name="liveness">
            <h2>liveness</h2>
            <hr />
            
            <pre><code>liveness int64</code></pre>
         </article>
         
         <article class="global" data-name="checkStrictDups">
            <h2>checkStrictDups</h2>
            <hr />
            
            <p>See -strictdups command line flag.</p>
            
            <pre><code>checkStrictDups int</code></pre>
         </article>
         
         <article class="global" data-name="strictDupMsgCount">
            <h2>strictDupMsgCount</h2>
            <hr />
            
            <pre><code>strictDupMsgCount int</code></pre>
         </article>
         
         <article class="global" data-name="Segtext">
            <h2>Segtext</h2>
            <hr />
            
            <pre><code>Segtext sym.Segment</code></pre>
         </article>
         
         <article class="global" data-name="Segrodata">
            <h2>Segrodata</h2>
            <hr />
            
            <pre><code>Segrodata sym.Segment</code></pre>
         </article>
         
         <article class="global" data-name="Segrelrodata">
            <h2>Segrelrodata</h2>
            <hr />
            
            <pre><code>Segrelrodata sym.Segment</code></pre>
         </article>
         
         <article class="global" data-name="Segdata">
            <h2>Segdata</h2>
            <hr />
            
            <pre><code>Segdata sym.Segment</code></pre>
         </article>
         
         <article class="global" data-name="Segdwarf">
            <h2>Segdwarf</h2>
            <hr />
            
            <pre><code>Segdwarf sym.Segment</code></pre>
         </article>
         
         <article class="global" data-name="Segpdata">
            <h2>Segpdata</h2>
            <hr />
            
            <pre><code>Segpdata sym.Segment</code></pre>
         </article>
         
         <article class="global" data-name="Segxdata">
            <h2>Segxdata</h2>
            <hr />
            
            <pre><code>Segxdata sym.Segment</code></pre>
         </article>
         
         <article class="global" data-name="Segments">
            <h2>Segments</h2>
            <hr />
            
            <pre><code>Segments</code></pre>
         </article>
         
         <article class="global" data-name="pkgdef">
            <h2>pkgdef</h2>
            <hr />
            
            <pre><code>pkgdef</code></pre>
         </article>
         
         <article class="global" data-name="externalobj">
            <h2>externalobj</h2>
            <hr />
            
            <p>externalobj is set to true if we see an object compiled by
the host compiler that is not from a package that is known
to support internal linking mode.</p>
            
            <pre><code>externalobj</code></pre>
         </article>
         
         <article class="global" data-name="dynimportfail">
            <h2>dynimportfail</h2>
            <hr />
            
            <p>dynimportfail is a list of packages for which generating
the dynimport file, _cgo_import.go, failed. If there are
any of these objects, we must link externally. Issue 52863.</p>
            
            <pre><code>dynimportfail []string</code></pre>
         </article>
         
         <article class="global" data-name="preferlinkext">
            <h2>preferlinkext</h2>
            <hr />
            
            <p>preferlinkext is a list of packages for which the Go command
noticed use of peculiar C flags. If we see any of these,
default to linking externally unless overridden by the
user. See issues #58619, #58620, and #58848.</p>
            
            <pre><code>preferlinkext []string</code></pre>
         </article>
         
         <article class="global" data-name="unknownObjFormat">
            <h2>unknownObjFormat</h2>
            <hr />
            
            <p>unknownObjFormat is set to true if we see an object whose
format we don't recognize.</p>
            
            <pre><code>unknownObjFormat</code></pre>
         </article>
         
         <article class="global" data-name="theline">
            <h2>theline</h2>
            <hr />
            
            <pre><code>theline string</code></pre>
         </article>
         
         <article class="global" data-name="hostobj">
            <h2>hostobj</h2>
            <hr />
            
            <pre><code>hostobj []Hostobj</code></pre>
         </article>
         
         <article class="global" data-name="internalpkg">
            <h2>internalpkg</h2>
            <hr />
            
            <p>These packages can use internal linking mode.
Others trigger external mode.</p>
            
            <pre><code>internalpkg</code></pre>
         </article>
         
         <article class="global" data-name="createTrivialCOnce">
            <h2>createTrivialCOnce</h2>
            <hr />
            
            <pre><code>createTrivialCOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="wantHdr">
            <h2>wantHdr</h2>
            <hr />
            
            <pre><code>wantHdr</code></pre>
         </article>
         
         <article class="global" data-name="TextSym">
            <h2>TextSym</h2>
            <hr />
            
            <p>see also https://9p.io/magic/man2html/1/nm</p>
            
            <pre><code>TextSym SymbolType</code></pre>
         </article>
         
         <article class="global" data-name="DataSym">
            <h2>DataSym</h2>
            <hr />
            
            <pre><code>DataSym SymbolType</code></pre>
         </article>
         
         <article class="global" data-name="BSSSym">
            <h2>BSSSym</h2>
            <hr />
            
            <pre><code>BSSSym SymbolType</code></pre>
         </article>
         
         <article class="global" data-name="UndefinedSym">
            <h2>UndefinedSym</h2>
            <hr />
            
            <pre><code>UndefinedSym SymbolType</code></pre>
         </article>
         
         <article class="global" data-name="TLSSym">
            <h2>TLSSym</h2>
            <hr />
            
            <pre><code>TLSSym SymbolType</code></pre>
         </article>
         
         <article class="global" data-name="FrameSym">
            <h2>FrameSym</h2>
            <hr />
            
            <pre><code>FrameSym SymbolType</code></pre>
         </article>
         
         <article class="global" data-name="ParamSym">
            <h2>ParamSym</h2>
            <hr />
            
            <pre><code>ParamSym SymbolType</code></pre>
         </article>
         
         <article class="global" data-name="AutoSym">
            <h2>AutoSym</h2>
            <hr />
            
            <pre><code>AutoSym SymbolType</code></pre>
         </article>
         
         <article class="global" data-name="DeletedAutoSym">
            <h2>DeletedAutoSym</h2>
            <hr />
            
            <p>Deleted auto (not a real sym, just placeholder for type)</p>
            
            <pre><code>DeletedAutoSym</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ markKind</code></pre>
         </article>
         
         <article class="global" data-name="visiting">
            <h2>visiting</h2>
            <hr />
            
            <pre><code>visiting</code></pre>
         </article>
         
         <article class="global" data-name="visited">
            <h2>visited</h2>
            <hr />
            
            <pre><code>visited</code></pre>
         </article>
         
         <article class="global" data-name="hostobjcounter">
            <h2>hostobjcounter</h2>
            <hr />
            
            <pre><code>hostobjcounter int</code></pre>
         </article>
         
         <article class="global" data-name="PEBASE">
            <h2>PEBASE</h2>
            <hr />
            
            <p>PEBASE is the base address for the executable.
It is small for 32-bit and large for 64-bit.</p>
            
            <pre><code>PEBASE int64</code></pre>
         </article>
         
         <article class="global" data-name="PESECTALIGN">
            <h2>PESECTALIGN</h2>
            <hr />
            
            <p>SectionAlignment must be greater than or equal to FileAlignment.
The default is the page size for the architecture.</p>
            
            <pre><code>PESECTALIGN int64</code></pre>
         </article>
         
         <article class="global" data-name="PEFILEALIGN">
            <h2>PEFILEALIGN</h2>
            <hr />
            
            <p>FileAlignment should be a power of 2 between 512 and 64 K, inclusive.
The default is 512. If the SectionAlignment is less than
the architecture's page size, then FileAlignment must match SectionAlignment.</p>
            
            <pre><code>PEFILEALIGN int64</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_CNT_CODE">
            <h2>IMAGE_SCN_CNT_CODE</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_CNT_CODE</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_CNT_INITIALIZED_DATA">
            <h2>IMAGE_SCN_CNT_INITIALIZED_DATA</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_CNT_INITIALIZED_DATA</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_CNT_UNINITIALIZED_DATA">
            <h2>IMAGE_SCN_CNT_UNINITIALIZED_DATA</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_CNT_UNINITIALIZED_DATA</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_LNK_OTHER">
            <h2>IMAGE_SCN_LNK_OTHER</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_LNK_OTHER</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_LNK_INFO">
            <h2>IMAGE_SCN_LNK_INFO</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_LNK_INFO</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_LNK_REMOVE">
            <h2>IMAGE_SCN_LNK_REMOVE</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_LNK_REMOVE</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_LNK_COMDAT">
            <h2>IMAGE_SCN_LNK_COMDAT</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_LNK_COMDAT</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_GPREL">
            <h2>IMAGE_SCN_GPREL</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_GPREL</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_MEM_PURGEABLE">
            <h2>IMAGE_SCN_MEM_PURGEABLE</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_MEM_PURGEABLE</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_MEM_16BIT">
            <h2>IMAGE_SCN_MEM_16BIT</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_MEM_16BIT</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_MEM_LOCKED">
            <h2>IMAGE_SCN_MEM_LOCKED</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_MEM_LOCKED</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_MEM_PRELOAD">
            <h2>IMAGE_SCN_MEM_PRELOAD</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_MEM_PRELOAD</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_ALIGN_1BYTES">
            <h2>IMAGE_SCN_ALIGN_1BYTES</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_ALIGN_1BYTES</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_ALIGN_2BYTES">
            <h2>IMAGE_SCN_ALIGN_2BYTES</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_ALIGN_2BYTES</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_ALIGN_4BYTES">
            <h2>IMAGE_SCN_ALIGN_4BYTES</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_ALIGN_4BYTES</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_ALIGN_8BYTES">
            <h2>IMAGE_SCN_ALIGN_8BYTES</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_ALIGN_8BYTES</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_ALIGN_16BYTES">
            <h2>IMAGE_SCN_ALIGN_16BYTES</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_ALIGN_16BYTES</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_ALIGN_32BYTES">
            <h2>IMAGE_SCN_ALIGN_32BYTES</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_ALIGN_32BYTES</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_ALIGN_64BYTES">
            <h2>IMAGE_SCN_ALIGN_64BYTES</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_ALIGN_64BYTES</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_ALIGN_128BYTES">
            <h2>IMAGE_SCN_ALIGN_128BYTES</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_ALIGN_128BYTES</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_ALIGN_256BYTES">
            <h2>IMAGE_SCN_ALIGN_256BYTES</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_ALIGN_256BYTES</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_ALIGN_512BYTES">
            <h2>IMAGE_SCN_ALIGN_512BYTES</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_ALIGN_512BYTES</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_ALIGN_1024BYTES">
            <h2>IMAGE_SCN_ALIGN_1024BYTES</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_ALIGN_1024BYTES</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_ALIGN_2048BYTES">
            <h2>IMAGE_SCN_ALIGN_2048BYTES</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_ALIGN_2048BYTES</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_ALIGN_4096BYTES">
            <h2>IMAGE_SCN_ALIGN_4096BYTES</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_ALIGN_4096BYTES</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_ALIGN_8192BYTES">
            <h2>IMAGE_SCN_ALIGN_8192BYTES</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_ALIGN_8192BYTES</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_LNK_NRELOC_OVFL">
            <h2>IMAGE_SCN_LNK_NRELOC_OVFL</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_LNK_NRELOC_OVFL</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_MEM_DISCARDABLE">
            <h2>IMAGE_SCN_MEM_DISCARDABLE</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_MEM_DISCARDABLE</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_MEM_NOT_CACHED">
            <h2>IMAGE_SCN_MEM_NOT_CACHED</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_MEM_NOT_CACHED</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_MEM_NOT_PAGED">
            <h2>IMAGE_SCN_MEM_NOT_PAGED</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_MEM_NOT_PAGED</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_MEM_SHARED">
            <h2>IMAGE_SCN_MEM_SHARED</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_MEM_SHARED</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_MEM_EXECUTE">
            <h2>IMAGE_SCN_MEM_EXECUTE</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_MEM_EXECUTE</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_MEM_READ">
            <h2>IMAGE_SCN_MEM_READ</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_MEM_READ</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SCN_MEM_WRITE">
            <h2>IMAGE_SCN_MEM_WRITE</h2>
            <hr />
            
            <pre><code>IMAGE_SCN_MEM_WRITE</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SYM_TYPE_NULL">
            <h2>IMAGE_SYM_TYPE_NULL</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_SYM_TYPE_NULL</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SYM_TYPE_STRUCT">
            <h2>IMAGE_SYM_TYPE_STRUCT</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_SYM_TYPE_STRUCT</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SYM_DTYPE_FUNCTION">
            <h2>IMAGE_SYM_DTYPE_FUNCTION</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_SYM_DTYPE_FUNCTION</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SYM_DTYPE_ARRAY">
            <h2>IMAGE_SYM_DTYPE_ARRAY</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_SYM_DTYPE_ARRAY</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SYM_CLASS_EXTERNAL">
            <h2>IMAGE_SYM_CLASS_EXTERNAL</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_SYM_CLASS_EXTERNAL</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_SYM_CLASS_STATIC">
            <h2>IMAGE_SYM_CLASS_STATIC</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_SYM_CLASS_STATIC</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_I386_DIR32">
            <h2>IMAGE_REL_I386_DIR32</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_I386_DIR32</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_I386_DIR32NB">
            <h2>IMAGE_REL_I386_DIR32NB</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_I386_DIR32NB</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_I386_SECREL">
            <h2>IMAGE_REL_I386_SECREL</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_I386_SECREL</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_I386_REL32">
            <h2>IMAGE_REL_I386_REL32</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_I386_REL32</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_AMD64_ADDR64">
            <h2>IMAGE_REL_AMD64_ADDR64</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_AMD64_ADDR64</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_AMD64_ADDR32">
            <h2>IMAGE_REL_AMD64_ADDR32</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_AMD64_ADDR32</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_AMD64_ADDR32NB">
            <h2>IMAGE_REL_AMD64_ADDR32NB</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_AMD64_ADDR32NB</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_AMD64_REL32">
            <h2>IMAGE_REL_AMD64_REL32</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_AMD64_REL32</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_AMD64_SECREL">
            <h2>IMAGE_REL_AMD64_SECREL</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_AMD64_SECREL</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM_ABSOLUTE">
            <h2>IMAGE_REL_ARM_ABSOLUTE</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM_ABSOLUTE</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM_ADDR32">
            <h2>IMAGE_REL_ARM_ADDR32</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM_ADDR32</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM_ADDR32NB">
            <h2>IMAGE_REL_ARM_ADDR32NB</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM_ADDR32NB</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM_BRANCH24">
            <h2>IMAGE_REL_ARM_BRANCH24</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM_BRANCH24</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM_BRANCH11">
            <h2>IMAGE_REL_ARM_BRANCH11</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM_BRANCH11</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM_SECREL">
            <h2>IMAGE_REL_ARM_SECREL</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM_SECREL</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_ABSOLUTE">
            <h2>IMAGE_REL_ARM64_ABSOLUTE</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_ABSOLUTE</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_ADDR32">
            <h2>IMAGE_REL_ARM64_ADDR32</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_ADDR32</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_ADDR32NB">
            <h2>IMAGE_REL_ARM64_ADDR32NB</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_ADDR32NB</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_BRANCH26">
            <h2>IMAGE_REL_ARM64_BRANCH26</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_BRANCH26</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_PAGEBASE_REL21">
            <h2>IMAGE_REL_ARM64_PAGEBASE_REL21</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_PAGEBASE_REL21</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_REL21">
            <h2>IMAGE_REL_ARM64_REL21</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_REL21</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_PAGEOFFSET_12A">
            <h2>IMAGE_REL_ARM64_PAGEOFFSET_12A</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_PAGEOFFSET_12A</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_PAGEOFFSET_12L">
            <h2>IMAGE_REL_ARM64_PAGEOFFSET_12L</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_PAGEOFFSET_12L</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_SECREL">
            <h2>IMAGE_REL_ARM64_SECREL</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_SECREL</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_SECREL_LOW12A">
            <h2>IMAGE_REL_ARM64_SECREL_LOW12A</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_SECREL_LOW12A</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_SECREL_HIGH12A">
            <h2>IMAGE_REL_ARM64_SECREL_HIGH12A</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_SECREL_HIGH12A</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_SECREL_LOW12L">
            <h2>IMAGE_REL_ARM64_SECREL_LOW12L</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_SECREL_LOW12L</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_TOKEN">
            <h2>IMAGE_REL_ARM64_TOKEN</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_TOKEN</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_SECTION">
            <h2>IMAGE_REL_ARM64_SECTION</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_SECTION</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_ADDR64">
            <h2>IMAGE_REL_ARM64_ADDR64</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_ADDR64</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_BRANCH19">
            <h2>IMAGE_REL_ARM64_BRANCH19</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_BRANCH19</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_BRANCH14">
            <h2>IMAGE_REL_ARM64_BRANCH14</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_BRANCH14</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_ARM64_REL32">
            <h2>IMAGE_REL_ARM64_REL32</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_ARM64_REL32</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_BASED_HIGHLOW">
            <h2>IMAGE_REL_BASED_HIGHLOW</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_BASED_HIGHLOW</code></pre>
         </article>
         
         <article class="global" data-name="IMAGE_REL_BASED_DIR64">
            <h2>IMAGE_REL_BASED_DIR64</h2>
            <hr />
            
            <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
            
            <pre><code>IMAGE_REL_BASED_DIR64</code></pre>
         </article>
         
         <article class="global" data-name="PeMinimumTargetMajorVersion">
            <h2>PeMinimumTargetMajorVersion</h2>
            <hr />
            
            <pre><code>PeMinimumTargetMajorVersion</code></pre>
         </article>
         
         <article class="global" data-name="PeMinimumTargetMinorVersion">
            <h2>PeMinimumTargetMinorVersion</h2>
            <hr />
            
            <pre><code>PeMinimumTargetMinorVersion</code></pre>
         </article>
         
         <article class="global" data-name="dosstub">
            <h2>dosstub</h2>
            <hr />
            
            <p>DOS stub that prints out
"This program cannot be run in DOS mode."
See IMAGE_DOS_HEADER in the Windows SDK for the format of the header used here.</p>
            
            <pre><code>dosstub</code></pre>
         </article>
         
         <article class="global" data-name="rsrcsyms">
            <h2>rsrcsyms</h2>
            <hr />
            
            <pre><code>rsrcsyms []loader.Sym</code></pre>
         </article>
         
         <article class="global" data-name="PESECTHEADR">
            <h2>PESECTHEADR</h2>
            <hr />
            
            <pre><code>PESECTHEADR int32</code></pre>
         </article>
         
         <article class="global" data-name="PEFILEHEADR">
            <h2>PEFILEHEADR</h2>
            <hr />
            
            <pre><code>PEFILEHEADR int32</code></pre>
         </article>
         
         <article class="global" data-name="pe64">
            <h2>pe64</h2>
            <hr />
            
            <pre><code>pe64 int</code></pre>
         </article>
         
         <article class="global" data-name="dr">
            <h2>dr</h2>
            <hr />
            
            <pre><code>dr *Dll</code></pre>
         </article>
         
         <article class="global" data-name="dexport">
            <h2>dexport</h2>
            <hr />
            
            <pre><code>dexport []loader.Sym</code></pre>
         </article>
         
         <article class="global" data-name="isLabel">
            <h2>isLabel</h2>
            <hr />
            
            <pre><code>isLabel</code></pre>
         </article>
         
         <article class="global" data-name="pefile">
            <h2>pefile</h2>
            <hr />
            
            <pre><code>pefile peFile</code></pre>
         </article>
         
         <article class="global" data-name="blockSize">
            <h2>blockSize</h2>
            <hr />
            
            <pre><code>blockSize</code></pre>
         </article>
         
         <article class="global" data-name="covCounterDataStartOff">
            <h2>covCounterDataStartOff</h2>
            <hr />
            
            <pre><code>covCounterDataStartOff uint64</code></pre>
         </article>
         
         <article class="global" data-name="covCounterDataLen">
            <h2>covCounterDataLen</h2>
            <hr />
            
            <pre><code>covCounterDataLen uint64</code></pre>
         </article>
         
         <article class="global" data-name="zeros">
            <h2>zeros</h2>
            <hr />
            
            <pre><code>zeros []byte</code></pre>
         </article>
         
         <article class="global" data-name="strdata">
            <h2>strdata</h2>
            <hr />
            
            <pre><code>strdata</code></pre>
         </article>
         
         <article class="global" data-name="strnames">
            <h2>strnames</h2>
            <hr />
            
            <pre><code>strnames []string</code></pre>
         </article>
         
         <article class="global" data-name="debugGCProg">
            <h2>debugGCProg</h2>
            <hr />
            
            <pre><code>debugGCProg</code></pre>
         </article>
         
         <article class="global" data-name="cutoff">
            <h2>cutoff</h2>
            <hr />
            
            <p>cutoff is the maximum data section size permitted by the linker
(see issue #9862).</p>
            
            <pre><code>cutoff</code></pre>
         </article>
         
         <article class="global" data-name="wasmMinDataAddr">
            <h2>wasmMinDataAddr</h2>
            <hr />
            
            <p>On Wasm, we reserve 4096 bytes for zero page, then 8192 bytes for wasm_exec.js
to store command line args and environment variables.
Data sections starts from at least address 12288.
Keep in sync with wasm_exec.js.</p>
            
            <pre><code>wasmMinDataAddr</code></pre>
         </article>
         
         <article class="global" data-name="GdbScriptPythonFileId">
            <h2>GdbScriptPythonFileId</h2>
            <hr />
            
            <p>https://sourceware.org/gdb/onlinedocs/gdb/dotdebug_005fgdb_005fscripts-section.html
Each entry inside .debug_gdb_scripts section begins with a non-null prefix
byte that specifies the kind of entry. The following entries are supported:</p>
            
            <pre><code>GdbScriptPythonFileId</code></pre>
         </article>
         
         <article class="global" data-name="GdbScriptSchemeFileId">
            <h2>GdbScriptSchemeFileId</h2>
            <hr />
            
            <p>https://sourceware.org/gdb/onlinedocs/gdb/dotdebug_005fgdb_005fscripts-section.html
Each entry inside .debug_gdb_scripts section begins with a non-null prefix
byte that specifies the kind of entry. The following entries are supported:</p>
            
            <pre><code>GdbScriptSchemeFileId</code></pre>
         </article>
         
         <article class="global" data-name="GdbScriptPythonTextId">
            <h2>GdbScriptPythonTextId</h2>
            <hr />
            
            <p>https://sourceware.org/gdb/onlinedocs/gdb/dotdebug_005fgdb_005fscripts-section.html
Each entry inside .debug_gdb_scripts section begins with a non-null prefix
byte that specifies the kind of entry. The following entries are supported:</p>
            
            <pre><code>GdbScriptPythonTextId</code></pre>
         </article>
         
         <article class="global" data-name="GdbScriptSchemeTextId">
            <h2>GdbScriptSchemeTextId</h2>
            <hr />
            
            <p>https://sourceware.org/gdb/onlinedocs/gdb/dotdebug_005fgdb_005fscripts-section.html
Each entry inside .debug_gdb_scripts section begins with a non-null prefix
byte that specifies the kind of entry. The following entries are supported:</p>
            
            <pre><code>GdbScriptSchemeTextId</code></pre>
         </article>
         
         <article class="global" data-name="gdbscript">
            <h2>gdbscript</h2>
            <hr />
            
            <pre><code>gdbscript string</code></pre>
         </article>
         
         <article class="global" data-name="dwarfp">
            <h2>dwarfp</h2>
            <hr />
            
            <p>dwarfp stores the collected DWARF symbols created during
dwarf generation.</p>
            
            <pre><code>dwarfp []dwarfSecInfo</code></pre>
         </article>
         
         <article class="global" data-name="dwtypes">
            <h2>dwtypes</h2>
            <hr />
            
            <pre><code>dwtypes dwarf.DWDie</code></pre>
         </article>
         
         <article class="global" data-name="LINE_BASE">
            <h2>LINE_BASE</h2>
            <hr />
            
            <p>* Generate a sequence of opcodes that is as short as possible.
 * See section 6.2.5</p>
            
            <pre><code>LINE_BASE</code></pre>
         </article>
         
         <article class="global" data-name="LINE_RANGE">
            <h2>LINE_RANGE</h2>
            <hr />
            
            <p>* Generate a sequence of opcodes that is as short as possible.
 * See section 6.2.5</p>
            
            <pre><code>LINE_RANGE</code></pre>
         </article>
         
         <article class="global" data-name="PC_RANGE">
            <h2>PC_RANGE</h2>
            <hr />
            
            <p>* Generate a sequence of opcodes that is as short as possible.
 * See section 6.2.5</p>
            
            <pre><code>PC_RANGE</code></pre>
         </article>
         
         <article class="global" data-name="OPCODE_BASE">
            <h2>OPCODE_BASE</h2>
            <hr />
            
            <p>* Generate a sequence of opcodes that is as short as possible.
 * See section 6.2.5</p>
            
            <pre><code>OPCODE_BASE</code></pre>
         </article>
         
         <article class="global" data-name="dataAlignmentFactor">
            <h2>dataAlignmentFactor</h2>
            <hr />
            
            <p>*  Emit .debug_frame</p>
            
            <pre><code>dataAlignmentFactor</code></pre>
         </article>
         
         <article class="global" data-name="COMPUNITHEADERSIZE">
            <h2>COMPUNITHEADERSIZE</h2>
            <hr />
            
            <pre><code>COMPUNITHEADERSIZE</code></pre>
         </article>
         
         <article class="global" data-name="prototypedies">
            <h2>prototypedies</h2>
            <hr />
            
            <pre><code>prototypedies *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="dwsectCUSizeMu">
            <h2>dwsectCUSizeMu</h2>
            <hr />
            
            <p>On AIX, the symbol table needs to know where are the compilation units parts
for a specific package in each .dw section.
dwsectCUSize map will save the size of a compilation unit for
the corresponding .dw section.
This size can later be retrieved with the index "sectionName.pkgName".</p>
            
            <pre><code>dwsectCUSizeMu sync.Mutex</code></pre>
         </article>
         
         <article class="global" data-name="dwsectCUSize">
            <h2>dwsectCUSize</h2>
            <hr />
            
            <pre><code>dwsectCUSize *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="syscallExecSupported">
            <h2>syscallExecSupported</h2>
            <hr />
            
            <pre><code>syscallExecSupported</code></pre>
         </article>
         
         <article class="global" data-name="INITIAL_MACHO_HEADR">
            <h2>INITIAL_MACHO_HEADR</h2>
            <hr />
            
            <p>* Total amount of space to reserve at the start of the file
 * for Header, PHeaders, and SHeaders.
 * May waste some.</p>
            
            <pre><code>INITIAL_MACHO_HEADR</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_CPU_AMD64">
            <h2>MACHO_CPU_AMD64</h2>
            <hr />
            
            <pre><code>MACHO_CPU_AMD64</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_CPU_386">
            <h2>MACHO_CPU_386</h2>
            <hr />
            
            <pre><code>MACHO_CPU_386</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_SUBCPU_X86">
            <h2>MACHO_SUBCPU_X86</h2>
            <hr />
            
            <pre><code>MACHO_SUBCPU_X86</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_CPU_ARM">
            <h2>MACHO_CPU_ARM</h2>
            <hr />
            
            <pre><code>MACHO_CPU_ARM</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_SUBCPU_ARM">
            <h2>MACHO_SUBCPU_ARM</h2>
            <hr />
            
            <pre><code>MACHO_SUBCPU_ARM</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_SUBCPU_ARMV7">
            <h2>MACHO_SUBCPU_ARMV7</h2>
            <hr />
            
            <pre><code>MACHO_SUBCPU_ARMV7</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_CPU_ARM64">
            <h2>MACHO_CPU_ARM64</h2>
            <hr />
            
            <pre><code>MACHO_CPU_ARM64</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_SUBCPU_ARM64_ALL">
            <h2>MACHO_SUBCPU_ARM64_ALL</h2>
            <hr />
            
            <pre><code>MACHO_SUBCPU_ARM64_ALL</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_SUBCPU_ARM64_V8">
            <h2>MACHO_SUBCPU_ARM64_V8</h2>
            <hr />
            
            <pre><code>MACHO_SUBCPU_ARM64_V8</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_SUBCPU_ARM64E">
            <h2>MACHO_SUBCPU_ARM64E</h2>
            <hr />
            
            <pre><code>MACHO_SUBCPU_ARM64E</code></pre>
         </article>
         
         <article class="global" data-name="MACHO32SYMSIZE">
            <h2>MACHO32SYMSIZE</h2>
            <hr />
            
            <pre><code>MACHO32SYMSIZE</code></pre>
         </article>
         
         <article class="global" data-name="MACHO64SYMSIZE">
            <h2>MACHO64SYMSIZE</h2>
            <hr />
            
            <pre><code>MACHO64SYMSIZE</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_X86_64_RELOC_UNSIGNED">
            <h2>MACHO_X86_64_RELOC_UNSIGNED</h2>
            <hr />
            
            <pre><code>MACHO_X86_64_RELOC_UNSIGNED</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_X86_64_RELOC_SIGNED">
            <h2>MACHO_X86_64_RELOC_SIGNED</h2>
            <hr />
            
            <pre><code>MACHO_X86_64_RELOC_SIGNED</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_X86_64_RELOC_BRANCH">
            <h2>MACHO_X86_64_RELOC_BRANCH</h2>
            <hr />
            
            <pre><code>MACHO_X86_64_RELOC_BRANCH</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_X86_64_RELOC_GOT_LOAD">
            <h2>MACHO_X86_64_RELOC_GOT_LOAD</h2>
            <hr />
            
            <pre><code>MACHO_X86_64_RELOC_GOT_LOAD</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_X86_64_RELOC_GOT">
            <h2>MACHO_X86_64_RELOC_GOT</h2>
            <hr />
            
            <pre><code>MACHO_X86_64_RELOC_GOT</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_X86_64_RELOC_SUBTRACTOR">
            <h2>MACHO_X86_64_RELOC_SUBTRACTOR</h2>
            <hr />
            
            <pre><code>MACHO_X86_64_RELOC_SUBTRACTOR</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_X86_64_RELOC_SIGNED_1">
            <h2>MACHO_X86_64_RELOC_SIGNED_1</h2>
            <hr />
            
            <pre><code>MACHO_X86_64_RELOC_SIGNED_1</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_X86_64_RELOC_SIGNED_2">
            <h2>MACHO_X86_64_RELOC_SIGNED_2</h2>
            <hr />
            
            <pre><code>MACHO_X86_64_RELOC_SIGNED_2</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_X86_64_RELOC_SIGNED_4">
            <h2>MACHO_X86_64_RELOC_SIGNED_4</h2>
            <hr />
            
            <pre><code>MACHO_X86_64_RELOC_SIGNED_4</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_ARM_RELOC_VANILLA">
            <h2>MACHO_ARM_RELOC_VANILLA</h2>
            <hr />
            
            <pre><code>MACHO_ARM_RELOC_VANILLA</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_ARM_RELOC_PAIR">
            <h2>MACHO_ARM_RELOC_PAIR</h2>
            <hr />
            
            <pre><code>MACHO_ARM_RELOC_PAIR</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_ARM_RELOC_SECTDIFF">
            <h2>MACHO_ARM_RELOC_SECTDIFF</h2>
            <hr />
            
            <pre><code>MACHO_ARM_RELOC_SECTDIFF</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_ARM_RELOC_BR24">
            <h2>MACHO_ARM_RELOC_BR24</h2>
            <hr />
            
            <pre><code>MACHO_ARM_RELOC_BR24</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_ARM64_RELOC_UNSIGNED">
            <h2>MACHO_ARM64_RELOC_UNSIGNED</h2>
            <hr />
            
            <pre><code>MACHO_ARM64_RELOC_UNSIGNED</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_ARM64_RELOC_BRANCH26">
            <h2>MACHO_ARM64_RELOC_BRANCH26</h2>
            <hr />
            
            <pre><code>MACHO_ARM64_RELOC_BRANCH26</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_ARM64_RELOC_PAGE21">
            <h2>MACHO_ARM64_RELOC_PAGE21</h2>
            <hr />
            
            <pre><code>MACHO_ARM64_RELOC_PAGE21</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_ARM64_RELOC_PAGEOFF12">
            <h2>MACHO_ARM64_RELOC_PAGEOFF12</h2>
            <hr />
            
            <pre><code>MACHO_ARM64_RELOC_PAGEOFF12</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_ARM64_RELOC_GOT_LOAD_PAGE21">
            <h2>MACHO_ARM64_RELOC_GOT_LOAD_PAGE21</h2>
            <hr />
            
            <pre><code>MACHO_ARM64_RELOC_GOT_LOAD_PAGE21</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_ARM64_RELOC_GOT_LOAD_PAGEOFF12">
            <h2>MACHO_ARM64_RELOC_GOT_LOAD_PAGEOFF12</h2>
            <hr />
            
            <pre><code>MACHO_ARM64_RELOC_GOT_LOAD_PAGEOFF12</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_ARM64_RELOC_ADDEND">
            <h2>MACHO_ARM64_RELOC_ADDEND</h2>
            <hr />
            
            <pre><code>MACHO_ARM64_RELOC_ADDEND</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_GENERIC_RELOC_VANILLA">
            <h2>MACHO_GENERIC_RELOC_VANILLA</h2>
            <hr />
            
            <pre><code>MACHO_GENERIC_RELOC_VANILLA</code></pre>
         </article>
         
         <article class="global" data-name="MACHO_FAKE_GOTPCREL">
            <h2>MACHO_FAKE_GOTPCREL</h2>
            <hr />
            
            <pre><code>MACHO_FAKE_GOTPCREL</code></pre>
         </article>
         
         <article class="global" data-name="MH_MAGIC">
            <h2>MH_MAGIC</h2>
            <hr />
            
            <pre><code>MH_MAGIC</code></pre>
         </article>
         
         <article class="global" data-name="MH_MAGIC_64">
            <h2>MH_MAGIC_64</h2>
            <hr />
            
            <pre><code>MH_MAGIC_64</code></pre>
         </article>
         
         <article class="global" data-name="MH_OBJECT">
            <h2>MH_OBJECT</h2>
            <hr />
            
            <pre><code>MH_OBJECT</code></pre>
         </article>
         
         <article class="global" data-name="MH_EXECUTE">
            <h2>MH_EXECUTE</h2>
            <hr />
            
            <pre><code>MH_EXECUTE</code></pre>
         </article>
         
         <article class="global" data-name="MH_NOUNDEFS">
            <h2>MH_NOUNDEFS</h2>
            <hr />
            
            <pre><code>MH_NOUNDEFS</code></pre>
         </article>
         
         <article class="global" data-name="MH_DYLDLINK">
            <h2>MH_DYLDLINK</h2>
            <hr />
            
            <pre><code>MH_DYLDLINK</code></pre>
         </article>
         
         <article class="global" data-name="MH_PIE">
            <h2>MH_PIE</h2>
            <hr />
            
            <pre><code>MH_PIE</code></pre>
         </article>
         
         <article class="global" data-name="S_REGULAR">
            <h2>S_REGULAR</h2>
            <hr />
            
            <pre><code>S_REGULAR</code></pre>
         </article>
         
         <article class="global" data-name="S_ZEROFILL">
            <h2>S_ZEROFILL</h2>
            <hr />
            
            <pre><code>S_ZEROFILL</code></pre>
         </article>
         
         <article class="global" data-name="S_NON_LAZY_SYMBOL_POINTERS">
            <h2>S_NON_LAZY_SYMBOL_POINTERS</h2>
            <hr />
            
            <pre><code>S_NON_LAZY_SYMBOL_POINTERS</code></pre>
         </article>
         
         <article class="global" data-name="S_SYMBOL_STUBS">
            <h2>S_SYMBOL_STUBS</h2>
            <hr />
            
            <pre><code>S_SYMBOL_STUBS</code></pre>
         </article>
         
         <article class="global" data-name="S_MOD_INIT_FUNC_POINTERS">
            <h2>S_MOD_INIT_FUNC_POINTERS</h2>
            <hr />
            
            <pre><code>S_MOD_INIT_FUNC_POINTERS</code></pre>
         </article>
         
         <article class="global" data-name="S_ATTR_PURE_INSTRUCTIONS">
            <h2>S_ATTR_PURE_INSTRUCTIONS</h2>
            <hr />
            
            <pre><code>S_ATTR_PURE_INSTRUCTIONS</code></pre>
         </article>
         
         <article class="global" data-name="S_ATTR_DEBUG">
            <h2>S_ATTR_DEBUG</h2>
            <hr />
            
            <pre><code>S_ATTR_DEBUG</code></pre>
         </article>
         
         <article class="global" data-name="S_ATTR_SOME_INSTRUCTIONS">
            <h2>S_ATTR_SOME_INSTRUCTIONS</h2>
            <hr />
            
            <pre><code>S_ATTR_SOME_INSTRUCTIONS</code></pre>
         </article>
         
         <article class="global" data-name="PLATFORM_MACOS">
            <h2>PLATFORM_MACOS</h2>
            <hr />
            
            <pre><code>PLATFORM_MACOS MachoPlatform</code></pre>
         </article>
         
         <article class="global" data-name="PLATFORM_IOS">
            <h2>PLATFORM_IOS</h2>
            <hr />
            
            <pre><code>PLATFORM_IOS MachoPlatform</code></pre>
         </article>
         
         <article class="global" data-name="PLATFORM_TVOS">
            <h2>PLATFORM_TVOS</h2>
            <hr />
            
            <pre><code>PLATFORM_TVOS MachoPlatform</code></pre>
         </article>
         
         <article class="global" data-name="PLATFORM_WATCHOS">
            <h2>PLATFORM_WATCHOS</h2>
            <hr />
            
            <pre><code>PLATFORM_WATCHOS MachoPlatform</code></pre>
         </article>
         
         <article class="global" data-name="PLATFORM_BRIDGEOS">
            <h2>PLATFORM_BRIDGEOS</h2>
            <hr />
            
            <pre><code>PLATFORM_BRIDGEOS MachoPlatform</code></pre>
         </article>
         
         <article class="global" data-name="PLATFORM_MACCATALYST">
            <h2>PLATFORM_MACCATALYST</h2>
            <hr />
            
            <pre><code>PLATFORM_MACCATALYST MachoPlatform</code></pre>
         </article>
         
         <article class="global" data-name="REBASE_TYPE_POINTER">
            <h2>REBASE_TYPE_POINTER</h2>
            <hr />
            
            <p>rebase table opcode</p>
            
            <pre><code>REBASE_TYPE_POINTER</code></pre>
         </article>
         
         <article class="global" data-name="REBASE_TYPE_TEXT_ABSOLUTE32">
            <h2>REBASE_TYPE_TEXT_ABSOLUTE32</h2>
            <hr />
            
            <p>rebase table opcode</p>
            
            <pre><code>REBASE_TYPE_TEXT_ABSOLUTE32</code></pre>
         </article>
         
         <article class="global" data-name="REBASE_TYPE_TEXT_PCREL32">
            <h2>REBASE_TYPE_TEXT_PCREL32</h2>
            <hr />
            
            <p>rebase table opcode</p>
            
            <pre><code>REBASE_TYPE_TEXT_PCREL32</code></pre>
         </article>
         
         <article class="global" data-name="REBASE_OPCODE_MASK">
            <h2>REBASE_OPCODE_MASK</h2>
            <hr />
            
            <p>rebase table opcode</p>
            
            <pre><code>REBASE_OPCODE_MASK</code></pre>
         </article>
         
         <article class="global" data-name="REBASE_IMMEDIATE_MASK">
            <h2>REBASE_IMMEDIATE_MASK</h2>
            <hr />
            
            <p>rebase table opcode</p>
            
            <pre><code>REBASE_IMMEDIATE_MASK</code></pre>
         </article>
         
         <article class="global" data-name="REBASE_OPCODE_DONE">
            <h2>REBASE_OPCODE_DONE</h2>
            <hr />
            
            <p>rebase table opcode</p>
            
            <pre><code>REBASE_OPCODE_DONE</code></pre>
         </article>
         
         <article class="global" data-name="REBASE_OPCODE_SET_TYPE_IMM">
            <h2>REBASE_OPCODE_SET_TYPE_IMM</h2>
            <hr />
            
            <p>rebase table opcode</p>
            
            <pre><code>REBASE_OPCODE_SET_TYPE_IMM</code></pre>
         </article>
         
         <article class="global" data-name="REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB">
            <h2>REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB</h2>
            <hr />
            
            <p>rebase table opcode</p>
            
            <pre><code>REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB</code></pre>
         </article>
         
         <article class="global" data-name="REBASE_OPCODE_ADD_ADDR_ULEB">
            <h2>REBASE_OPCODE_ADD_ADDR_ULEB</h2>
            <hr />
            
            <p>rebase table opcode</p>
            
            <pre><code>REBASE_OPCODE_ADD_ADDR_ULEB</code></pre>
         </article>
         
         <article class="global" data-name="REBASE_OPCODE_ADD_ADDR_IMM_SCALED">
            <h2>REBASE_OPCODE_ADD_ADDR_IMM_SCALED</h2>
            <hr />
            
            <p>rebase table opcode</p>
            
            <pre><code>REBASE_OPCODE_ADD_ADDR_IMM_SCALED</code></pre>
         </article>
         
         <article class="global" data-name="REBASE_OPCODE_DO_REBASE_IMM_TIMES">
            <h2>REBASE_OPCODE_DO_REBASE_IMM_TIMES</h2>
            <hr />
            
            <p>rebase table opcode</p>
            
            <pre><code>REBASE_OPCODE_DO_REBASE_IMM_TIMES</code></pre>
         </article>
         
         <article class="global" data-name="REBASE_OPCODE_DO_REBASE_ULEB_TIMES">
            <h2>REBASE_OPCODE_DO_REBASE_ULEB_TIMES</h2>
            <hr />
            
            <p>rebase table opcode</p>
            
            <pre><code>REBASE_OPCODE_DO_REBASE_ULEB_TIMES</code></pre>
         </article>
         
         <article class="global" data-name="REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB">
            <h2>REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB</h2>
            <hr />
            
            <p>rebase table opcode</p>
            
            <pre><code>REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB</code></pre>
         </article>
         
         <article class="global" data-name="REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB">
            <h2>REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB</h2>
            <hr />
            
            <p>rebase table opcode</p>
            
            <pre><code>REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB</code></pre>
         </article>
         
         <article class="global" data-name="BIND_TYPE_POINTER">
            <h2>BIND_TYPE_POINTER</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_TYPE_POINTER</code></pre>
         </article>
         
         <article class="global" data-name="BIND_TYPE_TEXT_ABSOLUTE32">
            <h2>BIND_TYPE_TEXT_ABSOLUTE32</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_TYPE_TEXT_ABSOLUTE32</code></pre>
         </article>
         
         <article class="global" data-name="BIND_TYPE_TEXT_PCREL32">
            <h2>BIND_TYPE_TEXT_PCREL32</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_TYPE_TEXT_PCREL32</code></pre>
         </article>
         
         <article class="global" data-name="BIND_SPECIAL_DYLIB_SELF">
            <h2>BIND_SPECIAL_DYLIB_SELF</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_SPECIAL_DYLIB_SELF</code></pre>
         </article>
         
         <article class="global" data-name="BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE">
            <h2>BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE</code></pre>
         </article>
         
         <article class="global" data-name="BIND_SPECIAL_DYLIB_FLAT_LOOKUP">
            <h2>BIND_SPECIAL_DYLIB_FLAT_LOOKUP</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_SPECIAL_DYLIB_FLAT_LOOKUP</code></pre>
         </article>
         
         <article class="global" data-name="BIND_SPECIAL_DYLIB_WEAK_LOOKUP">
            <h2>BIND_SPECIAL_DYLIB_WEAK_LOOKUP</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_SPECIAL_DYLIB_WEAK_LOOKUP</code></pre>
         </article>
         
         <article class="global" data-name="BIND_OPCODE_MASK">
            <h2>BIND_OPCODE_MASK</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_OPCODE_MASK</code></pre>
         </article>
         
         <article class="global" data-name="BIND_IMMEDIATE_MASK">
            <h2>BIND_IMMEDIATE_MASK</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_IMMEDIATE_MASK</code></pre>
         </article>
         
         <article class="global" data-name="BIND_OPCODE_DONE">
            <h2>BIND_OPCODE_DONE</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_OPCODE_DONE</code></pre>
         </article>
         
         <article class="global" data-name="BIND_OPCODE_SET_DYLIB_ORDINAL_IMM">
            <h2>BIND_OPCODE_SET_DYLIB_ORDINAL_IMM</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_OPCODE_SET_DYLIB_ORDINAL_IMM</code></pre>
         </article>
         
         <article class="global" data-name="BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB">
            <h2>BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB</code></pre>
         </article>
         
         <article class="global" data-name="BIND_OPCODE_SET_DYLIB_SPECIAL_IMM">
            <h2>BIND_OPCODE_SET_DYLIB_SPECIAL_IMM</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_OPCODE_SET_DYLIB_SPECIAL_IMM</code></pre>
         </article>
         
         <article class="global" data-name="BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM">
            <h2>BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM</code></pre>
         </article>
         
         <article class="global" data-name="BIND_OPCODE_SET_TYPE_IMM">
            <h2>BIND_OPCODE_SET_TYPE_IMM</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_OPCODE_SET_TYPE_IMM</code></pre>
         </article>
         
         <article class="global" data-name="BIND_OPCODE_SET_ADDEND_SLEB">
            <h2>BIND_OPCODE_SET_ADDEND_SLEB</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_OPCODE_SET_ADDEND_SLEB</code></pre>
         </article>
         
         <article class="global" data-name="BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB">
            <h2>BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB</code></pre>
         </article>
         
         <article class="global" data-name="BIND_OPCODE_ADD_ADDR_ULEB">
            <h2>BIND_OPCODE_ADD_ADDR_ULEB</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_OPCODE_ADD_ADDR_ULEB</code></pre>
         </article>
         
         <article class="global" data-name="BIND_OPCODE_DO_BIND">
            <h2>BIND_OPCODE_DO_BIND</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_OPCODE_DO_BIND</code></pre>
         </article>
         
         <article class="global" data-name="BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB">
            <h2>BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB</code></pre>
         </article>
         
         <article class="global" data-name="BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED">
            <h2>BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED</code></pre>
         </article>
         
         <article class="global" data-name="BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB">
            <h2>BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB</code></pre>
         </article>
         
         <article class="global" data-name="BIND_OPCODE_THREADED">
            <h2>BIND_OPCODE_THREADED</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_OPCODE_THREADED</code></pre>
         </article>
         
         <article class="global" data-name="BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB">
            <h2>BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB</code></pre>
         </article>
         
         <article class="global" data-name="BIND_SUBOPCODE_THREADED_APPLY">
            <h2>BIND_SUBOPCODE_THREADED_APPLY</h2>
            <hr />
            
            <p>bind table opcode</p>
            
            <pre><code>BIND_SUBOPCODE_THREADED_APPLY</code></pre>
         </article>
         
         <article class="global" data-name="machoHeaderSize64">
            <h2>machoHeaderSize64</h2>
            <hr />
            
            <pre><code>machoHeaderSize64</code></pre>
         </article>
         
         <article class="global" data-name="machohdr">
            <h2>machohdr</h2>
            <hr />
            
            <pre><code>machohdr MachoHdr</code></pre>
         </article>
         
         <article class="global" data-name="load">
            <h2>load</h2>
            <hr />
            
            <pre><code>load []MachoLoad</code></pre>
         </article>
         
         <article class="global" data-name="machoPlatform">
            <h2>machoPlatform</h2>
            <hr />
            
            <pre><code>machoPlatform MachoPlatform</code></pre>
         </article>
         
         <article class="global" data-name="seg">
            <h2>seg</h2>
            <hr />
            
            <pre><code>seg []MachoSeg</code></pre>
         </article>
         
         <article class="global" data-name="nseg">
            <h2>nseg</h2>
            <hr />
            
            <pre><code>nseg int</code></pre>
         </article>
         
         <article class="global" data-name="ndebug">
            <h2>ndebug</h2>
            <hr />
            
            <pre><code>ndebug int</code></pre>
         </article>
         
         <article class="global" data-name="nsect">
            <h2>nsect</h2>
            <hr />
            
            <pre><code>nsect int</code></pre>
         </article>
         
         <article class="global" data-name="SymKindLocal">
            <h2>SymKindLocal</h2>
            <hr />
            
            <pre><code>SymKindLocal</code></pre>
         </article>
         
         <article class="global" data-name="SymKindExtdef">
            <h2>SymKindExtdef</h2>
            <hr />
            
            <pre><code>SymKindExtdef</code></pre>
         </article>
         
         <article class="global" data-name="SymKindUndef">
            <h2>SymKindUndef</h2>
            <hr />
            
            <pre><code>SymKindUndef</code></pre>
         </article>
         
         <article class="global" data-name="NumSymKind">
            <h2>NumSymKind</h2>
            <hr />
            
            <pre><code>NumSymKind</code></pre>
         </article>
         
         <article class="global" data-name="nkind">
            <h2>nkind</h2>
            <hr />
            
            <pre><code>nkind []int</code></pre>
         </article>
         
         <article class="global" data-name="sortsym">
            <h2>sortsym</h2>
            <hr />
            
            <pre><code>sortsym []loader.Sym</code></pre>
         </article>
         
         <article class="global" data-name="nsortsym">
            <h2>nsortsym</h2>
            <hr />
            
            <pre><code>nsortsym int</code></pre>
         </article>
         
         <article class="global" data-name="loadBudget">
            <h2>loadBudget</h2>
            <hr />
            
            <p>Amount of space left for adding load commands
that refer to dynamic libraries. Because these have
to go in the Mach-O header, we can't just pick a
"big enough" header size. The initial header is
one page, the non-dynamic library stuff takes
up about 1300 bytes; we overestimate that as 2k.</p>
            
            <pre><code>loadBudget</code></pre>
         </article>
         
         <article class="global" data-name="dylib">
            <h2>dylib</h2>
            <hr />
            
            <pre><code>dylib []string</code></pre>
         </article>
         
         <article class="global" data-name="linkoff">
            <h2>linkoff</h2>
            <hr />
            
            <pre><code>linkoff int64</code></pre>
         </article>
         
         <article class="global" data-name="machorebase">
            <h2>machorebase</h2>
            <hr />
            
            <pre><code>machorebase []machoRebaseRecord</code></pre>
         </article>
         
         <article class="global" data-name="machobind">
            <h2>machobind</h2>
            <hr />
            
            <pre><code>machobind []machoBindRecord</code></pre>
         </article>
          
         <article class="struct" data-name="builtFile">
            <h2>type builtFile struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">*objfilepkg.File
path string</code></pre>
         </article>
         
         <article class="struct" data-name="stackCheck">
            <h2>type stackCheck struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">ctxt *Link
ldr *loader.Loader
morestack loader.Sym
callSize int
height *ast.MapType
graph *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="stackCheckEdge">
            <h2>type stackCheckEdge struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">growth int
target loader.Sym</code></pre>
         </article>
         
         <article class="struct" data-name="stackCheckChain">
            <h2>type stackCheckChain struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">stackCheckEdge
printed bool</code></pre>
         </article>
         
         <article class="struct" data-name="Target">
            <h2>type Target struct</h2>
            <hr />
            
            <p>Target holds the configuration we're building for.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Arch *sys.Arch
HeadType objabi.HeadType
LinkMode LinkMode
BuildMode BuildMode
linkShared bool
canUsePlugins bool
IsELF bool</code></pre>
         </article>
         
         <article class="struct" data-name="deadcodePass">
            <h2>type deadcodePass struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">ctxt *Link
ldr *loader.Loader
wq heap
ifaceMethod *ast.MapType
genericIfaceMethod *ast.MapType
markableMethods []methodref
reflectSeen bool
dynlink bool
methodsigstmp []methodsig
pkginits []loader.Sym
mapinitnoop loader.Sym</code></pre>
         </article>
         
         <article class="struct" data-name="methodsig">
            <h2>type methodsig struct</h2>
            <hr />
            
            <p>methodsig is a typed method signature (name + type).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
typ loader.Sym</code></pre>
         </article>
         
         <article class="struct" data-name="methodref">
            <h2>type methodref struct</h2>
            <hr />
            
            <p>methodref holds the relocations from a receiver type symbol to its
method. There are three relocations, one for each of the fields in
the reflect.method struct: mtyp, ifn, and tfn.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">m methodsig
src loader.Sym
r int</code></pre>
         </article>
         
         <article class="struct" data-name="elfNote">
            <h2>type elfNote struct</h2>
            <hr />
            
            <p>* Note header.  The ".note" section contains an array of notes.  Each
 * begins with this header, aligned to a word boundary.  Immediately
 * following the note header is n_namesz bytes of name, padded to the
 * next word boundary.  Then comes n_descsz bytes of descriptor, again
 * padded to a word boundary.  The values of n_namesz and n_descsz do
 * not include the padding.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">nNamesz uint32
nDescsz uint32
nType uint32</code></pre>
         </article>
         
         <article class="struct" data-name="ElfShdr">
            <h2>type ElfShdr struct</h2>
            <hr />
            
            <p>* Section header.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">elf.Section64
shnum elf.SectionIndex</code></pre>
         </article>
         
         <article class="struct" data-name="ELFArch">
            <h2>type ELFArch struct</h2>
            <hr />
            
            <p>ELFArch includes target-specific hooks for ELF targets.
This is initialized by the target-specific Init function
called by the linker's main function in cmd/link/main.go.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Androiddynld string
Linuxdynld string
LinuxdynldMusl string
Freebsddynld string
Netbsddynld string
Openbsddynld string
Dragonflydynld string
Solarisdynld string
Reloc1 func
RelocSize uint32
SetupPLT func
DynamicReadOnly bool</code></pre>
         </article>
         
         <article class="struct" data-name="Elfstring">
            <h2>type Elfstring struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">s string
off int</code></pre>
         </article>
         
         <article class="struct" data-name="Elfaux">
            <h2>type Elfaux struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">next *Elfaux
num int
vers string</code></pre>
         </article>
         
         <article class="struct" data-name="Elflib">
            <h2>type Elflib struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">next *Elflib
aux *Elfaux
file string</code></pre>
         </article>
         
         <article class="struct" data-name="Rpath">
            <h2>type Rpath struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">set bool
val string</code></pre>
         </article>
         
         <article class="struct" data-name="fipsObj">
            <h2>type fipsObj struct</h2>
            <hr />
            
            <p>fipsObj calculates the fips object hash and optionally writes
the hashed content to a file for debugging.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">r io.ReaderAt
w io.Writer
wf *os.File
h hash.Hash
tmp []byte</code></pre>
         </article>
         
         <article class="struct" data-name="OutBuf">
            <h2>type OutBuf struct</h2>
            <hr />
            
            <p>OutBuf is a buffered file writer.

It is similar to the Writer in cmd/internal/bio with a few small differences.

First, it tracks the output architecture and uses it to provide
endian helpers.

Second, it provides a very cheap offset counter that doesn't require
any system calls to read the value.

Third, it also mmaps the output file (if available). The intended usage is:
  - Mmap the output file
  - Write the content
  - possibly apply any edits in the output buffer
  - possibly write more content to the file. These writes take place in a heap
    backed buffer that will get synced to disk.
  - Munmap the output file

And finally, it provides a mechanism by which you can multithread the
writing of output files. This mechanism is accomplished by copying a OutBuf,
and using it in the thread/goroutine.

Parallel OutBuf is intended to be used like:

	func write(out *OutBuf) {
	  var wg sync.WaitGroup
	  for i := 0; i < 10; i++ {
	    wg.Add(1)
	    view, err := out.View(start[i])
	    if err != nil {
	       // handle output
	       continue
	    }
	    go func(out *OutBuf, i int) {
	      // do output
	      wg.Done()
	    }(view, i)
	  }
	  wg.Wait()
	}</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">arch *sys.Arch
off int64
buf []byte
heap []byte
name string
f *os.File
encbuf []byte
isView bool</code></pre>
         </article>
         
         <article class="struct" data-name="pclntab">
            <h2>type pclntab struct</h2>
            <hr />
            
            <p>pclntab holds the state needed for pclntab generation.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">firstFunc loader.Sym
lastFunc loader.Sym
size int64
carrier loader.Sym
pclntab loader.Sym
pcheader loader.Sym
funcnametab loader.Sym
findfunctab loader.Sym
cutab loader.Sym
filetab loader.Sym
pctab loader.Sym
nfunc int32
nfiles uint32</code></pre>
         </article>
         
         <article class="struct" data-name="XcoffFileHdr64">
            <h2>type XcoffFileHdr64 struct</h2>
            <hr />
            
            <p>File Header</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Fmagic uint16
Fnscns uint16
Ftimedat int32
Fsymptr uint64
Fopthdr uint16
Fflags uint16
Fnsyms int32</code></pre>
         </article>
         
         <article class="struct" data-name="XcoffAoutHdr64">
            <h2>type XcoffAoutHdr64 struct</h2>
            <hr />
            
            <p>Auxiliary Header</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Omagic int16
Ovstamp int16
Odebugger uint32
Otextstart uint64
Odatastart uint64
Otoc uint64
Osnentry int16
Osntext int16
Osndata int16
Osntoc int16
Osnloader int16
Osnbss int16
Oalgntext int16
Oalgndata int16
Omodtype []byte
Ocpuflag uint8
Ocputype uint8
Otextpsize uint8
Odatapsize uint8
Ostackpsize uint8
Oflags uint8
Otsize uint64
Odsize uint64
Obsize uint64
Oentry uint64
Omaxstack uint64
Omaxdata uint64
Osntdata int16
Osntbss int16
Ox64flags uint16
Oresv3a int16
Oresv3 []int32</code></pre>
         </article>
         
         <article class="struct" data-name="XcoffScnHdr64">
            <h2>type XcoffScnHdr64 struct</h2>
            <hr />
            
            <p>Section Header</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Sname []byte
Spaddr uint64
Svaddr uint64
Ssize uint64
Sscnptr uint64
Srelptr uint64
Slnnoptr uint64
Snreloc uint32
Snlnno uint32
Sflags uint32</code></pre>
         </article>
         
         <article class="struct" data-name="XcoffSymEnt64">
            <h2>type XcoffSymEnt64 struct</h2>
            <hr />
            
            <p>Symbol Table Entry</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Nvalue uint64
Noffset uint32
Nscnum int16
Ntype uint16
Nsclass uint8
Nnumaux int8</code></pre>
         </article>
         
         <article class="struct" data-name="XcoffAuxFile64">
            <h2>type XcoffAuxFile64 struct</h2>
            <hr />
            
            <p>File Auxiliary Entry</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Xzeroes uint32
Xoffset uint32
X_pad1 []byte
Xftype uint8
X_pad2 []byte
Xauxtype uint8</code></pre>
         </article>
         
         <article class="struct" data-name="XcoffAuxFcn64">
            <h2>type XcoffAuxFcn64 struct</h2>
            <hr />
            
            <p>Function Auxiliary Entry</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Xlnnoptr uint64
Xfsize uint32
Xendndx uint32
Xpad uint8
Xauxtype uint8</code></pre>
         </article>
         
         <article class="struct" data-name="XcoffAuxCSect64">
            <h2>type XcoffAuxCSect64 struct</h2>
            <hr />
            
            <p>csect Auxiliary Entry.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Xscnlenlo uint32
Xparmhash uint32
Xsnhash uint16
Xsmtyp uint8
Xsmclas uint8
Xscnlenhi uint32
Xpad uint8
Xauxtype uint8</code></pre>
         </article>
         
         <article class="struct" data-name="XcoffAuxDWARF64">
            <h2>type XcoffAuxDWARF64 struct</h2>
            <hr />
            
            <p>DWARF Auxiliary Entry</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Xscnlen uint64
X_pad []byte
Xauxtype uint8</code></pre>
         </article>
         
         <article class="struct" data-name="XcoffLdHdr64">
            <h2>type XcoffLdHdr64 struct</h2>
            <hr />
            
            <p>Loader Header</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Lversion int32
Lnsyms int32
Lnreloc int32
Listlen uint32
Lnimpid int32
Lstlen uint32
Limpoff uint64
Lstoff uint64
Lsymoff uint64
Lrldoff uint64</code></pre>
         </article>
         
         <article class="struct" data-name="XcoffLdSym64">
            <h2>type XcoffLdSym64 struct</h2>
            <hr />
            
            <p>Loader Symbol</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Lvalue uint64
Loffset uint32
Lscnum int16
Lsmtype int8
Lsmclas int8
Lifile int32
Lparm uint32</code></pre>
         </article>
         
         <article class="struct" data-name="xcoffLoaderSymbol">
            <h2>type xcoffLoaderSymbol struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">sym loader.Sym
smtype int8
smclas int8</code></pre>
         </article>
         
         <article class="struct" data-name="XcoffLdImportFile64">
            <h2>type XcoffLdImportFile64 struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Limpidpath string
Limpidbase string
Limpidmem string</code></pre>
         </article>
         
         <article class="struct" data-name="XcoffLdRel64">
            <h2>type XcoffLdRel64 struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Lvaddr uint64
Lrtype uint16
Lrsecnm int16
Lsymndx int32</code></pre>
         </article>
         
         <article class="struct" data-name="xcoffLoaderReloc">
            <h2>type xcoffLoaderReloc struct</h2>
            <hr />
            
            <p>xcoffLoaderReloc holds information about a relocation made by the loader.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">sym loader.Sym
roff int32
rtype uint16
symndx int32</code></pre>
         </article>
         
         <article class="struct" data-name="XcoffLdStr64">
            <h2>type XcoffLdStr64 struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">size uint16
name string</code></pre>
         </article>
         
         <article class="struct" data-name="xcoffFile">
            <h2>type xcoffFile struct</h2>
            <hr />
            
            <p>xcoffFile is used to build XCOFF file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">xfhdr XcoffFileHdr64
xahdr XcoffAoutHdr64
sections []*XcoffScnHdr64
sectText *XcoffScnHdr64
sectData *XcoffScnHdr64
sectBss *XcoffScnHdr64
stringTable xcoffStringTable
sectNameToScnum *ast.MapType
loaderSize uint64
symtabOffset int64
symbolCount uint32
symtabSym []xcoffSym
dynLibraries *ast.MapType
loaderSymbols []*xcoffLoaderSymbol
loaderReloc []*xcoffLoaderReloc
sync.Mutex</code></pre>
         </article>
         
         <article class="struct" data-name="xcoffStringTable">
            <h2>type xcoffStringTable struct</h2>
            <hr />
            
            <p>xcoffStringTable is a XCOFF string table.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">strings []string
stringsLen int</code></pre>
         </article>
         
         <article class="struct" data-name="xcoffSymSrcFile">
            <h2>type xcoffSymSrcFile struct</h2>
            <hr />
            
            <p>type records C_FILE information needed for genasmsym in XCOFF.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
file *XcoffSymEnt64
csectAux *XcoffAuxCSect64
csectSymNb uint64
csectVAStart int64
csectVAEnd int64</code></pre>
         </article>
         
         <article class="struct" data-name="ArHdr">
            <h2>type ArHdr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
date string
uid string
gid string
mode string
size string
fmag string</code></pre>
         </article>
         
         <article class="struct" data-name="typelinkSortKey">
            <h2>type typelinkSortKey struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">TypeStr string
Type loader.Sym</code></pre>
         </article>
         
         <article class="struct" data-name="ArchSyms">
            <h2>type ArchSyms struct</h2>
            <hr />
            
            <p>ArchSyms holds a number of architecture specific symbols used during
relocation.  Rather than allowing them universal access to all symbols,
we keep a subset for relocation application.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Rel loader.Sym
Rela loader.Sym
RelPLT loader.Sym
RelaPLT loader.Sym
LinkEditGOT loader.Sym
LinkEditPLT loader.Sym
TOC loader.Sym
DotTOC []loader.Sym
GOT loader.Sym
PLT loader.Sym
GOTPLT loader.Sym
Tlsg loader.Sym
Tlsoffset int
Dynamic loader.Sym
DynSym loader.Sym
DynStr loader.Sym
unreachableMethod loader.Sym
mainInittasks loader.Sym</code></pre>
         </article>
         
         <article class="struct" data-name="Arch">
            <h2>type Arch struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Funcalign int
Maxalign int
Minalign int
Dwarfregsp int
Dwarfreglr int
TrampLimit uint64
CodePad []byte
Plan9Magic uint32
Plan9_64Bit bool
Adddynrel func
Archinit func
Archreloc func
Archrelocvariant func
Trampoline func
Asmb func
Asmb2 func
Extreloc func
Gentext func
Machoreloc1 func
MachorelocSize uint32
PEreloc1 func
Xcoffreloc1 func
GenSymsLate func
TLSIEtoLE func
AssignAddress func
ELF ELFArch</code></pre>
         </article>
         
         <article class="struct" data-name="Hostobj">
            <h2>type Hostobj struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">ld func
pkg string
pn string
file string
off int64
length int64</code></pre>
         </article>
         
         <article class="struct" data-name="Shlib">
            <h2>type Shlib struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Path string
Hash []byte
Deps []string
File *elf.File
symAddr *ast.MapType
relocTarget *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="shlibReloc">
            <h2>type shlibReloc struct</h2>
            <hr />
            
            <p>A relocation that applies to part of the shared library.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">addr uint64
target string</code></pre>
         </article>
         
         <article class="struct" data-name="Link">
            <h2>type Link struct</h2>
            <hr />
            
            <p>Link holds the context for writing object code from a compiler
or for reading that input into the linker.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Target
ErrorReporter
ArchSyms
outSem *ast.ChanType
Out *OutBuf
version int
Debugvlog int
Bso *bufio.Writer
Loaded bool
compressDWARF bool
Libdir []string
Library []*sym.Library
LibraryByPkg *ast.MapType
Shlibs []Shlib
Textp []loader.Sym
Moduledata loader.Sym
PackageFile *ast.MapType
PackageShlib *ast.MapType
tramps []loader.Sym
compUnits []*sym.CompilationUnit
runtimeCU *sym.CompilationUnit
loader *loader.Loader
cgodata []cgodata
datap []loader.Sym
dynexp []loader.Sym
numelfsym int
generatorSyms *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="cgodata">
            <h2>type cgodata struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">file string
pkg string
directives [][]string</code></pre>
         </article>
         
         <article class="struct" data-name="IMAGE_IMPORT_DESCRIPTOR">
            <h2>type IMAGE_IMPORT_DESCRIPTOR struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">OriginalFirstThunk uint32
TimeDateStamp uint32
ForwarderChain uint32
Name uint32
FirstThunk uint32</code></pre>
         </article>
         
         <article class="struct" data-name="IMAGE_EXPORT_DIRECTORY">
            <h2>type IMAGE_EXPORT_DIRECTORY struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Characteristics uint32
TimeDateStamp uint32
MajorVersion uint16
MinorVersion uint16
Name uint32
Base uint32
NumberOfFunctions uint32
NumberOfNames uint32
AddressOfFunctions uint32
AddressOfNames uint32
AddressOfNameOrdinals uint32</code></pre>
         </article>
         
         <article class="struct" data-name="Imp">
            <h2>type Imp struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">s loader.Sym
off uint64
next *Imp
argsize int</code></pre>
         </article>
         
         <article class="struct" data-name="Dll">
            <h2>type Dll struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
nameoff uint64
thunkoff uint64
ms *Imp
next *Dll</code></pre>
         </article>
         
         <article class="struct" data-name="peStringTable">
            <h2>type peStringTable struct</h2>
            <hr />
            
            <p>peStringTable is a COFF string table.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">strings []string
stringsLen int</code></pre>
         </article>
         
         <article class="struct" data-name="peSection">
            <h2>type peSection struct</h2>
            <hr />
            
            <p>peSection represents section from COFF section table.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
shortName string
index int
virtualSize uint32
virtualAddress uint32
sizeOfRawData uint32
pointerToRawData uint32
pointerToRelocations uint32
numberOfRelocations uint16
characteristics uint32</code></pre>
         </article>
         
         <article class="struct" data-name="peFile">
            <h2>type peFile struct</h2>
            <hr />
            
            <p>peFile is used to build COFF file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">sections []*peSection
stringTable peStringTable
textSect *peSection
rdataSect *peSection
dataSect *peSection
bssSect *peSection
ctorsSect *peSection
pdataSect *peSection
xdataSect *peSection
nextSectOffset uint32
nextFileOffset uint32
symtabOffset int64
symbolCount int
dataDirectory []pe.DataDirectory</code></pre>
         </article>
         
         <article class="struct" data-name="peBaseRelocEntry">
            <h2>type peBaseRelocEntry struct</h2>
            <hr />
            
            <p>peBaseRelocEntry represents a single relocation entry.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">typeOff uint16</code></pre>
         </article>
         
         <article class="struct" data-name="peBaseRelocBlock">
            <h2>type peBaseRelocBlock struct</h2>
            <hr />
            
            <p>peBaseRelocBlock represents a Base Relocation Block. A block
is a collection of relocation entries in a page, where each
entry describes a single relocation.
The block page RVA (Relative Virtual Address) is the index
into peBaseRelocTable.blocks.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">entries []peBaseRelocEntry</code></pre>
         </article>
         
         <article class="struct" data-name="peBaseRelocTable">
            <h2>type peBaseRelocTable struct</h2>
            <hr />
            
            <p>A PE base relocation table is a list of blocks, where each block
contains relocation information for a single page. The blocks
must be emitted in order of page virtual address.
See https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#the-reloc-section-image-only</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">blocks *ast.MapType
pages pePages</code></pre>
         </article>
         
         <article class="struct" data-name="relocSymState">
            <h2>type relocSymState struct</h2>
            <hr />
            
            <p>relocSymState hold state information needed when making a series of
successive calls to relocsym(). The items here are invariant
(meaning that they are set up once initially and then don't change
during the execution of relocsym), with the exception of a slice
used to facilitate batch allocation of external relocations. Calls
to relocsym happen in parallel; the assumption is that each
parallel thread will have its own state object.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">target *Target
ldr *loader.Loader
err *ErrorReporter
syms *ArchSyms</code></pre>
         </article>
         
         <article class="struct" data-name="GCProg">
            <h2>type GCProg struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">ctxt *Link
sym *loader.SymbolBuilder
w gcprog.Writer</code></pre>
         </article>
         
         <article class="struct" data-name="dodataState">
            <h2>type dodataState struct</h2>
            <hr />
            
            <p>dodataState holds bits of state information needed by dodata() and the
various helpers it calls. The lifetime of these items should not extend
past the end of dodata().</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ctxt *Link
data [][]loader.Sym
dataMaxAlign []int32
symGroupType []sym.SymKind
datsize int64</code></pre>
         </article>
         
         <article class="struct" data-name="symNameSize">
            <h2>type symNameSize struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
sz int64
val int64
sym loader.Sym</code></pre>
         </article>
         
         <article class="struct" data-name="dwctxt">
            <h2>type dwctxt struct</h2>
            <hr />
            
            <p>dwctxt is a wrapper intended to satisfy the method set of
dwarf.Context, so that functions like dwarf.PutAttrs will work with
DIEs that use loader.Sym as opposed to *sym.Symbol. It is also
being used as a place to store tables/maps that are useful as part
of type conversion (this is just a convenience; it would be easy to
split these things out into another type if need be).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">linkctxt *Link
ldr *loader.Loader
arch *sys.Arch
tmap *ast.MapType
rtmap *ast.MapType
tdmap *ast.MapType
typeRuntimeEface loader.Sym
typeRuntimeIface loader.Sym
uintptrInfoSym loader.Sym
dwmu *sync.Mutex</code></pre>
         </article>
         
         <article class="struct" data-name="dwarfSecInfo">
            <h2>type dwarfSecInfo struct</h2>
            <hr />
            
            <p>dwarfSecInfo holds information about a DWARF output section,
specifically a section symbol and a list of symbols contained in
that section. On the syms list, the first symbol will always be the
section symbol, then any remaining symbols (if any) will be
sub-symbols in that section. Note that for some sections (eg:
.debug_abbrev), the section symbol is all there is (all content is
contained in it). For other sections (eg: .debug_info), the section
symbol is empty and all the content is in the sub-symbols. Finally
there are some sections (eg: .debug_ranges) where it is a mix (both
the section symbol and the sub-symbols have content)</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">syms []loader.Sym</code></pre>
         </article>
         
         <article class="struct" data-name="dwUnitSyms">
            <h2>type dwUnitSyms struct</h2>
            <hr />
            
            <p>dwUnitSyms stores input and output symbols for DWARF generation
for a given compilation unit.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">lineProlog loader.Sym
rangeProlog loader.Sym
infoEpilog loader.Sym
linesyms []loader.Sym
infosyms []loader.Sym
locsyms []loader.Sym
rangessyms []loader.Sym</code></pre>
         </article>
         
         <article class="struct" data-name="unresolvedSymKey">
            <h2>type unresolvedSymKey struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">from loader.Sym
to loader.Sym</code></pre>
         </article>
         
         <article class="struct" data-name="ErrorReporter">
            <h2>type ErrorReporter struct</h2>
            <hr />
            
            <p>ErrorReporter is used to make error reporting thread safe.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">loader.ErrorReporter
unresSyms *ast.MapType
unresMutex sync.Mutex
SymName symNameFn</code></pre>
         </article>
         
         <article class="struct" data-name="MachoHdr">
            <h2>type MachoHdr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">cpu uint32
subcpu uint32</code></pre>
         </article>
         
         <article class="struct" data-name="MachoSect">
            <h2>type MachoSect struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
segname string
addr uint64
size uint64
off uint32
align uint32
reloc uint32
nreloc uint32
flag uint32
res1 uint32
res2 uint32</code></pre>
         </article>
         
         <article class="struct" data-name="MachoSeg">
            <h2>type MachoSeg struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
vsize uint64
vaddr uint64
fileoffset uint64
filesize uint64
prot1 uint32
prot2 uint32
nsect uint32
msect uint32
sect []MachoSect
flag uint32</code></pre>
         </article>
         
         <article class="struct" data-name="MachoPlatformLoad">
            <h2>type MachoPlatformLoad struct</h2>
            <hr />
            
            <p>MachoPlatformLoad represents a LC_VERSION_MIN_* or
LC_BUILD_VERSION load command.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">platform MachoPlatform
cmd MachoLoad</code></pre>
         </article>
         
         <article class="struct" data-name="MachoLoad">
            <h2>type MachoLoad struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">type_ uint32
data []uint32</code></pre>
         </article>
         
         <article class="struct" data-name="machoRebaseRecord">
            <h2>type machoRebaseRecord struct</h2>
            <hr />
            
            <p>A rebase entry tells the dynamic linker the data at sym+off needs to be
relocated when the in-memory image moves. (This is somewhat like, say,
ELF R_X86_64_RELATIVE).
For now, the only kind of entry we support is that the data is an absolute
address. That seems all we need.
In the binary it uses a compact stateful bytecode encoding. So we record
entries as we go and build the table at the end.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">sym loader.Sym
off int64</code></pre>
         </article>
         
         <article class="struct" data-name="machoBindRecord">
            <h2>type machoBindRecord struct</h2>
            <hr />
            
            <p>A bind entry tells the dynamic linker the data at GOT+off should be bound
to the address of the target symbol, which is a dynamic import.
For now, the only kind of entry we support is that the data is an absolute
address, and the source symbol is always the GOT. That seems all we need.
In the binary it uses a compact stateful bytecode encoding. So we record
entries as we go and build the table at the end.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">off int64
targ loader.Sym</code></pre>
         </article>
         
         <article class="struct" data-name="dyldInfoCmd">
            <h2>type dyldInfoCmd struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Cmd macho.LoadCmd
Len uint32
RebaseOff uint32
RebaseLen uint32
BindOff uint32
BindLen uint32
WeakBindOff uint32
WeakBindLen uint32
LazyBindOff uint32
LazyBindLen uint32
ExportOff uint32
ExportLen uint32</code></pre>
         </article>
         
         <article class="struct" data-name="linkEditDataCmd">
            <h2>type linkEditDataCmd struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Cmd macho.LoadCmd
Len uint32
DataOff uint32
DataLen uint32</code></pre>
         </article>
         
         <article class="struct" data-name="encryptionInfoCmd">
            <h2>type encryptionInfoCmd struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Cmd macho.LoadCmd
Len uint32
CryptOff uint32
CryptLen uint32
CryptId uint32</code></pre>
         </article>
         
         <article class="struct" data-name="uuidCmd">
            <h2>type uuidCmd struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Cmd macho.LoadCmd
Len uint32
Uuid []byte</code></pre>
         </article>
          
         <article class="function" data-name="Mmap">
            <h2>Mmap</h2>
            <hr />
            
            <p>Mmap maps the output file with the given size. It unmaps the old mapping
if it is already mapped. It also flushes any in-heap data to the new
mapping.</p>
            
            <pre><code>func Mmap(filesize uint64) err error</code></pre>
         </article>
         
         <article class="function" data-name="munmap">
            <h2>munmap</h2>
            <hr />
            
            <pre><code>func munmap()</code></pre>
         </article>
         
         <article class="function" data-name="purgeSignatureCache">
            <h2>purgeSignatureCache</h2>
            <hr />
            
            <pre><code>func purgeSignatureCache()</code></pre>
         </article>
         
         <article class="function" data-name="setUpContext">
            <h2>setUpContext</h2>
            <hr />
            
            <pre><code>func setUpContext(arch *sys.Arch, iself bool, ht objabi.HeadType, bm string, lm string) *Link</code></pre>
         </article>
         
         <article class="function" data-name="TestAddGotSym">
            <h2>TestAddGotSym</h2>
            <hr />
            
            <p>Make sure the addgotsym properly increases the symbols.</p>
            
            <pre><code>func TestAddGotSym(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="mustHaveDWARF">
            <h2>mustHaveDWARF</h2>
            <hr />
            
            <pre><code>func mustHaveDWARF(t testing.TB)</code></pre>
         </article>
         
         <article class="function" data-name="TestRuntimeTypesPresent">
            <h2>TestRuntimeTypesPresent</h2>
            <hr />
            
            <pre><code>func TestRuntimeTypesPresent(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="findTypes">
            <h2>findTypes</h2>
            <hr />
            
            <pre><code>func findTypes(t *testing.T, dw *dwarf.Data, want *ast.MapType) found *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="gobuild">
            <h2>gobuild</h2>
            <hr />
            
            <pre><code>func gobuild(t *testing.T, dir string, testfile string, gcflags string) *builtFile</code></pre>
         </article>
         
         <article class="function" data-name="gobuildTestdata">
            <h2>gobuildTestdata</h2>
            <hr />
            
            <pre><code>func gobuildTestdata(t *testing.T, pkgDir string, gcflags string) *builtFile</code></pre>
         </article>
         
         <article class="function" data-name="gobuildAndExamine">
            <h2>gobuildAndExamine</h2>
            <hr />
            
            <p>Helper to build a snippet of source for examination with dwtest.Examiner.</p>
            
            <pre><code>func gobuildAndExamine(t *testing.T, source string, gcflags string) (*dwarf.Data, *dwtest.Examiner)</code></pre>
         </article>
         
         <article class="function" data-name="findSubprogramDIE">
            <h2>findSubprogramDIE</h2>
            <hr />
            
            <pre><code>func findSubprogramDIE(t *testing.T, ex *dwtest.Examiner, sym string) *dwarf.Entry</code></pre>
         </article>
         
         <article class="function" data-name="TestEmbeddedStructMarker">
            <h2>TestEmbeddedStructMarker</h2>
            <hr />
            
            <pre><code>func TestEmbeddedStructMarker(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="findMembers">
            <h2>findMembers</h2>
            <hr />
            
            <pre><code>func findMembers(rdr *dwarf.Reader) (*ast.MapType, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestSizes">
            <h2>TestSizes</h2>
            <hr />
            
            <pre><code>func TestSizes(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestFieldOverlap">
            <h2>TestFieldOverlap</h2>
            <hr />
            
            <pre><code>func TestFieldOverlap(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSubprogramDeclFileLine">
            <h2>TestSubprogramDeclFileLine</h2>
            <hr />
            
            <pre><code>func TestSubprogramDeclFileLine(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestVarDeclLine">
            <h2>TestVarDeclLine</h2>
            <hr />
            
            <pre><code>func TestVarDeclLine(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInlinedRoutineCallFileLine">
            <h2>TestInlinedRoutineCallFileLine</h2>
            <hr />
            
            <p>TestInlinedRoutineCallFileLine tests the call file and line records for an
inlined subroutine.</p>
            
            <pre><code>func TestInlinedRoutineCallFileLine(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInlinedRoutineArgsVars">
            <h2>TestInlinedRoutineArgsVars</h2>
            <hr />
            
            <p>TestInlinedRoutineArgsVars tests the argument and variable records for an inlined subroutine.</p>
            
            <pre><code>func TestInlinedRoutineArgsVars(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="abstractOriginSanity">
            <h2>abstractOriginSanity</h2>
            <hr />
            
            <pre><code>func abstractOriginSanity(t *testing.T, pkgDir string, flags string)</code></pre>
         </article>
         
         <article class="function" data-name="TestAbstractOriginSanity">
            <h2>TestAbstractOriginSanity</h2>
            <hr />
            
            <pre><code>func TestAbstractOriginSanity(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAbstractOriginSanityIssue25459">
            <h2>TestAbstractOriginSanityIssue25459</h2>
            <hr />
            
            <pre><code>func TestAbstractOriginSanityIssue25459(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAbstractOriginSanityIssue26237">
            <h2>TestAbstractOriginSanityIssue26237</h2>
            <hr />
            
            <pre><code>func TestAbstractOriginSanityIssue26237(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestRuntimeTypeAttrInternal">
            <h2>TestRuntimeTypeAttrInternal</h2>
            <hr />
            
            <pre><code>func TestRuntimeTypeAttrInternal(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestRuntimeTypeAttrExternal">
            <h2>TestRuntimeTypeAttrExternal</h2>
            <hr />
            
            <p>External linking requires a host linker (https://golang.org/src/cmd/cgo/doc.go l.732)</p>
            
            <pre><code>func TestRuntimeTypeAttrExternal(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testRuntimeTypeAttr">
            <h2>testRuntimeTypeAttr</h2>
            <hr />
            
            <pre><code>func testRuntimeTypeAttr(t *testing.T, flags string)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue27614">
            <h2>TestIssue27614</h2>
            <hr />
            
            <pre><code>func TestIssue27614(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestStaticTmp">
            <h2>TestStaticTmp</h2>
            <hr />
            
            <pre><code>func TestStaticTmp(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPackageNameAttr">
            <h2>TestPackageNameAttr</h2>
            <hr />
            
            <pre><code>func TestPackageNameAttr(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMachoIssue32233">
            <h2>TestMachoIssue32233</h2>
            <hr />
            
            <pre><code>func TestMachoIssue32233(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWindowsIssue36495">
            <h2>TestWindowsIssue36495</h2>
            <hr />
            
            <pre><code>func TestWindowsIssue36495(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue38192">
            <h2>TestIssue38192</h2>
            <hr />
            
            <pre><code>func TestIssue38192(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue39757">
            <h2>TestIssue39757</h2>
            <hr />
            
            <pre><code>func TestIssue39757(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue42484">
            <h2>TestIssue42484</h2>
            <hr />
            
            <pre><code>func TestIssue42484(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="processParams">
            <h2>processParams</h2>
            <hr />
            
            <p>processParams examines the formal parameter children of subprogram
DIE "die" using the explorer "ex" and returns a string that
captures the name, order, and classification of the subprogram's
input and output parameters. For example, for the go function

	func foo(i1 int, f1 float64) (string, bool) {

this function would return a string something like

	i1:0:1 f1:1:1 ~r0:2:2 ~r1:3:2

where each chunk above is of the form NAME:ORDER:INOUTCLASSIFICATION</p>
            
            <pre><code>func processParams(die *dwarf.Entry, ex *dwtest.Examiner) string</code></pre>
         </article>
         
         <article class="function" data-name="TestOutputParamAbbrevAndAttr">
            <h2>TestOutputParamAbbrevAndAttr</h2>
            <hr />
            
            <pre><code>func TestOutputParamAbbrevAndAttr(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDictIndex">
            <h2>TestDictIndex</h2>
            <hr />
            
            <pre><code>func TestDictIndex(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestOptimizedOutParamHandling">
            <h2>TestOptimizedOutParamHandling</h2>
            <hr />
            
            <pre><code>func TestOptimizedOutParamHandling(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue54320">
            <h2>TestIssue54320</h2>
            <hr />
            
            <pre><code>func TestIssue54320(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestZeroSizedVariable">
            <h2>TestZeroSizedVariable</h2>
            <hr />
            
            <pre><code>func TestZeroSizedVariable(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestConsistentGoKindAndRuntimeType">
            <h2>TestConsistentGoKindAndRuntimeType</h2>
            <hr />
            
            <pre><code>func TestConsistentGoKindAndRuntimeType(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="ldpkg">
            <h2>ldpkg</h2>
            <hr />
            
            <pre><code>func ldpkg(ctxt *Link, f *bio.Reader, lib *sym.Library, length int64, filename string)</code></pre>
         </article>
         
         <article class="function" data-name="loadcgo">
            <h2>loadcgo</h2>
            <hr />
            
            <pre><code>func loadcgo(ctxt *Link, file string, pkg string, p string)</code></pre>
         </article>
         
         <article class="function" data-name="setCgoAttr">
            <h2>setCgoAttr</h2>
            <hr />
            
            <p>Set symbol attributes or flags based on cgo directives.
Any newly discovered HOSTOBJ syms are added to 'hostObjSyms'.</p>
            
            <pre><code>func setCgoAttr(ctxt *Link, file string, pkg string, directives [][]string, hostObjSyms *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="openbsdTrimLibVersion">
            <h2>openbsdTrimLibVersion</h2>
            <hr />
            
            <p>openbsdTrimLibVersion indicates whether a shared library is
versioned and if it is, returns the unversioned name. The
OpenBSD library naming scheme is lib<name>.so.<major>.<minor></p>
            
            <pre><code>func openbsdTrimLibVersion(lib string) (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="dedupLibrariesOpenBSD">
            <h2>dedupLibrariesOpenBSD</h2>
            <hr />
            
            <p>dedupLibrariesOpenBSD dedups a list of shared libraries, treating versioned
and unversioned libraries as equivalents. Versioned libraries are preferred
and retained over unversioned libraries. This avoids the situation where
the use of cgo results in a DT_NEEDED for a versioned library (for example,
libc.so.96.1), while a dynamic import specifies an unversioned library (for
example, libc.so) - this would otherwise result in two DT_NEEDED entries
for the same library, resulting in a failure when ld.so attempts to load
the Go binary.</p>
            
            <pre><code>func dedupLibrariesOpenBSD(ctxt *Link, libs []string) []string</code></pre>
         </article>
         
         <article class="function" data-name="dedupLibraries">
            <h2>dedupLibraries</h2>
            <hr />
            
            <pre><code>func dedupLibraries(ctxt *Link, libs []string) []string</code></pre>
         </article>
         
         <article class="function" data-name="adddynlib">
            <h2>adddynlib</h2>
            <hr />
            
            <pre><code>func adddynlib(ctxt *Link, lib string)</code></pre>
         </article>
         
         <article class="function" data-name="Adddynsym">
            <h2>Adddynsym</h2>
            <hr />
            
            <pre><code>func Adddynsym(ldr *loader.Loader, target *Target, syms *ArchSyms, s loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="fieldtrack">
            <h2>fieldtrack</h2>
            <hr />
            
            <pre><code>func fieldtrack(arch *sys.Arch, l *loader.Loader)</code></pre>
         </article>
         
         <article class="function" data-name="addexport">
            <h2>addexport</h2>
            <hr />
            
            <pre><code>func addexport()</code></pre>
         </article>
         
         <article class="function" data-name="push">
            <h2>push</h2>
            <hr />
            
            <pre><code>func push(s loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="pop">
            <h2>pop</h2>
            <hr />
            
            <pre><code>func pop() loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="empty">
            <h2>empty</h2>
            <hr />
            
            <pre><code>func empty() bool</code></pre>
         </article>
         
         <article class="function" data-name="push">
            <h2>push</h2>
            <hr />
            
            <pre><code>func push(ldr *loader.Loader, s loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="pop">
            <h2>pop</h2>
            <hr />
            
            <pre><code>func pop(ldr *loader.Loader) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="empty">
            <h2>empty</h2>
            <hr />
            
            <pre><code>func empty() bool</code></pre>
         </article>
         
         <article class="function" data-name="fallocate">
            <h2>fallocate</h2>
            <hr />
            
            <pre><code>func fallocate(size uint64) error</code></pre>
         </article>
         
         <article class="function" data-name="fallocate">
            <h2>fallocate</h2>
            <hr />
            
            <pre><code>func fallocate(size uint64) error</code></pre>
         </article>
         
         <article class="function" data-name="doStackCheck">
            <h2>doStackCheck</h2>
            <hr />
            
            <p>doStackCheck walks the call tree to check that there is always
enough stack space for call frames, especially for a chain of
nosplit functions.

It walks all functions to accumulate the number of bytes they can
grow the stack by without a split check and checks this against the
limit.</p>
            
            <pre><code>func doStackCheck()</code></pre>
         </article>
         
         <article class="function" data-name="newStackCheck">
            <h2>newStackCheck</h2>
            <hr />
            
            <pre><code>func newStackCheck(ctxt *Link, graph bool) *stackCheck</code></pre>
         </article>
         
         <article class="function" data-name="symName">
            <h2>symName</h2>
            <hr />
            
            <pre><code>func symName(sym loader.Sym) string</code></pre>
         </article>
         
         <article class="function" data-name="check">
            <h2>check</h2>
            <hr />
            
            <p>check returns the stack height of sym. It populates sc.height and
sc.graph for sym and every function in its call tree.</p>
            
            <pre><code>func check(sym loader.Sym) int</code></pre>
         </article>
         
         <article class="function" data-name="computeHeight">
            <h2>computeHeight</h2>
            <hr />
            
            <p>computeHeight returns the stack height of sym. If graph is true, it
also returns the out-edges of sym.

Caching is applied to this in check. Call check instead of calling
this directly.</p>
            
            <pre><code>func computeHeight(sym loader.Sym, graph bool) (int, []stackCheckEdge)</code></pre>
         </article>
         
         <article class="function" data-name="findRoots">
            <h2>findRoots</h2>
            <hr />
            
            <pre><code>func findRoots() []loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="report">
            <h2>report</h2>
            <hr />
            
            <pre><code>func report(sym loader.Sym, depth int, chain *[]stackCheckChain)</code></pre>
         </article>
         
         <article class="function" data-name="asmb">
            <h2>asmb</h2>
            <hr />
            
            <p>Assembling the binary is broken into two steps:
  - writing out the code/data/dwarf Segments, applying relocations on the fly
  - writing out the architecture specific pieces.

This function handles the first part.</p>
            
            <pre><code>func asmb(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="asmb2">
            <h2>asmb2</h2>
            <hr />
            
            <p>Assembling the binary is broken into two steps:
  - writing out the code/data/dwarf Segments
  - writing out the architecture specific pieces.

This function handles the second part.</p>
            
            <pre><code>func asmb2(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="writePlan9Header">
            <h2>writePlan9Header</h2>
            <hr />
            
            <p>writePlan9Header writes out the plan9 header at the present position in the OutBuf.</p>
            
            <pre><code>func writePlan9Header(buf *OutBuf, magic uint32, entry int64, is64Bit bool)</code></pre>
         </article>
         
         <article class="function" data-name="asmbPlan9">
            <h2>asmbPlan9</h2>
            <hr />
            
            <p>asmbPlan9 assembles a plan 9 binary.</p>
            
            <pre><code>func asmbPlan9(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="sizeExtRelocs">
            <h2>sizeExtRelocs</h2>
            <hr />
            
            <p>sizeExtRelocs precomputes the size needed for the reloc records,
sets the size and offset for relocation records in each section,
and mmap the output buffer with the proper size.</p>
            
            <pre><code>func sizeExtRelocs(ctxt *Link, relsize uint32)</code></pre>
         </article>
         
         <article class="function" data-name="relocSectFn">
            <h2>relocSectFn</h2>
            <hr />
            
            <p>relocSectFn wraps the function writing relocations of a section
for parallel execution. Returns the wrapped function and a wait
group for which the caller should wait.</p>
            
            <pre><code>func relocSectFn(ctxt *Link, relocSect func) (func, *sync.WaitGroup)</code></pre>
         </article>
         
         <article class="function" data-name="TestDeadcode">
            <h2>TestDeadcode</h2>
            <hr />
            
            <pre><code>func TestDeadcode(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="execArchive">
            <h2>execArchive</h2>
            <hr />
            
            <pre><code>func execArchive(argv []string)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue33808">
            <h2>TestIssue33808</h2>
            <hr />
            
            <pre><code>func TestIssue33808(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUndefinedRelocErrors">
            <h2>TestUndefinedRelocErrors</h2>
            <hr />
            
            <pre><code>func TestUndefinedRelocErrors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestArchiveBuildInvokeWithExec">
            <h2>TestArchiveBuildInvokeWithExec</h2>
            <hr />
            
            <pre><code>func TestArchiveBuildInvokeWithExec(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLargeTextSectionSplitting">
            <h2>TestLargeTextSectionSplitting</h2>
            <hr />
            
            <pre><code>func TestLargeTextSectionSplitting(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWindowsBuildmodeCSharedASLR">
            <h2>TestWindowsBuildmodeCSharedASLR</h2>
            <hr />
            
            <pre><code>func TestWindowsBuildmodeCSharedASLR(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testWindowsBuildmodeCSharedASLR">
            <h2>testWindowsBuildmodeCSharedASLR</h2>
            <hr />
            
            <pre><code>func testWindowsBuildmodeCSharedASLR(t *testing.T, useASLR bool)</code></pre>
         </article>
         
         <article class="function" data-name="TestMemProfileCheck">
            <h2>TestMemProfileCheck</h2>
            <hr />
            
            <p>TestMemProfileCheck tests that cmd/link sets
runtime.disableMemoryProfiling if the runtime.MemProfile
symbol is unreachable after deadcode (and not dynlinking).
The runtime then uses that to set the default value of
runtime.MemProfileRate, which this test checks.</p>
            
            <pre><code>func TestMemProfileCheck(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestRISCVTrampolines">
            <h2>TestRISCVTrampolines</h2>
            <hr />
            
            <pre><code>func TestRISCVTrampolines(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestStackCheckOutput">
            <h2>TestStackCheckOutput</h2>
            <hr />
            
            <pre><code>func TestStackCheckOutput(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="putelfstr">
            <h2>putelfstr</h2>
            <hr />
            
            <pre><code>func putelfstr(s string) int</code></pre>
         </article>
         
         <article class="function" data-name="putelfsyment">
            <h2>putelfsyment</h2>
            <hr />
            
            <pre><code>func putelfsyment(out *OutBuf, off int, addr int64, size int64, info uint8, shndx elf.SectionIndex, other int)</code></pre>
         </article>
         
         <article class="function" data-name="putelfsym">
            <h2>putelfsym</h2>
            <hr />
            
            <pre><code>func putelfsym(ctxt *Link, x loader.Sym, typ elf.SymType, curbind elf.SymBind)</code></pre>
         </article>
         
         <article class="function" data-name="putelfsectionsym">
            <h2>putelfsectionsym</h2>
            <hr />
            
            <pre><code>func putelfsectionsym(ctxt *Link, out *OutBuf, s loader.Sym, shndx elf.SectionIndex)</code></pre>
         </article>
         
         <article class="function" data-name="genelfsym">
            <h2>genelfsym</h2>
            <hr />
            
            <pre><code>func genelfsym(ctxt *Link, elfbind elf.SymBind)</code></pre>
         </article>
         
         <article class="function" data-name="asmElfSym">
            <h2>asmElfSym</h2>
            <hr />
            
            <pre><code>func asmElfSym(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="putplan9sym">
            <h2>putplan9sym</h2>
            <hr />
            
            <pre><code>func putplan9sym(ctxt *Link, ldr *loader.Loader, s loader.Sym, char SymbolType)</code></pre>
         </article>
         
         <article class="function" data-name="asmbPlan9Sym">
            <h2>asmbPlan9Sym</h2>
            <hr />
            
            <pre><code>func asmbPlan9Sym(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="textsectionmap">
            <h2>textsectionmap</h2>
            <hr />
            
            <p>Create a table with information on the text sections.
Return the symbol of the table, and number of sections.</p>
            
            <pre><code>func textsectionmap(ctxt *Link) (loader.Sym, uint32)</code></pre>
         </article>
         
         <article class="function" data-name="symtab">
            <h2>symtab</h2>
            <hr />
            
            <pre><code>func symtab(pcln *pclntab) []sym.SymKind</code></pre>
         </article>
         
         <article class="function" data-name="setCarrierSym">
            <h2>setCarrierSym</h2>
            <hr />
            
            <pre><code>func setCarrierSym(typ sym.SymKind, s loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="setCarrierSize">
            <h2>setCarrierSize</h2>
            <hr />
            
            <pre><code>func setCarrierSize(typ sym.SymKind, sz int64)</code></pre>
         </article>
         
         <article class="function" data-name="isStaticTmp">
            <h2>isStaticTmp</h2>
            <hr />
            
            <pre><code>func isStaticTmp(name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="mangleABIName">
            <h2>mangleABIName</h2>
            <hr />
            
            <p>Mangle function name with ABI information.</p>
            
            <pre><code>func mangleABIName(ctxt *Link, ldr *loader.Loader, x loader.Sym, name string) string</code></pre>
         </article>
         
         <article class="function" data-name="IsExe">
            <h2>IsExe</h2>
            <hr />
            
            <pre><code>func IsExe() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsShared">
            <h2>IsShared</h2>
            <hr />
            
            <pre><code>func IsShared() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsPlugin">
            <h2>IsPlugin</h2>
            <hr />
            
            <pre><code>func IsPlugin() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsInternal">
            <h2>IsInternal</h2>
            <hr />
            
            <pre><code>func IsInternal() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsExternal">
            <h2>IsExternal</h2>
            <hr />
            
            <pre><code>func IsExternal() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsPIE">
            <h2>IsPIE</h2>
            <hr />
            
            <pre><code>func IsPIE() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsSharedGoLink">
            <h2>IsSharedGoLink</h2>
            <hr />
            
            <pre><code>func IsSharedGoLink() bool</code></pre>
         </article>
         
         <article class="function" data-name="CanUsePlugins">
            <h2>CanUsePlugins</h2>
            <hr />
            
            <pre><code>func CanUsePlugins() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsElf">
            <h2>IsElf</h2>
            <hr />
            
            <pre><code>func IsElf() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsDynlinkingGo">
            <h2>IsDynlinkingGo</h2>
            <hr />
            
            <pre><code>func IsDynlinkingGo() bool</code></pre>
         </article>
         
         <article class="function" data-name="UseRelro">
            <h2>UseRelro</h2>
            <hr />
            
            <p>UseRelro reports whether to make use of "read only relocations" aka
relro.</p>
            
            <pre><code>func UseRelro() bool</code></pre>
         </article>
         
         <article class="function" data-name="Is386">
            <h2>Is386</h2>
            <hr />
            
            <pre><code>func Is386() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsARM">
            <h2>IsARM</h2>
            <hr />
            
            <pre><code>func IsARM() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsARM64">
            <h2>IsARM64</h2>
            <hr />
            
            <pre><code>func IsARM64() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsAMD64">
            <h2>IsAMD64</h2>
            <hr />
            
            <pre><code>func IsAMD64() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsMIPS">
            <h2>IsMIPS</h2>
            <hr />
            
            <pre><code>func IsMIPS() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsMIPS64">
            <h2>IsMIPS64</h2>
            <hr />
            
            <pre><code>func IsMIPS64() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsLOONG64">
            <h2>IsLOONG64</h2>
            <hr />
            
            <pre><code>func IsLOONG64() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsPPC64">
            <h2>IsPPC64</h2>
            <hr />
            
            <pre><code>func IsPPC64() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsRISCV64">
            <h2>IsRISCV64</h2>
            <hr />
            
            <pre><code>func IsRISCV64() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsS390X">
            <h2>IsS390X</h2>
            <hr />
            
            <pre><code>func IsS390X() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsWasm">
            <h2>IsWasm</h2>
            <hr />
            
            <pre><code>func IsWasm() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsLinux">
            <h2>IsLinux</h2>
            <hr />
            
            <pre><code>func IsLinux() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsDarwin">
            <h2>IsDarwin</h2>
            <hr />
            
            <pre><code>func IsDarwin() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsWindows">
            <h2>IsWindows</h2>
            <hr />
            
            <pre><code>func IsWindows() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsPlan9">
            <h2>IsPlan9</h2>
            <hr />
            
            <pre><code>func IsPlan9() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsAIX">
            <h2>IsAIX</h2>
            <hr />
            
            <pre><code>func IsAIX() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsSolaris">
            <h2>IsSolaris</h2>
            <hr />
            
            <pre><code>func IsSolaris() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsNetbsd">
            <h2>IsNetbsd</h2>
            <hr />
            
            <pre><code>func IsNetbsd() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsOpenbsd">
            <h2>IsOpenbsd</h2>
            <hr />
            
            <pre><code>func IsOpenbsd() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsFreebsd">
            <h2>IsFreebsd</h2>
            <hr />
            
            <pre><code>func IsFreebsd() bool</code></pre>
         </article>
         
         <article class="function" data-name="mustSetHeadType">
            <h2>mustSetHeadType</h2>
            <hr />
            
            <pre><code>func mustSetHeadType()</code></pre>
         </article>
         
         <article class="function" data-name="IsBigEndian">
            <h2>IsBigEndian</h2>
            <hr />
            
            <pre><code>func IsBigEndian() bool</code></pre>
         </article>
         
         <article class="function" data-name="UsesLibc">
            <h2>UsesLibc</h2>
            <hr />
            
            <pre><code>func UsesLibc() bool</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <p>Set implements flag.Value to set the build mode based on the argument
to the -buildmode flag.</p>
            
            <pre><code>func Set(s string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(s string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="mustLinkExternal">
            <h2>mustLinkExternal</h2>
            <hr />
            
            <p>mustLinkExternal reports whether the program being linked requires
the external linker be used to complete the link.</p>
            
            <pre><code>func mustLinkExternal(ctxt *Link) (res bool, reason string)</code></pre>
         </article>
         
         <article class="function" data-name="determineLinkMode">
            <h2>determineLinkMode</h2>
            <hr />
            
            <p>determineLinkMode sets ctxt.LinkMode.

It is called after flags are processed and inputs are processed,
so the ctxt.LinkMode variable has an initial value from the -linkmode
flag and the iscgo, externalobj, and unknownObjFormat variables are set.</p>
            
            <pre><code>func determineLinkMode(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="flood">
            <h2>flood</h2>
            <hr />
            
            <pre><code>func flood()</code></pre>
         </article>
         
         <article class="function" data-name="mapinitcleanup">
            <h2>mapinitcleanup</h2>
            <hr />
            
            <p>mapinitcleanup walks all pkg init functions and looks for weak relocations
to mapinit symbols that are no longer reachable. It rewrites
the relocs to target a new no-op routine in the runtime.</p>
            
            <pre><code>func mapinitcleanup()</code></pre>
         </article>
         
         <article class="function" data-name="mark">
            <h2>mark</h2>
            <hr />
            
            <pre><code>func mark(symIdx loader.Sym, parent loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="dumpDepAddFlags">
            <h2>dumpDepAddFlags</h2>
            <hr />
            
            <pre><code>func dumpDepAddFlags(name string, symIdx loader.Sym) string</code></pre>
         </article>
         
         <article class="function" data-name="markMethod">
            <h2>markMethod</h2>
            <hr />
            
            <pre><code>func markMethod(m methodref)</code></pre>
         </article>
         
         <article class="function" data-name="deadcode">
            <h2>deadcode</h2>
            <hr />
            
            <p>deadcode marks all reachable symbols.

The basis of the dead code elimination is a flood fill of symbols,
following their relocations, beginning at *flagEntrySymbol.

This flood fill is wrapped in logic for pruning unused methods.
All methods are mentioned by relocations on their receiver's *rtype.
These relocations are specially defined as R_METHODOFF by the compiler
so we can detect and manipulated them here.

There are three ways a method of a reachable type can be invoked:

 1. direct call
 2. through a reachable interface type
 3. reflect.Value.Method (or MethodByName), or reflect.Type.Method
    (or MethodByName)

The first case is handled by the flood fill, a directly called method
is marked as reachable.

The second case is handled by decomposing all reachable interface
types into method signatures. Each encountered method is compared
against the interface method signatures, if it matches it is marked
as reachable. This is extremely conservative, but easy and correct.

The third case is handled by looking for functions that compiler flagged
as REFLECTMETHOD. REFLECTMETHOD on a function F means that F does a method
lookup with reflection, but the compiler was not able to statically determine
the method name.

All functions that call reflect.Value.Method or reflect.Type.Method are REFLECTMETHODs.
Functions that call reflect.Value.MethodByName or reflect.Type.MethodByName with
a non-constant argument are REFLECTMETHODs, too. If we find a REFLECTMETHOD,
we give up on static analysis, and mark all exported methods of all reachable
types as reachable.

If the argument to MethodByName is a compile-time constant, the compiler
emits a relocation with the method name. Matching methods are kept in all
reachable types.

Any unreached text symbols are removed from ctxt.Textp.</p>
            
            <pre><code>func deadcode(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="isExported">
            <h2>isExported</h2>
            <hr />
            
            <pre><code>func isExported() bool</code></pre>
         </article>
         
         <article class="function" data-name="decodeMethodSig">
            <h2>decodeMethodSig</h2>
            <hr />
            
            <p>decodeMethodSig decodes an array of method signature information.
Each element of the array is size bytes. The first 4 bytes is a
nameOff for the method name, and the next 4 bytes is a typeOff for
the function type.

Conveniently this is the layout of both runtime.method and runtime.imethod.</p>
            
            <pre><code>func decodeMethodSig(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, relocs *loader.Relocs, off int, size int, count int) []methodsig</code></pre>
         </article>
         
         <article class="function" data-name="decodeIfaceMethod">
            <h2>decodeIfaceMethod</h2>
            <hr />
            
            <p>Decode the method of interface type symbol symIdx at offset off.</p>
            
            <pre><code>func decodeIfaceMethod(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, off int64) methodsig</code></pre>
         </article>
         
         <article class="function" data-name="decodeGenericIfaceMethod">
            <h2>decodeGenericIfaceMethod</h2>
            <hr />
            
            <p>Decode the method name stored in symbol symIdx. The symbol should contain just the bytes of a method name.</p>
            
            <pre><code>func decodeGenericIfaceMethod(ldr *loader.Loader, symIdx loader.Sym) string</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeMethods">
            <h2>decodetypeMethods</h2>
            <hr />
            
            <pre><code>func decodetypeMethods(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, relocs *loader.Relocs) []methodsig</code></pre>
         </article>
         
         <article class="function" data-name="decodeInuxi">
            <h2>decodeInuxi</h2>
            <hr />
            
            <pre><code>func decodeInuxi(arch *sys.Arch, p []byte, sz int) uint64</code></pre>
         </article>
         
         <article class="function" data-name="commonsize">
            <h2>commonsize</h2>
            <hr />
            
            <pre><code>func commonsize(arch *sys.Arch) int</code></pre>
         </article>
         
         <article class="function" data-name="structfieldSize">
            <h2>structfieldSize</h2>
            <hr />
            
            <pre><code>func structfieldSize(arch *sys.Arch) int</code></pre>
         </article>
         
         <article class="function" data-name="uncommonSize">
            <h2>uncommonSize</h2>
            <hr />
            
            <pre><code>func uncommonSize(arch *sys.Arch) int</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeKind">
            <h2>decodetypeKind</h2>
            <hr />
            
            <p>Type.commonType.kind</p>
            
            <pre><code>func decodetypeKind(arch *sys.Arch, p []byte) abi.Kind</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeSize">
            <h2>decodetypeSize</h2>
            <hr />
            
            <p>Type.commonType.size</p>
            
            <pre><code>func decodetypeSize(arch *sys.Arch, p []byte) int64</code></pre>
         </article>
         
         <article class="function" data-name="decodetypePtrdata">
            <h2>decodetypePtrdata</h2>
            <hr />
            
            <p>Type.commonType.ptrdata</p>
            
            <pre><code>func decodetypePtrdata(arch *sys.Arch, p []byte) int64</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeHasUncommon">
            <h2>decodetypeHasUncommon</h2>
            <hr />
            
            <p>Type.commonType.tflag</p>
            
            <pre><code>func decodetypeHasUncommon(arch *sys.Arch, p []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeGCMaskOnDemand">
            <h2>decodetypeGCMaskOnDemand</h2>
            <hr />
            
            <p>Type.commonType.tflag</p>
            
            <pre><code>func decodetypeGCMaskOnDemand(arch *sys.Arch, p []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeFuncDotdotdot">
            <h2>decodetypeFuncDotdotdot</h2>
            <hr />
            
            <p>Type.FuncType.dotdotdot</p>
            
            <pre><code>func decodetypeFuncDotdotdot(arch *sys.Arch, p []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeFuncInCount">
            <h2>decodetypeFuncInCount</h2>
            <hr />
            
            <p>Type.FuncType.inCount</p>
            
            <pre><code>func decodetypeFuncInCount(arch *sys.Arch, p []byte) int</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeFuncOutCount">
            <h2>decodetypeFuncOutCount</h2>
            <hr />
            
            <pre><code>func decodetypeFuncOutCount(arch *sys.Arch, p []byte) int</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeIfaceMethodCount">
            <h2>decodetypeIfaceMethodCount</h2>
            <hr />
            
            <p>InterfaceType.methods.length</p>
            
            <pre><code>func decodetypeIfaceMethodCount(arch *sys.Arch, p []byte) int64</code></pre>
         </article>
         
         <article class="function" data-name="decodeReloc">
            <h2>decodeReloc</h2>
            <hr />
            
            <pre><code>func decodeReloc(ldr *loader.Loader, symIdx loader.Sym, relocs *loader.Relocs, off int32) loader.Reloc</code></pre>
         </article>
         
         <article class="function" data-name="decodeRelocSym">
            <h2>decodeRelocSym</h2>
            <hr />
            
            <pre><code>func decodeRelocSym(ldr *loader.Loader, symIdx loader.Sym, relocs *loader.Relocs, off int32) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeName">
            <h2>decodetypeName</h2>
            <hr />
            
            <p>decodetypeName decodes the name from a reflect.name.</p>
            
            <pre><code>func decodetypeName(ldr *loader.Loader, symIdx loader.Sym, relocs *loader.Relocs, off int) string</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeNameEmbedded">
            <h2>decodetypeNameEmbedded</h2>
            <hr />
            
            <pre><code>func decodetypeNameEmbedded(ldr *loader.Loader, symIdx loader.Sym, relocs *loader.Relocs, off int) bool</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeFuncInType">
            <h2>decodetypeFuncInType</h2>
            <hr />
            
            <pre><code>func decodetypeFuncInType(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, relocs *loader.Relocs, i int) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeFuncOutType">
            <h2>decodetypeFuncOutType</h2>
            <hr />
            
            <pre><code>func decodetypeFuncOutType(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, relocs *loader.Relocs, i int) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeArrayElem">
            <h2>decodetypeArrayElem</h2>
            <hr />
            
            <pre><code>func decodetypeArrayElem(ctxt *Link, arch *sys.Arch, symIdx loader.Sym) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeArrayLen">
            <h2>decodetypeArrayLen</h2>
            <hr />
            
            <pre><code>func decodetypeArrayLen(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) int64</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeChanElem">
            <h2>decodetypeChanElem</h2>
            <hr />
            
            <pre><code>func decodetypeChanElem(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeMapKey">
            <h2>decodetypeMapKey</h2>
            <hr />
            
            <pre><code>func decodetypeMapKey(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeMapValue">
            <h2>decodetypeMapValue</h2>
            <hr />
            
            <pre><code>func decodetypeMapValue(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeMapSwissGroup">
            <h2>decodetypeMapSwissGroup</h2>
            <hr />
            
            <pre><code>func decodetypeMapSwissGroup(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="decodetypePtrElem">
            <h2>decodetypePtrElem</h2>
            <hr />
            
            <pre><code>func decodetypePtrElem(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeStructFieldCount">
            <h2>decodetypeStructFieldCount</h2>
            <hr />
            
            <pre><code>func decodetypeStructFieldCount(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) int</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeStructFieldArrayOff">
            <h2>decodetypeStructFieldArrayOff</h2>
            <hr />
            
            <pre><code>func decodetypeStructFieldArrayOff(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, i int) int</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeStructFieldName">
            <h2>decodetypeStructFieldName</h2>
            <hr />
            
            <pre><code>func decodetypeStructFieldName(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, i int) string</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeStructFieldType">
            <h2>decodetypeStructFieldType</h2>
            <hr />
            
            <pre><code>func decodetypeStructFieldType(ctxt *Link, arch *sys.Arch, symIdx loader.Sym, i int) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeStructFieldOffset">
            <h2>decodetypeStructFieldOffset</h2>
            <hr />
            
            <pre><code>func decodetypeStructFieldOffset(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, i int) int64</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeStructFieldEmbedded">
            <h2>decodetypeStructFieldEmbedded</h2>
            <hr />
            
            <pre><code>func decodetypeStructFieldEmbedded(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, i int) bool</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeStr">
            <h2>decodetypeStr</h2>
            <hr />
            
            <p>decodetypeStr returns the contents of an rtype's str field (a nameOff).</p>
            
            <pre><code>func decodetypeStr(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) string</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeGcmask">
            <h2>decodetypeGcmask</h2>
            <hr />
            
            <pre><code>func decodetypeGcmask(ctxt *Link, s loader.Sym) []byte</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeGcprog">
            <h2>decodetypeGcprog</h2>
            <hr />
            
            <p>Type.commonType.gc</p>
            
            <pre><code>func decodetypeGcprog(ctxt *Link, s loader.Sym) []byte</code></pre>
         </article>
         
         <article class="function" data-name="findShlibSection">
            <h2>findShlibSection</h2>
            <hr />
            
            <p>Find the elf.Section of a given shared library that contains a given address.</p>
            
            <pre><code>func findShlibSection(ctxt *Link, path string, addr uint64) *elf.Section</code></pre>
         </article>
         
         <article class="function" data-name="decodetypeGcprogShlib">
            <h2>decodetypeGcprogShlib</h2>
            <hr />
            
            <pre><code>func decodetypeGcprogShlib(ctxt *Link, data []byte) uint64</code></pre>
         </article>
         
         <article class="function" data-name="decodeItabType">
            <h2>decodeItabType</h2>
            <hr />
            
            <p>decodeItabType returns the itab.Type field from an itab.</p>
            
            <pre><code>func decodeItabType(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="decodeTargetSym">
            <h2>decodeTargetSym</h2>
            <hr />
            
            <p>decodeTargetSym finds the symbol pointed to by the pointer slot at offset off in s.</p>
            
            <pre><code>func decodeTargetSym(ctxt *Link, arch *sys.Arch, s loader.Sym, off int64) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="Elfinit">
            <h2>Elfinit</h2>
            <hr />
            
            <p>Initialize the global variable that describes the ELF header. It will be updated as
we write section and prog headers.</p>
            
            <pre><code>func Elfinit(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="fixElfPhdr">
            <h2>fixElfPhdr</h2>
            <hr />
            
            <p>Make sure PT_LOAD is aligned properly and
that there is no gap,
correct ELF loaders will do this implicitly,
but buggy ELF loaders like the one in some
versions of QEMU and UPX won't.</p>
            
            <pre><code>func fixElfPhdr(e *ElfPhdr)</code></pre>
         </article>
         
         <article class="function" data-name="elf64phdr">
            <h2>elf64phdr</h2>
            <hr />
            
            <pre><code>func elf64phdr(out *OutBuf, e *ElfPhdr)</code></pre>
         </article>
         
         <article class="function" data-name="elf32phdr">
            <h2>elf32phdr</h2>
            <hr />
            
            <pre><code>func elf32phdr(out *OutBuf, e *ElfPhdr)</code></pre>
         </article>
         
         <article class="function" data-name="elf64shdr">
            <h2>elf64shdr</h2>
            <hr />
            
            <pre><code>func elf64shdr(out *OutBuf, e *ElfShdr)</code></pre>
         </article>
         
         <article class="function" data-name="elf32shdr">
            <h2>elf32shdr</h2>
            <hr />
            
            <pre><code>func elf32shdr(out *OutBuf, e *ElfShdr)</code></pre>
         </article>
         
         <article class="function" data-name="elfwriteshdrs">
            <h2>elfwriteshdrs</h2>
            <hr />
            
            <pre><code>func elfwriteshdrs(out *OutBuf) uint32</code></pre>
         </article>
         
         <article class="function" data-name="elfsetstring">
            <h2>elfsetstring</h2>
            <hr />
            
            <pre><code>func elfsetstring(ctxt *Link, s loader.Sym, str string, off int)</code></pre>
         </article>
         
         <article class="function" data-name="elfwritephdrs">
            <h2>elfwritephdrs</h2>
            <hr />
            
            <pre><code>func elfwritephdrs(out *OutBuf) uint32</code></pre>
         </article>
         
         <article class="function" data-name="newElfPhdr">
            <h2>newElfPhdr</h2>
            <hr />
            
            <pre><code>func newElfPhdr() *ElfPhdr</code></pre>
         </article>
         
         <article class="function" data-name="newElfShdr">
            <h2>newElfShdr</h2>
            <hr />
            
            <pre><code>func newElfShdr(name int64) *ElfShdr</code></pre>
         </article>
         
         <article class="function" data-name="getElfEhdr">
            <h2>getElfEhdr</h2>
            <hr />
            
            <pre><code>func getElfEhdr() *ElfEhdr</code></pre>
         </article>
         
         <article class="function" data-name="elf64writehdr">
            <h2>elf64writehdr</h2>
            <hr />
            
            <pre><code>func elf64writehdr(out *OutBuf) uint32</code></pre>
         </article>
         
         <article class="function" data-name="elf32writehdr">
            <h2>elf32writehdr</h2>
            <hr />
            
            <pre><code>func elf32writehdr(out *OutBuf) uint32</code></pre>
         </article>
         
         <article class="function" data-name="elfwritehdr">
            <h2>elfwritehdr</h2>
            <hr />
            
            <pre><code>func elfwritehdr(out *OutBuf) uint32</code></pre>
         </article>
         
         <article class="function" data-name="elfhash">
            <h2>elfhash</h2>
            <hr />
            
            <p>Taken directly from the definition document for ELF64.</p>
            
            <pre><code>func elfhash(name string) uint32</code></pre>
         </article>
         
         <article class="function" data-name="elfWriteDynEntSym">
            <h2>elfWriteDynEntSym</h2>
            <hr />
            
            <pre><code>func elfWriteDynEntSym(ctxt *Link, s *loader.SymbolBuilder, tag elf.DynTag, t loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="Elfwritedynent">
            <h2>Elfwritedynent</h2>
            <hr />
            
            <pre><code>func Elfwritedynent(arch *sys.Arch, s *loader.SymbolBuilder, tag elf.DynTag, val uint64)</code></pre>
         </article>
         
         <article class="function" data-name="Elfwritedynentsymplus">
            <h2>Elfwritedynentsymplus</h2>
            <hr />
            
            <pre><code>func Elfwritedynentsymplus(ctxt *Link, s *loader.SymbolBuilder, tag elf.DynTag, t loader.Sym, add int64)</code></pre>
         </article>
         
         <article class="function" data-name="elfwritedynentsymsize">
            <h2>elfwritedynentsymsize</h2>
            <hr />
            
            <pre><code>func elfwritedynentsymsize(ctxt *Link, s *loader.SymbolBuilder, tag elf.DynTag, t loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="elfinterp">
            <h2>elfinterp</h2>
            <hr />
            
            <pre><code>func elfinterp(sh *ElfShdr, startva uint64, resoff uint64, p string) int</code></pre>
         </article>
         
         <article class="function" data-name="elfwriteinterp">
            <h2>elfwriteinterp</h2>
            <hr />
            
            <pre><code>func elfwriteinterp(out *OutBuf) int</code></pre>
         </article>
         
         <article class="function" data-name="elfMipsAbiFlags">
            <h2>elfMipsAbiFlags</h2>
            <hr />
            
            <pre><code>func elfMipsAbiFlags(sh *ElfShdr, startva uint64, resoff uint64) int</code></pre>
         </article>
         
         <article class="function" data-name="elfWriteMipsAbiFlags">
            <h2>elfWriteMipsAbiFlags</h2>
            <hr />
            
            <p>Layout is given by this C definition:

	typedef struct
	{
	  /* Version of flags structure.  */
	  uint16_t version;
	  /* The level of the ISA: 1-5, 32, 64.  */
	  uint8_t isa_level;
	  /* The revision of ISA: 0 for MIPS V and below, 1-n otherwise.  */
	  uint8_t isa_rev;
	  /* The size of general purpose registers.  */
	  uint8_t gpr_size;
	  /* The size of co-processor 1 registers.  */
	  uint8_t cpr1_size;
	  /* The size of co-processor 2 registers.  */
	  uint8_t cpr2_size;
	  /* The floating-point ABI.  */
	  uint8_t fp_abi;
	  /* Processor-specific extension.  */
	  uint32_t isa_ext;
	  /* Mask of ASEs used.  */
	  uint32_t ases;
	  /* Mask of general flags.  */
	  uint32_t flags1;
	  uint32_t flags2;
	} Elf_Internal_ABIFlags_v0;</p>
            
            <pre><code>func elfWriteMipsAbiFlags(ctxt *Link) int</code></pre>
         </article>
         
         <article class="function" data-name="elfnote">
            <h2>elfnote</h2>
            <hr />
            
            <pre><code>func elfnote(sh *ElfShdr, startva uint64, resoff uint64, sizes ...int) int</code></pre>
         </article>
         
         <article class="function" data-name="elfwritenotehdr">
            <h2>elfwritenotehdr</h2>
            <hr />
            
            <pre><code>func elfwritenotehdr(out *OutBuf, str string, namesz uint32, descsz uint32, tag uint32) *ElfShdr</code></pre>
         </article>
         
         <article class="function" data-name="elfnetbsdsig">
            <h2>elfnetbsdsig</h2>
            <hr />
            
            <pre><code>func elfnetbsdsig(sh *ElfShdr, startva uint64, resoff uint64) int</code></pre>
         </article>
         
         <article class="function" data-name="elfwritenetbsdsig">
            <h2>elfwritenetbsdsig</h2>
            <hr />
            
            <pre><code>func elfwritenetbsdsig(out *OutBuf) int</code></pre>
         </article>
         
         <article class="function" data-name="elfnetbsdpax">
            <h2>elfnetbsdpax</h2>
            <hr />
            
            <pre><code>func elfnetbsdpax(sh *ElfShdr, startva uint64, resoff uint64) int</code></pre>
         </article>
         
         <article class="function" data-name="elfwritenetbsdpax">
            <h2>elfwritenetbsdpax</h2>
            <hr />
            
            <pre><code>func elfwritenetbsdpax(out *OutBuf) int</code></pre>
         </article>
         
         <article class="function" data-name="elfopenbsdsig">
            <h2>elfopenbsdsig</h2>
            <hr />
            
            <pre><code>func elfopenbsdsig(sh *ElfShdr, startva uint64, resoff uint64) int</code></pre>
         </article>
         
         <article class="function" data-name="elfwriteopenbsdsig">
            <h2>elfwriteopenbsdsig</h2>
            <hr />
            
            <pre><code>func elfwriteopenbsdsig(out *OutBuf) int</code></pre>
         </article>
         
         <article class="function" data-name="elffreebsdsig">
            <h2>elffreebsdsig</h2>
            <hr />
            
            <pre><code>func elffreebsdsig(sh *ElfShdr, startva uint64, resoff uint64) int</code></pre>
         </article>
         
         <article class="function" data-name="elfwritefreebsdsig">
            <h2>elfwritefreebsdsig</h2>
            <hr />
            
            <p>elfwritefreebsdsig writes FreeBSD .note section.

See https://www.netbsd.org/docs/kernel/elf-notes.html for the description of
a Note element format and
https://github.com/freebsd/freebsd-src/blob/main/sys/sys/elf_common.h#L790
for the FreeBSD-specific values.</p>
            
            <pre><code>func elfwritefreebsdsig(out *OutBuf) int</code></pre>
         </article>
         
         <article class="function" data-name="addbuildinfo">
            <h2>addbuildinfo</h2>
            <hr />
            
            <pre><code>func addbuildinfo(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="elfbuildinfo">
            <h2>elfbuildinfo</h2>
            <hr />
            
            <pre><code>func elfbuildinfo(sh *ElfShdr, startva uint64, resoff uint64) int</code></pre>
         </article>
         
         <article class="function" data-name="elfgobuildid">
            <h2>elfgobuildid</h2>
            <hr />
            
            <pre><code>func elfgobuildid(sh *ElfShdr, startva uint64, resoff uint64) int</code></pre>
         </article>
         
         <article class="function" data-name="elfwritebuildinfo">
            <h2>elfwritebuildinfo</h2>
            <hr />
            
            <pre><code>func elfwritebuildinfo(out *OutBuf) int</code></pre>
         </article>
         
         <article class="function" data-name="elfwritegobuildid">
            <h2>elfwritegobuildid</h2>
            <hr />
            
            <pre><code>func elfwritegobuildid(out *OutBuf) int</code></pre>
         </article>
         
         <article class="function" data-name="addelflib">
            <h2>addelflib</h2>
            <hr />
            
            <pre><code>func addelflib(list **Elflib, file string, vers string) *Elfaux</code></pre>
         </article>
         
         <article class="function" data-name="elfdynhash">
            <h2>elfdynhash</h2>
            <hr />
            
            <pre><code>func elfdynhash(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="elfphload">
            <h2>elfphload</h2>
            <hr />
            
            <pre><code>func elfphload(seg *sym.Segment) *ElfPhdr</code></pre>
         </article>
         
         <article class="function" data-name="elfphrelro">
            <h2>elfphrelro</h2>
            <hr />
            
            <pre><code>func elfphrelro(seg *sym.Segment)</code></pre>
         </article>
         
         <article class="function" data-name="elfshname">
            <h2>elfshname</h2>
            <hr />
            
            <pre><code>func elfshname(name string) *ElfShdr</code></pre>
         </article>
         
         <article class="function" data-name="elfshnamedup">
            <h2>elfshnamedup</h2>
            <hr />
            
            <p>Create an ElfShdr for the section with name.
Create a duplicate if one already exists with that name.</p>
            
            <pre><code>func elfshnamedup(name string) *ElfShdr</code></pre>
         </article>
         
         <article class="function" data-name="elfshalloc">
            <h2>elfshalloc</h2>
            <hr />
            
            <pre><code>func elfshalloc(sect *sym.Section) *ElfShdr</code></pre>
         </article>
         
         <article class="function" data-name="elfshbits">
            <h2>elfshbits</h2>
            <hr />
            
            <pre><code>func elfshbits(linkmode LinkMode, sect *sym.Section) *ElfShdr</code></pre>
         </article>
         
         <article class="function" data-name="elfshreloc">
            <h2>elfshreloc</h2>
            <hr />
            
            <pre><code>func elfshreloc(arch *sys.Arch, sect *sym.Section) *ElfShdr</code></pre>
         </article>
         
         <article class="function" data-name="elfrelocsect">
            <h2>elfrelocsect</h2>
            <hr />
            
            <pre><code>func elfrelocsect(ctxt *Link, out *OutBuf, sect *sym.Section, syms []loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="elfEmitReloc">
            <h2>elfEmitReloc</h2>
            <hr />
            
            <pre><code>func elfEmitReloc(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="addgonote">
            <h2>addgonote</h2>
            <hr />
            
            <pre><code>func addgonote(ctxt *Link, sectionName string, tag uint32, desc []byte)</code></pre>
         </article>
         
         <article class="function" data-name="doelf">
            <h2>doelf</h2>
            <hr />
            
            <pre><code>func doelf()</code></pre>
         </article>
         
         <article class="function" data-name="shsym">
            <h2>shsym</h2>
            <hr />
            
            <p>Do not write DT_NULL.  elfdynhash will finish it.</p>
            
            <pre><code>func shsym(sh *ElfShdr, ldr *loader.Loader, s loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="phsh">
            <h2>phsh</h2>
            <hr />
            
            <pre><code>func phsh(ph *ElfPhdr, sh *ElfShdr)</code></pre>
         </article>
         
         <article class="function" data-name="Asmbelfsetup">
            <h2>Asmbelfsetup</h2>
            <hr />
            
            <pre><code>func Asmbelfsetup()</code></pre>
         </article>
         
         <article class="function" data-name="asmbElf">
            <h2>asmbElf</h2>
            <hr />
            
            <pre><code>func asmbElf(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="elfadddynsym">
            <h2>elfadddynsym</h2>
            <hr />
            
            <pre><code>func elfadddynsym(ldr *loader.Loader, target *Target, syms *ArchSyms, s loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="TestDynSymShInfo">
            <h2>TestDynSymShInfo</h2>
            <hr />
            
            <pre><code>func TestDynSymShInfo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNoDuplicateNeededEntries">
            <h2>TestNoDuplicateNeededEntries</h2>
            <hr />
            
            <pre><code>func TestNoDuplicateNeededEntries(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestShStrTabAttributesIssue62600">
            <h2>TestShStrTabAttributesIssue62600</h2>
            <hr />
            
            <pre><code>func TestShStrTabAttributesIssue62600(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestElfBindNow">
            <h2>TestElfBindNow</h2>
            <hr />
            
            <pre><code>func TestElfBindNow(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestRelroSectionOverlapIssue67261">
            <h2>TestRelroSectionOverlapIssue67261</h2>
            <hr />
            
            <pre><code>func TestRelroSectionOverlapIssue67261(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="readImportCfg">
            <h2>readImportCfg</h2>
            <hr />
            
            <pre><code>func readImportCfg(file string)</code></pre>
         </article>
         
         <article class="function" data-name="pkgname">
            <h2>pkgname</h2>
            <hr />
            
            <pre><code>func pkgname(ctxt *Link, lib string) string</code></pre>
         </article>
         
         <article class="function" data-name="findlib">
            <h2>findlib</h2>
            <hr />
            
            <pre><code>func findlib(ctxt *Link, lib string) (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="addlib">
            <h2>addlib</h2>
            <hr />
            
            <pre><code>func addlib(ctxt *Link, src string, obj string, lib string, fingerprint goobj.FingerprintType) *sym.Library</code></pre>
         </article>
         
         <article class="function" data-name="addlibpath">
            <h2>addlibpath</h2>
            <hr />
            
            <p>* add library to library list, return added library.
 *	srcref: src file referring to package
 *	objref: object file referring to package
 *	file: object file, e.g., /home/rsc/go/pkg/container/vector.a
 *	pkg: package import path, e.g. container/vector
 *	shlib: path to shared library, or .shlibname file holding path
 *	fingerprint: if not 0, expected fingerprint for import from srcref
 *	             fingerprint is 0 if the library is not imported (e.g. main)</p>
            
            <pre><code>func addlibpath(ctxt *Link, srcref string, objref string, file string, pkg string, shlib string, fingerprint goobj.FingerprintType) *sym.Library</code></pre>
         </article>
         
         <article class="function" data-name="atolwhex">
            <h2>atolwhex</h2>
            <hr />
            
            <pre><code>func atolwhex(s string) int64</code></pre>
         </article>
         
         <article class="function" data-name="PrepareAddmoduledata">
            <h2>PrepareAddmoduledata</h2>
            <hr />
            
            <p>PrepareAddmoduledata returns a symbol builder that target-specific
code can use to build up the linker-generated go.link.addmoduledata
function, along with the sym for runtime.addmoduledata itself. If
this function is not needed (for example in cases where we're
linking a module that contains the runtime) the returned builder
will be nil.</p>
            
            <pre><code>func PrepareAddmoduledata(ctxt *Link) (*loader.SymbolBuilder, loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(s string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="IsBoolFlag">
            <h2>IsBoolFlag</h2>
            <hr />
            
            <pre><code>func IsBoolFlag() bool</code></pre>
         </article>
         
         <article class="function" data-name="Main">
            <h2>Main</h2>
            <hr />
            
            <p>Main is the main entry point for the linker code.</p>
            
            <pre><code>func Main(arch *sys.Arch, theArch Arch)</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(val string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="startProfile">
            <h2>startProfile</h2>
            <hr />
            
            <pre><code>func startProfile()</code></pre>
         </article>
         
         <article class="function" data-name="fallocate">
            <h2>fallocate</h2>
            <hr />
            
            <pre><code>func fallocate(size uint64) error</code></pre>
         </article>
         
         <article class="function" data-name="loadfips">
            <h2>loadfips</h2>
            <hr />
            
            <p>loadfips creates the special bracketing symbols and go:fipsinfo.</p>
            
            <pre><code>func loadfips(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="newFipsObj">
            <h2>newFipsObj</h2>
            <hr />
            
            <p>newFipsObj creates a fipsObj reading from r and writing to fipso
(unless fipso is the empty string, in which case it writes nowhere
and only computes the hash).</p>
            
            <pre><code>func newFipsObj(r io.ReaderAt, fipso string) (*fipsObj, error)</code></pre>
         </article>
         
         <article class="function" data-name="addSection">
            <h2>addSection</h2>
            <hr />
            
            <p>addSection adds the section of r (passed to newFipsObj)
starting at byte offset start and ending before byte offset end
to the fips object file.</p>
            
            <pre><code>func addSection(start int64, end int64) error</code></pre>
         </article>
         
         <article class="function" data-name="sum">
            <h2>sum</h2>
            <hr />
            
            <p>sum returns the hash of the fips object file.</p>
            
            <pre><code>func sum() []byte</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close closes the fipsObj. In particular it closes the output
object file specified by fipso in the call to [newFipsObj].</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="asmbfips">
            <h2>asmbfips</h2>
            <hr />
            
            <p>asmbfips is called from [asmb] to update go:fipsinfo
when using internal linking.
See [hostlinkfips] for external linking.</p>
            
            <pre><code>func asmbfips(ctxt *Link, fipso string)</code></pre>
         </article>
         
         <article class="function" data-name="hostlinkfips">
            <h2>hostlinkfips</h2>
            <hr />
            
            <p>hostlinkfips is called from [hostlink] to update go:fipsinfo
when using external linking.
See [asmbfips] for internal linking.</p>
            
            <pre><code>func hostlinkfips(ctxt *Link, exe string, fipso string) error</code></pre>
         </article>
         
         <article class="function" data-name="machofips">
            <h2>machofips</h2>
            <hr />
            
            <p>machofips updates go:fipsinfo after external linking
on systems using Mach-O (GOOS=darwin, GOOS=ios).</p>
            
            <pre><code>func machofips(ctxt *Link, exe string, fipso string) error</code></pre>
         </article>
         
         <article class="function" data-name="elffips">
            <h2>elffips</h2>
            <hr />
            
            <p>machofips updates go:fipsinfo after external linking
on systems using ELF (most Unix systems).</p>
            
            <pre><code>func elffips(ctxt *Link, exe string, fipso string) error</code></pre>
         </article>
         
         <article class="function" data-name="pefips">
            <h2>pefips</h2>
            <hr />
            
            <p>pefips updates go:fipsinfo after external linking
on systems using PE (GOOS=windows).</p>
            
            <pre><code>func pefips(ctxt *Link, exe string, fipso string) error</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <pre><code>func Open(name string) error</code></pre>
         </article>
         
         <article class="function" data-name="NewOutBuf">
            <h2>NewOutBuf</h2>
            <hr />
            
            <pre><code>func NewOutBuf(arch *sys.Arch) *OutBuf</code></pre>
         </article>
         
         <article class="function" data-name="View">
            <h2>View</h2>
            <hr />
            
            <pre><code>func View(start uint64) (*OutBuf, error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="ErrorClose">
            <h2>ErrorClose</h2>
            <hr />
            
            <p>ErrorClose closes the output file (if any).
It is supposed to be called only at exit on error, so it doesn't do
any clean up or buffer flushing, just closes the file.</p>
            
            <pre><code>func ErrorClose()</code></pre>
         </article>
         
         <article class="function" data-name="isMmapped">
            <h2>isMmapped</h2>
            <hr />
            
            <p>isMmapped returns true if the OutBuf is mmaped.</p>
            
            <pre><code>func isMmapped() bool</code></pre>
         </article>
         
         <article class="function" data-name="Data">
            <h2>Data</h2>
            <hr />
            
            <p>Data returns the whole written OutBuf as a byte slice.</p>
            
            <pre><code>func Data() []byte</code></pre>
         </article>
         
         <article class="function" data-name="copyHeap">
            <h2>copyHeap</h2>
            <hr />
            
            <p>copyHeap copies the heap to the mmapped section of memory, returning true if
a copy takes place.</p>
            
            <pre><code>func copyHeap() bool</code></pre>
         </article>
         
         <article class="function" data-name="writeLoc">
            <h2>writeLoc</h2>
            <hr />
            
            <p>writeLoc determines the write location if a buffer is mmaped.
We maintain two write buffers, an mmapped section, and a heap section for
writing. When the mmapped section is full, we switch over the heap memory
for writing.</p>
            
            <pre><code>func writeLoc(lenToWrite int64) (int64, []byte)</code></pre>
         </article>
         
         <article class="function" data-name="SeekSet">
            <h2>SeekSet</h2>
            <hr />
            
            <pre><code>func SeekSet(p int64)</code></pre>
         </article>
         
         <article class="function" data-name="Offset">
            <h2>Offset</h2>
            <hr />
            
            <pre><code>func Offset() int64</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write writes the contents of v to the buffer.</p>
            
            <pre><code>func Write(v []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Write8">
            <h2>Write8</h2>
            <hr />
            
            <pre><code>func Write8(v uint8)</code></pre>
         </article>
         
         <article class="function" data-name="WriteByte">
            <h2>WriteByte</h2>
            <hr />
            
            <p>WriteByte is an alias for Write8 to fulfill the io.ByteWriter interface.</p>
            
            <pre><code>func WriteByte(v byte) error</code></pre>
         </article>
         
         <article class="function" data-name="Write16">
            <h2>Write16</h2>
            <hr />
            
            <pre><code>func Write16(v uint16)</code></pre>
         </article>
         
         <article class="function" data-name="Write32">
            <h2>Write32</h2>
            <hr />
            
            <pre><code>func Write32(v uint32)</code></pre>
         </article>
         
         <article class="function" data-name="Write32b">
            <h2>Write32b</h2>
            <hr />
            
            <pre><code>func Write32b(v uint32)</code></pre>
         </article>
         
         <article class="function" data-name="Write64">
            <h2>Write64</h2>
            <hr />
            
            <pre><code>func Write64(v uint64)</code></pre>
         </article>
         
         <article class="function" data-name="Write64b">
            <h2>Write64b</h2>
            <hr />
            
            <pre><code>func Write64b(v uint64)</code></pre>
         </article>
         
         <article class="function" data-name="WriteString">
            <h2>WriteString</h2>
            <hr />
            
            <pre><code>func WriteString(s string)</code></pre>
         </article>
         
         <article class="function" data-name="WriteStringN">
            <h2>WriteStringN</h2>
            <hr />
            
            <p>WriteStringN writes the first n bytes of s.
If n is larger than len(s) then it is padded with zero bytes.</p>
            
            <pre><code>func WriteStringN(s string, n int)</code></pre>
         </article>
         
         <article class="function" data-name="WriteStringPad">
            <h2>WriteStringPad</h2>
            <hr />
            
            <p>WriteStringPad writes the first n bytes of s.
If n is larger than len(s) then it is padded with the bytes in pad (repeated as needed).</p>
            
            <pre><code>func WriteStringPad(s string, n int, pad []byte)</code></pre>
         </article>
         
         <article class="function" data-name="WriteSym">
            <h2>WriteSym</h2>
            <hr />
            
            <p>WriteSym writes the content of a Symbol, and returns the output buffer
that we just wrote, so we can apply further edit to the symbol content.
For generator symbols, it also sets the symbol's Data to the output
buffer.</p>
            
            <pre><code>func WriteSym(ldr *loader.Loader, s loader.Sym) []byte</code></pre>
         </article>
         
         <article class="function" data-name="fcntl">
            <h2>fcntl</h2>
            <hr />
            
            <p>Implemented in the syscall package.</p>
            
            <pre><code>func fcntl(fd int, cmd int, arg int) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="fallocate">
            <h2>fallocate</h2>
            <hr />
            
            <pre><code>func fallocate(size uint64) error</code></pre>
         </article>
         
         <article class="function" data-name="purgeSignatureCache">
            <h2>purgeSignatureCache</h2>
            <hr />
            
            <pre><code>func purgeSignatureCache()</code></pre>
         </article>
         
         <article class="function" data-name="TestMMap">
            <h2>TestMMap</h2>
            <hr />
            
            <p>TestMMap ensures that we can actually mmap on every supported platform.</p>
            
            <pre><code>func TestMMap(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriteLoc">
            <h2>TestWriteLoc</h2>
            <hr />
            
            <p>TestWriteLoc ensures that the math surrounding writeLoc is correct.</p>
            
            <pre><code>func TestWriteLoc(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIsMmapped">
            <h2>TestIsMmapped</h2>
            <hr />
            
            <pre><code>func TestIsMmapped(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Mmap">
            <h2>Mmap</h2>
            <hr />
            
            <p>Mmap maps the output file with the given size. It unmaps the old mapping
if it is already mapped. It also flushes any in-heap data to the new
mapping.</p>
            
            <pre><code>func Mmap(filesize uint64) error</code></pre>
         </article>
         
         <article class="function" data-name="munmap">
            <h2>munmap</h2>
            <hr />
            
            <pre><code>func munmap()</code></pre>
         </article>
         
         <article class="function" data-name="addGeneratedSym">
            <h2>addGeneratedSym</h2>
            <hr />
            
            <p>addGeneratedSym adds a generator symbol to pclntab, returning the new Sym.
It is the caller's responsibility to save the symbol in state.</p>
            
            <pre><code>func addGeneratedSym(ctxt *Link, name string, size int64, f generatorFunc) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="makePclntab">
            <h2>makePclntab</h2>
            <hr />
            
            <p>makePclntab makes a pclntab object, and assembles all the compilation units
we'll need to write pclntab. Returns the pclntab structure, a slice of the
CompilationUnits we need, and a slice of the function symbols we need to
generate pclntab.</p>
            
            <pre><code>func makePclntab(ctxt *Link, container loader.Bitmap) (*pclntab, []*sym.CompilationUnit, []loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="emitPcln">
            <h2>emitPcln</h2>
            <hr />
            
            <pre><code>func emitPcln(ctxt *Link, s loader.Sym, container loader.Bitmap) bool</code></pre>
         </article>
         
         <article class="function" data-name="computeDeferReturn">
            <h2>computeDeferReturn</h2>
            <hr />
            
            <pre><code>func computeDeferReturn(ctxt *Link, deferReturnSym loader.Sym, s loader.Sym) uint32</code></pre>
         </article>
         
         <article class="function" data-name="genInlTreeSym">
            <h2>genInlTreeSym</h2>
            <hr />
            
            <p>genInlTreeSym generates the InlTree sym for a function with the
specified FuncInfo.</p>
            
            <pre><code>func genInlTreeSym(ctxt *Link, cu *sym.CompilationUnit, fi loader.FuncInfo, arch *sys.Arch, nameOffsets *ast.MapType) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="makeInlSyms">
            <h2>makeInlSyms</h2>
            <hr />
            
            <p>makeInlSyms returns a map of loader.Sym that are created inlSyms.</p>
            
            <pre><code>func makeInlSyms(ctxt *Link, funcs []loader.Sym, nameOffsets *ast.MapType) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="generatePCHeader">
            <h2>generatePCHeader</h2>
            <hr />
            
            <p>generatePCHeader creates the runtime.pcheader symbol, setting it up as a
generator to fill in its data later.</p>
            
            <pre><code>func generatePCHeader(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="walkFuncs">
            <h2>walkFuncs</h2>
            <hr />
            
            <p>walkFuncs iterates over the funcs, calling a function for each unique
function and inlined function.</p>
            
            <pre><code>func walkFuncs(ctxt *Link, funcs []loader.Sym, f func)</code></pre>
         </article>
         
         <article class="function" data-name="generateFuncnametab">
            <h2>generateFuncnametab</h2>
            <hr />
            
            <p>generateFuncnametab creates the function name table. Returns a map of
func symbol to the name offset in runtime.funcnamtab.</p>
            
            <pre><code>func generateFuncnametab(ctxt *Link, funcs []loader.Sym) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="walkFilenames">
            <h2>walkFilenames</h2>
            <hr />
            
            <p>walkFilenames walks funcs, calling a function for each filename used in each
function's line table.</p>
            
            <pre><code>func walkFilenames(ctxt *Link, funcs []loader.Sym, f func)</code></pre>
         </article>
         
         <article class="function" data-name="generateFilenameTabs">
            <h2>generateFilenameTabs</h2>
            <hr />
            
            <p>generateFilenameTabs creates LUTs needed for filename lookup. Returns a slice
of the index at which each CU begins in runtime.cutab.

Function objects keep track of the files they reference to print the stack.
This function creates a per-CU list of filenames if CU[M] references
files[1-N], the following is generated:

	runtime.cutab:
	  CU[M]
	   offsetToFilename[0]
	   offsetToFilename[1]
	   ..

	runtime.filetab
	   filename[0]
	   filename[1]

Looking up a filename then becomes:
 0. Given a func, and filename index [K]
 1. Get Func.CUIndex:       M := func.cuOffset
 2. Find filename offset:   fileOffset := runtime.cutab[M+K]
 3. Get the filename:       getcstring(runtime.filetab[fileOffset])</p>
            
            <pre><code>func generateFilenameTabs(ctxt *Link, compUnits []*sym.CompilationUnit, funcs []loader.Sym) []uint32</code></pre>
         </article>
         
         <article class="function" data-name="generatePctab">
            <h2>generatePctab</h2>
            <hr />
            
            <p>generatePctab creates the runtime.pctab variable, holding all the
deduplicated pcdata.</p>
            
            <pre><code>func generatePctab(ctxt *Link, funcs []loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="numPCData">
            <h2>numPCData</h2>
            <hr />
            
            <p>numPCData returns the number of PCData syms for the FuncInfo.
NB: Preload must be called on valid FuncInfos before calling this function.</p>
            
            <pre><code>func numPCData(ldr *loader.Loader, s loader.Sym, fi loader.FuncInfo) uint32</code></pre>
         </article>
         
         <article class="function" data-name="generateFunctab">
            <h2>generateFunctab</h2>
            <hr />
            
            <p>generateFunctab creates the runtime.functab

runtime.functab contains two things:

  - pc->func look up table.
  - array of func objects, interleaved with pcdata and funcdata</p>
            
            <pre><code>func generateFunctab(ctxt *Link, funcs []loader.Sym, inlSyms *ast.MapType, cuOffsets []uint32, nameOffsets *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="funcData">
            <h2>funcData</h2>
            <hr />
            
            <p>funcData returns the funcdata and offsets for the FuncInfo.
The funcdata are written into runtime.functab after each func
object. This is a helper function to make querying the FuncInfo object
cleaner.

NB: Preload must be called on the FuncInfo before calling.
NB: fdSyms is used as scratch space.</p>
            
            <pre><code>func funcData(ldr *loader.Loader, s loader.Sym, fi loader.FuncInfo, inlSym loader.Sym, fdSyms []loader.Sym) []loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="calculateFunctabSize">
            <h2>calculateFunctabSize</h2>
            <hr />
            
            <p>calculateFunctabSize calculates the size of the pclntab, and the offsets in
the output buffer for individual func entries.</p>
            
            <pre><code>func calculateFunctabSize(ctxt *Link, funcs []loader.Sym) (int64, []uint32)</code></pre>
         </article>
         
         <article class="function" data-name="writePCToFunc">
            <h2>writePCToFunc</h2>
            <hr />
            
            <p>writePCToFunc writes the PC->func lookup table.</p>
            
            <pre><code>func writePCToFunc(ctxt *Link, sb *loader.SymbolBuilder, funcs []loader.Sym, startLocations []uint32)</code></pre>
         </article>
         
         <article class="function" data-name="writeFuncs">
            <h2>writeFuncs</h2>
            <hr />
            
            <p>writeFuncs writes the func structures and pcdata to runtime.functab.</p>
            
            <pre><code>func writeFuncs(ctxt *Link, sb *loader.SymbolBuilder, funcs []loader.Sym, inlSyms *ast.MapType, startLocations []uint32, cuOffsets []uint32, nameOffsets *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="pclntab">
            <h2>pclntab</h2>
            <hr />
            
            <p>pclntab generates the pcln table for the link output.</p>
            
            <pre><code>func pclntab(container loader.Bitmap) *pclntab</code></pre>
         </article>
         
         <article class="function" data-name="expandGoroot">
            <h2>expandGoroot</h2>
            <hr />
            
            <pre><code>func expandGoroot(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="findfunctab">
            <h2>findfunctab</h2>
            <hr />
            
            <p>findfunctab generates a lookup table to quickly find the containing
function for a pc. See src/runtime/symtab.go:findfunc for details.</p>
            
            <pre><code>func findfunctab(state *pclntab, container loader.Bitmap)</code></pre>
         </article>
         
         <article class="function" data-name="findContainerSyms">
            <h2>findContainerSyms</h2>
            <hr />
            
            <p>findContainerSyms returns a bitmap, indexed by symbol number, where there's
a 1 for every container symbol.</p>
            
            <pre><code>func findContainerSyms() loader.Bitmap</code></pre>
         </article>
         
         <article class="function" data-name="linknew">
            <h2>linknew</h2>
            <hr />
            
            <pre><code>func linknew(arch *sys.Arch) *Link</code></pre>
         </article>
         
         <article class="function" data-name="computeTLSOffset">
            <h2>computeTLSOffset</h2>
            <hr />
            
            <p>computeTLSOffset records the thread-local storage offset.
Not used for Android where the TLS offset is determined at runtime.</p>
            
            <pre><code>func computeTLSOffset()</code></pre>
         </article>
         
         <article class="function" data-name="size">
            <h2>size</h2>
            <hr />
            
            <p>size returns size of string table t.</p>
            
            <pre><code>func size() int</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <p>add adds string str to string table t.</p>
            
            <pre><code>func add(str string) int</code></pre>
         </article>
         
         <article class="function" data-name="write">
            <h2>write</h2>
            <hr />
            
            <p>write writes string table t into the output file.</p>
            
            <pre><code>func write(out *OutBuf)</code></pre>
         </article>
         
         <article class="function" data-name="write">
            <h2>write</h2>
            <hr />
            
            <p>write writes XCOFF section sect into the output file.</p>
            
            <pre><code>func write(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="addSection">
            <h2>addSection</h2>
            <hr />
            
            <p>addSection adds section to the XCOFF file f.</p>
            
            <pre><code>func addSection(name string, addr uint64, size uint64, fileoff uint64, flags uint32) *XcoffScnHdr64</code></pre>
         </article>
         
         <article class="function" data-name="addDwarfSection">
            <h2>addDwarfSection</h2>
            <hr />
            
            <p>addDwarfSection adds a dwarf section to the XCOFF file f.
This function is similar to addSection, but Dwarf section names
must be modified to conventional names and they are various subtypes.</p>
            
            <pre><code>func addDwarfSection(s *sym.Section) *XcoffScnHdr64</code></pre>
         </article>
         
         <article class="function" data-name="xcoffGetDwarfSubtype">
            <h2>xcoffGetDwarfSubtype</h2>
            <hr />
            
            <p>xcoffGetDwarfSubtype returns the XCOFF name of the DWARF section str
and its subtype constant.</p>
            
            <pre><code>func xcoffGetDwarfSubtype(str string) (string, uint32)</code></pre>
         </article>
         
         <article class="function" data-name="getXCOFFscnum">
            <h2>getXCOFFscnum</h2>
            <hr />
            
            <p>getXCOFFscnum returns the XCOFF section number of a Go section.</p>
            
            <pre><code>func getXCOFFscnum(sect *sym.Section) int16</code></pre>
         </article>
         
         <article class="function" data-name="Xcoffinit">
            <h2>Xcoffinit</h2>
            <hr />
            
            <p>Xcoffinit initialised some internal value and setups
already known header information.</p>
            
            <pre><code>func Xcoffinit(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="xcoffUpdateOuterSize">
            <h2>xcoffUpdateOuterSize</h2>
            <hr />
            
            <p>xcoffUpdateOuterSize stores the size of outer symbols in order to have it
in the symbol table.</p>
            
            <pre><code>func xcoffUpdateOuterSize(ctxt *Link, size int64, stype sym.SymKind)</code></pre>
         </article>
         
         <article class="function" data-name="addSymbol">
            <h2>addSymbol</h2>
            <hr />
            
            <p>addSymbol writes a symbol or an auxiliary symbol entry on ctxt.out.</p>
            
            <pre><code>func addSymbol(sym xcoffSym)</code></pre>
         </article>
         
         <article class="function" data-name="xcoffAlign">
            <h2>xcoffAlign</h2>
            <hr />
            
            <p>xcoffAlign returns the log base 2 of the symbol's alignment.</p>
            
            <pre><code>func xcoffAlign(ldr *loader.Loader, x loader.Sym, t SymbolType) uint8</code></pre>
         </article>
         
         <article class="function" data-name="logBase2">
            <h2>logBase2</h2>
            <hr />
            
            <p>logBase2 returns the log in base 2 of a.</p>
            
            <pre><code>func logBase2(a int) uint8</code></pre>
         </article>
         
         <article class="function" data-name="writeSymbolNewFile">
            <h2>writeSymbolNewFile</h2>
            <hr />
            
            <p>Write symbols needed when a new file appeared:
- a C_FILE with one auxiliary entry for its name
- C_DWARF symbols to provide debug information
- a C_HIDEXT which will be a csect containing all of its functions
It needs several parameters to create .csect symbols such as its entry point and its section number.

Currently, a new file is in fact a new package. It seems to be OK, but it might change
in the future.</p>
            
            <pre><code>func writeSymbolNewFile(ctxt *Link, name string, firstEntry uint64, extnum int16)</code></pre>
         </article>
         
         <article class="function" data-name="updatePreviousFile">
            <h2>updatePreviousFile</h2>
            <hr />
            
            <p>Update values for the previous package.
  - Svalue of the C_FILE symbol: if it is the last one, this Svalue must be -1
  - Xsclen of the csect symbol.</p>
            
            <pre><code>func updatePreviousFile(ctxt *Link, last bool)</code></pre>
         </article>
         
         <article class="function" data-name="writeSymbolFunc">
            <h2>writeSymbolFunc</h2>
            <hr />
            
            <p>Write symbol representing a .text function.
The symbol table is split with C_FILE corresponding to each package
and not to each source file as it should be.</p>
            
            <pre><code>func writeSymbolFunc(ctxt *Link, x loader.Sym) []xcoffSym</code></pre>
         </article>
         
         <article class="function" data-name="putaixsym">
            <h2>putaixsym</h2>
            <hr />
            
            <p>put function used by genasmsym to write symbol table.</p>
            
            <pre><code>func putaixsym(ctxt *Link, x loader.Sym, t SymbolType)</code></pre>
         </article>
         
         <article class="function" data-name="asmaixsym">
            <h2>asmaixsym</h2>
            <hr />
            
            <p>Generate XCOFF Symbol table.
It will be written in out file in Asmbxcoff, because it must be
at the very end, especially after relocation sections which needs symbols' index.</p>
            
            <pre><code>func asmaixsym(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="genDynSym">
            <h2>genDynSym</h2>
            <hr />
            
            <pre><code>func genDynSym(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="adddynimpsym">
            <h2>adddynimpsym</h2>
            <hr />
            
            <p>(*xcoffFile)adddynimpsym adds the dynamic symbol "s" to a XCOFF file.
A new symbol named s.Extname() is created to be the actual dynamic symbol
in the .loader section and in the symbol table as an External Reference.
The symbol "s" is transformed to SXCOFFTOC to end up in .data section.
However, there is no writing protection on those symbols and
it might need to be added.
TODO(aix): Handles dynamic symbols without library.</p>
            
            <pre><code>func adddynimpsym(ctxt *Link, s loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="Xcoffadddynrel">
            <h2>Xcoffadddynrel</h2>
            <hr />
            
            <p>Xcoffadddynrel adds a dynamic relocation in a XCOFF file.
This relocation will be made by the loader.</p>
            
            <pre><code>func Xcoffadddynrel(target *Target, ldr *loader.Loader, syms *ArchSyms, s loader.Sym, r loader.Reloc, rIdx int) bool</code></pre>
         </article>
         
         <article class="function" data-name="doxcoff">
            <h2>doxcoff</h2>
            <hr />
            
            <pre><code>func doxcoff()</code></pre>
         </article>
         
         <article class="function" data-name="Loaderblk">
            <h2>Loaderblk</h2>
            <hr />
            
            <p>Create loader section and returns its size.</p>
            
            <pre><code>func Loaderblk(ctxt *Link, off uint64)</code></pre>
         </article>
         
         <article class="function" data-name="writeLdrScn">
            <h2>writeLdrScn</h2>
            <hr />
            
            <pre><code>func writeLdrScn(ctxt *Link, globalOff uint64)</code></pre>
         </article>
         
         <article class="function" data-name="writeFileHeader">
            <h2>writeFileHeader</h2>
            <hr />
            
            <pre><code>func writeFileHeader(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="xcoffwrite">
            <h2>xcoffwrite</h2>
            <hr />
            
            <pre><code>func xcoffwrite(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="asmbXcoff">
            <h2>asmbXcoff</h2>
            <hr />
            
            <p>Generate XCOFF assembly file.</p>
            
            <pre><code>func asmbXcoff(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="emitRelocations">
            <h2>emitRelocations</h2>
            <hr />
            
            <p>emitRelocations emits relocation entries for go.o in external linking.</p>
            
            <pre><code>func emitRelocations(ctxt *Link, fileoff int64)</code></pre>
         </article>
         
         <article class="function" data-name="xcoffCreateExportFile">
            <h2>xcoffCreateExportFile</h2>
            <hr />
            
            <p>xcoffCreateExportFile creates a file with exported symbols for
-Wl,-bE option.
ld won't export symbols unless they are listed in an export file.</p>
            
            <pre><code>func xcoffCreateExportFile(ctxt *Link) fname string</code></pre>
         </article>
         
         <article class="function" data-name="pruneUndefsForWindows">
            <h2>pruneUndefsForWindows</h2>
            <hr />
            
            <p>pruneUndefsForWindows trims the list "undefs" of currently
outstanding unresolved symbols to remove references to DLL import
symbols (e.g. "__imp_XXX"). In older versions of the linker, we
would just immediately forward references from the import sym
(__imp_XXX) to the DLL sym (XXX), but with newer compilers this
strategy falls down in certain cases. We instead now do this
forwarding later on as a post-processing step, and meaning that
during the middle part of host object loading we can see a lot of
unresolved (SXREF) import symbols. We do not, however, want to
trigger the inclusion of an object from a host archive if the
reference is going to be eventually forwarded to the corresponding
SDYNIMPORT symbol, so here we strip out such refs from the undefs
list.</p>
            
            <pre><code>func pruneUndefsForWindows(ldr *loader.Loader, undefs []loader.Sym, froms []loader.Sym) ([]loader.Sym, []loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="hostArchive">
            <h2>hostArchive</h2>
            <hr />
            
            <p>hostArchive reads an archive file holding host objects and links in
required objects. The general format is the same as a Go archive
file, but it has an armap listing symbols and the objects that
define them. This is used for the compiler support library
libgcc.a.</p>
            
            <pre><code>func hostArchive(ctxt *Link, name string)</code></pre>
         </article>
         
         <article class="function" data-name="readArmap">
            <h2>readArmap</h2>
            <hr />
            
            <p>readArmap reads the archive symbol map.</p>
            
            <pre><code>func readArmap(filename string, f *bio.Reader, arhdr ArHdr) archiveMap</code></pre>
         </article>
         
         <article class="function" data-name="TestFallocate">
            <h2>TestFallocate</h2>
            <hr />
            
            <pre><code>func TestFallocate(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDedupLibraries">
            <h2>TestDedupLibraries</h2>
            <hr />
            
            <pre><code>func TestDedupLibraries(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDedupLibrariesOpenBSD">
            <h2>TestDedupLibrariesOpenBSD</h2>
            <hr />
            
            <pre><code>func TestDedupLibrariesOpenBSD(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDedupLibrariesOpenBSDLink">
            <h2>TestDedupLibrariesOpenBSDLink</h2>
            <hr />
            
            <pre><code>func TestDedupLibrariesOpenBSDLink(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="inittasks">
            <h2>inittasks</h2>
            <hr />
            
            <p>Inittasks finds inittask records, figures out a good
order to execute them in, and emits that order for the
runtime to use.

An inittask represents the initialization code that needs
to be run for a package. For package p, the p..inittask
symbol contains a list of init functions to run, both
explicit user init functions and implicit compiler-generated
init functions for initializing global variables like maps.

In addition, inittask records have dependencies between each
other, mirroring the import dependencies. So if package p
imports package q, then there will be a dependency p -> q.
We can't initialize package p until after package q has
already been initialized.

Package dependencies are encoded with relocations. If package
p imports package q, then package p's inittask record will
have a R_INITORDER relocation pointing to package q's inittask
record. See cmd/compile/internal/pkginit/init.go.

This function computes an ordering of all of the inittask
records so that the order respects all the dependencies,
and given that restriction, orders the inittasks in
lexicographic order.</p>
            
            <pre><code>func inittasks()</code></pre>
         </article>
         
         <article class="function" data-name="inittaskSym">
            <h2>inittaskSym</h2>
            <hr />
            
            <p>inittaskSym builds a symbol containing pointers to all the inittasks
that need to be run, given a list of root inittask symbols.</p>
            
            <pre><code>func inittaskSym(rootNames []string, symName string) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="writeSEH">
            <h2>writeSEH</h2>
            <hr />
            
            <pre><code>func writeSEH(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="writeSEHAMD64">
            <h2>writeSEHAMD64</h2>
            <hr />
            
            <pre><code>func writeSEHAMD64(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="typelink">
            <h2>typelink</h2>
            <hr />
            
            <p>typelink generates the typelink table which is used by reflect.typelinks().
Types that should be added to the typelinks table are marked with the
MakeTypelink attribute by the compiler.</p>
            
            <pre><code>func typelink()</code></pre>
         </article>
         
         <article class="function" data-name="AtExit">
            <h2>AtExit</h2>
            <hr />
            
            <pre><code>func AtExit(f func)</code></pre>
         </article>
         
         <article class="function" data-name="runAtExitFuncs">
            <h2>runAtExitFuncs</h2>
            <hr />
            
            <p>runAtExitFuncs runs the queued set of AtExit functions.</p>
            
            <pre><code>func runAtExitFuncs()</code></pre>
         </article>
         
         <article class="function" data-name="Exit">
            <h2>Exit</h2>
            <hr />
            
            <p>Exit exits with code after executing all atExitFuncs.</p>
            
            <pre><code>func Exit(code int)</code></pre>
         </article>
         
         <article class="function" data-name="Exitf">
            <h2>Exitf</h2>
            <hr />
            
            <p>Exitf logs an error message then calls Exit(2).</p>
            
            <pre><code>func Exitf(format string, a ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="afterErrorAction">
            <h2>afterErrorAction</h2>
            <hr />
            
            <p>afterErrorAction updates 'nerrors' on error and invokes exit or
panics in the proper circumstances.</p>
            
            <pre><code>func afterErrorAction()</code></pre>
         </article>
         
         <article class="function" data-name="Errorf">
            <h2>Errorf</h2>
            <hr />
            
            <p>Errorf logs an error message without a specific symbol for context.
Use ctxt.Errorf when possible.

If more than 20 errors have been printed, exit with an error.

Logging an error means that on exit cmd/link will delete any
output file and return a non-zero error code.</p>
            
            <pre><code>func Errorf(format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Errorf">
            <h2>Errorf</h2>
            <hr />
            
            <p>Errorf method logs an error message.

If more than 20 errors have been printed, exit with an error.

Logging an error means that on exit cmd/link will delete any
output file and return a non-zero error code.</p>
            
            <pre><code>func Errorf(s loader.Sym, format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="artrim">
            <h2>artrim</h2>
            <hr />
            
            <pre><code>func artrim(x []byte) string</code></pre>
         </article>
         
         <article class="function" data-name="stringtouint32">
            <h2>stringtouint32</h2>
            <hr />
            
            <pre><code>func stringtouint32(x []uint32, s string)</code></pre>
         </article>
         
         <article class="function" data-name="TestHeap">
            <h2>TestHeap</h2>
            <hr />
            
            <pre><code>func TestHeap(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="verify">
            <h2>verify</h2>
            <hr />
            
            <p>recursively verify heap-ness, starting at element i.</p>
            
            <pre><code>func verify(h *heap, i int) bool</code></pre>
         </article>
         
         <article class="function" data-name="mkArchSym">
            <h2>mkArchSym</h2>
            <hr />
            
            <p>mkArchSym is a helper for setArchSyms, to set up a special symbol.</p>
            
            <pre><code>func mkArchSym(name string, ver int, ls *loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="mkArchSymVec">
            <h2>mkArchSymVec</h2>
            <hr />
            
            <p>mkArchSymVec is similar to  setArchSyms, but operates on elements within
a slice, where each element corresponds to some symbol version.</p>
            
            <pre><code>func mkArchSymVec(name string, ver int, ls []loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="setArchSyms">
            <h2>setArchSyms</h2>
            <hr />
            
            <p>setArchSyms sets up the ArchSyms structure, and must be called before
relocations are applied.</p>
            
            <pre><code>func setArchSyms()</code></pre>
         </article>
         
         <article class="function" data-name="DynlinkingGo">
            <h2>DynlinkingGo</h2>
            <hr />
            
            <p>DynlinkingGo reports whether we are producing Go code that can live
in separate shared libraries linked together at runtime.</p>
            
            <pre><code>func DynlinkingGo() bool</code></pre>
         </article>
         
         <article class="function" data-name="CanUsePlugins">
            <h2>CanUsePlugins</h2>
            <hr />
            
            <p>CanUsePlugins reports whether a plugins can be used</p>
            
            <pre><code>func CanUsePlugins() bool</code></pre>
         </article>
         
         <article class="function" data-name="NeedCodeSign">
            <h2>NeedCodeSign</h2>
            <hr />
            
            <p>NeedCodeSign reports whether we need to code-sign the output binary.</p>
            
            <pre><code>func NeedCodeSign() bool</code></pre>
         </article>
         
         <article class="function" data-name="Lflag">
            <h2>Lflag</h2>
            <hr />
            
            <pre><code>func Lflag(ctxt *Link, arg string)</code></pre>
         </article>
         
         <article class="function" data-name="mayberemoveoutfile">
            <h2>mayberemoveoutfile</h2>
            <hr />
            
            <p>* Unix doesn't like it when we write to a running (or, sometimes,
 * recently run) binary, so remove the output file before writing it.
 * On Windows 7, remove() can force a subsequent create() to fail.
 * S_ISREG() does not exist on Plan 9.</p>
            
            <pre><code>func mayberemoveoutfile()</code></pre>
         </article>
         
         <article class="function" data-name="libinit">
            <h2>libinit</h2>
            <hr />
            
            <pre><code>func libinit(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="exitIfErrors">
            <h2>exitIfErrors</h2>
            <hr />
            
            <pre><code>func exitIfErrors()</code></pre>
         </article>
         
         <article class="function" data-name="errorexit">
            <h2>errorexit</h2>
            <hr />
            
            <pre><code>func errorexit()</code></pre>
         </article>
         
         <article class="function" data-name="loadinternal">
            <h2>loadinternal</h2>
            <hr />
            
            <pre><code>func loadinternal(ctxt *Link, name string) *sym.Library</code></pre>
         </article>
         
         <article class="function" data-name="extld">
            <h2>extld</h2>
            <hr />
            
            <p>extld returns the current external linker.</p>
            
            <pre><code>func extld() []string</code></pre>
         </article>
         
         <article class="function" data-name="findLibPathCmd">
            <h2>findLibPathCmd</h2>
            <hr />
            
            <p>findLibPathCmd uses cmd command to find gcc library libname.
It returns library full path if found, or "none" if not found.</p>
            
            <pre><code>func findLibPathCmd(cmd string, libname string) string</code></pre>
         </article>
         
         <article class="function" data-name="findLibPath">
            <h2>findLibPath</h2>
            <hr />
            
            <p>findLibPath searches for library libname.
It returns library full path if found, or "none" if not found.</p>
            
            <pre><code>func findLibPath(libname string) string</code></pre>
         </article>
         
         <article class="function" data-name="loadlib">
            <h2>loadlib</h2>
            <hr />
            
            <pre><code>func loadlib()</code></pre>
         </article>
         
         <article class="function" data-name="loadWindowsHostArchives">
            <h2>loadWindowsHostArchives</h2>
            <hr />
            
            <p>loadWindowsHostArchives loads in host archives and objects when
doing internal linking on windows. Older toolchains seem to require
just a single pass through the various archives, but some modern
toolchains when linking a C program with mingw pass library paths
multiple times to the linker, e.g. "... -lmingwex -lmingw32 ...
-lmingwex -lmingw32 ...". To accommodate this behavior, we make two
passes over the host archives below.</p>
            
            <pre><code>func loadWindowsHostArchives(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="loadcgodirectives">
            <h2>loadcgodirectives</h2>
            <hr />
            
            <p>loadcgodirectives reads the previously discovered cgo directives, creating
symbols in preparation for host object loading or use later in the link.</p>
            
            <pre><code>func loadcgodirectives()</code></pre>
         </article>
         
         <article class="function" data-name="linksetup">
            <h2>linksetup</h2>
            <hr />
            
            <p>Set up flags and special symbols depending on the platform build mode.
This version works with loader.Loader.</p>
            
            <pre><code>func linksetup()</code></pre>
         </article>
         
         <article class="function" data-name="mangleTypeSym">
            <h2>mangleTypeSym</h2>
            <hr />
            
            <p>mangleTypeSym shortens the names of symbols that represent Go types
if they are visible in the symbol table.

As the names of these symbols are derived from the string of
the type, they can run to many kilobytes long. So we shorten
them using a SHA-1 when the name appears in the final binary.
This also removes characters that upset external linkers.

These are the symbols that begin with the prefix 'type.' and
contain run-time type information used by the runtime and reflect
packages. All Go binaries contain these symbols, but only
those programs loaded dynamically in multiple parts need these
symbols to have entries in the symbol table.</p>
            
            <pre><code>func mangleTypeSym()</code></pre>
         </article>
         
         <article class="function" data-name="typeSymbolMangle">
            <h2>typeSymbolMangle</h2>
            <hr />
            
            <p>typeSymbolMangle mangles the given symbol name into something shorter.

Keep the type:. prefix, which parts of the linker (like the
DWARF generator) know means the symbol is not decodable.
Leave type:runtime. symbols alone, because other parts of
the linker manipulates them.</p>
            
            <pre><code>func typeSymbolMangle(name string) string</code></pre>
         </article>
         
         <article class="function" data-name="nextar">
            <h2>nextar</h2>
            <hr />
            
            <p>* look for the next file in an archive.
 * adapted from libmach.</p>
            
            <pre><code>func nextar(bp *bio.Reader, off int64, a *ArHdr) int64</code></pre>
         </article>
         
         <article class="function" data-name="loadobjfile">
            <h2>loadobjfile</h2>
            <hr />
            
            <pre><code>func loadobjfile(ctxt *Link, lib *sym.Library)</code></pre>
         </article>
         
         <article class="function" data-name="ldhostobj">
            <h2>ldhostobj</h2>
            <hr />
            
            <pre><code>func ldhostobj(ld func, headType objabi.HeadType, f *bio.Reader, pkg string, length int64, pn string, file string) *Hostobj</code></pre>
         </article>
         
         <article class="function" data-name="hostobjs">
            <h2>hostobjs</h2>
            <hr />
            
            <pre><code>func hostobjs(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="hostlinksetup">
            <h2>hostlinksetup</h2>
            <hr />
            
            <pre><code>func hostlinksetup(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="cleanTimeStamps">
            <h2>cleanTimeStamps</h2>
            <hr />
            
            <p>cleanTimeStamps resets the timestamps for the specified list of
existing files to the Unix epoch (1970-01-01 00:00:00 +0000 UTC).
We take this step in order to help preserve reproducible builds;
this seems to be primarily needed for external linking on Darwin
with later versions of xcode, which (unfortunately) seem to want to
incorporate object file times into the final output file's build
ID. See issue 64947 for the unpleasant details.</p>
            
            <pre><code>func cleanTimeStamps(files []string)</code></pre>
         </article>
         
         <article class="function" data-name="hostobjCopy">
            <h2>hostobjCopy</h2>
            <hr />
            
            <p>hostobjCopy creates a copy of the object files in hostobj in a
temporary directory.</p>
            
            <pre><code>func hostobjCopy() paths []string</code></pre>
         </article>
         
         <article class="function" data-name="writeGDBLinkerScript">
            <h2>writeGDBLinkerScript</h2>
            <hr />
            
            <p>writeGDBLinkerScript creates gcc linker script file in temp
directory. writeGDBLinkerScript returns created file path.
The script is used to work around gcc bug
(see https://golang.org/issue/20183 for details).</p>
            
            <pre><code>func writeGDBLinkerScript() string</code></pre>
         </article>
         
         <article class="function" data-name="archive">
            <h2>archive</h2>
            <hr />
            
            <p>archive builds a .a archive from the hostobj object files.</p>
            
            <pre><code>func archive()</code></pre>
         </article>
         
         <article class="function" data-name="hostlink">
            <h2>hostlink</h2>
            <hr />
            
            <pre><code>func hostlink()</code></pre>
         </article>
         
         <article class="function" data-name="passLongArgsInResponseFile">
            <h2>passLongArgsInResponseFile</h2>
            <hr />
            
            <p>passLongArgsInResponseFile writes the arguments into a file if they
are very long.</p>
            
            <pre><code>func passLongArgsInResponseFile(argv []string, altLinker string) []string</code></pre>
         </article>
         
         <article class="function" data-name="linkerFlagSupported">
            <h2>linkerFlagSupported</h2>
            <hr />
            
            <pre><code>func linkerFlagSupported(arch *sys.Arch, linker string, altLinker string, flag string) bool</code></pre>
         </article>
         
         <article class="function" data-name="trimLinkerArgv">
            <h2>trimLinkerArgv</h2>
            <hr />
            
            <p>trimLinkerArgv returns a new copy of argv that does not include flags
that are not relevant for testing whether some linker option works.</p>
            
            <pre><code>func trimLinkerArgv(argv []string) []string</code></pre>
         </article>
         
         <article class="function" data-name="hostlinkArchArgs">
            <h2>hostlinkArchArgs</h2>
            <hr />
            
            <p>hostlinkArchArgs returns arguments to pass to the external linker
based on the architecture.</p>
            
            <pre><code>func hostlinkArchArgs(arch *sys.Arch) []string</code></pre>
         </article>
         
         <article class="function" data-name="ldobj">
            <h2>ldobj</h2>
            <hr />
            
            <p>ldobj loads an input object. If it is a host object (an object
compiled by a non-Go compiler) it returns the Hostobj pointer. If
it is a Go object, it returns nil.</p>
            
            <pre><code>func ldobj(ctxt *Link, f *bio.Reader, lib *sym.Library, length int64, pn string, file string) *Hostobj</code></pre>
         </article>
         
         <article class="function" data-name="symbolsAreUnresolved">
            <h2>symbolsAreUnresolved</h2>
            <hr />
            
            <p>symbolsAreUnresolved scans through the loader's list of unresolved
symbols and checks to see whether any of them match the names of the
symbols in 'want'. Return value is a list of bools, with list[K] set
to true if there is an unresolved reference to the symbol in want[K].</p>
            
            <pre><code>func symbolsAreUnresolved(ctxt *Link, want []string) []bool</code></pre>
         </article>
         
         <article class="function" data-name="hostObject">
            <h2>hostObject</h2>
            <hr />
            
            <p>hostObject reads a single host object file (compare to "hostArchive").
This is used as part of internal linking when we need to pull in
files such as "crt?.o".</p>
            
            <pre><code>func hostObject(ctxt *Link, objname string, path string)</code></pre>
         </article>
         
         <article class="function" data-name="checkFingerprint">
            <h2>checkFingerprint</h2>
            <hr />
            
            <pre><code>func checkFingerprint(lib *sym.Library, libfp goobj.FingerprintType, src string, srcfp goobj.FingerprintType)</code></pre>
         </article>
         
         <article class="function" data-name="readelfsymboldata">
            <h2>readelfsymboldata</h2>
            <hr />
            
            <pre><code>func readelfsymboldata(ctxt *Link, f *elf.File, sym *elf.Symbol) []byte</code></pre>
         </article>
         
         <article class="function" data-name="readwithpad">
            <h2>readwithpad</h2>
            <hr />
            
            <pre><code>func readwithpad(r io.Reader, sz int32) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="readnote">
            <h2>readnote</h2>
            <hr />
            
            <pre><code>func readnote(f *elf.File, name []byte, typ int32) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="findshlib">
            <h2>findshlib</h2>
            <hr />
            
            <pre><code>func findshlib(ctxt *Link, shlib string) string</code></pre>
         </article>
         
         <article class="function" data-name="ldshlibsyms">
            <h2>ldshlibsyms</h2>
            <hr />
            
            <pre><code>func ldshlibsyms(ctxt *Link, shlib string)</code></pre>
         </article>
         
         <article class="function" data-name="addsection">
            <h2>addsection</h2>
            <hr />
            
            <pre><code>func addsection(ldr *loader.Loader, arch *sys.Arch, seg *sym.Segment, name string, rwx int) *sym.Section</code></pre>
         </article>
         
         <article class="function" data-name="usage">
            <h2>usage</h2>
            <hr />
            
            <pre><code>func usage()</code></pre>
         </article>
         
         <article class="function" data-name="defineInternal">
            <h2>defineInternal</h2>
            <hr />
            
            <p>defineInternal defines a symbol used internally by the go runtime.</p>
            
            <pre><code>func defineInternal(p string, t sym.SymKind) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="xdefine">
            <h2>xdefine</h2>
            <hr />
            
            <pre><code>func xdefine(p string, t sym.SymKind, v int64) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="datoff">
            <h2>datoff</h2>
            <hr />
            
            <pre><code>func datoff(ldr *loader.Loader, s loader.Sym, addr int64) int64</code></pre>
         </article>
         
         <article class="function" data-name="Entryvalue">
            <h2>Entryvalue</h2>
            <hr />
            
            <pre><code>func Entryvalue(ctxt *Link) int64</code></pre>
         </article>
         
         <article class="function" data-name="callgraph">
            <h2>callgraph</h2>
            <hr />
            
            <pre><code>func callgraph()</code></pre>
         </article>
         
         <article class="function" data-name="Rnd">
            <h2>Rnd</h2>
            <hr />
            
            <pre><code>func Rnd(v int64, r int64) int64</code></pre>
         </article>
         
         <article class="function" data-name="bgetc">
            <h2>bgetc</h2>
            <hr />
            
            <pre><code>func bgetc(r *bio.Reader) int</code></pre>
         </article>
         
         <article class="function" data-name="postorder">
            <h2>postorder</h2>
            <hr />
            
            <pre><code>func postorder(libs []*sym.Library) []*sym.Library</code></pre>
         </article>
         
         <article class="function" data-name="dfs">
            <h2>dfs</h2>
            <hr />
            
            <pre><code>func dfs(lib *sym.Library, mark *ast.MapType, order *[]*sym.Library)</code></pre>
         </article>
         
         <article class="function" data-name="ElfSymForReloc">
            <h2>ElfSymForReloc</h2>
            <hr />
            
            <pre><code>func ElfSymForReloc(ctxt *Link, s loader.Sym) int32</code></pre>
         </article>
         
         <article class="function" data-name="AddGotSym">
            <h2>AddGotSym</h2>
            <hr />
            
            <pre><code>func AddGotSym(target *Target, ldr *loader.Loader, syms *ArchSyms, s loader.Sym, elfRelocTyp uint32)</code></pre>
         </article>
         
         <article class="function" data-name="captureHostObj">
            <h2>captureHostObj</h2>
            <hr />
            
            <p>captureHostObj writes out the content of a host object (pulled from
an archive or loaded from a *.o file directly) to a directory
specified via the linker's "-capturehostobjs" debugging flag. This
is intended to make it easier for a developer to inspect the actual
object feeding into "CGO internal" link step.</p>
            
            <pre><code>func captureHostObj(h *Hostobj)</code></pre>
         </article>
         
         <article class="function" data-name="findExtLinkTool">
            <h2>findExtLinkTool</h2>
            <hr />
            
            <p>findExtLinkTool invokes the external linker CC with --print-prog-name
passing the name of the tool we're interested in, such as "strip",
"ar", or "dsymutil", and returns the path passed back from the command.</p>
            
            <pre><code>func findExtLinkTool(toolname string) string</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Logf">
            <h2>Logf</h2>
            <hr />
            
            <pre><code>func Logf(format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="addImports">
            <h2>addImports</h2>
            <hr />
            
            <pre><code>func addImports(ctxt *Link, l *sym.Library, pn string)</code></pre>
         </article>
         
         <article class="function" data-name="IncVersion">
            <h2>IncVersion</h2>
            <hr />
            
            <p>Allocate a new version (i.e. symbol namespace).</p>
            
            <pre><code>func IncVersion() int</code></pre>
         </article>
         
         <article class="function" data-name="MaxVersion">
            <h2>MaxVersion</h2>
            <hr />
            
            <p>returns the maximum version number</p>
            
            <pre><code>func MaxVersion() int</code></pre>
         </article>
         
         <article class="function" data-name="createGeneratorSymbol">
            <h2>createGeneratorSymbol</h2>
            <hr />
            
            <p>createGeneratorSymbol is a convenience method for creating a generator
symbol.</p>
            
            <pre><code>func createGeneratorSymbol(name string, version int, t sym.SymKind, size int64, gen generatorFunc) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="Mmap">
            <h2>Mmap</h2>
            <hr />
            
            <p>Mmap allocates an in-heap output buffer with the given size. It copies
any old data (if any) to the new buffer.</p>
            
            <pre><code>func Mmap(filesize uint64) error</code></pre>
         </article>
         
         <article class="function" data-name="munmap">
            <h2>munmap</h2>
            <hr />
            
            <pre><code>func munmap()</code></pre>
         </article>
         
         <article class="function" data-name="size">
            <h2>size</h2>
            <hr />
            
            <p>size returns size of string table t.</p>
            
            <pre><code>func size() int</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <p>add adds string str to string table t.</p>
            
            <pre><code>func add(str string) int</code></pre>
         </article>
         
         <article class="function" data-name="write">
            <h2>write</h2>
            <hr />
            
            <p>write writes string table t into the output file.</p>
            
            <pre><code>func write(out *OutBuf)</code></pre>
         </article>
         
         <article class="function" data-name="checkOffset">
            <h2>checkOffset</h2>
            <hr />
            
            <p>checkOffset verifies COFF section sect offset in the file.</p>
            
            <pre><code>func checkOffset(off int64)</code></pre>
         </article>
         
         <article class="function" data-name="checkSegment">
            <h2>checkSegment</h2>
            <hr />
            
            <p>checkSegment verifies COFF section sect matches address
and file offset provided in segment seg.</p>
            
            <pre><code>func checkSegment(seg *sym.Segment)</code></pre>
         </article>
         
         <article class="function" data-name="pad">
            <h2>pad</h2>
            <hr />
            
            <p>pad adds zeros to the section sect. It writes as many bytes
as necessary to make section sect.SizeOfRawData bytes long.
It assumes that n bytes are already written to the file.</p>
            
            <pre><code>func pad(out *OutBuf, n uint32)</code></pre>
         </article>
         
         <article class="function" data-name="write">
            <h2>write</h2>
            <hr />
            
            <p>write writes COFF section sect into the output file.</p>
            
            <pre><code>func write(out *OutBuf, linkmode LinkMode) error</code></pre>
         </article>
         
         <article class="function" data-name="emitRelocations">
            <h2>emitRelocations</h2>
            <hr />
            
            <p>emitRelocations emits the relocation entries for the sect.
The actual relocations are emitted by relocfn.
This updates the corresponding PE section table entry
with the relocation offset and count.</p>
            
            <pre><code>func emitRelocations(out *OutBuf, relocfn func)</code></pre>
         </article>
         
         <article class="function" data-name="addSection">
            <h2>addSection</h2>
            <hr />
            
            <p>addSection adds section to the COFF file f.</p>
            
            <pre><code>func addSection(name string, sectsize int, filesize int) *peSection</code></pre>
         </article>
         
         <article class="function" data-name="addDWARFSection">
            <h2>addDWARFSection</h2>
            <hr />
            
            <p>addDWARFSection adds DWARF section to the COFF file f.
This function is similar to addSection, but DWARF section names are
longer than 8 characters, so they need to be stored in the string table.</p>
            
            <pre><code>func addDWARFSection(name string, size int) *peSection</code></pre>
         </article>
         
         <article class="function" data-name="addDWARF">
            <h2>addDWARF</h2>
            <hr />
            
            <p>addDWARF adds DWARF information to the COFF file f.</p>
            
            <pre><code>func addDWARF()</code></pre>
         </article>
         
         <article class="function" data-name="addSEH">
            <h2>addSEH</h2>
            <hr />
            
            <p>addSEH adds SEH information to the COFF file f.</p>
            
            <pre><code>func addSEH(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="addInitArray">
            <h2>addInitArray</h2>
            <hr />
            
            <p>addInitArray adds .ctors COFF section to the file f.</p>
            
            <pre><code>func addInitArray(ctxt *Link) *peSection</code></pre>
         </article>
         
         <article class="function" data-name="emitRelocations">
            <h2>emitRelocations</h2>
            <hr />
            
            <p>emitRelocations emits relocation entries for go.o in external linking.</p>
            
            <pre><code>func emitRelocations(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="writeSymbol">
            <h2>writeSymbol</h2>
            <hr />
            
            <p>writeSymbol appends symbol s to file f symbol table.
It also sets s.Dynid to written symbol number.</p>
            
            <pre><code>func writeSymbol(out *OutBuf, ldr *loader.Loader, s loader.Sym, name string, value int64, sectidx int, typ uint16, class uint8)</code></pre>
         </article>
         
         <article class="function" data-name="mapToPESection">
            <h2>mapToPESection</h2>
            <hr />
            
            <p>mapToPESection searches peFile f for s symbol's location.
It returns PE section index, and offset within that section.</p>
            
            <pre><code>func mapToPESection(ldr *loader.Loader, s loader.Sym, linkmode LinkMode) (pesectidx int, offset int64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="AddPELabelSym">
            <h2>AddPELabelSym</h2>
            <hr />
            
            <pre><code>func AddPELabelSym(ldr *loader.Loader, s loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="writeSymbols">
            <h2>writeSymbols</h2>
            <hr />
            
            <p>writeSymbols writes all COFF symbol table records.</p>
            
            <pre><code>func writeSymbols(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="writeSymbolTableAndStringTable">
            <h2>writeSymbolTableAndStringTable</h2>
            <hr />
            
            <p>writeSymbolTableAndStringTable writes out symbol and string tables for peFile f.</p>
            
            <pre><code>func writeSymbolTableAndStringTable(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="writeFileHeader">
            <h2>writeFileHeader</h2>
            <hr />
            
            <p>writeFileHeader writes COFF file header for peFile f.</p>
            
            <pre><code>func writeFileHeader(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="writeOptionalHeader">
            <h2>writeOptionalHeader</h2>
            <hr />
            
            <p>writeOptionalHeader writes COFF optional header for peFile f.</p>
            
            <pre><code>func writeOptionalHeader(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="Peinit">
            <h2>Peinit</h2>
            <hr />
            
            <pre><code>func Peinit(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="pewrite">
            <h2>pewrite</h2>
            <hr />
            
            <pre><code>func pewrite(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="strput">
            <h2>strput</h2>
            <hr />
            
            <pre><code>func strput(out *OutBuf, s string)</code></pre>
         </article>
         
         <article class="function" data-name="initdynimport">
            <h2>initdynimport</h2>
            <hr />
            
            <pre><code>func initdynimport(ctxt *Link) *Dll</code></pre>
         </article>
         
         <article class="function" data-name="peimporteddlls">
            <h2>peimporteddlls</h2>
            <hr />
            
            <p>peimporteddlls returns the gcc command line argument to link all imported
DLLs.</p>
            
            <pre><code>func peimporteddlls() []string</code></pre>
         </article>
         
         <article class="function" data-name="addimports">
            <h2>addimports</h2>
            <hr />
            
            <pre><code>func addimports(ctxt *Link, datsect *peSection)</code></pre>
         </article>
         
         <article class="function" data-name="initdynexport">
            <h2>initdynexport</h2>
            <hr />
            
            <pre><code>func initdynexport(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="addexports">
            <h2>addexports</h2>
            <hr />
            
            <pre><code>func addexports(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="addentry">
            <h2>addentry</h2>
            <hr />
            
            <pre><code>func addentry(ldr *loader.Loader, s loader.Sym, r *loader.Reloc)</code></pre>
         </article>
         
         <article class="function" data-name="write">
            <h2>write</h2>
            <hr />
            
            <pre><code>func write(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="addPEBaseRelocSym">
            <h2>addPEBaseRelocSym</h2>
            <hr />
            
            <pre><code>func addPEBaseRelocSym(ldr *loader.Loader, s loader.Sym, rt *peBaseRelocTable)</code></pre>
         </article>
         
         <article class="function" data-name="needPEBaseReloc">
            <h2>needPEBaseReloc</h2>
            <hr />
            
            <pre><code>func needPEBaseReloc(ctxt *Link) bool</code></pre>
         </article>
         
         <article class="function" data-name="addPEBaseReloc">
            <h2>addPEBaseReloc</h2>
            <hr />
            
            <pre><code>func addPEBaseReloc(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="dope">
            <h2>dope</h2>
            <hr />
            
            <pre><code>func dope()</code></pre>
         </article>
         
         <article class="function" data-name="setpersrc">
            <h2>setpersrc</h2>
            <hr />
            
            <pre><code>func setpersrc(ctxt *Link, syms []loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="addpersrc">
            <h2>addpersrc</h2>
            <hr />
            
            <pre><code>func addpersrc(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="asmbPe">
            <h2>asmbPe</h2>
            <hr />
            
            <pre><code>func asmbPe(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="isRuntimeDepPkg">
            <h2>isRuntimeDepPkg</h2>
            <hr />
            
            <p>isRuntimeDepPkg reports whether pkg is the runtime package or its dependency.
TODO: just compute from the runtime package, and remove this hardcoded list.</p>
            
            <pre><code>func isRuntimeDepPkg(pkg string) bool</code></pre>
         </article>
         
         <article class="function" data-name="maxSizeTrampolines">
            <h2>maxSizeTrampolines</h2>
            <hr />
            
            <p>Estimate the max size needed to hold any new trampolines created for this function. This
is used to determine when the section can be split if it becomes too large, to ensure that
the trampolines are in the same section as the function that uses them.</p>
            
            <pre><code>func maxSizeTrampolines(ctxt *Link, ldr *loader.Loader, s loader.Sym, isTramp bool) uint64</code></pre>
         </article>
         
         <article class="function" data-name="trampoline">
            <h2>trampoline</h2>
            <hr />
            
            <p>Detect too-far jumps in function s, and add trampolines if necessary.
ARM, LOONG64, PPC64, PPC64LE and RISCV64 support trampoline insertion for internal
and external linking. On PPC64 and PPC64LE the text sections might be split
but will still insert trampolines where necessary.</p>
            
            <pre><code>func trampoline(ctxt *Link, s loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="isPLTCall">
            <h2>isPLTCall</h2>
            <hr />
            
            <p>whether rt is a (host object) relocation that will be turned into
a call to PLT.</p>
            
            <pre><code>func isPLTCall(arch *sys.Arch, rt objabi.RelocType) bool</code></pre>
         </article>
         
         <article class="function" data-name="FoldSubSymbolOffset">
            <h2>FoldSubSymbolOffset</h2>
            <hr />
            
            <p>FoldSubSymbolOffset computes the offset of symbol s to its top-level outer
symbol. Returns the top-level symbol and the offset.
This is used in generating external relocations.</p>
            
            <pre><code>func FoldSubSymbolOffset(ldr *loader.Loader, s loader.Sym) (loader.Sym, int64)</code></pre>
         </article>
         
         <article class="function" data-name="relocsym">
            <h2>relocsym</h2>
            <hr />
            
            <p>relocsym resolve relocations in "s", updating the symbol's content
in "P".
The main loop walks through the list of relocations attached to "s"
and resolves them where applicable. Relocations are often
architecture-specific, requiring calls into the 'archreloc' and/or
'archrelocvariant' functions for the architecture. When external
linking is in effect, it may not be  possible to completely resolve
the address/offset for a symbol, in which case the goal is to lay
the groundwork for turning a given relocation into an external reloc
(to be applied by the external linker). For more on how relocations
work in general, see

	"Linkers and Loaders", by John R. Levine (Morgan Kaufmann, 1999), ch. 7

This is a performance-critical function for the linker; be careful
to avoid introducing unnecessary allocations in the main loop.</p>
            
            <pre><code>func relocsym(s loader.Sym, P []byte)</code></pre>
         </article>
         
         <article class="function" data-name="extreloc">
            <h2>extreloc</h2>
            <hr />
            
            <p>Convert a Go relocation to an external relocation.</p>
            
            <pre><code>func extreloc(ctxt *Link, ldr *loader.Loader, s loader.Sym, r loader.Reloc) (loader.ExtReloc, bool)</code></pre>
         </article>
         
         <article class="function" data-name="ExtrelocSimple">
            <h2>ExtrelocSimple</h2>
            <hr />
            
            <p>ExtrelocSimple creates a simple external relocation from r, with the same
symbol and addend.</p>
            
            <pre><code>func ExtrelocSimple(ldr *loader.Loader, r loader.Reloc) loader.ExtReloc</code></pre>
         </article>
         
         <article class="function" data-name="ExtrelocViaOuterSym">
            <h2>ExtrelocViaOuterSym</h2>
            <hr />
            
            <p>ExtrelocViaOuterSym creates an external relocation from r targeting the
outer symbol and folding the subsymbol's offset into the addend.</p>
            
            <pre><code>func ExtrelocViaOuterSym(ldr *loader.Loader, r loader.Reloc, s loader.Sym) loader.ExtReloc</code></pre>
         </article>
         
         <article class="function" data-name="makeRelocSymState">
            <h2>makeRelocSymState</h2>
            <hr />
            
            <p>makeRelocSymState creates a relocSymState container object to
pass to relocsym(). If relocsym() calls happen in parallel,
each parallel thread should have its own state object.</p>
            
            <pre><code>func makeRelocSymState() *relocSymState</code></pre>
         </article>
         
         <article class="function" data-name="windynrelocsym">
            <h2>windynrelocsym</h2>
            <hr />
            
            <p>windynrelocsym examines a text symbol 's' and looks for relocations
from it that correspond to references to symbols defined in DLLs,
then fixes up those relocations as needed. A reference to a symbol
XYZ from some DLL will fall into one of two categories: an indirect
ref via "__imp_XYZ", or a direct ref to "XYZ". Here's an example of
an indirect ref (this is an excerpt from objdump -ldr):

	     1c1: 48 89 c6                     	movq	%rax, %rsi
	     1c4: ff 15 00 00 00 00            	callq	*(%rip)
			00000000000001c6:  IMAGE_REL_AMD64_REL32	__imp__errno

In the assembly above, the code loads up the value of __imp_errno
and then does an indirect call to that value.

Here is what a direct reference might look like:

	     137: e9 20 06 00 00               	jmp	0x75c <pow+0x75c>
	     13c: e8 00 00 00 00               	callq	0x141 <pow+0x141>
			000000000000013d:  IMAGE_REL_AMD64_REL32	_errno

The assembly below dispenses with the import symbol and just makes
a direct call to _errno.

The code below handles indirect refs by redirecting the target of
the relocation from "__imp_XYZ" to "XYZ" (since the latter symbol
is what the Windows loader is expected to resolve). For direct refs
the call is redirected to a stub, where the stub first loads the
symbol and then direct an indirect call to that value.

Note that for a given symbol (as above) it is perfectly legal to
have both direct and indirect references.</p>
            
            <pre><code>func windynrelocsym(ctxt *Link, rel *loader.SymbolBuilder, s loader.Sym) error</code></pre>
         </article>
         
         <article class="function" data-name="windynrelocsyms">
            <h2>windynrelocsyms</h2>
            <hr />
            
            <p>windynrelocsyms generates jump table to C library functions that will be
added later. windynrelocsyms writes the table into .rel symbol.</p>
            
            <pre><code>func windynrelocsyms()</code></pre>
         </article>
         
         <article class="function" data-name="dynrelocsym">
            <h2>dynrelocsym</h2>
            <hr />
            
            <pre><code>func dynrelocsym(ctxt *Link, s loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="dynreloc">
            <h2>dynreloc</h2>
            <hr />
            
            <pre><code>func dynreloc(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="CodeblkPad">
            <h2>CodeblkPad</h2>
            <hr />
            
            <pre><code>func CodeblkPad(ctxt *Link, out *OutBuf, addr int64, size int64, pad []byte)</code></pre>
         </article>
         
         <article class="function" data-name="writeBlocks">
            <h2>writeBlocks</h2>
            <hr />
            
            <p>writeBlocks writes a specified chunk of symbols to the output buffer. It
breaks the write up into ≥blockSize chunks to write them out, and schedules
as many goroutines as necessary to accomplish this task. This call then
blocks, waiting on the writes to complete. Note that we use the sem parameter
to limit the number of concurrent writes taking place.</p>
            
            <pre><code>func writeBlocks(ctxt *Link, out *OutBuf, sem *ast.ChanType, ldr *loader.Loader, syms []loader.Sym, addr int64, size int64, pad []byte)</code></pre>
         </article>
         
         <article class="function" data-name="writeBlock">
            <h2>writeBlock</h2>
            <hr />
            
            <pre><code>func writeBlock(ctxt *Link, out *OutBuf, ldr *loader.Loader, syms []loader.Sym, addr int64, size int64, pad []byte)</code></pre>
         </article>
         
         <article class="function" data-name="writeParallel">
            <h2>writeParallel</h2>
            <hr />
            
            <p>writeParallel handles scheduling parallel execution of data write functions.</p>
            
            <pre><code>func writeParallel(wg *sync.WaitGroup, fn writeFn, ctxt *Link, seek uint64, vaddr uint64, length uint64)</code></pre>
         </article>
         
         <article class="function" data-name="datblk">
            <h2>datblk</h2>
            <hr />
            
            <pre><code>func datblk(ctxt *Link, out *OutBuf, addr int64, size int64)</code></pre>
         </article>
         
         <article class="function" data-name="DatblkBytes">
            <h2>DatblkBytes</h2>
            <hr />
            
            <p>Used only on Wasm for now.</p>
            
            <pre><code>func DatblkBytes(ctxt *Link, addr int64, size int64) []byte</code></pre>
         </article>
         
         <article class="function" data-name="writeDatblkToOutBuf">
            <h2>writeDatblkToOutBuf</h2>
            <hr />
            
            <pre><code>func writeDatblkToOutBuf(ctxt *Link, out *OutBuf, addr int64, size int64)</code></pre>
         </article>
         
         <article class="function" data-name="dwarfblk">
            <h2>dwarfblk</h2>
            <hr />
            
            <pre><code>func dwarfblk(ctxt *Link, out *OutBuf, addr int64, size int64)</code></pre>
         </article>
         
         <article class="function" data-name="pdatablk">
            <h2>pdatablk</h2>
            <hr />
            
            <pre><code>func pdatablk(ctxt *Link, out *OutBuf, addr int64, size int64)</code></pre>
         </article>
         
         <article class="function" data-name="xdatablk">
            <h2>xdatablk</h2>
            <hr />
            
            <pre><code>func xdatablk(ctxt *Link, out *OutBuf, addr int64, size int64)</code></pre>
         </article>
         
         <article class="function" data-name="addstrdata1">
            <h2>addstrdata1</h2>
            <hr />
            
            <pre><code>func addstrdata1(ctxt *Link, arg string)</code></pre>
         </article>
         
         <article class="function" data-name="addstrdata">
            <h2>addstrdata</h2>
            <hr />
            
            <p>addstrdata sets the initial value of the string variable name to value.</p>
            
            <pre><code>func addstrdata(arch *sys.Arch, l *loader.Loader, name string, value string)</code></pre>
         </article>
         
         <article class="function" data-name="dostrdata">
            <h2>dostrdata</h2>
            <hr />
            
            <pre><code>func dostrdata()</code></pre>
         </article>
         
         <article class="function" data-name="addgostring">
            <h2>addgostring</h2>
            <hr />
            
            <p>addgostring adds str, as a Go string value, to s. symname is the name of the
symbol used to define the string data and must be unique per linked object.</p>
            
            <pre><code>func addgostring(ctxt *Link, ldr *loader.Loader, s *loader.SymbolBuilder, symname string, str string)</code></pre>
         </article>
         
         <article class="function" data-name="addinitarrdata">
            <h2>addinitarrdata</h2>
            <hr />
            
            <pre><code>func addinitarrdata(ctxt *Link, ldr *loader.Loader, s loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="symalign">
            <h2>symalign</h2>
            <hr />
            
            <p>symalign returns the required alignment for the given symbol s.</p>
            
            <pre><code>func symalign(ldr *loader.Loader, s loader.Sym) int32</code></pre>
         </article>
         
         <article class="function" data-name="aligndatsize">
            <h2>aligndatsize</h2>
            <hr />
            
            <pre><code>func aligndatsize(state *dodataState, datsize int64, s loader.Sym) int64</code></pre>
         </article>
         
         <article class="function" data-name="Init">
            <h2>Init</h2>
            <hr />
            
            <pre><code>func Init(ctxt *Link, name string)</code></pre>
         </article>
         
         <article class="function" data-name="writeByte">
            <h2>writeByte</h2>
            <hr />
            
            <pre><code>func writeByte() func</code></pre>
         </article>
         
         <article class="function" data-name="End">
            <h2>End</h2>
            <hr />
            
            <pre><code>func End(size int64)</code></pre>
         </article>
         
         <article class="function" data-name="AddSym">
            <h2>AddSym</h2>
            <hr />
            
            <pre><code>func AddSym(s loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="AddType">
            <h2>AddType</h2>
            <hr />
            
            <p>Add to the gc program the ptr bits for the type typ at
byte offset off in the region being described.
The type must have a pointer in it.</p>
            
            <pre><code>func AddType(off int64, typ loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="checkdatsize">
            <h2>checkdatsize</h2>
            <hr />
            
            <p>check accumulated size of data sections</p>
            
            <pre><code>func checkdatsize(symn sym.SymKind)</code></pre>
         </article>
         
         <article class="function" data-name="checkSectSize">
            <h2>checkSectSize</h2>
            <hr />
            
            <pre><code>func checkSectSize(sect *sym.Section)</code></pre>
         </article>
         
         <article class="function" data-name="fixZeroSizedSymbols">
            <h2>fixZeroSizedSymbols</h2>
            <hr />
            
            <p>fixZeroSizedSymbols gives a few special symbols with zero size some space.</p>
            
            <pre><code>func fixZeroSizedSymbols(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="makeRelroForSharedLib">
            <h2>makeRelroForSharedLib</h2>
            <hr />
            
            <p>makeRelroForSharedLib creates a section of readonly data if necessary.</p>
            
            <pre><code>func makeRelroForSharedLib(target *Link)</code></pre>
         </article>
         
         <article class="function" data-name="symType">
            <h2>symType</h2>
            <hr />
            
            <p>symType returns the (possibly overridden) type of 's'.</p>
            
            <pre><code>func symType(s loader.Sym) sym.SymKind</code></pre>
         </article>
         
         <article class="function" data-name="setSymType">
            <h2>setSymType</h2>
            <hr />
            
            <p>setSymType sets a new override type for 's'.</p>
            
            <pre><code>func setSymType(s loader.Sym, kind sym.SymKind)</code></pre>
         </article>
         
         <article class="function" data-name="dodata">
            <h2>dodata</h2>
            <hr />
            
            <pre><code>func dodata(symGroupType []sym.SymKind)</code></pre>
         </article>
         
         <article class="function" data-name="allocateDataSectionForSym">
            <h2>allocateDataSectionForSym</h2>
            <hr />
            
            <p>allocateDataSectionForSym creates a new sym.Section into which a
single symbol will be placed. Here "seg" is the segment into which
the section will go, "s" is the symbol to be placed into the new
section, and "rwx" contains permissions for the section.</p>
            
            <pre><code>func allocateDataSectionForSym(seg *sym.Segment, s loader.Sym, rwx int) *sym.Section</code></pre>
         </article>
         
         <article class="function" data-name="allocateNamedDataSection">
            <h2>allocateNamedDataSection</h2>
            <hr />
            
            <p>allocateNamedDataSection creates a new sym.Section for a category
of data symbols. Here "seg" is the segment into which the section
will go, "sName" is the name to give to the section, "types" is a
range of symbol types to be put into the section, and "rwx"
contains permissions for the section.</p>
            
            <pre><code>func allocateNamedDataSection(seg *sym.Segment, sName string, types []sym.SymKind, rwx int) *sym.Section</code></pre>
         </article>
         
         <article class="function" data-name="assignDsymsToSection">
            <h2>assignDsymsToSection</h2>
            <hr />
            
            <p>assignDsymsToSection assigns a collection of data symbols to a
newly created section. "sect" is the section into which to place
the symbols, "syms" holds the list of symbols to assign,
"forceType" (if non-zero) contains a new sym type to apply to each
sym during the assignment, and "aligner" is a hook to call to
handle alignment during the assignment process.</p>
            
            <pre><code>func assignDsymsToSection(sect *sym.Section, syms []loader.Sym, forceType sym.SymKind, aligner func)</code></pre>
         </article>
         
         <article class="function" data-name="assignToSection">
            <h2>assignToSection</h2>
            <hr />
            
            <pre><code>func assignToSection(sect *sym.Section, symn sym.SymKind, forceType sym.SymKind)</code></pre>
         </article>
         
         <article class="function" data-name="allocateSingleSymSections">
            <h2>allocateSingleSymSections</h2>
            <hr />
            
            <p>allocateSingleSymSections walks through the bucketed data symbols
with type 'symn', creates a new section for each sym, and assigns
the sym to a newly created section. Section name is set from the
symbol name. "Seg" is the segment into which to place the new
section, "forceType" is the new sym.SymKind to assign to the symbol
within the section, and "rwx" holds section permissions.</p>
            
            <pre><code>func allocateSingleSymSections(seg *sym.Segment, symn sym.SymKind, forceType sym.SymKind, rwx int)</code></pre>
         </article>
         
         <article class="function" data-name="allocateNamedSectionAndAssignSyms">
            <h2>allocateNamedSectionAndAssignSyms</h2>
            <hr />
            
            <p>allocateNamedSectionAndAssignSyms creates a new section with the
specified name, then walks through the bucketed data symbols with
type 'symn' and assigns each of them to this new section. "Seg" is
the segment into which to place the new section, "secName" is the
name to give to the new section, "forceType" (if non-zero) contains
a new sym type to apply to each sym during the assignment, and
"rwx" holds section permissions.</p>
            
            <pre><code>func allocateNamedSectionAndAssignSyms(seg *sym.Segment, secName string, symn sym.SymKind, forceType sym.SymKind, rwx int) *sym.Section</code></pre>
         </article>
         
         <article class="function" data-name="allocateDataSections">
            <h2>allocateDataSections</h2>
            <hr />
            
            <p>allocateDataSections allocates sym.Section objects for data/rodata
(and related) symbols, and then assigns symbols to those sections.</p>
            
            <pre><code>func allocateDataSections(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="allocateDwarfSections">
            <h2>allocateDwarfSections</h2>
            <hr />
            
            <p>allocateDwarfSections allocates sym.Section objects for DWARF
symbols, and assigns symbols to sections.</p>
            
            <pre><code>func allocateDwarfSections(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="allocateSEHSections">
            <h2>allocateSEHSections</h2>
            <hr />
            
            <p>allocateSEHSections allocate a sym.Section object for SEH
symbols, and assigns symbols to sections.</p>
            
            <pre><code>func allocateSEHSections(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="dodataSect">
            <h2>dodataSect</h2>
            <hr />
            
            <pre><code>func dodataSect(ctxt *Link, symn sym.SymKind, syms []loader.Sym) (result []loader.Sym, maxAlign int32)</code></pre>
         </article>
         
         <article class="function" data-name="textbuildid">
            <h2>textbuildid</h2>
            <hr />
            
            <p>Add buildid to beginning of text segment, on non-ELF systems.
Non-ELF binary formats are not always flexible enough to
give us a place to put the Go build ID. On those systems, we put it
at the very beginning of the text segment.
This “header” is read by cmd/go.</p>
            
            <pre><code>func textbuildid()</code></pre>
         </article>
         
         <article class="function" data-name="buildinfo">
            <h2>buildinfo</h2>
            <hr />
            
            <pre><code>func buildinfo()</code></pre>
         </article>
         
         <article class="function" data-name="appendString">
            <h2>appendString</h2>
            <hr />
            
            <p>appendString appends s to data, prefixed by its varint-encoded length.</p>
            
            <pre><code>func appendString(data []byte, s string) []byte</code></pre>
         </article>
         
         <article class="function" data-name="textaddress">
            <h2>textaddress</h2>
            <hr />
            
            <p>assign addresses to text</p>
            
            <pre><code>func textaddress()</code></pre>
         </article>
         
         <article class="function" data-name="assignAddress">
            <h2>assignAddress</h2>
            <hr />
            
            <p>assigns address for a text symbol, returns (possibly new) section, its number, and the address.</p>
            
            <pre><code>func assignAddress(ctxt *Link, sect *sym.Section, n int, s loader.Sym, va uint64, isTramp bool, big bool) (*sym.Section, int, uint64)</code></pre>
         </article>
         
         <article class="function" data-name="resetAddress">
            <h2>resetAddress</h2>
            <hr />
            
            <pre><code>func resetAddress(ctxt *Link, s loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="splitTextSections">
            <h2>splitTextSections</h2>
            <hr />
            
            <p>Return whether we may need to split text sections.

On PPC64x, when external linking, a text section should not be
larger than 2^25 bytes due to the size of call target offset field
in the 'bl' instruction. Splitting into smaller text sections
smaller than this limit allows the system linker to modify the long
calls appropriately. The limit allows for the space needed for
tables inserted by the linker.

The same applies to Darwin/ARM64, with 2^27 byte threshold.

Similarly for ARM, we split sections (at 2^25 bytes) to avoid
inconsistencies between the Go linker's reachability calculations
(e.g. will direct call from X to Y need a trampoline) and similar
machinery in the external linker; see #58425 for more on the
history here.</p>
            
            <pre><code>func splitTextSections(ctxt *Link) bool</code></pre>
         </article>
         
         <article class="function" data-name="address">
            <h2>address</h2>
            <hr />
            
            <p>address assigns virtual addresses to all segments and sections and
returns all segments in file order.</p>
            
            <pre><code>func address() []*sym.Segment</code></pre>
         </article>
         
         <article class="function" data-name="layout">
            <h2>layout</h2>
            <hr />
            
            <p>layout assigns file offsets and lengths to the segments in order.
Returns the file size containing all the segments.</p>
            
            <pre><code>func layout(order []*sym.Segment) uint64</code></pre>
         </article>
         
         <article class="function" data-name="AddTramp">
            <h2>AddTramp</h2>
            <hr />
            
            <p>add a trampoline with symbol s (to be laid down after the current function)</p>
            
            <pre><code>func AddTramp(s *loader.SymbolBuilder, typ sym.SymKind)</code></pre>
         </article>
         
         <article class="function" data-name="compressSyms">
            <h2>compressSyms</h2>
            <hr />
            
            <p>compressSyms compresses syms and returns the contents of the
compressed section. If the section would get larger, it returns nil.</p>
            
            <pre><code>func compressSyms(ctxt *Link, syms []loader.Sym) []byte</code></pre>
         </article>
         
         <article class="function" data-name="PtrSize">
            <h2>PtrSize</h2>
            <hr />
            
            <pre><code>func PtrSize() int</code></pre>
         </article>
         
         <article class="function" data-name="Size">
            <h2>Size</h2>
            <hr />
            
            <pre><code>func Size(s dwarf.Sym) int64</code></pre>
         </article>
         
         <article class="function" data-name="AddInt">
            <h2>AddInt</h2>
            <hr />
            
            <pre><code>func AddInt(s dwarf.Sym, size int, i int64)</code></pre>
         </article>
         
         <article class="function" data-name="AddBytes">
            <h2>AddBytes</h2>
            <hr />
            
            <pre><code>func AddBytes(s dwarf.Sym, b []byte)</code></pre>
         </article>
         
         <article class="function" data-name="AddString">
            <h2>AddString</h2>
            <hr />
            
            <pre><code>func AddString(s dwarf.Sym, v string)</code></pre>
         </article>
         
         <article class="function" data-name="AddAddress">
            <h2>AddAddress</h2>
            <hr />
            
            <pre><code>func AddAddress(s dwarf.Sym, data *ast.InterfaceType, value int64)</code></pre>
         </article>
         
         <article class="function" data-name="AddCURelativeAddress">
            <h2>AddCURelativeAddress</h2>
            <hr />
            
            <pre><code>func AddCURelativeAddress(s dwarf.Sym, data *ast.InterfaceType, value int64)</code></pre>
         </article>
         
         <article class="function" data-name="AddSectionOffset">
            <h2>AddSectionOffset</h2>
            <hr />
            
            <pre><code>func AddSectionOffset(s dwarf.Sym, size int, t *ast.InterfaceType, ofs int64)</code></pre>
         </article>
         
         <article class="function" data-name="AddDWARFAddrSectionOffset">
            <h2>AddDWARFAddrSectionOffset</h2>
            <hr />
            
            <pre><code>func AddDWARFAddrSectionOffset(s dwarf.Sym, t *ast.InterfaceType, ofs int64)</code></pre>
         </article>
         
         <article class="function" data-name="Logf">
            <h2>Logf</h2>
            <hr />
            
            <pre><code>func Logf(format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="CurrentOffset">
            <h2>CurrentOffset</h2>
            <hr />
            
            <pre><code>func CurrentOffset(s dwarf.Sym) int64</code></pre>
         </article>
         
         <article class="function" data-name="RecordDclReference">
            <h2>RecordDclReference</h2>
            <hr />
            
            <pre><code>func RecordDclReference(s dwarf.Sym, t dwarf.Sym, dclIdx int, inlIndex int)</code></pre>
         </article>
         
         <article class="function" data-name="RecordChildDieOffsets">
            <h2>RecordChildDieOffsets</h2>
            <hr />
            
            <pre><code>func RecordChildDieOffsets(s dwarf.Sym, vars []*dwarf.Var, offsets []int32)</code></pre>
         </article>
         
         <article class="function" data-name="isDwarf64">
            <h2>isDwarf64</h2>
            <hr />
            
            <pre><code>func isDwarf64(ctxt *Link) bool</code></pre>
         </article>
         
         <article class="function" data-name="secSym">
            <h2>secSym</h2>
            <hr />
            
            <p>secSym returns the section symbol for the section.</p>
            
            <pre><code>func secSym() loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="subSyms">
            <h2>subSyms</h2>
            <hr />
            
            <p>subSyms returns a list of sub-symbols for the section.</p>
            
            <pre><code>func subSyms() []loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="writeabbrev">
            <h2>writeabbrev</h2>
            <hr />
            
            <pre><code>func writeabbrev() dwarfSecInfo</code></pre>
         </article>
         
         <article class="function" data-name="newattr">
            <h2>newattr</h2>
            <hr />
            
            <p>newattr attaches a new attribute to the specified DIE.

FIXME: at the moment attributes are stored in a linked list in a
fairly space-inefficient way -- it might be better to instead look
up all attrs in a single large table, then store indices into the
table in the DIE. This would allow us to common up storage for
attributes that are shared by many DIEs (ex: byte size of N).</p>
            
            <pre><code>func newattr(die *dwarf.DWDie, attr uint16, cls int, value int64, data *ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="getattr">
            <h2>getattr</h2>
            <hr />
            
            <p>Each DIE (except the root ones) has at least 1 attribute: its
name. getattr moves the desired one to the front so
frequently searched ones are found faster.</p>
            
            <pre><code>func getattr(die *dwarf.DWDie, attr uint16) *dwarf.DWAttr</code></pre>
         </article>
         
         <article class="function" data-name="newdie">
            <h2>newdie</h2>
            <hr />
            
            <p>Every DIE manufactured by the linker has at least an AT_name
attribute (but it will only be written out if it is listed in the abbrev).
The compiler does create nameless DWARF DIEs (ex: concrete subprogram
instance).
FIXME: it would be more efficient to bulk-allocate DIEs.</p>
            
            <pre><code>func newdie(parent *dwarf.DWDie, abbrev int, name string) *dwarf.DWDie</code></pre>
         </article>
         
         <article class="function" data-name="walktypedef">
            <h2>walktypedef</h2>
            <hr />
            
            <pre><code>func walktypedef(die *dwarf.DWDie) *dwarf.DWDie</code></pre>
         </article>
         
         <article class="function" data-name="walksymtypedef">
            <h2>walksymtypedef</h2>
            <hr />
            
            <pre><code>func walksymtypedef(symIdx loader.Sym) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="findchild">
            <h2>findchild</h2>
            <hr />
            
            <p>Find child by AT_name using hashtable if available or linear scan
if not.</p>
            
            <pre><code>func findchild(die *dwarf.DWDie, name string) *dwarf.DWDie</code></pre>
         </article>
         
         <article class="function" data-name="find">
            <h2>find</h2>
            <hr />
            
            <p>find looks up the loader symbol for the DWARF DIE generated for the
type with the specified name.</p>
            
            <pre><code>func find(name string) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="mustFind">
            <h2>mustFind</h2>
            <hr />
            
            <pre><code>func mustFind(name string) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="adddwarfref">
            <h2>adddwarfref</h2>
            <hr />
            
            <pre><code>func adddwarfref(sb *loader.SymbolBuilder, t loader.Sym, size int)</code></pre>
         </article>
         
         <article class="function" data-name="newrefattr">
            <h2>newrefattr</h2>
            <hr />
            
            <pre><code>func newrefattr(die *dwarf.DWDie, attr uint16, ref loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="dtolsym">
            <h2>dtolsym</h2>
            <hr />
            
            <pre><code>func dtolsym(s dwarf.Sym) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="putdie">
            <h2>putdie</h2>
            <hr />
            
            <pre><code>func putdie(syms []loader.Sym, die *dwarf.DWDie) []loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="reverselist">
            <h2>reverselist</h2>
            <hr />
            
            <pre><code>func reverselist(list **dwarf.DWDie)</code></pre>
         </article>
         
         <article class="function" data-name="reversetree">
            <h2>reversetree</h2>
            <hr />
            
            <pre><code>func reversetree(list **dwarf.DWDie)</code></pre>
         </article>
         
         <article class="function" data-name="newmemberoffsetattr">
            <h2>newmemberoffsetattr</h2>
            <hr />
            
            <pre><code>func newmemberoffsetattr(die *dwarf.DWDie, offs int32)</code></pre>
         </article>
         
         <article class="function" data-name="lookupOrDiag">
            <h2>lookupOrDiag</h2>
            <hr />
            
            <pre><code>func lookupOrDiag(n string) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="dotypedef">
            <h2>dotypedef</h2>
            <hr />
            
            <pre><code>func dotypedef(parent *dwarf.DWDie, name string, def *dwarf.DWDie) *dwarf.DWDie</code></pre>
         </article>
         
         <article class="function" data-name="defgotype">
            <h2>defgotype</h2>
            <hr />
            
            <p>Define gotype, for composite ones recurse into constituents.</p>
            
            <pre><code>func defgotype(gotype loader.Sym) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="newtype">
            <h2>newtype</h2>
            <hr />
            
            <pre><code>func newtype(gotype loader.Sym) *dwarf.DWDie</code></pre>
         </article>
         
         <article class="function" data-name="nameFromDIESym">
            <h2>nameFromDIESym</h2>
            <hr />
            
            <pre><code>func nameFromDIESym(dwtypeDIESym loader.Sym) string</code></pre>
         </article>
         
         <article class="function" data-name="defptrto">
            <h2>defptrto</h2>
            <hr />
            
            <pre><code>func defptrto(dwtype loader.Sym) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="copychildrenexcept">
            <h2>copychildrenexcept</h2>
            <hr />
            
            <p>Copies src's children into dst. Copies attributes by value.
DWAttr.data is copied as pointer only. If except is one of
the top-level children, it will not be copied.</p>
            
            <pre><code>func copychildrenexcept(ctxt *Link, dst *dwarf.DWDie, src *dwarf.DWDie, except *dwarf.DWDie)</code></pre>
         </article>
         
         <article class="function" data-name="copychildren">
            <h2>copychildren</h2>
            <hr />
            
            <pre><code>func copychildren(ctxt *Link, dst *dwarf.DWDie, src *dwarf.DWDie)</code></pre>
         </article>
         
         <article class="function" data-name="substitutetype">
            <h2>substitutetype</h2>
            <hr />
            
            <p>Search children (assumed to have TAG_member) for the one named
field and set its AT_type to dwtype</p>
            
            <pre><code>func substitutetype(structdie *dwarf.DWDie, field string, dwtype loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="findprotodie">
            <h2>findprotodie</h2>
            <hr />
            
            <pre><code>func findprotodie(ctxt *Link, name string) *dwarf.DWDie</code></pre>
         </article>
         
         <article class="function" data-name="synthesizestringtypes">
            <h2>synthesizestringtypes</h2>
            <hr />
            
            <pre><code>func synthesizestringtypes(ctxt *Link, die *dwarf.DWDie)</code></pre>
         </article>
         
         <article class="function" data-name="synthesizeslicetypes">
            <h2>synthesizeslicetypes</h2>
            <hr />
            
            <pre><code>func synthesizeslicetypes(ctxt *Link, die *dwarf.DWDie)</code></pre>
         </article>
         
         <article class="function" data-name="mkinternaltypename">
            <h2>mkinternaltypename</h2>
            <hr />
            
            <pre><code>func mkinternaltypename(base string, arg1 string, arg2 string) string</code></pre>
         </article>
         
         <article class="function" data-name="mkinternaltype">
            <h2>mkinternaltype</h2>
            <hr />
            
            <pre><code>func mkinternaltype(ctxt *Link, abbrev int, typename string, keyname string, valname string, f func) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="synthesizemaptypes">
            <h2>synthesizemaptypes</h2>
            <hr />
            
            <pre><code>func synthesizemaptypes(ctxt *Link, die *dwarf.DWDie)</code></pre>
         </article>
         
         <article class="function" data-name="synthesizemaptypesSwiss">
            <h2>synthesizemaptypesSwiss</h2>
            <hr />
            
            <pre><code>func synthesizemaptypesSwiss(ctxt *Link, die *dwarf.DWDie)</code></pre>
         </article>
         
         <article class="function" data-name="synthesizemaptypesOld">
            <h2>synthesizemaptypesOld</h2>
            <hr />
            
            <pre><code>func synthesizemaptypesOld(ctxt *Link, die *dwarf.DWDie)</code></pre>
         </article>
         
         <article class="function" data-name="synthesizechantypes">
            <h2>synthesizechantypes</h2>
            <hr />
            
            <pre><code>func synthesizechantypes(ctxt *Link, die *dwarf.DWDie)</code></pre>
         </article>
         
         <article class="function" data-name="createUnitLength">
            <h2>createUnitLength</h2>
            <hr />
            
            <p>createUnitLength creates the initial length field with value v and update
offset of unit_length if needed.</p>
            
            <pre><code>func createUnitLength(su *loader.SymbolBuilder, v uint64)</code></pre>
         </article>
         
         <article class="function" data-name="addDwarfAddrField">
            <h2>addDwarfAddrField</h2>
            <hr />
            
            <p>addDwarfAddrField adds a DWARF field in DWARF 64bits or 32bits.</p>
            
            <pre><code>func addDwarfAddrField(sb *loader.SymbolBuilder, v uint64)</code></pre>
         </article>
         
         <article class="function" data-name="addDwarfAddrRef">
            <h2>addDwarfAddrRef</h2>
            <hr />
            
            <p>addDwarfAddrRef adds a DWARF pointer in DWARF 64bits or 32bits.</p>
            
            <pre><code>func addDwarfAddrRef(sb *loader.SymbolBuilder, t loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="calcCompUnitRanges">
            <h2>calcCompUnitRanges</h2>
            <hr />
            
            <p>calcCompUnitRanges calculates the PC ranges of the compilation units.</p>
            
            <pre><code>func calcCompUnitRanges()</code></pre>
         </article>
         
         <article class="function" data-name="movetomodule">
            <h2>movetomodule</h2>
            <hr />
            
            <pre><code>func movetomodule(ctxt *Link, parent *dwarf.DWDie)</code></pre>
         </article>
         
         <article class="function" data-name="getCompilationDir">
            <h2>getCompilationDir</h2>
            <hr />
            
            <pre><code>func getCompilationDir() string</code></pre>
         </article>
         
         <article class="function" data-name="importInfoSymbol">
            <h2>importInfoSymbol</h2>
            <hr />
            
            <pre><code>func importInfoSymbol(dsym loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="expandFile">
            <h2>expandFile</h2>
            <hr />
            
            <pre><code>func expandFile(fname string) string</code></pre>
         </article>
         
         <article class="function" data-name="writeDirFileTables">
            <h2>writeDirFileTables</h2>
            <hr />
            
            <p>writeDirFileTables emits the portion of the DWARF line table
prologue containing the include directories and file names,
described in section 6.2.4 of the DWARF 4 standard. It walks the
filepaths for the unit to discover any common directories, which
are emitted to the directory table first, then the file table is
emitted after that.</p>
            
            <pre><code>func writeDirFileTables(unit *sym.CompilationUnit, lsu *loader.SymbolBuilder)</code></pre>
         </article>
         
         <article class="function" data-name="writelines">
            <h2>writelines</h2>
            <hr />
            
            <p>writelines collects up and chains together the symbols needed to
form the DWARF line table for the specified compilation unit,
returning a list of symbols. The returned list will include an
initial symbol containing the line table header and prologue (with
file table), then a series of compiler-emitted line table symbols
(one per live function), and finally an epilog symbol containing an
end-of-sequence operator. The prologue and epilog symbols are passed
in (having been created earlier); here we add content to them.</p>
            
            <pre><code>func writelines(unit *sym.CompilationUnit, lineProlog loader.Sym) []loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="writepcranges">
            <h2>writepcranges</h2>
            <hr />
            
            <p>writepcranges generates the DW_AT_ranges table for compilation unit
"unit", and returns a collection of ranges symbols (one for the
compilation unit DIE itself and the remainder from functions in the unit).</p>
            
            <pre><code>func writepcranges(unit *sym.CompilationUnit, base loader.Sym, pcs []dwarf.Range, rangeProlog loader.Sym) []loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="appendPCDeltaCFA">
            <h2>appendPCDeltaCFA</h2>
            <hr />
            
            <p>appendPCDeltaCFA appends per-PC CFA deltas to b and returns the final slice.</p>
            
            <pre><code>func appendPCDeltaCFA(arch *sys.Arch, b []byte, deltapc int64, cfa int64) []byte</code></pre>
         </article>
         
         <article class="function" data-name="writeframes">
            <h2>writeframes</h2>
            <hr />
            
            <pre><code>func writeframes(fs loader.Sym) dwarfSecInfo</code></pre>
         </article>
         
         <article class="function" data-name="writeUnitInfo">
            <h2>writeUnitInfo</h2>
            <hr />
            
            <pre><code>func writeUnitInfo(u *sym.CompilationUnit, abbrevsym loader.Sym, infoEpilog loader.Sym) []loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="writegdbscript">
            <h2>writegdbscript</h2>
            <hr />
            
            <pre><code>func writegdbscript() dwarfSecInfo</code></pre>
         </article>
         
         <article class="function" data-name="dwarfEnabled">
            <h2>dwarfEnabled</h2>
            <hr />
            
            <pre><code>func dwarfEnabled(ctxt *Link) bool</code></pre>
         </article>
         
         <article class="function" data-name="mkBuiltinType">
            <h2>mkBuiltinType</h2>
            <hr />
            
            <p>mkBuiltinType populates the dwctxt2 sym lookup maps for the
newly created builtin type DIE 'typeDie'.</p>
            
            <pre><code>func mkBuiltinType(ctxt *Link, abrv int, tname string) *dwarf.DWDie</code></pre>
         </article>
         
         <article class="function" data-name="dwarfVisitFunction">
            <h2>dwarfVisitFunction</h2>
            <hr />
            
            <p>dwarfVisitFunction takes a function (text) symbol and processes the
subprogram DIE for the function and picks up any other DIEs
(absfns, types) that it references.</p>
            
            <pre><code>func dwarfVisitFunction(fnSym loader.Sym, unit *sym.CompilationUnit)</code></pre>
         </article>
         
         <article class="function" data-name="dwarfGenerateDebugInfo">
            <h2>dwarfGenerateDebugInfo</h2>
            <hr />
            
            <p>dwarfGenerateDebugInfo generated debug info entries for all types,
variables and functions in the program.
Along with dwarfGenerateDebugSyms they are the two main entry points into
dwarf generation: dwarfGenerateDebugInfo does all the work that should be
done before symbol names are mangled while dwarfGenerateDebugSyms does
all the work that can only be done after addresses have been assigned to
text symbols.</p>
            
            <pre><code>func dwarfGenerateDebugInfo(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="dwarfGenerateDebugSyms">
            <h2>dwarfGenerateDebugSyms</h2>
            <hr />
            
            <p>dwarfGenerateDebugSyms constructs debug_line, debug_frame, and
debug_loc. It also writes out the debug_info section using symbols
generated in dwarfGenerateDebugInfo2.</p>
            
            <pre><code>func dwarfGenerateDebugSyms(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="dwUnitPortion">
            <h2>dwUnitPortion</h2>
            <hr />
            
            <p>dwUnitPortion assembles the DWARF content for a given compilation
unit: debug_info, debug_lines, debug_ranges, debug_loc (debug_frame
is handled elsewhere). Order is important; the calls to writelines
and writepcranges below make updates to the compilation unit DIE,
hence they have to happen before the call to writeUnitInfo.</p>
            
            <pre><code>func dwUnitPortion(u *sym.CompilationUnit, abbrevsym loader.Sym, us *dwUnitSyms)</code></pre>
         </article>
         
         <article class="function" data-name="dwarfGenerateDebugSyms">
            <h2>dwarfGenerateDebugSyms</h2>
            <hr />
            
            <pre><code>func dwarfGenerateDebugSyms()</code></pre>
         </article>
         
         <article class="function" data-name="collectUnitLocs">
            <h2>collectUnitLocs</h2>
            <hr />
            
            <pre><code>func collectUnitLocs(u *sym.CompilationUnit) []loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="dwarfaddshstrings">
            <h2>dwarfaddshstrings</h2>
            <hr />
            
            <p>Add DWARF section names to the section header string table, by calling add
on each name. ELF only.</p>
            
            <pre><code>func dwarfaddshstrings(ctxt *Link, add func)</code></pre>
         </article>
         
         <article class="function" data-name="dwarfaddelfsectionsyms">
            <h2>dwarfaddelfsectionsyms</h2>
            <hr />
            
            <pre><code>func dwarfaddelfsectionsyms(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="dwarfcompress">
            <h2>dwarfcompress</h2>
            <hr />
            
            <p>dwarfcompress compresses the DWARF sections. Relocations are applied
on the fly. After this, dwarfp will contain a different (new) set of
symbols, and sections may have been replaced.</p>
            
            <pre><code>func dwarfcompress(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="compilationUnitByStartPCCmp">
            <h2>compilationUnitByStartPCCmp</h2>
            <hr />
            
            <pre><code>func compilationUnitByStartPCCmp(a *sym.CompilationUnit, b *sym.CompilationUnit) int</code></pre>
         </article>
         
         <article class="function" data-name="getPkgFromCUSym">
            <h2>getPkgFromCUSym</h2>
            <hr />
            
            <p>getPkgFromCUSym returns the package name for the compilation unit
represented by s.
The prefix dwarf.InfoPrefix+".pkg." needs to be removed in order to get
the package name.</p>
            
            <pre><code>func getPkgFromCUSym(s loader.Sym) string</code></pre>
         </article>
         
         <article class="function" data-name="getDwsectCUSize">
            <h2>getDwsectCUSize</h2>
            <hr />
            
            <p>getDwsectCUSize retrieves the corresponding package size inside the current section.</p>
            
            <pre><code>func getDwsectCUSize(sname string, pkgname string) uint64</code></pre>
         </article>
         
         <article class="function" data-name="addDwsectCUSize">
            <h2>addDwsectCUSize</h2>
            <hr />
            
            <pre><code>func addDwsectCUSize(sname string, pkgname string, size uint64)</code></pre>
         </article>
         
         <article class="function" data-name="errorUnresolved">
            <h2>errorUnresolved</h2>
            <hr />
            
            <p>errorUnresolved prints unresolved symbol error for rs that is referenced from s.</p>
            
            <pre><code>func errorUnresolved(ldr *loader.Loader, s loader.Sym, rs loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="execArchive">
            <h2>execArchive</h2>
            <hr />
            
            <p>execArchive invokes the archiver tool with syscall.Exec(), with
the expectation that this is the last thing that takes place
in the linking operation.</p>
            
            <pre><code>func execArchive(argv []string)</code></pre>
         </article>
         
         <article class="function" data-name="getMachoHdr">
            <h2>getMachoHdr</h2>
            <hr />
            
            <pre><code>func getMachoHdr() *MachoHdr</code></pre>
         </article>
         
         <article class="function" data-name="newMachoLoad">
            <h2>newMachoLoad</h2>
            <hr />
            
            <p>Create a new Mach-O load command. ndata is the number of 32-bit words for
the data (not including the load command header).</p>
            
            <pre><code>func newMachoLoad(arch *sys.Arch, type_ uint32, ndata uint32) *MachoLoad</code></pre>
         </article>
         
         <article class="function" data-name="newMachoSeg">
            <h2>newMachoSeg</h2>
            <hr />
            
            <pre><code>func newMachoSeg(name string, msect int) *MachoSeg</code></pre>
         </article>
         
         <article class="function" data-name="newMachoSect">
            <h2>newMachoSect</h2>
            <hr />
            
            <pre><code>func newMachoSect(seg *MachoSeg, name string, segname string) *MachoSect</code></pre>
         </article>
         
         <article class="function" data-name="machowrite">
            <h2>machowrite</h2>
            <hr />
            
            <pre><code>func machowrite(ctxt *Link, arch *sys.Arch, out *OutBuf, linkmode LinkMode) int</code></pre>
         </article>
         
         <article class="function" data-name="domacho">
            <h2>domacho</h2>
            <hr />
            
            <pre><code>func domacho()</code></pre>
         </article>
         
         <article class="function" data-name="machoadddynlib">
            <h2>machoadddynlib</h2>
            <hr />
            
            <pre><code>func machoadddynlib(lib string, linkmode LinkMode)</code></pre>
         </article>
         
         <article class="function" data-name="machoshbits">
            <h2>machoshbits</h2>
            <hr />
            
            <pre><code>func machoshbits(ctxt *Link, mseg *MachoSeg, sect *sym.Section, segname string)</code></pre>
         </article>
         
         <article class="function" data-name="asmbMacho">
            <h2>asmbMacho</h2>
            <hr />
            
            <pre><code>func asmbMacho(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="symkind">
            <h2>symkind</h2>
            <hr />
            
            <pre><code>func symkind(ldr *loader.Loader, s loader.Sym) int</code></pre>
         </article>
         
         <article class="function" data-name="collectmachosyms">
            <h2>collectmachosyms</h2>
            <hr />
            
            <pre><code>func collectmachosyms(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="machosymorder">
            <h2>machosymorder</h2>
            <hr />
            
            <pre><code>func machosymorder(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="AddMachoSym">
            <h2>AddMachoSym</h2>
            <hr />
            
            <p>AddMachoSym adds s to Mach-O symbol table, used in GenSymLate.
Currently only used on ARM64 when external linking.</p>
            
            <pre><code>func AddMachoSym(ldr *loader.Loader, s loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="machoShouldExport">
            <h2>machoShouldExport</h2>
            <hr />
            
            <p>machoShouldExport reports whether a symbol needs to be exported.

When dynamically linking, all non-local variables and plugin-exported
symbols need to be exported.</p>
            
            <pre><code>func machoShouldExport(ctxt *Link, ldr *loader.Loader, s loader.Sym) bool</code></pre>
         </article>
         
         <article class="function" data-name="machosymtab">
            <h2>machosymtab</h2>
            <hr />
            
            <pre><code>func machosymtab(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="machodysymtab">
            <h2>machodysymtab</h2>
            <hr />
            
            <pre><code>func machodysymtab(ctxt *Link, base int64)</code></pre>
         </article>
         
         <article class="function" data-name="doMachoLink">
            <h2>doMachoLink</h2>
            <hr />
            
            <pre><code>func doMachoLink(ctxt *Link) int64</code></pre>
         </article>
         
         <article class="function" data-name="machorelocsect">
            <h2>machorelocsect</h2>
            <hr />
            
            <pre><code>func machorelocsect(ctxt *Link, out *OutBuf, sect *sym.Section, syms []loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="machoEmitReloc">
            <h2>machoEmitReloc</h2>
            <hr />
            
            <pre><code>func machoEmitReloc(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="hostobjMachoPlatform">
            <h2>hostobjMachoPlatform</h2>
            <hr />
            
            <p>hostobjMachoPlatform returns the first platform load command found
in the host object, if any.</p>
            
            <pre><code>func hostobjMachoPlatform(h *Hostobj) (*MachoPlatformLoad, error)</code></pre>
         </article>
         
         <article class="function" data-name="peekMachoPlatform">
            <h2>peekMachoPlatform</h2>
            <hr />
            
            <p>peekMachoPlatform returns the first LC_VERSION_MIN_* or LC_BUILD_VERSION
load command found in the Mach-O file, if any.</p>
            
            <pre><code>func peekMachoPlatform(m *macho.File) (*MachoPlatformLoad, error)</code></pre>
         </article>
         
         <article class="function" data-name="MachoAddRebase">
            <h2>MachoAddRebase</h2>
            <hr />
            
            <pre><code>func MachoAddRebase(s loader.Sym, off int64)</code></pre>
         </article>
         
         <article class="function" data-name="MachoAddBind">
            <h2>MachoAddBind</h2>
            <hr />
            
            <pre><code>func MachoAddBind(off int64, targ loader.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="machoDyldInfo">
            <h2>machoDyldInfo</h2>
            <hr />
            
            <p>Generate data for the dynamic linker, used in LC_DYLD_INFO_ONLY load command.
See mach-o/loader.h, struct dyld_info_command, for the encoding.
e.g. https://opensource.apple.com/source/xnu/xnu-6153.81.5/EXTERNAL_HEADERS/mach-o/loader.h</p>
            
            <pre><code>func machoDyldInfo(ctxt *Link)</code></pre>
         </article>
         
         <article class="function" data-name="machoCodeSigSym">
            <h2>machoCodeSigSym</h2>
            <hr />
            
            <p>machoCodeSigSym creates and returns a symbol for code signature.
The symbol context is left as zeros, which will be generated at the end
(as it depends on the rest of the file).</p>
            
            <pre><code>func machoCodeSigSym(ctxt *Link, codeSize int64) loader.Sym</code></pre>
         </article>
         
         <article class="function" data-name="machoCodeSign">
            <h2>machoCodeSign</h2>
            <hr />
            
            <p>machoCodeSign code-signs Mach-O file fname with an ad-hoc signature.
This is used for updating an external linker generated binary.</p>
            
            <pre><code>func machoCodeSign(ctxt *Link, fname string) error</code></pre>
         </article>
         
         <article class="function" data-name="uuidFromGoBuildId">
            <h2>uuidFromGoBuildId</h2>
            <hr />
            
            <p>uuidFromGoBuildId hashes the Go build ID and returns a slice of 16
bytes suitable for use as the payload in a Macho LC_UUID load
command.</p>
            
            <pre><code>func uuidFromGoBuildId(buildID string) []byte</code></pre>
         </article>
         
         <article class="function" data-name="machoRewriteUuid">
            <h2>machoRewriteUuid</h2>
            <hr />
            
            <p>machoRewriteUuid copies over the contents of the Macho executable
exef into the output file outexe, and in the process updates the
LC_UUID command to a new value recomputed from the Go build id.</p>
            
            <pre><code>func machoRewriteUuid(ctxt *Link, exef *os.File, exem *macho.File, outexe string) error</code></pre>
         </article>
         
         <article class="function" data-name="msync">
            <h2>msync</h2>
            <hr />
            
            <pre><code>func msync(b []byte, flags int) err error</code></pre>
         </article>
         
         <article class="function" data-name="TestNooptCgoBuild">
            <h2>TestNooptCgoBuild</h2>
            <hr />
            
            <pre><code>func TestNooptCgoBuild(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="machoCombineDwarf">
            <h2>machoCombineDwarf</h2>
            <hr />
            
            <p>machoCombineDwarf merges dwarf info generated by dsymutil into a macho executable.

With internal linking, DWARF is embedded into the executable, this lets us do the
same for external linking.
exef is the file of the executable with no DWARF. It must have enough room in the macho
header to add the DWARF sections. (Use ld's -headerpad option)
exem is the macho representation of exef.
dsym is the path to the macho file containing DWARF from dsymutil.
outexe is the path where the combined executable should be saved.</p>
            
            <pre><code>func machoCombineDwarf(ctxt *Link, exef *os.File, exem *macho.File, dsym string, outexe string) error</code></pre>
         </article>
         
         <article class="function" data-name="machoCompressSections">
            <h2>machoCompressSections</h2>
            <hr />
            
            <p>machoCompressSections tries to compress the DWARF segments in dwarfm,
returning the updated sections and segment contents, nils if the sections
weren't compressed, or an error if there was a problem reading dwarfm.</p>
            
            <pre><code>func machoCompressSections(ctxt *Link, dwarfm *macho.File) ([]*macho.Section, []byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="machoCompressSection">
            <h2>machoCompressSection</h2>
            <hr />
            
            <p>machoCompressSection compresses secBytes if it results in less data.</p>
            
            <pre><code>func machoCompressSection(sectBytes []byte) (compressed bool, contents []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="machoUpdateSegment">
            <h2>machoUpdateSegment</h2>
            <hr />
            
            <p>machoUpdateSegment updates the load command for a moved segment.
Only the linkedit segment should move, and it should have 0 sections.</p>
            
            <pre><code>func machoUpdateSegment(r imacho.LoadCmdUpdater, linkseg *macho.Segment, linkoffset uint64) error</code></pre>
         </article>
         
         <article class="function" data-name="machoUpdateSections">
            <h2>machoUpdateSections</h2>
            <hr />
            
            <pre><code>func machoUpdateSections(r imacho.LoadCmdUpdater, seg *macho.Segment64, deltaOffset uint64, compressedSects []*macho.Section) error</code></pre>
         </article>
         
         <article class="function" data-name="machoUpdateDwarfHeader">
            <h2>machoUpdateDwarfHeader</h2>
            <hr />
            
            <p>machoUpdateDwarfHeader updates the DWARF segment load command.</p>
            
            <pre><code>func machoUpdateDwarfHeader(r *imacho.LoadCmdUpdater, compressedSects []*macho.Section, dwarfsize uint64, dwarfstart int64, realdwarf *macho.Segment) error</code></pre>
         </article>
         
         <article class="function" data-name="machoUpdateLoadCommand">
            <h2>machoUpdateLoadCommand</h2>
            <hr />
            
            <pre><code>func machoUpdateLoadCommand(r imacho.LoadCmdUpdater, linkseg *macho.Segment, linkoffset uint64, cmd *ast.InterfaceType, fields ...string) error</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
