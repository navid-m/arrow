<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - ld</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>ld</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"cmd/internal/sys"
"cmd/link/internal/loader"
"encoding/binary"
"errors"
"log"
"os"
"cmd/internal/objabi"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"slices"
"strings"
"fmt"
"internal/buildcfg"
"internal/platform"
"bufio"
"bytes"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"crypto/hmac"
"crypto/sha256"
"debug/elf"
"debug/macho"
"debug/pe"
"encoding/binary"
"fmt"
"hash"
"io"
"os"
"cmd/internal/objabi"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"fmt"
"sort"
"internal/unsafeheader"
"syscall"
"unsafe"
"cmd/internal/sys"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/link/internal/loader"
"fmt"
"internal/buildcfg"
"sort"
"strings"
"cmd/link/internal/loader"
"encoding/binary"
"fmt"
"os"
"cmd/internal/hash"
"cmd/internal/objabi"
"cmd/internal/sys"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"debug/elf"
"encoding/binary"
"encoding/hex"
"fmt"
"internal/buildcfg"
"os"
"path/filepath"
"runtime"
"slices"
"strings"
"bytes"
"debug/elf"
"debug/macho"
"encoding/base64"
"encoding/binary"
"fmt"
"internal/buildcfg"
"io"
"log"
"os"
"os/exec"
"path/filepath"
"runtime"
"slices"
"sort"
"strings"
"sync"
"time"
"cmd/internal/bio"
"cmd/internal/goobj"
"cmd/internal/hash"
"cmd/internal/objabi"
"cmd/internal/sys"
"cmd/link/internal/loadelf"
"cmd/link/internal/loader"
"cmd/link/internal/loadmacho"
"cmd/link/internal/loadpe"
"cmd/link/internal/loadxcoff"
"cmd/link/internal/sym"
"syscall"
"syscall"
"cmd/internal/goobj"
"cmd/internal/objabi"
"cmd/internal/sys"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"fmt"
"internal/abi"
"internal/buildcfg"
"path/filepath"
"strings"
"cmd/internal/objabi"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"fmt"
"runtime"
"sync"
"bytes"
"cmd/internal/gcprog"
"cmd/internal/objabi"
"cmd/internal/sys"
"cmd/link/internal/loader"
"cmd/link/internal/loadpe"
"cmd/link/internal/sym"
"compress/zlib"
"debug/elf"
"encoding/binary"
"fmt"
"internal/abi"
"log"
"math/rand"
"os"
"sort"
"strconv"
"strings"
"sync"
"sync/atomic"
"cmd/internal/goobj"
"cmd/internal/objabi"
"cmd/internal/sys"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"fmt"
"internal/abi"
"internal/buildcfg"
"strings"
"unicode"
"os"
"os/exec"
"path/filepath"
"syscall"
"bufio"
"cmd/internal/objabi"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"debug/elf"
"fmt"
imacho "cmd/internal/macho"
"bytes"
"compress/zlib"
"debug/macho"
"encoding/binary"
"fmt"
"io"
"os"
"reflect"
"unsafe"
"syscall"
"unsafe"
"internal/syscall/unix"
"syscall"
"cmd/internal/dwarf"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
"cmd/internal/sys"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"cmp"
"fmt"
"internal/abi"
"internal/buildcfg"
"log"
"path"
"runtime"
"slices"
"strings"
"sync"
"cmd/internal/hash"
imacho "cmd/internal/macho"
"debug/macho"
"io"
"os"
_ "unsafe"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"debug/elf"
"fmt"
"internal/buildcfg"
"path/filepath"
"strings"
"cmd/internal/bio"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"encoding/binary"
"fmt"
"internal/buildcfg"
"io"
"os"
"path/filepath"
"strings"
"cmd/internal/objabi"
"cmd/internal/sys"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"debug/pe"
"encoding/binary"
"fmt"
"internal/buildcfg"
"math"
"slices"
"sort"
"strconv"
"strings"
"cmd/internal/objabi"
"cmd/internal/sys"
"encoding/binary"
"bytes"
"encoding/binary"
"fmt"
"math/bits"
"os"
"path/filepath"
"sort"
"strings"
"sync"
"cmd/internal/objabi"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"cmd/internal/bio"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/sys"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"debug/elf"
"encoding/json"
"fmt"
"io"
"os"
"sort"
"strconv"
"strings"
"cmd/link/internal/loader"
"cmd/internal/sys"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"debug/elf"
"encoding/binary"
"internal/abi"
"log"
"cmd/internal/objabi"
"cmd/internal/sys"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"internal/buildcfg"
"log"
"runtime"
"cmd/internal/obj"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"sync"
"log"
"os"
"path"
"path/filepath"
"strconv"
"strings"
"cmd/internal/goobj"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"bytes"
"cmd/internal/codesign"
imacho "cmd/internal/macho"
"cmd/internal/objabi"
"cmd/internal/sys"
"cmd/link/internal/loader"
"cmd/link/internal/sym"
"debug/macho"
"encoding/binary"
"fmt"
"internal/buildcfg"
"io"
"os"
"sort"
"strings"
"unsafe"
"bufio"
"cmd/internal/goobj"
"cmd/internal/objabi"
"cmd/internal/quoted"
"cmd/internal/sys"
"cmd/internal/telemetry/counter"
"cmd/link/internal/benchmark"
"flag"
"internal/buildcfg"
"log"
"os"
"runtime"
"runtime/pprof"
"strconv"
"strings"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="AOUTHSZ_EXEC32">
               <h3>
                  AOUTHSZ_EXEC32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Headers size</p>
               
               <pre><code>const AOUTHSZ_EXEC32 = 72</code></pre>
            </article>
            
            <article class="global" data-name="AOUTHSZ_EXEC64">
               <h3>
                  AOUTHSZ_EXEC64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Headers size</p>
               
               <pre><code>const AOUTHSZ_EXEC64 = 120</code></pre>
            </article>
            
            <article class="global" data-name="ARMAG">
               <h3>
                  ARMAG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ARMAG = "!<arch>\n"</code></pre>
            </article>
            
            <article class="global" data-name="ARM_MAGIC_TRAMP_NUMBER">
               <h3>
                  ARM_MAGIC_TRAMP_NUMBER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Relocation types.</p>
               
               <pre><code>const ARM_MAGIC_TRAMP_NUMBER = 0x5c000003</code></pre>
            </article>
            
            <article class="global" data-name="AutoSym">
               <h3>
                  AutoSym 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const AutoSym SymbolType = 'a'</code></pre>
            </article>
            
            <article class="global" data-name="BIND_IMMEDIATE_MASK">
               <h3>
                  BIND_IMMEDIATE_MASK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_IMMEDIATE_MASK = 0x0F</code></pre>
            </article>
            
            <article class="global" data-name="BIND_OPCODE_ADD_ADDR_ULEB">
               <h3>
                  BIND_OPCODE_ADD_ADDR_ULEB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_OPCODE_ADD_ADDR_ULEB = 0x80</code></pre>
            </article>
            
            <article class="global" data-name="BIND_OPCODE_DONE">
               <h3>
                  BIND_OPCODE_DONE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_OPCODE_DONE = 0x00</code></pre>
            </article>
            
            <article class="global" data-name="BIND_OPCODE_DO_BIND">
               <h3>
                  BIND_OPCODE_DO_BIND 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_OPCODE_DO_BIND = 0x90</code></pre>
            </article>
            
            <article class="global" data-name="BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED">
               <h3>
                  BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED = 0xB0</code></pre>
            </article>
            
            <article class="global" data-name="BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB">
               <h3>
                  BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB = 0xA0</code></pre>
            </article>
            
            <article class="global" data-name="BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB">
               <h3>
                  BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB = 0xC0</code></pre>
            </article>
            
            <article class="global" data-name="BIND_OPCODE_MASK">
               <h3>
                  BIND_OPCODE_MASK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_OPCODE_MASK = 0xF0</code></pre>
            </article>
            
            <article class="global" data-name="BIND_OPCODE_SET_ADDEND_SLEB">
               <h3>
                  BIND_OPCODE_SET_ADDEND_SLEB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_OPCODE_SET_ADDEND_SLEB = 0x60</code></pre>
            </article>
            
            <article class="global" data-name="BIND_OPCODE_SET_DYLIB_ORDINAL_IMM">
               <h3>
                  BIND_OPCODE_SET_DYLIB_ORDINAL_IMM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_OPCODE_SET_DYLIB_ORDINAL_IMM = 0x10</code></pre>
            </article>
            
            <article class="global" data-name="BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB">
               <h3>
                  BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB = 0x20</code></pre>
            </article>
            
            <article class="global" data-name="BIND_OPCODE_SET_DYLIB_SPECIAL_IMM">
               <h3>
                  BIND_OPCODE_SET_DYLIB_SPECIAL_IMM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_OPCODE_SET_DYLIB_SPECIAL_IMM = 0x30</code></pre>
            </article>
            
            <article class="global" data-name="BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB">
               <h3>
                  BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB = 0x70</code></pre>
            </article>
            
            <article class="global" data-name="BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM">
               <h3>
                  BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM = 0x40</code></pre>
            </article>
            
            <article class="global" data-name="BIND_OPCODE_SET_TYPE_IMM">
               <h3>
                  BIND_OPCODE_SET_TYPE_IMM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_OPCODE_SET_TYPE_IMM = 0x50</code></pre>
            </article>
            
            <article class="global" data-name="BIND_OPCODE_THREADED">
               <h3>
                  BIND_OPCODE_THREADED 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_OPCODE_THREADED = 0xD0</code></pre>
            </article>
            
            <article class="global" data-name="BIND_SPECIAL_DYLIB_FLAT_LOOKUP">
               <h3>
                  BIND_SPECIAL_DYLIB_FLAT_LOOKUP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_SPECIAL_DYLIB_FLAT_LOOKUP = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE">
               <h3>
                  BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="BIND_SPECIAL_DYLIB_SELF">
               <h3>
                  BIND_SPECIAL_DYLIB_SELF 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_SPECIAL_DYLIB_SELF = 0</code></pre>
            </article>
            
            <article class="global" data-name="BIND_SPECIAL_DYLIB_WEAK_LOOKUP">
               <h3>
                  BIND_SPECIAL_DYLIB_WEAK_LOOKUP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_SPECIAL_DYLIB_WEAK_LOOKUP = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="BIND_SUBOPCODE_THREADED_APPLY">
               <h3>
                  BIND_SUBOPCODE_THREADED_APPLY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_SUBOPCODE_THREADED_APPLY = 0x01</code></pre>
            </article>
            
            <article class="global" data-name="BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB">
               <h3>
                  BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB = 0x00</code></pre>
            </article>
            
            <article class="global" data-name="BIND_TYPE_POINTER">
               <h3>
                  BIND_TYPE_POINTER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_TYPE_POINTER = 1</code></pre>
            </article>
            
            <article class="global" data-name="BIND_TYPE_TEXT_ABSOLUTE32">
               <h3>
                  BIND_TYPE_TEXT_ABSOLUTE32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_TYPE_TEXT_ABSOLUTE32 = 2</code></pre>
            </article>
            
            <article class="global" data-name="BIND_TYPE_TEXT_PCREL32">
               <h3>
                  BIND_TYPE_TEXT_PCREL32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>bind table opcode</p>
               
               <pre><code>const BIND_TYPE_TEXT_PCREL32 = 3</code></pre>
            </article>
            
            <article class="global" data-name="BSSSym">
               <h3>
                  BSSSym 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const BSSSym SymbolType = 'B'</code></pre>
            </article>
            
            <article class="global" data-name="BuildModeCArchive">
               <h3>
                  BuildModeCArchive 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const BuildModeCArchive</code></pre>
            </article>
            
            <article class="global" data-name="BuildModeCShared">
               <h3>
                  BuildModeCShared 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const BuildModeCShared</code></pre>
            </article>
            
            <article class="global" data-name="BuildModeExe">
               <h3>
                  BuildModeExe 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const BuildModeExe</code></pre>
            </article>
            
            <article class="global" data-name="BuildModePIE">
               <h3>
                  BuildModePIE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const BuildModePIE</code></pre>
            </article>
            
            <article class="global" data-name="BuildModePlugin">
               <h3>
                  BuildModePlugin 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const BuildModePlugin</code></pre>
            </article>
            
            <article class="global" data-name="BuildModeShared">
               <h3>
                  BuildModeShared 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const BuildModeShared</code></pre>
            </article>
            
            <article class="global" data-name="BuildModeUnset">
               <h3>
                  BuildModeUnset 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const BuildModeUnset BuildMode = iota</code></pre>
            </article>
            
            <article class="global" data-name="COMPUNITHEADERSIZE">
               <h3>
                  COMPUNITHEADERSIZE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const COMPUNITHEADERSIZE = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="C_BCOMM">
               <h3>
                  C_BCOMM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_BCOMM = 135</code></pre>
            </article>
            
            <article class="global" data-name="C_BINCL">
               <h3>
                  C_BINCL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_BINCL = 108</code></pre>
            </article>
            
            <article class="global" data-name="C_BLOCK">
               <h3>
                  C_BLOCK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_BLOCK = 100</code></pre>
            </article>
            
            <article class="global" data-name="C_BSTAT">
               <h3>
                  C_BSTAT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_BSTAT = 143</code></pre>
            </article>
            
            <article class="global" data-name="C_DECL">
               <h3>
                  C_DECL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_DECL = 140</code></pre>
            </article>
            
            <article class="global" data-name="C_DWARF">
               <h3>
                  C_DWARF 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_DWARF = 112</code></pre>
            </article>
            
            <article class="global" data-name="C_ECOML">
               <h3>
                  C_ECOML 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_ECOML = 136</code></pre>
            </article>
            
            <article class="global" data-name="C_ECOMM">
               <h3>
                  C_ECOMM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_ECOMM = 137</code></pre>
            </article>
            
            <article class="global" data-name="C_EINCL">
               <h3>
                  C_EINCL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_EINCL = 109</code></pre>
            </article>
            
            <article class="global" data-name="C_ENTRY">
               <h3>
                  C_ENTRY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_ENTRY = 141</code></pre>
            </article>
            
            <article class="global" data-name="C_ESTAT">
               <h3>
                  C_ESTAT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_ESTAT = 144</code></pre>
            </article>
            
            <article class="global" data-name="C_EXT">
               <h3>
                  C_EXT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_EXT = 2</code></pre>
            </article>
            
            <article class="global" data-name="C_FCN">
               <h3>
                  C_FCN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_FCN = 101</code></pre>
            </article>
            
            <article class="global" data-name="C_FILE">
               <h3>
                  C_FILE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_FILE = 103</code></pre>
            </article>
            
            <article class="global" data-name="C_FUN">
               <h3>
                  C_FUN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_FUN = 142</code></pre>
            </article>
            
            <article class="global" data-name="C_GSYM">
               <h3>
                  C_GSYM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_GSYM = 128</code></pre>
            </article>
            
            <article class="global" data-name="C_GTLS">
               <h3>
                  C_GTLS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_GTLS = 145</code></pre>
            </article>
            
            <article class="global" data-name="C_HIDEXT">
               <h3>
                  C_HIDEXT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_HIDEXT = 107</code></pre>
            </article>
            
            <article class="global" data-name="C_LSYM">
               <h3>
                  C_LSYM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_LSYM = 129</code></pre>
            </article>
            
            <article class="global" data-name="C_NULL">
               <h3>
                  C_NULL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_NULL = 0</code></pre>
            </article>
            
            <article class="global" data-name="C_PSYM">
               <h3>
                  C_PSYM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_PSYM = 130</code></pre>
            </article>
            
            <article class="global" data-name="C_RPSYM">
               <h3>
                  C_RPSYM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_RPSYM = 132</code></pre>
            </article>
            
            <article class="global" data-name="C_RSYM">
               <h3>
                  C_RSYM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_RSYM = 131</code></pre>
            </article>
            
            <article class="global" data-name="C_STAT">
               <h3>
                  C_STAT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_STAT = 3</code></pre>
            </article>
            
            <article class="global" data-name="C_STSYM">
               <h3>
                  C_STSYM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_STSYM = 133</code></pre>
            </article>
            
            <article class="global" data-name="C_STTLS">
               <h3>
                  C_STTLS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_STTLS = 146</code></pre>
            </article>
            
            <article class="global" data-name="C_WEAKEXT">
               <h3>
                  C_WEAKEXT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage Class.</p>
               
               <pre><code>const C_WEAKEXT = 111</code></pre>
            </article>
            
            <article class="global" data-name="CarrierSymByType">
               <h3>
                  CarrierSymByType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>CarrierSymByType tracks carrier symbols and their sizes.</p>
               
               <pre><code>var CarrierSymByType [sym.SXREF]struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="DataSym">
               <h3>
                  DataSym 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const DataSym SymbolType = 'D'</code></pre>
            </article>
            
            <article class="global" data-name="DeletedAutoSym">
               <h3>
                  DeletedAutoSym 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Deleted auto (not a real sym, just placeholder for type)</p>
               
               <pre><code>const DeletedAutoSym = 'x'</code></pre>
            </article>
            
            <article class="global" data-name="ELF32HDRSIZE">
               <h3>
                  ELF32HDRSIZE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Go linker interface</p>
               
               <pre><code>const ELF32HDRSIZE = 52</code></pre>
            </article>
            
            <article class="global" data-name="ELF32PHDRSIZE">
               <h3>
                  ELF32PHDRSIZE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Go linker interface</p>
               
               <pre><code>const ELF32PHDRSIZE = 32</code></pre>
            </article>
            
            <article class="global" data-name="ELF32RELSIZE">
               <h3>
                  ELF32RELSIZE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Go linker interface</p>
               
               <pre><code>const ELF32RELSIZE = 8</code></pre>
            </article>
            
            <article class="global" data-name="ELF32SHDRSIZE">
               <h3>
                  ELF32SHDRSIZE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Go linker interface</p>
               
               <pre><code>const ELF32SHDRSIZE = 40</code></pre>
            </article>
            
            <article class="global" data-name="ELF32SYMSIZE">
               <h3>
                  ELF32SYMSIZE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Go linker interface</p>
               
               <pre><code>const ELF32SYMSIZE = 16</code></pre>
            </article>
            
            <article class="global" data-name="ELF64HDRSIZE">
               <h3>
                  ELF64HDRSIZE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Go linker interface</p>
               
               <pre><code>const ELF64HDRSIZE = 64</code></pre>
            </article>
            
            <article class="global" data-name="ELF64PHDRSIZE">
               <h3>
                  ELF64PHDRSIZE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Go linker interface</p>
               
               <pre><code>const ELF64PHDRSIZE = 56</code></pre>
            </article>
            
            <article class="global" data-name="ELF64RELASIZE">
               <h3>
                  ELF64RELASIZE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Go linker interface</p>
               
               <pre><code>const ELF64RELASIZE = 24</code></pre>
            </article>
            
            <article class="global" data-name="ELF64RELSIZE">
               <h3>
                  ELF64RELSIZE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Go linker interface</p>
               
               <pre><code>const ELF64RELSIZE = 16</code></pre>
            </article>
            
            <article class="global" data-name="ELF64SHDRSIZE">
               <h3>
                  ELF64SHDRSIZE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Go linker interface</p>
               
               <pre><code>const ELF64SHDRSIZE = 64</code></pre>
            </article>
            
            <article class="global" data-name="ELF64SYMSIZE">
               <h3>
                  ELF64SYMSIZE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Go linker interface</p>
               
               <pre><code>const ELF64SYMSIZE = 24</code></pre>
            </article>
            
            <article class="global" data-name="ELFRESERVE">
               <h3>
                  ELFRESERVE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Total amount of space to reserve at the start of the file
 * for Header, PHeaders, SHeaders, and interp.
 * May waste some.
 * On FreeBSD, cannot be larger than a page.</p>
               
               <pre><code>const ELFRESERVE = 4096</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_BUILDINFO_NAME">
               <h3>
                  ELF_NOTE_BUILDINFO_NAME 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ELF_NOTE_BUILDINFO_NAME = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_BUILDINFO_NAMESZ">
               <h3>
                  ELF_NOTE_BUILDINFO_NAMESZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Build info note</p>
               
               <pre><code>const ELF_NOTE_BUILDINFO_NAMESZ = 4</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_BUILDINFO_TAG">
               <h3>
                  ELF_NOTE_BUILDINFO_TAG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Build info note</p>
               
               <pre><code>const ELF_NOTE_BUILDINFO_TAG = 3</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_FREEBSD_ABI_TAG">
               <h3>
                  ELF_NOTE_FREEBSD_ABI_TAG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FreeBSD Signature (as per sys/elf_common.h)</p>
               
               <pre><code>const ELF_NOTE_FREEBSD_ABI_TAG = 1</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_FREEBSD_DESCSZ">
               <h3>
                  ELF_NOTE_FREEBSD_DESCSZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FreeBSD Signature (as per sys/elf_common.h)</p>
               
               <pre><code>const ELF_NOTE_FREEBSD_DESCSZ = 4</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_FREEBSD_FCTL_ASLR_DISABLE">
               <h3>
                  ELF_NOTE_FREEBSD_FCTL_ASLR_DISABLE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FreeBSD Signature (as per sys/elf_common.h)</p>
               
               <pre><code>const ELF_NOTE_FREEBSD_FCTL_ASLR_DISABLE = 0x1</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_FREEBSD_FEATURE_CTL_TAG">
               <h3>
                  ELF_NOTE_FREEBSD_FEATURE_CTL_TAG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FreeBSD Signature (as per sys/elf_common.h)</p>
               
               <pre><code>const ELF_NOTE_FREEBSD_FEATURE_CTL_TAG = 4</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_FREEBSD_NAME">
               <h3>
                  ELF_NOTE_FREEBSD_NAME 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ELF_NOTE_FREEBSD_NAME = "FreeBSD\x00"</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_FREEBSD_NAMESZ">
               <h3>
                  ELF_NOTE_FREEBSD_NAMESZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FreeBSD Signature (as per sys/elf_common.h)</p>
               
               <pre><code>const ELF_NOTE_FREEBSD_NAMESZ = 8</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_FREEBSD_NOINIT_TAG">
               <h3>
                  ELF_NOTE_FREEBSD_NOINIT_TAG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FreeBSD Signature (as per sys/elf_common.h)</p>
               
               <pre><code>const ELF_NOTE_FREEBSD_NOINIT_TAG = 2</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_FREEBSD_VERSION">
               <h3>
                  ELF_NOTE_FREEBSD_VERSION 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FreeBSD Signature (as per sys/elf_common.h)</p>
               
               <pre><code>const ELF_NOTE_FREEBSD_VERSION = 1203000</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_GOABIHASH_TAG">
               <h3>
                  ELF_NOTE_GOABIHASH_TAG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Go specific notes</p>
               
               <pre><code>const ELF_NOTE_GOABIHASH_TAG = 2</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_GOBUILDID_TAG">
               <h3>
                  ELF_NOTE_GOBUILDID_TAG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Go specific notes</p>
               
               <pre><code>const ELF_NOTE_GOBUILDID_TAG = 4</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_GODEPS_TAG">
               <h3>
                  ELF_NOTE_GODEPS_TAG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Go specific notes</p>
               
               <pre><code>const ELF_NOTE_GODEPS_TAG = 3</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_GOPKGLIST_TAG">
               <h3>
                  ELF_NOTE_GOPKGLIST_TAG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Go specific notes</p>
               
               <pre><code>const ELF_NOTE_GOPKGLIST_TAG = 1</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_GO_NAME">
               <h3>
                  ELF_NOTE_GO_NAME 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ELF_NOTE_GO_NAME = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_NETBSD_DESCSZ">
               <h3>
                  ELF_NOTE_NETBSD_DESCSZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>NetBSD Signature (as per sys/exec_elf.h)</p>
               
               <pre><code>const ELF_NOTE_NETBSD_DESCSZ = 4</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_NETBSD_NAME">
               <h3>
                  ELF_NOTE_NETBSD_NAME 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ELF_NOTE_NETBSD_NAME = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_NETBSD_NAMESZ">
               <h3>
                  ELF_NOTE_NETBSD_NAMESZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>NetBSD Signature (as per sys/exec_elf.h)</p>
               
               <pre><code>const ELF_NOTE_NETBSD_NAMESZ = 7</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_NETBSD_TAG">
               <h3>
                  ELF_NOTE_NETBSD_TAG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>NetBSD Signature (as per sys/exec_elf.h)</p>
               
               <pre><code>const ELF_NOTE_NETBSD_TAG = 1</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_NETBSD_VERSION">
               <h3>
                  ELF_NOTE_NETBSD_VERSION 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>NetBSD Signature (as per sys/exec_elf.h)</p>
               
               <pre><code>const ELF_NOTE_NETBSD_VERSION = 700000000</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_OPENBSD_DESCSZ">
               <h3>
                  ELF_NOTE_OPENBSD_DESCSZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>OpenBSD Signature</p>
               
               <pre><code>const ELF_NOTE_OPENBSD_DESCSZ = 4</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_OPENBSD_NAME">
               <h3>
                  ELF_NOTE_OPENBSD_NAME 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ELF_NOTE_OPENBSD_NAME = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_OPENBSD_NAMESZ">
               <h3>
                  ELF_NOTE_OPENBSD_NAMESZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>OpenBSD Signature</p>
               
               <pre><code>const ELF_NOTE_OPENBSD_NAMESZ = 8</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_OPENBSD_TAG">
               <h3>
                  ELF_NOTE_OPENBSD_TAG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>OpenBSD Signature</p>
               
               <pre><code>const ELF_NOTE_OPENBSD_TAG = 1</code></pre>
            </article>
            
            <article class="global" data-name="ELF_NOTE_OPENBSD_VERSION">
               <h3>
                  ELF_NOTE_OPENBSD_VERSION 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>OpenBSD Signature</p>
               
               <pre><code>const ELF_NOTE_OPENBSD_VERSION = 0</code></pre>
            </article>
            
            <article class="global" data-name="FILHSZ_32">
               <h3>
                  FILHSZ_32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Headers size</p>
               
               <pre><code>const FILHSZ_32 = 20</code></pre>
            </article>
            
            <article class="global" data-name="FILHSZ_64">
               <h3>
                  FILHSZ_64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Headers size</p>
               
               <pre><code>const FILHSZ_64 = 24</code></pre>
            </article>
            
            <article class="global" data-name="F_DSA">
               <h3>
                  F_DSA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags that describe the type of the object file.</p>
               
               <pre><code>const F_DSA = 0x0040</code></pre>
            </article>
            
            <article class="global" data-name="F_DYNLOAD">
               <h3>
                  F_DYNLOAD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags that describe the type of the object file.</p>
               
               <pre><code>const F_DYNLOAD = 0x1000</code></pre>
            </article>
            
            <article class="global" data-name="F_EXEC">
               <h3>
                  F_EXEC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags that describe the type of the object file.</p>
               
               <pre><code>const F_EXEC = 0x0002</code></pre>
            </article>
            
            <article class="global" data-name="F_FDPR_OPTI">
               <h3>
                  F_FDPR_OPTI 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags that describe the type of the object file.</p>
               
               <pre><code>const F_FDPR_OPTI = 0x0020</code></pre>
            </article>
            
            <article class="global" data-name="F_FDPR_PROF">
               <h3>
                  F_FDPR_PROF 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags that describe the type of the object file.</p>
               
               <pre><code>const F_FDPR_PROF = 0x0010</code></pre>
            </article>
            
            <article class="global" data-name="F_LNNO">
               <h3>
                  F_LNNO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags that describe the type of the object file.</p>
               
               <pre><code>const F_LNNO = 0x0004</code></pre>
            </article>
            
            <article class="global" data-name="F_LOADONLY">
               <h3>
                  F_LOADONLY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags that describe the type of the object file.</p>
               
               <pre><code>const F_LOADONLY = 0x4000</code></pre>
            </article>
            
            <article class="global" data-name="F_RELFLG">
               <h3>
                  F_RELFLG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags that describe the type of the object file.</p>
               
               <pre><code>const F_RELFLG = 0x0001</code></pre>
            </article>
            
            <article class="global" data-name="F_SHROBJ">
               <h3>
                  F_SHROBJ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags that describe the type of the object file.</p>
               
               <pre><code>const F_SHROBJ = 0x2000</code></pre>
            </article>
            
            <article class="global" data-name="F_VARPG">
               <h3>
                  F_VARPG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags that describe the type of the object file.</p>
               
               <pre><code>const F_VARPG = 0x0100</code></pre>
            </article>
            
            <article class="global" data-name="FlagC">
               <h3>
                  FlagC 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var FlagC = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="FlagD">
               <h3>
                  FlagD 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var FlagD = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="FlagDebugTextSize">
               <h3>
                  FlagDebugTextSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var FlagDebugTextSize = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="FlagDebugTramp">
               <h3>
                  FlagDebugTramp 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var FlagDebugTramp = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="FlagRound">
               <h3>
                  FlagRound 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var FlagRound = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="FlagS">
               <h3>
                  FlagS 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var FlagS = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="FlagStrictDups">
               <h3>
                  FlagStrictDups 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var FlagStrictDups = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="FlagTextAddr">
               <h3>
                  FlagTextAddr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var FlagTextAddr = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="FlagW">
               <h3>
                  FlagW 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var FlagW = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="FrameSym">
               <h3>
                  FrameSym 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FrameSym SymbolType = 'm'</code></pre>
            </article>
            
            <article class="global" data-name="Funcalign">
               <h3>
                  Funcalign 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Funcalign int</code></pre>
            </article>
            
            <article class="global" data-name="GdbScriptPythonFileId">
               <h3>
                  GdbScriptPythonFileId 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>https://sourceware.org/gdb/onlinedocs/gdb/dotdebug_005fgdb_005fscripts-section.html
Each entry inside .debug_gdb_scripts section begins with a non-null prefix
byte that specifies the kind of entry. The following entries are supported:</p>
               
               <pre><code>const GdbScriptPythonFileId = 1</code></pre>
            </article>
            
            <article class="global" data-name="GdbScriptPythonTextId">
               <h3>
                  GdbScriptPythonTextId 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>https://sourceware.org/gdb/onlinedocs/gdb/dotdebug_005fgdb_005fscripts-section.html
Each entry inside .debug_gdb_scripts section begins with a non-null prefix
byte that specifies the kind of entry. The following entries are supported:</p>
               
               <pre><code>const GdbScriptPythonTextId = 4</code></pre>
            </article>
            
            <article class="global" data-name="GdbScriptSchemeFileId">
               <h3>
                  GdbScriptSchemeFileId 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>https://sourceware.org/gdb/onlinedocs/gdb/dotdebug_005fgdb_005fscripts-section.html
Each entry inside .debug_gdb_scripts section begins with a non-null prefix
byte that specifies the kind of entry. The following entries are supported:</p>
               
               <pre><code>const GdbScriptSchemeFileId = 3</code></pre>
            </article>
            
            <article class="global" data-name="GdbScriptSchemeTextId">
               <h3>
                  GdbScriptSchemeTextId 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>https://sourceware.org/gdb/onlinedocs/gdb/dotdebug_005fgdb_005fscripts-section.html
Each entry inside .debug_gdb_scripts section begins with a non-null prefix
byte that specifies the kind of entry. The following entries are supported:</p>
               
               <pre><code>const GdbScriptSchemeTextId = 6</code></pre>
            </article>
            
            <article class="global" data-name="HEADR">
               <h3>
                  HEADR 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var HEADR int32</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_AMD64_ADDR32">
               <h3>
                  IMAGE_REL_AMD64_ADDR32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_AMD64_ADDR32 = 0x0002</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_AMD64_ADDR32NB">
               <h3>
                  IMAGE_REL_AMD64_ADDR32NB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_AMD64_ADDR32NB = 0x0003</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_AMD64_ADDR64">
               <h3>
                  IMAGE_REL_AMD64_ADDR64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_AMD64_ADDR64 = 0x0001</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_AMD64_REL32">
               <h3>
                  IMAGE_REL_AMD64_REL32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_AMD64_REL32 = 0x0004</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_AMD64_SECREL">
               <h3>
                  IMAGE_REL_AMD64_SECREL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_AMD64_SECREL = 0x000B</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_ABSOLUTE">
               <h3>
                  IMAGE_REL_ARM64_ABSOLUTE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_ABSOLUTE = 0x0000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_ADDR32">
               <h3>
                  IMAGE_REL_ARM64_ADDR32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_ADDR32 = 0x0001</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_ADDR32NB">
               <h3>
                  IMAGE_REL_ARM64_ADDR32NB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_ADDR32NB = 0x0002</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_ADDR64">
               <h3>
                  IMAGE_REL_ARM64_ADDR64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_ADDR64 = 0x000E</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_BRANCH14">
               <h3>
                  IMAGE_REL_ARM64_BRANCH14 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_BRANCH14 = 0x0010</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_BRANCH19">
               <h3>
                  IMAGE_REL_ARM64_BRANCH19 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_BRANCH19 = 0x000F</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_BRANCH26">
               <h3>
                  IMAGE_REL_ARM64_BRANCH26 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_BRANCH26 = 0x0003</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_PAGEBASE_REL21">
               <h3>
                  IMAGE_REL_ARM64_PAGEBASE_REL21 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_PAGEBASE_REL21 = 0x0004</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_PAGEOFFSET_12A">
               <h3>
                  IMAGE_REL_ARM64_PAGEOFFSET_12A 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_PAGEOFFSET_12A = 0x0006</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_PAGEOFFSET_12L">
               <h3>
                  IMAGE_REL_ARM64_PAGEOFFSET_12L 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_PAGEOFFSET_12L = 0x0007</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_REL21">
               <h3>
                  IMAGE_REL_ARM64_REL21 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_REL21 = 0x0005</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_REL32">
               <h3>
                  IMAGE_REL_ARM64_REL32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_REL32 = 0x0011</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_SECREL">
               <h3>
                  IMAGE_REL_ARM64_SECREL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_SECREL = 0x0008</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_SECREL_HIGH12A">
               <h3>
                  IMAGE_REL_ARM64_SECREL_HIGH12A 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_SECREL_HIGH12A = 0x000A</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_SECREL_LOW12A">
               <h3>
                  IMAGE_REL_ARM64_SECREL_LOW12A 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_SECREL_LOW12A = 0x0009</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_SECREL_LOW12L">
               <h3>
                  IMAGE_REL_ARM64_SECREL_LOW12L 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_SECREL_LOW12L = 0x000B</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_SECTION">
               <h3>
                  IMAGE_REL_ARM64_SECTION 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_SECTION = 0x000D</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM64_TOKEN">
               <h3>
                  IMAGE_REL_ARM64_TOKEN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM64_TOKEN = 0x000C</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM_ABSOLUTE">
               <h3>
                  IMAGE_REL_ARM_ABSOLUTE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM_ABSOLUTE = 0x0000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM_ADDR32">
               <h3>
                  IMAGE_REL_ARM_ADDR32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM_ADDR32 = 0x0001</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM_ADDR32NB">
               <h3>
                  IMAGE_REL_ARM_ADDR32NB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM_ADDR32NB = 0x0002</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM_BRANCH11">
               <h3>
                  IMAGE_REL_ARM_BRANCH11 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM_BRANCH11 = 0x0004</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM_BRANCH24">
               <h3>
                  IMAGE_REL_ARM_BRANCH24 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM_BRANCH24 = 0x0003</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_ARM_SECREL">
               <h3>
                  IMAGE_REL_ARM_SECREL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_ARM_SECREL = 0x000F</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_BASED_DIR64">
               <h3>
                  IMAGE_REL_BASED_DIR64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_BASED_DIR64 = 10</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_BASED_HIGHLOW">
               <h3>
                  IMAGE_REL_BASED_HIGHLOW 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_BASED_HIGHLOW = 3</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_I386_DIR32">
               <h3>
                  IMAGE_REL_I386_DIR32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_I386_DIR32 = 0x0006</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_I386_DIR32NB">
               <h3>
                  IMAGE_REL_I386_DIR32NB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_I386_DIR32NB = 0x0007</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_I386_REL32">
               <h3>
                  IMAGE_REL_I386_REL32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_I386_REL32 = 0x0014</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_REL_I386_SECREL">
               <h3>
                  IMAGE_REL_I386_SECREL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_REL_I386_SECREL = 0x000B</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_ALIGN_1024BYTES">
               <h3>
                  IMAGE_SCN_ALIGN_1024BYTES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_ALIGN_1024BYTES = 0x00B00000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_ALIGN_128BYTES">
               <h3>
                  IMAGE_SCN_ALIGN_128BYTES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_ALIGN_128BYTES = 0x00800000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_ALIGN_16BYTES">
               <h3>
                  IMAGE_SCN_ALIGN_16BYTES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_ALIGN_16BYTES = 0x00500000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_ALIGN_1BYTES">
               <h3>
                  IMAGE_SCN_ALIGN_1BYTES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_ALIGN_1BYTES = 0x00100000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_ALIGN_2048BYTES">
               <h3>
                  IMAGE_SCN_ALIGN_2048BYTES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_ALIGN_2048BYTES = 0x00C00000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_ALIGN_256BYTES">
               <h3>
                  IMAGE_SCN_ALIGN_256BYTES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_ALIGN_256BYTES = 0x00900000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_ALIGN_2BYTES">
               <h3>
                  IMAGE_SCN_ALIGN_2BYTES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_ALIGN_2BYTES = 0x00200000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_ALIGN_32BYTES">
               <h3>
                  IMAGE_SCN_ALIGN_32BYTES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_ALIGN_32BYTES = 0x00600000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_ALIGN_4096BYTES">
               <h3>
                  IMAGE_SCN_ALIGN_4096BYTES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_ALIGN_4096BYTES = 0x00D00000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_ALIGN_4BYTES">
               <h3>
                  IMAGE_SCN_ALIGN_4BYTES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_ALIGN_4BYTES = 0x00300000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_ALIGN_512BYTES">
               <h3>
                  IMAGE_SCN_ALIGN_512BYTES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_ALIGN_512BYTES = 0x00A00000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_ALIGN_64BYTES">
               <h3>
                  IMAGE_SCN_ALIGN_64BYTES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_ALIGN_64BYTES = 0x00700000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_ALIGN_8192BYTES">
               <h3>
                  IMAGE_SCN_ALIGN_8192BYTES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_ALIGN_8192BYTES = 0x00E00000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_ALIGN_8BYTES">
               <h3>
                  IMAGE_SCN_ALIGN_8BYTES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_ALIGN_8BYTES = 0x00400000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_CNT_CODE">
               <h3>
                  IMAGE_SCN_CNT_CODE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_CNT_CODE = 0x00000020</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_CNT_INITIALIZED_DATA">
               <h3>
                  IMAGE_SCN_CNT_INITIALIZED_DATA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_CNT_INITIALIZED_DATA = 0x00000040</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_CNT_UNINITIALIZED_DATA">
               <h3>
                  IMAGE_SCN_CNT_UNINITIALIZED_DATA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x00000080</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_GPREL">
               <h3>
                  IMAGE_SCN_GPREL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_GPREL = 0x00008000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_LNK_COMDAT">
               <h3>
                  IMAGE_SCN_LNK_COMDAT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_LNK_COMDAT = 0x00001000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_LNK_INFO">
               <h3>
                  IMAGE_SCN_LNK_INFO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_LNK_INFO = 0x00000200</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_LNK_NRELOC_OVFL">
               <h3>
                  IMAGE_SCN_LNK_NRELOC_OVFL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_LNK_NRELOC_OVFL = 0x01000000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_LNK_OTHER">
               <h3>
                  IMAGE_SCN_LNK_OTHER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_LNK_OTHER = 0x00000100</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_LNK_REMOVE">
               <h3>
                  IMAGE_SCN_LNK_REMOVE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_LNK_REMOVE = 0x00000800</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_MEM_16BIT">
               <h3>
                  IMAGE_SCN_MEM_16BIT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_MEM_16BIT = 0x00020000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_MEM_DISCARDABLE">
               <h3>
                  IMAGE_SCN_MEM_DISCARDABLE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_MEM_DISCARDABLE = 0x02000000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_MEM_EXECUTE">
               <h3>
                  IMAGE_SCN_MEM_EXECUTE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_MEM_EXECUTE = 0x20000000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_MEM_LOCKED">
               <h3>
                  IMAGE_SCN_MEM_LOCKED 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_MEM_LOCKED = 0x00040000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_MEM_NOT_CACHED">
               <h3>
                  IMAGE_SCN_MEM_NOT_CACHED 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_MEM_NOT_CACHED = 0x04000000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_MEM_NOT_PAGED">
               <h3>
                  IMAGE_SCN_MEM_NOT_PAGED 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_MEM_NOT_PAGED = 0x08000000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_MEM_PRELOAD">
               <h3>
                  IMAGE_SCN_MEM_PRELOAD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_MEM_PRELOAD = 0x00080000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_MEM_PURGEABLE">
               <h3>
                  IMAGE_SCN_MEM_PURGEABLE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_MEM_PURGEABLE = 0x00020000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_MEM_READ">
               <h3>
                  IMAGE_SCN_MEM_READ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_MEM_READ = 0x40000000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_MEM_SHARED">
               <h3>
                  IMAGE_SCN_MEM_SHARED 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_MEM_SHARED = 0x10000000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SCN_MEM_WRITE">
               <h3>
                  IMAGE_SCN_MEM_WRITE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const IMAGE_SCN_MEM_WRITE = 0x80000000</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SYM_CLASS_EXTERNAL">
               <h3>
                  IMAGE_SYM_CLASS_EXTERNAL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_SYM_CLASS_EXTERNAL = 2</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SYM_CLASS_STATIC">
               <h3>
                  IMAGE_SYM_CLASS_STATIC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_SYM_CLASS_STATIC = 3</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SYM_DTYPE_ARRAY">
               <h3>
                  IMAGE_SYM_DTYPE_ARRAY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_SYM_DTYPE_ARRAY = 3</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SYM_DTYPE_FUNCTION">
               <h3>
                  IMAGE_SYM_DTYPE_FUNCTION 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_SYM_DTYPE_FUNCTION = 2</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SYM_TYPE_NULL">
               <h3>
                  IMAGE_SYM_TYPE_NULL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_SYM_TYPE_NULL = 0</code></pre>
            </article>
            
            <article class="global" data-name="IMAGE_SYM_TYPE_STRUCT">
               <h3>
                  IMAGE_SYM_TYPE_STRUCT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format.
TODO(crawshaw): add these constants to debug/pe.</p>
               
               <pre><code>const IMAGE_SYM_TYPE_STRUCT = 8</code></pre>
            </article>
            
            <article class="global" data-name="INITIAL_MACHO_HEADR">
               <h3>
                  INITIAL_MACHO_HEADR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Total amount of space to reserve at the start of the file
 * for Header, PHeaders, and SHeaders.
 * May waste some.</p>
               
               <pre><code>const INITIAL_MACHO_HEADR = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="LDHDRSZ_32">
               <h3>
                  LDHDRSZ_32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Headers size</p>
               
               <pre><code>const LDHDRSZ_32 = 32</code></pre>
            </article>
            
            <article class="global" data-name="LDHDRSZ_64">
               <h3>
                  LDHDRSZ_64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Headers size</p>
               
               <pre><code>const LDHDRSZ_64 = 56</code></pre>
            </article>
            
            <article class="global" data-name="LDSYMSZ_64">
               <h3>
                  LDSYMSZ_64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Headers size</p>
               
               <pre><code>const LDSYMSZ_64 = 24</code></pre>
            </article>
            
            <article class="global" data-name="LINE_BASE">
               <h3>
                  LINE_BASE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Generate a sequence of opcodes that is as short as possible.
 * See section 6.2.5</p>
               
               <pre><code>const LINE_BASE = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="LINE_RANGE">
               <h3>
                  LINE_RANGE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Generate a sequence of opcodes that is as short as possible.
 * See section 6.2.5</p>
               
               <pre><code>const LINE_RANGE = 10</code></pre>
            </article>
            
            <article class="global" data-name="LinkAuto">
               <h3>
                  LinkAuto 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const LinkAuto LinkMode = iota</code></pre>
            </article>
            
            <article class="global" data-name="LinkExternal">
               <h3>
                  LinkExternal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const LinkExternal</code></pre>
            </article>
            
            <article class="global" data-name="LinkInternal">
               <h3>
                  LinkInternal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const LinkInternal</code></pre>
            </article>
            
            <article class="global" data-name="MACHO32SYMSIZE">
               <h3>
                  MACHO32SYMSIZE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO32SYMSIZE = 12</code></pre>
            </article>
            
            <article class="global" data-name="MACHO64SYMSIZE">
               <h3>
                  MACHO64SYMSIZE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO64SYMSIZE = 16</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_ARM64_RELOC_ADDEND">
               <h3>
                  MACHO_ARM64_RELOC_ADDEND 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_ARM64_RELOC_ADDEND = 10</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_ARM64_RELOC_BRANCH26">
               <h3>
                  MACHO_ARM64_RELOC_BRANCH26 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_ARM64_RELOC_BRANCH26 = 2</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_ARM64_RELOC_GOT_LOAD_PAGE21">
               <h3>
                  MACHO_ARM64_RELOC_GOT_LOAD_PAGE21 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_ARM64_RELOC_GOT_LOAD_PAGE21 = 5</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_ARM64_RELOC_GOT_LOAD_PAGEOFF12">
               <h3>
                  MACHO_ARM64_RELOC_GOT_LOAD_PAGEOFF12 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_ARM64_RELOC_GOT_LOAD_PAGEOFF12 = 6</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_ARM64_RELOC_PAGE21">
               <h3>
                  MACHO_ARM64_RELOC_PAGE21 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_ARM64_RELOC_PAGE21 = 3</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_ARM64_RELOC_PAGEOFF12">
               <h3>
                  MACHO_ARM64_RELOC_PAGEOFF12 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_ARM64_RELOC_PAGEOFF12 = 4</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_ARM64_RELOC_UNSIGNED">
               <h3>
                  MACHO_ARM64_RELOC_UNSIGNED 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_ARM64_RELOC_UNSIGNED = 0</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_ARM_RELOC_BR24">
               <h3>
                  MACHO_ARM_RELOC_BR24 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_ARM_RELOC_BR24 = 5</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_ARM_RELOC_PAIR">
               <h3>
                  MACHO_ARM_RELOC_PAIR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_ARM_RELOC_PAIR = 1</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_ARM_RELOC_SECTDIFF">
               <h3>
                  MACHO_ARM_RELOC_SECTDIFF 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_ARM_RELOC_SECTDIFF = 2</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_ARM_RELOC_VANILLA">
               <h3>
                  MACHO_ARM_RELOC_VANILLA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_ARM_RELOC_VANILLA = 0</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_CPU_386">
               <h3>
                  MACHO_CPU_386 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_CPU_386 = 7</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_CPU_AMD64">
               <h3>
                  MACHO_CPU_AMD64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_CPU_AMD64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_CPU_ARM">
               <h3>
                  MACHO_CPU_ARM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_CPU_ARM = 12</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_CPU_ARM64">
               <h3>
                  MACHO_CPU_ARM64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_CPU_ARM64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_FAKE_GOTPCREL">
               <h3>
                  MACHO_FAKE_GOTPCREL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_FAKE_GOTPCREL = 100</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_GENERIC_RELOC_VANILLA">
               <h3>
                  MACHO_GENERIC_RELOC_VANILLA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_GENERIC_RELOC_VANILLA = 0</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_SUBCPU_ARM">
               <h3>
                  MACHO_SUBCPU_ARM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_SUBCPU_ARM = 0</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_SUBCPU_ARM64E">
               <h3>
                  MACHO_SUBCPU_ARM64E 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_SUBCPU_ARM64E = 2</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_SUBCPU_ARM64_ALL">
               <h3>
                  MACHO_SUBCPU_ARM64_ALL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_SUBCPU_ARM64_ALL = 0</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_SUBCPU_ARM64_V8">
               <h3>
                  MACHO_SUBCPU_ARM64_V8 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_SUBCPU_ARM64_V8 = 1</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_SUBCPU_ARMV7">
               <h3>
                  MACHO_SUBCPU_ARMV7 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_SUBCPU_ARMV7 = 9</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_SUBCPU_X86">
               <h3>
                  MACHO_SUBCPU_X86 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_SUBCPU_X86 = 3</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_X86_64_RELOC_BRANCH">
               <h3>
                  MACHO_X86_64_RELOC_BRANCH 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_X86_64_RELOC_BRANCH = 2</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_X86_64_RELOC_GOT">
               <h3>
                  MACHO_X86_64_RELOC_GOT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_X86_64_RELOC_GOT = 4</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_X86_64_RELOC_GOT_LOAD">
               <h3>
                  MACHO_X86_64_RELOC_GOT_LOAD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_X86_64_RELOC_GOT_LOAD = 3</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_X86_64_RELOC_SIGNED">
               <h3>
                  MACHO_X86_64_RELOC_SIGNED 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_X86_64_RELOC_SIGNED = 1</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_X86_64_RELOC_SIGNED_1">
               <h3>
                  MACHO_X86_64_RELOC_SIGNED_1 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_X86_64_RELOC_SIGNED_1 = 6</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_X86_64_RELOC_SIGNED_2">
               <h3>
                  MACHO_X86_64_RELOC_SIGNED_2 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_X86_64_RELOC_SIGNED_2 = 7</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_X86_64_RELOC_SIGNED_4">
               <h3>
                  MACHO_X86_64_RELOC_SIGNED_4 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_X86_64_RELOC_SIGNED_4 = 8</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_X86_64_RELOC_SUBTRACTOR">
               <h3>
                  MACHO_X86_64_RELOC_SUBTRACTOR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_X86_64_RELOC_SUBTRACTOR = 5</code></pre>
            </article>
            
            <article class="global" data-name="MACHO_X86_64_RELOC_UNSIGNED">
               <h3>
                  MACHO_X86_64_RELOC_UNSIGNED 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MACHO_X86_64_RELOC_UNSIGNED = 0</code></pre>
            </article>
            
            <article class="global" data-name="MH_DYLDLINK">
               <h3>
                  MH_DYLDLINK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MH_DYLDLINK = 0x4</code></pre>
            </article>
            
            <article class="global" data-name="MH_EXECUTE">
               <h3>
                  MH_EXECUTE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MH_EXECUTE = 0x2</code></pre>
            </article>
            
            <article class="global" data-name="MH_MAGIC">
               <h3>
                  MH_MAGIC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MH_MAGIC = 0xfeedface</code></pre>
            </article>
            
            <article class="global" data-name="MH_MAGIC_64">
               <h3>
                  MH_MAGIC_64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MH_MAGIC_64 = 0xfeedfacf</code></pre>
            </article>
            
            <article class="global" data-name="MH_NOUNDEFS">
               <h3>
                  MH_NOUNDEFS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MH_NOUNDEFS = 0x1</code></pre>
            </article>
            
            <article class="global" data-name="MH_OBJECT">
               <h3>
                  MH_OBJECT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MH_OBJECT = 0x1</code></pre>
            </article>
            
            <article class="global" data-name="MH_PIE">
               <h3>
                  MH_PIE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MH_PIE = 0x200000</code></pre>
            </article>
            
            <article class="global" data-name="MIPS_FPABI_ANY">
               <h3>
                  MIPS_FPABI_ANY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FP code in the module uses the FP32 ABI for a 32-bit ABI</p>
               
               <pre><code>const MIPS_FPABI_ANY = 1</code></pre>
            </article>
            
            <article class="global" data-name="MIPS_FPABI_FP64">
               <h3>
                  MIPS_FPABI_FP64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FP code in the module uses the FP64  ABI</p>
               
               <pre><code>const MIPS_FPABI_FP64 = 6</code></pre>
            </article>
            
            <article class="global" data-name="MIPS_FPABI_FP64A">
               <h3>
                  MIPS_FPABI_FP64A 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FP code in the module uses the FP64A ABI</p>
               
               <pre><code>const MIPS_FPABI_FP64A = 7</code></pre>
            </article>
            
            <article class="global" data-name="MIPS_FPABI_FPXX">
               <h3>
                  MIPS_FPABI_FPXX 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FP code in the module uses the FPXX  ABI</p>
               
               <pre><code>const MIPS_FPABI_FPXX = 5</code></pre>
            </article>
            
            <article class="global" data-name="MIPS_FPABI_HIST">
               <h3>
                  MIPS_FPABI_HIST 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FP code in the module assumes an FPU with FR=1 and has 12
callee-saved doubles. Historic, no longer supported.</p>
               
               <pre><code>const MIPS_FPABI_HIST = 4</code></pre>
            </article>
            
            <article class="global" data-name="MIPS_FPABI_NONE">
               <h3>
                  MIPS_FPABI_NONE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>No floating point is present in the module (default)</p>
               
               <pre><code>const MIPS_FPABI_NONE = 0</code></pre>
            </article>
            
            <article class="global" data-name="MIPS_FPABI_SINGLE">
               <h3>
                  MIPS_FPABI_SINGLE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FP code in the module only uses single precision ABI</p>
               
               <pre><code>const MIPS_FPABI_SINGLE = 2</code></pre>
            </article>
            
            <article class="global" data-name="MIPS_FPABI_SOFT">
               <h3>
                  MIPS_FPABI_SOFT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FP code in the module uses soft-float ABI</p>
               
               <pre><code>const MIPS_FPABI_SOFT = 3</code></pre>
            </article>
            
            <article class="global" data-name="NOIDX">
               <h3>
                  NOIDX 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NOIDX = 0x7fffffff</code></pre>
            </article>
            
            <article class="global" data-name="NSECT">
               <h3>
                  NSECT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* We use the 64-bit data structures on both 32- and 64-bit machines
 * in order to write the code just once.  The 64-bit data structure is
 * written in the 32-bit format on the 32-bit machines.</p>
               
               <pre><code>const NSECT = 400</code></pre>
            </article>
            
            <article class="global" data-name="N_ABS">
               <h3>
                  N_ABS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const N_ABS = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="N_DEBUG">
               <h3>
                  N_DEBUG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Nscnum</p>
               
               <pre><code>const N_DEBUG = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="N_UNDEF">
               <h3>
                  N_UNDEF 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const N_UNDEF = 0</code></pre>
            </article>
            
            <article class="global" data-name="Nelfsym">
               <h3>
                  Nelfsym 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Nelfsym = 1</code></pre>
            </article>
            
            <article class="global" data-name="NumSymKind">
               <h3>
                  NumSymKind 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NumSymKind</code></pre>
            </article>
            
            <article class="global" data-name="OPCODE_BASE">
               <h3>
                  OPCODE_BASE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Generate a sequence of opcodes that is as short as possible.
 * See section 6.2.5</p>
               
               <pre><code>const OPCODE_BASE = 11</code></pre>
            </article>
            
            <article class="global" data-name="PC_RANGE">
               <h3>
                  PC_RANGE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>* Generate a sequence of opcodes that is as short as possible.
 * See section 6.2.5</p>
               
               <pre><code>const PC_RANGE = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="PEBASE">
               <h3>
                  PEBASE 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>PEBASE is the base address for the executable.
It is small for 32-bit and large for 64-bit.</p>
               
               <pre><code>var PEBASE int64</code></pre>
            </article>
            
            <article class="global" data-name="PEFILEALIGN">
               <h3>
                  PEFILEALIGN 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>FileAlignment should be a power of 2 between 512 and 64 K, inclusive.
The default is 512. If the SectionAlignment is less than
the architecture's page size, then FileAlignment must match SectionAlignment.</p>
               
               <pre><code>var PEFILEALIGN int64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="PEFILEHEADR">
               <h3>
                  PEFILEHEADR 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var PEFILEHEADR int32</code></pre>
            </article>
            
            <article class="global" data-name="PESECTALIGN">
               <h3>
                  PESECTALIGN 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>SectionAlignment must be greater than or equal to FileAlignment.
The default is the page size for the architecture.</p>
               
               <pre><code>var PESECTALIGN int64 = 0x1000</code></pre>
            </article>
            
            <article class="global" data-name="PESECTHEADR">
               <h3>
                  PESECTHEADR 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var PESECTHEADR int32</code></pre>
            </article>
            
            <article class="global" data-name="PLATFORM_BRIDGEOS">
               <h3>
                  PLATFORM_BRIDGEOS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const PLATFORM_BRIDGEOS MachoPlatform = 5</code></pre>
            </article>
            
            <article class="global" data-name="PLATFORM_IOS">
               <h3>
                  PLATFORM_IOS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const PLATFORM_IOS MachoPlatform = 2</code></pre>
            </article>
            
            <article class="global" data-name="PLATFORM_MACCATALYST">
               <h3>
                  PLATFORM_MACCATALYST 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const PLATFORM_MACCATALYST MachoPlatform = 6</code></pre>
            </article>
            
            <article class="global" data-name="PLATFORM_MACOS">
               <h3>
                  PLATFORM_MACOS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const PLATFORM_MACOS MachoPlatform = 1</code></pre>
            </article>
            
            <article class="global" data-name="PLATFORM_TVOS">
               <h3>
                  PLATFORM_TVOS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const PLATFORM_TVOS MachoPlatform = 3</code></pre>
            </article>
            
            <article class="global" data-name="PLATFORM_WATCHOS">
               <h3>
                  PLATFORM_WATCHOS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const PLATFORM_WATCHOS MachoPlatform = 4</code></pre>
            </article>
            
            <article class="global" data-name="ParamSym">
               <h3>
                  ParamSym 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ParamSym SymbolType = 'p'</code></pre>
            </article>
            
            <article class="global" data-name="PeMinimumTargetMajorVersion">
               <h3>
                  PeMinimumTargetMajorVersion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const PeMinimumTargetMajorVersion = 6</code></pre>
            </article>
            
            <article class="global" data-name="PeMinimumTargetMinorVersion">
               <h3>
                  PeMinimumTargetMinorVersion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const PeMinimumTargetMinorVersion = 1</code></pre>
            </article>
            
            <article class="global" data-name="REBASE_IMMEDIATE_MASK">
               <h3>
                  REBASE_IMMEDIATE_MASK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>rebase table opcode</p>
               
               <pre><code>const REBASE_IMMEDIATE_MASK = 0x0F</code></pre>
            </article>
            
            <article class="global" data-name="REBASE_OPCODE_ADD_ADDR_IMM_SCALED">
               <h3>
                  REBASE_OPCODE_ADD_ADDR_IMM_SCALED 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>rebase table opcode</p>
               
               <pre><code>const REBASE_OPCODE_ADD_ADDR_IMM_SCALED = 0x40</code></pre>
            </article>
            
            <article class="global" data-name="REBASE_OPCODE_ADD_ADDR_ULEB">
               <h3>
                  REBASE_OPCODE_ADD_ADDR_ULEB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>rebase table opcode</p>
               
               <pre><code>const REBASE_OPCODE_ADD_ADDR_ULEB = 0x30</code></pre>
            </article>
            
            <article class="global" data-name="REBASE_OPCODE_DONE">
               <h3>
                  REBASE_OPCODE_DONE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>rebase table opcode</p>
               
               <pre><code>const REBASE_OPCODE_DONE = 0x00</code></pre>
            </article>
            
            <article class="global" data-name="REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB">
               <h3>
                  REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>rebase table opcode</p>
               
               <pre><code>const REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB = 0x70</code></pre>
            </article>
            
            <article class="global" data-name="REBASE_OPCODE_DO_REBASE_IMM_TIMES">
               <h3>
                  REBASE_OPCODE_DO_REBASE_IMM_TIMES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>rebase table opcode</p>
               
               <pre><code>const REBASE_OPCODE_DO_REBASE_IMM_TIMES = 0x50</code></pre>
            </article>
            
            <article class="global" data-name="REBASE_OPCODE_DO_REBASE_ULEB_TIMES">
               <h3>
                  REBASE_OPCODE_DO_REBASE_ULEB_TIMES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>rebase table opcode</p>
               
               <pre><code>const REBASE_OPCODE_DO_REBASE_ULEB_TIMES = 0x60</code></pre>
            </article>
            
            <article class="global" data-name="REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB">
               <h3>
                  REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>rebase table opcode</p>
               
               <pre><code>const REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB = 0x80</code></pre>
            </article>
            
            <article class="global" data-name="REBASE_OPCODE_MASK">
               <h3>
                  REBASE_OPCODE_MASK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>rebase table opcode</p>
               
               <pre><code>const REBASE_OPCODE_MASK = 0xF0</code></pre>
            </article>
            
            <article class="global" data-name="REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB">
               <h3>
                  REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>rebase table opcode</p>
               
               <pre><code>const REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB = 0x20</code></pre>
            </article>
            
            <article class="global" data-name="REBASE_OPCODE_SET_TYPE_IMM">
               <h3>
                  REBASE_OPCODE_SET_TYPE_IMM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>rebase table opcode</p>
               
               <pre><code>const REBASE_OPCODE_SET_TYPE_IMM = 0x10</code></pre>
            </article>
            
            <article class="global" data-name="REBASE_TYPE_POINTER">
               <h3>
                  REBASE_TYPE_POINTER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>rebase table opcode</p>
               
               <pre><code>const REBASE_TYPE_POINTER = 1</code></pre>
            </article>
            
            <article class="global" data-name="REBASE_TYPE_TEXT_ABSOLUTE32">
               <h3>
                  REBASE_TYPE_TEXT_ABSOLUTE32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>rebase table opcode</p>
               
               <pre><code>const REBASE_TYPE_TEXT_ABSOLUTE32 = 2</code></pre>
            </article>
            
            <article class="global" data-name="REBASE_TYPE_TEXT_PCREL32">
               <h3>
                  REBASE_TYPE_TEXT_PCREL32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>rebase table opcode</p>
               
               <pre><code>const REBASE_TYPE_TEXT_PCREL32 = 3</code></pre>
            </article>
            
            <article class="global" data-name="RELSZ_64">
               <h3>
                  RELSZ_64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Headers size</p>
               
               <pre><code>const RELSZ_64 = 14</code></pre>
            </article>
            
            <article class="global" data-name="SARMAG">
               <h3>
                  SARMAG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SARMAG = 8</code></pre>
            </article>
            
            <article class="global" data-name="SAR_HDR">
               <h3>
                  SAR_HDR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SAR_HDR = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="SCNHSZ_32">
               <h3>
                  SCNHSZ_32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Headers size</p>
               
               <pre><code>const SCNHSZ_32 = 40</code></pre>
            </article>
            
            <article class="global" data-name="SCNHSZ_64">
               <h3>
                  SCNHSZ_64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Headers size</p>
               
               <pre><code>const SCNHSZ_64 = 72</code></pre>
            </article>
            
            <article class="global" data-name="SSUBTYP_DWABREV">
               <h3>
                  SSUBTYP_DWABREV 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SSUBTYP_DWABREV = 0x60000</code></pre>
            </article>
            
            <article class="global" data-name="SSUBTYP_DWARNGE">
               <h3>
                  SSUBTYP_DWARNGE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SSUBTYP_DWARNGE = 0x50000</code></pre>
            </article>
            
            <article class="global" data-name="SSUBTYP_DWFRAME">
               <h3>
                  SSUBTYP_DWFRAME 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SSUBTYP_DWFRAME = 0xA0000</code></pre>
            </article>
            
            <article class="global" data-name="SSUBTYP_DWINFO">
               <h3>
                  SSUBTYP_DWINFO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SSUBTYP_DWINFO = 0x10000</code></pre>
            </article>
            
            <article class="global" data-name="SSUBTYP_DWLINE">
               <h3>
                  SSUBTYP_DWLINE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SSUBTYP_DWLINE = 0x20000</code></pre>
            </article>
            
            <article class="global" data-name="SSUBTYP_DWLOC">
               <h3>
                  SSUBTYP_DWLOC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SSUBTYP_DWLOC = 0x90000</code></pre>
            </article>
            
            <article class="global" data-name="SSUBTYP_DWMAC">
               <h3>
                  SSUBTYP_DWMAC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SSUBTYP_DWMAC = 0xB0000</code></pre>
            </article>
            
            <article class="global" data-name="SSUBTYP_DWPBNMS">
               <h3>
                  SSUBTYP_DWPBNMS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SSUBTYP_DWPBNMS = 0x30000</code></pre>
            </article>
            
            <article class="global" data-name="SSUBTYP_DWPBTYP">
               <h3>
                  SSUBTYP_DWPBTYP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SSUBTYP_DWPBTYP = 0x40000</code></pre>
            </article>
            
            <article class="global" data-name="SSUBTYP_DWRNGES">
               <h3>
                  SSUBTYP_DWRNGES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SSUBTYP_DWRNGES = 0x80000</code></pre>
            </article>
            
            <article class="global" data-name="SSUBTYP_DWSTR">
               <h3>
                  SSUBTYP_DWSTR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SSUBTYP_DWSTR = 0x70000</code></pre>
            </article>
            
            <article class="global" data-name="STYP_BSS">
               <h3>
                  STYP_BSS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags defining the section type.</p>
               
               <pre><code>const STYP_BSS = 0x0080</code></pre>
            </article>
            
            <article class="global" data-name="STYP_DATA">
               <h3>
                  STYP_DATA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags defining the section type.</p>
               
               <pre><code>const STYP_DATA = 0x0040</code></pre>
            </article>
            
            <article class="global" data-name="STYP_DEBUG">
               <h3>
                  STYP_DEBUG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags defining the section type.</p>
               
               <pre><code>const STYP_DEBUG = 0x2000</code></pre>
            </article>
            
            <article class="global" data-name="STYP_DWARF">
               <h3>
                  STYP_DWARF 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags defining the section type.</p>
               
               <pre><code>const STYP_DWARF = 0x0010</code></pre>
            </article>
            
            <article class="global" data-name="STYP_EXCEPT">
               <h3>
                  STYP_EXCEPT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags defining the section type.</p>
               
               <pre><code>const STYP_EXCEPT = 0x0100</code></pre>
            </article>
            
            <article class="global" data-name="STYP_INFO">
               <h3>
                  STYP_INFO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags defining the section type.</p>
               
               <pre><code>const STYP_INFO = 0x0200</code></pre>
            </article>
            
            <article class="global" data-name="STYP_LOADER">
               <h3>
                  STYP_LOADER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags defining the section type.</p>
               
               <pre><code>const STYP_LOADER = 0x1000</code></pre>
            </article>
            
            <article class="global" data-name="STYP_OVRFLO">
               <h3>
                  STYP_OVRFLO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags defining the section type.</p>
               
               <pre><code>const STYP_OVRFLO = 0x8000</code></pre>
            </article>
            
            <article class="global" data-name="STYP_TBSS">
               <h3>
                  STYP_TBSS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags defining the section type.</p>
               
               <pre><code>const STYP_TBSS = 0x0800</code></pre>
            </article>
            
            <article class="global" data-name="STYP_TDATA">
               <h3>
                  STYP_TDATA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags defining the section type.</p>
               
               <pre><code>const STYP_TDATA = 0x0400</code></pre>
            </article>
            
            <article class="global" data-name="STYP_TEXT">
               <h3>
                  STYP_TEXT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags defining the section type.</p>
               
               <pre><code>const STYP_TEXT = 0x0020</code></pre>
            </article>
            
            <article class="global" data-name="STYP_TYPCHK">
               <h3>
                  STYP_TYPCHK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flags defining the section type.</p>
               
               <pre><code>const STYP_TYPCHK = 0x4000</code></pre>
            </article>
            
            <article class="global" data-name="SUBBUCKETS">
               <h3>
                  SUBBUCKETS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SUBBUCKETS = 16</code></pre>
            </article>
            
            <article class="global" data-name="SUBBUCKETSIZE">
               <h3>
                  SUBBUCKETSIZE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SUBBUCKETSIZE = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="SYMESZ">
               <h3>
                  SYMESZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SYMESZ = 18</code></pre>
            </article>
            
            <article class="global" data-name="SYM_TYPE_FUNC">
               <h3>
                  SYM_TYPE_FUNC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SYM_TYPE_FUNC = 0x0020</code></pre>
            </article>
            
            <article class="global" data-name="SYM_V_EXPORTED">
               <h3>
                  SYM_V_EXPORTED 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SYM_V_EXPORTED = 0x4000</code></pre>
            </article>
            
            <article class="global" data-name="SYM_V_HIDDEN">
               <h3>
                  SYM_V_HIDDEN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SYM_V_HIDDEN = 0x2000</code></pre>
            </article>
            
            <article class="global" data-name="SYM_V_INTERNAL">
               <h3>
                  SYM_V_INTERNAL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Ntype</p>
               
               <pre><code>const SYM_V_INTERNAL = 0x1000</code></pre>
            </article>
            
            <article class="global" data-name="SYM_V_PROTECTED">
               <h3>
                  SYM_V_PROTECTED 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SYM_V_PROTECTED = 0x3000</code></pre>
            </article>
            
            <article class="global" data-name="S_ATTR_DEBUG">
               <h3>
                  S_ATTR_DEBUG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const S_ATTR_DEBUG = 0x02000000</code></pre>
            </article>
            
            <article class="global" data-name="S_ATTR_PURE_INSTRUCTIONS">
               <h3>
                  S_ATTR_PURE_INSTRUCTIONS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const S_ATTR_PURE_INSTRUCTIONS = 0x80000000</code></pre>
            </article>
            
            <article class="global" data-name="S_ATTR_SOME_INSTRUCTIONS">
               <h3>
                  S_ATTR_SOME_INSTRUCTIONS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const S_ATTR_SOME_INSTRUCTIONS = 0x00000400</code></pre>
            </article>
            
            <article class="global" data-name="S_MOD_INIT_FUNC_POINTERS">
               <h3>
                  S_MOD_INIT_FUNC_POINTERS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const S_MOD_INIT_FUNC_POINTERS = 0x9</code></pre>
            </article>
            
            <article class="global" data-name="S_NON_LAZY_SYMBOL_POINTERS">
               <h3>
                  S_NON_LAZY_SYMBOL_POINTERS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const S_NON_LAZY_SYMBOL_POINTERS = 0x6</code></pre>
            </article>
            
            <article class="global" data-name="S_REGULAR">
               <h3>
                  S_REGULAR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const S_REGULAR = 0x0</code></pre>
            </article>
            
            <article class="global" data-name="S_SYMBOL_STUBS">
               <h3>
                  S_SYMBOL_STUBS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const S_SYMBOL_STUBS = 0x8</code></pre>
            </article>
            
            <article class="global" data-name="S_ZEROFILL">
               <h3>
                  S_ZEROFILL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const S_ZEROFILL = 0x1</code></pre>
            </article>
            
            <article class="global" data-name="Segdata">
               <h3>
                  Segdata 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Segdata sym.Segment</code></pre>
            </article>
            
            <article class="global" data-name="Segdwarf">
               <h3>
                  Segdwarf 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Segdwarf sym.Segment</code></pre>
            </article>
            
            <article class="global" data-name="Segments">
               <h3>
                  Segments 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Segments = []*sym.Segment{...}</code></pre>
            </article>
            
            <article class="global" data-name="Segpdata">
               <h3>
                  Segpdata 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Segpdata sym.Segment</code></pre>
            </article>
            
            <article class="global" data-name="Segrelrodata">
               <h3>
                  Segrelrodata 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Segrelrodata sym.Segment</code></pre>
            </article>
            
            <article class="global" data-name="Segrodata">
               <h3>
                  Segrodata 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Segrodata sym.Segment</code></pre>
            </article>
            
            <article class="global" data-name="Segtext">
               <h3>
                  Segtext 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Segtext sym.Segment</code></pre>
            </article>
            
            <article class="global" data-name="Segxdata">
               <h3>
                  Segxdata 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Segxdata sym.Segment</code></pre>
            </article>
            
            <article class="global" data-name="SymKindExtdef">
               <h3>
                  SymKindExtdef 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SymKindExtdef</code></pre>
            </article>
            
            <article class="global" data-name="SymKindLocal">
               <h3>
                  SymKindLocal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SymKindLocal = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="SymKindUndef">
               <h3>
                  SymKindUndef 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SymKindUndef</code></pre>
            </article>
            
            <article class="global" data-name="TLSSym">
               <h3>
                  TLSSym 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TLSSym SymbolType = 't'</code></pre>
            </article>
            
            <article class="global" data-name="TextSym">
               <h3>
                  TextSym 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>see also https://9p.io/magic/man2html/1/nm</p>
               
               <pre><code>const TextSym SymbolType = 'T'</code></pre>
            </article>
            
            <article class="global" data-name="U64_TOCMAGIC">
               <h3>
                  U64_TOCMAGIC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const U64_TOCMAGIC = 0767</code></pre>
            </article>
            
            <article class="global" data-name="UndefinedSym">
               <h3>
                  UndefinedSym 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const UndefinedSym SymbolType = 'U'</code></pre>
            </article>
            
            <article class="global" data-name="XCOFFDATABASE">
               <h3>
                  XCOFFDATABASE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFFDATABASE = 0x200000000</code></pre>
            </article>
            
            <article class="global" data-name="XCOFFHDRRESERVE">
               <h3>
                  XCOFFHDRRESERVE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Total amount of space to reserve at the start of the file
for File Header, Auxiliary Header, and Section Headers.
May waste some.</p>
               
               <pre><code>const XCOFFHDRRESERVE = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="XCOFFSECTALIGN">
               <h3>
                  XCOFFSECTALIGN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>base on dump -o, then rounded from 32B to 64B to
match worst case elf text section alignment on ppc64.</p>
               
               <pre><code>const XCOFFSECTALIGN int64 = 64</code></pre>
            </article>
            
            <article class="global" data-name="XCOFFTEXTBASE">
               <h3>
                  XCOFFTEXTBASE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>XCOFF binaries should normally have all its sections position-independent.
However, this is not yet possible for .text because of some R_ADDR relocations
inside RODATA symbols.
.data and .bss are position-independent so their address start inside an unreachable
segment during execution to force segfault if something is wrong.</p>
               
               <pre><code>const XCOFFTEXTBASE = 0x100000000</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_BA">
               <h3>
                  XCOFF_R_BA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_BA = 0x08</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_BR">
               <h3>
                  XCOFF_R_BR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_BR = 0x0A</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_GL">
               <h3>
                  XCOFF_R_GL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_GL = 0x05</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_NEG">
               <h3>
                  XCOFF_R_NEG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_NEG = 0x01</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_POS">
               <h3>
                  XCOFF_R_POS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_POS = 0x00</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_RBA">
               <h3>
                  XCOFF_R_RBA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_RBA = 0x18</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_RBR">
               <h3>
                  XCOFF_R_RBR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_RBR = 0x1A</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_REF">
               <h3>
                  XCOFF_R_REF 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_REF = 0x0F</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_REL">
               <h3>
                  XCOFF_R_REL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_REL = 0x02</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_RL">
               <h3>
                  XCOFF_R_RL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_RL = 0x0C</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_RLA">
               <h3>
                  XCOFF_R_RLA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_RLA = 0x0D</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_TCL">
               <h3>
                  XCOFF_R_TCL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_TCL = 0x06</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_TLS">
               <h3>
                  XCOFF_R_TLS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_TLS = 0x20</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_TLSM">
               <h3>
                  XCOFF_R_TLSM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_TLSM = 0x24</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_TLSML">
               <h3>
                  XCOFF_R_TLSML 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_TLSML = 0x25</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_TLS_IE">
               <h3>
                  XCOFF_R_TLS_IE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_TLS_IE = 0x21</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_TLS_LD">
               <h3>
                  XCOFF_R_TLS_LD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_TLS_LD = 0x22</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_TLS_LE">
               <h3>
                  XCOFF_R_TLS_LE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_TLS_LE = 0x23</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_TOC">
               <h3>
                  XCOFF_R_TOC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_TOC = 0x03</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_TOCL">
               <h3>
                  XCOFF_R_TOCL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_TOCL = 0x31</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_TOCU">
               <h3>
                  XCOFF_R_TOCU 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_TOCU = 0x30</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_TRL">
               <h3>
                  XCOFF_R_TRL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_TRL = 0x12</code></pre>
            </article>
            
            <article class="global" data-name="XCOFF_R_TRLA">
               <h3>
                  XCOFF_R_TRLA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const XCOFF_R_TRLA = 0x13</code></pre>
            </article>
            
            <article class="global" data-name="XFT_CD">
               <h3>
                  XFT_CD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Xftype field</p>
               
               <pre><code>const XFT_CD = 128</code></pre>
            </article>
            
            <article class="global" data-name="XFT_CT">
               <h3>
                  XFT_CT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Xftype field</p>
               
               <pre><code>const XFT_CT = 1</code></pre>
            </article>
            
            <article class="global" data-name="XFT_CV">
               <h3>
                  XFT_CV 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Xftype field</p>
               
               <pre><code>const XFT_CV = 2</code></pre>
            </article>
            
            <article class="global" data-name="XFT_FN">
               <h3>
                  XFT_FN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Xftype field</p>
               
               <pre><code>const XFT_FN = 0</code></pre>
            </article>
            
            <article class="global" data-name="XMC_BS">
               <h3>
                  XMC_BS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_BS = 9</code></pre>
            </article>
            
            <article class="global" data-name="XMC_DB">
               <h3>
                  XMC_DB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_DB = 2</code></pre>
            </article>
            
            <article class="global" data-name="XMC_DS">
               <h3>
                  XMC_DS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_DS = 10</code></pre>
            </article>
            
            <article class="global" data-name="XMC_GL">
               <h3>
                  XMC_GL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_GL = 6</code></pre>
            </article>
            
            <article class="global" data-name="XMC_PR">
               <h3>
                  XMC_PR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_PR = 0</code></pre>
            </article>
            
            <article class="global" data-name="XMC_RO">
               <h3>
                  XMC_RO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_RO = 1</code></pre>
            </article>
            
            <article class="global" data-name="XMC_RW">
               <h3>
                  XMC_RW 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_RW = 5</code></pre>
            </article>
            
            <article class="global" data-name="XMC_SV">
               <h3>
                  XMC_SV 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_SV = 8</code></pre>
            </article>
            
            <article class="global" data-name="XMC_SV3264">
               <h3>
                  XMC_SV3264 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_SV3264 = 18</code></pre>
            </article>
            
            <article class="global" data-name="XMC_SV64">
               <h3>
                  XMC_SV64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_SV64 = 17</code></pre>
            </article>
            
            <article class="global" data-name="XMC_TC">
               <h3>
                  XMC_TC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_TC = 3</code></pre>
            </article>
            
            <article class="global" data-name="XMC_TC0">
               <h3>
                  XMC_TC0 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_TC0 = 15</code></pre>
            </article>
            
            <article class="global" data-name="XMC_TD">
               <h3>
                  XMC_TD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_TD = 16</code></pre>
            </article>
            
            <article class="global" data-name="XMC_TE">
               <h3>
                  XMC_TE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_TE = 22</code></pre>
            </article>
            
            <article class="global" data-name="XMC_TL">
               <h3>
                  XMC_TL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_TL = 20</code></pre>
            </article>
            
            <article class="global" data-name="XMC_UA">
               <h3>
                  XMC_UA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_UA = 4</code></pre>
            </article>
            
            <article class="global" data-name="XMC_UC">
               <h3>
                  XMC_UC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_UC = 11</code></pre>
            </article>
            
            <article class="global" data-name="XMC_UL">
               <h3>
                  XMC_UL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_UL = 21</code></pre>
            </article>
            
            <article class="global" data-name="XMC_XO">
               <h3>
                  XMC_XO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Storage-mapping class.</p>
               
               <pre><code>const XMC_XO = 7</code></pre>
            </article>
            
            <article class="global" data-name="XTY_CM">
               <h3>
                  XTY_CM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Symbol type field.</p>
               
               <pre><code>const XTY_CM = 3</code></pre>
            </article>
            
            <article class="global" data-name="XTY_ENT">
               <h3>
                  XTY_ENT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Symbol type field.</p>
               
               <pre><code>const XTY_ENT = 0x20</code></pre>
            </article>
            
            <article class="global" data-name="XTY_ER">
               <h3>
                  XTY_ER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Symbol type field.</p>
               
               <pre><code>const XTY_ER = 0</code></pre>
            </article>
            
            <article class="global" data-name="XTY_EXP">
               <h3>
                  XTY_EXP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Symbol type field.</p>
               
               <pre><code>const XTY_EXP = 0x10</code></pre>
            </article>
            
            <article class="global" data-name="XTY_IMP">
               <h3>
                  XTY_IMP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Symbol type field.</p>
               
               <pre><code>const XTY_IMP = 0x40</code></pre>
            </article>
            
            <article class="global" data-name="XTY_LD">
               <h3>
                  XTY_LD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Symbol type field.</p>
               
               <pre><code>const XTY_LD = 2</code></pre>
            </article>
            
            <article class="global" data-name="XTY_SD">
               <h3>
                  XTY_SD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Symbol type field.</p>
               
               <pre><code>const XTY_SD = 1</code></pre>
            </article>
            
            <article class="global" data-name="XTY_WK">
               <h3>
                  XTY_WK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Symbol type field.</p>
               
               <pre><code>const XTY_WK = 0x8</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ = fmt.Print</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _ markKind = iota</code></pre>
            </article>
            
            <article class="global" data-name="_AUX_CSECT">
               <h3>
                  _AUX_CSECT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Auxiliary type</p>
               
               <pre><code>const _AUX_CSECT = 251</code></pre>
            </article>
            
            <article class="global" data-name="_AUX_EXCEPT">
               <h3>
                  _AUX_EXCEPT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Auxiliary type</p>
               
               <pre><code>const _AUX_EXCEPT = 255</code></pre>
            </article>
            
            <article class="global" data-name="_AUX_FCN">
               <h3>
                  _AUX_FCN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Auxiliary type</p>
               
               <pre><code>const _AUX_FCN = 254</code></pre>
            </article>
            
            <article class="global" data-name="_AUX_FILE">
               <h3>
                  _AUX_FILE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Auxiliary type</p>
               
               <pre><code>const _AUX_FILE = 252</code></pre>
            </article>
            
            <article class="global" data-name="_AUX_SECT">
               <h3>
                  _AUX_SECT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Auxiliary type</p>
               
               <pre><code>const _AUX_SECT = 250</code></pre>
            </article>
            
            <article class="global" data-name="_AUX_SYM">
               <h3>
                  _AUX_SYM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Auxiliary type</p>
               
               <pre><code>const _AUX_SYM = 253</code></pre>
            </article>
            
            <article class="global" data-name="abiInternalVer">
               <h3>
                  abiInternalVer 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Symbol version of ABIInternal symbols. It is sym.SymVerABIInternal if ABI wrappers
are used, 0 otherwise.</p>
               
               <pre><code>var abiInternalVer = sym.SymVerABIInternal</code></pre>
            </article>
            
            <article class="global" data-name="atExitFuncs">
               <h3>
                  atExitFuncs 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var atExitFuncs []func()</code></pre>
            </article>
            
            <article class="global" data-name="benchmarkFileFlag">
               <h3>
                  benchmarkFileFlag 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var benchmarkFileFlag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="benchmarkFlag">
               <h3>
                  benchmarkFlag 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var benchmarkFlag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="blockSize">
               <h3>
                  blockSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const blockSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="buildinfo">
               <h3>
                  buildinfo 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var buildinfo []byte</code></pre>
            </article>
            
            <article class="global" data-name="checkStrictDups">
               <h3>
                  checkStrictDups 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>See -strictdups command line flag.</p>
               
               <pre><code>var checkStrictDups int</code></pre>
            </article>
            
            <article class="global" data-name="covCounterDataLen">
               <h3>
                  covCounterDataLen 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var covCounterDataLen uint64</code></pre>
            </article>
            
            <article class="global" data-name="covCounterDataStartOff">
               <h3>
                  covCounterDataStartOff 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var covCounterDataStartOff uint64</code></pre>
            </article>
            
            <article class="global" data-name="cpuprofile">
               <h3>
                  cpuprofile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var cpuprofile = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="createTrivialCOnce">
               <h3>
                  createTrivialCOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var createTrivialCOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="currDwscnoff">
               <h3>
                  currDwscnoff 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var currDwscnoff = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="currSymSrcFile">
               <h3>
                  currSymSrcFile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var currSymSrcFile xcoffSymSrcFile</code></pre>
            </article>
            
            <article class="global" data-name="cutoff">
               <h3>
                  cutoff 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>cutoff is the maximum data section size permitted by the linker
(see issue #9862).</p>
               
               <pre><code>const cutoff = 2e9</code></pre>
            </article>
            
            <article class="global" data-name="dataAlignmentFactor">
               <h3>
                  dataAlignmentFactor 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>*  Emit .debug_frame</p>
               
               <pre><code>const dataAlignmentFactor = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="debugGCProg">
               <h3>
                  debugGCProg 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const debugGCProg = false</code></pre>
            </article>
            
            <article class="global" data-name="debug_s">
               <h3>
                  debug_s 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var debug_s bool</code></pre>
            </article>
            
            <article class="global" data-name="dexport">
               <h3>
                  dexport 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var dexport []loader.Sym</code></pre>
            </article>
            
            <article class="global" data-name="dosstub">
               <h3>
                  dosstub 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>DOS stub that prints out
"This program cannot be run in DOS mode."
See IMAGE_DOS_HEADER in the Windows SDK for the format of the header used here.</p>
               
               <pre><code>var dosstub = []uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="dr">
               <h3>
                  dr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var dr *Dll</code></pre>
            </article>
            
            <article class="global" data-name="dwarfp">
               <h3>
                  dwarfp 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>dwarfp stores the collected DWARF symbols created during
dwarf generation.</p>
               
               <pre><code>var dwarfp []dwarfSecInfo</code></pre>
            </article>
            
            <article class="global" data-name="dwsectCUSize">
               <h3>
                  dwsectCUSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var dwsectCUSize map[string]uint64</code></pre>
            </article>
            
            <article class="global" data-name="dwsectCUSizeMu">
               <h3>
                  dwsectCUSizeMu 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>On AIX, the symbol table needs to know where are the compilation units parts
for a specific package in each .dw section.
dwsectCUSize map will save the size of a compilation unit for
the corresponding .dw section.
This size can later be retrieved with the index "sectionName.pkgName".</p>
               
               <pre><code>var dwsectCUSizeMu sync.Mutex</code></pre>
            </article>
            
            <article class="global" data-name="dwtypes">
               <h3>
                  dwtypes 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var dwtypes dwarf.DWDie</code></pre>
            </article>
            
            <article class="global" data-name="dylib">
               <h3>
                  dylib 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var dylib []string</code></pre>
            </article>
            
            <article class="global" data-name="dynimportfail">
               <h3>
                  dynimportfail 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>dynimportfail is a list of packages for which generating
the dynimport file, _cgo_import.go, failed. If there are
any of these objects, we must link externally. Issue 52863.</p>
               
               <pre><code>var dynimportfail []string</code></pre>
            </article>
            
            <article class="global" data-name="dynlib">
               <h3>
                  dynlib 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var dynlib []string</code></pre>
            </article>
            
            <article class="global" data-name="ehdr">
               <h3>
                  ehdr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ehdr ElfEhdr</code></pre>
            </article>
            
            <article class="global" data-name="elf64">
               <h3>
                  elf64 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var elf64 bool</code></pre>
            </article>
            
            <article class="global" data-name="elfRelType">
               <h3>
                  elfRelType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Either ".rel" or ".rela" depending on which type of relocation the
target platform uses.</p>
               
               <pre><code>var elfRelType string</code></pre>
            </article>
            
            <article class="global" data-name="elfglobalsymndx">
               <h3>
                  elfglobalsymndx 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var elfglobalsymndx int</code></pre>
            </article>
            
            <article class="global" data-name="elfshstrdat">
               <h3>
                  elfshstrdat 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var elfshstrdat []byte</code></pre>
            </article>
            
            <article class="global" data-name="elfstr">
               <h3>
                  elfstr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var elfstr [100]Elfstring</code></pre>
            </article>
            
            <article class="global" data-name="elfstrdat">
               <h3>
                  elfstrdat 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var elfstrdat []byte</code></pre>
            </article>
            
            <article class="global" data-name="elfverneed">
               <h3>
                  elfverneed 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var elfverneed int</code></pre>
            </article>
            
            <article class="global" data-name="enableFIPS">
               <h3>
                  enableFIPS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const enableFIPS = true</code></pre>
            </article>
            
            <article class="global" data-name="errNoFallocate">
               <h3>
                  errNoFallocate 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>If fallocate is not supported on this platform, return this error. The error
is ignored where needed, and OutBuf writes to heap memory.</p>
               
               <pre><code>var errNoFallocate = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="externalobj">
               <h3>
                  externalobj 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>externalobj is set to true if we see an object compiled by
the host compiler that is not from a package that is known
to support internal linking mode.</p>
               
               <pre><code>var externalobj = false</code></pre>
            </article>
            
            <article class="global" data-name="fipsMagic">
               <h3>
                  fipsMagic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fipsMagic = "\xff Go fipsinfo \xff\x00"</code></pre>
            </article>
            
            <article class="global" data-name="fipsMagicLen">
               <h3>
                  fipsMagicLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fipsMagicLen = 16</code></pre>
            </article>
            
            <article class="global" data-name="fipsSumLen">
               <h3>
                  fipsSumLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fipsSumLen = 32</code></pre>
            </article>
            
            <article class="global" data-name="fipsSyms">
               <h3>
                  fipsSyms 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>fipsSyms are the special FIPS section bracketing symbols.</p>
               
               <pre><code>var fipsSyms = []struct{...}{...}</code></pre>
            </article>
            
            <article class="global" data-name="fipsinfo">
               <h3>
                  fipsinfo 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>fipsinfo is the loader symbol for go:fipsinfo.</p>
               
               <pre><code>var fipsinfo loader.Sym</code></pre>
            </article>
            
            <article class="global" data-name="flag8">
               <h3>
                  flag8 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flag8 bool</code></pre>
            </article>
            
            <article class="global" data-name="flagA">
               <h3>
                  flagA 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagA = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagAsan">
               <h3>
                  flagAsan 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagAsan = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagAslr">
               <h3>
                  flagAslr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagAslr = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagBindNow">
               <h3>
                  flagBindNow 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagBindNow = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagBuildid">
               <h3>
                  flagBuildid 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagBuildid = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagCaptureHostObjs">
               <h3>
                  flagCaptureHostObjs 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagCaptureHostObjs = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagCheckLinkname">
               <h3>
                  flagCheckLinkname 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagCheckLinkname = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagDebugNosplit">
               <h3>
                  flagDebugNosplit 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagDebugNosplit = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagDumpDep">
               <h3>
                  flagDumpDep 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagDumpDep = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagEntrySymbol">
               <h3>
                  flagEntrySymbol 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagEntrySymbol = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagExtar">
               <h3>
                  flagExtar 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagExtar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagExtld">
               <h3>
                  flagExtld 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagExtld quoted.Flag</code></pre>
            </article>
            
            <article class="global" data-name="flagExtldflags">
               <h3>
                  flagExtldflags 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagExtldflags quoted.Flag</code></pre>
            </article>
            
            <article class="global" data-name="flagF">
               <h3>
                  flagF 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagF = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagFieldTrack">
               <h3>
                  flagFieldTrack 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagFieldTrack = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagFipso">
               <h3>
                  flagFipso 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagFipso = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagG">
               <h3>
                  flagG 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagG = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagH">
               <h3>
                  flagH 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagH = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagHostBuildid">
               <h3>
                  flagHostBuildid 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagHostBuildid = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagInstallSuffix">
               <h3>
                  flagInstallSuffix 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagInstallSuffix = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagInterpreter">
               <h3>
                  flagInterpreter 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagInterpreter = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagLibGCC">
               <h3>
                  flagLibGCC 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagLibGCC = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagMsan">
               <h3>
                  flagMsan 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagMsan = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagN">
               <h3>
                  flagN 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagN = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagOutfile">
               <h3>
                  flagOutfile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagOutfile = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagPluginPath">
               <h3>
                  flagPluginPath 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagPluginPath = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagPruneWeakMap">
               <h3>
                  flagPruneWeakMap 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagPruneWeakMap = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagRace">
               <h3>
                  flagRace 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagRace = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagRandLayout">
               <h3>
                  flagRandLayout 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagRandLayout = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagTmpdir">
               <h3>
                  flagTmpdir 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagTmpdir = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagW">
               <h3>
                  flagW 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var flagW ternaryFlag</code></pre>
            </article>
            
            <article class="global" data-name="funcSize">
               <h3>
                  funcSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const funcSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="gdbscript">
               <h3>
                  gdbscript 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var gdbscript string</code></pre>
            </article>
            
            <article class="global" data-name="havedynamic">
               <h3>
                  havedynamic 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var havedynamic int</code></pre>
            </article>
            
            <article class="global" data-name="hostobj">
               <h3>
                  hostobj 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var hostobj []Hostobj</code></pre>
            </article>
            
            <article class="global" data-name="hostobjcounter">
               <h3>
                  hostobjcounter 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var hostobjcounter int</code></pre>
            </article>
            
            <article class="global" data-name="internalpkg">
               <h3>
                  internalpkg 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>These packages can use internal linking mode.
Others trigger external mode.</p>
               
               <pre><code>var internalpkg = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="interp">
               <h3>
                  interp 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var interp string</code></pre>
            </article>
            
            <article class="global" data-name="interpreter">
               <h3>
                  interpreter 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var interpreter string</code></pre>
            </article>
            
            <article class="global" data-name="isLabel">
               <h3>
                  isLabel 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var isLabel = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="iscgo">
               <h3>
                  iscgo 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var iscgo bool</code></pre>
            </article>
            
            <article class="global" data-name="lcSize">
               <h3>
                  lcSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var lcSize int32</code></pre>
            </article>
            
            <article class="global" data-name="ldflag">
               <h3>
                  ldflag 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ldflag []string</code></pre>
            </article>
            
            <article class="global" data-name="linkoff">
               <h3>
                  linkoff 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var linkoff int64</code></pre>
            </article>
            
            <article class="global" data-name="liveness">
               <h3>
                  liveness 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var liveness int64</code></pre>
            </article>
            
            <article class="global" data-name="load">
               <h3>
                  load 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var load []MachoLoad</code></pre>
            </article>
            
            <article class="global" data-name="loadBudget">
               <h3>
                  loadBudget 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Amount of space left for adding load commands
that refer to dynamic libraries. Because these have
to go in the Mach-O header, we can't just pick a
"big enough" header size. The initial header is
one page, the non-dynamic library stuff takes
up about 1300 bytes; we overestimate that as 2k.</p>
               
               <pre><code>var loadBudget = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="machoHeaderSize64">
               <h3>
                  machoHeaderSize64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const machoHeaderSize64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="machoPlatform">
               <h3>
                  machoPlatform 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var machoPlatform MachoPlatform</code></pre>
            </article>
            
            <article class="global" data-name="machobind">
               <h3>
                  machobind 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var machobind []machoBindRecord</code></pre>
            </article>
            
            <article class="global" data-name="machohdr">
               <h3>
                  machohdr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var machohdr MachoHdr</code></pre>
            </article>
            
            <article class="global" data-name="machorebase">
               <h3>
                  machorebase 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var machorebase []machoRebaseRecord</code></pre>
            </article>
            
            <article class="global" data-name="maxOutBufHeapLen">
               <h3>
                  maxOutBufHeapLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>maxOutBufHeapLen limits the growth of the heap area.</p>
               
               <pre><code>const maxOutBufHeapLen = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="memprofile">
               <h3>
                  memprofile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var memprofile = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="memprofilerate">
               <h3>
                  memprofilerate 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Flags used by the linker. The exported flags are used by the architecture-specific packages.</p>
               
               <pre><code>var memprofilerate = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ndebug">
               <h3>
                  ndebug 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ndebug int</code></pre>
            </article>
            
            <article class="global" data-name="nelfstr">
               <h3>
                  nelfstr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nelfstr int</code></pre>
            </article>
            
            <article class="global" data-name="nerrors">
               <h3>
                  nerrors 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nerrors int</code></pre>
            </article>
            
            <article class="global" data-name="nkind">
               <h3>
                  nkind 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nkind [NumSymKind]int</code></pre>
            </article>
            
            <article class="global" data-name="nsect">
               <h3>
                  nsect 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nsect int</code></pre>
            </article>
            
            <article class="global" data-name="nseg">
               <h3>
                  nseg 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nseg int</code></pre>
            </article>
            
            <article class="global" data-name="nsortsym">
               <h3>
                  nsortsym 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nsortsym int</code></pre>
            </article>
            
            <article class="global" data-name="outbufMode">
               <h3>
                  outbufMode 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const outbufMode = 0775</code></pre>
            </article>
            
            <article class="global" data-name="outerSymSize">
               <h3>
                  outerSymSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var outerSymSize = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ownTmpDir">
               <h3>
                  ownTmpDir 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ownTmpDir bool</code></pre>
            </article>
            
            <article class="global" data-name="pe64">
               <h3>
                  pe64 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var pe64 int</code></pre>
            </article>
            
            <article class="global" data-name="pefile">
               <h3>
                  pefile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var pefile peFile</code></pre>
            </article>
            
            <article class="global" data-name="phdr">
               <h3>
                  phdr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var phdr [NSECT]*ElfPhdr</code></pre>
            </article>
            
            <article class="global" data-name="pkgdef">
               <h3>
                  pkgdef 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const pkgdef = "__.PKGDEF"</code></pre>
            </article>
            
            <article class="global" data-name="pkglistfornote">
               <h3>
                  pkglistfornote 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var pkglistfornote []byte</code></pre>
            </article>
            
            <article class="global" data-name="preferlinkext">
               <h3>
                  preferlinkext 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>preferlinkext is a list of packages for which the Go command
noticed use of peculiar C flags. If we see any of these,
default to linking externally unless overridden by the
user. See issues #58619, #58620, and #58848.</p>
               
               <pre><code>var preferlinkext []string</code></pre>
            </article>
            
            <article class="global" data-name="prototypedies">
               <h3>
                  prototypedies 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var prototypedies map[string]*dwarf.DWDie</code></pre>
            </article>
            
            <article class="global" data-name="rpath">
               <h3>
                  rpath 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var rpath Rpath</code></pre>
            </article>
            
            <article class="global" data-name="rsrcsyms">
               <h3>
                  rsrcsyms 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var rsrcsyms []loader.Sym</code></pre>
            </article>
            
            <article class="global" data-name="seenlib">
               <h3>
                  seenlib 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var seenlib = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="seg">
               <h3>
                  seg 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var seg [16]MachoSeg</code></pre>
            </article>
            
            <article class="global" data-name="sehp">
               <h3>
                  sehp 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var sehp struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="shdr">
               <h3>
                  shdr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var shdr [NSECT]*ElfShdr</code></pre>
            </article>
            
            <article class="global" data-name="sortsym">
               <h3>
                  sortsym 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var sortsym []loader.Sym</code></pre>
            </article>
            
            <article class="global" data-name="spSize">
               <h3>
                  spSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var spSize int32</code></pre>
            </article>
            
            <article class="global" data-name="stackCheckCycle">
               <h3>
                  stackCheckCycle 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>stackCheckCycle is a sentinel stored in the height map to detect if
we've found a cycle. This is effectively an "infinite" stack
height, so we use the closest value to infinity that we can.</p>
               
               <pre><code>const stackCheckCycle int16 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="stackCheckIndirect">
               <h3>
                  stackCheckIndirect 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>stackCheckIndirect is a sentinel Sym value used to represent the
target of an indirect/closure call.</p>
               
               <pre><code>const stackCheckIndirect loader.Sym = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="strdata">
               <h3>
                  strdata 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var strdata = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="strictDupMsgCount">
               <h3>
                  strictDupMsgCount 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var strictDupMsgCount int</code></pre>
            </article>
            
            <article class="global" data-name="strnames">
               <h3>
                  strnames 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var strnames []string</code></pre>
            </article>
            
            <article class="global" data-name="symSize">
               <h3>
                  symSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var symSize int32</code></pre>
            </article>
            
            <article class="global" data-name="syscallExecSupported">
               <h3>
                  syscallExecSupported 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const syscallExecSupported = true</code></pre>
            </article>
            
            <article class="global" data-name="syscallExecSupported">
               <h3>
                  syscallExecSupported 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const syscallExecSupported = false</code></pre>
            </article>
            
            <article class="global" data-name="ternaryFlagFalse">
               <h3>
                  ternaryFlagFalse 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ternaryFlagFalse</code></pre>
            </article>
            
            <article class="global" data-name="ternaryFlagTrue">
               <h3>
                  ternaryFlagTrue 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ternaryFlagTrue</code></pre>
            </article>
            
            <article class="global" data-name="ternaryFlagUnset">
               <h3>
                  ternaryFlagUnset 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ternaryFlagUnset ternaryFlag = iota</code></pre>
            </article>
            
            <article class="global" data-name="thearch">
               <h3>
                  thearch 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var thearch Arch</code></pre>
            </article>
            
            <article class="global" data-name="theline">
               <h3>
                  theline 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var theline string</code></pre>
            </article>
            
            <article class="global" data-name="unknownObjFormat">
               <h3>
                  unknownObjFormat 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>unknownObjFormat is set to true if we see an object whose
format we don't recognize.</p>
               
               <pre><code>var unknownObjFormat = false</code></pre>
            </article>
            
            <article class="global" data-name="viewCloseError">
               <h3>
                  viewCloseError 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var viewCloseError = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="viewError">
               <h3>
                  viewError 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var viewError = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="visited">
               <h3>
                  visited 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const visited</code></pre>
            </article>
            
            <article class="global" data-name="visiting">
               <h3>
                  visiting 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const visiting</code></pre>
            </article>
            
            <article class="global" data-name="wantHdr">
               <h3>
                  wantHdr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var wantHdr = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="wasmMinDataAddr">
               <h3>
                  wasmMinDataAddr 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>On Wasm, we reserve 4096 bytes for zero page, then 8192 bytes for wasm_exec.js
to store command line args and environment variables.
Data sections starts from at least address 12288.
Keep in sync with wasm_exec.js.</p>
               
               <pre><code>const wasmMinDataAddr = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="windowsgui">
               <h3>
                  windowsgui 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var windowsgui bool</code></pre>
            </article>
            
            <article class="global" data-name="xfile">
               <h3>
                  xfile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Var used by XCOFF Generation algorithms</p>
               
               <pre><code>var xfile xcoffFile</code></pre>
            </article>
            
            <article class="global" data-name="zeros">
               <h3>
                  zeros 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var zeros [512]byte</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="BuildMode">
               <h3>
                  BuildMode
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A BuildMode indicates the sort of object we are building.
Possible build modes are the same as those for the -buildmode flag
in cmd/go, and are documented in 'go help buildmode'.</p>
               
               <pre><code>type BuildMode uint8</code></pre>
            </article>
            
            <article class="type" data-name="ElfEhdr">
               <h3>
                  ElfEhdr
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>* ELF header.</p>
               
               <pre><code>type ElfEhdr elf.Header64</code></pre>
            </article>
            
            <article class="type" data-name="ElfPhdr">
               <h3>
                  ElfPhdr
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>* Program header.</p>
               
               <pre><code>type ElfPhdr elf.ProgHeader</code></pre>
            </article>
            
            <article class="type" data-name="LinkMode">
               <h3>
                  LinkMode
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>LinkMode indicates whether an external linker is used for the final link.</p>
               
               <pre><code>type LinkMode uint8</code></pre>
            </article>
            
            <article class="type" data-name="MachoPlatform">
               <h3>
                  MachoPlatform
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type MachoPlatform int</code></pre>
            </article>
            
            <article class="type" data-name="SymbolType">
               <h3>
                  SymbolType
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type SymbolType int8</code></pre>
            </article>
            
            <article class="type" data-name="archiveMap">
               <h3>
                  archiveMap
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>archiveMap is an archive symbol map: a mapping from symbol name to
offset within the archive file.</p>
               
               <pre><code>type archiveMap map[string]uint64</code></pre>
            </article>
            
            <article class="type" data-name="dwSym">
               <h3>
                  dwSym
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>dwSym wraps a loader.Sym; this type is meant to obey the interface
rules for dwarf.Sym from the cmd/internal/dwarf package. DwDie and
DwAttr objects contain references to symbols via this type.</p>
               
               <pre><code>type dwSym loader.Sym</code></pre>
            </article>
            
            <article class="type" data-name="generatorFunc">
               <h3>
                  generatorFunc
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>generatorFunc is a convenience type.
Some linker-created Symbols are large and shouldn't really live in the heap.
Such Symbols can define a generator function. Their bytes can be generated
directly in the output mmap.
Relocations are applied prior to emitting generator Symbol contents.
Generator Symbols that require relocations can be written in two passes.
The first pass, at Symbol creation time, adds only relocations.
The second pass, at content generation time, adds the rest.
See generateFunctab for an example.
Generator functions shouldn't grow the Symbol size.
Generator functions must be safe for concurrent use.
Generator Symbols have their Data set to the mmapped area when the
generator is called.</p>
               
               <pre><code>type generatorFunc func(*Link, loader.Sym)</code></pre>
            </article>
            
            <article class="type" data-name="heap">
               <h3>
                  heap
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type heap []loader.Sym</code></pre>
            </article>
            
            <article class="type" data-name="lexHeap">
               <h3>
                  lexHeap
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Same as heap, but sorts alphabetically instead of by index.
(Note that performance is not so critical here, as it is
in the case above. Some simplification might be in order.)</p>
               
               <pre><code>type lexHeap []loader.Sym</code></pre>
            </article>
            
            <article class="type" data-name="machoUpdateFunc">
               <h3>
                  machoUpdateFunc
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type machoUpdateFunc func(ctxt *Link, exef *os.File, exem *macho.File, outexe string) error</code></pre>
            </article>
            
            <article class="type" data-name="markKind">
               <h3>
                  markKind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type markKind uint8</code></pre>
            </article>
            
            <article class="type" data-name="pePages">
               <h3>
                  pePages
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>pePages is a type used to store the list of pages for which there
are base relocation blocks. This is defined as a type so that
it can be sorted.</p>
               
               <pre><code>type pePages []uint32</code></pre>
            </article>
            
            <article class="type" data-name="shlibRelocs">
               <h3>
                  shlibRelocs
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type shlibRelocs []shlibReloc</code></pre>
            </article>
            
            <article class="type" data-name="symNameFn">
               <h3>
                  symNameFn
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type symNameFn func(s loader.Sym) string</code></pre>
            </article>
            
            <article class="type" data-name="ternaryFlag">
               <h3>
                  ternaryFlag
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>ternaryFlag is like a boolean flag, but has a default value that is
neither true nor false, allowing it to be set from context (e.g. from another
flag).
*ternaryFlag implements flag.Value.</p>
               
               <pre><code>type ternaryFlag int</code></pre>
            </article>
            
            <article class="type" data-name="writeFn">
               <h3>
                  writeFn
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type writeFn func(*Link, *OutBuf, int64, int64)</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="xcoffSym">
               <h3>
                  xcoffSym
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Type representing all XCOFF symbols.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type xcoffSym interface {

}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="ArHdr">
               <h3>
                  ArHdr
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ArHdr struct {
name string
date string
uid string
gid string
mode string
size string
fmag string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Arch">
               <h3>
                  Arch
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Arch struct {
Funcalign int
Maxalign int
Minalign int
Dwarfregsp int
Dwarfreglr int
TrampLimit uint64
CodePad []byte
Plan9Magic uint32
Plan9_64Bit bool
Adddynrel func(*Target, *loader.Loader, *ArchSyms, loader.Sym, loader.Reloc, int) bool
Archinit func(*Link)
Archreloc func(*Target, *loader.Loader, *ArchSyms, loader.Reloc, loader.Sym, int64) (relocatedOffset int64, nExtReloc int, ok bool)
Archrelocvariant func(target *Target, ldr *loader.Loader, rel loader.Reloc, rv sym.RelocVariant, sym loader.Sym, offset int64, data []byte) relocatedOffset int64
Trampoline func(ctxt *Link, ldr *loader.Loader, ri int, rs loader.Sym, s loader.Sym)
Asmb func(*Link, *loader.Loader)
Asmb2 func(*Link, *loader.Loader)
Extreloc func(*Target, *loader.Loader, loader.Reloc, loader.Sym) (loader.ExtReloc, bool)
Gentext func(*Link, *loader.Loader)
Machoreloc1 func(*sys.Arch, *OutBuf, *loader.Loader, loader.Sym, loader.ExtReloc, int64) bool
MachorelocSize uint32
PEreloc1 func(*sys.Arch, *OutBuf, *loader.Loader, loader.Sym, loader.ExtReloc, int64) bool
Xcoffreloc1 func(*sys.Arch, *OutBuf, *loader.Loader, loader.Sym, loader.ExtReloc, int64) bool
GenSymsLate func(*Link, *loader.Loader)
TLSIEtoLE func(P []byte, off int, size int)
AssignAddress func(ldr *loader.Loader, sect *sym.Section, n int, s loader.Sym, va uint64, isTramp bool) (*sym.Section, int, uint64)
ELF ELFArch
}</code></pre>
            </article>
            
            <article class="struct" data-name="ArchSyms">
               <h3>
                  ArchSyms
                  <span class="badge">struct</span>
               </h3>
               
               <p>ArchSyms holds a number of architecture specific symbols used during
relocation.  Rather than allowing them universal access to all symbols,
we keep a subset for relocation application.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ArchSyms struct {
Rel loader.Sym
Rela loader.Sym
RelPLT loader.Sym
RelaPLT loader.Sym
LinkEditGOT loader.Sym
LinkEditPLT loader.Sym
TOC loader.Sym
DotTOC []loader.Sym
GOT loader.Sym
PLT loader.Sym
GOTPLT loader.Sym
Tlsg loader.Sym
Tlsoffset int
Dynamic loader.Sym
DynSym loader.Sym
DynStr loader.Sym
unreachableMethod loader.Sym
mainInittasks loader.Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="Dll">
               <h3>
                  Dll
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Dll struct {
name string
nameoff uint64
thunkoff uint64
ms *Imp
next *Dll
}</code></pre>
            </article>
            
            <article class="struct" data-name="ELFArch">
               <h3>
                  ELFArch
                  <span class="badge">struct</span>
               </h3>
               
               <p>ELFArch includes target-specific hooks for ELF targets.
This is initialized by the target-specific Init function
called by the linker's main function in cmd/link/main.go.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ELFArch struct {
Androiddynld string
Linuxdynld string
LinuxdynldMusl string
Freebsddynld string
Netbsddynld string
Openbsddynld string
Dragonflydynld string
Solarisdynld string
Reloc1 func(*Link, *OutBuf, *loader.Loader, loader.Sym, loader.ExtReloc, int, int64) bool
RelocSize uint32
SetupPLT func(ctxt *Link, ldr *loader.Loader, plt *loader.SymbolBuilder, gotplt *loader.SymbolBuilder, dynamic loader.Sym)
DynamicReadOnly bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="ElfShdr">
               <h3>
                  ElfShdr
                  <span class="badge">struct</span>
               </h3>
               
               <p>* Section header.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ElfShdr struct {
elf.Section64
shnum elf.SectionIndex
}</code></pre>
            </article>
            
            <article class="struct" data-name="Elfaux">
               <h3>
                  Elfaux
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Elfaux struct {
next *Elfaux
num int
vers string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Elflib">
               <h3>
                  Elflib
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Elflib struct {
next *Elflib
aux *Elfaux
file string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Elfstring">
               <h3>
                  Elfstring
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Elfstring struct {
s string
off int
}</code></pre>
            </article>
            
            <article class="struct" data-name="ErrorReporter">
               <h3>
                  ErrorReporter
                  <span class="badge">struct</span>
               </h3>
               
               <p>ErrorReporter is used to make error reporting thread safe.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ErrorReporter struct {
loader.ErrorReporter
unresSyms map[unresolvedSymKey]bool
unresMutex sync.Mutex
SymName symNameFn
}</code></pre>
            </article>
            
            <article class="struct" data-name="GCProg">
               <h3>
                  GCProg
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type GCProg struct {
ctxt *Link
sym *loader.SymbolBuilder
w gcprog.Writer
}</code></pre>
            </article>
            
            <article class="struct" data-name="Hostobj">
               <h3>
                  Hostobj
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Hostobj struct {
ld func(*Link, *bio.Reader, string, int64, string)
pkg string
pn string
file string
off int64
length int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="IMAGE_EXPORT_DIRECTORY">
               <h3>
                  IMAGE_EXPORT_DIRECTORY
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type IMAGE_EXPORT_DIRECTORY struct {
Characteristics uint32
TimeDateStamp uint32
MajorVersion uint16
MinorVersion uint16
Name uint32
Base uint32
NumberOfFunctions uint32
NumberOfNames uint32
AddressOfFunctions uint32
AddressOfNames uint32
AddressOfNameOrdinals uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="IMAGE_IMPORT_DESCRIPTOR">
               <h3>
                  IMAGE_IMPORT_DESCRIPTOR
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type IMAGE_IMPORT_DESCRIPTOR struct {
OriginalFirstThunk uint32
TimeDateStamp uint32
ForwarderChain uint32
Name uint32
FirstThunk uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="Imp">
               <h3>
                  Imp
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Imp struct {
s loader.Sym
off uint64
next *Imp
argsize int
}</code></pre>
            </article>
            
            <article class="struct" data-name="Link">
               <h3>
                  Link
                  <span class="badge">struct</span>
               </h3>
               
               <p>Link holds the context for writing object code from a compiler
or for reading that input into the linker.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Link struct {
Target
ErrorReporter
ArchSyms
outSem chan int
Out *OutBuf
version int
Debugvlog int
Bso *bufio.Writer
Loaded bool
compressDWARF bool
Libdir []string
Library []*sym.Library
LibraryByPkg map[string]*sym.Library
Shlibs []Shlib
Textp []loader.Sym
Moduledata loader.Sym
PackageFile map[string]string
PackageShlib map[string]string
tramps []loader.Sym
compUnits []*sym.CompilationUnit
runtimeCU *sym.CompilationUnit
loader *loader.Loader
cgodata []cgodata
datap []loader.Sym
dynexp []loader.Sym
numelfsym int
generatorSyms map[loader.Sym]generatorFunc
}</code></pre>
            </article>
            
            <article class="struct" data-name="MachoHdr">
               <h3>
                  MachoHdr
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MachoHdr struct {
cpu uint32
subcpu uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="MachoLoad">
               <h3>
                  MachoLoad
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MachoLoad struct {
type_ uint32
data []uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="MachoPlatformLoad">
               <h3>
                  MachoPlatformLoad
                  <span class="badge">struct</span>
               </h3>
               
               <p>MachoPlatformLoad represents a LC_VERSION_MIN_* or
LC_BUILD_VERSION load command.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MachoPlatformLoad struct {
platform MachoPlatform
cmd MachoLoad
}</code></pre>
            </article>
            
            <article class="struct" data-name="MachoSect">
               <h3>
                  MachoSect
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MachoSect struct {
name string
segname string
addr uint64
size uint64
off uint32
align uint32
reloc uint32
nreloc uint32
flag uint32
res1 uint32
res2 uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="MachoSeg">
               <h3>
                  MachoSeg
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MachoSeg struct {
name string
vsize uint64
vaddr uint64
fileoffset uint64
filesize uint64
prot1 uint32
prot2 uint32
nsect uint32
msect uint32
sect []MachoSect
flag uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="OutBuf">
               <h3>
                  OutBuf
                  <span class="badge">struct</span>
               </h3>
               
               <p>OutBuf is a buffered file writer.
It is similar to the Writer in cmd/internal/bio with a few small differences.
First, it tracks the output architecture and uses it to provide
endian helpers.
Second, it provides a very cheap offset counter that doesn't require
any system calls to read the value.
Third, it also mmaps the output file (if available). The intended usage is:
- Mmap the output file
- Write the content
- possibly apply any edits in the output buffer
- possibly write more content to the file. These writes take place in a heap
backed buffer that will get synced to disk.
- Munmap the output file
And finally, it provides a mechanism by which you can multithread the
writing of output files. This mechanism is accomplished by copying a OutBuf,
and using it in the thread/goroutine.
Parallel OutBuf is intended to be used like:
func write(out *OutBuf) {
var wg sync.WaitGroup
for i := 0; i < 10; i++ {
wg.Add(1)
view, err := out.View(start[i])
if err != nil {
// handle output
continue
}
go func(out *OutBuf, i int) {
// do output
wg.Done()
}(view, i)
}
wg.Wait()
}</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type OutBuf struct {
arch *sys.Arch
off int64
buf []byte
heap []byte
name string
f *os.File
encbuf [8]byte
isView bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="Rpath">
               <h3>
                  Rpath
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Rpath struct {
set bool
val string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Shlib">
               <h3>
                  Shlib
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Shlib struct {
Path string
Hash []byte
Deps []string
File *elf.File
symAddr map[string]uint64
relocTarget map[uint64]string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Target">
               <h3>
                  Target
                  <span class="badge">struct</span>
               </h3>
               
               <p>Target holds the configuration we're building for.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Target struct {
Arch *sys.Arch
HeadType objabi.HeadType
LinkMode LinkMode
BuildMode BuildMode
linkShared bool
canUsePlugins bool
IsELF bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="XcoffAoutHdr64">
               <h3>
                  XcoffAoutHdr64
                  <span class="badge">struct</span>
               </h3>
               
               <p>Auxiliary Header</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type XcoffAoutHdr64 struct {
Omagic int16
Ovstamp int16
Odebugger uint32
Otextstart uint64
Odatastart uint64
Otoc uint64
Osnentry int16
Osntext int16
Osndata int16
Osntoc int16
Osnloader int16
Osnbss int16
Oalgntext int16
Oalgndata int16
Omodtype [2]byte
Ocpuflag uint8
Ocputype uint8
Otextpsize uint8
Odatapsize uint8
Ostackpsize uint8
Oflags uint8
Otsize uint64
Odsize uint64
Obsize uint64
Oentry uint64
Omaxstack uint64
Omaxdata uint64
Osntdata int16
Osntbss int16
Ox64flags uint16
Oresv3a int16
Oresv3 [2]int32
}</code></pre>
            </article>
            
            <article class="struct" data-name="XcoffAuxCSect64">
               <h3>
                  XcoffAuxCSect64
                  <span class="badge">struct</span>
               </h3>
               
               <p>csect Auxiliary Entry.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type XcoffAuxCSect64 struct {
Xscnlenlo uint32
Xparmhash uint32
Xsnhash uint16
Xsmtyp uint8
Xsmclas uint8
Xscnlenhi uint32
Xpad uint8
Xauxtype uint8
}</code></pre>
            </article>
            
            <article class="struct" data-name="XcoffAuxDWARF64">
               <h3>
                  XcoffAuxDWARF64
                  <span class="badge">struct</span>
               </h3>
               
               <p>DWARF Auxiliary Entry</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type XcoffAuxDWARF64 struct {
Xscnlen uint64
X_pad [9]byte
Xauxtype uint8
}</code></pre>
            </article>
            
            <article class="struct" data-name="XcoffAuxFcn64">
               <h3>
                  XcoffAuxFcn64
                  <span class="badge">struct</span>
               </h3>
               
               <p>Function Auxiliary Entry</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type XcoffAuxFcn64 struct {
Xlnnoptr uint64
Xfsize uint32
Xendndx uint32
Xpad uint8
Xauxtype uint8
}</code></pre>
            </article>
            
            <article class="struct" data-name="XcoffAuxFile64">
               <h3>
                  XcoffAuxFile64
                  <span class="badge">struct</span>
               </h3>
               
               <p>File Auxiliary Entry</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type XcoffAuxFile64 struct {
Xzeroes uint32
Xoffset uint32
X_pad1 [6]byte
Xftype uint8
X_pad2 [2]byte
Xauxtype uint8
}</code></pre>
            </article>
            
            <article class="struct" data-name="XcoffFileHdr64">
               <h3>
                  XcoffFileHdr64
                  <span class="badge">struct</span>
               </h3>
               
               <p>File Header</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type XcoffFileHdr64 struct {
Fmagic uint16
Fnscns uint16
Ftimedat int32
Fsymptr uint64
Fopthdr uint16
Fflags uint16
Fnsyms int32
}</code></pre>
            </article>
            
            <article class="struct" data-name="XcoffLdHdr64">
               <h3>
                  XcoffLdHdr64
                  <span class="badge">struct</span>
               </h3>
               
               <p>Loader Header</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type XcoffLdHdr64 struct {
Lversion int32
Lnsyms int32
Lnreloc int32
Listlen uint32
Lnimpid int32
Lstlen uint32
Limpoff uint64
Lstoff uint64
Lsymoff uint64
Lrldoff uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="XcoffLdImportFile64">
               <h3>
                  XcoffLdImportFile64
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type XcoffLdImportFile64 struct {
Limpidpath string
Limpidbase string
Limpidmem string
}</code></pre>
            </article>
            
            <article class="struct" data-name="XcoffLdRel64">
               <h3>
                  XcoffLdRel64
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type XcoffLdRel64 struct {
Lvaddr uint64
Lrtype uint16
Lrsecnm int16
Lsymndx int32
}</code></pre>
            </article>
            
            <article class="struct" data-name="XcoffLdStr64">
               <h3>
                  XcoffLdStr64
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type XcoffLdStr64 struct {
size uint16
name string
}</code></pre>
            </article>
            
            <article class="struct" data-name="XcoffLdSym64">
               <h3>
                  XcoffLdSym64
                  <span class="badge">struct</span>
               </h3>
               
               <p>Loader Symbol</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type XcoffLdSym64 struct {
Lvalue uint64
Loffset uint32
Lscnum int16
Lsmtype int8
Lsmclas int8
Lifile int32
Lparm uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="XcoffScnHdr64">
               <h3>
                  XcoffScnHdr64
                  <span class="badge">struct</span>
               </h3>
               
               <p>Section Header</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type XcoffScnHdr64 struct {
Sname [8]byte
Spaddr uint64
Svaddr uint64
Ssize uint64
Sscnptr uint64
Srelptr uint64
Slnnoptr uint64
Snreloc uint32
Snlnno uint32
Sflags uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="XcoffSymEnt64">
               <h3>
                  XcoffSymEnt64
                  <span class="badge">struct</span>
               </h3>
               
               <p>Symbol Table Entry</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type XcoffSymEnt64 struct {
Nvalue uint64
Noffset uint32
Nscnum int16
Ntype uint16
Nsclass uint8
Nnumaux int8
}</code></pre>
            </article>
            
            <article class="struct" data-name="cgodata">
               <h3>
                  cgodata
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type cgodata struct {
file string
pkg string
directives [][]string
}</code></pre>
            </article>
            
            <article class="struct" data-name="deadcodePass">
               <h3>
                  deadcodePass
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type deadcodePass struct {
ctxt *Link
ldr *loader.Loader
wq heap
ifaceMethod map[methodsig]bool
genericIfaceMethod map[string]bool
markableMethods []methodref
reflectSeen bool
dynlink bool
methodsigstmp []methodsig
pkginits []loader.Sym
mapinitnoop loader.Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="dodataState">
               <h3>
                  dodataState
                  <span class="badge">struct</span>
               </h3>
               
               <p>dodataState holds bits of state information needed by dodata() and the
various helpers it calls. The lifetime of these items should not extend
past the end of dodata().</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dodataState struct {
ctxt *Link
data [sym.SXREF][]loader.Sym
dataMaxAlign [sym.SXREF]int32
symGroupType []sym.SymKind
datsize int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="dwUnitSyms">
               <h3>
                  dwUnitSyms
                  <span class="badge">struct</span>
               </h3>
               
               <p>dwUnitSyms stores input and output symbols for DWARF generation
for a given compilation unit.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dwUnitSyms struct {
lineProlog loader.Sym
rangeProlog loader.Sym
infoEpilog loader.Sym
linesyms []loader.Sym
infosyms []loader.Sym
locsyms []loader.Sym
rangessyms []loader.Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="dwarfSecInfo">
               <h3>
                  dwarfSecInfo
                  <span class="badge">struct</span>
               </h3>
               
               <p>dwarfSecInfo holds information about a DWARF output section,
specifically a section symbol and a list of symbols contained in
that section. On the syms list, the first symbol will always be the
section symbol, then any remaining symbols (if any) will be
sub-symbols in that section. Note that for some sections (eg:
.debug_abbrev), the section symbol is all there is (all content is
contained in it). For other sections (eg: .debug_info), the section
symbol is empty and all the content is in the sub-symbols. Finally
there are some sections (eg: .debug_ranges) where it is a mix (both
the section symbol and the sub-symbols have content)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dwarfSecInfo struct {
syms []loader.Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="dwctxt">
               <h3>
                  dwctxt
                  <span class="badge">struct</span>
               </h3>
               
               <p>dwctxt is a wrapper intended to satisfy the method set of
dwarf.Context, so that functions like dwarf.PutAttrs will work with
DIEs that use loader.Sym as opposed to *sym.Symbol. It is also
being used as a place to store tables/maps that are useful as part
of type conversion (this is just a convenience; it would be easy to
split these things out into another type if need be).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dwctxt struct {
linkctxt *Link
ldr *loader.Loader
arch *sys.Arch
tmap map[string]loader.Sym
rtmap map[loader.Sym]loader.Sym
tdmap map[loader.Sym]loader.Sym
typeRuntimeEface loader.Sym
typeRuntimeIface loader.Sym
uintptrInfoSym loader.Sym
dwmu *sync.Mutex
}</code></pre>
            </article>
            
            <article class="struct" data-name="dyldInfoCmd">
               <h3>
                  dyldInfoCmd
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dyldInfoCmd struct {
Cmd macho.LoadCmd
Len uint32
RebaseOff uint32
RebaseLen uint32
BindOff uint32
BindLen uint32
WeakBindOff uint32
WeakBindLen uint32
LazyBindOff uint32
LazyBindLen uint32
ExportOff uint32
ExportLen uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="elfNote">
               <h3>
                  elfNote
                  <span class="badge">struct</span>
               </h3>
               
               <p>* Note header.  The ".note" section contains an array of notes.  Each
 * begins with this header, aligned to a word boundary.  Immediately
 * following the note header is n_namesz bytes of name, padded to the
 * next word boundary.  Then comes n_descsz bytes of descriptor, again
 * padded to a word boundary.  The values of n_namesz and n_descsz do
 * not include the padding.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type elfNote struct {
nNamesz uint32
nDescsz uint32
nType uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="encryptionInfoCmd">
               <h3>
                  encryptionInfoCmd
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type encryptionInfoCmd struct {
Cmd macho.LoadCmd
Len uint32
CryptOff uint32
CryptLen uint32
CryptId uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="fipsObj">
               <h3>
                  fipsObj
                  <span class="badge">struct</span>
               </h3>
               
               <p>fipsObj calculates the fips object hash and optionally writes
the hashed content to a file for debugging.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fipsObj struct {
r io.ReaderAt
w io.Writer
wf *os.File
h hash.Hash
tmp [8]byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="linkEditDataCmd">
               <h3>
                  linkEditDataCmd
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type linkEditDataCmd struct {
Cmd macho.LoadCmd
Len uint32
DataOff uint32
DataLen uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="machoBindRecord">
               <h3>
                  machoBindRecord
                  <span class="badge">struct</span>
               </h3>
               
               <p>A bind entry tells the dynamic linker the data at GOT+off should be bound
to the address of the target symbol, which is a dynamic import.
For now, the only kind of entry we support is that the data is an absolute
address, and the source symbol is always the GOT. That seems all we need.
In the binary it uses a compact stateful bytecode encoding. So we record
entries as we go and build the table at the end.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type machoBindRecord struct {
off int64
targ loader.Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="machoRebaseRecord">
               <h3>
                  machoRebaseRecord
                  <span class="badge">struct</span>
               </h3>
               
               <p>A rebase entry tells the dynamic linker the data at sym+off needs to be
relocated when the in-memory image moves. (This is somewhat like, say,
ELF R_X86_64_RELATIVE).
For now, the only kind of entry we support is that the data is an absolute
address. That seems all we need.
In the binary it uses a compact stateful bytecode encoding. So we record
entries as we go and build the table at the end.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type machoRebaseRecord struct {
sym loader.Sym
off int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="methodref">
               <h3>
                  methodref
                  <span class="badge">struct</span>
               </h3>
               
               <p>methodref holds the relocations from a receiver type symbol to its
method. There are three relocations, one for each of the fields in
the reflect.method struct: mtyp, ifn, and tfn.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type methodref struct {
m methodsig
src loader.Sym
r int
}</code></pre>
            </article>
            
            <article class="struct" data-name="methodsig">
               <h3>
                  methodsig
                  <span class="badge">struct</span>
               </h3>
               
               <p>methodsig is a typed method signature (name + type).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type methodsig struct {
name string
typ loader.Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="pclntab">
               <h3>
                  pclntab
                  <span class="badge">struct</span>
               </h3>
               
               <p>pclntab holds the state needed for pclntab generation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pclntab struct {
firstFunc loader.Sym
lastFunc loader.Sym
size int64
carrier loader.Sym
pclntab loader.Sym
pcheader loader.Sym
funcnametab loader.Sym
findfunctab loader.Sym
cutab loader.Sym
filetab loader.Sym
pctab loader.Sym
nfunc int32
nfiles uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="peBaseRelocBlock">
               <h3>
                  peBaseRelocBlock
                  <span class="badge">struct</span>
               </h3>
               
               <p>peBaseRelocBlock represents a Base Relocation Block. A block
is a collection of relocation entries in a page, where each
entry describes a single relocation.
The block page RVA (Relative Virtual Address) is the index
into peBaseRelocTable.blocks.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type peBaseRelocBlock struct {
entries []peBaseRelocEntry
}</code></pre>
            </article>
            
            <article class="struct" data-name="peBaseRelocEntry">
               <h3>
                  peBaseRelocEntry
                  <span class="badge">struct</span>
               </h3>
               
               <p>peBaseRelocEntry represents a single relocation entry.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type peBaseRelocEntry struct {
typeOff uint16
}</code></pre>
            </article>
            
            <article class="struct" data-name="peBaseRelocTable">
               <h3>
                  peBaseRelocTable
                  <span class="badge">struct</span>
               </h3>
               
               <p>A PE base relocation table is a list of blocks, where each block
contains relocation information for a single page. The blocks
must be emitted in order of page virtual address.
See https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format#the-reloc-section-image-only</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type peBaseRelocTable struct {
blocks map[uint32]peBaseRelocBlock
pages pePages
}</code></pre>
            </article>
            
            <article class="struct" data-name="peFile">
               <h3>
                  peFile
                  <span class="badge">struct</span>
               </h3>
               
               <p>peFile is used to build COFF file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type peFile struct {
sections []*peSection
stringTable peStringTable
textSect *peSection
rdataSect *peSection
dataSect *peSection
bssSect *peSection
ctorsSect *peSection
pdataSect *peSection
xdataSect *peSection
nextSectOffset uint32
nextFileOffset uint32
symtabOffset int64
symbolCount int
dataDirectory [16]pe.DataDirectory
}</code></pre>
            </article>
            
            <article class="struct" data-name="peSection">
               <h3>
                  peSection
                  <span class="badge">struct</span>
               </h3>
               
               <p>peSection represents section from COFF section table.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type peSection struct {
name string
shortName string
index int
virtualSize uint32
virtualAddress uint32
sizeOfRawData uint32
pointerToRawData uint32
pointerToRelocations uint32
numberOfRelocations uint16
characteristics uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="peStringTable">
               <h3>
                  peStringTable
                  <span class="badge">struct</span>
               </h3>
               
               <p>peStringTable is a COFF string table.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type peStringTable struct {
strings []string
stringsLen int
}</code></pre>
            </article>
            
            <article class="struct" data-name="relocSymState">
               <h3>
                  relocSymState
                  <span class="badge">struct</span>
               </h3>
               
               <p>relocSymState hold state information needed when making a series of
successive calls to relocsym(). The items here are invariant
(meaning that they are set up once initially and then don't change
during the execution of relocsym), with the exception of a slice
used to facilitate batch allocation of external relocations. Calls
to relocsym happen in parallel; the assumption is that each
parallel thread will have its own state object.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type relocSymState struct {
target *Target
ldr *loader.Loader
err *ErrorReporter
syms *ArchSyms
}</code></pre>
            </article>
            
            <article class="struct" data-name="shlibReloc">
               <h3>
                  shlibReloc
                  <span class="badge">struct</span>
               </h3>
               
               <p>A relocation that applies to part of the shared library.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type shlibReloc struct {
addr uint64
target string
}</code></pre>
            </article>
            
            <article class="struct" data-name="stackCheck">
               <h3>
                  stackCheck
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type stackCheck struct {
ctxt *Link
ldr *loader.Loader
morestack loader.Sym
callSize int
height map[loader.Sym]int16
graph map[loader.Sym][]stackCheckEdge
}</code></pre>
            </article>
            
            <article class="struct" data-name="stackCheckChain">
               <h3>
                  stackCheckChain
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type stackCheckChain struct {
stackCheckEdge
printed bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="stackCheckEdge">
               <h3>
                  stackCheckEdge
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type stackCheckEdge struct {
growth int
target loader.Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="symNameSize">
               <h3>
                  symNameSize
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type symNameSize struct {
name string
sz int64
val int64
sym loader.Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="typelinkSortKey">
               <h3>
                  typelinkSortKey
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type typelinkSortKey struct {
TypeStr string
Type loader.Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="unresolvedSymKey">
               <h3>
                  unresolvedSymKey
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type unresolvedSymKey struct {
from loader.Sym
to loader.Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="uuidCmd">
               <h3>
                  uuidCmd
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type uuidCmd struct {
Cmd macho.LoadCmd
Len uint32
Uuid [16]byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="xcoffFile">
               <h3>
                  xcoffFile
                  <span class="badge">struct</span>
               </h3>
               
               <p>xcoffFile is used to build XCOFF file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type xcoffFile struct {
xfhdr XcoffFileHdr64
xahdr XcoffAoutHdr64
sections []*XcoffScnHdr64
sectText *XcoffScnHdr64
sectData *XcoffScnHdr64
sectBss *XcoffScnHdr64
stringTable xcoffStringTable
sectNameToScnum map[string]int16
loaderSize uint64
symtabOffset int64
symbolCount uint32
symtabSym []xcoffSym
dynLibraries map[string]int
loaderSymbols []*xcoffLoaderSymbol
loaderReloc []*xcoffLoaderReloc
sync.Mutex
}</code></pre>
            </article>
            
            <article class="struct" data-name="xcoffLoaderReloc">
               <h3>
                  xcoffLoaderReloc
                  <span class="badge">struct</span>
               </h3>
               
               <p>xcoffLoaderReloc holds information about a relocation made by the loader.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type xcoffLoaderReloc struct {
sym loader.Sym
roff int32
rtype uint16
symndx int32
}</code></pre>
            </article>
            
            <article class="struct" data-name="xcoffLoaderSymbol">
               <h3>
                  xcoffLoaderSymbol
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type xcoffLoaderSymbol struct {
sym loader.Sym
smtype int8
smclas int8
}</code></pre>
            </article>
            
            <article class="struct" data-name="xcoffStringTable">
               <h3>
                  xcoffStringTable
                  <span class="badge">struct</span>
               </h3>
               
               <p>xcoffStringTable is a XCOFF string table.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type xcoffStringTable struct {
strings []string
stringsLen int
}</code></pre>
            </article>
            
            <article class="struct" data-name="xcoffSymSrcFile">
               <h3>
                  xcoffSymSrcFile
                  <span class="badge">struct</span>
               </h3>
               
               <p>type records C_FILE information needed for genasmsym in XCOFF.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type xcoffSymSrcFile struct {
name string
file *XcoffSymEnt64
csectAux *XcoffAuxCSect64
csectSymNb uint64
csectVAStart int64
csectVAEnd int64
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="AddAddress">
               <h3>
                  AddAddress 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c dwctxt) AddAddress(s dwarf.Sym, data interface{}, value int64)</code></pre>
            </article>
            
            <article class="function" data-name="AddBytes">
               <h3>
                  AddBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c dwctxt) AddBytes(s dwarf.Sym, b []byte)</code></pre>
            </article>
            
            <article class="function" data-name="AddCURelativeAddress">
               <h3>
                  AddCURelativeAddress 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c dwctxt) AddCURelativeAddress(s dwarf.Sym, data interface{}, value int64)</code></pre>
            </article>
            
            <article class="function" data-name="AddDWARFAddrSectionOffset">
               <h3>
                  AddDWARFAddrSectionOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c dwctxt) AddDWARFAddrSectionOffset(s dwarf.Sym, t interface{}, ofs int64)</code></pre>
            </article>
            
            <article class="function" data-name="AddGotSym">
               <h3>
                  AddGotSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func AddGotSym(target *Target, ldr *loader.Loader, syms *ArchSyms, s loader.Sym, elfRelocTyp uint32)</code></pre>
            </article>
            
            <article class="function" data-name="AddInt">
               <h3>
                  AddInt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c dwctxt) AddInt(s dwarf.Sym, size int, i int64)</code></pre>
            </article>
            
            <article class="function" data-name="AddMachoSym">
               <h3>
                  AddMachoSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AddMachoSym adds s to Mach-O symbol table, used in GenSymLate.
Currently only used on ARM64 when external linking.</p>
               
               <pre><code>func AddMachoSym(ldr *loader.Loader, s loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="AddPELabelSym">
               <h3>
                  AddPELabelSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func AddPELabelSym(ldr *loader.Loader, s loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="AddSectionOffset">
               <h3>
                  AddSectionOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c dwctxt) AddSectionOffset(s dwarf.Sym, size int, t interface{}, ofs int64)</code></pre>
            </article>
            
            <article class="function" data-name="AddString">
               <h3>
                  AddString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c dwctxt) AddString(s dwarf.Sym, v string)</code></pre>
            </article>
            
            <article class="function" data-name="AddSym">
               <h3>
                  AddSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *GCProg) AddSym(s loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="AddTramp">
               <h3>
                  AddTramp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>add a trampoline with symbol s (to be laid down after the current function)</p>
               
               <pre><code>func (ctxt *Link) AddTramp(s *loader.SymbolBuilder, typ sym.SymKind)</code></pre>
            </article>
            
            <article class="function" data-name="AddType">
               <h3>
                  AddType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add to the gc program the ptr bits for the type typ at
byte offset off in the region being described.
The type must have a pointer in it.</p>
               
               <pre><code>func (p *GCProg) AddType(off int64, typ loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="Adddynsym">
               <h3>
                  Adddynsym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func Adddynsym(ldr *loader.Loader, target *Target, syms *ArchSyms, s loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="Asmbelfsetup">
               <h3>
                  Asmbelfsetup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func Asmbelfsetup()</code></pre>
            </article>
            
            <article class="function" data-name="AtExit">
               <h3>
                  AtExit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func AtExit(f func())</code></pre>
            </article>
            
            <article class="function" data-name="CanUsePlugins">
               <h3>
                  CanUsePlugins 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CanUsePlugins reports whether a plugins can be used</p>
               
               <pre><code>func (ctxt *Link) CanUsePlugins() bool</code></pre>
            </article>
            
            <article class="function" data-name="CanUsePlugins">
               <h3>
                  CanUsePlugins 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) CanUsePlugins() bool</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close closes the fipsObj. In particular it closes the output
object file specified by fipso in the call to [newFipsObj].</p>
               
               <pre><code>func (f *fipsObj) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="CodeblkPad">
               <h3>
                  CodeblkPad 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func CodeblkPad(ctxt *Link, out *OutBuf, addr int64, size int64, pad []byte)</code></pre>
            </article>
            
            <article class="function" data-name="CurrentOffset">
               <h3>
                  CurrentOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c dwctxt) CurrentOffset(s dwarf.Sym) int64</code></pre>
            </article>
            
            <article class="function" data-name="Data">
               <h3>
                  Data 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Data returns the whole written OutBuf as a byte slice.</p>
               
               <pre><code>func (out *OutBuf) Data() []byte</code></pre>
            </article>
            
            <article class="function" data-name="DatblkBytes">
               <h3>
                  DatblkBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Used only on Wasm for now.</p>
               
               <pre><code>func DatblkBytes(ctxt *Link, addr int64, size int64) []byte</code></pre>
            </article>
            
            <article class="function" data-name="DynlinkingGo">
               <h3>
                  DynlinkingGo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DynlinkingGo reports whether we are producing Go code that can live
in separate shared libraries linked together at runtime.</p>
               
               <pre><code>func (ctxt *Link) DynlinkingGo() bool</code></pre>
            </article>
            
            <article class="function" data-name="ElfSymForReloc">
               <h3>
                  ElfSymForReloc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ElfSymForReloc(ctxt *Link, s loader.Sym) int32</code></pre>
            </article>
            
            <article class="function" data-name="Elfinit">
               <h3>
                  Elfinit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Initialize the global variable that describes the ELF header. It will be updated as
we write section and prog headers.</p>
               
               <pre><code>func Elfinit(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="Elfwritedynent">
               <h3>
                  Elfwritedynent 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func Elfwritedynent(arch *sys.Arch, s *loader.SymbolBuilder, tag elf.DynTag, val uint64)</code></pre>
            </article>
            
            <article class="function" data-name="Elfwritedynentsymplus">
               <h3>
                  Elfwritedynentsymplus 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func Elfwritedynentsymplus(ctxt *Link, s *loader.SymbolBuilder, tag elf.DynTag, t loader.Sym, add int64)</code></pre>
            </article>
            
            <article class="function" data-name="End">
               <h3>
                  End 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *GCProg) End(size int64)</code></pre>
            </article>
            
            <article class="function" data-name="Entryvalue">
               <h3>
                  Entryvalue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func Entryvalue(ctxt *Link) int64</code></pre>
            </article>
            
            <article class="function" data-name="ErrorClose">
               <h3>
                  ErrorClose 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ErrorClose closes the output file (if any).
It is supposed to be called only at exit on error, so it doesn't do
any clean up or buffer flushing, just closes the file.</p>
               
               <pre><code>func (out *OutBuf) ErrorClose()</code></pre>
            </article>
            
            <article class="function" data-name="Errorf">
               <h3>
                  Errorf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Errorf method logs an error message.
If more than 20 errors have been printed, exit with an error.
Logging an error means that on exit cmd/link will delete any
output file and return a non-zero error code.</p>
               
               <pre><code>func (ctxt *Link) Errorf(s loader.Sym, format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="Errorf">
               <h3>
                  Errorf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Errorf logs an error message without a specific symbol for context.
Use ctxt.Errorf when possible.
If more than 20 errors have been printed, exit with an error.
Logging an error means that on exit cmd/link will delete any
output file and return a non-zero error code.</p>
               
               <pre><code>func Errorf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="Exit">
               <h3>
                  Exit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Exit exits with code after executing all atExitFuncs.</p>
               
               <pre><code>func Exit(code int)</code></pre>
            </article>
            
            <article class="function" data-name="Exitf">
               <h3>
                  Exitf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Exitf logs an error message then calls Exit(2).</p>
               
               <pre><code>func Exitf(format string, a ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="ExtrelocSimple">
               <h3>
                  ExtrelocSimple 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ExtrelocSimple creates a simple external relocation from r, with the same
symbol and addend.</p>
               
               <pre><code>func ExtrelocSimple(ldr *loader.Loader, r loader.Reloc) loader.ExtReloc</code></pre>
            </article>
            
            <article class="function" data-name="ExtrelocViaOuterSym">
               <h3>
                  ExtrelocViaOuterSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ExtrelocViaOuterSym creates an external relocation from r targeting the
outer symbol and folding the subsymbol's offset into the addend.</p>
               
               <pre><code>func ExtrelocViaOuterSym(ldr *loader.Loader, r loader.Reloc, s loader.Sym) loader.ExtReloc</code></pre>
            </article>
            
            <article class="function" data-name="FoldSubSymbolOffset">
               <h3>
                  FoldSubSymbolOffset 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FoldSubSymbolOffset computes the offset of symbol s to its top-level outer
symbol. Returns the top-level symbol and the offset.
This is used in generating external relocations.</p>
               
               <pre><code>func FoldSubSymbolOffset(ldr *loader.Loader, s loader.Sym) (loader.Sym, int64)</code></pre>
            </article>
            
            <article class="function" data-name="IncVersion">
               <h3>
                  IncVersion 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Allocate a new version (i.e. symbol namespace).</p>
               
               <pre><code>func (ctxt *Link) IncVersion() int</code></pre>
            </article>
            
            <article class="function" data-name="Init">
               <h3>
                  Init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *GCProg) Init(ctxt *Link, name string)</code></pre>
            </article>
            
            <article class="function" data-name="Is386">
               <h3>
                  Is386 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) Is386() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsAIX">
               <h3>
                  IsAIX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsAIX() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsAMD64">
               <h3>
                  IsAMD64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsAMD64() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsARM">
               <h3>
                  IsARM 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsARM() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsARM64">
               <h3>
                  IsARM64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsARM64() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsBigEndian">
               <h3>
                  IsBigEndian 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsBigEndian() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsBoolFlag">
               <h3>
                  IsBoolFlag 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *ternaryFlag) IsBoolFlag() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsDarwin">
               <h3>
                  IsDarwin 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsDarwin() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsDynlinkingGo">
               <h3>
                  IsDynlinkingGo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsDynlinkingGo() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsElf">
               <h3>
                  IsElf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsElf() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsExe">
               <h3>
                  IsExe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsExe() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsExternal">
               <h3>
                  IsExternal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsExternal() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsFreebsd">
               <h3>
                  IsFreebsd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsFreebsd() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsInternal">
               <h3>
                  IsInternal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsInternal() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsLOONG64">
               <h3>
                  IsLOONG64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsLOONG64() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsLinux">
               <h3>
                  IsLinux 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsLinux() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsMIPS">
               <h3>
                  IsMIPS 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsMIPS() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsMIPS64">
               <h3>
                  IsMIPS64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsMIPS64() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsNetbsd">
               <h3>
                  IsNetbsd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsNetbsd() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsOpenbsd">
               <h3>
                  IsOpenbsd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsOpenbsd() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPIE">
               <h3>
                  IsPIE 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsPIE() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPPC64">
               <h3>
                  IsPPC64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsPPC64() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPlan9">
               <h3>
                  IsPlan9 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsPlan9() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPlugin">
               <h3>
                  IsPlugin 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsPlugin() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsRISCV64">
               <h3>
                  IsRISCV64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsRISCV64() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsS390X">
               <h3>
                  IsS390X 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsS390X() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsShared">
               <h3>
                  IsShared 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsShared() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsSharedGoLink">
               <h3>
                  IsSharedGoLink 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsSharedGoLink() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsSolaris">
               <h3>
                  IsSolaris 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsSolaris() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsWasm">
               <h3>
                  IsWasm 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsWasm() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsWindows">
               <h3>
                  IsWindows 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) IsWindows() bool</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s shlibRelocs) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s shlibRelocs) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="Lflag">
               <h3>
                  Lflag 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func Lflag(ctxt *Link, arg string)</code></pre>
            </article>
            
            <article class="function" data-name="Loaderblk">
               <h3>
                  Loaderblk 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Create loader section and returns its size.</p>
               
               <pre><code>func Loaderblk(ctxt *Link, off uint64)</code></pre>
            </article>
            
            <article class="function" data-name="Logf">
               <h3>
                  Logf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) Logf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="Logf">
               <h3>
                  Logf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c dwctxt) Logf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="MachoAddBind">
               <h3>
                  MachoAddBind 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func MachoAddBind(off int64, targ loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="MachoAddRebase">
               <h3>
                  MachoAddRebase 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func MachoAddRebase(s loader.Sym, off int64)</code></pre>
            </article>
            
            <article class="function" data-name="Main">
               <h3>
                  Main 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Main is the main entry point for the linker code.</p>
               
               <pre><code>func Main(arch *sys.Arch, theArch Arch)</code></pre>
            </article>
            
            <article class="function" data-name="MaxVersion">
               <h3>
                  MaxVersion 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>returns the maximum version number</p>
               
               <pre><code>func (ctxt *Link) MaxVersion() int</code></pre>
            </article>
            
            <article class="function" data-name="Mmap">
               <h3>
                  Mmap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Mmap allocates an in-heap output buffer with the given size. It copies
any old data (if any) to the new buffer.</p>
               
               <pre><code>func (out *OutBuf) Mmap(filesize uint64) error</code></pre>
            </article>
            
            <article class="function" data-name="Mmap">
               <h3>
                  Mmap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Mmap maps the output file with the given size. It unmaps the old mapping
if it is already mapped. It also flushes any in-heap data to the new
mapping.</p>
               
               <pre><code>func (out *OutBuf) Mmap(filesize uint64) error</code></pre>
            </article>
            
            <article class="function" data-name="Mmap">
               <h3>
                  Mmap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Mmap maps the output file with the given size. It unmaps the old mapping
if it is already mapped. It also flushes any in-heap data to the new
mapping.</p>
               
               <pre><code>func (out *OutBuf) Mmap(filesize uint64) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="NeedCodeSign">
               <h3>
                  NeedCodeSign 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NeedCodeSign reports whether we need to code-sign the output binary.</p>
               
               <pre><code>func (ctxt *Link) NeedCodeSign() bool</code></pre>
            </article>
            
            <article class="function" data-name="NewOutBuf">
               <h3>
                  NewOutBuf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewOutBuf(arch *sys.Arch) *OutBuf</code></pre>
            </article>
            
            <article class="function" data-name="Offset">
               <h3>
                  Offset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) Offset() int64</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) Open(name string) error</code></pre>
            </article>
            
            <article class="function" data-name="Peinit">
               <h3>
                  Peinit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func Peinit(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="PrepareAddmoduledata">
               <h3>
                  PrepareAddmoduledata 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PrepareAddmoduledata returns a symbol builder that target-specific
code can use to build up the linker-generated go.link.addmoduledata
function, along with the sym for runtime.addmoduledata itself. If
this function is not needed (for example in cases where we're
linking a module that contains the runtime) the returned builder
will be nil.</p>
               
               <pre><code>func PrepareAddmoduledata(ctxt *Link) (*loader.SymbolBuilder, loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="PtrSize">
               <h3>
                  PtrSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c dwctxt) PtrSize() int</code></pre>
            </article>
            
            <article class="function" data-name="RecordChildDieOffsets">
               <h3>
                  RecordChildDieOffsets 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c dwctxt) RecordChildDieOffsets(s dwarf.Sym, vars []*dwarf.Var, offsets []int32)</code></pre>
            </article>
            
            <article class="function" data-name="RecordDclReference">
               <h3>
                  RecordDclReference 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c dwctxt) RecordDclReference(s dwarf.Sym, t dwarf.Sym, dclIdx int, inlIndex int)</code></pre>
            </article>
            
            <article class="function" data-name="Rnd">
               <h3>
                  Rnd 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func Rnd(v int64, r int64) int64</code></pre>
            </article>
            
            <article class="function" data-name="SeekSet">
               <h3>
                  SeekSet 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) SeekSet(p int64)</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Rpath) Set(val string) error</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *ternaryFlag) Set(s string) error</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mode *LinkMode) Set(s string) error</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set implements flag.Value to set the build mode based on the argument
to the -buildmode flag.</p>
               
               <pre><code>func (mode *BuildMode) Set(s string) error</code></pre>
            </article>
            
            <article class="function" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c dwctxt) Size(s dwarf.Sym) int64</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Rpath) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *ternaryFlag) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mode *LinkMode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mode BuildMode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s shlibRelocs) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="UseRelro">
               <h3>
                  UseRelro 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UseRelro reports whether to make use of "read only relocations" aka
relro.</p>
               
               <pre><code>func (t *Target) UseRelro() bool</code></pre>
            </article>
            
            <article class="function" data-name="UsesLibc">
               <h3>
                  UsesLibc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) UsesLibc() bool</code></pre>
            </article>
            
            <article class="function" data-name="View">
               <h3>
                  View 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) View(start uint64) (*OutBuf, error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write writes the contents of v to the buffer.</p>
               
               <pre><code>func (out *OutBuf) Write(v []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Write16">
               <h3>
                  Write16 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) Write16(v uint16)</code></pre>
            </article>
            
            <article class="function" data-name="Write32">
               <h3>
                  Write32 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) Write32(v uint32)</code></pre>
            </article>
            
            <article class="function" data-name="Write32b">
               <h3>
                  Write32b 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) Write32b(v uint32)</code></pre>
            </article>
            
            <article class="function" data-name="Write64">
               <h3>
                  Write64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) Write64(v uint64)</code></pre>
            </article>
            
            <article class="function" data-name="Write64b">
               <h3>
                  Write64b 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) Write64b(v uint64)</code></pre>
            </article>
            
            <article class="function" data-name="Write8">
               <h3>
                  Write8 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) Write8(v uint8)</code></pre>
            </article>
            
            <article class="function" data-name="WriteByte">
               <h3>
                  WriteByte 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteByte is an alias for Write8 to fulfill the io.ByteWriter interface.</p>
               
               <pre><code>func (out *OutBuf) WriteByte(v byte) error</code></pre>
            </article>
            
            <article class="function" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) WriteString(s string)</code></pre>
            </article>
            
            <article class="function" data-name="WriteStringN">
               <h3>
                  WriteStringN 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteStringN writes the first n bytes of s.
If n is larger than len(s) then it is padded with zero bytes.</p>
               
               <pre><code>func (out *OutBuf) WriteStringN(s string, n int)</code></pre>
            </article>
            
            <article class="function" data-name="WriteStringPad">
               <h3>
                  WriteStringPad 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteStringPad writes the first n bytes of s.
If n is larger than len(s) then it is padded with the bytes in pad (repeated as needed).</p>
               
               <pre><code>func (out *OutBuf) WriteStringPad(s string, n int, pad []byte)</code></pre>
            </article>
            
            <article class="function" data-name="WriteSym">
               <h3>
                  WriteSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteSym writes the content of a Symbol, and returns the output buffer
that we just wrote, so we can apply further edit to the symbol content.
For generator symbols, it also sets the symbol's Data to the output
buffer.</p>
               
               <pre><code>func (out *OutBuf) WriteSym(ldr *loader.Loader, s loader.Sym) []byte</code></pre>
            </article>
            
            <article class="function" data-name="Xcoffadddynrel">
               <h3>
                  Xcoffadddynrel 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Xcoffadddynrel adds a dynamic relocation in a XCOFF file.
This relocation will be made by the loader.</p>
               
               <pre><code>func Xcoffadddynrel(target *Target, ldr *loader.Loader, syms *ArchSyms, s loader.Sym, r loader.Reloc, rIdx int) bool</code></pre>
            </article>
            
            <article class="function" data-name="Xcoffinit">
               <h3>
                  Xcoffinit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Xcoffinit initialised some internal value and setups
already known header information.</p>
               
               <pre><code>func Xcoffinit(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>add adds string str to string table t.</p>
               
               <pre><code>func (t *xcoffStringTable) add(str string) int</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>add adds string str to string table t.</p>
               
               <pre><code>func (t *peStringTable) add(str string) int</code></pre>
            </article>
            
            <article class="function" data-name="addDWARF">
               <h3>
                  addDWARF 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addDWARF adds DWARF information to the COFF file f.</p>
               
               <pre><code>func (f *peFile) addDWARF()</code></pre>
            </article>
            
            <article class="function" data-name="addDWARFSection">
               <h3>
                  addDWARFSection 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addDWARFSection adds DWARF section to the COFF file f.
This function is similar to addSection, but DWARF section names are
longer than 8 characters, so they need to be stored in the string table.</p>
               
               <pre><code>func (f *peFile) addDWARFSection(name string, size int) *peSection</code></pre>
            </article>
            
            <article class="function" data-name="addDwarfAddrField">
               <h3>
                  addDwarfAddrField 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addDwarfAddrField adds a DWARF field in DWARF 64bits or 32bits.</p>
               
               <pre><code>func (d *dwctxt) addDwarfAddrField(sb *loader.SymbolBuilder, v uint64)</code></pre>
            </article>
            
            <article class="function" data-name="addDwarfAddrRef">
               <h3>
                  addDwarfAddrRef 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addDwarfAddrRef adds a DWARF pointer in DWARF 64bits or 32bits.</p>
               
               <pre><code>func (d *dwctxt) addDwarfAddrRef(sb *loader.SymbolBuilder, t loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="addDwarfSection">
               <h3>
                  addDwarfSection 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addDwarfSection adds a dwarf section to the XCOFF file f.
This function is similar to addSection, but Dwarf section names
must be modified to conventional names and they are various subtypes.</p>
               
               <pre><code>func (f *xcoffFile) addDwarfSection(s *sym.Section) *XcoffScnHdr64</code></pre>
            </article>
            
            <article class="function" data-name="addDwsectCUSize">
               <h3>
                  addDwsectCUSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addDwsectCUSize(sname string, pkgname string, size uint64)</code></pre>
            </article>
            
            <article class="function" data-name="addGeneratedSym">
               <h3>
                  addGeneratedSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addGeneratedSym adds a generator symbol to pclntab, returning the new Sym.
It is the caller's responsibility to save the symbol in state.</p>
               
               <pre><code>func (state *pclntab) addGeneratedSym(ctxt *Link, name string, size int64, f generatorFunc) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="addImports">
               <h3>
                  addImports 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addImports(ctxt *Link, l *sym.Library, pn string)</code></pre>
            </article>
            
            <article class="function" data-name="addInitArray">
               <h3>
                  addInitArray 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addInitArray adds .ctors COFF section to the file f.</p>
               
               <pre><code>func (f *peFile) addInitArray(ctxt *Link) *peSection</code></pre>
            </article>
            
            <article class="function" data-name="addPEBaseReloc">
               <h3>
                  addPEBaseReloc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addPEBaseReloc(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="addPEBaseRelocSym">
               <h3>
                  addPEBaseRelocSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addPEBaseRelocSym(ldr *loader.Loader, s loader.Sym, rt *peBaseRelocTable)</code></pre>
            </article>
            
            <article class="function" data-name="addSEH">
               <h3>
                  addSEH 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addSEH adds SEH information to the COFF file f.</p>
               
               <pre><code>func (f *peFile) addSEH(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="addSection">
               <h3>
                  addSection 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addSection adds section to the XCOFF file f.</p>
               
               <pre><code>func (f *xcoffFile) addSection(name string, addr uint64, size uint64, fileoff uint64, flags uint32) *XcoffScnHdr64</code></pre>
            </article>
            
            <article class="function" data-name="addSection">
               <h3>
                  addSection 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addSection adds section to the COFF file f.</p>
               
               <pre><code>func (f *peFile) addSection(name string, sectsize int, filesize int) *peSection</code></pre>
            </article>
            
            <article class="function" data-name="addSection">
               <h3>
                  addSection 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addSection adds the section of r (passed to newFipsObj)
starting at byte offset start and ending before byte offset end
to the fips object file.</p>
               
               <pre><code>func (f *fipsObj) addSection(start int64, end int64) error</code></pre>
            </article>
            
            <article class="function" data-name="addSymbol">
               <h3>
                  addSymbol 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addSymbol writes a symbol or an auxiliary symbol entry on ctxt.out.</p>
               
               <pre><code>func (f *xcoffFile) addSymbol(sym xcoffSym)</code></pre>
            </article>
            
            <article class="function" data-name="addbuildinfo">
               <h3>
                  addbuildinfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addbuildinfo(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="adddwarfref">
               <h3>
                  adddwarfref 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) adddwarfref(sb *loader.SymbolBuilder, t loader.Sym, size int)</code></pre>
            </article>
            
            <article class="function" data-name="adddynimpsym">
               <h3>
                  adddynimpsym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>(*xcoffFile)adddynimpsym adds the dynamic symbol "s" to a XCOFF file.
A new symbol named s.Extname() is created to be the actual dynamic symbol
in the .loader section and in the symbol table as an External Reference.
The symbol "s" is transformed to SXCOFFTOC to end up in .data section.
However, there is no writing protection on those symbols and
it might need to be added.
TODO(aix): Handles dynamic symbols without library.</p>
               
               <pre><code>func (f *xcoffFile) adddynimpsym(ctxt *Link, s loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="adddynlib">
               <h3>
                  adddynlib 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func adddynlib(ctxt *Link, lib string)</code></pre>
            </article>
            
            <article class="function" data-name="addelflib">
               <h3>
                  addelflib 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addelflib(list **Elflib, file string, vers string) *Elfaux</code></pre>
            </article>
            
            <article class="function" data-name="addentry">
               <h3>
                  addentry 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rt *peBaseRelocTable) addentry(ldr *loader.Loader, s loader.Sym, r *loader.Reloc)</code></pre>
            </article>
            
            <article class="function" data-name="addexport">
               <h3>
                  addexport 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) addexport()</code></pre>
            </article>
            
            <article class="function" data-name="addexports">
               <h3>
                  addexports 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addexports(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="addgonote">
               <h3>
                  addgonote 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addgonote(ctxt *Link, sectionName string, tag uint32, desc []byte)</code></pre>
            </article>
            
            <article class="function" data-name="addgostring">
               <h3>
                  addgostring 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addgostring adds str, as a Go string value, to s. symname is the name of the
symbol used to define the string data and must be unique per linked object.</p>
               
               <pre><code>func addgostring(ctxt *Link, ldr *loader.Loader, s *loader.SymbolBuilder, symname string, str string)</code></pre>
            </article>
            
            <article class="function" data-name="addimports">
               <h3>
                  addimports 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addimports(ctxt *Link, datsect *peSection)</code></pre>
            </article>
            
            <article class="function" data-name="addinitarrdata">
               <h3>
                  addinitarrdata 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addinitarrdata(ctxt *Link, ldr *loader.Loader, s loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="addlib">
               <h3>
                  addlib 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addlib(ctxt *Link, src string, obj string, lib string, fingerprint goobj.FingerprintType) *sym.Library</code></pre>
            </article>
            
            <article class="function" data-name="addlibpath">
               <h3>
                  addlibpath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>* add library to library list, return added library.
 *	srcref: src file referring to package
 *	objref: object file referring to package
 *	file: object file, e.g., /home/rsc/go/pkg/container/vector.a
 *	pkg: package import path, e.g. container/vector
 *	shlib: path to shared library, or .shlibname file holding path
 *	fingerprint: if not 0, expected fingerprint for import from srcref
 *	             fingerprint is 0 if the library is not imported (e.g. main)</p>
               
               <pre><code>func addlibpath(ctxt *Link, srcref string, objref string, file string, pkg string, shlib string, fingerprint goobj.FingerprintType) *sym.Library</code></pre>
            </article>
            
            <article class="function" data-name="addpersrc">
               <h3>
                  addpersrc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addpersrc(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="address">
               <h3>
                  address 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>address assigns virtual addresses to all segments and sections and
returns all segments in file order.</p>
               
               <pre><code>func (ctxt *Link) address() []*sym.Segment</code></pre>
            </article>
            
            <article class="function" data-name="addsection">
               <h3>
                  addsection 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addsection(ldr *loader.Loader, arch *sys.Arch, seg *sym.Segment, name string, rwx int) *sym.Section</code></pre>
            </article>
            
            <article class="function" data-name="addstrdata">
               <h3>
                  addstrdata 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addstrdata sets the initial value of the string variable name to value.</p>
               
               <pre><code>func addstrdata(arch *sys.Arch, l *loader.Loader, name string, value string)</code></pre>
            </article>
            
            <article class="function" data-name="addstrdata1">
               <h3>
                  addstrdata1 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addstrdata1(ctxt *Link, arg string)</code></pre>
            </article>
            
            <article class="function" data-name="afterErrorAction">
               <h3>
                  afterErrorAction 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>afterErrorAction updates 'nerrors' on error and invokes exit or
panics in the proper circumstances.</p>
               
               <pre><code>func afterErrorAction()</code></pre>
            </article>
            
            <article class="function" data-name="aligndatsize">
               <h3>
                  aligndatsize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func aligndatsize(state *dodataState, datsize int64, s loader.Sym) int64</code></pre>
            </article>
            
            <article class="function" data-name="allocateDataSectionForSym">
               <h3>
                  allocateDataSectionForSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>allocateDataSectionForSym creates a new sym.Section into which a
single symbol will be placed. Here "seg" is the segment into which
the section will go, "s" is the symbol to be placed into the new
section, and "rwx" contains permissions for the section.</p>
               
               <pre><code>func (state *dodataState) allocateDataSectionForSym(seg *sym.Segment, s loader.Sym, rwx int) *sym.Section</code></pre>
            </article>
            
            <article class="function" data-name="allocateDataSections">
               <h3>
                  allocateDataSections 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>allocateDataSections allocates sym.Section objects for data/rodata
(and related) symbols, and then assigns symbols to those sections.</p>
               
               <pre><code>func (state *dodataState) allocateDataSections(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="allocateDwarfSections">
               <h3>
                  allocateDwarfSections 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>allocateDwarfSections allocates sym.Section objects for DWARF
symbols, and assigns symbols to sections.</p>
               
               <pre><code>func (state *dodataState) allocateDwarfSections(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="allocateNamedDataSection">
               <h3>
                  allocateNamedDataSection 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>allocateNamedDataSection creates a new sym.Section for a category
of data symbols. Here "seg" is the segment into which the section
will go, "sName" is the name to give to the section, "types" is a
range of symbol types to be put into the section, and "rwx"
contains permissions for the section.</p>
               
               <pre><code>func (state *dodataState) allocateNamedDataSection(seg *sym.Segment, sName string, types []sym.SymKind, rwx int) *sym.Section</code></pre>
            </article>
            
            <article class="function" data-name="allocateNamedSectionAndAssignSyms">
               <h3>
                  allocateNamedSectionAndAssignSyms 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>allocateNamedSectionAndAssignSyms creates a new section with the
specified name, then walks through the bucketed data symbols with
type 'symn' and assigns each of them to this new section. "Seg" is
the segment into which to place the new section, "secName" is the
name to give to the new section, "forceType" (if non-zero) contains
a new sym type to apply to each sym during the assignment, and
"rwx" holds section permissions.</p>
               
               <pre><code>func (state *dodataState) allocateNamedSectionAndAssignSyms(seg *sym.Segment, secName string, symn sym.SymKind, forceType sym.SymKind, rwx int) *sym.Section</code></pre>
            </article>
            
            <article class="function" data-name="allocateSEHSections">
               <h3>
                  allocateSEHSections 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>allocateSEHSections allocate a sym.Section object for SEH
symbols, and assigns symbols to sections.</p>
               
               <pre><code>func (state *dodataState) allocateSEHSections(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="allocateSingleSymSections">
               <h3>
                  allocateSingleSymSections 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>allocateSingleSymSections walks through the bucketed data symbols
with type 'symn', creates a new section for each sym, and assigns
the sym to a newly created section. Section name is set from the
symbol name. "Seg" is the segment into which to place the new
section, "forceType" is the new sym.SymKind to assign to the symbol
within the section, and "rwx" holds section permissions.</p>
               
               <pre><code>func (state *dodataState) allocateSingleSymSections(seg *sym.Segment, symn sym.SymKind, forceType sym.SymKind, rwx int)</code></pre>
            </article>
            
            <article class="function" data-name="appendPCDeltaCFA">
               <h3>
                  appendPCDeltaCFA 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendPCDeltaCFA appends per-PC CFA deltas to b and returns the final slice.</p>
               
               <pre><code>func appendPCDeltaCFA(arch *sys.Arch, b []byte, deltapc int64, cfa int64) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendString">
               <h3>
                  appendString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendString appends s to data, prefixed by its varint-encoded length.</p>
               
               <pre><code>func appendString(data []byte, s string) []byte</code></pre>
            </article>
            
            <article class="function" data-name="archive">
               <h3>
                  archive 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>archive builds a .a archive from the hostobj object files.</p>
               
               <pre><code>func (ctxt *Link) archive()</code></pre>
            </article>
            
            <article class="function" data-name="artrim">
               <h3>
                  artrim 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func artrim(x []byte) string</code></pre>
            </article>
            
            <article class="function" data-name="asmElfSym">
               <h3>
                  asmElfSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func asmElfSym(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="asmaixsym">
               <h3>
                  asmaixsym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Generate XCOFF Symbol table.
It will be written in out file in Asmbxcoff, because it must be
at the very end, especially after relocation sections which needs symbols' index.</p>
               
               <pre><code>func (f *xcoffFile) asmaixsym(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="asmb">
               <h3>
                  asmb 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Assembling the binary is broken into two steps:
- writing out the code/data/dwarf Segments, applying relocations on the fly
- writing out the architecture specific pieces.
This function handles the first part.</p>
               
               <pre><code>func asmb(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="asmb2">
               <h3>
                  asmb2 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Assembling the binary is broken into two steps:
- writing out the code/data/dwarf Segments
- writing out the architecture specific pieces.
This function handles the second part.</p>
               
               <pre><code>func asmb2(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="asmbElf">
               <h3>
                  asmbElf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func asmbElf(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="asmbMacho">
               <h3>
                  asmbMacho 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func asmbMacho(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="asmbPe">
               <h3>
                  asmbPe 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func asmbPe(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="asmbPlan9">
               <h3>
                  asmbPlan9 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>asmbPlan9 assembles a plan 9 binary.</p>
               
               <pre><code>func asmbPlan9(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="asmbPlan9Sym">
               <h3>
                  asmbPlan9Sym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func asmbPlan9Sym(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="asmbXcoff">
               <h3>
                  asmbXcoff 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Generate XCOFF assembly file.</p>
               
               <pre><code>func asmbXcoff(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="asmbfips">
               <h3>
                  asmbfips 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>asmbfips is called from [asmb] to update go:fipsinfo
when using internal linking.
See [hostlinkfips] for external linking.</p>
               
               <pre><code>func asmbfips(ctxt *Link, fipso string)</code></pre>
            </article>
            
            <article class="function" data-name="assignAddress">
               <h3>
                  assignAddress 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>assigns address for a text symbol, returns (possibly new) section, its number, and the address.</p>
               
               <pre><code>func assignAddress(ctxt *Link, sect *sym.Section, n int, s loader.Sym, va uint64, isTramp bool, big bool) (*sym.Section, int, uint64)</code></pre>
            </article>
            
            <article class="function" data-name="assignDsymsToSection">
               <h3>
                  assignDsymsToSection 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>assignDsymsToSection assigns a collection of data symbols to a
newly created section. "sect" is the section into which to place
the symbols, "syms" holds the list of symbols to assign,
"forceType" (if non-zero) contains a new sym type to apply to each
sym during the assignment, and "aligner" is a hook to call to
handle alignment during the assignment process.</p>
               
               <pre><code>func (state *dodataState) assignDsymsToSection(sect *sym.Section, syms []loader.Sym, forceType sym.SymKind, aligner func(state *dodataState, datsize int64, s loader.Sym) int64)</code></pre>
            </article>
            
            <article class="function" data-name="assignToSection">
               <h3>
                  assignToSection 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (state *dodataState) assignToSection(sect *sym.Section, symn sym.SymKind, forceType sym.SymKind)</code></pre>
            </article>
            
            <article class="function" data-name="atolwhex">
               <h3>
                  atolwhex 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func atolwhex(s string) int64</code></pre>
            </article>
            
            <article class="function" data-name="bgetc">
               <h3>
                  bgetc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func bgetc(r *bio.Reader) int</code></pre>
            </article>
            
            <article class="function" data-name="buildinfo">
               <h3>
                  buildinfo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) buildinfo()</code></pre>
            </article>
            
            <article class="function" data-name="calcCompUnitRanges">
               <h3>
                  calcCompUnitRanges 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>calcCompUnitRanges calculates the PC ranges of the compilation units.</p>
               
               <pre><code>func (d *dwctxt) calcCompUnitRanges()</code></pre>
            </article>
            
            <article class="function" data-name="calculateFunctabSize">
               <h3>
                  calculateFunctabSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>calculateFunctabSize calculates the size of the pclntab, and the offsets in
the output buffer for individual func entries.</p>
               
               <pre><code>func (state pclntab) calculateFunctabSize(ctxt *Link, funcs []loader.Sym) (int64, []uint32)</code></pre>
            </article>
            
            <article class="function" data-name="callgraph">
               <h3>
                  callgraph 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) callgraph()</code></pre>
            </article>
            
            <article class="function" data-name="captureHostObj">
               <h3>
                  captureHostObj 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>captureHostObj writes out the content of a host object (pulled from
an archive or loaded from a *.o file directly) to a directory
specified via the linker's "-capturehostobjs" debugging flag. This
is intended to make it easier for a developer to inspect the actual
object feeding into "CGO internal" link step.</p>
               
               <pre><code>func captureHostObj(h *Hostobj)</code></pre>
            </article>
            
            <article class="function" data-name="check">
               <h3>
                  check 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>check returns the stack height of sym. It populates sc.height and
sc.graph for sym and every function in its call tree.</p>
               
               <pre><code>func (sc *stackCheck) check(sym loader.Sym) int</code></pre>
            </article>
            
            <article class="function" data-name="checkFingerprint">
               <h3>
                  checkFingerprint 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func checkFingerprint(lib *sym.Library, libfp goobj.FingerprintType, src string, srcfp goobj.FingerprintType)</code></pre>
            </article>
            
            <article class="function" data-name="checkOffset">
               <h3>
                  checkOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>checkOffset verifies COFF section sect offset in the file.</p>
               
               <pre><code>func (sect *peSection) checkOffset(off int64)</code></pre>
            </article>
            
            <article class="function" data-name="checkSectSize">
               <h3>
                  checkSectSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func checkSectSize(sect *sym.Section)</code></pre>
            </article>
            
            <article class="function" data-name="checkSegment">
               <h3>
                  checkSegment 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>checkSegment verifies COFF section sect matches address
and file offset provided in segment seg.</p>
               
               <pre><code>func (sect *peSection) checkSegment(seg *sym.Segment)</code></pre>
            </article>
            
            <article class="function" data-name="checkdatsize">
               <h3>
                  checkdatsize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>check accumulated size of data sections</p>
               
               <pre><code>func (state *dodataState) checkdatsize(symn sym.SymKind)</code></pre>
            </article>
            
            <article class="function" data-name="cleanTimeStamps">
               <h3>
                  cleanTimeStamps 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>cleanTimeStamps resets the timestamps for the specified list of
existing files to the Unix epoch (1970-01-01 00:00:00 +0000 UTC).
We take this step in order to help preserve reproducible builds;
this seems to be primarily needed for external linking on Darwin
with later versions of xcode, which (unfortunately) seem to want to
incorporate object file times into the final output file's build
ID. See issue 64947 for the unpleasant details.</p>
               
               <pre><code>func cleanTimeStamps(files []string)</code></pre>
            </article>
            
            <article class="function" data-name="collectUnitLocs">
               <h3>
                  collectUnitLocs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) collectUnitLocs(u *sym.CompilationUnit) []loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="collectmachosyms">
               <h3>
                  collectmachosyms 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func collectmachosyms(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="commonsize">
               <h3>
                  commonsize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func commonsize(arch *sys.Arch) int</code></pre>
            </article>
            
            <article class="function" data-name="compilationUnitByStartPCCmp">
               <h3>
                  compilationUnitByStartPCCmp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func compilationUnitByStartPCCmp(a *sym.CompilationUnit, b *sym.CompilationUnit) int</code></pre>
            </article>
            
            <article class="function" data-name="compressSyms">
               <h3>
                  compressSyms 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>compressSyms compresses syms and returns the contents of the
compressed section. If the section would get larger, it returns nil.</p>
               
               <pre><code>func compressSyms(ctxt *Link, syms []loader.Sym) []byte</code></pre>
            </article>
            
            <article class="function" data-name="computeDeferReturn">
               <h3>
                  computeDeferReturn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func computeDeferReturn(ctxt *Link, deferReturnSym loader.Sym, s loader.Sym) uint32</code></pre>
            </article>
            
            <article class="function" data-name="computeHeight">
               <h3>
                  computeHeight 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>computeHeight returns the stack height of sym. If graph is true, it
also returns the out-edges of sym.
Caching is applied to this in check. Call check instead of calling
this directly.</p>
               
               <pre><code>func (sc *stackCheck) computeHeight(sym loader.Sym, graph bool) (int, []stackCheckEdge)</code></pre>
            </article>
            
            <article class="function" data-name="computeTLSOffset">
               <h3>
                  computeTLSOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>computeTLSOffset records the thread-local storage offset.
Not used for Android where the TLS offset is determined at runtime.</p>
               
               <pre><code>func (ctxt *Link) computeTLSOffset()</code></pre>
            </article>
            
            <article class="function" data-name="copyHeap">
               <h3>
                  copyHeap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>copyHeap copies the heap to the mmapped section of memory, returning true if
a copy takes place.</p>
               
               <pre><code>func (out *OutBuf) copyHeap() bool</code></pre>
            </article>
            
            <article class="function" data-name="copychildren">
               <h3>
                  copychildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) copychildren(ctxt *Link, dst *dwarf.DWDie, src *dwarf.DWDie)</code></pre>
            </article>
            
            <article class="function" data-name="copychildrenexcept">
               <h3>
                  copychildrenexcept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Copies src's children into dst. Copies attributes by value.
DWAttr.data is copied as pointer only. If except is one of
the top-level children, it will not be copied.</p>
               
               <pre><code>func (d *dwctxt) copychildrenexcept(ctxt *Link, dst *dwarf.DWDie, src *dwarf.DWDie, except *dwarf.DWDie)</code></pre>
            </article>
            
            <article class="function" data-name="createGeneratorSymbol">
               <h3>
                  createGeneratorSymbol 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>createGeneratorSymbol is a convenience method for creating a generator
symbol.</p>
               
               <pre><code>func (ctxt *Link) createGeneratorSymbol(name string, version int, t sym.SymKind, size int64, gen generatorFunc) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="createUnitLength">
               <h3>
                  createUnitLength 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>createUnitLength creates the initial length field with value v and update
offset of unit_length if needed.</p>
               
               <pre><code>func (d *dwctxt) createUnitLength(su *loader.SymbolBuilder, v uint64)</code></pre>
            </article>
            
            <article class="function" data-name="datblk">
               <h3>
                  datblk 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func datblk(ctxt *Link, out *OutBuf, addr int64, size int64)</code></pre>
            </article>
            
            <article class="function" data-name="datoff">
               <h3>
                  datoff 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func datoff(ldr *loader.Loader, s loader.Sym, addr int64) int64</code></pre>
            </article>
            
            <article class="function" data-name="deadcode">
               <h3>
                  deadcode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>deadcode marks all reachable symbols.
The basis of the dead code elimination is a flood fill of symbols,
following their relocations, beginning at *flagEntrySymbol.
This flood fill is wrapped in logic for pruning unused methods.
All methods are mentioned by relocations on their receiver's *rtype.
These relocations are specially defined as R_METHODOFF by the compiler
so we can detect and manipulated them here.
There are three ways a method of a reachable type can be invoked:
1. direct call
2. through a reachable interface type
3. reflect.Value.Method (or MethodByName), or reflect.Type.Method
(or MethodByName)
The first case is handled by the flood fill, a directly called method
is marked as reachable.
The second case is handled by decomposing all reachable interface
types into method signatures. Each encountered method is compared
against the interface method signatures, if it matches it is marked
as reachable. This is extremely conservative, but easy and correct.
The third case is handled by looking for functions that compiler flagged
as REFLECTMETHOD. REFLECTMETHOD on a function F means that F does a method
lookup with reflection, but the compiler was not able to statically determine
the method name.
All functions that call reflect.Value.Method or reflect.Type.Method are REFLECTMETHODs.
Functions that call reflect.Value.MethodByName or reflect.Type.MethodByName with
a non-constant argument are REFLECTMETHODs, too. If we find a REFLECTMETHOD,
we give up on static analysis, and mark all exported methods of all reachable
types as reachable.
If the argument to MethodByName is a compile-time constant, the compiler
emits a relocation with the method name. Matching methods are kept in all
reachable types.
Any unreached text symbols are removed from ctxt.Textp.</p>
               
               <pre><code>func deadcode(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="decodeGenericIfaceMethod">
               <h3>
                  decodeGenericIfaceMethod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Decode the method name stored in symbol symIdx. The symbol should contain just the bytes of a method name.</p>
               
               <pre><code>func (d *deadcodePass) decodeGenericIfaceMethod(ldr *loader.Loader, symIdx loader.Sym) string</code></pre>
            </article>
            
            <article class="function" data-name="decodeIfaceMethod">
               <h3>
                  decodeIfaceMethod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Decode the method of interface type symbol symIdx at offset off.</p>
               
               <pre><code>func (d *deadcodePass) decodeIfaceMethod(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, off int64) methodsig</code></pre>
            </article>
            
            <article class="function" data-name="decodeInuxi">
               <h3>
                  decodeInuxi 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodeInuxi(arch *sys.Arch, p []byte, sz int) uint64</code></pre>
            </article>
            
            <article class="function" data-name="decodeItabType">
               <h3>
                  decodeItabType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>decodeItabType returns the itab.Type field from an itab.</p>
               
               <pre><code>func decodeItabType(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="decodeMethodSig">
               <h3>
                  decodeMethodSig 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>decodeMethodSig decodes an array of method signature information.
Each element of the array is size bytes. The first 4 bytes is a
nameOff for the method name, and the next 4 bytes is a typeOff for
the function type.
Conveniently this is the layout of both runtime.method and runtime.imethod.</p>
               
               <pre><code>func (d *deadcodePass) decodeMethodSig(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, relocs *loader.Relocs, off int, size int, count int) []methodsig</code></pre>
            </article>
            
            <article class="function" data-name="decodeReloc">
               <h3>
                  decodeReloc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodeReloc(ldr *loader.Loader, symIdx loader.Sym, relocs *loader.Relocs, off int32) loader.Reloc</code></pre>
            </article>
            
            <article class="function" data-name="decodeRelocSym">
               <h3>
                  decodeRelocSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodeRelocSym(ldr *loader.Loader, symIdx loader.Sym, relocs *loader.Relocs, off int32) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="decodeTargetSym">
               <h3>
                  decodeTargetSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>decodeTargetSym finds the symbol pointed to by the pointer slot at offset off in s.</p>
               
               <pre><code>func decodeTargetSym(ctxt *Link, arch *sys.Arch, s loader.Sym, off int64) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeArrayElem">
               <h3>
                  decodetypeArrayElem 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeArrayElem(ctxt *Link, arch *sys.Arch, symIdx loader.Sym) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeArrayLen">
               <h3>
                  decodetypeArrayLen 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeArrayLen(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) int64</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeChanElem">
               <h3>
                  decodetypeChanElem 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeChanElem(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeFuncDotdotdot">
               <h3>
                  decodetypeFuncDotdotdot 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Type.FuncType.dotdotdot</p>
               
               <pre><code>func decodetypeFuncDotdotdot(arch *sys.Arch, p []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeFuncInCount">
               <h3>
                  decodetypeFuncInCount 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Type.FuncType.inCount</p>
               
               <pre><code>func decodetypeFuncInCount(arch *sys.Arch, p []byte) int</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeFuncInType">
               <h3>
                  decodetypeFuncInType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeFuncInType(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, relocs *loader.Relocs, i int) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeFuncOutCount">
               <h3>
                  decodetypeFuncOutCount 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeFuncOutCount(arch *sys.Arch, p []byte) int</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeFuncOutType">
               <h3>
                  decodetypeFuncOutType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeFuncOutType(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, relocs *loader.Relocs, i int) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeGCMaskOnDemand">
               <h3>
                  decodetypeGCMaskOnDemand 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Type.commonType.tflag</p>
               
               <pre><code>func decodetypeGCMaskOnDemand(arch *sys.Arch, p []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeGcmask">
               <h3>
                  decodetypeGcmask 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeGcmask(ctxt *Link, s loader.Sym) []byte</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeGcprog">
               <h3>
                  decodetypeGcprog 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Type.commonType.gc</p>
               
               <pre><code>func decodetypeGcprog(ctxt *Link, s loader.Sym) []byte</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeGcprogShlib">
               <h3>
                  decodetypeGcprogShlib 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeGcprogShlib(ctxt *Link, data []byte) uint64</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeHasUncommon">
               <h3>
                  decodetypeHasUncommon 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Type.commonType.tflag</p>
               
               <pre><code>func decodetypeHasUncommon(arch *sys.Arch, p []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeIfaceMethodCount">
               <h3>
                  decodetypeIfaceMethodCount 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>InterfaceType.methods.length</p>
               
               <pre><code>func decodetypeIfaceMethodCount(arch *sys.Arch, p []byte) int64</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeKind">
               <h3>
                  decodetypeKind 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Type.commonType.kind</p>
               
               <pre><code>func decodetypeKind(arch *sys.Arch, p []byte) abi.Kind</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeMapKey">
               <h3>
                  decodetypeMapKey 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeMapKey(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeMapSwissGroup">
               <h3>
                  decodetypeMapSwissGroup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeMapSwissGroup(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeMapValue">
               <h3>
                  decodetypeMapValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeMapValue(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeMethods">
               <h3>
                  decodetypeMethods 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *deadcodePass) decodetypeMethods(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, relocs *loader.Relocs) []methodsig</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeName">
               <h3>
                  decodetypeName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>decodetypeName decodes the name from a reflect.name.</p>
               
               <pre><code>func decodetypeName(ldr *loader.Loader, symIdx loader.Sym, relocs *loader.Relocs, off int) string</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeNameEmbedded">
               <h3>
                  decodetypeNameEmbedded 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeNameEmbedded(ldr *loader.Loader, symIdx loader.Sym, relocs *loader.Relocs, off int) bool</code></pre>
            </article>
            
            <article class="function" data-name="decodetypePtrElem">
               <h3>
                  decodetypePtrElem 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypePtrElem(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="decodetypePtrdata">
               <h3>
                  decodetypePtrdata 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Type.commonType.ptrdata</p>
               
               <pre><code>func decodetypePtrdata(arch *sys.Arch, p []byte) int64</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeSize">
               <h3>
                  decodetypeSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Type.commonType.size</p>
               
               <pre><code>func decodetypeSize(arch *sys.Arch, p []byte) int64</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeStr">
               <h3>
                  decodetypeStr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>decodetypeStr returns the contents of an rtype's str field (a nameOff).</p>
               
               <pre><code>func decodetypeStr(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) string</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeStructFieldArrayOff">
               <h3>
                  decodetypeStructFieldArrayOff 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeStructFieldArrayOff(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, i int) int</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeStructFieldCount">
               <h3>
                  decodetypeStructFieldCount 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeStructFieldCount(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym) int</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeStructFieldEmbedded">
               <h3>
                  decodetypeStructFieldEmbedded 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeStructFieldEmbedded(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, i int) bool</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeStructFieldName">
               <h3>
                  decodetypeStructFieldName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeStructFieldName(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, i int) string</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeStructFieldOffset">
               <h3>
                  decodetypeStructFieldOffset 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeStructFieldOffset(ldr *loader.Loader, arch *sys.Arch, symIdx loader.Sym, i int) int64</code></pre>
            </article>
            
            <article class="function" data-name="decodetypeStructFieldType">
               <h3>
                  decodetypeStructFieldType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodetypeStructFieldType(ctxt *Link, arch *sys.Arch, symIdx loader.Sym, i int) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="dedupLibraries">
               <h3>
                  dedupLibraries 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dedupLibraries(ctxt *Link, libs []string) []string</code></pre>
            </article>
            
            <article class="function" data-name="dedupLibrariesOpenBSD">
               <h3>
                  dedupLibrariesOpenBSD 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dedupLibrariesOpenBSD dedups a list of shared libraries, treating versioned
and unversioned libraries as equivalents. Versioned libraries are preferred
and retained over unversioned libraries. This avoids the situation where
the use of cgo results in a DT_NEEDED for a versioned library (for example,
libc.so.96.1), while a dynamic import specifies an unversioned library (for
example, libc.so) - this would otherwise result in two DT_NEEDED entries
for the same library, resulting in a failure when ld.so attempts to load
the Go binary.</p>
               
               <pre><code>func dedupLibrariesOpenBSD(ctxt *Link, libs []string) []string</code></pre>
            </article>
            
            <article class="function" data-name="defgotype">
               <h3>
                  defgotype 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Define gotype, for composite ones recurse into constituents.</p>
               
               <pre><code>func (d *dwctxt) defgotype(gotype loader.Sym) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="defineInternal">
               <h3>
                  defineInternal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>defineInternal defines a symbol used internally by the go runtime.</p>
               
               <pre><code>func (ctxt *Link) defineInternal(p string, t sym.SymKind) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="defptrto">
               <h3>
                  defptrto 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) defptrto(dwtype loader.Sym) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="determineLinkMode">
               <h3>
                  determineLinkMode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>determineLinkMode sets ctxt.LinkMode.
It is called after flags are processed and inputs are processed,
so the ctxt.LinkMode variable has an initial value from the -linkmode
flag and the iscgo, externalobj, and unknownObjFormat variables are set.</p>
               
               <pre><code>func determineLinkMode(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="dfs">
               <h3>
                  dfs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dfs(lib *sym.Library, mark map[*sym.Library]markKind, order *[]*sym.Library)</code></pre>
            </article>
            
            <article class="function" data-name="doMachoLink">
               <h3>
                  doMachoLink 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func doMachoLink(ctxt *Link) int64</code></pre>
            </article>
            
            <article class="function" data-name="doStackCheck">
               <h3>
                  doStackCheck 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>doStackCheck walks the call tree to check that there is always
enough stack space for call frames, especially for a chain of
nosplit functions.
It walks all functions to accumulate the number of bytes they can
grow the stack by without a split check and checks this against the
limit.</p>
               
               <pre><code>func (ctxt *Link) doStackCheck()</code></pre>
            </article>
            
            <article class="function" data-name="dodata">
               <h3>
                  dodata 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) dodata(symGroupType []sym.SymKind)</code></pre>
            </article>
            
            <article class="function" data-name="dodataSect">
               <h3>
                  dodataSect 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (state *dodataState) dodataSect(ctxt *Link, symn sym.SymKind, syms []loader.Sym) (result []loader.Sym, maxAlign int32)</code></pre>
            </article>
            
            <article class="function" data-name="doelf">
               <h3>
                  doelf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) doelf()</code></pre>
            </article>
            
            <article class="function" data-name="domacho">
               <h3>
                  domacho 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) domacho()</code></pre>
            </article>
            
            <article class="function" data-name="dope">
               <h3>
                  dope 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) dope()</code></pre>
            </article>
            
            <article class="function" data-name="dostrdata">
               <h3>
                  dostrdata 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) dostrdata()</code></pre>
            </article>
            
            <article class="function" data-name="dotypedef">
               <h3>
                  dotypedef 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) dotypedef(parent *dwarf.DWDie, name string, def *dwarf.DWDie) *dwarf.DWDie</code></pre>
            </article>
            
            <article class="function" data-name="doxcoff">
               <h3>
                  doxcoff 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) doxcoff()</code></pre>
            </article>
            
            <article class="function" data-name="dtolsym">
               <h3>
                  dtolsym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) dtolsym(s dwarf.Sym) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="dumpDepAddFlags">
               <h3>
                  dumpDepAddFlags 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *deadcodePass) dumpDepAddFlags(name string, symIdx loader.Sym) string</code></pre>
            </article>
            
            <article class="function" data-name="dwUnitPortion">
               <h3>
                  dwUnitPortion 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>dwUnitPortion assembles the DWARF content for a given compilation
unit: debug_info, debug_lines, debug_ranges, debug_loc (debug_frame
is handled elsewhere). Order is important; the calls to writelines
and writepcranges below make updates to the compilation unit DIE,
hence they have to happen before the call to writeUnitInfo.</p>
               
               <pre><code>func (d *dwctxt) dwUnitPortion(u *sym.CompilationUnit, abbrevsym loader.Sym, us *dwUnitSyms)</code></pre>
            </article>
            
            <article class="function" data-name="dwarfEnabled">
               <h3>
                  dwarfEnabled 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dwarfEnabled(ctxt *Link) bool</code></pre>
            </article>
            
            <article class="function" data-name="dwarfGenerateDebugInfo">
               <h3>
                  dwarfGenerateDebugInfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dwarfGenerateDebugInfo generated debug info entries for all types,
variables and functions in the program.
Along with dwarfGenerateDebugSyms they are the two main entry points into
dwarf generation: dwarfGenerateDebugInfo does all the work that should be
done before symbol names are mangled while dwarfGenerateDebugSyms does
all the work that can only be done after addresses have been assigned to
text symbols.</p>
               
               <pre><code>func dwarfGenerateDebugInfo(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="dwarfGenerateDebugSyms">
               <h3>
                  dwarfGenerateDebugSyms 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dwarfGenerateDebugSyms constructs debug_line, debug_frame, and
debug_loc. It also writes out the debug_info section using symbols
generated in dwarfGenerateDebugInfo2.</p>
               
               <pre><code>func dwarfGenerateDebugSyms(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="dwarfGenerateDebugSyms">
               <h3>
                  dwarfGenerateDebugSyms 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) dwarfGenerateDebugSyms()</code></pre>
            </article>
            
            <article class="function" data-name="dwarfVisitFunction">
               <h3>
                  dwarfVisitFunction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>dwarfVisitFunction takes a function (text) symbol and processes the
subprogram DIE for the function and picks up any other DIEs
(absfns, types) that it references.</p>
               
               <pre><code>func (d *dwctxt) dwarfVisitFunction(fnSym loader.Sym, unit *sym.CompilationUnit)</code></pre>
            </article>
            
            <article class="function" data-name="dwarfaddelfsectionsyms">
               <h3>
                  dwarfaddelfsectionsyms 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dwarfaddelfsectionsyms(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="dwarfaddshstrings">
               <h3>
                  dwarfaddshstrings 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Add DWARF section names to the section header string table, by calling add
on each name. ELF only.</p>
               
               <pre><code>func dwarfaddshstrings(ctxt *Link, add func(string))</code></pre>
            </article>
            
            <article class="function" data-name="dwarfblk">
               <h3>
                  dwarfblk 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dwarfblk(ctxt *Link, out *OutBuf, addr int64, size int64)</code></pre>
            </article>
            
            <article class="function" data-name="dwarfcompress">
               <h3>
                  dwarfcompress 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dwarfcompress compresses the DWARF sections. Relocations are applied
on the fly. After this, dwarfp will contain a different (new) set of
symbols, and sections may have been replaced.</p>
               
               <pre><code>func dwarfcompress(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="dynreloc">
               <h3>
                  dynreloc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (state *dodataState) dynreloc(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="dynrelocsym">
               <h3>
                  dynrelocsym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dynrelocsym(ctxt *Link, s loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="elf32phdr">
               <h3>
                  elf32phdr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elf32phdr(out *OutBuf, e *ElfPhdr)</code></pre>
            </article>
            
            <article class="function" data-name="elf32shdr">
               <h3>
                  elf32shdr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elf32shdr(out *OutBuf, e *ElfShdr)</code></pre>
            </article>
            
            <article class="function" data-name="elf32writehdr">
               <h3>
                  elf32writehdr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elf32writehdr(out *OutBuf) uint32</code></pre>
            </article>
            
            <article class="function" data-name="elf64phdr">
               <h3>
                  elf64phdr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elf64phdr(out *OutBuf, e *ElfPhdr)</code></pre>
            </article>
            
            <article class="function" data-name="elf64shdr">
               <h3>
                  elf64shdr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elf64shdr(out *OutBuf, e *ElfShdr)</code></pre>
            </article>
            
            <article class="function" data-name="elf64writehdr">
               <h3>
                  elf64writehdr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elf64writehdr(out *OutBuf) uint32</code></pre>
            </article>
            
            <article class="function" data-name="elfEmitReloc">
               <h3>
                  elfEmitReloc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfEmitReloc(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="elfMipsAbiFlags">
               <h3>
                  elfMipsAbiFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfMipsAbiFlags(sh *ElfShdr, startva uint64, resoff uint64) int</code></pre>
            </article>
            
            <article class="function" data-name="elfWriteDynEntSym">
               <h3>
                  elfWriteDynEntSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfWriteDynEntSym(ctxt *Link, s *loader.SymbolBuilder, tag elf.DynTag, t loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="elfWriteMipsAbiFlags">
               <h3>
                  elfWriteMipsAbiFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Layout is given by this C definition:
typedef struct
{
/* Version of flags structure.
uint16_t version;
/* The level of the ISA: 1-5, 32, 64.
uint8_t isa_level;
/* The revision of ISA: 0 for MIPS V and below, 1-n otherwise.
uint8_t isa_rev;
/* The size of general purpose registers.
uint8_t gpr_size;
/* The size of co-processor 1 registers.
uint8_t cpr1_size;
/* The size of co-processor 2 registers.
uint8_t cpr2_size;
/* The floating-point ABI.
uint8_t fp_abi;
/* Processor-specific extension.
uint32_t isa_ext;
/* Mask of ASEs used.
uint32_t ases;
/* Mask of general flags.
uint32_t flags1;
uint32_t flags2;
} Elf_Internal_ABIFlags_v0;</p>
               
               <pre><code>func elfWriteMipsAbiFlags(ctxt *Link) int</code></pre>
            </article>
            
            <article class="function" data-name="elfadddynsym">
               <h3>
                  elfadddynsym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfadddynsym(ldr *loader.Loader, target *Target, syms *ArchSyms, s loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="elfbuildinfo">
               <h3>
                  elfbuildinfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfbuildinfo(sh *ElfShdr, startva uint64, resoff uint64) int</code></pre>
            </article>
            
            <article class="function" data-name="elfdynhash">
               <h3>
                  elfdynhash 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfdynhash(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="elffips">
               <h3>
                  elffips 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>machofips updates go:fipsinfo after external linking
on systems using ELF (most Unix systems).</p>
               
               <pre><code>func elffips(ctxt *Link, exe string, fipso string) error</code></pre>
            </article>
            
            <article class="function" data-name="elffreebsdsig">
               <h3>
                  elffreebsdsig 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elffreebsdsig(sh *ElfShdr, startva uint64, resoff uint64) int</code></pre>
            </article>
            
            <article class="function" data-name="elfgobuildid">
               <h3>
                  elfgobuildid 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfgobuildid(sh *ElfShdr, startva uint64, resoff uint64) int</code></pre>
            </article>
            
            <article class="function" data-name="elfhash">
               <h3>
                  elfhash 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Taken directly from the definition document for ELF64.</p>
               
               <pre><code>func elfhash(name string) uint32</code></pre>
            </article>
            
            <article class="function" data-name="elfinterp">
               <h3>
                  elfinterp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfinterp(sh *ElfShdr, startva uint64, resoff uint64, p string) int</code></pre>
            </article>
            
            <article class="function" data-name="elfnetbsdpax">
               <h3>
                  elfnetbsdpax 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfnetbsdpax(sh *ElfShdr, startva uint64, resoff uint64) int</code></pre>
            </article>
            
            <article class="function" data-name="elfnetbsdsig">
               <h3>
                  elfnetbsdsig 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfnetbsdsig(sh *ElfShdr, startva uint64, resoff uint64) int</code></pre>
            </article>
            
            <article class="function" data-name="elfnote">
               <h3>
                  elfnote 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfnote(sh *ElfShdr, startva uint64, resoff uint64, sizes ...int) int</code></pre>
            </article>
            
            <article class="function" data-name="elfopenbsdsig">
               <h3>
                  elfopenbsdsig 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfopenbsdsig(sh *ElfShdr, startva uint64, resoff uint64) int</code></pre>
            </article>
            
            <article class="function" data-name="elfphload">
               <h3>
                  elfphload 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfphload(seg *sym.Segment) *ElfPhdr</code></pre>
            </article>
            
            <article class="function" data-name="elfphrelro">
               <h3>
                  elfphrelro 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfphrelro(seg *sym.Segment)</code></pre>
            </article>
            
            <article class="function" data-name="elfrelocsect">
               <h3>
                  elfrelocsect 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfrelocsect(ctxt *Link, out *OutBuf, sect *sym.Section, syms []loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="elfsetstring">
               <h3>
                  elfsetstring 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfsetstring(ctxt *Link, s loader.Sym, str string, off int)</code></pre>
            </article>
            
            <article class="function" data-name="elfshalloc">
               <h3>
                  elfshalloc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfshalloc(sect *sym.Section) *ElfShdr</code></pre>
            </article>
            
            <article class="function" data-name="elfshbits">
               <h3>
                  elfshbits 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfshbits(linkmode LinkMode, sect *sym.Section) *ElfShdr</code></pre>
            </article>
            
            <article class="function" data-name="elfshname">
               <h3>
                  elfshname 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfshname(name string) *ElfShdr</code></pre>
            </article>
            
            <article class="function" data-name="elfshnamedup">
               <h3>
                  elfshnamedup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Create an ElfShdr for the section with name.
Create a duplicate if one already exists with that name.</p>
               
               <pre><code>func elfshnamedup(name string) *ElfShdr</code></pre>
            </article>
            
            <article class="function" data-name="elfshreloc">
               <h3>
                  elfshreloc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfshreloc(arch *sys.Arch, sect *sym.Section) *ElfShdr</code></pre>
            </article>
            
            <article class="function" data-name="elfwritebuildinfo">
               <h3>
                  elfwritebuildinfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfwritebuildinfo(out *OutBuf) int</code></pre>
            </article>
            
            <article class="function" data-name="elfwritedynentsymsize">
               <h3>
                  elfwritedynentsymsize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfwritedynentsymsize(ctxt *Link, s *loader.SymbolBuilder, tag elf.DynTag, t loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="elfwritefreebsdsig">
               <h3>
                  elfwritefreebsdsig 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>elfwritefreebsdsig writes FreeBSD .note section.
See https://www.netbsd.org/docs/kernel/elf-notes.html for the description of
a Note element format and
https://github.com/freebsd/freebsd-src/blob/main/sys/sys/elf_common.h#L790
for the FreeBSD-specific values.</p>
               
               <pre><code>func elfwritefreebsdsig(out *OutBuf) int</code></pre>
            </article>
            
            <article class="function" data-name="elfwritegobuildid">
               <h3>
                  elfwritegobuildid 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfwritegobuildid(out *OutBuf) int</code></pre>
            </article>
            
            <article class="function" data-name="elfwritehdr">
               <h3>
                  elfwritehdr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfwritehdr(out *OutBuf) uint32</code></pre>
            </article>
            
            <article class="function" data-name="elfwriteinterp">
               <h3>
                  elfwriteinterp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfwriteinterp(out *OutBuf) int</code></pre>
            </article>
            
            <article class="function" data-name="elfwritenetbsdpax">
               <h3>
                  elfwritenetbsdpax 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfwritenetbsdpax(out *OutBuf) int</code></pre>
            </article>
            
            <article class="function" data-name="elfwritenetbsdsig">
               <h3>
                  elfwritenetbsdsig 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfwritenetbsdsig(out *OutBuf) int</code></pre>
            </article>
            
            <article class="function" data-name="elfwritenotehdr">
               <h3>
                  elfwritenotehdr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfwritenotehdr(out *OutBuf, str string, namesz uint32, descsz uint32, tag uint32) *ElfShdr</code></pre>
            </article>
            
            <article class="function" data-name="elfwriteopenbsdsig">
               <h3>
                  elfwriteopenbsdsig 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfwriteopenbsdsig(out *OutBuf) int</code></pre>
            </article>
            
            <article class="function" data-name="elfwritephdrs">
               <h3>
                  elfwritephdrs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfwritephdrs(out *OutBuf) uint32</code></pre>
            </article>
            
            <article class="function" data-name="elfwriteshdrs">
               <h3>
                  elfwriteshdrs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elfwriteshdrs(out *OutBuf) uint32</code></pre>
            </article>
            
            <article class="function" data-name="emitPcln">
               <h3>
                  emitPcln 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func emitPcln(ctxt *Link, s loader.Sym, container loader.Bitmap) bool</code></pre>
            </article>
            
            <article class="function" data-name="emitRelocations">
               <h3>
                  emitRelocations 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>emitRelocations emits relocation entries for go.o in external linking.</p>
               
               <pre><code>func (f *xcoffFile) emitRelocations(ctxt *Link, fileoff int64)</code></pre>
            </article>
            
            <article class="function" data-name="emitRelocations">
               <h3>
                  emitRelocations 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>emitRelocations emits relocation entries for go.o in external linking.</p>
               
               <pre><code>func (f *peFile) emitRelocations(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="emitRelocations">
               <h3>
                  emitRelocations 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>emitRelocations emits the relocation entries for the sect.
The actual relocations are emitted by relocfn.
This updates the corresponding PE section table entry
with the relocation offset and count.</p>
               
               <pre><code>func (sect *peSection) emitRelocations(out *OutBuf, relocfn func() int)</code></pre>
            </article>
            
            <article class="function" data-name="empty">
               <h3>
                  empty 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *lexHeap) empty() bool</code></pre>
            </article>
            
            <article class="function" data-name="empty">
               <h3>
                  empty 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *heap) empty() bool</code></pre>
            </article>
            
            <article class="function" data-name="errorUnresolved">
               <h3>
                  errorUnresolved 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>errorUnresolved prints unresolved symbol error for rs that is referenced from s.</p>
               
               <pre><code>func (reporter *ErrorReporter) errorUnresolved(ldr *loader.Loader, s loader.Sym, rs loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="errorexit">
               <h3>
                  errorexit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func errorexit()</code></pre>
            </article>
            
            <article class="function" data-name="execArchive">
               <h3>
                  execArchive 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>execArchive invokes the archiver tool with syscall.Exec(), with
the expectation that this is the last thing that takes place
in the linking operation.</p>
               
               <pre><code>func (ctxt *Link) execArchive(argv []string)</code></pre>
            </article>
            
            <article class="function" data-name="execArchive">
               <h3>
                  execArchive 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) execArchive(argv []string)</code></pre>
            </article>
            
            <article class="function" data-name="exitIfErrors">
               <h3>
                  exitIfErrors 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func exitIfErrors()</code></pre>
            </article>
            
            <article class="function" data-name="expandFile">
               <h3>
                  expandFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func expandFile(fname string) string</code></pre>
            </article>
            
            <article class="function" data-name="expandGoroot">
               <h3>
                  expandGoroot 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func expandGoroot(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="extld">
               <h3>
                  extld 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>extld returns the current external linker.</p>
               
               <pre><code>func (ctxt *Link) extld() []string</code></pre>
            </article>
            
            <article class="function" data-name="extreloc">
               <h3>
                  extreloc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Convert a Go relocation to an external relocation.</p>
               
               <pre><code>func extreloc(ctxt *Link, ldr *loader.Loader, s loader.Sym, r loader.Reloc) (loader.ExtReloc, bool)</code></pre>
            </article>
            
            <article class="function" data-name="fallocate">
               <h3>
                  fallocate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) fallocate(size uint64) error</code></pre>
            </article>
            
            <article class="function" data-name="fallocate">
               <h3>
                  fallocate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) fallocate(size uint64) error</code></pre>
            </article>
            
            <article class="function" data-name="fallocate">
               <h3>
                  fallocate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) fallocate(size uint64) error</code></pre>
            </article>
            
            <article class="function" data-name="fallocate">
               <h3>
                  fallocate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) fallocate(size uint64) error</code></pre>
            </article>
            
            <article class="function" data-name="fcntl">
               <h3>
                  fcntl 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Implemented in the syscall package.
go:linkname fcntl syscall.fcntl</p>
               
               <pre><code>func fcntl(fd int, cmd int, arg int) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="fieldtrack">
               <h3>
                  fieldtrack 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fieldtrack(arch *sys.Arch, l *loader.Loader)</code></pre>
            </article>
            
            <article class="function" data-name="find">
               <h3>
                  find 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>find looks up the loader symbol for the DWARF DIE generated for the
type with the specified name.</p>
               
               <pre><code>func (d *dwctxt) find(name string) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="findContainerSyms">
               <h3>
                  findContainerSyms 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>findContainerSyms returns a bitmap, indexed by symbol number, where there's
a 1 for every container symbol.</p>
               
               <pre><code>func (ctxt *Link) findContainerSyms() loader.Bitmap</code></pre>
            </article>
            
            <article class="function" data-name="findExtLinkTool">
               <h3>
                  findExtLinkTool 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>findExtLinkTool invokes the external linker CC with --print-prog-name
passing the name of the tool we're interested in, such as "strip",
"ar", or "dsymutil", and returns the path passed back from the command.</p>
               
               <pre><code>func (ctxt *Link) findExtLinkTool(toolname string) string</code></pre>
            </article>
            
            <article class="function" data-name="findLibPath">
               <h3>
                  findLibPath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>findLibPath searches for library libname.
It returns library full path if found, or "none" if not found.</p>
               
               <pre><code>func (ctxt *Link) findLibPath(libname string) string</code></pre>
            </article>
            
            <article class="function" data-name="findLibPathCmd">
               <h3>
                  findLibPathCmd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>findLibPathCmd uses cmd command to find gcc library libname.
It returns library full path if found, or "none" if not found.</p>
               
               <pre><code>func (ctxt *Link) findLibPathCmd(cmd string, libname string) string</code></pre>
            </article>
            
            <article class="function" data-name="findRoots">
               <h3>
                  findRoots 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sc *stackCheck) findRoots() []loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="findShlibSection">
               <h3>
                  findShlibSection 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Find the elf.Section of a given shared library that contains a given address.</p>
               
               <pre><code>func findShlibSection(ctxt *Link, path string, addr uint64) *elf.Section</code></pre>
            </article>
            
            <article class="function" data-name="findchild">
               <h3>
                  findchild 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Find child by AT_name using hashtable if available or linear scan
if not.</p>
               
               <pre><code>func findchild(die *dwarf.DWDie, name string) *dwarf.DWDie</code></pre>
            </article>
            
            <article class="function" data-name="findfunctab">
               <h3>
                  findfunctab 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>findfunctab generates a lookup table to quickly find the containing
function for a pc. See src/runtime/symtab.go:findfunc for details.</p>
               
               <pre><code>func (ctxt *Link) findfunctab(state *pclntab, container loader.Bitmap)</code></pre>
            </article>
            
            <article class="function" data-name="findlib">
               <h3>
                  findlib 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func findlib(ctxt *Link, lib string) (string, bool)</code></pre>
            </article>
            
            <article class="function" data-name="findprotodie">
               <h3>
                  findprotodie 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) findprotodie(ctxt *Link, name string) *dwarf.DWDie</code></pre>
            </article>
            
            <article class="function" data-name="findshlib">
               <h3>
                  findshlib 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func findshlib(ctxt *Link, shlib string) string</code></pre>
            </article>
            
            <article class="function" data-name="fixElfPhdr">
               <h3>
                  fixElfPhdr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Make sure PT_LOAD is aligned properly and
that there is no gap,
correct ELF loaders will do this implicitly,
but buggy ELF loaders like the one in some
versions of QEMU and UPX won't.</p>
               
               <pre><code>func fixElfPhdr(e *ElfPhdr)</code></pre>
            </article>
            
            <article class="function" data-name="fixZeroSizedSymbols">
               <h3>
                  fixZeroSizedSymbols 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fixZeroSizedSymbols gives a few special symbols with zero size some space.</p>
               
               <pre><code>func fixZeroSizedSymbols(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="flood">
               <h3>
                  flood 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *deadcodePass) flood()</code></pre>
            </article>
            
            <article class="function" data-name="funcData">
               <h3>
                  funcData 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>funcData returns the funcdata and offsets for the FuncInfo.
The funcdata are written into runtime.functab after each func
object. This is a helper function to make querying the FuncInfo object
cleaner.
NB: Preload must be called on the FuncInfo before calling.
NB: fdSyms is used as scratch space.</p>
               
               <pre><code>func funcData(ldr *loader.Loader, s loader.Sym, fi loader.FuncInfo, inlSym loader.Sym, fdSyms []loader.Sym) []loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="genDynSym">
               <h3>
                  genDynSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *xcoffFile) genDynSym(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="genInlTreeSym">
               <h3>
                  genInlTreeSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>genInlTreeSym generates the InlTree sym for a function with the
specified FuncInfo.</p>
               
               <pre><code>func genInlTreeSym(ctxt *Link, cu *sym.CompilationUnit, fi loader.FuncInfo, arch *sys.Arch, nameOffsets map[loader.Sym]uint32) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="genelfsym">
               <h3>
                  genelfsym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func genelfsym(ctxt *Link, elfbind elf.SymBind)</code></pre>
            </article>
            
            <article class="function" data-name="generateFilenameTabs">
               <h3>
                  generateFilenameTabs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>generateFilenameTabs creates LUTs needed for filename lookup. Returns a slice
of the index at which each CU begins in runtime.cutab.
Function objects keep track of the files they reference to print the stack.
This function creates a per-CU list of filenames if CU[M] references
files[1-N], the following is generated:
runtime.cutab:
CU[M]
offsetToFilename[0]
offsetToFilename[1]
..
runtime.filetab
filename[0]
filename[1]
Looking up a filename then becomes:
0. Given a func, and filename index [K]
1. Get Func.CUIndex:       M := func.cuOffset
2. Find filename offset:   fileOffset := runtime.cutab[M+K]
3. Get the filename:       getcstring(runtime.filetab[fileOffset])</p>
               
               <pre><code>func (state *pclntab) generateFilenameTabs(ctxt *Link, compUnits []*sym.CompilationUnit, funcs []loader.Sym) []uint32</code></pre>
            </article>
            
            <article class="function" data-name="generateFuncnametab">
               <h3>
                  generateFuncnametab 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>generateFuncnametab creates the function name table. Returns a map of
func symbol to the name offset in runtime.funcnamtab.</p>
               
               <pre><code>func (state *pclntab) generateFuncnametab(ctxt *Link, funcs []loader.Sym) map[loader.Sym]uint32</code></pre>
            </article>
            
            <article class="function" data-name="generateFunctab">
               <h3>
                  generateFunctab 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>generateFunctab creates the runtime.functab
runtime.functab contains two things:
- pc->func look up table.
- array of func objects, interleaved with pcdata and funcdata</p>
               
               <pre><code>func (state *pclntab) generateFunctab(ctxt *Link, funcs []loader.Sym, inlSyms map[loader.Sym]loader.Sym, cuOffsets []uint32, nameOffsets map[loader.Sym]uint32)</code></pre>
            </article>
            
            <article class="function" data-name="generatePCHeader">
               <h3>
                  generatePCHeader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>generatePCHeader creates the runtime.pcheader symbol, setting it up as a
generator to fill in its data later.</p>
               
               <pre><code>func (state *pclntab) generatePCHeader(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="generatePctab">
               <h3>
                  generatePctab 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>generatePctab creates the runtime.pctab variable, holding all the
deduplicated pcdata.</p>
               
               <pre><code>func (state *pclntab) generatePctab(ctxt *Link, funcs []loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="getCompilationDir">
               <h3>
                  getCompilationDir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func getCompilationDir() string</code></pre>
            </article>
            
            <article class="function" data-name="getDwsectCUSize">
               <h3>
                  getDwsectCUSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>getDwsectCUSize retrieves the corresponding package size inside the current section.</p>
               
               <pre><code>func getDwsectCUSize(sname string, pkgname string) uint64</code></pre>
            </article>
            
            <article class="function" data-name="getElfEhdr">
               <h3>
                  getElfEhdr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func getElfEhdr() *ElfEhdr</code></pre>
            </article>
            
            <article class="function" data-name="getMachoHdr">
               <h3>
                  getMachoHdr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func getMachoHdr() *MachoHdr</code></pre>
            </article>
            
            <article class="function" data-name="getPkgFromCUSym">
               <h3>
                  getPkgFromCUSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>getPkgFromCUSym returns the package name for the compilation unit
represented by s.
The prefix dwarf.InfoPrefix+".pkg." needs to be removed in order to get
the package name.</p>
               
               <pre><code>func (d *dwctxt) getPkgFromCUSym(s loader.Sym) string</code></pre>
            </article>
            
            <article class="function" data-name="getXCOFFscnum">
               <h3>
                  getXCOFFscnum 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>getXCOFFscnum returns the XCOFF section number of a Go section.</p>
               
               <pre><code>func (f *xcoffFile) getXCOFFscnum(sect *sym.Section) int16</code></pre>
            </article>
            
            <article class="function" data-name="getattr">
               <h3>
                  getattr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Each DIE (except the root ones) has at least 1 attribute: its
name. getattr moves the desired one to the front so
frequently searched ones are found faster.</p>
               
               <pre><code>func getattr(die *dwarf.DWDie, attr uint16) *dwarf.DWAttr</code></pre>
            </article>
            
            <article class="function" data-name="hostArchive">
               <h3>
                  hostArchive 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hostArchive reads an archive file holding host objects and links in
required objects. The general format is the same as a Go archive
file, but it has an armap listing symbols and the objects that
define them. This is used for the compiler support library
libgcc.a.</p>
               
               <pre><code>func hostArchive(ctxt *Link, name string)</code></pre>
            </article>
            
            <article class="function" data-name="hostObject">
               <h3>
                  hostObject 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hostObject reads a single host object file (compare to "hostArchive").
This is used as part of internal linking when we need to pull in
files such as "crt?.o".</p>
               
               <pre><code>func hostObject(ctxt *Link, objname string, path string)</code></pre>
            </article>
            
            <article class="function" data-name="hostlink">
               <h3>
                  hostlink 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) hostlink()</code></pre>
            </article>
            
            <article class="function" data-name="hostlinkArchArgs">
               <h3>
                  hostlinkArchArgs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hostlinkArchArgs returns arguments to pass to the external linker
based on the architecture.</p>
               
               <pre><code>func hostlinkArchArgs(arch *sys.Arch) []string</code></pre>
            </article>
            
            <article class="function" data-name="hostlinkfips">
               <h3>
                  hostlinkfips 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hostlinkfips is called from [hostlink] to update go:fipsinfo
when using external linking.
See [asmbfips] for internal linking.</p>
               
               <pre><code>func hostlinkfips(ctxt *Link, exe string, fipso string) error</code></pre>
            </article>
            
            <article class="function" data-name="hostlinksetup">
               <h3>
                  hostlinksetup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func hostlinksetup(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="hostobjCopy">
               <h3>
                  hostobjCopy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>hostobjCopy creates a copy of the object files in hostobj in a
temporary directory.</p>
               
               <pre><code>func (ctxt *Link) hostobjCopy() (paths []string)</code></pre>
            </article>
            
            <article class="function" data-name="hostobjMachoPlatform">
               <h3>
                  hostobjMachoPlatform 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hostobjMachoPlatform returns the first platform load command found
in the host object, if any.</p>
               
               <pre><code>func hostobjMachoPlatform(h *Hostobj) (*MachoPlatformLoad, error)</code></pre>
            </article>
            
            <article class="function" data-name="hostobjs">
               <h3>
                  hostobjs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func hostobjs(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="importInfoSymbol">
               <h3>
                  importInfoSymbol 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) importInfoSymbol(dsym loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rt *peBaseRelocTable) init(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *deadcodePass) init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="initdynexport">
               <h3>
                  initdynexport 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initdynexport(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="initdynimport">
               <h3>
                  initdynimport 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initdynimport(ctxt *Link) *Dll</code></pre>
            </article>
            
            <article class="function" data-name="inittaskSym">
               <h3>
                  inittaskSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>inittaskSym builds a symbol containing pointers to all the inittasks
that need to be run, given a list of root inittask symbols.</p>
               
               <pre><code>func (ctxt *Link) inittaskSym(rootNames []string, symName string) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="inittasks">
               <h3>
                  inittasks 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Inittasks finds inittask records, figures out a good
order to execute them in, and emits that order for the
runtime to use.
An inittask represents the initialization code that needs
to be run for a package. For package p, the p..inittask
symbol contains a list of init functions to run, both
explicit user init functions and implicit compiler-generated
init functions for initializing global variables like maps.
In addition, inittask records have dependencies between each
other, mirroring the import dependencies. So if package p
imports package q, then there will be a dependency p -> q.
We can't initialize package p until after package q has
already been initialized.
Package dependencies are encoded with relocations. If package
p imports package q, then package p's inittask record will
have a R_INITORDER relocation pointing to package q's inittask
record. See cmd/compile/internal/pkginit/init.go.
This function computes an ordering of all of the inittask
records so that the order respects all the dependencies,
and given that restriction, orders the inittasks in
lexicographic order.</p>
               
               <pre><code>func (ctxt *Link) inittasks()</code></pre>
            </article>
            
            <article class="function" data-name="isDwarf64">
               <h3>
                  isDwarf64 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isDwarf64(ctxt *Link) bool</code></pre>
            </article>
            
            <article class="function" data-name="isExported">
               <h3>
                  isExported 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m methodref) isExported() bool</code></pre>
            </article>
            
            <article class="function" data-name="isMmapped">
               <h3>
                  isMmapped 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isMmapped returns true if the OutBuf is mmaped.</p>
               
               <pre><code>func (out *OutBuf) isMmapped() bool</code></pre>
            </article>
            
            <article class="function" data-name="isPLTCall">
               <h3>
                  isPLTCall 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>whether rt is a (host object) relocation that will be turned into
a call to PLT.</p>
               
               <pre><code>func isPLTCall(arch *sys.Arch, rt objabi.RelocType) bool</code></pre>
            </article>
            
            <article class="function" data-name="isRuntimeDepPkg">
               <h3>
                  isRuntimeDepPkg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isRuntimeDepPkg reports whether pkg is the runtime package or its dependency.
TODO: just compute from the runtime package, and remove this hardcoded list.</p>
               
               <pre><code>func isRuntimeDepPkg(pkg string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isStaticTmp">
               <h3>
                  isStaticTmp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isStaticTmp(name string) bool</code></pre>
            </article>
            
            <article class="function" data-name="layout">
               <h3>
                  layout 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>layout assigns file offsets and lengths to the segments in order.
Returns the file size containing all the segments.</p>
               
               <pre><code>func (ctxt *Link) layout(order []*sym.Segment) uint64</code></pre>
            </article>
            
            <article class="function" data-name="ldhostobj">
               <h3>
                  ldhostobj 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ldhostobj(ld func(*Link, *bio.Reader, string, int64, string), headType objabi.HeadType, f *bio.Reader, pkg string, length int64, pn string, file string) *Hostobj</code></pre>
            </article>
            
            <article class="function" data-name="ldobj">
               <h3>
                  ldobj 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ldobj loads an input object. If it is a host object (an object
compiled by a non-Go compiler) it returns the Hostobj pointer. If
it is a Go object, it returns nil.</p>
               
               <pre><code>func ldobj(ctxt *Link, f *bio.Reader, lib *sym.Library, length int64, pn string, file string) *Hostobj</code></pre>
            </article>
            
            <article class="function" data-name="ldpkg">
               <h3>
                  ldpkg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ldpkg(ctxt *Link, f *bio.Reader, lib *sym.Library, length int64, filename string)</code></pre>
            </article>
            
            <article class="function" data-name="ldshlibsyms">
               <h3>
                  ldshlibsyms 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ldshlibsyms(ctxt *Link, shlib string)</code></pre>
            </article>
            
            <article class="function" data-name="libinit">
               <h3>
                  libinit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func libinit(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="linkerFlagSupported">
               <h3>
                  linkerFlagSupported 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func linkerFlagSupported(arch *sys.Arch, linker string, altLinker string, flag string) bool</code></pre>
            </article>
            
            <article class="function" data-name="linknew">
               <h3>
                  linknew 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func linknew(arch *sys.Arch) *Link</code></pre>
            </article>
            
            <article class="function" data-name="linksetup">
               <h3>
                  linksetup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set up flags and special symbols depending on the platform build mode.
This version works with loader.Loader.</p>
               
               <pre><code>func (ctxt *Link) linksetup()</code></pre>
            </article>
            
            <article class="function" data-name="loadWindowsHostArchives">
               <h3>
                  loadWindowsHostArchives 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>loadWindowsHostArchives loads in host archives and objects when
doing internal linking on windows. Older toolchains seem to require
just a single pass through the various archives, but some modern
toolchains when linking a C program with mingw pass library paths
multiple times to the linker, e.g. "... -lmingwex -lmingw32 ...
-lmingwex -lmingw32 ...". To accommodate this behavior, we make two
passes over the host archives below.</p>
               
               <pre><code>func loadWindowsHostArchives(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="loadcgo">
               <h3>
                  loadcgo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func loadcgo(ctxt *Link, file string, pkg string, p string)</code></pre>
            </article>
            
            <article class="function" data-name="loadcgodirectives">
               <h3>
                  loadcgodirectives 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>loadcgodirectives reads the previously discovered cgo directives, creating
symbols in preparation for host object loading or use later in the link.</p>
               
               <pre><code>func (ctxt *Link) loadcgodirectives()</code></pre>
            </article>
            
            <article class="function" data-name="loadfips">
               <h3>
                  loadfips 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>loadfips creates the special bracketing symbols and go:fipsinfo.</p>
               
               <pre><code>func loadfips(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="loadinternal">
               <h3>
                  loadinternal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func loadinternal(ctxt *Link, name string) *sym.Library</code></pre>
            </article>
            
            <article class="function" data-name="loadlib">
               <h3>
                  loadlib 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) loadlib()</code></pre>
            </article>
            
            <article class="function" data-name="loadobjfile">
               <h3>
                  loadobjfile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func loadobjfile(ctxt *Link, lib *sym.Library)</code></pre>
            </article>
            
            <article class="function" data-name="logBase2">
               <h3>
                  logBase2 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>logBase2 returns the log in base 2 of a.</p>
               
               <pre><code>func logBase2(a int) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupOrDiag">
               <h3>
                  lookupOrDiag 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) lookupOrDiag(n string) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="machoCodeSigSym">
               <h3>
                  machoCodeSigSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>machoCodeSigSym creates and returns a symbol for code signature.
The symbol context is left as zeros, which will be generated at the end
(as it depends on the rest of the file).</p>
               
               <pre><code>func machoCodeSigSym(ctxt *Link, codeSize int64) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="machoCodeSign">
               <h3>
                  machoCodeSign 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>machoCodeSign code-signs Mach-O file fname with an ad-hoc signature.
This is used for updating an external linker generated binary.</p>
               
               <pre><code>func machoCodeSign(ctxt *Link, fname string) error</code></pre>
            </article>
            
            <article class="function" data-name="machoCombineDwarf">
               <h3>
                  machoCombineDwarf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>machoCombineDwarf merges dwarf info generated by dsymutil into a macho executable.
With internal linking, DWARF is embedded into the executable, this lets us do the
same for external linking.
exef is the file of the executable with no DWARF. It must have enough room in the macho
header to add the DWARF sections. (Use ld's -headerpad option)
exem is the macho representation of exef.
dsym is the path to the macho file containing DWARF from dsymutil.
outexe is the path where the combined executable should be saved.</p>
               
               <pre><code>func machoCombineDwarf(ctxt *Link, exef *os.File, exem *macho.File, dsym string, outexe string) error</code></pre>
            </article>
            
            <article class="function" data-name="machoCompressSection">
               <h3>
                  machoCompressSection 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>machoCompressSection compresses secBytes if it results in less data.</p>
               
               <pre><code>func machoCompressSection(sectBytes []byte) (compressed bool, contents []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="machoCompressSections">
               <h3>
                  machoCompressSections 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>machoCompressSections tries to compress the DWARF segments in dwarfm,
returning the updated sections and segment contents, nils if the sections
weren't compressed, or an error if there was a problem reading dwarfm.</p>
               
               <pre><code>func machoCompressSections(ctxt *Link, dwarfm *macho.File) ([]*macho.Section, []byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="machoDyldInfo">
               <h3>
                  machoDyldInfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Generate data for the dynamic linker, used in LC_DYLD_INFO_ONLY load command.
See mach-o/loader.h, struct dyld_info_command, for the encoding.
e.g. https://opensource.apple.com/source/xnu/xnu-6153.81.5/EXTERNAL_HEADERS/mach-o/loader.h</p>
               
               <pre><code>func machoDyldInfo(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="machoEmitReloc">
               <h3>
                  machoEmitReloc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func machoEmitReloc(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="machoRewriteUuid">
               <h3>
                  machoRewriteUuid 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>machoRewriteUuid copies over the contents of the Macho executable
exef into the output file outexe, and in the process updates the
LC_UUID command to a new value recomputed from the Go build id.</p>
               
               <pre><code>func machoRewriteUuid(ctxt *Link, exef *os.File, exem *macho.File, outexe string) error</code></pre>
            </article>
            
            <article class="function" data-name="machoShouldExport">
               <h3>
                  machoShouldExport 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>machoShouldExport reports whether a symbol needs to be exported.
When dynamically linking, all non-local variables and plugin-exported
symbols need to be exported.</p>
               
               <pre><code>func machoShouldExport(ctxt *Link, ldr *loader.Loader, s loader.Sym) bool</code></pre>
            </article>
            
            <article class="function" data-name="machoUpdateDwarfHeader">
               <h3>
                  machoUpdateDwarfHeader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>machoUpdateDwarfHeader updates the DWARF segment load command.</p>
               
               <pre><code>func machoUpdateDwarfHeader(r *imacho.LoadCmdUpdater, compressedSects []*macho.Section, dwarfsize uint64, dwarfstart int64, realdwarf *macho.Segment) error</code></pre>
            </article>
            
            <article class="function" data-name="machoUpdateLoadCommand">
               <h3>
                  machoUpdateLoadCommand 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func machoUpdateLoadCommand(r imacho.LoadCmdUpdater, linkseg *macho.Segment, linkoffset uint64, cmd interface{}, fields ...string) error</code></pre>
            </article>
            
            <article class="function" data-name="machoUpdateSections">
               <h3>
                  machoUpdateSections 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func machoUpdateSections(r imacho.LoadCmdUpdater, seg *macho.Segment64, deltaOffset uint64, compressedSects []*macho.Section) error</code></pre>
            </article>
            
            <article class="function" data-name="machoUpdateSegment">
               <h3>
                  machoUpdateSegment 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>machoUpdateSegment updates the load command for a moved segment.
Only the linkedit segment should move, and it should have 0 sections.</p>
               
               <pre><code>func machoUpdateSegment(r imacho.LoadCmdUpdater, linkseg *macho.Segment, linkoffset uint64) error</code></pre>
            </article>
            
            <article class="function" data-name="machoadddynlib">
               <h3>
                  machoadddynlib 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func machoadddynlib(lib string, linkmode LinkMode)</code></pre>
            </article>
            
            <article class="function" data-name="machodysymtab">
               <h3>
                  machodysymtab 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func machodysymtab(ctxt *Link, base int64)</code></pre>
            </article>
            
            <article class="function" data-name="machofips">
               <h3>
                  machofips 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>machofips updates go:fipsinfo after external linking
on systems using Mach-O (GOOS=darwin, GOOS=ios).</p>
               
               <pre><code>func machofips(ctxt *Link, exe string, fipso string) error</code></pre>
            </article>
            
            <article class="function" data-name="machorelocsect">
               <h3>
                  machorelocsect 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func machorelocsect(ctxt *Link, out *OutBuf, sect *sym.Section, syms []loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="machoshbits">
               <h3>
                  machoshbits 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func machoshbits(ctxt *Link, mseg *MachoSeg, sect *sym.Section, segname string)</code></pre>
            </article>
            
            <article class="function" data-name="machosymorder">
               <h3>
                  machosymorder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func machosymorder(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="machosymtab">
               <h3>
                  machosymtab 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func machosymtab(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="machowrite">
               <h3>
                  machowrite 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func machowrite(ctxt *Link, arch *sys.Arch, out *OutBuf, linkmode LinkMode) int</code></pre>
            </article>
            
            <article class="function" data-name="makeInlSyms">
               <h3>
                  makeInlSyms 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeInlSyms returns a map of loader.Sym that are created inlSyms.</p>
               
               <pre><code>func makeInlSyms(ctxt *Link, funcs []loader.Sym, nameOffsets map[loader.Sym]uint32) map[loader.Sym]loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="makePclntab">
               <h3>
                  makePclntab 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makePclntab makes a pclntab object, and assembles all the compilation units
we'll need to write pclntab. Returns the pclntab structure, a slice of the
CompilationUnits we need, and a slice of the function symbols we need to
generate pclntab.</p>
               
               <pre><code>func makePclntab(ctxt *Link, container loader.Bitmap) (*pclntab, []*sym.CompilationUnit, []loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="makeRelocSymState">
               <h3>
                  makeRelocSymState 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>makeRelocSymState creates a relocSymState container object to
pass to relocsym(). If relocsym() calls happen in parallel,
each parallel thread should have its own state object.</p>
               
               <pre><code>func (ctxt *Link) makeRelocSymState() *relocSymState</code></pre>
            </article>
            
            <article class="function" data-name="makeRelroForSharedLib">
               <h3>
                  makeRelroForSharedLib 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>makeRelroForSharedLib creates a section of readonly data if necessary.</p>
               
               <pre><code>func (state *dodataState) makeRelroForSharedLib(target *Link)</code></pre>
            </article>
            
            <article class="function" data-name="mangleABIName">
               <h3>
                  mangleABIName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Mangle function name with ABI information.</p>
               
               <pre><code>func mangleABIName(ctxt *Link, ldr *loader.Loader, x loader.Sym, name string) string</code></pre>
            </article>
            
            <article class="function" data-name="mangleTypeSym">
               <h3>
                  mangleTypeSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mangleTypeSym shortens the names of symbols that represent Go types
if they are visible in the symbol table.
As the names of these symbols are derived from the string of
the type, they can run to many kilobytes long. So we shorten
them using a SHA-1 when the name appears in the final binary.
This also removes characters that upset external linkers.
These are the symbols that begin with the prefix 'type.' and
contain run-time type information used by the runtime and reflect
packages. All Go binaries contain these symbols, but only
those programs loaded dynamically in multiple parts need these
symbols to have entries in the symbol table.</p>
               
               <pre><code>func (ctxt *Link) mangleTypeSym()</code></pre>
            </article>
            
            <article class="function" data-name="mapToPESection">
               <h3>
                  mapToPESection 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mapToPESection searches peFile f for s symbol's location.
It returns PE section index, and offset within that section.</p>
               
               <pre><code>func (f *peFile) mapToPESection(ldr *loader.Loader, s loader.Sym, linkmode LinkMode) (pesectidx int, offset int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="mapinitcleanup">
               <h3>
                  mapinitcleanup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mapinitcleanup walks all pkg init functions and looks for weak relocations
to mapinit symbols that are no longer reachable. It rewrites
the relocs to target a new no-op routine in the runtime.</p>
               
               <pre><code>func (d *deadcodePass) mapinitcleanup()</code></pre>
            </article>
            
            <article class="function" data-name="mark">
               <h3>
                  mark 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *deadcodePass) mark(symIdx loader.Sym, parent loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="markMethod">
               <h3>
                  markMethod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *deadcodePass) markMethod(m methodref)</code></pre>
            </article>
            
            <article class="function" data-name="maxSizeTrampolines">
               <h3>
                  maxSizeTrampolines 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Estimate the max size needed to hold any new trampolines created for this function. This
is used to determine when the section can be split if it becomes too large, to ensure that
the trampolines are in the same section as the function that uses them.</p>
               
               <pre><code>func maxSizeTrampolines(ctxt *Link, ldr *loader.Loader, s loader.Sym, isTramp bool) uint64</code></pre>
            </article>
            
            <article class="function" data-name="mayberemoveoutfile">
               <h3>
                  mayberemoveoutfile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>* Unix doesn't like it when we write to a running (or, sometimes,
 * recently run) binary, so remove the output file before writing it.
 * On Windows 7, remove() can force a subsequent create() to fail.
 * S_ISREG() does not exist on Plan 9.</p>
               
               <pre><code>func mayberemoveoutfile()</code></pre>
            </article>
            
            <article class="function" data-name="mkArchSym">
               <h3>
                  mkArchSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mkArchSym is a helper for setArchSyms, to set up a special symbol.</p>
               
               <pre><code>func (ctxt *Link) mkArchSym(name string, ver int, ls *loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="mkArchSymVec">
               <h3>
                  mkArchSymVec 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mkArchSymVec is similar to  setArchSyms, but operates on elements within
a slice, where each element corresponds to some symbol version.</p>
               
               <pre><code>func (ctxt *Link) mkArchSymVec(name string, ver int, ls []loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="mkBuiltinType">
               <h3>
                  mkBuiltinType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mkBuiltinType populates the dwctxt2 sym lookup maps for the
newly created builtin type DIE 'typeDie'.</p>
               
               <pre><code>func (d *dwctxt) mkBuiltinType(ctxt *Link, abrv int, tname string) *dwarf.DWDie</code></pre>
            </article>
            
            <article class="function" data-name="mkinternaltype">
               <h3>
                  mkinternaltype 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) mkinternaltype(ctxt *Link, abbrev int, typename string, keyname string, valname string, f func(*dwarf.DWDie)) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="mkinternaltypename">
               <h3>
                  mkinternaltypename 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func mkinternaltypename(base string, arg1 string, arg2 string) string</code></pre>
            </article>
            
            <article class="function" data-name="movetomodule">
               <h3>
                  movetomodule 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func movetomodule(ctxt *Link, parent *dwarf.DWDie)</code></pre>
            </article>
            
            <article class="function" data-name="msync">
               <h3>
                  msync 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname msync syscall.msync</p>
               
               <pre><code>func msync(b []byte, flags int) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="munmap">
               <h3>
                  munmap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) munmap()</code></pre>
            </article>
            
            <article class="function" data-name="munmap">
               <h3>
                  munmap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) munmap()</code></pre>
            </article>
            
            <article class="function" data-name="munmap">
               <h3>
                  munmap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) munmap()</code></pre>
            </article>
            
            <article class="function" data-name="mustFind">
               <h3>
                  mustFind 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) mustFind(name string) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="mustLinkExternal">
               <h3>
                  mustLinkExternal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>mustLinkExternal reports whether the program being linked requires
the external linker be used to complete the link.</p>
               
               <pre><code>func mustLinkExternal(ctxt *Link) (res bool, reason string)</code></pre>
            </article>
            
            <article class="function" data-name="mustSetHeadType">
               <h3>
                  mustSetHeadType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Target) mustSetHeadType()</code></pre>
            </article>
            
            <article class="function" data-name="nameFromDIESym">
               <h3>
                  nameFromDIESym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) nameFromDIESym(dwtypeDIESym loader.Sym) string</code></pre>
            </article>
            
            <article class="function" data-name="needPEBaseReloc">
               <h3>
                  needPEBaseReloc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func needPEBaseReloc(ctxt *Link) bool</code></pre>
            </article>
            
            <article class="function" data-name="newElfPhdr">
               <h3>
                  newElfPhdr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newElfPhdr() *ElfPhdr</code></pre>
            </article>
            
            <article class="function" data-name="newElfShdr">
               <h3>
                  newElfShdr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newElfShdr(name int64) *ElfShdr</code></pre>
            </article>
            
            <article class="function" data-name="newFipsObj">
               <h3>
                  newFipsObj 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newFipsObj creates a fipsObj reading from r and writing to fipso
(unless fipso is the empty string, in which case it writes nowhere
and only computes the hash).</p>
               
               <pre><code>func newFipsObj(r io.ReaderAt, fipso string) (*fipsObj, error)</code></pre>
            </article>
            
            <article class="function" data-name="newMachoLoad">
               <h3>
                  newMachoLoad 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Create a new Mach-O load command. ndata is the number of 32-bit words for
the data (not including the load command header).</p>
               
               <pre><code>func newMachoLoad(arch *sys.Arch, type_ uint32, ndata uint32) *MachoLoad</code></pre>
            </article>
            
            <article class="function" data-name="newMachoSect">
               <h3>
                  newMachoSect 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newMachoSect(seg *MachoSeg, name string, segname string) *MachoSect</code></pre>
            </article>
            
            <article class="function" data-name="newMachoSeg">
               <h3>
                  newMachoSeg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newMachoSeg(name string, msect int) *MachoSeg</code></pre>
            </article>
            
            <article class="function" data-name="newStackCheck">
               <h3>
                  newStackCheck 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newStackCheck(ctxt *Link, graph bool) *stackCheck</code></pre>
            </article>
            
            <article class="function" data-name="newattr">
               <h3>
                  newattr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newattr attaches a new attribute to the specified DIE.
FIXME: at the moment attributes are stored in a linked list in a
fairly space-inefficient way -- it might be better to instead look
up all attrs in a single large table, then store indices into the
table in the DIE. This would allow us to common up storage for
attributes that are shared by many DIEs (ex: byte size of N).</p>
               
               <pre><code>func newattr(die *dwarf.DWDie, attr uint16, cls int, value int64, data interface{})</code></pre>
            </article>
            
            <article class="function" data-name="newdie">
               <h3>
                  newdie 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Every DIE manufactured by the linker has at least an AT_name
attribute (but it will only be written out if it is listed in the abbrev).
The compiler does create nameless DWARF DIEs (ex: concrete subprogram
instance).
FIXME: it would be more efficient to bulk-allocate DIEs.</p>
               
               <pre><code>func (d *dwctxt) newdie(parent *dwarf.DWDie, abbrev int, name string) *dwarf.DWDie</code></pre>
            </article>
            
            <article class="function" data-name="newmemberoffsetattr">
               <h3>
                  newmemberoffsetattr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newmemberoffsetattr(die *dwarf.DWDie, offs int32)</code></pre>
            </article>
            
            <article class="function" data-name="newrefattr">
               <h3>
                  newrefattr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) newrefattr(die *dwarf.DWDie, attr uint16, ref loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="newtype">
               <h3>
                  newtype 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) newtype(gotype loader.Sym) *dwarf.DWDie</code></pre>
            </article>
            
            <article class="function" data-name="nextar">
               <h3>
                  nextar 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>* look for the next file in an archive.
 * adapted from libmach.</p>
               
               <pre><code>func nextar(bp *bio.Reader, off int64, a *ArHdr) int64</code></pre>
            </article>
            
            <article class="function" data-name="numPCData">
               <h3>
                  numPCData 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>numPCData returns the number of PCData syms for the FuncInfo.
NB: Preload must be called on valid FuncInfos before calling this function.</p>
               
               <pre><code>func numPCData(ldr *loader.Loader, s loader.Sym, fi loader.FuncInfo) uint32</code></pre>
            </article>
            
            <article class="function" data-name="openbsdTrimLibVersion">
               <h3>
                  openbsdTrimLibVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>openbsdTrimLibVersion indicates whether a shared library is
versioned and if it is, returns the unversioned name. The
OpenBSD library naming scheme is lib<name>.so.<major>.<minor></p>
               
               <pre><code>func openbsdTrimLibVersion(lib string) (string, bool)</code></pre>
            </article>
            
            <article class="function" data-name="pad">
               <h3>
                  pad 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>pad adds zeros to the section sect. It writes as many bytes
as necessary to make section sect.SizeOfRawData bytes long.
It assumes that n bytes are already written to the file.</p>
               
               <pre><code>func (sect *peSection) pad(out *OutBuf, n uint32)</code></pre>
            </article>
            
            <article class="function" data-name="passLongArgsInResponseFile">
               <h3>
                  passLongArgsInResponseFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>passLongArgsInResponseFile writes the arguments into a file if they
are very long.</p>
               
               <pre><code>func (ctxt *Link) passLongArgsInResponseFile(argv []string, altLinker string) []string</code></pre>
            </article>
            
            <article class="function" data-name="pclntab">
               <h3>
                  pclntab 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>pclntab generates the pcln table for the link output.</p>
               
               <pre><code>func (ctxt *Link) pclntab(container loader.Bitmap) *pclntab</code></pre>
            </article>
            
            <article class="function" data-name="pdatablk">
               <h3>
                  pdatablk 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func pdatablk(ctxt *Link, out *OutBuf, addr int64, size int64)</code></pre>
            </article>
            
            <article class="function" data-name="peekMachoPlatform">
               <h3>
                  peekMachoPlatform 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>peekMachoPlatform returns the first LC_VERSION_MIN_* or LC_BUILD_VERSION
load command found in the Mach-O file, if any.</p>
               
               <pre><code>func peekMachoPlatform(m *macho.File) (*MachoPlatformLoad, error)</code></pre>
            </article>
            
            <article class="function" data-name="pefips">
               <h3>
                  pefips 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>pefips updates go:fipsinfo after external linking
on systems using PE (GOOS=windows).</p>
               
               <pre><code>func pefips(ctxt *Link, exe string, fipso string) error</code></pre>
            </article>
            
            <article class="function" data-name="peimporteddlls">
               <h3>
                  peimporteddlls 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>peimporteddlls returns the gcc command line argument to link all imported
DLLs.</p>
               
               <pre><code>func peimporteddlls() []string</code></pre>
            </article>
            
            <article class="function" data-name="pewrite">
               <h3>
                  pewrite 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func pewrite(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="phsh">
               <h3>
                  phsh 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func phsh(ph *ElfPhdr, sh *ElfShdr)</code></pre>
            </article>
            
            <article class="function" data-name="pkgname">
               <h3>
                  pkgname 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func pkgname(ctxt *Link, lib string) string</code></pre>
            </article>
            
            <article class="function" data-name="pop">
               <h3>
                  pop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *lexHeap) pop(ldr *loader.Loader) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="pop">
               <h3>
                  pop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *heap) pop() loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="postorder">
               <h3>
                  postorder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func postorder(libs []*sym.Library) []*sym.Library</code></pre>
            </article>
            
            <article class="function" data-name="pruneUndefsForWindows">
               <h3>
                  pruneUndefsForWindows 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>pruneUndefsForWindows trims the list "undefs" of currently
outstanding unresolved symbols to remove references to DLL import
symbols (e.g. "__imp_XXX"). In older versions of the linker, we
would just immediately forward references from the import sym
(__imp_XXX) to the DLL sym (XXX), but with newer compilers this
strategy falls down in certain cases. We instead now do this
forwarding later on as a post-processing step, and meaning that
during the middle part of host object loading we can see a lot of
unresolved (SXREF) import symbols. We do not, however, want to
trigger the inclusion of an object from a host archive if the
reference is going to be eventually forwarded to the corresponding
SDYNIMPORT symbol, so here we strip out such refs from the undefs
list.</p>
               
               <pre><code>func pruneUndefsForWindows(ldr *loader.Loader, undefs []loader.Sym, froms []loader.Sym) ([]loader.Sym, []loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="purgeSignatureCache">
               <h3>
                  purgeSignatureCache 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) purgeSignatureCache()</code></pre>
            </article>
            
            <article class="function" data-name="purgeSignatureCache">
               <h3>
                  purgeSignatureCache 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (out *OutBuf) purgeSignatureCache()</code></pre>
            </article>
            
            <article class="function" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *lexHeap) push(ldr *loader.Loader, s loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *heap) push(s loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="putaixsym">
               <h3>
                  putaixsym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>put function used by genasmsym to write symbol table.</p>
               
               <pre><code>func putaixsym(ctxt *Link, x loader.Sym, t SymbolType)</code></pre>
            </article>
            
            <article class="function" data-name="putdie">
               <h3>
                  putdie 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) putdie(syms []loader.Sym, die *dwarf.DWDie) []loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="putelfsectionsym">
               <h3>
                  putelfsectionsym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func putelfsectionsym(ctxt *Link, out *OutBuf, s loader.Sym, shndx elf.SectionIndex)</code></pre>
            </article>
            
            <article class="function" data-name="putelfstr">
               <h3>
                  putelfstr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func putelfstr(s string) int</code></pre>
            </article>
            
            <article class="function" data-name="putelfsym">
               <h3>
                  putelfsym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func putelfsym(ctxt *Link, x loader.Sym, typ elf.SymType, curbind elf.SymBind)</code></pre>
            </article>
            
            <article class="function" data-name="putelfsyment">
               <h3>
                  putelfsyment 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func putelfsyment(out *OutBuf, off int, addr int64, size int64, info uint8, shndx elf.SectionIndex, other int)</code></pre>
            </article>
            
            <article class="function" data-name="putplan9sym">
               <h3>
                  putplan9sym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func putplan9sym(ctxt *Link, ldr *loader.Loader, s loader.Sym, char SymbolType)</code></pre>
            </article>
            
            <article class="function" data-name="readArmap">
               <h3>
                  readArmap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readArmap reads the archive symbol map.</p>
               
               <pre><code>func readArmap(filename string, f *bio.Reader, arhdr ArHdr) archiveMap</code></pre>
            </article>
            
            <article class="function" data-name="readImportCfg">
               <h3>
                  readImportCfg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) readImportCfg(file string)</code></pre>
            </article>
            
            <article class="function" data-name="readelfsymboldata">
               <h3>
                  readelfsymboldata 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func readelfsymboldata(ctxt *Link, f *elf.File, sym *elf.Symbol) []byte</code></pre>
            </article>
            
            <article class="function" data-name="readnote">
               <h3>
                  readnote 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func readnote(f *elf.File, name []byte, typ int32) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="readwithpad">
               <h3>
                  readwithpad 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func readwithpad(r io.Reader, sz int32) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="relocSectFn">
               <h3>
                  relocSectFn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>relocSectFn wraps the function writing relocations of a section
for parallel execution. Returns the wrapped function and a wait
group for which the caller should wait.</p>
               
               <pre><code>func relocSectFn(ctxt *Link, relocSect func(*Link, *OutBuf, *sym.Section, []loader.Sym)) (func(*Link, *sym.Section, []loader.Sym), *sync.WaitGroup)</code></pre>
            </article>
            
            <article class="function" data-name="relocsym">
               <h3>
                  relocsym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>relocsym resolve relocations in "s", updating the symbol's content
in "P".
The main loop walks through the list of relocations attached to "s"
and resolves them where applicable. Relocations are often
architecture-specific, requiring calls into the 'archreloc' and/or
'archrelocvariant' functions for the architecture. When external
linking is in effect, it may not be  possible to completely resolve
the address/offset for a symbol, in which case the goal is to lay
the groundwork for turning a given relocation into an external reloc
(to be applied by the external linker). For more on how relocations
work in general, see
"Linkers and Loaders", by John R. Levine (Morgan Kaufmann, 1999), ch. 7
This is a performance-critical function for the linker; be careful
to avoid introducing unnecessary allocations in the main loop.</p>
               
               <pre><code>func (st *relocSymState) relocsym(s loader.Sym, P []byte)</code></pre>
            </article>
            
            <article class="function" data-name="report">
               <h3>
                  report 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sc *stackCheck) report(sym loader.Sym, depth int, chain *[]stackCheckChain)</code></pre>
            </article>
            
            <article class="function" data-name="resetAddress">
               <h3>
                  resetAddress 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func resetAddress(ctxt *Link, s loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="reverselist">
               <h3>
                  reverselist 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func reverselist(list **dwarf.DWDie)</code></pre>
            </article>
            
            <article class="function" data-name="reversetree">
               <h3>
                  reversetree 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func reversetree(list **dwarf.DWDie)</code></pre>
            </article>
            
            <article class="function" data-name="runAtExitFuncs">
               <h3>
                  runAtExitFuncs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>runAtExitFuncs runs the queued set of AtExit functions.</p>
               
               <pre><code>func runAtExitFuncs()</code></pre>
            </article>
            
            <article class="function" data-name="secSym">
               <h3>
                  secSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>secSym returns the section symbol for the section.</p>
               
               <pre><code>func (dsi *dwarfSecInfo) secSym() loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="setArchSyms">
               <h3>
                  setArchSyms 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setArchSyms sets up the ArchSyms structure, and must be called before
relocations are applied.</p>
               
               <pre><code>func (ctxt *Link) setArchSyms()</code></pre>
            </article>
            
            <article class="function" data-name="setCarrierSize">
               <h3>
                  setCarrierSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setCarrierSize(typ sym.SymKind, sz int64)</code></pre>
            </article>
            
            <article class="function" data-name="setCarrierSym">
               <h3>
                  setCarrierSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setCarrierSym(typ sym.SymKind, s loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="setCgoAttr">
               <h3>
                  setCgoAttr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Set symbol attributes or flags based on cgo directives.
Any newly discovered HOSTOBJ syms are added to 'hostObjSyms'.</p>
               
               <pre><code>func setCgoAttr(ctxt *Link, file string, pkg string, directives [][]string, hostObjSyms map[loader.Sym]struct{...})</code></pre>
            </article>
            
            <article class="function" data-name="setSymType">
               <h3>
                  setSymType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setSymType sets a new override type for 's'.</p>
               
               <pre><code>func (state *dodataState) setSymType(s loader.Sym, kind sym.SymKind)</code></pre>
            </article>
            
            <article class="function" data-name="setpersrc">
               <h3>
                  setpersrc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setpersrc(ctxt *Link, syms []loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="shsym">
               <h3>
                  shsym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Do not write DT_NULL.  elfdynhash will finish it.</p>
               
               <pre><code>func shsym(sh *ElfShdr, ldr *loader.Loader, s loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="size">
               <h3>
                  size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>size returns size of string table t.</p>
               
               <pre><code>func (t *xcoffStringTable) size() int</code></pre>
            </article>
            
            <article class="function" data-name="size">
               <h3>
                  size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>size returns size of string table t.</p>
               
               <pre><code>func (t *peStringTable) size() int</code></pre>
            </article>
            
            <article class="function" data-name="sizeExtRelocs">
               <h3>
                  sizeExtRelocs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>sizeExtRelocs precomputes the size needed for the reloc records,
sets the size and offset for relocation records in each section,
and mmap the output buffer with the proper size.</p>
               
               <pre><code>func sizeExtRelocs(ctxt *Link, relsize uint32)</code></pre>
            </article>
            
            <article class="function" data-name="splitTextSections">
               <h3>
                  splitTextSections 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Return whether we may need to split text sections.
On PPC64x, when external linking, a text section should not be
larger than 2^25 bytes due to the size of call target offset field
in the 'bl' instruction. Splitting into smaller text sections
smaller than this limit allows the system linker to modify the long
calls appropriately. The limit allows for the space needed for
tables inserted by the linker.
The same applies to Darwin/ARM64, with 2^27 byte threshold.
Similarly for ARM, we split sections (at 2^25 bytes) to avoid
inconsistencies between the Go linker's reachability calculations
(e.g. will direct call from X to Y need a trampoline) and similar
machinery in the external linker; see #58425 for more on the
history here.</p>
               
               <pre><code>func splitTextSections(ctxt *Link) bool</code></pre>
            </article>
            
            <article class="function" data-name="startProfile">
               <h3>
                  startProfile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func startProfile()</code></pre>
            </article>
            
            <article class="function" data-name="stringtouint32">
               <h3>
                  stringtouint32 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func stringtouint32(x []uint32, s string)</code></pre>
            </article>
            
            <article class="function" data-name="strput">
               <h3>
                  strput 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func strput(out *OutBuf, s string)</code></pre>
            </article>
            
            <article class="function" data-name="structfieldSize">
               <h3>
                  structfieldSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func structfieldSize(arch *sys.Arch) int</code></pre>
            </article>
            
            <article class="function" data-name="subSyms">
               <h3>
                  subSyms 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>subSyms returns a list of sub-symbols for the section.</p>
               
               <pre><code>func (dsi *dwarfSecInfo) subSyms() []loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="substitutetype">
               <h3>
                  substitutetype 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Search children (assumed to have TAG_member) for the one named
field and set its AT_type to dwtype</p>
               
               <pre><code>func (d *dwctxt) substitutetype(structdie *dwarf.DWDie, field string, dwtype loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="sum">
               <h3>
                  sum 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>sum returns the hash of the fips object file.</p>
               
               <pre><code>func (f *fipsObj) sum() []byte</code></pre>
            </article>
            
            <article class="function" data-name="symName">
               <h3>
                  symName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sc *stackCheck) symName(sym loader.Sym) string</code></pre>
            </article>
            
            <article class="function" data-name="symType">
               <h3>
                  symType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>symType returns the (possibly overridden) type of 's'.</p>
               
               <pre><code>func (state *dodataState) symType(s loader.Sym) sym.SymKind</code></pre>
            </article>
            
            <article class="function" data-name="symalign">
               <h3>
                  symalign 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>symalign returns the required alignment for the given symbol s.</p>
               
               <pre><code>func symalign(ldr *loader.Loader, s loader.Sym) int32</code></pre>
            </article>
            
            <article class="function" data-name="symbolsAreUnresolved">
               <h3>
                  symbolsAreUnresolved 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>symbolsAreUnresolved scans through the loader's list of unresolved
symbols and checks to see whether any of them match the names of the
symbols in 'want'. Return value is a list of bools, with list[K] set
to true if there is an unresolved reference to the symbol in want[K].</p>
               
               <pre><code>func symbolsAreUnresolved(ctxt *Link, want []string) []bool</code></pre>
            </article>
            
            <article class="function" data-name="symkind">
               <h3>
                  symkind 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func symkind(ldr *loader.Loader, s loader.Sym) int</code></pre>
            </article>
            
            <article class="function" data-name="symtab">
               <h3>
                  symtab 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) symtab(pcln *pclntab) []sym.SymKind</code></pre>
            </article>
            
            <article class="function" data-name="synthesizechantypes">
               <h3>
                  synthesizechantypes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) synthesizechantypes(ctxt *Link, die *dwarf.DWDie)</code></pre>
            </article>
            
            <article class="function" data-name="synthesizemaptypes">
               <h3>
                  synthesizemaptypes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) synthesizemaptypes(ctxt *Link, die *dwarf.DWDie)</code></pre>
            </article>
            
            <article class="function" data-name="synthesizemaptypesOld">
               <h3>
                  synthesizemaptypesOld 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) synthesizemaptypesOld(ctxt *Link, die *dwarf.DWDie)</code></pre>
            </article>
            
            <article class="function" data-name="synthesizemaptypesSwiss">
               <h3>
                  synthesizemaptypesSwiss 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) synthesizemaptypesSwiss(ctxt *Link, die *dwarf.DWDie)</code></pre>
            </article>
            
            <article class="function" data-name="synthesizeslicetypes">
               <h3>
                  synthesizeslicetypes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) synthesizeslicetypes(ctxt *Link, die *dwarf.DWDie)</code></pre>
            </article>
            
            <article class="function" data-name="synthesizestringtypes">
               <h3>
                  synthesizestringtypes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) synthesizestringtypes(ctxt *Link, die *dwarf.DWDie)</code></pre>
            </article>
            
            <article class="function" data-name="textaddress">
               <h3>
                  textaddress 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>assign addresses to text</p>
               
               <pre><code>func (ctxt *Link) textaddress()</code></pre>
            </article>
            
            <article class="function" data-name="textbuildid">
               <h3>
                  textbuildid 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add buildid to beginning of text segment, on non-ELF systems.
Non-ELF binary formats are not always flexible enough to
give us a place to put the Go build ID. On those systems, we put it
at the very beginning of the text segment.
This “header” is read by cmd/go.</p>
               
               <pre><code>func (ctxt *Link) textbuildid()</code></pre>
            </article>
            
            <article class="function" data-name="textsectionmap">
               <h3>
                  textsectionmap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Create a table with information on the text sections.
Return the symbol of the table, and number of sections.</p>
               
               <pre><code>func textsectionmap(ctxt *Link) (loader.Sym, uint32)</code></pre>
            </article>
            
            <article class="function" data-name="trampoline">
               <h3>
                  trampoline 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Detect too-far jumps in function s, and add trampolines if necessary.
ARM, LOONG64, PPC64, PPC64LE and RISCV64 support trampoline insertion for internal
and external linking. On PPC64 and PPC64LE the text sections might be split
but will still insert trampolines where necessary.</p>
               
               <pre><code>func trampoline(ctxt *Link, s loader.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="trimLinkerArgv">
               <h3>
                  trimLinkerArgv 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>trimLinkerArgv returns a new copy of argv that does not include flags
that are not relevant for testing whether some linker option works.</p>
               
               <pre><code>func trimLinkerArgv(argv []string) []string</code></pre>
            </article>
            
            <article class="function" data-name="typeSymbolMangle">
               <h3>
                  typeSymbolMangle 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>typeSymbolMangle mangles the given symbol name into something shorter.
Keep the type:. prefix, which parts of the linker (like the
DWARF generator) know means the symbol is not decodable.
Leave type:runtime. symbols alone, because other parts of
the linker manipulates them.</p>
               
               <pre><code>func typeSymbolMangle(name string) string</code></pre>
            </article>
            
            <article class="function" data-name="typelink">
               <h3>
                  typelink 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>typelink generates the typelink table which is used by reflect.typelinks().
Types that should be added to the typelinks table are marked with the
MakeTypelink attribute by the compiler.</p>
               
               <pre><code>func (ctxt *Link) typelink()</code></pre>
            </article>
            
            <article class="function" data-name="uncommonSize">
               <h3>
                  uncommonSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func uncommonSize(arch *sys.Arch) int</code></pre>
            </article>
            
            <article class="function" data-name="updatePreviousFile">
               <h3>
                  updatePreviousFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Update values for the previous package.
- Svalue of the C_FILE symbol: if it is the last one, this Svalue must be -1
- Xsclen of the csect symbol.</p>
               
               <pre><code>func (f *xcoffFile) updatePreviousFile(ctxt *Link, last bool)</code></pre>
            </article>
            
            <article class="function" data-name="usage">
               <h3>
                  usage 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func usage()</code></pre>
            </article>
            
            <article class="function" data-name="uuidFromGoBuildId">
               <h3>
                  uuidFromGoBuildId 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>uuidFromGoBuildId hashes the Go build ID and returns a slice of 16
bytes suitable for use as the payload in a Macho LC_UUID load
command.</p>
               
               <pre><code>func uuidFromGoBuildId(buildID string) []byte</code></pre>
            </article>
            
            <article class="function" data-name="walkFilenames">
               <h3>
                  walkFilenames 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>walkFilenames walks funcs, calling a function for each filename used in each
function's line table.</p>
               
               <pre><code>func walkFilenames(ctxt *Link, funcs []loader.Sym, f func(*sym.CompilationUnit, goobj.CUFileIndex))</code></pre>
            </article>
            
            <article class="function" data-name="walkFuncs">
               <h3>
                  walkFuncs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>walkFuncs iterates over the funcs, calling a function for each unique
function and inlined function.</p>
               
               <pre><code>func walkFuncs(ctxt *Link, funcs []loader.Sym, f func(loader.Sym))</code></pre>
            </article>
            
            <article class="function" data-name="walksymtypedef">
               <h3>
                  walksymtypedef 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) walksymtypedef(symIdx loader.Sym) loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="walktypedef">
               <h3>
                  walktypedef 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func walktypedef(die *dwarf.DWDie) *dwarf.DWDie</code></pre>
            </article>
            
            <article class="function" data-name="windynrelocsym">
               <h3>
                  windynrelocsym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>windynrelocsym examines a text symbol 's' and looks for relocations
from it that correspond to references to symbols defined in DLLs,
then fixes up those relocations as needed. A reference to a symbol
XYZ from some DLL will fall into one of two categories: an indirect
ref via "__imp_XYZ", or a direct ref to "XYZ". Here's an example of
an indirect ref (this is an excerpt from objdump -ldr):
1c1: 48 89 c6                     	movq	%rax, %rsi
1c4: ff 15 00 00 00 00            	callq	*(%rip)
00000000000001c6:  IMAGE_REL_AMD64_REL32	__imp__errno
In the assembly above, the code loads up the value of __imp_errno
and then does an indirect call to that value.
Here is what a direct reference might look like:
137: e9 20 06 00 00               	jmp	0x75c <pow+0x75c>
13c: e8 00 00 00 00               	callq	0x141 <pow+0x141>
000000000000013d:  IMAGE_REL_AMD64_REL32	_errno
The assembly below dispenses with the import symbol and just makes
a direct call to _errno.
The code below handles indirect refs by redirecting the target of
the relocation from "__imp_XYZ" to "XYZ" (since the latter symbol
is what the Windows loader is expected to resolve). For direct refs
the call is redirected to a stub, where the stub first loads the
symbol and then direct an indirect call to that value.
Note that for a given symbol (as above) it is perfectly legal to
have both direct and indirect references.</p>
               
               <pre><code>func windynrelocsym(ctxt *Link, rel *loader.SymbolBuilder, s loader.Sym) error</code></pre>
            </article>
            
            <article class="function" data-name="windynrelocsyms">
               <h3>
                  windynrelocsyms 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>windynrelocsyms generates jump table to C library functions that will be
added later. windynrelocsyms writes the table into .rel symbol.</p>
               
               <pre><code>func (ctxt *Link) windynrelocsyms()</code></pre>
            </article>
            
            <article class="function" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>write writes COFF section sect into the output file.</p>
               
               <pre><code>func (sect *peSection) write(out *OutBuf, linkmode LinkMode) error</code></pre>
            </article>
            
            <article class="function" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rt *peBaseRelocTable) write(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>write writes string table t into the output file.</p>
               
               <pre><code>func (t *xcoffStringTable) write(out *OutBuf)</code></pre>
            </article>
            
            <article class="function" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>write writes string table t into the output file.</p>
               
               <pre><code>func (t *peStringTable) write(out *OutBuf)</code></pre>
            </article>
            
            <article class="function" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>write writes XCOFF section sect into the output file.</p>
               
               <pre><code>func (sect *XcoffScnHdr64) write(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="writeBlock">
               <h3>
                  writeBlock 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func writeBlock(ctxt *Link, out *OutBuf, ldr *loader.Loader, syms []loader.Sym, addr int64, size int64, pad []byte)</code></pre>
            </article>
            
            <article class="function" data-name="writeBlocks">
               <h3>
                  writeBlocks 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>writeBlocks writes a specified chunk of symbols to the output buffer. It
breaks the write up into ≥blockSize chunks to write them out, and schedules
as many goroutines as necessary to accomplish this task. This call then
blocks, waiting on the writes to complete. Note that we use the sem parameter
to limit the number of concurrent writes taking place.</p>
               
               <pre><code>func writeBlocks(ctxt *Link, out *OutBuf, sem chan int, ldr *loader.Loader, syms []loader.Sym, addr int64, size int64, pad []byte)</code></pre>
            </article>
            
            <article class="function" data-name="writeByte">
               <h3>
                  writeByte 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *GCProg) writeByte() (func(x byte))</code></pre>
            </article>
            
            <article class="function" data-name="writeDatblkToOutBuf">
               <h3>
                  writeDatblkToOutBuf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func writeDatblkToOutBuf(ctxt *Link, out *OutBuf, addr int64, size int64)</code></pre>
            </article>
            
            <article class="function" data-name="writeDirFileTables">
               <h3>
                  writeDirFileTables 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeDirFileTables emits the portion of the DWARF line table
prologue containing the include directories and file names,
described in section 6.2.4 of the DWARF 4 standard. It walks the
filepaths for the unit to discover any common directories, which
are emitted to the directory table first, then the file table is
emitted after that.</p>
               
               <pre><code>func (d *dwctxt) writeDirFileTables(unit *sym.CompilationUnit, lsu *loader.SymbolBuilder)</code></pre>
            </article>
            
            <article class="function" data-name="writeFileHeader">
               <h3>
                  writeFileHeader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeFileHeader writes COFF file header for peFile f.</p>
               
               <pre><code>func (f *peFile) writeFileHeader(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="writeFileHeader">
               <h3>
                  writeFileHeader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *xcoffFile) writeFileHeader(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="writeFuncs">
               <h3>
                  writeFuncs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>writeFuncs writes the func structures and pcdata to runtime.functab.</p>
               
               <pre><code>func writeFuncs(ctxt *Link, sb *loader.SymbolBuilder, funcs []loader.Sym, inlSyms map[loader.Sym]loader.Sym, startLocations []uint32, cuOffsets []uint32, nameOffsets map[loader.Sym]uint32)</code></pre>
            </article>
            
            <article class="function" data-name="writeGDBLinkerScript">
               <h3>
                  writeGDBLinkerScript 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>writeGDBLinkerScript creates gcc linker script file in temp
directory. writeGDBLinkerScript returns created file path.
The script is used to work around gcc bug
(see https://golang.org/issue/20183 for details).</p>
               
               <pre><code>func writeGDBLinkerScript() string</code></pre>
            </article>
            
            <article class="function" data-name="writeLdrScn">
               <h3>
                  writeLdrScn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *xcoffFile) writeLdrScn(ctxt *Link, globalOff uint64)</code></pre>
            </article>
            
            <article class="function" data-name="writeLoc">
               <h3>
                  writeLoc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeLoc determines the write location if a buffer is mmaped.
We maintain two write buffers, an mmapped section, and a heap section for
writing. When the mmapped section is full, we switch over the heap memory
for writing.</p>
               
               <pre><code>func (out *OutBuf) writeLoc(lenToWrite int64) (int64, []byte)</code></pre>
            </article>
            
            <article class="function" data-name="writeOptionalHeader">
               <h3>
                  writeOptionalHeader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeOptionalHeader writes COFF optional header for peFile f.</p>
               
               <pre><code>func (f *peFile) writeOptionalHeader(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="writePCToFunc">
               <h3>
                  writePCToFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>writePCToFunc writes the PC->func lookup table.</p>
               
               <pre><code>func writePCToFunc(ctxt *Link, sb *loader.SymbolBuilder, funcs []loader.Sym, startLocations []uint32)</code></pre>
            </article>
            
            <article class="function" data-name="writeParallel">
               <h3>
                  writeParallel 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>writeParallel handles scheduling parallel execution of data write functions.</p>
               
               <pre><code>func writeParallel(wg *sync.WaitGroup, fn writeFn, ctxt *Link, seek uint64, vaddr uint64, length uint64)</code></pre>
            </article>
            
            <article class="function" data-name="writePlan9Header">
               <h3>
                  writePlan9Header 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>writePlan9Header writes out the plan9 header at the present position in the OutBuf.</p>
               
               <pre><code>func writePlan9Header(buf *OutBuf, magic uint32, entry int64, is64Bit bool)</code></pre>
            </article>
            
            <article class="function" data-name="writeSEH">
               <h3>
                  writeSEH 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func writeSEH(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="writeSEHAMD64">
               <h3>
                  writeSEHAMD64 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func writeSEHAMD64(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="writeSymbol">
               <h3>
                  writeSymbol 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeSymbol appends symbol s to file f symbol table.
It also sets s.Dynid to written symbol number.</p>
               
               <pre><code>func (f *peFile) writeSymbol(out *OutBuf, ldr *loader.Loader, s loader.Sym, name string, value int64, sectidx int, typ uint16, class uint8)</code></pre>
            </article>
            
            <article class="function" data-name="writeSymbolFunc">
               <h3>
                  writeSymbolFunc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write symbol representing a .text function.
The symbol table is split with C_FILE corresponding to each package
and not to each source file as it should be.</p>
               
               <pre><code>func (f *xcoffFile) writeSymbolFunc(ctxt *Link, x loader.Sym) []xcoffSym</code></pre>
            </article>
            
            <article class="function" data-name="writeSymbolNewFile">
               <h3>
                  writeSymbolNewFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write symbols needed when a new file appeared:
- a C_FILE with one auxiliary entry for its name
- C_DWARF symbols to provide debug information
- a C_HIDEXT which will be a csect containing all of its functions
It needs several parameters to create .csect symbols such as its entry point and its section number.
Currently, a new file is in fact a new package. It seems to be OK, but it might change
in the future.</p>
               
               <pre><code>func (f *xcoffFile) writeSymbolNewFile(ctxt *Link, name string, firstEntry uint64, extnum int16)</code></pre>
            </article>
            
            <article class="function" data-name="writeSymbolTableAndStringTable">
               <h3>
                  writeSymbolTableAndStringTable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeSymbolTableAndStringTable writes out symbol and string tables for peFile f.</p>
               
               <pre><code>func (f *peFile) writeSymbolTableAndStringTable(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="writeSymbols">
               <h3>
                  writeSymbols 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeSymbols writes all COFF symbol table records.</p>
               
               <pre><code>func (f *peFile) writeSymbols(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="writeUnitInfo">
               <h3>
                  writeUnitInfo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) writeUnitInfo(u *sym.CompilationUnit, abbrevsym loader.Sym, infoEpilog loader.Sym) []loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="writeabbrev">
               <h3>
                  writeabbrev 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) writeabbrev() dwarfSecInfo</code></pre>
            </article>
            
            <article class="function" data-name="writeframes">
               <h3>
                  writeframes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) writeframes(fs loader.Sym) dwarfSecInfo</code></pre>
            </article>
            
            <article class="function" data-name="writegdbscript">
               <h3>
                  writegdbscript 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dwctxt) writegdbscript() dwarfSecInfo</code></pre>
            </article>
            
            <article class="function" data-name="writelines">
               <h3>
                  writelines 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writelines collects up and chains together the symbols needed to
form the DWARF line table for the specified compilation unit,
returning a list of symbols. The returned list will include an
initial symbol containing the line table header and prologue (with
file table), then a series of compiler-emitted line table symbols
(one per live function), and finally an epilog symbol containing an
end-of-sequence operator. The prologue and epilog symbols are passed
in (having been created earlier); here we add content to them.</p>
               
               <pre><code>func (d *dwctxt) writelines(unit *sym.CompilationUnit, lineProlog loader.Sym) []loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="writepcranges">
               <h3>
                  writepcranges 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writepcranges generates the DW_AT_ranges table for compilation unit
"unit", and returns a collection of ranges symbols (one for the
compilation unit DIE itself and the remainder from functions in the unit).</p>
               
               <pre><code>func (d *dwctxt) writepcranges(unit *sym.CompilationUnit, base loader.Sym, pcs []dwarf.Range, rangeProlog loader.Sym) []loader.Sym</code></pre>
            </article>
            
            <article class="function" data-name="xcoffAlign">
               <h3>
                  xcoffAlign 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>xcoffAlign returns the log base 2 of the symbol's alignment.</p>
               
               <pre><code>func xcoffAlign(ldr *loader.Loader, x loader.Sym, t SymbolType) uint8</code></pre>
            </article>
            
            <article class="function" data-name="xcoffCreateExportFile">
               <h3>
                  xcoffCreateExportFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>xcoffCreateExportFile creates a file with exported symbols for
-Wl,-bE option.
ld won't export symbols unless they are listed in an export file.</p>
               
               <pre><code>func xcoffCreateExportFile(ctxt *Link) (fname string)</code></pre>
            </article>
            
            <article class="function" data-name="xcoffGetDwarfSubtype">
               <h3>
                  xcoffGetDwarfSubtype 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>xcoffGetDwarfSubtype returns the XCOFF name of the DWARF section str
and its subtype constant.</p>
               
               <pre><code>func xcoffGetDwarfSubtype(str string) (string, uint32)</code></pre>
            </article>
            
            <article class="function" data-name="xcoffUpdateOuterSize">
               <h3>
                  xcoffUpdateOuterSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>xcoffUpdateOuterSize stores the size of outer symbols in order to have it
in the symbol table.</p>
               
               <pre><code>func xcoffUpdateOuterSize(ctxt *Link, size int64, stype sym.SymKind)</code></pre>
            </article>
            
            <article class="function" data-name="xcoffwrite">
               <h3>
                  xcoffwrite 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func xcoffwrite(ctxt *Link)</code></pre>
            </article>
            
            <article class="function" data-name="xdatablk">
               <h3>
                  xdatablk 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func xdatablk(ctxt *Link, out *OutBuf, addr int64, size int64)</code></pre>
            </article>
            
            <article class="function" data-name="xdefine">
               <h3>
                  xdefine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ctxt *Link) xdefine(p string, t sym.SymKind, v int64) loader.Sym</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
