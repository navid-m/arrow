<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - types2</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>types2</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"cmd/compile/internal/syntax"
. "internal/types/errors"
"slices"
"cmd/compile/internal/syntax"
. "internal/types/errors"
"strings"
"cmd/compile/internal/syntax"
"fmt"
. "internal/types/errors"
"path/filepath"
"strings"
"cmd/compile/internal/syntax"
"fmt"
"go/constant"
. "internal/types/errors"
"strings"
"cmd/compile/internal/syntax"
"fmt"
"go/constant"
"internal/buildcfg"
. "internal/types/errors"
"slices"
"cmd/compile/internal/syntax"
"go/constant"
. "internal/types/errors"
"slices"
"unicode"
"cmd/compile/internal/syntax"
"fmt"
"io"
"slices"
"strings"
"sync"
"cmd/compile/internal/syntax"
"go/constant"
"go/token"
. "internal/types/errors"
"math"
"bytes"
"cmd/compile/internal/syntax"
"fmt"
"strconv"
"strings"
"cmd/compile/internal/syntax"
. "internal/types/errors"
"cmd/compile/internal/syntax"
"go/constant"
"cmd/compile/internal/syntax"
"bytes"
"fmt"
"slices"
"strconv"
"strings"
"unicode/utf8"
"cmd/compile/internal/syntax"
"go/constant"
"go/token"
. "internal/types/errors"
"bytes"
"fmt"
"strconv"
"strings"
"sync"
"cmd/compile/internal/syntax"
"fmt"
. "internal/types/errors"
"runtime"
"strings"
"cmd/compile/internal/syntax"
"fmt"
"cmd/compile/internal/syntax"
"fmt"
"go/constant"
. "internal/types/errors"
"strings"
"cmd/compile/internal/syntax"
. "internal/types/errors"
"strings"
"cmd/compile/internal/syntax"
. "internal/types/errors"
"bytes"
"fmt"
"sync/atomic"
"cmd/compile/internal/syntax"
. "internal/types/errors"
"cmd/compile/internal/syntax"
"cmp"
"container/heap"
"fmt"
. "internal/types/errors"
"slices"
"sort"
"cmd/compile/internal/syntax"
"errors"
"fmt"
"internal/buildcfg"
. "internal/types/errors"
"go/constant"
. "internal/types/errors"
"unicode"
"strings"
"cmd/compile/internal/syntax"
"go/constant"
"strings"
"cmd/compile/internal/syntax"
"fmt"
"go/constant"
"go/token"
. "internal/types/errors"
"cmd/compile/internal/syntax"
"fmt"
"slices"
"strings"
"bytes"
"cmd/compile/internal/syntax"
"strings"
"sync"
"sync/atomic"
"bytes"
"cmd/compile/internal/syntax"
"fmt"
"go/constant"
. "internal/types/errors"
"bytes"
"fmt"
"sort"
"strings"
"fmt"
"go/version"
"internal/goversion"
"cmd/compile/internal/syntax"
"fmt"
"go/constant"
. "internal/types/errors"
"sync/atomic"
"bytes"
"cmd/compile/internal/syntax"
"fmt"
"go/constant"
"strings"
"unicode"
"unicode/utf8"
"cmd/compile/internal/syntax"
"fmt"
. "internal/types/errors"
"strings"
"fmt"
"cmd/compile/internal/syntax"
"cmp"
"fmt"
"go/constant"
. "internal/types/errors"
"slices"
"strconv"
"strings"
"unicode"
"cmd/compile/internal/syntax"
"go/constant"
"internal/buildcfg"
. "internal/types/errors"
"slices"
"cmd/compile/internal/syntax"
. "internal/types/errors"
"strconv"
"cmd/compile/internal/syntax"
"go/constant"
"go/token"
"cmd/compile/internal/syntax"
"cmd/compile/internal/syntax"
. "internal/types/errors"
"slices"
"strings"
"cmd/compile/internal/syntax"
"fmt"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="Bool" data-name="Bool">
               <h3>
                  Bool 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Bool" class="anchor" title="Link to Bool">#</a>
               </h3>
               
               <p>predeclared types</p>
               
               <pre><code class="language-go">const Bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Byte" data-name="Byte">
               <h3>
                  Byte 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Byte" class="anchor" title="Link to Byte">#</a>
               </h3>
               
               <p>aliases</p>
               
               <pre><code class="language-go">const Byte = Uint8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Complex128" data-name="Complex128">
               <h3>
                  Complex128 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Complex128" class="anchor" title="Link to Complex128">#</a>
               </h3>
               
               <pre><code class="language-go">const Complex128</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Complex64" data-name="Complex64">
               <h3>
                  Complex64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Complex64" class="anchor" title="Link to Complex64">#</a>
               </h3>
               
               <pre><code class="language-go">const Complex64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FieldVal" data-name="FieldVal">
               <h3>
                  FieldVal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FieldVal" class="anchor" title="Link to FieldVal">#</a>
               </h3>
               
               <pre><code class="language-go">const FieldVal SelectionKind = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Float32" data-name="Float32">
               <h3>
                  Float32 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Float32" class="anchor" title="Link to Float32">#</a>
               </h3>
               
               <pre><code class="language-go">const Float32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Float64" data-name="Float64">
               <h3>
                  Float64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Float64" class="anchor" title="Link to Float64">#</a>
               </h3>
               
               <pre><code class="language-go">const Float64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int" data-name="Int">
               <h3>
                  Int 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Int" class="anchor" title="Link to Int">#</a>
               </h3>
               
               <pre><code class="language-go">const Int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int16" data-name="Int16">
               <h3>
                  Int16 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Int16" class="anchor" title="Link to Int16">#</a>
               </h3>
               
               <pre><code class="language-go">const Int16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int32" data-name="Int32">
               <h3>
                  Int32 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Int32" class="anchor" title="Link to Int32">#</a>
               </h3>
               
               <pre><code class="language-go">const Int32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int64" data-name="Int64">
               <h3>
                  Int64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Int64" class="anchor" title="Link to Int64">#</a>
               </h3>
               
               <pre><code class="language-go">const Int64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int8" data-name="Int8">
               <h3>
                  Int8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Int8" class="anchor" title="Link to Int8">#</a>
               </h3>
               
               <pre><code class="language-go">const Int8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Invalid" data-name="Invalid">
               <h3>
                  Invalid 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Invalid" class="anchor" title="Link to Invalid">#</a>
               </h3>
               
               <pre><code class="language-go">const Invalid BasicKind = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IsBoolean" data-name="IsBoolean">
               <h3>
                  IsBoolean 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IsBoolean" class="anchor" title="Link to IsBoolean">#</a>
               </h3>
               
               <p>Properties of basic types.</p>
               
               <pre><code class="language-go">const IsBoolean BasicInfo = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IsComplex" data-name="IsComplex">
               <h3>
                  IsComplex 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IsComplex" class="anchor" title="Link to IsComplex">#</a>
               </h3>
               
               <p>Properties of basic types.</p>
               
               <pre><code class="language-go">const IsComplex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IsConstType" data-name="IsConstType">
               <h3>
                  IsConstType 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IsConstType" class="anchor" title="Link to IsConstType">#</a>
               </h3>
               
               <p>Properties of basic types.</p>
               
               <pre><code class="language-go">const IsConstType = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IsFloat" data-name="IsFloat">
               <h3>
                  IsFloat 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IsFloat" class="anchor" title="Link to IsFloat">#</a>
               </h3>
               
               <p>Properties of basic types.</p>
               
               <pre><code class="language-go">const IsFloat</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IsInteger" data-name="IsInteger">
               <h3>
                  IsInteger 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IsInteger" class="anchor" title="Link to IsInteger">#</a>
               </h3>
               
               <p>Properties of basic types.</p>
               
               <pre><code class="language-go">const IsInteger</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IsNumeric" data-name="IsNumeric">
               <h3>
                  IsNumeric 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IsNumeric" class="anchor" title="Link to IsNumeric">#</a>
               </h3>
               
               <p>Properties of basic types.</p>
               
               <pre><code class="language-go">const IsNumeric = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IsOrdered" data-name="IsOrdered">
               <h3>
                  IsOrdered 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IsOrdered" class="anchor" title="Link to IsOrdered">#</a>
               </h3>
               
               <p>Properties of basic types.</p>
               
               <pre><code class="language-go">const IsOrdered = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IsString" data-name="IsString">
               <h3>
                  IsString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IsString" class="anchor" title="Link to IsString">#</a>
               </h3>
               
               <p>Properties of basic types.</p>
               
               <pre><code class="language-go">const IsString</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IsUnsigned" data-name="IsUnsigned">
               <h3>
                  IsUnsigned 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IsUnsigned" class="anchor" title="Link to IsUnsigned">#</a>
               </h3>
               
               <p>Properties of basic types.</p>
               
               <pre><code class="language-go">const IsUnsigned</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IsUntyped" data-name="IsUntyped">
               <h3>
                  IsUntyped 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IsUntyped" class="anchor" title="Link to IsUntyped">#</a>
               </h3>
               
               <p>Properties of basic types.</p>
               
               <pre><code class="language-go">const IsUntyped</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MethodExpr" data-name="MethodExpr">
               <h3>
                  MethodExpr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MethodExpr" class="anchor" title="Link to MethodExpr">#</a>
               </h3>
               
               <pre><code class="language-go">const MethodExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MethodVal" data-name="MethodVal">
               <h3>
                  MethodVal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MethodVal" class="anchor" title="Link to MethodVal">#</a>
               </h3>
               
               <pre><code class="language-go">const MethodVal</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RecvOnly" data-name="RecvOnly">
               <h3>
                  RecvOnly 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RecvOnly" class="anchor" title="Link to RecvOnly">#</a>
               </h3>
               
               <p>The direction of a channel is indicated by one of these constants.</p>
               
               <pre><code class="language-go">const RecvOnly</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Rune" data-name="Rune">
               <h3>
                  Rune 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Rune" class="anchor" title="Link to Rune">#</a>
               </h3>
               
               <pre><code class="language-go">const Rune = Int32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SendOnly" data-name="SendOnly">
               <h3>
                  SendOnly 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SendOnly" class="anchor" title="Link to SendOnly">#</a>
               </h3>
               
               <p>The direction of a channel is indicated by one of these constants.</p>
               
               <pre><code class="language-go">const SendOnly</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SendRecv" data-name="SendRecv">
               <h3>
                  SendRecv 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SendRecv" class="anchor" title="Link to SendRecv">#</a>
               </h3>
               
               <p>The direction of a channel is indicated by one of these constants.</p>
               
               <pre><code class="language-go">const SendRecv ChanDir = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">const String</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Typ" data-name="Typ">
               <h3>
                  Typ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Typ" class="anchor" title="Link to Typ">#</a>
               </h3>
               
               <p>Typ contains the predeclared *Basic types indexed by their
corresponding BasicKind.
The *Basic type for Typ[Byte] will have the name "uint8".
Use Universe.Lookup("byte").Type() to obtain the specific
alias basic type named "byte" (and analogous for "rune").</p>
               
               <pre><code class="language-go">var Typ = [...]*Basic{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uint" data-name="Uint">
               <h3>
                  Uint 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uint" class="anchor" title="Link to Uint">#</a>
               </h3>
               
               <pre><code class="language-go">const Uint</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uint16" data-name="Uint16">
               <h3>
                  Uint16 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uint16" class="anchor" title="Link to Uint16">#</a>
               </h3>
               
               <pre><code class="language-go">const Uint16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uint32" data-name="Uint32">
               <h3>
                  Uint32 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uint32" class="anchor" title="Link to Uint32">#</a>
               </h3>
               
               <pre><code class="language-go">const Uint32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uint64" data-name="Uint64">
               <h3>
                  Uint64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uint64" class="anchor" title="Link to Uint64">#</a>
               </h3>
               
               <pre><code class="language-go">const Uint64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uint8" data-name="Uint8">
               <h3>
                  Uint8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uint8" class="anchor" title="Link to Uint8">#</a>
               </h3>
               
               <pre><code class="language-go">const Uint8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uintptr" data-name="Uintptr">
               <h3>
                  Uintptr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uintptr" class="anchor" title="Link to Uintptr">#</a>
               </h3>
               
               <pre><code class="language-go">const Uintptr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Universe" data-name="Universe">
               <h3>
                  Universe 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Universe" class="anchor" title="Link to Universe">#</a>
               </h3>
               
               <p>The Universe scope contains all predeclared objects of Go.
It is the outermost scope of any chain of nested scopes.</p>
               
               <pre><code class="language-go">var Universe *Scope</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Unsafe" data-name="Unsafe">
               <h3>
                  Unsafe 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Unsafe" class="anchor" title="Link to Unsafe">#</a>
               </h3>
               
               <p>The Unsafe package is the package returned by an importer
for the import path "unsafe".</p>
               
               <pre><code class="language-go">var Unsafe *Package</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnsafePointer" data-name="UnsafePointer">
               <h3>
                  UnsafePointer 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnsafePointer" class="anchor" title="Link to UnsafePointer">#</a>
               </h3>
               
               <pre><code class="language-go">const UnsafePointer</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UntypedBool" data-name="UntypedBool">
               <h3>
                  UntypedBool 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UntypedBool" class="anchor" title="Link to UntypedBool">#</a>
               </h3>
               
               <p>types for untyped values</p>
               
               <pre><code class="language-go">const UntypedBool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UntypedComplex" data-name="UntypedComplex">
               <h3>
                  UntypedComplex 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UntypedComplex" class="anchor" title="Link to UntypedComplex">#</a>
               </h3>
               
               <pre><code class="language-go">const UntypedComplex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UntypedFloat" data-name="UntypedFloat">
               <h3>
                  UntypedFloat 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UntypedFloat" class="anchor" title="Link to UntypedFloat">#</a>
               </h3>
               
               <pre><code class="language-go">const UntypedFloat</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UntypedInt" data-name="UntypedInt">
               <h3>
                  UntypedInt 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UntypedInt" class="anchor" title="Link to UntypedInt">#</a>
               </h3>
               
               <pre><code class="language-go">const UntypedInt</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UntypedNil" data-name="UntypedNil">
               <h3>
                  UntypedNil 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UntypedNil" class="anchor" title="Link to UntypedNil">#</a>
               </h3>
               
               <pre><code class="language-go">const UntypedNil</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UntypedRune" data-name="UntypedRune">
               <h3>
                  UntypedRune 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UntypedRune" class="anchor" title="Link to UntypedRune">#</a>
               </h3>
               
               <pre><code class="language-go">const UntypedRune</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UntypedString" data-name="UntypedString">
               <h3>
                  UntypedString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UntypedString" class="anchor" title="Link to UntypedString">#</a>
               </h3>
               
               <pre><code class="language-go">const UntypedString</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Add" data-name="_Add">
               <h3>
                  _Add 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Add" class="anchor" title="Link to _Add">#</a>
               </h3>
               
               <p>package unsafe</p>
               
               <pre><code class="language-go">const _Add</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Alignof" data-name="_Alignof">
               <h3>
                  _Alignof 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Alignof" class="anchor" title="Link to _Alignof">#</a>
               </h3>
               
               <pre><code class="language-go">const _Alignof</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Append" data-name="_Append">
               <h3>
                  _Append 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Append" class="anchor" title="Link to _Append">#</a>
               </h3>
               
               <p>universe scope</p>
               
               <pre><code class="language-go">const _Append builtinId = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Assert" data-name="_Assert">
               <h3>
                  _Assert 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Assert" class="anchor" title="Link to _Assert">#</a>
               </h3>
               
               <p>testing support</p>
               
               <pre><code class="language-go">const _Assert</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Cap" data-name="_Cap">
               <h3>
                  _Cap 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Cap" class="anchor" title="Link to _Cap">#</a>
               </h3>
               
               <pre><code class="language-go">const _Cap</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Clear" data-name="_Clear">
               <h3>
                  _Clear 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Clear" class="anchor" title="Link to _Clear">#</a>
               </h3>
               
               <pre><code class="language-go">const _Clear</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Close" data-name="_Close">
               <h3>
                  _Close 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Close" class="anchor" title="Link to _Close">#</a>
               </h3>
               
               <pre><code class="language-go">const _Close</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Complex" data-name="_Complex">
               <h3>
                  _Complex 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Complex" class="anchor" title="Link to _Complex">#</a>
               </h3>
               
               <pre><code class="language-go">const _Complex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Copy" data-name="_Copy">
               <h3>
                  _Copy 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Copy" class="anchor" title="Link to _Copy">#</a>
               </h3>
               
               <pre><code class="language-go">const _Copy</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Delete" data-name="_Delete">
               <h3>
                  _Delete 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Delete" class="anchor" title="Link to _Delete">#</a>
               </h3>
               
               <pre><code class="language-go">const _Delete</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Imag" data-name="_Imag">
               <h3>
                  _Imag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Imag" class="anchor" title="Link to _Imag">#</a>
               </h3>
               
               <pre><code class="language-go">const _Imag</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Len" data-name="_Len">
               <h3>
                  _Len 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Len" class="anchor" title="Link to _Len">#</a>
               </h3>
               
               <pre><code class="language-go">const _Len</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Make" data-name="_Make">
               <h3>
                  _Make 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Make" class="anchor" title="Link to _Make">#</a>
               </h3>
               
               <pre><code class="language-go">const _Make</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Max" data-name="_Max">
               <h3>
                  _Max 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Max" class="anchor" title="Link to _Max">#</a>
               </h3>
               
               <pre><code class="language-go">const _Max</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Min" data-name="_Min">
               <h3>
                  _Min 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Min" class="anchor" title="Link to _Min">#</a>
               </h3>
               
               <pre><code class="language-go">const _Min</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_New" data-name="_New">
               <h3>
                  _New 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_New" class="anchor" title="Link to _New">#</a>
               </h3>
               
               <pre><code class="language-go">const _New</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Offsetof" data-name="_Offsetof">
               <h3>
                  _Offsetof 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Offsetof" class="anchor" title="Link to _Offsetof">#</a>
               </h3>
               
               <pre><code class="language-go">const _Offsetof</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Panic" data-name="_Panic">
               <h3>
                  _Panic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Panic" class="anchor" title="Link to _Panic">#</a>
               </h3>
               
               <pre><code class="language-go">const _Panic</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Print" data-name="_Print">
               <h3>
                  _Print 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Print" class="anchor" title="Link to _Print">#</a>
               </h3>
               
               <pre><code class="language-go">const _Print</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Println" data-name="_Println">
               <h3>
                  _Println 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Println" class="anchor" title="Link to _Println">#</a>
               </h3>
               
               <pre><code class="language-go">const _Println</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Real" data-name="_Real">
               <h3>
                  _Real 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Real" class="anchor" title="Link to _Real">#</a>
               </h3>
               
               <pre><code class="language-go">const _Real</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Recover" data-name="_Recover">
               <h3>
                  _Recover 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Recover" class="anchor" title="Link to _Recover">#</a>
               </h3>
               
               <pre><code class="language-go">const _Recover</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Sizeof" data-name="_Sizeof">
               <h3>
                  _Sizeof 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Sizeof" class="anchor" title="Link to _Sizeof">#</a>
               </h3>
               
               <pre><code class="language-go">const _Sizeof</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Slice" data-name="_Slice">
               <h3>
                  _Slice 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Slice" class="anchor" title="Link to _Slice">#</a>
               </h3>
               
               <pre><code class="language-go">const _Slice</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_SliceData" data-name="_SliceData">
               <h3>
                  _SliceData 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_SliceData" class="anchor" title="Link to _SliceData">#</a>
               </h3>
               
               <pre><code class="language-go">const _SliceData</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_String" data-name="_String">
               <h3>
                  _String 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_String" class="anchor" title="Link to _String">#</a>
               </h3>
               
               <pre><code class="language-go">const _String</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_StringData" data-name="_StringData">
               <h3>
                  _StringData 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_StringData" class="anchor" title="Link to _StringData">#</a>
               </h3>
               
               <pre><code class="language-go">const _StringData</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Trace" data-name="_Trace">
               <h3>
                  _Trace 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Trace" class="anchor" title="Link to _Trace">#</a>
               </h3>
               
               <pre><code class="language-go">const _Trace</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_aliasAny" data-name="_aliasAny">
               <h3>
                  _aliasAny 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_aliasAny" class="anchor" title="Link to _aliasAny">#</a>
               </h3>
               
               <p>_aliasAny changes the behavior of [Scope.Lookup] for "any" in the
[Universe] scope.
This is necessary because while Alias creation is controlled by
[Config.EnableAlias], the representation of "any" is a global. In
[Scope.Lookup], we select this global representation based on the result of
[aliasAny], but as a result need to guard against this behavior changing
during the type checking pass. Therefore we implement the following rule:
any number of goroutines can type check concurrently with the same
EnableAlias value, but if any goroutine tries to type check concurrently
with a different EnableAlias value, we panic.
To achieve this, _aliasAny is a state machine:
0:        no type checking is occurring
negative: type checking is occurring without EnableAlias set
positive: type checking is occurring with EnableAlias set</p>
               
               <pre><code class="language-go">var _aliasAny int32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="allTermlist" data-name="allTermlist">
               <h3>
                  allTermlist 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#allTermlist" class="anchor" title="Link to allTermlist">#</a>
               </h3>
               
               <p>allTermlist represents the set of all types.
It is in normal form.</p>
               
               <pre><code class="language-go">var allTermlist = termlist{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="assign" data-name="assign">
               <h3>
                  assign 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#assign" class="anchor" title="Link to assign">#</a>
               </h3>
               
               <p>If assign is set, we are unifying types involved in an assignment:
they may match inexactly at the top, but element types must match
exactly.</p>
               
               <pre><code class="language-go">const assign unifyMode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="basicAliases" data-name="basicAliases">
               <h3>
                  basicAliases 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#basicAliases" class="anchor" title="Link to basicAliases">#</a>
               </h3>
               
               <pre><code class="language-go">var basicAliases = [...]*Basic{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="basicSizes" data-name="basicSizes">
               <h3>
                  basicSizes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#basicSizes" class="anchor" title="Link to basicSizes">#</a>
               </h3>
               
               <pre><code class="language-go">var basicSizes = [...]byte{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="binaryOpPredicates" data-name="binaryOpPredicates">
               <h3>
                  binaryOpPredicates 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#binaryOpPredicates" class="anchor" title="Link to binaryOpPredicates">#</a>
               </h3>
               
               <pre><code class="language-go">var binaryOpPredicates opPredicates</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="black" data-name="black">
               <h3>
                  black 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#black" class="anchor" title="Link to black">#</a>
               </h3>
               
               <p>An object may be painted in one of three colors.
Color values other than white or black are considered grey.</p>
               
               <pre><code class="language-go">const black</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="breakOk" data-name="breakOk">
               <h3>
                  breakOk 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#breakOk" class="anchor" title="Link to breakOk">#</a>
               </h3>
               
               <p>permissible control-flow statements</p>
               
               <pre><code class="language-go">const breakOk stmtContext = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="builtin" data-name="builtin">
               <h3>
                  builtin 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#builtin" class="anchor" title="Link to builtin">#</a>
               </h3>
               
               <pre><code class="language-go">const builtin</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cgoPrefixes" data-name="cgoPrefixes">
               <h3>
                  cgoPrefixes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cgoPrefixes" class="anchor" title="Link to cgoPrefixes">#</a>
               </h3>
               
               <pre><code class="language-go">var cgoPrefixes = [...]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cgofunc" data-name="cgofunc">
               <h3>
                  cgofunc 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#cgofunc" class="anchor" title="Link to cgofunc">#</a>
               </h3>
               
               <pre><code class="language-go">const cgofunc</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="commaerr" data-name="commaerr">
               <h3>
                  commaerr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#commaerr" class="anchor" title="Link to commaerr">#</a>
               </h3>
               
               <pre><code class="language-go">const commaerr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="commaok" data-name="commaok">
               <h3>
                  commaok 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#commaok" class="anchor" title="Link to commaok">#</a>
               </h3>
               
               <pre><code class="language-go">const commaok</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="complete" data-name="complete">
               <h3>
                  complete 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#complete" class="anchor" title="Link to complete">#</a>
               </h3>
               
               <pre><code class="language-go">const complete</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="constant_" data-name="constant_">
               <h3>
                  constant_ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#constant_" class="anchor" title="Link to constant_">#</a>
               </h3>
               
               <pre><code class="language-go">const constant_</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="continueOk" data-name="continueOk">
               <h3>
                  continueOk 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#continueOk" class="anchor" title="Link to continueOk">#</a>
               </h3>
               
               <pre><code class="language-go">const continueOk</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="conversion" data-name="conversion">
               <h3>
                  conversion 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#conversion" class="anchor" title="Link to conversion">#</a>
               </h3>
               
               <pre><code class="language-go">const conversion exprKind = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debug" data-name="debug">
               <h3>
                  debug 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debug" class="anchor" title="Link to debug">#</a>
               </h3>
               
               <p>debugging/development support</p>
               
               <pre><code class="language-go">const debug = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="emptyInterface" data-name="emptyInterface">
               <h3>
                  emptyInterface 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#emptyInterface" class="anchor" title="Link to emptyInterface">#</a>
               </h3>
               
               <p>emptyInterface represents the empty interface</p>
               
               <pre><code class="language-go">var emptyInterface = Interface{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="enableCoreTypeUnification" data-name="enableCoreTypeUnification">
               <h3>
                  enableCoreTypeUnification 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#enableCoreTypeUnification" class="anchor" title="Link to enableCoreTypeUnification">#</a>
               </h3>
               
               <p>If enableCoreTypeUnification is set, unification will consider
the core types, if any, of non-local (unbound) type parameters.</p>
               
               <pre><code class="language-go">const enableCoreTypeUnification = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="enableReverseTypeInference" data-name="enableReverseTypeInference">
               <h3>
                  enableReverseTypeInference 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#enableReverseTypeInference" class="anchor" title="Link to enableReverseTypeInference">#</a>
               </h3>
               
               <p>If enableReverseTypeInference is set, uninstantiated and
partially instantiated generic functions may be assigned
(incl. returned) to variables of function type and type
inference will attempt to infer the missing type arguments.
Available with go1.21.</p>
               
               <pre><code class="language-go">const enableReverseTypeInference = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exact" data-name="exact">
               <h3>
                  exact 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exact" class="anchor" title="Link to exact">#</a>
               </h3>
               
               <p>If exact is set, types unify if they are identical (or can be
made identical with suitable arguments for type parameters).
Otherwise, a named type and a type literal unify if their
underlying types unify, channel directions are ignored, and
if there is an interface, the other type must implement the
interface.</p>
               
               <pre><code class="language-go">const exact</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="expression" data-name="expression">
               <h3>
                  expression 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#expression" class="anchor" title="Link to expression">#</a>
               </h3>
               
               <pre><code class="language-go">const expression</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fallthroughOk" data-name="fallthroughOk">
               <h3>
                  fallthroughOk 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#fallthroughOk" class="anchor" title="Link to fallthroughOk">#</a>
               </h3>
               
               <pre><code class="language-go">const fallthroughOk</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="finalSwitchCase" data-name="finalSwitchCase">
               <h3>
                  finalSwitchCase 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#finalSwitchCase" class="anchor" title="Link to finalSwitchCase">#</a>
               </h3>
               
               <p>additional context information</p>
               
               <pre><code class="language-go">const finalSwitchCase</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gcArchSizes" data-name="gcArchSizes">
               <h3>
                  gcArchSizes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gcArchSizes" class="anchor" title="Link to gcArchSizes">#</a>
               </h3>
               
               <p>common architecture word sizes and alignments</p>
               
               <pre><code class="language-go">var gcArchSizes = map[string]*gcSizes{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoArchSizes" data-name="gccgoArchSizes">
               <h3>
                  gccgoArchSizes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gccgoArchSizes" class="anchor" title="Link to gccgoArchSizes">#</a>
               </h3>
               
               <pre><code class="language-go">var gccgoArchSizes = map[string]*StdSizes{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="go1_13" data-name="go1_13">
               <h3>
                  go1_13 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#go1_13" class="anchor" title="Link to go1_13">#</a>
               </h3>
               
               <pre><code class="language-go">var go1_13 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="go1_14" data-name="go1_14">
               <h3>
                  go1_14 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#go1_14" class="anchor" title="Link to go1_14">#</a>
               </h3>
               
               <pre><code class="language-go">var go1_14 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="go1_17" data-name="go1_17">
               <h3>
                  go1_17 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#go1_17" class="anchor" title="Link to go1_17">#</a>
               </h3>
               
               <pre><code class="language-go">var go1_17 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="go1_18" data-name="go1_18">
               <h3>
                  go1_18 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#go1_18" class="anchor" title="Link to go1_18">#</a>
               </h3>
               
               <pre><code class="language-go">var go1_18 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="go1_20" data-name="go1_20">
               <h3>
                  go1_20 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#go1_20" class="anchor" title="Link to go1_20">#</a>
               </h3>
               
               <pre><code class="language-go">var go1_20 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="go1_21" data-name="go1_21">
               <h3>
                  go1_21 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#go1_21" class="anchor" title="Link to go1_21">#</a>
               </h3>
               
               <pre><code class="language-go">var go1_21 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="go1_22" data-name="go1_22">
               <h3>
                  go1_22 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#go1_22" class="anchor" title="Link to go1_22">#</a>
               </h3>
               
               <pre><code class="language-go">var go1_22 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="go1_23" data-name="go1_23">
               <h3>
                  go1_23 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#go1_23" class="anchor" title="Link to go1_23">#</a>
               </h3>
               
               <pre><code class="language-go">var go1_23 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="go1_9" data-name="go1_9">
               <h3>
                  go1_9 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#go1_9" class="anchor" title="Link to go1_9">#</a>
               </h3>
               
               <p>Go versions that introduced language changes</p>
               
               <pre><code class="language-go">var go1_9 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="go_current" data-name="go_current">
               <h3>
                  go_current 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#go_current" class="anchor" title="Link to go_current">#</a>
               </h3>
               
               <p>current (deployed) Go version</p>
               
               <pre><code class="language-go">var go_current = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="grey" data-name="grey">
               <h3>
                  grey 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#grey" class="anchor" title="Link to grey">#</a>
               </h3>
               
               <p>An object may be painted in one of three colors.
Color values other than white or black are considered grey.</p>
               
               <pre><code class="language-go">const grey</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inTypeSwitch" data-name="inTypeSwitch">
               <h3>
                  inTypeSwitch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inTypeSwitch" class="anchor" title="Link to inTypeSwitch">#</a>
               </h3>
               
               <pre><code class="language-go">const inTypeSwitch</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="invalid" data-name="invalid">
               <h3>
                  invalid 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#invalid" class="anchor" title="Link to invalid">#</a>
               </h3>
               
               <pre><code class="language-go">const invalid operandMode = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="invalidArg" data-name="invalidArg">
               <h3>
                  invalidArg 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#invalidArg" class="anchor" title="Link to invalidArg">#</a>
               </h3>
               
               <pre><code class="language-go">const invalidArg = "invalid argument: "</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="invalidOp" data-name="invalidOp">
               <h3>
                  invalidOp 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#invalidOp" class="anchor" title="Link to invalidOp">#</a>
               </h3>
               
               <pre><code class="language-go">const invalidOp = "invalid operation: "</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="invalidTypeSet" data-name="invalidTypeSet">
               <h3>
                  invalidTypeSet 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#invalidTypeSet" class="anchor" title="Link to invalidTypeSet">#</a>
               </h3>
               
               <p>invalidTypeSet is a singleton type set to signal an invalid type set
due to an error. It's also a valid empty type set, so consumers of
type sets may choose to ignore it.</p>
               
               <pre><code class="language-go">var invalidTypeSet _TypeSet</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="isTypes2" data-name="isTypes2">
               <h3>
                  isTypes2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#isTypes2" class="anchor" title="Link to isTypes2">#</a>
               </h3>
               
               <pre><code class="language-go">const isTypes2 = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="kind2tok" data-name="kind2tok">
               <h3>
                  kind2tok 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#kind2tok" class="anchor" title="Link to kind2tok">#</a>
               </h3>
               
               <pre><code class="language-go">var kind2tok = [...]token.Token{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="lastID" data-name="lastID">
               <h3>
                  lastID 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#lastID" class="anchor" title="Link to lastID">#</a>
               </h3>
               
               <p>Note: This is a uint32 rather than a uint64 because the
respective 64 bit atomic instructions are not available
on all platforms.</p>
               
               <pre><code class="language-go">var lastID atomic.Uint32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapindex" data-name="mapindex">
               <h3>
                  mapindex 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mapindex" class="anchor" title="Link to mapindex">#</a>
               </h3>
               
               <pre><code class="language-go">const mapindex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxTermCount" data-name="maxTermCount">
               <h3>
                  maxTermCount 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxTermCount" class="anchor" title="Link to maxTermCount">#</a>
               </h3>
               
               <p>Avoid excessive type-checking times due to quadratic termlist operations.</p>
               
               <pre><code class="language-go">const maxTermCount = 100</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nilvalue" data-name="nilvalue">
               <h3>
                  nilvalue 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#nilvalue" class="anchor" title="Link to nilvalue">#</a>
               </h3>
               
               <pre><code class="language-go">const nilvalue</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nopos" data-name="nopos">
               <h3>
                  nopos 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#nopos" class="anchor" title="Link to nopos">#</a>
               </h3>
               
               <p>nopos indicates an unknown position</p>
               
               <pre><code class="language-go">var nopos syntax.Pos</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="novalue" data-name="novalue">
               <h3>
                  novalue 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#novalue" class="anchor" title="Link to novalue">#</a>
               </h3>
               
               <pre><code class="language-go">const novalue</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="op2str1" data-name="op2str1">
               <h3>
                  op2str1 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#op2str1" class="anchor" title="Link to op2str1">#</a>
               </h3>
               
               <pre><code class="language-go">var op2str1 = [...]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="op2str2" data-name="op2str2">
               <h3>
                  op2str2 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#op2str2" class="anchor" title="Link to op2str2">#</a>
               </h3>
               
               <p>This is only used for operations that may cause overflow.</p>
               
               <pre><code class="language-go">var op2str2 = [...]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="op2tok" data-name="op2tok">
               <h3>
                  op2tok 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#op2tok" class="anchor" title="Link to op2tok">#</a>
               </h3>
               
               <p>op2tok translates syntax.Operators into token.Tokens.</p>
               
               <pre><code class="language-go">var op2tok = [...]token.Token{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="operandModeString" data-name="operandModeString">
               <h3>
                  operandModeString 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#operandModeString" class="anchor" title="Link to operandModeString">#</a>
               </h3>
               
               <pre><code class="language-go">var operandModeString = [...]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="panicAtUnificationDepthLimit" data-name="panicAtUnificationDepthLimit">
               <h3>
                  panicAtUnificationDepthLimit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#panicAtUnificationDepthLimit" class="anchor" title="Link to panicAtUnificationDepthLimit">#</a>
               </h3>
               
               <p>Whether to panic when unificationDepthLimit is reached.
If disabled, a recursion depth overflow results in a (quiet)
unification failure.</p>
               
               <pre><code class="language-go">const panicAtUnificationDepthLimit = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="predeclaredConsts" data-name="predeclaredConsts">
               <h3>
                  predeclaredConsts 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#predeclaredConsts" class="anchor" title="Link to predeclaredConsts">#</a>
               </h3>
               
               <pre><code class="language-go">var predeclaredConsts = [...]struct{...}{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="predeclaredFuncs" data-name="predeclaredFuncs">
               <h3>
                  predeclaredFuncs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#predeclaredFuncs" class="anchor" title="Link to predeclaredFuncs">#</a>
               </h3>
               
               <pre><code class="language-go">var predeclaredFuncs = [...]struct{...}{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="resolved" data-name="resolved">
               <h3>
                  resolved 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#resolved" class="anchor" title="Link to resolved">#</a>
               </h3>
               
               <pre><code class="language-go">const resolved</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="statement" data-name="statement">
               <h3>
                  statement 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#statement" class="anchor" title="Link to statement">#</a>
               </h3>
               
               <pre><code class="language-go">const statement</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdSizes" data-name="stdSizes">
               <h3>
                  stdSizes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#stdSizes" class="anchor" title="Link to stdSizes">#</a>
               </h3>
               
               <p>stdSizes is used if Config.Sizes == nil.</p>
               
               <pre><code class="language-go">var stdSizes = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="termSep" data-name="termSep">
               <h3>
                  termSep 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#termSep" class="anchor" title="Link to termSep">#</a>
               </h3>
               
               <p>termSep is the separator used between individual terms.</p>
               
               <pre><code class="language-go">const termSep = " | "</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="topTypeSet" data-name="topTypeSet">
               <h3>
                  topTypeSet 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#topTypeSet" class="anchor" title="Link to topTypeSet">#</a>
               </h3>
               
               <p>topTypeSet may be used as type set for the empty interface.</p>
               
               <pre><code class="language-go">var topTypeSet = _TypeSet{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="traceInference" data-name="traceInference">
               <h3>
                  traceInference 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#traceInference" class="anchor" title="Link to traceInference">#</a>
               </h3>
               
               <p>If traceInference is set, unification will print a trace of its operation.
Interpretation of trace:
x ≡ y    attempt to unify types x and y
p ➞ y    type parameter p is set to type y (p is inferred to be y)
p ⇄ q    type parameters p and q match (p is inferred to be q and vice versa)
x ≢ y    types x and y cannot be unified
[p, q, ...] ➞ [x, y, ...]    mapping from type parameters to types</p>
               
               <pre><code class="language-go">const traceInference = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="typexpr" data-name="typexpr">
               <h3>
                  typexpr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#typexpr" class="anchor" title="Link to typexpr">#</a>
               </h3>
               
               <pre><code class="language-go">const typexpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unaryOpPredicates" data-name="unaryOpPredicates">
               <h3>
                  unaryOpPredicates 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#unaryOpPredicates" class="anchor" title="Link to unaryOpPredicates">#</a>
               </h3>
               
               <pre><code class="language-go">var unaryOpPredicates opPredicates</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unificationDepthLimit" data-name="unificationDepthLimit">
               <h3>
                  unificationDepthLimit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#unificationDepthLimit" class="anchor" title="Link to unificationDepthLimit">#</a>
               </h3>
               
               <p>Upper limit for recursion depth. Used to catch infinite recursions
due to implementation issues (e.g., see issues go.dev/issue/48619, go.dev/issue/48656).</p>
               
               <pre><code class="language-go">const unificationDepthLimit = 50</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="universeAnyAlias" data-name="universeAnyAlias">
               <h3>
                  universeAnyAlias 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#universeAnyAlias" class="anchor" title="Link to universeAnyAlias">#</a>
               </h3>
               
               <pre><code class="language-go">var universeAnyAlias *TypeName</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="universeAnyNoAlias" data-name="universeAnyNoAlias">
               <h3>
                  universeAnyNoAlias 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#universeAnyNoAlias" class="anchor" title="Link to universeAnyNoAlias">#</a>
               </h3>
               
               <pre><code class="language-go">var universeAnyNoAlias *TypeName</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="universeBool" data-name="universeBool">
               <h3>
                  universeBool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#universeBool" class="anchor" title="Link to universeBool">#</a>
               </h3>
               
               <pre><code class="language-go">var universeBool Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="universeByte" data-name="universeByte">
               <h3>
                  universeByte 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#universeByte" class="anchor" title="Link to universeByte">#</a>
               </h3>
               
               <pre><code class="language-go">var universeByte Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="universeComparable" data-name="universeComparable">
               <h3>
                  universeComparable 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#universeComparable" class="anchor" title="Link to universeComparable">#</a>
               </h3>
               
               <pre><code class="language-go">var universeComparable Object</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="universeError" data-name="universeError">
               <h3>
                  universeError 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#universeError" class="anchor" title="Link to universeError">#</a>
               </h3>
               
               <pre><code class="language-go">var universeError Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="universeIota" data-name="universeIota">
               <h3>
                  universeIota 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#universeIota" class="anchor" title="Link to universeIota">#</a>
               </h3>
               
               <pre><code class="language-go">var universeIota Object</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="universeRune" data-name="universeRune">
               <h3>
                  universeRune 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#universeRune" class="anchor" title="Link to universeRune">#</a>
               </h3>
               
               <pre><code class="language-go">var universeRune Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unresolved" data-name="unresolved">
               <h3>
                  unresolved 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#unresolved" class="anchor" title="Link to unresolved">#</a>
               </h3>
               
               <pre><code class="language-go">const unresolved namedState = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="value" data-name="value">
               <h3>
                  value 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#value" class="anchor" title="Link to value">#</a>
               </h3>
               
               <pre><code class="language-go">const value</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="variable" data-name="variable">
               <h3>
                  variable 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#variable" class="anchor" title="Link to variable">#</a>
               </h3>
               
               <pre><code class="language-go">const variable</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="white" data-name="white">
               <h3>
                  white 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#white" class="anchor" title="Link to white">#</a>
               </h3>
               
               <p>An object may be painted in one of three colors.
Color values other than white or black are considered grey.</p>
               
               <pre><code class="language-go">const white color = iota</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="BasicInfo" data-name="BasicInfo">
               <h3>
                  BasicInfo
                  <span class="badge type-badge">type</span>
                  <a href="#BasicInfo" class="anchor" title="Link to BasicInfo">#</a>
               </h3>
               
               <p>BasicInfo is a set of flags describing properties of a basic type.</p>
               
               <pre><code class="language-go">type BasicInfo int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="BasicKind" data-name="BasicKind">
               <h3>
                  BasicKind
                  <span class="badge type-badge">type</span>
                  <a href="#BasicKind" class="anchor" title="Link to BasicKind">#</a>
               </h3>
               
               <p>BasicKind describes the kind of basic type.</p>
               
               <pre><code class="language-go">type BasicKind int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="ChanDir" data-name="ChanDir">
               <h3>
                  ChanDir
                  <span class="badge type-badge">type</span>
                  <a href="#ChanDir" class="anchor" title="Link to ChanDir">#</a>
               </h3>
               
               <p>A ChanDir value indicates a channel direction.</p>
               
               <pre><code class="language-go">type ChanDir int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="ImportMode" data-name="ImportMode">
               <h3>
                  ImportMode
                  <span class="badge type-badge">type</span>
                  <a href="#ImportMode" class="anchor" title="Link to ImportMode">#</a>
               </h3>
               
               <p>ImportMode is reserved for future use.</p>
               
               <pre><code class="language-go">type ImportMode int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Qualifier" data-name="Qualifier">
               <h3>
                  Qualifier
                  <span class="badge type-badge">type</span>
                  <a href="#Qualifier" class="anchor" title="Link to Qualifier">#</a>
               </h3>
               
               <p>A Qualifier controls how named package-level objects are printed in
calls to [TypeString], [ObjectString], and [SelectionString].
These three formatting routines call the Qualifier for each
package-level object O, and if the Qualifier returns a non-empty
string p, the object is printed in the form p.O.
If it returns an empty string, only the object name O is printed.
Using a nil Qualifier is equivalent to using (*[Package]).Path: the
object is qualified by the import path, e.g., "encoding/json.Marshal".</p>
               
               <pre><code class="language-go">type Qualifier func(*Package) string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="SelectionKind" data-name="SelectionKind">
               <h3>
                  SelectionKind
                  <span class="badge type-badge">type</span>
                  <a href="#SelectionKind" class="anchor" title="Link to SelectionKind">#</a>
               </h3>
               
               <p>SelectionKind describes the kind of a selector expression x.f
(excluding qualified identifiers).
If x is a struct or *struct, a selector expression x.f may denote a
sequence of selection operations x.a.b.c.f. The SelectionKind
describes the kind of the final (explicit) operation; all the
previous (implicit) operations are always field selections.
Each element of Indices specifies an implicit field (a, b, c)
by its index in the struct type of the field selection operand.
For a FieldVal operation, the final selection refers to the field
specified by Selection.Obj.
For a MethodVal operation, the final selection refers to a method.
If the "pointerness" of the method's declared receiver does not
match that of the effective receiver after implicit field
selection, then an & or * operation is implicitly applied to the
receiver variable or value.
So, x.f denotes (&x.a.b.c).f when f requires a pointer receiver but
x.a.b.c is a non-pointer variable; and it denotes (*x.a.b.c).f when
f requires a non-pointer receiver but x.a.b.c is a pointer value.
All pointer indirections, whether due to implicit or explicit field
selections or * operations inserted for "pointerness", panic if
applied to a nil pointer, so a method call x.f() may panic even
before the function call.
By contrast, a MethodExpr operation T.f is essentially equivalent
to a function literal of the form:
func(x T, args) (results) { return x.f(args) }
Consequently, any implicit field selections and * operations
inserted for "pointerness" are not evaluated until the function is
called, so a T.f or (*T).f expression never panics.</p>
               
               <pre><code class="language-go">type SelectionKind int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Term" data-name="Term">
               <h3>
                  Term
                  <span class="badge type-badge">type</span>
                  <a href="#Term" class="anchor" title="Link to Term">#</a>
               </h3>
               
               <p>A Term represents a term in a Union.</p>
               
               <pre><code class="language-go">type Term term</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type
                  <span class="badge type-badge">type</span>
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <p>A Type represents a type of Go.
All types implement the Type interface.</p>
               
               <pre><code class="language-go">type Type syntax.Type</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="builtinId" data-name="builtinId">
               <h3>
                  builtinId
                  <span class="badge type-badge">type</span>
                  <a href="#builtinId" class="anchor" title="Link to builtinId">#</a>
               </h3>
               
               <p>A builtinId is the id of a builtin function.</p>
               
               <pre><code class="language-go">type builtinId int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="color" data-name="color">
               <h3>
                  color
                  <span class="badge type-badge">type</span>
                  <a href="#color" class="anchor" title="Link to color">#</a>
               </h3>
               
               <p>color encodes the color of an object (see Checker.objDecl for details).</p>
               
               <pre><code class="language-go">type color uint32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="exprKind" data-name="exprKind">
               <h3>
                  exprKind
                  <span class="badge type-badge">type</span>
                  <a href="#exprKind" class="anchor" title="Link to exprKind">#</a>
               </h3>
               
               <p>exprKind describes the kind of an expression; the kind
determines if an expression is valid in 'statement context'.</p>
               
               <pre><code class="language-go">type exprKind int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="goVersion" data-name="goVersion">
               <h3>
                  goVersion
                  <span class="badge type-badge">type</span>
                  <a href="#goVersion" class="anchor" title="Link to goVersion">#</a>
               </h3>
               
               <p>A goVersion is a Go language version string of the form "go1.%d"
where d is the minor version number. goVersion strings don't
contain release numbers ("go1.20.1" is not a valid goVersion).</p>
               
               <pre><code class="language-go">type goVersion string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="namedState" data-name="namedState">
               <h3>
                  namedState
                  <span class="badge type-badge">type</span>
                  <a href="#namedState" class="anchor" title="Link to namedState">#</a>
               </h3>
               
               <p>namedState represents the possible states that a named type may assume.</p>
               
               <pre><code class="language-go">type namedState uint32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="nodeQueue" data-name="nodeQueue">
               <h3>
                  nodeQueue
                  <span class="badge type-badge">type</span>
                  <a href="#nodeQueue" class="anchor" title="Link to nodeQueue">#</a>
               </h3>
               
               <p>nodeQueue implements the container/heap interface;
a nodeQueue may be used as a priority queue.</p>
               
               <pre><code class="language-go">type nodeQueue []*graphNode</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="nodeSet" data-name="nodeSet">
               <h3>
                  nodeSet
                  <span class="badge type-badge">type</span>
                  <a href="#nodeSet" class="anchor" title="Link to nodeSet">#</a>
               </h3>
               
               <pre><code class="language-go">type nodeSet map[*graphNode]bool</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="objset" data-name="objset">
               <h3>
                  objset
                  <span class="badge type-badge">type</span>
                  <a href="#objset" class="anchor" title="Link to objset">#</a>
               </h3>
               
               <p>An objset is a set of objects identified by their unique id.
The zero value for objset is a ready-to-use empty objset.</p>
               
               <pre><code class="language-go">type objset map[string]Object</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="opPredicates" data-name="opPredicates">
               <h3>
                  opPredicates
                  <span class="badge type-badge">type</span>
                  <a href="#opPredicates" class="anchor" title="Link to opPredicates">#</a>
               </h3>
               
               <pre><code class="language-go">type opPredicates map[syntax.Operator]func(Type) bool</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="operandMode" data-name="operandMode">
               <h3>
                  operandMode
                  <span class="badge type-badge">type</span>
                  <a href="#operandMode" class="anchor" title="Link to operandMode">#</a>
               </h3>
               
               <p>An operandMode specifies the (addressing) mode of an operand.</p>
               
               <pre><code class="language-go">type operandMode byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="stmtContext" data-name="stmtContext">
               <h3>
                  stmtContext
                  <span class="badge type-badge">type</span>
                  <a href="#stmtContext" class="anchor" title="Link to stmtContext">#</a>
               </h3>
               
               <p>stmtContext is a bitset describing which
control-flow statements are permissible,
and provides additional context information
for better error messages.</p>
               
               <pre><code class="language-go">type stmtContext uint</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="substMap" data-name="substMap">
               <h3>
                  substMap
                  <span class="badge type-badge">type</span>
                  <a href="#substMap" class="anchor" title="Link to substMap">#</a>
               </h3>
               
               <pre><code class="language-go">type substMap map[*TypeParam]Type</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="termlist" data-name="termlist">
               <h3>
                  termlist
                  <span class="badge type-badge">type</span>
                  <a href="#termlist" class="anchor" title="Link to termlist">#</a>
               </h3>
               
               <p>A termlist represents the type set represented by the union
t1 ∪ y2 ∪ ... tn of the type sets of the terms t1 to tn.
A termlist is in normal form if all terms are disjoint.
termlist operations don't require the operands to be in
normal form.</p>
               
               <pre><code class="language-go">type termlist []*term</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="typeParamsById" data-name="typeParamsById">
               <h3>
                  typeParamsById
                  <span class="badge type-badge">type</span>
                  <a href="#typeParamsById" class="anchor" title="Link to typeParamsById">#</a>
               </h3>
               
               <pre><code class="language-go">type typeParamsById []*TypeParam</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="unifyMode" data-name="unifyMode">
               <h3>
                  unifyMode
                  <span class="badge type-badge">type</span>
                  <a href="#unifyMode" class="anchor" title="Link to unifyMode">#</a>
               </h3>
               
               <p>unifyMode controls the behavior of the unifier.</p>
               
               <pre><code class="language-go">type unifyMode uint</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="valueMap" data-name="valueMap">
               <h3>
                  valueMap
                  <span class="badge type-badge">type</span>
                  <a href="#valueMap" class="anchor" title="Link to valueMap">#</a>
               </h3>
               
               <p>A valueMap maps a case value (of a basic Go type) to a list of positions
where the same case value appeared, together with the corresponding case
types.
Since two case values may have the same "underlying" value but different
types we need to also check the value's types (e.g., byte(1) vs myByte(1))
when the switch expression is of interface type.</p>
               
               <pre><code class="language-go">type valueMap map[interface{}][]valueType</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Importer" data-name="Importer">
               <h3>
                  Importer
                  <span class="badge interface-badge">interface</span>
                  <a href="#Importer" class="anchor" title="Link to Importer">#</a>
               </h3>
               
               <p>An Importer resolves import paths to Packages.
CAUTION: This interface does not support the import of locally
vendored packages. See https://golang.org/s/go15vendor.
If possible, external implementations should implement ImporterFrom.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Importer interface {
Import(path string) (*Package, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="ImporterFrom" data-name="ImporterFrom">
               <h3>
                  ImporterFrom
                  <span class="badge interface-badge">interface</span>
                  <a href="#ImporterFrom" class="anchor" title="Link to ImporterFrom">#</a>
               </h3>
               
               <p>An ImporterFrom resolves import paths to packages; it
supports vendoring per https://golang.org/s/go15vendor.
Use go/importer to obtain an ImporterFrom implementation.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type ImporterFrom interface {
Importer
ImportFrom(path string, dir string, mode ImportMode) (*Package, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Object" data-name="Object">
               <h3>
                  Object
                  <span class="badge interface-badge">interface</span>
                  <a href="#Object" class="anchor" title="Link to Object">#</a>
               </h3>
               
               <p>An Object is a named language entity.
An Object may be a constant ([Const]), type name ([TypeName]),
variable or struct field ([Var]), function or method ([Func]),
imported package ([PkgName]), label ([Label]),
built-in function ([Builtin]),
or the predeclared identifier 'nil' ([Nil]).
The environment, which is structured as a tree of Scopes,
maps each name to the unique Object that it denotes.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Object interface {
Parent() *Scope
Pos() syntax.Pos
Pkg() *Package
Name() string
Type() Type
Exported() bool
Id() string
String() string
order() uint32
color() color
setType(Type)
setOrder(uint32)
setColor(color color)
setParent(*Scope)
sameId(pkg *Package, name string, foldCase bool) bool
scopePos() syntax.Pos
setScopePos(pos syntax.Pos)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Sizes" data-name="Sizes">
               <h3>
                  Sizes
                  <span class="badge interface-badge">interface</span>
                  <a href="#Sizes" class="anchor" title="Link to Sizes">#</a>
               </h3>
               
               <p>Sizes defines the sizing functions for package unsafe.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Sizes interface {
Alignof(T Type) int64
Offsetsof(fields []*Var) []int64
Sizeof(T Type) int64
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="cleaner" data-name="cleaner">
               <h3>
                  cleaner
                  <span class="badge interface-badge">interface</span>
                  <a href="#cleaner" class="anchor" title="Link to cleaner">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type cleaner interface {
cleanup()
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="dependency" data-name="dependency">
               <h3>
                  dependency
                  <span class="badge interface-badge">interface</span>
                  <a href="#dependency" class="anchor" title="Link to dependency">#</a>
               </h3>
               
               <p>A dependency is an object that may be a dependency in an initialization
expression. Only constants, variables, and functions can be dependencies.
Constants are here because constant expression cycles are reported during
initialization order computation.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type dependency interface {
Object
isDependency()
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="genericType" data-name="genericType">
               <h3>
                  genericType
                  <span class="badge interface-badge">interface</span>
                  <a href="#genericType" class="anchor" title="Link to genericType">#</a>
               </h3>
               
               <p>A genericType implements access to its type parameters.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type genericType interface {
Type
TypeParams() *TypeParamList
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="poser" data-name="poser">
               <h3>
                  poser
                  <span class="badge interface-badge">interface</span>
                  <a href="#poser" class="anchor" title="Link to poser">#</a>
               </h3>
               
               <p>The poser interface is used to extract the position of type-checker errors.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type poser interface {
Pos() syntax.Pos
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Alias" data-name="Alias">
               <h3>
                  Alias
                  <span class="badge">struct</span>
                  <a href="#Alias" class="anchor" title="Link to Alias">#</a>
               </h3>
               
               <p>An Alias represents an alias type.
Alias types are created by alias declarations such as:
type A = int
The type on the right-hand side of the declaration can be accessed
using [Alias.Rhs]. This type may itself be an alias.
Call [Unalias] to obtain the first non-alias type in a chain of
alias type declarations.
Like a defined ([Named]) type, an alias type has a name.
Use the [Alias.Obj] method to access its [TypeName] object.
Historically, Alias types were not materialized so that, in the example
above, A's type was represented by a Basic (int), not an Alias
whose [Alias.Rhs] is int. But Go 1.24 allows you to declare an
alias type with type parameters or arguments:
type Set[K comparable] = map[K]bool
s := make(Set[String])
and this requires that Alias types be materialized. Use the
[Alias.TypeParams] and [Alias.TypeArgs] methods to access them.
To ease the transition, the Alias type was introduced in go1.22,
but the type-checker would not construct values of this type unless
the GODEBUG=gotypesalias=1 environment variable was provided.
Starting in go1.23, this variable is enabled by default.
This setting also causes the predeclared type "any" to be
represented as an Alias, not a bare [Interface].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Alias struct {
obj *TypeName
orig *Alias
tparams *TypeParamList
targs *TypeList
fromRHS Type
actual Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ArgumentError" data-name="ArgumentError">
               <h3>
                  ArgumentError
                  <span class="badge">struct</span>
                  <a href="#ArgumentError" class="anchor" title="Link to ArgumentError">#</a>
               </h3>
               
               <p>An ArgumentError holds an error associated with an argument index.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ArgumentError struct {
Index int
Err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Array" data-name="Array">
               <h3>
                  Array
                  <span class="badge">struct</span>
                  <a href="#Array" class="anchor" title="Link to Array">#</a>
               </h3>
               
               <p>An Array represents an array type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Array struct {
len int64
elem Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Basic" data-name="Basic">
               <h3>
                  Basic
                  <span class="badge">struct</span>
                  <a href="#Basic" class="anchor" title="Link to Basic">#</a>
               </h3>
               
               <p>A Basic represents a basic type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Basic struct {
kind BasicKind
info BasicInfo
name string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Builtin" data-name="Builtin">
               <h3>
                  Builtin
                  <span class="badge">struct</span>
                  <a href="#Builtin" class="anchor" title="Link to Builtin">#</a>
               </h3>
               
               <p>A Builtin represents a built-in function.
Builtins don't have a valid type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Builtin struct {
object
id builtinId
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Chan" data-name="Chan">
               <h3>
                  Chan
                  <span class="badge">struct</span>
                  <a href="#Chan" class="anchor" title="Link to Chan">#</a>
               </h3>
               
               <p>A Chan represents a channel type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Chan struct {
dir ChanDir
elem Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Checker" data-name="Checker">
               <h3>
                  Checker
                  <span class="badge">struct</span>
                  <a href="#Checker" class="anchor" title="Link to Checker">#</a>
               </h3>
               
               <p>A Checker maintains the state of the type checker.
It must be created with NewChecker.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Checker struct {
conf *Config
ctxt *Context
pkg *Package
*Info
nextID uint64
objMap map[Object]*declInfo
impMap map[importKey]*Package
pkgPathMap map[string]map[string]bool
seenPkgMap map[*Package]bool
files []*syntax.File
versions map[*syntax.PosBase]string
imports []*PkgName
dotImportMap map[dotImportKey]*PkgName
brokenAliases map[*TypeName]bool
unionTypeSets map[*Union]*_TypeSet
usedVars map[*Var]bool
usedPkgNames map[*PkgName]bool
mono monoGraph
firstErr error
methods map[*TypeName][]*Func
untyped map[syntax.Expr]exprInfo
delayed []action
objPath []Object
cleaners []cleaner
environment
indent int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Config" data-name="Config">
               <h3>
                  Config
                  <span class="badge">struct</span>
                  <a href="#Config" class="anchor" title="Link to Config">#</a>
               </h3>
               
               <p>A Config specifies the configuration for type checking.
The zero value for Config is a ready-to-use default configuration.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Config struct {
Context *Context
GoVersion string
IgnoreFuncBodies bool
FakeImportC bool
IgnoreBranchErrors bool
go115UsesCgo bool
Trace bool
Error func(err error)
Importer Importer
Sizes Sizes
DisableUnusedImportCheck bool
ErrorURL string
EnableAlias bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Const" data-name="Const">
               <h3>
                  Const
                  <span class="badge">struct</span>
                  <a href="#Const" class="anchor" title="Link to Const">#</a>
               </h3>
               
               <p>A Const represents a declared constant.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Const struct {
object
val constant.Value
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Context" data-name="Context">
               <h3>
                  Context
                  <span class="badge">struct</span>
                  <a href="#Context" class="anchor" title="Link to Context">#</a>
               </h3>
               
               <p>A Context is an opaque type checking context. It may be used to share
identical type instances across type-checked packages or calls to
Instantiate. Contexts are safe for concurrent use.
The use of a shared context does not guarantee that identical instances are
deduplicated in all cases.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Context struct {
mu sync.Mutex
typeMap map[string][]ctxtEntry
nextID int
originIDs map[Type]int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error
                  <span class="badge">struct</span>
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <p>An Error describes a type-checking error; it implements the error interface.
A "soft" error is an error that still permits a valid interpretation of a
package (such as "unused variable"); "hard" errors may lead to unpredictable
behavior if ignored.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Error struct {
Pos syntax.Pos
Msg string
Full string
Soft bool
Code Code
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Func" data-name="Func">
               <h3>
                  Func
                  <span class="badge">struct</span>
                  <a href="#Func" class="anchor" title="Link to Func">#</a>
               </h3>
               
               <p>A Func represents a declared function, concrete method, or abstract
(interface) method. Its Type() is always a *Signature.
An abstract method may belong to many interfaces due to embedding.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Func struct {
object
hasPtrRecv_ bool
origin *Func
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Info" data-name="Info">
               <h3>
                  Info
                  <span class="badge">struct</span>
                  <a href="#Info" class="anchor" title="Link to Info">#</a>
               </h3>
               
               <p>Info holds result type information for a type-checked package.
Only the information for which a map is provided is collected.
If the package has type errors, the collected information may
be incomplete.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Info struct {
Types map[syntax.Expr]TypeAndValue
StoreTypesInSyntax bool
Instances map[*syntax.Name]Instance
Defs map[*syntax.Name]Object
Uses map[*syntax.Name]Object
Implicits map[syntax.Node]Object
Selections map[*syntax.SelectorExpr]*Selection
Scopes map[syntax.Node]*Scope
InitOrder []*Initializer
FileVersions map[*syntax.PosBase]string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Initializer" data-name="Initializer">
               <h3>
                  Initializer
                  <span class="badge">struct</span>
                  <a href="#Initializer" class="anchor" title="Link to Initializer">#</a>
               </h3>
               
               <p>An Initializer describes a package-level variable, or a list of variables in case
of a multi-valued initialization expression, and the corresponding initialization
expression.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Initializer struct {
Lhs []*Var
Rhs syntax.Expr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Instance" data-name="Instance">
               <h3>
                  Instance
                  <span class="badge">struct</span>
                  <a href="#Instance" class="anchor" title="Link to Instance">#</a>
               </h3>
               
               <p>Instance reports the type arguments and instantiated type for type and
function instantiations. For type instantiations, Type will be of dynamic
type *Named. For function instantiations, Type will be of dynamic type
*Signature.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Instance struct {
TypeArgs *TypeList
Type Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Interface" data-name="Interface">
               <h3>
                  Interface
                  <span class="badge">struct</span>
                  <a href="#Interface" class="anchor" title="Link to Interface">#</a>
               </h3>
               
               <p>An Interface represents an interface type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Interface struct {
check *Checker
methods []*Func
embeddeds []Type
embedPos *[]syntax.Pos
implicit bool
complete bool
tset *_TypeSet
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Label" data-name="Label">
               <h3>
                  Label
                  <span class="badge">struct</span>
                  <a href="#Label" class="anchor" title="Link to Label">#</a>
               </h3>
               
               <p>A Label represents a declared label.
Labels don't have a type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Label struct {
object
used bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Map" data-name="Map">
               <h3>
                  Map
                  <span class="badge">struct</span>
                  <a href="#Map" class="anchor" title="Link to Map">#</a>
               </h3>
               
               <p>A Map represents a map type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Map struct {
key Type
elem Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Named" data-name="Named">
               <h3>
                  Named
                  <span class="badge">struct</span>
                  <a href="#Named" class="anchor" title="Link to Named">#</a>
               </h3>
               
               <p>A Named represents a named (defined) type.
A declaration such as:
type S struct { ... }
creates a defined type whose underlying type is a struct,
and binds this type to the object S, a [TypeName].
Use [Named.Underlying] to access the underlying type.
Use [Named.Obj] to obtain the object S.
Before type aliases (Go 1.9), the spec called defined types "named types".</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Named struct {
check *Checker
obj *TypeName
fromRHS Type
inst *instance
mu sync.Mutex
state_ uint32
underlying Type
tparams *TypeParamList
methods []*Func
loader func(*Named) (tparams []*TypeParam, underlying Type, methods []*Func)
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Nil" data-name="Nil">
               <h3>
                  Nil
                  <span class="badge">struct</span>
                  <a href="#Nil" class="anchor" title="Link to Nil">#</a>
               </h3>
               
               <p>Nil represents the predeclared value nil.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Nil struct {
object
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Package" data-name="Package">
               <h3>
                  Package
                  <span class="badge">struct</span>
                  <a href="#Package" class="anchor" title="Link to Package">#</a>
               </h3>
               
               <p>A Package describes a Go package.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Package struct {
path string
name string
scope *Scope
imports []*Package
complete bool
fake bool
cgo bool
goVersion string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PkgName" data-name="PkgName">
               <h3>
                  PkgName
                  <span class="badge">struct</span>
                  <a href="#PkgName" class="anchor" title="Link to PkgName">#</a>
               </h3>
               
               <p>A PkgName represents an imported Go package.
PkgNames don't have a type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PkgName struct {
object
imported *Package
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Pointer" data-name="Pointer">
               <h3>
                  Pointer
                  <span class="badge">struct</span>
                  <a href="#Pointer" class="anchor" title="Link to Pointer">#</a>
               </h3>
               
               <p>A Pointer represents a pointer type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Pointer struct {
base Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Scope" data-name="Scope">
               <h3>
                  Scope
                  <span class="badge">struct</span>
                  <a href="#Scope" class="anchor" title="Link to Scope">#</a>
               </h3>
               
               <p>A Scope maintains a set of objects and links to its containing
(parent) and contained (children) scopes. Objects may be inserted
and looked up by name. The zero value for Scope is a ready-to-use
empty scope.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Scope struct {
parent *Scope
children []*Scope
number int
elems map[string]Object
pos syntax.Pos
end syntax.Pos
comment string
isFunc bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Selection" data-name="Selection">
               <h3>
                  Selection
                  <span class="badge">struct</span>
                  <a href="#Selection" class="anchor" title="Link to Selection">#</a>
               </h3>
               
               <p>A Selection describes a selector expression x.f.
For the declarations:
type T struct{ x int; E }
type E struct{}
func (e E) m() {}
var p *T
the following relations exist:
Selector    Kind          Recv    Obj    Type       Index     Indirect
p.x         FieldVal      T       x      int        {0}       true
p.m         MethodVal     *T      m      func()     {1, 0}    true
T.m         MethodExpr    T       m      func(T)    {1, 0}    false</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Selection struct {
kind SelectionKind
recv Type
obj Object
index []int
indirect bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Signature" data-name="Signature">
               <h3>
                  Signature
                  <span class="badge">struct</span>
                  <a href="#Signature" class="anchor" title="Link to Signature">#</a>
               </h3>
               
               <p>A Signature represents a (non-builtin) function or method type.
The receiver is ignored when comparing signatures for identity.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Signature struct {
rparams *TypeParamList
tparams *TypeParamList
scope *Scope
recv *Var
params *Tuple
results *Tuple
variadic bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Slice" data-name="Slice">
               <h3>
                  Slice
                  <span class="badge">struct</span>
                  <a href="#Slice" class="anchor" title="Link to Slice">#</a>
               </h3>
               
               <p>A Slice represents a slice type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Slice struct {
elem Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="StdSizes" data-name="StdSizes">
               <h3>
                  StdSizes
                  <span class="badge">struct</span>
                  <a href="#StdSizes" class="anchor" title="Link to StdSizes">#</a>
               </h3>
               
               <p>StdSizes is a convenience type for creating commonly used Sizes.
It makes the following simplifying assumptions:
- The size of explicitly sized basic types (int16, etc.) is the
specified size.
- The size of strings and interfaces is 2*WordSize.
- The size of slices is 3*WordSize.
- The size of an array of n elements corresponds to the size of
a struct of n consecutive fields of the array's element type.
- The size of a struct is the offset of the last field plus that
field's size. As with all element types, if the struct is used
in an array its size must first be aligned to a multiple of the
struct's alignment.
- All other types have size WordSize.
- Arrays and structs are aligned per spec definition; all other
types are naturally aligned with a maximum alignment MaxAlign.
*StdSizes implements Sizes.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type StdSizes struct {
WordSize int64
MaxAlign int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Struct" data-name="Struct">
               <h3>
                  Struct
                  <span class="badge">struct</span>
                  <a href="#Struct" class="anchor" title="Link to Struct">#</a>
               </h3>
               
               <p>A Struct represents a struct type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Struct struct {
fields []*Var
tags []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Tuple" data-name="Tuple">
               <h3>
                  Tuple
                  <span class="badge">struct</span>
                  <a href="#Tuple" class="anchor" title="Link to Tuple">#</a>
               </h3>
               
               <p>A Tuple represents an ordered list of variables; a nil *Tuple is a valid (empty) tuple.
Tuples are used as components of signatures and to represent the type of multiple
assignments; they are not first class types of Go.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Tuple struct {
vars []*Var
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TypeAndValue" data-name="TypeAndValue">
               <h3>
                  TypeAndValue
                  <span class="badge">struct</span>
                  <a href="#TypeAndValue" class="anchor" title="Link to TypeAndValue">#</a>
               </h3>
               
               <p>TypeAndValue reports the type and value (for constants)
of the corresponding expression.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type TypeAndValue struct {
mode operandMode
Type Type
Value constant.Value
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TypeList" data-name="TypeList">
               <h3>
                  TypeList
                  <span class="badge">struct</span>
                  <a href="#TypeList" class="anchor" title="Link to TypeList">#</a>
               </h3>
               
               <p>TypeList holds a list of types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type TypeList struct {
types []Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TypeName" data-name="TypeName">
               <h3>
                  TypeName
                  <span class="badge">struct</span>
                  <a href="#TypeName" class="anchor" title="Link to TypeName">#</a>
               </h3>
               
               <p>A TypeName is an [Object] that represents a type with a name:
a defined type ([Named]),
an alias type ([Alias]),
a type parameter ([TypeParam]),
or a predeclared type such as int or error.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type TypeName struct {
object
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TypeParam" data-name="TypeParam">
               <h3>
                  TypeParam
                  <span class="badge">struct</span>
                  <a href="#TypeParam" class="anchor" title="Link to TypeParam">#</a>
               </h3>
               
               <p>A TypeParam represents the type of a type parameter in a generic declaration.
A TypeParam has a name; use the [TypeParam.Obj] method to access
its [TypeName] object.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type TypeParam struct {
check *Checker
id uint64
obj *TypeName
index int
bound Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TypeParamList" data-name="TypeParamList">
               <h3>
                  TypeParamList
                  <span class="badge">struct</span>
                  <a href="#TypeParamList" class="anchor" title="Link to TypeParamList">#</a>
               </h3>
               
               <p>TypeParamList holds a list of type parameters.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type TypeParamList struct {
tparams []*TypeParam
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Union" data-name="Union">
               <h3>
                  Union
                  <span class="badge">struct</span>
                  <a href="#Union" class="anchor" title="Link to Union">#</a>
               </h3>
               
               <p>A Union represents a union of terms embedded in an interface.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Union struct {
terms []*Term
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Var" data-name="Var">
               <h3>
                  Var
                  <span class="badge">struct</span>
                  <a href="#Var" class="anchor" title="Link to Var">#</a>
               </h3>
               
               <p>A Variable represents a declared variable (including function parameters and results, and struct fields).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Var struct {
object
origin *Var
embedded bool
isField bool
isParam bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="_TypeSet" data-name="_TypeSet">
               <h3>
                  _TypeSet
                  <span class="badge">struct</span>
                  <a href="#_TypeSet" class="anchor" title="Link to _TypeSet">#</a>
               </h3>
               
               <p>A _TypeSet represents the type set of an interface.
Because of existing language restrictions, methods can be "factored out"
from the terms. The actual type set is the intersection of the type set
implied by the methods and the type set described by the terms and the
comparable bit. To test whether a type is included in a type set
("implements" relation), the type must implement all methods _and_ be
an element of the type set described by the terms and the comparable bit.
If the term list describes the set of all types and comparable is true,
only comparable types are meant; in all other cases comparable is false.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type _TypeSet struct {
methods []*Func
terms termlist
comparable bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="action" data-name="action">
               <h3>
                  action
                  <span class="badge">struct</span>
                  <a href="#action" class="anchor" title="Link to action">#</a>
               </h3>
               
               <p>An action describes a (delayed) action.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type action struct {
version goVersion
f func()
desc *actionDesc
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="actionDesc" data-name="actionDesc">
               <h3>
                  actionDesc
                  <span class="badge">struct</span>
                  <a href="#actionDesc" class="anchor" title="Link to actionDesc">#</a>
               </h3>
               
               <p>An actionDesc provides information on an action.
For debugging only.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type actionDesc struct {
pos poser
format string
args []interface{}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="bailout" data-name="bailout">
               <h3>
                  bailout
                  <span class="badge">struct</span>
                  <a href="#bailout" class="anchor" title="Link to bailout">#</a>
               </h3>
               
               <p>A bailout panic is used for early termination.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type bailout struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="block" data-name="block">
               <h3>
                  block
                  <span class="badge">struct</span>
                  <a href="#block" class="anchor" title="Link to block">#</a>
               </h3>
               
               <p>A block tracks label declarations in a block and its enclosing blocks.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type block struct {
parent *block
lstmt *syntax.LabeledStmt
labels map[string]*syntax.LabeledStmt
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="comparer" data-name="comparer">
               <h3>
                  comparer
                  <span class="badge">struct</span>
                  <a href="#comparer" class="anchor" title="Link to comparer">#</a>
               </h3>
               
               <p>A comparer is used to compare types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type comparer struct {
ignoreTags bool
ignoreInvalids bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ctxtEntry" data-name="ctxtEntry">
               <h3>
                  ctxtEntry
                  <span class="badge">struct</span>
                  <a href="#ctxtEntry" class="anchor" title="Link to ctxtEntry">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ctxtEntry struct {
orig Type
targs []Type
instance Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cycleFinder" data-name="cycleFinder">
               <h3>
                  cycleFinder
                  <span class="badge">struct</span>
                  <a href="#cycleFinder" class="anchor" title="Link to cycleFinder">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type cycleFinder struct {
tparams []*TypeParam
inferred []Type
seen map[Type]bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="declInfo" data-name="declInfo">
               <h3>
                  declInfo
                  <span class="badge">struct</span>
                  <a href="#declInfo" class="anchor" title="Link to declInfo">#</a>
               </h3>
               
               <p>A declInfo describes a package-level const, type, var, or func declaration.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type declInfo struct {
file *Scope
version goVersion
lhs []*Var
vtyp syntax.Expr
init syntax.Expr
inherited bool
tdecl *syntax.TypeDecl
fdecl *syntax.FuncDecl
deps map[Object]bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dotImportKey" data-name="dotImportKey">
               <h3>
                  dotImportKey
                  <span class="badge">struct</span>
                  <a href="#dotImportKey" class="anchor" title="Link to dotImportKey">#</a>
               </h3>
               
               <p>A dotImportKey describes a dot-imported object in the given scope.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type dotImportKey struct {
scope *Scope
name string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="embeddedType" data-name="embeddedType">
               <h3>
                  embeddedType
                  <span class="badge">struct</span>
                  <a href="#embeddedType" class="anchor" title="Link to embeddedType">#</a>
               </h3>
               
               <p>embeddedType represents an embedded type</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type embeddedType struct {
typ Type
index []int
indirect bool
multiples bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="environment" data-name="environment">
               <h3>
                  environment
                  <span class="badge">struct</span>
                  <a href="#environment" class="anchor" title="Link to environment">#</a>
               </h3>
               
               <p>An environment represents the environment within which an object is
type-checked.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type environment struct {
decl *declInfo
scope *Scope
version goVersion
iota constant.Value
errpos syntax.Pos
inTParamList bool
sig *Signature
isPanic map[*syntax.CallExpr]bool
hasLabel bool
hasCallOrRecv bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="errorDesc" data-name="errorDesc">
               <h3>
                  errorDesc
                  <span class="badge">struct</span>
                  <a href="#errorDesc" class="anchor" title="Link to errorDesc">#</a>
               </h3>
               
               <p>An errorDesc describes part of a type-checking error.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type errorDesc struct {
pos syntax.Pos
msg string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="error_" data-name="error_">
               <h3>
                  error_
                  <span class="badge">struct</span>
                  <a href="#error_" class="anchor" title="Link to error_">#</a>
               </h3>
               
               <p>An error_ represents a type-checking error.
A new error_ is created with Checker.newError.
To report an error_, call error_.report.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type error_ struct {
check *Checker
desc []errorDesc
code Code
soft bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="exprInfo" data-name="exprInfo">
               <h3>
                  exprInfo
                  <span class="badge">struct</span>
                  <a href="#exprInfo" class="anchor" title="Link to exprInfo">#</a>
               </h3>
               
               <p>exprInfo stores information about an untyped expression.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type exprInfo struct {
isLhs bool
mode operandMode
typ *Basic
val constant.Value
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="gcSizes" data-name="gcSizes">
               <h3>
                  gcSizes
                  <span class="badge">struct</span>
                  <a href="#gcSizes" class="anchor" title="Link to gcSizes">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type gcSizes struct {
WordSize int64
MaxAlign int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="graphNode" data-name="graphNode">
               <h3>
                  graphNode
                  <span class="badge">struct</span>
                  <a href="#graphNode" class="anchor" title="Link to graphNode">#</a>
               </h3>
               
               <p>A graphNode represents a node in the object dependency graph.
Each node p in n.pred represents an edge p->n, and each node
s in n.succ represents an edge n->s; with a->b indicating that
a depends on b.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type graphNode struct {
obj dependency
pred nodeSet
succ nodeSet
index int
ndeps int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ifacePair" data-name="ifacePair">
               <h3>
                  ifacePair
                  <span class="badge">struct</span>
                  <a href="#ifacePair" class="anchor" title="Link to ifacePair">#</a>
               </h3>
               
               <p>An ifacePair is a node in a stack of interface type pairs compared for identity.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ifacePair struct {
x *Interface
y *Interface
prev *ifacePair
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="importKey" data-name="importKey">
               <h3>
                  importKey
                  <span class="badge">struct</span>
                  <a href="#importKey" class="anchor" title="Link to importKey">#</a>
               </h3>
               
               <p>An importKey identifies an imported package by import path and source directory
(directory containing the file containing the import). In practice, the directory
may always be the same, or may not matter. Given an (import path, directory), an
importer must always return the same package (but given two different import paths,
an importer may still return the same package by mapping them to the same package
paths).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type importKey struct {
path string
dir string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="instance" data-name="instance">
               <h3>
                  instance
                  <span class="badge">struct</span>
                  <a href="#instance" class="anchor" title="Link to instance">#</a>
               </h3>
               
               <p>instance holds information that is only necessary for instantiated named
types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type instance struct {
orig *Named
targs *TypeList
expandedMethods int
ctxt *Context
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="instanceLookup" data-name="instanceLookup">
               <h3>
                  instanceLookup
                  <span class="badge">struct</span>
                  <a href="#instanceLookup" class="anchor" title="Link to instanceLookup">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type instanceLookup struct {
buf [3]*Named
m map[*Named][]*Named
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="lazyObject" data-name="lazyObject">
               <h3>
                  lazyObject
                  <span class="badge">struct</span>
                  <a href="#lazyObject" class="anchor" title="Link to lazyObject">#</a>
               </h3>
               
               <p>A lazyObject represents an imported Object that has not been fully
resolved yet by its importer.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type lazyObject struct {
parent *Scope
resolve func() Object
obj Object
once sync.Once
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="monoEdge" data-name="monoEdge">
               <h3>
                  monoEdge
                  <span class="badge">struct</span>
                  <a href="#monoEdge" class="anchor" title="Link to monoEdge">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type monoEdge struct {
dst int
src int
weight int
pos syntax.Pos
typ Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="monoGraph" data-name="monoGraph">
               <h3>
                  monoGraph
                  <span class="badge">struct</span>
                  <a href="#monoGraph" class="anchor" title="Link to monoGraph">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type monoGraph struct {
vertices []monoVertex
edges []monoEdge
canon map[*TypeParam]*TypeParam
nameIdx map[*TypeName]int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="monoVertex" data-name="monoVertex">
               <h3>
                  monoVertex
                  <span class="badge">struct</span>
                  <a href="#monoVertex" class="anchor" title="Link to monoVertex">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type monoVertex struct {
weight int
pre int
len int
obj *TypeName
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="object" data-name="object">
               <h3>
                  object
                  <span class="badge">struct</span>
                  <a href="#object" class="anchor" title="Link to object">#</a>
               </h3>
               
               <p>An object implements the common parts of an Object.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type object struct {
parent *Scope
pos syntax.Pos
pkg *Package
name string
typ Type
order_ uint32
color_ color
scopePos_ syntax.Pos
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="operand" data-name="operand">
               <h3>
                  operand
                  <span class="badge">struct</span>
                  <a href="#operand" class="anchor" title="Link to operand">#</a>
               </h3>
               
               <p>An operand represents an intermediate value during type checking.
Operands have an (addressing) mode, the expression evaluating to
the operand, the operand's type, a value for constants, and an id
for built-in functions.
The zero value of operand is a ready to use invalid operand.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type operand struct {
mode operandMode
expr syntax.Expr
typ Type
val constant.Value
id builtinId
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="subster" data-name="subster">
               <h3>
                  subster
                  <span class="badge">struct</span>
                  <a href="#subster" class="anchor" title="Link to subster">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type subster struct {
pos syntax.Pos
smap substMap
check *Checker
expanding *Named
ctxt *Context
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="target" data-name="target">
               <h3>
                  target
                  <span class="badge">struct</span>
                  <a href="#target" class="anchor" title="Link to target">#</a>
               </h3>
               
               <p>target represent the (signature) type and description of the LHS
variable of an assignment, or of a function result variable.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type target struct {
sig *Signature
desc string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="term" data-name="term">
               <h3>
                  term
                  <span class="badge">struct</span>
                  <a href="#term" class="anchor" title="Link to term">#</a>
               </h3>
               
               <p>A term describes elementary type sets:
∅:  (*term)(nil)     == ∅                      // set of no types (empty set)
𝓤:  &term{}          == 𝓤                      // set of all types (𝓤niverse)
T:  &term{false, T}  == {T}                    // set of type T
~t:  &term{true, t}   == {t' | under(t') == t}  // set of types with underlying type t</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type term struct {
tilde bool
typ Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="tpWalker" data-name="tpWalker">
               <h3>
                  tpWalker
                  <span class="badge">struct</span>
                  <a href="#tpWalker" class="anchor" title="Link to tpWalker">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type tpWalker struct {
tparams []*TypeParam
seen map[Type]bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="typeWriter" data-name="typeWriter">
               <h3>
                  typeWriter
                  <span class="badge">struct</span>
                  <a href="#typeWriter" class="anchor" title="Link to typeWriter">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type typeWriter struct {
buf *bytes.Buffer
seen map[Type]bool
qf Qualifier
ctxt *Context
tparams *TypeParamList
paramNames bool
tpSubscripts bool
pkgInfo bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="unifier" data-name="unifier">
               <h3>
                  unifier
                  <span class="badge">struct</span>
                  <a href="#unifier" class="anchor" title="Link to unifier">#</a>
               </h3>
               
               <p>A unifier maintains a list of type parameters and
corresponding types inferred for each type parameter.
A unifier is created by calling newUnifier.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type unifier struct {
handles map[*TypeParam]*Type
depth int
enableInterfaceInference bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="valueType" data-name="valueType">
               <h3>
                  valueType
                  <span class="badge">struct</span>
                  <a href="#valueType" class="anchor" title="Link to valueType">#</a>
               </h3>
               
               <p>A valueMap maps a case value (of a basic Go type) to a list of positions
where the same case value appeared, together with the corresponding case
types.
Since two case values may have the same "underlying" value but different
types we need to also check the value's types (e.g., byte(1) vs myByte(1))
when the switch expression is of interface type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type valueType struct {
pos syntax.Pos
typ Type
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AddMethod" data-name="AddMethod">
               <h3>
                  AddMethod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddMethod" class="anchor" title="Link to AddMethod">#</a>
               </h3>
               
               <p>AddMethod adds method m unless it is already in the method list.
The method must be in the same package as t, and t must not have
type arguments.</p>
               
               <pre><code class="language-go">func (t *Named) AddMethod(m *Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Addressable" data-name="Addressable">
               <h3>
                  Addressable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Addressable" class="anchor" title="Link to Addressable">#</a>
               </h3>
               
               <p>Addressable reports whether the corresponding expression
is addressable (https://golang.org/ref/spec#Address_operators).</p>
               
               <pre><code class="language-go">func (tv TypeAndValue) Addressable() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Alignof" data-name="Alignof">
               <h3>
                  Alignof 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Alignof" class="anchor" title="Link to Alignof">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *gcSizes) Alignof(T Type) (result int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Alignof" data-name="Alignof">
               <h3>
                  Alignof 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Alignof" class="anchor" title="Link to Alignof">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *StdSizes) Alignof(T Type) (result int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Anonymous" data-name="Anonymous">
               <h3>
                  Anonymous 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Anonymous" class="anchor" title="Link to Anonymous">#</a>
               </h3>
               
               <p>Anonymous reports whether the variable is an embedded field.
Same as Embedded; only present for backward-compatibility.</p>
               
               <pre><code class="language-go">func (obj *Var) Anonymous() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AsPointer" data-name="AsPointer">
               <h3>
                  AsPointer 
                  <span class="badge">function</span>
                  
                  <a href="#AsPointer" class="anchor" title="Link to AsPointer">#</a>
               </h3>
               
               <p>If t is a pointer, AsPointer returns that type, otherwise it returns nil.</p>
               
               <pre><code class="language-go">func AsPointer(t Type) *Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AsSignature" data-name="AsSignature">
               <h3>
                  AsSignature 
                  <span class="badge">function</span>
                  
                  <a href="#AsSignature" class="anchor" title="Link to AsSignature">#</a>
               </h3>
               
               <p>If t is a signature, AsSignature returns that type, otherwise it returns nil.</p>
               
               <pre><code class="language-go">func AsSignature(t Type) *Signature</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AssertableTo" data-name="AssertableTo">
               <h3>
                  AssertableTo 
                  <span class="badge">function</span>
                  
                  <a href="#AssertableTo" class="anchor" title="Link to AssertableTo">#</a>
               </h3>
               
               <p>AssertableTo reports whether a value of type V can be asserted to have type T.
The behavior of AssertableTo is unspecified in three cases:
- if T is Typ[Invalid]
- if V is a generalized interface; i.e., an interface that may only be used
as a type constraint in Go code
- if T is an uninstantiated generic type</p>
               
               <pre><code class="language-go">func AssertableTo(V *Interface, T Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Assignable" data-name="Assignable">
               <h3>
                  Assignable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Assignable" class="anchor" title="Link to Assignable">#</a>
               </h3>
               
               <p>Assignable reports whether the corresponding expression
is assignable to (provided a value of the right type).</p>
               
               <pre><code class="language-go">func (tv TypeAndValue) Assignable() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AssignableTo" data-name="AssignableTo">
               <h3>
                  AssignableTo 
                  <span class="badge">function</span>
                  
                  <a href="#AssignableTo" class="anchor" title="Link to AssignableTo">#</a>
               </h3>
               
               <p>AssignableTo reports whether a value of type V is assignable to a variable
of type T.
The behavior of AssignableTo is unspecified if V or T is Typ[Invalid] or an
uninstantiated generic type.</p>
               
               <pre><code class="language-go">func AssignableTo(V Type, T Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="At" data-name="At">
               <h3>
                  At 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#At" class="anchor" title="Link to At">#</a>
               </h3>
               
               <p>At returns the i'th type in the list.</p>
               
               <pre><code class="language-go">func (l *TypeList) At(i int) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="At" data-name="At">
               <h3>
                  At 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#At" class="anchor" title="Link to At">#</a>
               </h3>
               
               <p>At returns the i'th type parameter in the list.</p>
               
               <pre><code class="language-go">func (l *TypeParamList) At(i int) *TypeParam</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="At" data-name="At">
               <h3>
                  At 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#At" class="anchor" title="Link to At">#</a>
               </h3>
               
               <p>At returns the i'th variable of tuple t.</p>
               
               <pre><code class="language-go">func (t *Tuple) At(i int) *Var</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Check" data-name="Check">
               <h3>
                  Check 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Check" class="anchor" title="Link to Check">#</a>
               </h3>
               
               <p>Check type-checks a package and returns the resulting package object and
the first error if any. Additionally, if info != nil, Check populates each
of the non-nil maps in the Info struct.
The package is marked as complete if no errors occurred, otherwise it is
incomplete. See Config.Error for controlling behavior in the presence of
errors.
The package is specified by a list of *syntax.Files and corresponding
file set, and the package path the package is identified with.
The clean path must not be empty or dot (".").</p>
               
               <pre><code class="language-go">func (conf *Config) Check(path string, files []*syntax.File, info *Info) (*Package, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Child" data-name="Child">
               <h3>
                  Child 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Child" class="anchor" title="Link to Child">#</a>
               </h3>
               
               <p>Child returns the i'th child scope for 0 <= i < NumChildren().</p>
               
               <pre><code class="language-go">func (s *Scope) Child(i int) *Scope</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Comparable" data-name="Comparable">
               <h3>
                  Comparable 
                  <span class="badge">function</span>
                  
                  <a href="#Comparable" class="anchor" title="Link to Comparable">#</a>
               </h3>
               
               <p>Comparable reports whether values of type T are comparable.</p>
               
               <pre><code class="language-go">func Comparable(T Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Complete" data-name="Complete">
               <h3>
                  Complete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Complete" class="anchor" title="Link to Complete">#</a>
               </h3>
               
               <p>A package is complete if its scope contains (at least) all
exported objects; otherwise it is incomplete.</p>
               
               <pre><code class="language-go">func (pkg *Package) Complete() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Constraint" data-name="Constraint">
               <h3>
                  Constraint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Constraint" class="anchor" title="Link to Constraint">#</a>
               </h3>
               
               <p>Constraint returns the type constraint specified for t.</p>
               
               <pre><code class="language-go">func (t *TypeParam) Constraint() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ConvertibleTo" data-name="ConvertibleTo">
               <h3>
                  ConvertibleTo 
                  <span class="badge">function</span>
                  
                  <a href="#ConvertibleTo" class="anchor" title="Link to ConvertibleTo">#</a>
               </h3>
               
               <p>ConvertibleTo reports whether a value of type V is convertible to a value of
type T.
The behavior of ConvertibleTo is unspecified if V or T is Typ[Invalid] or an
uninstantiated generic type.</p>
               
               <pre><code class="language-go">func ConvertibleTo(V Type, T Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CoreType" data-name="CoreType">
               <h3>
                  CoreType 
                  <span class="badge">function</span>
                  
                  <a href="#CoreType" class="anchor" title="Link to CoreType">#</a>
               </h3>
               
               <p>If typ is a type parameter, CoreType returns the single underlying
type of all types in the corresponding type constraint if it exists, or
nil otherwise. If the type set contains only unrestricted and restricted
channel types (with identical element types), the single underlying type
is the restricted channel type if the restrictions are always the same.
If typ is not a type parameter, CoreType returns the underlying type.</p>
               
               <pre><code class="language-go">func CoreType(t Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DefPredeclaredTestFuncs" data-name="DefPredeclaredTestFuncs">
               <h3>
                  DefPredeclaredTestFuncs 
                  <span class="badge">function</span>
                  
                  <a href="#DefPredeclaredTestFuncs" class="anchor" title="Link to DefPredeclaredTestFuncs">#</a>
               </h3>
               
               <p>DefPredeclaredTestFuncs defines the assert and trace built-ins.
These built-ins are intended for debugging and testing of this
package only.</p>
               
               <pre><code class="language-go">func DefPredeclaredTestFuncs()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Default" data-name="Default">
               <h3>
                  Default 
                  <span class="badge">function</span>
                  
                  <a href="#Default" class="anchor" title="Link to Default">#</a>
               </h3>
               
               <p>Default returns the default "typed" type for an "untyped" type;
it returns the incoming type for all other types. The default type
for untyped nil is untyped nil.</p>
               
               <pre><code class="language-go">func Default(t Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Dir" data-name="Dir">
               <h3>
                  Dir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Dir" class="anchor" title="Link to Dir">#</a>
               </h3>
               
               <p>Dir returns the direction of channel c.</p>
               
               <pre><code class="language-go">func (c *Chan) Dir() ChanDir</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Elem" data-name="Elem">
               <h3>
                  Elem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Elem" class="anchor" title="Link to Elem">#</a>
               </h3>
               
               <p>Elem returns the element type of map m.</p>
               
               <pre><code class="language-go">func (m *Map) Elem() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Elem" data-name="Elem">
               <h3>
                  Elem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Elem" class="anchor" title="Link to Elem">#</a>
               </h3>
               
               <p>Elem returns the element type for the given pointer p.</p>
               
               <pre><code class="language-go">func (p *Pointer) Elem() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Elem" data-name="Elem">
               <h3>
                  Elem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Elem" class="anchor" title="Link to Elem">#</a>
               </h3>
               
               <p>Elem returns the element type of slice s.</p>
               
               <pre><code class="language-go">func (s *Slice) Elem() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Elem" data-name="Elem">
               <h3>
                  Elem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Elem" class="anchor" title="Link to Elem">#</a>
               </h3>
               
               <p>Elem returns the element type of channel c.</p>
               
               <pre><code class="language-go">func (c *Chan) Elem() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Elem" data-name="Elem">
               <h3>
                  Elem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Elem" class="anchor" title="Link to Elem">#</a>
               </h3>
               
               <p>Elem returns element type of array a.</p>
               
               <pre><code class="language-go">func (a *Array) Elem() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Embedded" data-name="Embedded">
               <h3>
                  Embedded 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Embedded" class="anchor" title="Link to Embedded">#</a>
               </h3>
               
               <p>Embedded reports whether the variable is an embedded field.</p>
               
               <pre><code class="language-go">func (obj *Var) Embedded() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EmbeddedType" data-name="EmbeddedType">
               <h3>
                  EmbeddedType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EmbeddedType" class="anchor" title="Link to EmbeddedType">#</a>
               </h3>
               
               <p>EmbeddedType returns the i'th embedded type of interface t for 0 <= i < t.NumEmbeddeds().</p>
               
               <pre><code class="language-go">func (t *Interface) EmbeddedType(i int) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Empty" data-name="Empty">
               <h3>
                  Empty 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Empty" class="anchor" title="Link to Empty">#</a>
               </h3>
               
               <p>Empty reports whether t is the empty interface.</p>
               
               <pre><code class="language-go">func (t *Interface) Empty() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <p>Error returns an error string formatted as follows:
filename:line:column: message</p>
               
               <pre><code class="language-go">func (err Error) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ArgumentError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ExplicitMethod" data-name="ExplicitMethod">
               <h3>
                  ExplicitMethod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ExplicitMethod" class="anchor" title="Link to ExplicitMethod">#</a>
               </h3>
               
               <p>ExplicitMethod returns the i'th explicitly declared method of interface t for 0 <= i < t.NumExplicitMethods().
The methods are ordered by their unique Id.</p>
               
               <pre><code class="language-go">func (t *Interface) ExplicitMethod(i int) *Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Exported" data-name="Exported">
               <h3>
                  Exported 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Exported" class="anchor" title="Link to Exported">#</a>
               </h3>
               
               <p>Exported reports whether the object is exported (starts with a capital letter).
It doesn't take into account whether the object is in a local (function) scope
or not.</p>
               
               <pre><code class="language-go">func (obj *object) Exported() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Exported" data-name="Exported">
               <h3>
                  Exported 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Exported" class="anchor" title="Link to Exported">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) Exported() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ExprString" data-name="ExprString">
               <h3>
                  ExprString 
                  <span class="badge">function</span>
                  
                  <a href="#ExprString" class="anchor" title="Link to ExprString">#</a>
               </h3>
               
               <p>ExprString returns a string representation of x.</p>
               
               <pre><code class="language-go">func ExprString(x syntax.Node) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Field" data-name="Field">
               <h3>
                  Field 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Field" class="anchor" title="Link to Field">#</a>
               </h3>
               
               <p>Field returns the i'th field for 0 <= i < NumFields().</p>
               
               <pre><code class="language-go">func (s *Struct) Field(i int) *Var</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Files" data-name="Files">
               <h3>
                  Files 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Files" class="anchor" title="Link to Files">#</a>
               </h3>
               
               <p>Files checks the provided files as part of the checker's package.</p>
               
               <pre><code class="language-go">func (check *Checker) Files(files []*syntax.File) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FullError" data-name="FullError">
               <h3>
                  FullError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FullError" class="anchor" title="Link to FullError">#</a>
               </h3>
               
               <p>FullError returns an error string like Error, buy it may contain
type-checker internal details such as subscript indices for type
parameters and more. Useful for debugging.</p>
               
               <pre><code class="language-go">func (err Error) FullError() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FullName" data-name="FullName">
               <h3>
                  FullName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FullName" class="anchor" title="Link to FullName">#</a>
               </h3>
               
               <p>FullName returns the package- or receiver-type-qualified name of
function or method obj.</p>
               
               <pre><code class="language-go">func (obj *Func) FullName() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoVersion" data-name="GoVersion">
               <h3>
                  GoVersion 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoVersion" class="anchor" title="Link to GoVersion">#</a>
               </h3>
               
               <p>GoVersion returns the minimum Go version required by this package.
If the minimum version is unknown, GoVersion returns the empty string.
Individual source files may specify a different minimum Go version,
as reported in the [go/ast.File.GoVersion] field.</p>
               
               <pre><code class="language-go">func (pkg *Package) GoVersion() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HasOk" data-name="HasOk">
               <h3>
                  HasOk 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HasOk" class="anchor" title="Link to HasOk">#</a>
               </h3>
               
               <p>HasOk reports whether the corresponding expression may be
used on the rhs of a comma-ok assignment.</p>
               
               <pre><code class="language-go">func (tv TypeAndValue) HasOk() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Id" data-name="Id">
               <h3>
                  Id 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Id" class="anchor" title="Link to Id">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) Id() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Id" data-name="Id">
               <h3>
                  Id 
                  <span class="badge">function</span>
                  
                  <a href="#Id" class="anchor" title="Link to Id">#</a>
               </h3>
               
               <p>Id returns name if it is exported, otherwise it
returns the name qualified with the package path.</p>
               
               <pre><code class="language-go">func Id(pkg *Package, name string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Id" data-name="Id">
               <h3>
                  Id 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Id" class="anchor" title="Link to Id">#</a>
               </h3>
               
               <p>Id is a wrapper for Id(obj.Pkg(), obj.Name()).</p>
               
               <pre><code class="language-go">func (obj *object) Id() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Identical" data-name="Identical">
               <h3>
                  Identical 
                  <span class="badge">function</span>
                  
                  <a href="#Identical" class="anchor" title="Link to Identical">#</a>
               </h3>
               
               <p>Identical reports whether x and y are identical types.
Receivers of [Signature] types are ignored.
Predicates such as [Identical], [Implements], and
[Satisfies] assume that both operands belong to a
consistent collection of symbols ([Object] values).
For example, two [Named] types can be identical only if their
[Named.Obj] methods return the same [TypeName] symbol.
A collection of symbols is consistent if, for each logical
package whose path is P, the creation of those symbols
involved at most one call to [NewPackage](P, ...).
To ensure consistency, use a single [Importer] for
all loaded packages and their dependencies.
For more information, see https://github.com/golang/go/issues/57497.</p>
               
               <pre><code class="language-go">func Identical(x Type, y Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IdenticalIgnoreTags" data-name="IdenticalIgnoreTags">
               <h3>
                  IdenticalIgnoreTags 
                  <span class="badge">function</span>
                  
                  <a href="#IdenticalIgnoreTags" class="anchor" title="Link to IdenticalIgnoreTags">#</a>
               </h3>
               
               <p>IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored.
Receivers of [Signature] types are ignored.</p>
               
               <pre><code class="language-go">func IdenticalIgnoreTags(x Type, y Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Implements" data-name="Implements">
               <h3>
                  Implements 
                  <span class="badge">function</span>
                  
                  <a href="#Implements" class="anchor" title="Link to Implements">#</a>
               </h3>
               
               <p>Implements reports whether type V implements interface T.
The behavior of Implements is unspecified if V is Typ[Invalid] or an uninstantiated
generic type.</p>
               
               <pre><code class="language-go">func Implements(V Type, T *Interface) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Imported" data-name="Imported">
               <h3>
                  Imported 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Imported" class="anchor" title="Link to Imported">#</a>
               </h3>
               
               <p>Imported returns the package that was imported.
It is distinct from Pkg(), which is the package containing the import statement.</p>
               
               <pre><code class="language-go">func (obj *PkgName) Imported() *Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Imports" data-name="Imports">
               <h3>
                  Imports 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Imports" class="anchor" title="Link to Imports">#</a>
               </h3>
               
               <p>Imports returns the list of packages directly imported by
pkg; the list is in source order.
If pkg was loaded from export data, Imports includes packages that
provide package-level objects referenced by pkg. This may be more or
less than the set of packages directly imported by pkg's source code.
If pkg uses cgo and the FakeImportC configuration option
was enabled, the imports list may contain a fake "C" package.</p>
               
               <pre><code class="language-go">func (pkg *Package) Imports() []*Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Index" data-name="Index">
               <h3>
                  Index 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Index" class="anchor" title="Link to Index">#</a>
               </h3>
               
               <p>Index returns the index of the type param within its param list, or -1 if
the type parameter has not yet been bound to a type.</p>
               
               <pre><code class="language-go">func (t *TypeParam) Index() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Index" data-name="Index">
               <h3>
                  Index 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Index" class="anchor" title="Link to Index">#</a>
               </h3>
               
               <p>Index describes the path from x to f in x.f.
The last index entry is the field or method index of the type declaring f;
either:
1. the list of declared methods of a named type; or
2. the list of methods of an interface type; or
3. the list of fields of a struct type.
The earlier index entries are the indices of the embedded fields implicitly
traversed to get from (the type of) x to f, starting at embedding depth 0.</p>
               
               <pre><code class="language-go">func (s *Selection) Index() []int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Indirect" data-name="Indirect">
               <h3>
                  Indirect 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Indirect" class="anchor" title="Link to Indirect">#</a>
               </h3>
               
               <p>Indirect reports whether any pointer indirection was required to get from
x to f in x.f.
Beware: Indirect spuriously returns true (Go issue #8353) for a
MethodVal selection in which the receiver argument and parameter
both have type *T so there is no indirection.
Unfortunately, a fix is too risky.</p>
               
               <pre><code class="language-go">func (s *Selection) Indirect() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Info" data-name="Info">
               <h3>
                  Info 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Info" class="anchor" title="Link to Info">#</a>
               </h3>
               
               <p>Info returns information about properties of basic type b.</p>
               
               <pre><code class="language-go">func (b *Basic) Info() BasicInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Insert" data-name="Insert">
               <h3>
                  Insert 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Insert" class="anchor" title="Link to Insert">#</a>
               </h3>
               
               <p>Insert attempts to insert an object obj into scope s.
If s already contains an alternative object alt with
the same name, Insert leaves s unchanged and returns alt.
Otherwise it inserts obj, sets the object's parent scope
if not already set, and returns nil.</p>
               
               <pre><code class="language-go">func (s *Scope) Insert(obj Object) Object</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InsertLazy" data-name="InsertLazy">
               <h3>
                  InsertLazy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InsertLazy" class="anchor" title="Link to InsertLazy">#</a>
               </h3>
               
               <p>InsertLazy is like Insert, but allows deferring construction of the
inserted object until it's accessed with Lookup. The Object
returned by resolve must have the same name as given to InsertLazy.
If s already contains an alternative object with the same name,
InsertLazy leaves s unchanged and returns false. Otherwise it
records the binding and returns true. The object's parent scope
will be set to s after resolve is called.</p>
               
               <pre><code class="language-go">func (s *Scope) InsertLazy(name string, resolve func() Object) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Instantiate" data-name="Instantiate">
               <h3>
                  Instantiate 
                  <span class="badge">function</span>
                  
                  <a href="#Instantiate" class="anchor" title="Link to Instantiate">#</a>
               </h3>
               
               <p>Instantiate instantiates the type orig with the given type arguments targs.
orig must be an *Alias, *Named, or *Signature type. If there is no error,
the resulting Type is an instantiated type of the same kind (*Alias, *Named
or *Signature, respectively).
Methods attached to a *Named type are also instantiated, and associated with
a new *Func that has the same position as the original method, but nil function
scope.
If ctxt is non-nil, it may be used to de-duplicate the instance against
previous instances with the same identity. As a special case, generic
*Signature origin types are only considered identical if they are pointer
equivalent, so that instantiating distinct (but possibly identical)
signatures will yield different instances. The use of a shared context does
not guarantee that identical instances are deduplicated in all cases.
If validate is set, Instantiate verifies that the number of type arguments
and parameters match, and that the type arguments satisfy their respective
type constraints. If verification fails, the resulting error may wrap an
*ArgumentError indicating which type argument did not satisfy its type parameter
constraint, and why.
If validate is not set, Instantiate does not verify the type argument count
or whether the type arguments satisfy their constraints. Instantiate is
guaranteed to not return an error, but may panic. Specifically, for
*Signature types, Instantiate will panic immediately if the type argument
count is incorrect; for *Named types, a panic may occur later inside the
*Named API.</p>
               
               <pre><code class="language-go">func Instantiate(ctxt *Context, orig Type, targs []Type, validate bool) (Type, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsAlias" data-name="IsAlias">
               <h3>
                  IsAlias 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsAlias" class="anchor" title="Link to IsAlias">#</a>
               </h3>
               
               <p>IsAlias reports whether obj is an alias name for a type.</p>
               
               <pre><code class="language-go">func (obj *TypeName) IsAlias() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsAll" data-name="IsAll">
               <h3>
                  IsAll 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsAll" class="anchor" title="Link to IsAll">#</a>
               </h3>
               
               <p>IsAll reports whether s is the set of all types (corresponding to the empty interface).</p>
               
               <pre><code class="language-go">func (s *_TypeSet) IsAll() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsBuiltin" data-name="IsBuiltin">
               <h3>
                  IsBuiltin 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsBuiltin" class="anchor" title="Link to IsBuiltin">#</a>
               </h3>
               
               <p>IsBuiltin reports whether the corresponding expression denotes
a (possibly parenthesized) built-in function.</p>
               
               <pre><code class="language-go">func (tv TypeAndValue) IsBuiltin() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsComparable" data-name="IsComparable">
               <h3>
                  IsComparable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsComparable" class="anchor" title="Link to IsComparable">#</a>
               </h3>
               
               <p>IsComparable reports whether each type in the set is comparable.</p>
               
               <pre><code class="language-go">func (s *_TypeSet) IsComparable(seen map[Type]bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsComparable" data-name="IsComparable">
               <h3>
                  IsComparable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsComparable" class="anchor" title="Link to IsComparable">#</a>
               </h3>
               
               <p>IsComparable reports whether each type in interface t's type set is comparable.</p>
               
               <pre><code class="language-go">func (t *Interface) IsComparable() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsEmpty" data-name="IsEmpty">
               <h3>
                  IsEmpty 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsEmpty" class="anchor" title="Link to IsEmpty">#</a>
               </h3>
               
               <p>IsEmpty reports whether s is the empty set.</p>
               
               <pre><code class="language-go">func (s *_TypeSet) IsEmpty() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsField" data-name="IsField">
               <h3>
                  IsField 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsField" class="anchor" title="Link to IsField">#</a>
               </h3>
               
               <p>IsField reports whether the variable is a struct field.</p>
               
               <pre><code class="language-go">func (obj *Var) IsField() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsImplicit" data-name="IsImplicit">
               <h3>
                  IsImplicit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsImplicit" class="anchor" title="Link to IsImplicit">#</a>
               </h3>
               
               <p>IsImplicit reports whether the interface t is a wrapper for a type set literal.</p>
               
               <pre><code class="language-go">func (t *Interface) IsImplicit() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsInterface" data-name="IsInterface">
               <h3>
                  IsInterface 
                  <span class="badge">function</span>
                  
                  <a href="#IsInterface" class="anchor" title="Link to IsInterface">#</a>
               </h3>
               
               <p>IsInterface reports whether t is an interface type.</p>
               
               <pre><code class="language-go">func IsInterface(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsMethodSet" data-name="IsMethodSet">
               <h3>
                  IsMethodSet 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsMethodSet" class="anchor" title="Link to IsMethodSet">#</a>
               </h3>
               
               <p>IsMethodSet reports whether the interface t is fully described by its method set.</p>
               
               <pre><code class="language-go">func (s *_TypeSet) IsMethodSet() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsMethodSet" data-name="IsMethodSet">
               <h3>
                  IsMethodSet 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsMethodSet" class="anchor" title="Link to IsMethodSet">#</a>
               </h3>
               
               <p>IsMethodSet reports whether the interface t is fully described by its method set.</p>
               
               <pre><code class="language-go">func (t *Interface) IsMethodSet() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsNil" data-name="IsNil">
               <h3>
                  IsNil 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsNil" class="anchor" title="Link to IsNil">#</a>
               </h3>
               
               <p>IsNil reports whether the corresponding expression denotes the
predeclared value nil. Depending on context, it may have been
given a type different from UntypedNil.</p>
               
               <pre><code class="language-go">func (tv TypeAndValue) IsNil() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsSyncAtomicAlign64" data-name="IsSyncAtomicAlign64">
               <h3>
                  IsSyncAtomicAlign64 
                  <span class="badge">function</span>
                  
                  <a href="#IsSyncAtomicAlign64" class="anchor" title="Link to IsSyncAtomicAlign64">#</a>
               </h3>
               
               <pre><code class="language-go">func IsSyncAtomicAlign64(T Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsType" data-name="IsType">
               <h3>
                  IsType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsType" class="anchor" title="Link to IsType">#</a>
               </h3>
               
               <p>IsType reports whether the corresponding expression specifies a type.</p>
               
               <pre><code class="language-go">func (tv TypeAndValue) IsType() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsValue" data-name="IsValue">
               <h3>
                  IsValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsValue" class="anchor" title="Link to IsValue">#</a>
               </h3>
               
               <p>IsValue reports whether the corresponding expression is a value.
Builtins are not considered values. Constant values have a non-
nil Value.</p>
               
               <pre><code class="language-go">func (tv TypeAndValue) IsValue() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsVoid" data-name="IsVoid">
               <h3>
                  IsVoid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsVoid" class="anchor" title="Link to IsVoid">#</a>
               </h3>
               
               <p>IsVoid reports whether the corresponding expression
is a function call without results.</p>
               
               <pre><code class="language-go">func (tv TypeAndValue) IsVoid() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Key" data-name="Key">
               <h3>
                  Key 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Key" class="anchor" title="Link to Key">#</a>
               </h3>
               
               <p>Key returns the key type of map m.</p>
               
               <pre><code class="language-go">func (m *Map) Key() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Kind" data-name="Kind">
               <h3>
                  Kind 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Kind" class="anchor" title="Link to Kind">#</a>
               </h3>
               
               <p>Kind returns the selection kind.</p>
               
               <pre><code class="language-go">func (s *Selection) Kind() SelectionKind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Kind" data-name="Kind">
               <h3>
                  Kind 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Kind" class="anchor" title="Link to Kind">#</a>
               </h3>
               
               <p>Kind returns the kind of basic type b.</p>
               
               <pre><code class="language-go">func (b *Basic) Kind() BasicKind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <p>Len returns the number of types in the list.
It is safe to call on a nil receiver.</p>
               
               <pre><code class="language-go">func (l *TypeList) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <p>Len returns the number of scope elements.</p>
               
               <pre><code class="language-go">func (s *Scope) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <p>Len returns the length of array a.
A negative result indicates an unknown length.</p>
               
               <pre><code class="language-go">func (a *Array) Len() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code class="language-go">func (a nodeQueue) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code class="language-go">func (u *Union) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <p>Len returns the number variables of tuple t.</p>
               
               <pre><code class="language-go">func (t *Tuple) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <p>Len returns the number of type parameters in the list.
It is safe to call on a nil receiver.</p>
               
               <pre><code class="language-go">func (l *TypeParamList) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code class="language-go">func (s typeParamsById) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Less" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Less" class="anchor" title="Link to Less">#</a>
               </h3>
               
               <pre><code class="language-go">func (s typeParamsById) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Less" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Less" class="anchor" title="Link to Less">#</a>
               </h3>
               
               <pre><code class="language-go">func (a nodeQueue) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lookup" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lookup" class="anchor" title="Link to Lookup">#</a>
               </h3>
               
               <p>Lookup returns the object in scope s with the given name if such an
object exists; otherwise the result is nil.</p>
               
               <pre><code class="language-go">func (s *Scope) Lookup(name string) Object</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupFieldOrMethod" data-name="LookupFieldOrMethod">
               <h3>
                  LookupFieldOrMethod 
                  <span class="badge">function</span>
                  
                  <a href="#LookupFieldOrMethod" class="anchor" title="Link to LookupFieldOrMethod">#</a>
               </h3>
               
               <p>LookupFieldOrMethod looks up a field or method with given package and name
in T and returns the corresponding *Var or *Func, an index sequence, and a
bool indicating if there were any pointer indirections on the path to the
field or method. If addressable is set, T is the type of an addressable
variable (only matters for method lookups). T must not be nil.
The last index entry is the field or method index in the (possibly embedded)
type where the entry was found, either:
1. the list of declared methods of a named type; or
2. the list of all methods (method set) of an interface type; or
3. the list of fields of a struct type.
The earlier index entries are the indices of the embedded struct fields
traversed to get to the found entry, starting at depth 0.
If no entry is found, a nil object is returned. In this case, the returned
index and indirect values have the following meaning:
- If index != nil, the index sequence points to an ambiguous entry
(the same name appeared more than once at the same embedding level).
- If indirect is set, a method with a pointer receiver type was found
but there was no pointer on the path from the actual receiver type to
the method's formal receiver base type, nor was the receiver addressable.</p>
               
               <pre><code class="language-go">func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupMethod" data-name="LookupMethod">
               <h3>
                  LookupMethod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LookupMethod" class="anchor" title="Link to LookupMethod">#</a>
               </h3>
               
               <p>LookupMethod returns the index of and method with matching package and name, or (-1, nil).</p>
               
               <pre><code class="language-go">func (s *_TypeSet) LookupMethod(pkg *Package, name string, foldCase bool) (int, *Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarkComplete" data-name="MarkComplete">
               <h3>
                  MarkComplete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarkComplete" class="anchor" title="Link to MarkComplete">#</a>
               </h3>
               
               <p>MarkComplete marks a package as complete.</p>
               
               <pre><code class="language-go">func (pkg *Package) MarkComplete()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarkImplicit" data-name="MarkImplicit">
               <h3>
                  MarkImplicit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarkImplicit" class="anchor" title="Link to MarkImplicit">#</a>
               </h3>
               
               <p>MarkImplicit marks the interface t as implicit, meaning this interface
corresponds to a constraint literal such as ~T or A|B without explicit
interface embedding. MarkImplicit should be called before any concurrent use
of implicit interfaces.</p>
               
               <pre><code class="language-go">func (t *Interface) MarkImplicit()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Method" data-name="Method">
               <h3>
                  Method 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Method" class="anchor" title="Link to Method">#</a>
               </h3>
               
               <p>Method returns the i'th method of named type t for 0 <= i < t.NumMethods().
For an ordinary or instantiated type t, the receiver base type of this
method is the named type t. For an uninstantiated generic type t, each
method receiver is instantiated with its receiver type parameters.
Methods are numbered deterministically: given the same list of source files
presented to the type checker, or the same sequence of NewMethod and AddMethod
calls, the mapping from method index to corresponding method remains the same.
But the specific ordering is not specified and must not be relied on as it may
change in the future.</p>
               
               <pre><code class="language-go">func (t *Named) Method(i int) *Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Method" data-name="Method">
               <h3>
                  Method 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Method" class="anchor" title="Link to Method">#</a>
               </h3>
               
               <p>Method returns the i'th method of s for 0 <= i < s.NumMethods().
The methods are ordered by their unique ID.</p>
               
               <pre><code class="language-go">func (s *_TypeSet) Method(i int) *Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Method" data-name="Method">
               <h3>
                  Method 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Method" class="anchor" title="Link to Method">#</a>
               </h3>
               
               <p>Method returns the i'th method of interface t for 0 <= i < t.NumMethods().
The methods are ordered by their unique Id.</p>
               
               <pre><code class="language-go">func (t *Interface) Method(i int) *Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MissingMethod" data-name="MissingMethod">
               <h3>
                  MissingMethod 
                  <span class="badge">function</span>
                  
                  <a href="#MissingMethod" class="anchor" title="Link to MissingMethod">#</a>
               </h3>
               
               <p>MissingMethod returns (nil, false) if V implements T, otherwise it
returns a missing method required by T and whether it is missing or
just has the wrong type: either a pointer receiver or wrong signature.
For non-interface types V, or if static is set, V implements T if all
methods of T are present in V. Otherwise (V is an interface and static
is not set), MissingMethod only checks that methods of T which are also
present in V have matching types (e.g., for a type assertion x.(T) where
x is of interface type V).</p>
               
               <pre><code class="language-go">func MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <p>Name returns the name of basic type b.</p>
               
               <pre><code class="language-go">func (b *Basic) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <p>Name returns the package name.</p>
               
               <pre><code class="language-go">func (pkg *Package) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <p>Name returns the object's (package-local, unqualified) name.</p>
               
               <pre><code class="language-go">func (obj *object) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Names" data-name="Names">
               <h3>
                  Names 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Names" class="anchor" title="Link to Names">#</a>
               </h3>
               
               <p>Names returns the scope's element names in sorted order.</p>
               
               <pre><code class="language-go">func (s *Scope) Names() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewAlias" data-name="NewAlias">
               <h3>
                  NewAlias 
                  <span class="badge">function</span>
                  
                  <a href="#NewAlias" class="anchor" title="Link to NewAlias">#</a>
               </h3>
               
               <p>NewAlias creates a new Alias type with the given type name and rhs.
rhs must not be nil.</p>
               
               <pre><code class="language-go">func NewAlias(obj *TypeName, rhs Type) *Alias</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewArray" data-name="NewArray">
               <h3>
                  NewArray 
                  <span class="badge">function</span>
                  
                  <a href="#NewArray" class="anchor" title="Link to NewArray">#</a>
               </h3>
               
               <p>NewArray returns a new array type for the given element type and length.
A negative length indicates an unknown length.</p>
               
               <pre><code class="language-go">func NewArray(elem Type, len int64) *Array</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewChan" data-name="NewChan">
               <h3>
                  NewChan 
                  <span class="badge">function</span>
                  
                  <a href="#NewChan" class="anchor" title="Link to NewChan">#</a>
               </h3>
               
               <p>NewChan returns a new channel type for the given direction and element type.</p>
               
               <pre><code class="language-go">func NewChan(dir ChanDir, elem Type) *Chan</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewChecker" data-name="NewChecker">
               <h3>
                  NewChecker 
                  <span class="badge">function</span>
                  
                  <a href="#NewChecker" class="anchor" title="Link to NewChecker">#</a>
               </h3>
               
               <p>NewChecker returns a new Checker instance for a given package.
Package files may be added incrementally via checker.Files.</p>
               
               <pre><code class="language-go">func NewChecker(conf *Config, pkg *Package, info *Info) *Checker</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewConst" data-name="NewConst">
               <h3>
                  NewConst 
                  <span class="badge">function</span>
                  
                  <a href="#NewConst" class="anchor" title="Link to NewConst">#</a>
               </h3>
               
               <p>NewConst returns a new constant with value val.
The remaining arguments set the attributes found with all Objects.</p>
               
               <pre><code class="language-go">func NewConst(pos syntax.Pos, pkg *Package, name string, typ Type, val constant.Value) *Const</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewContext" data-name="NewContext">
               <h3>
                  NewContext 
                  <span class="badge">function</span>
                  
                  <a href="#NewContext" class="anchor" title="Link to NewContext">#</a>
               </h3>
               
               <p>NewContext creates a new Context.</p>
               
               <pre><code class="language-go">func NewContext() *Context</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewField" data-name="NewField">
               <h3>
                  NewField 
                  <span class="badge">function</span>
                  
                  <a href="#NewField" class="anchor" title="Link to NewField">#</a>
               </h3>
               
               <p>NewField returns a new variable representing a struct field.
For embedded fields, the name is the unqualified type name
under which the field is accessible.</p>
               
               <pre><code class="language-go">func NewField(pos syntax.Pos, pkg *Package, name string, typ Type, embedded bool) *Var</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewFunc" data-name="NewFunc">
               <h3>
                  NewFunc 
                  <span class="badge">function</span>
                  
                  <a href="#NewFunc" class="anchor" title="Link to NewFunc">#</a>
               </h3>
               
               <p>NewFunc returns a new function with the given signature, representing
the function's type.</p>
               
               <pre><code class="language-go">func NewFunc(pos syntax.Pos, pkg *Package, name string, sig *Signature) *Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewInterfaceType" data-name="NewInterfaceType">
               <h3>
                  NewInterfaceType 
                  <span class="badge">function</span>
                  
                  <a href="#NewInterfaceType" class="anchor" title="Link to NewInterfaceType">#</a>
               </h3>
               
               <p>NewInterfaceType returns a new interface for the given methods and embedded types.
NewInterfaceType takes ownership of the provided methods and may modify their types
by setting missing receivers.</p>
               
               <pre><code class="language-go">func NewInterfaceType(methods []*Func, embeddeds []Type) *Interface</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewLabel" data-name="NewLabel">
               <h3>
                  NewLabel 
                  <span class="badge">function</span>
                  
                  <a href="#NewLabel" class="anchor" title="Link to NewLabel">#</a>
               </h3>
               
               <p>NewLabel returns a new label.</p>
               
               <pre><code class="language-go">func NewLabel(pos syntax.Pos, pkg *Package, name string) *Label</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewMap" data-name="NewMap">
               <h3>
                  NewMap 
                  <span class="badge">function</span>
                  
                  <a href="#NewMap" class="anchor" title="Link to NewMap">#</a>
               </h3>
               
               <p>NewMap returns a new map for the given key and element types.</p>
               
               <pre><code class="language-go">func NewMap(key Type, elem Type) *Map</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewNamed" data-name="NewNamed">
               <h3>
                  NewNamed 
                  <span class="badge">function</span>
                  
                  <a href="#NewNamed" class="anchor" title="Link to NewNamed">#</a>
               </h3>
               
               <p>NewNamed returns a new named type for the given type name, underlying type, and associated methods.
If the given type name obj doesn't have a type yet, its type is set to the returned named type.
The underlying type must not be a *Named.</p>
               
               <pre><code class="language-go">func NewNamed(obj *TypeName, underlying Type, methods []*Func) *Named</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewPackage" data-name="NewPackage">
               <h3>
                  NewPackage 
                  <span class="badge">function</span>
                  
                  <a href="#NewPackage" class="anchor" title="Link to NewPackage">#</a>
               </h3>
               
               <p>NewPackage returns a new Package for the given package path and name.
The package is not complete and contains no explicit imports.</p>
               
               <pre><code class="language-go">func NewPackage(path string, name string) *Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewParam" data-name="NewParam">
               <h3>
                  NewParam 
                  <span class="badge">function</span>
                  
                  <a href="#NewParam" class="anchor" title="Link to NewParam">#</a>
               </h3>
               
               <p>NewParam returns a new variable representing a function parameter.</p>
               
               <pre><code class="language-go">func NewParam(pos syntax.Pos, pkg *Package, name string, typ Type) *Var</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewPkgName" data-name="NewPkgName">
               <h3>
                  NewPkgName 
                  <span class="badge">function</span>
                  
                  <a href="#NewPkgName" class="anchor" title="Link to NewPkgName">#</a>
               </h3>
               
               <p>NewPkgName returns a new PkgName object representing an imported package.
The remaining arguments set the attributes found with all Objects.</p>
               
               <pre><code class="language-go">func NewPkgName(pos syntax.Pos, pkg *Package, name string, imported *Package) *PkgName</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewPointer" data-name="NewPointer">
               <h3>
                  NewPointer 
                  <span class="badge">function</span>
                  
                  <a href="#NewPointer" class="anchor" title="Link to NewPointer">#</a>
               </h3>
               
               <p>NewPointer returns a new pointer type for the given element (base) type.</p>
               
               <pre><code class="language-go">func NewPointer(elem Type) *Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewScope" data-name="NewScope">
               <h3>
                  NewScope 
                  <span class="badge">function</span>
                  
                  <a href="#NewScope" class="anchor" title="Link to NewScope">#</a>
               </h3>
               
               <p>NewScope returns a new, empty scope contained in the given parent
scope, if any. The comment is for debugging only.</p>
               
               <pre><code class="language-go">func NewScope(parent *Scope, pos syntax.Pos, end syntax.Pos, comment string) *Scope</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewSignatureType" data-name="NewSignatureType">
               <h3>
                  NewSignatureType 
                  <span class="badge">function</span>
                  
                  <a href="#NewSignatureType" class="anchor" title="Link to NewSignatureType">#</a>
               </h3>
               
               <p>NewSignatureType creates a new function type for the given receiver,
receiver type parameters, type parameters, parameters, and results. If
variadic is set, params must hold at least one parameter and the last
parameter's core type must be of unnamed slice or bytestring type.
If recv is non-nil, typeParams must be empty. If recvTypeParams is
non-empty, recv must be non-nil.</p>
               
               <pre><code class="language-go">func NewSignatureType(recv *Var, recvTypeParams []*TypeParam, typeParams []*TypeParam, params *Tuple, results *Tuple, variadic bool) *Signature</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewSlice" data-name="NewSlice">
               <h3>
                  NewSlice 
                  <span class="badge">function</span>
                  
                  <a href="#NewSlice" class="anchor" title="Link to NewSlice">#</a>
               </h3>
               
               <p>NewSlice returns a new slice type for the given element type.</p>
               
               <pre><code class="language-go">func NewSlice(elem Type) *Slice</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewStruct" data-name="NewStruct">
               <h3>
                  NewStruct 
                  <span class="badge">function</span>
                  
                  <a href="#NewStruct" class="anchor" title="Link to NewStruct">#</a>
               </h3>
               
               <p>NewStruct returns a new struct with the given fields and corresponding field tags.
If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be
only as long as required to hold the tag with the largest index i. Consequently,
if no field has a tag, tags may be nil.</p>
               
               <pre><code class="language-go">func NewStruct(fields []*Var, tags []string) *Struct</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewTerm" data-name="NewTerm">
               <h3>
                  NewTerm 
                  <span class="badge">function</span>
                  
                  <a href="#NewTerm" class="anchor" title="Link to NewTerm">#</a>
               </h3>
               
               <p>NewTerm returns a new union term.</p>
               
               <pre><code class="language-go">func NewTerm(tilde bool, typ Type) *Term</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewTuple" data-name="NewTuple">
               <h3>
                  NewTuple 
                  <span class="badge">function</span>
                  
                  <a href="#NewTuple" class="anchor" title="Link to NewTuple">#</a>
               </h3>
               
               <p>NewTuple returns a new tuple for the given variables.</p>
               
               <pre><code class="language-go">func NewTuple(x ...*Var) *Tuple</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewTypeName" data-name="NewTypeName">
               <h3>
                  NewTypeName 
                  <span class="badge">function</span>
                  
                  <a href="#NewTypeName" class="anchor" title="Link to NewTypeName">#</a>
               </h3>
               
               <p>NewTypeName returns a new type name denoting the given typ.
The remaining arguments set the attributes found with all Objects.
The typ argument may be a defined (Named) type or an alias type.
It may also be nil such that the returned TypeName can be used as
argument for NewNamed, which will set the TypeName's type as a side-
effect.</p>
               
               <pre><code class="language-go">func NewTypeName(pos syntax.Pos, pkg *Package, name string, typ Type) *TypeName</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewTypeNameLazy" data-name="NewTypeNameLazy">
               <h3>
                  NewTypeNameLazy 
                  <span class="badge">function</span>
                  
                  <a href="#NewTypeNameLazy" class="anchor" title="Link to NewTypeNameLazy">#</a>
               </h3>
               
               <p>NewTypeNameLazy returns a new defined type like NewTypeName, but it
lazily calls resolve to finish constructing the Named object.</p>
               
               <pre><code class="language-go">func NewTypeNameLazy(pos syntax.Pos, pkg *Package, name string, load func(named *Named) (tparams []*TypeParam, underlying Type, methods []*Func)) *TypeName</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewTypeParam" data-name="NewTypeParam">
               <h3>
                  NewTypeParam 
                  <span class="badge">function</span>
                  
                  <a href="#NewTypeParam" class="anchor" title="Link to NewTypeParam">#</a>
               </h3>
               
               <p>NewTypeParam returns a new TypeParam. Type parameters may be set on a Named
type by calling SetTypeParams. Setting a type parameter on more than one type
will result in a panic.
The constraint argument can be nil, and set later via SetConstraint. If the
constraint is non-nil, it must be fully defined.</p>
               
               <pre><code class="language-go">func NewTypeParam(obj *TypeName, constraint Type) *TypeParam</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewUnion" data-name="NewUnion">
               <h3>
                  NewUnion 
                  <span class="badge">function</span>
                  
                  <a href="#NewUnion" class="anchor" title="Link to NewUnion">#</a>
               </h3>
               
               <p>NewUnion returns a new Union type with the given terms.
It is an error to create an empty union; they are syntactically not possible.</p>
               
               <pre><code class="language-go">func NewUnion(terms []*Term) *Union</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewVar" data-name="NewVar">
               <h3>
                  NewVar 
                  <span class="badge">function</span>
                  
                  <a href="#NewVar" class="anchor" title="Link to NewVar">#</a>
               </h3>
               
               <p>NewVar returns a new variable.
The arguments set the attributes found with all Objects.</p>
               
               <pre><code class="language-go">func NewVar(pos syntax.Pos, pkg *Package, name string, typ Type) *Var</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumChildren" data-name="NumChildren">
               <h3>
                  NumChildren 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumChildren" class="anchor" title="Link to NumChildren">#</a>
               </h3>
               
               <p>NumChildren returns the number of scopes nested in s.</p>
               
               <pre><code class="language-go">func (s *Scope) NumChildren() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumEmbeddeds" data-name="NumEmbeddeds">
               <h3>
                  NumEmbeddeds 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumEmbeddeds" class="anchor" title="Link to NumEmbeddeds">#</a>
               </h3>
               
               <p>NumEmbeddeds returns the number of embedded types in interface t.</p>
               
               <pre><code class="language-go">func (t *Interface) NumEmbeddeds() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumExplicitMethods" data-name="NumExplicitMethods">
               <h3>
                  NumExplicitMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumExplicitMethods" class="anchor" title="Link to NumExplicitMethods">#</a>
               </h3>
               
               <p>NumExplicitMethods returns the number of explicitly declared methods of interface t.</p>
               
               <pre><code class="language-go">func (t *Interface) NumExplicitMethods() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumFields" data-name="NumFields">
               <h3>
                  NumFields 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumFields" class="anchor" title="Link to NumFields">#</a>
               </h3>
               
               <p>NumFields returns the number of fields in the struct (including blank and embedded fields).</p>
               
               <pre><code class="language-go">func (s *Struct) NumFields() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumMethods" data-name="NumMethods">
               <h3>
                  NumMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumMethods" class="anchor" title="Link to NumMethods">#</a>
               </h3>
               
               <p>NumMethods returns the number of methods available.</p>
               
               <pre><code class="language-go">func (s *_TypeSet) NumMethods() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumMethods" data-name="NumMethods">
               <h3>
                  NumMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumMethods" class="anchor" title="Link to NumMethods">#</a>
               </h3>
               
               <p>NumMethods returns the total number of methods of interface t.</p>
               
               <pre><code class="language-go">func (t *Interface) NumMethods() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumMethods" data-name="NumMethods">
               <h3>
                  NumMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumMethods" class="anchor" title="Link to NumMethods">#</a>
               </h3>
               
               <p>NumMethods returns the number of explicit methods defined for t.</p>
               
               <pre><code class="language-go">func (t *Named) NumMethods() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Obj" data-name="Obj">
               <h3>
                  Obj 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Obj" class="anchor" title="Link to Obj">#</a>
               </h3>
               
               <p>Obj returns the type name for the declaration defining the named type t. For
instantiated types, this is same as the type name of the origin type.</p>
               
               <pre><code class="language-go">func (t *Named) Obj() *TypeName</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Obj" data-name="Obj">
               <h3>
                  Obj 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Obj" class="anchor" title="Link to Obj">#</a>
               </h3>
               
               <p>Obj returns the type name for the declaration defining the alias type a.
For instantiated types, this is same as the type name of the origin type.</p>
               
               <pre><code class="language-go">func (a *Alias) Obj() *TypeName</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Obj" data-name="Obj">
               <h3>
                  Obj 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Obj" class="anchor" title="Link to Obj">#</a>
               </h3>
               
               <p>Obj returns the type name for the type parameter t.</p>
               
               <pre><code class="language-go">func (t *TypeParam) Obj() *TypeName</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Obj" data-name="Obj">
               <h3>
                  Obj 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Obj" class="anchor" title="Link to Obj">#</a>
               </h3>
               
               <p>Obj returns the object denoted by x.f; a *Var for
a field selection, and a *Func in all other cases.</p>
               
               <pre><code class="language-go">func (s *Selection) Obj() Object</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ObjectOf" data-name="ObjectOf">
               <h3>
                  ObjectOf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ObjectOf" class="anchor" title="Link to ObjectOf">#</a>
               </h3>
               
               <p>ObjectOf returns the object denoted by the specified id,
or nil if not found.
If id is an embedded struct field, ObjectOf returns the field (*Var)
it defines, not the type (*TypeName) it uses.
Precondition: the Uses and Defs maps are populated.</p>
               
               <pre><code class="language-go">func (info *Info) ObjectOf(id *syntax.Name) Object</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ObjectString" data-name="ObjectString">
               <h3>
                  ObjectString 
                  <span class="badge">function</span>
                  
                  <a href="#ObjectString" class="anchor" title="Link to ObjectString">#</a>
               </h3>
               
               <p>ObjectString returns the string form of obj.
The Qualifier controls the printing of
package-level objects, and may be nil.</p>
               
               <pre><code class="language-go">func ObjectString(obj Object, qf Qualifier) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Offsetsof" data-name="Offsetsof">
               <h3>
                  Offsetsof 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Offsetsof" class="anchor" title="Link to Offsetsof">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *gcSizes) Offsetsof(fields []*Var) []int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Offsetsof" data-name="Offsetsof">
               <h3>
                  Offsetsof 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Offsetsof" class="anchor" title="Link to Offsetsof">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *StdSizes) Offsetsof(fields []*Var) []int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Origin" data-name="Origin">
               <h3>
                  Origin 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Origin" class="anchor" title="Link to Origin">#</a>
               </h3>
               
               <p>Origin returns the canonical Func for its receiver, i.e. the Func object
recorded in Info.Defs.
For synthetic functions created during instantiation (such as methods on an
instantiated Named type or interface methods that depend on type arguments),
this will be the corresponding Func on the generic (uninstantiated) type.
For all other Funcs Origin returns the receiver.</p>
               
               <pre><code class="language-go">func (obj *Func) Origin() *Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Origin" data-name="Origin">
               <h3>
                  Origin 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Origin" class="anchor" title="Link to Origin">#</a>
               </h3>
               
               <p>Origin returns the generic Alias type of which a is an instance.
If a is not an instance of a generic alias, Origin returns a.</p>
               
               <pre><code class="language-go">func (a *Alias) Origin() *Alias</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Origin" data-name="Origin">
               <h3>
                  Origin 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Origin" class="anchor" title="Link to Origin">#</a>
               </h3>
               
               <p>Origin returns the canonical Var for its receiver, i.e. the Var object
recorded in Info.Defs.
For synthetic Vars created during instantiation (such as struct fields or
function parameters that depend on type arguments), this will be the
corresponding Var on the generic (uninstantiated) type. For all other Vars
Origin returns the receiver.</p>
               
               <pre><code class="language-go">func (obj *Var) Origin() *Var</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Origin" data-name="Origin">
               <h3>
                  Origin 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Origin" class="anchor" title="Link to Origin">#</a>
               </h3>
               
               <p>Origin returns the generic type from which the named type t is
instantiated. If t is not an instantiated type, the result is t.</p>
               
               <pre><code class="language-go">func (t *Named) Origin() *Named</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Params" data-name="Params">
               <h3>
                  Params 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Params" class="anchor" title="Link to Params">#</a>
               </h3>
               
               <p>Params returns the parameters of signature s, or nil.</p>
               
               <pre><code class="language-go">func (s *Signature) Params() *Tuple</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Parent" data-name="Parent">
               <h3>
                  Parent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Parent" class="anchor" title="Link to Parent">#</a>
               </h3>
               
               <p>stub implementations so *lazyObject implements Object and we can
store them directly into Scope.elems.</p>
               
               <pre><code class="language-go">func (*lazyObject) Parent() *Scope</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Parent" data-name="Parent">
               <h3>
                  Parent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Parent" class="anchor" title="Link to Parent">#</a>
               </h3>
               
               <p>Parent returns the scope's containing (parent) scope.</p>
               
               <pre><code class="language-go">func (s *Scope) Parent() *Scope</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Parent" data-name="Parent">
               <h3>
                  Parent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Parent" class="anchor" title="Link to Parent">#</a>
               </h3>
               
               <p>Parent returns the scope in which the object is declared.
The result is nil for methods and struct fields.</p>
               
               <pre><code class="language-go">func (obj *object) Parent() *Scope</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Path" data-name="Path">
               <h3>
                  Path 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Path" class="anchor" title="Link to Path">#</a>
               </h3>
               
               <p>Path returns the package path.</p>
               
               <pre><code class="language-go">func (pkg *Package) Path() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pkg" data-name="Pkg">
               <h3>
                  Pkg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pkg" class="anchor" title="Link to Pkg">#</a>
               </h3>
               
               <p>Pkg returns the package to which the function belongs.
The result is nil for methods of types in the Universe scope,
like method Error of the error built-in interface type.</p>
               
               <pre><code class="language-go">func (obj *Func) Pkg() *Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pkg" data-name="Pkg">
               <h3>
                  Pkg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pkg" class="anchor" title="Link to Pkg">#</a>
               </h3>
               
               <p>Pkg returns the package to which the object belongs.
The result is nil for labels and objects in the Universe scope.</p>
               
               <pre><code class="language-go">func (obj *object) Pkg() *Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pkg" data-name="Pkg">
               <h3>
                  Pkg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pkg" class="anchor" title="Link to Pkg">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) Pkg() *Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PkgNameOf" data-name="PkgNameOf">
               <h3>
                  PkgNameOf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PkgNameOf" class="anchor" title="Link to PkgNameOf">#</a>
               </h3>
               
               <p>PkgNameOf returns the local package name defined by the import,
or nil if not found.
For dot-imports, the package name is ".".
Precondition: the Defs and Implicts maps are populated.</p>
               
               <pre><code class="language-go">func (info *Info) PkgNameOf(imp *syntax.ImportDecl) *PkgName</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pop" data-name="Pop">
               <h3>
                  Pop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pop" class="anchor" title="Link to Pop">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *nodeQueue) Pop() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pos" data-name="Pos">
               <h3>
                  Pos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pos" class="anchor" title="Link to Pos">#</a>
               </h3>
               
               <p>Pos returns the declaration position of the object's identifier.</p>
               
               <pre><code class="language-go">func (obj *object) Pos() syntax.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pos" data-name="Pos">
               <h3>
                  Pos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pos" class="anchor" title="Link to Pos">#</a>
               </h3>
               
               <p>Pos returns the position of the expression corresponding to x.
If x is invalid the position is nopos.</p>
               
               <pre><code class="language-go">func (x *operand) Pos() syntax.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pos" data-name="Pos">
               <h3>
                  Pos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pos" class="anchor" title="Link to Pos">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) Pos() syntax.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Push" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Push" class="anchor" title="Link to Push">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *nodeQueue) Push(x any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RangeKeyVal" data-name="RangeKeyVal">
               <h3>
                  RangeKeyVal 
                  <span class="badge">function</span>
                  
                  <a href="#RangeKeyVal" class="anchor" title="Link to RangeKeyVal">#</a>
               </h3>
               
               <p>RangeKeyVal returns the key and value types for a range over typ.
It panics if range over typ is invalid.</p>
               
               <pre><code class="language-go">func RangeKeyVal(typ Type) (Type, Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Recv" data-name="Recv">
               <h3>
                  Recv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Recv" class="anchor" title="Link to Recv">#</a>
               </h3>
               
               <p>Recv returns the receiver of signature s (if a method), or nil if a
function. It is ignored when comparing signatures for identity.
For an abstract method, Recv returns the enclosing interface either
as a *[Named] or an *[Interface]. Due to embedding, an interface may
contain methods whose receiver type is a different interface.</p>
               
               <pre><code class="language-go">func (s *Signature) Recv() *Var</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Recv" data-name="Recv">
               <h3>
                  Recv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Recv" class="anchor" title="Link to Recv">#</a>
               </h3>
               
               <p>Recv returns the type of x in x.f.</p>
               
               <pre><code class="language-go">func (s *Selection) Recv() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RecvTypeParams" data-name="RecvTypeParams">
               <h3>
                  RecvTypeParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RecvTypeParams" class="anchor" title="Link to RecvTypeParams">#</a>
               </h3>
               
               <p>RecvTypeParams returns the receiver type parameters of signature s, or nil.</p>
               
               <pre><code class="language-go">func (s *Signature) RecvTypeParams() *TypeParamList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RelativeTo" data-name="RelativeTo">
               <h3>
                  RelativeTo 
                  <span class="badge">function</span>
                  
                  <a href="#RelativeTo" class="anchor" title="Link to RelativeTo">#</a>
               </h3>
               
               <p>RelativeTo returns a [Qualifier] that fully qualifies members of
all packages other than pkg.</p>
               
               <pre><code class="language-go">func RelativeTo(pkg *Package) Qualifier</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RenameResult" data-name="RenameResult">
               <h3>
                  RenameResult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RenameResult" class="anchor" title="Link to RenameResult">#</a>
               </h3>
               
               <p>RenameResult takes an array of (result) fields and an index, and if the indexed field
does not have a name and if the result in the signature also does not have a name,
then the signature and field are renamed to
fmt.Sprintf("#rv%d", i+1)
the newly named object is inserted into the signature's scope,
and the object and new field name are returned.
The intended use for RenameResult is to allow rangefunc to assign results within a closure.
This is a hack, as narrowly targeted as possible to discourage abuse.</p>
               
               <pre><code class="language-go">func (s *Signature) RenameResult(results []*syntax.Field, i int) (*Var, *syntax.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Results" data-name="Results">
               <h3>
                  Results 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Results" class="anchor" title="Link to Results">#</a>
               </h3>
               
               <p>Results returns the results of signature s, or nil.</p>
               
               <pre><code class="language-go">func (s *Signature) Results() *Tuple</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Rhs" data-name="Rhs">
               <h3>
                  Rhs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Rhs" class="anchor" title="Link to Rhs">#</a>
               </h3>
               
               <p>Rhs returns the type R on the right-hand side of an alias
declaration "type A = R", which may be another alias.</p>
               
               <pre><code class="language-go">func (a *Alias) Rhs() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Satisfies" data-name="Satisfies">
               <h3>
                  Satisfies 
                  <span class="badge">function</span>
                  
                  <a href="#Satisfies" class="anchor" title="Link to Satisfies">#</a>
               </h3>
               
               <p>Satisfies reports whether type V satisfies the constraint T.
The behavior of Satisfies is unspecified if V is Typ[Invalid] or an uninstantiated
generic type.</p>
               
               <pre><code class="language-go">func Satisfies(V Type, T *Interface) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Scope" data-name="Scope">
               <h3>
                  Scope 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Scope" class="anchor" title="Link to Scope">#</a>
               </h3>
               
               <p>Scope returns the scope of the function's body block.
The result is nil for imported or instantiated functions and methods
(but there is also no mechanism to get to an instantiated function).</p>
               
               <pre><code class="language-go">func (obj *Func) Scope() *Scope</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Scope" data-name="Scope">
               <h3>
                  Scope 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Scope" class="anchor" title="Link to Scope">#</a>
               </h3>
               
               <p>Scope returns the (complete or incomplete) package scope
holding the objects declared at package level (TypeNames,
Consts, Vars, and Funcs).
For a nil pkg receiver, Scope returns the Universe scope.</p>
               
               <pre><code class="language-go">func (pkg *Package) Scope() *Scope</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SelectionString" data-name="SelectionString">
               <h3>
                  SelectionString 
                  <span class="badge">function</span>
                  
                  <a href="#SelectionString" class="anchor" title="Link to SelectionString">#</a>
               </h3>
               
               <p>SelectionString returns the string form of s.
The Qualifier controls the printing of
package-level objects, and may be nil.
Examples:
"field (T) f int"
"method (T) f(X) Y"
"method expr (T) f(X) Y"</p>
               
               <pre><code class="language-go">func SelectionString(s *Selection, qf Qualifier) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetConstraint" data-name="SetConstraint">
               <h3>
                  SetConstraint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetConstraint" class="anchor" title="Link to SetConstraint">#</a>
               </h3>
               
               <p>SetConstraint sets the type constraint for t.
It must be called by users of NewTypeParam after the bound's underlying is
fully defined, and before using the type parameter in any way other than to
form other types. Once SetConstraint returns the receiver, t is safe for
concurrent use.</p>
               
               <pre><code class="language-go">func (t *TypeParam) SetConstraint(bound Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetImports" data-name="SetImports">
               <h3>
                  SetImports 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetImports" class="anchor" title="Link to SetImports">#</a>
               </h3>
               
               <p>SetImports sets the list of explicitly imported packages to list.
It is the caller's responsibility to make sure list elements are unique.</p>
               
               <pre><code class="language-go">func (pkg *Package) SetImports(list []*Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetName" data-name="SetName">
               <h3>
                  SetName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetName" class="anchor" title="Link to SetName">#</a>
               </h3>
               
               <p>SetName sets the package name.</p>
               
               <pre><code class="language-go">func (pkg *Package) SetName(name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetTypeParams" data-name="SetTypeParams">
               <h3>
                  SetTypeParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetTypeParams" class="anchor" title="Link to SetTypeParams">#</a>
               </h3>
               
               <p>SetTypeParams sets the type parameters of the alias type a.
The alias a must not have type arguments.</p>
               
               <pre><code class="language-go">func (a *Alias) SetTypeParams(tparams []*TypeParam)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetTypeParams" data-name="SetTypeParams">
               <h3>
                  SetTypeParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetTypeParams" class="anchor" title="Link to SetTypeParams">#</a>
               </h3>
               
               <p>SetTypeParams sets the type parameters of the named type t.
t must not have type arguments.</p>
               
               <pre><code class="language-go">func (t *Named) SetTypeParams(tparams []*TypeParam)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetUnderlying" data-name="SetUnderlying">
               <h3>
                  SetUnderlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetUnderlying" class="anchor" title="Link to SetUnderlying">#</a>
               </h3>
               
               <p>SetUnderlying sets the underlying type and marks t as complete.
t must not have type arguments.</p>
               
               <pre><code class="language-go">func (t *Named) SetUnderlying(underlying Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Signature" data-name="Signature">
               <h3>
                  Signature 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Signature" class="anchor" title="Link to Signature">#</a>
               </h3>
               
               <p>Signature returns the signature (type) of the function or method.</p>
               
               <pre><code class="language-go">func (obj *Func) Signature() *Signature</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sizeof" data-name="Sizeof">
               <h3>
                  Sizeof 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sizeof" class="anchor" title="Link to Sizeof">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *gcSizes) Sizeof(T Type) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sizeof" data-name="Sizeof">
               <h3>
                  Sizeof 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sizeof" class="anchor" title="Link to Sizeof">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *StdSizes) Sizeof(T Type) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SizesFor" data-name="SizesFor">
               <h3>
                  SizesFor 
                  <span class="badge">function</span>
                  
                  <a href="#SizesFor" class="anchor" title="Link to SizesFor">#</a>
               </h3>
               
               <p>SizesFor returns the Sizes used by a compiler for an architecture.
The result is nil if a compiler/architecture pair is not known.
Supported architectures for compiler "gc":
"386", "amd64", "amd64p32", "arm", "arm64", "loong64", "mips", "mipsle",
"mips64", "mips64le", "ppc64", "ppc64le", "riscv64", "s390x", "sparc64", "wasm".</p>
               
               <pre><code class="language-go">func SizesFor(compiler string, arch string) Sizes</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *Func) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Selection) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns a string representation of the current mapping
from type parameters to types.</p>
               
               <pre><code class="language-go">func (u *unifier) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *Interface) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String prints the termlist exactly (without normalization).</p>
               
               <pre><code class="language-go">func (xl termlist) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (pkg *Package) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Alias) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *Chan) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *_TypeSet) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *Map) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Pointer) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *term) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Slice) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *Tuple) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (u *Union) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *operand) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *Term) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (c color) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *TypeParam) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *object) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Signature) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Struct) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns a string representation of the scope, for debugging.</p>
               
               <pre><code class="language-go">func (s *Scope) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *Nil) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *Builtin) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (m unifyMode) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *Label) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (init *Initializer) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Basic) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *Var) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *TypeName) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *Const) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *PkgName) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Array) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *Named) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <pre><code class="language-go">func (a nodeQueue) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <pre><code class="language-go">func (s typeParamsById) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Tag" data-name="Tag">
               <h3>
                  Tag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Tag" class="anchor" title="Link to Tag">#</a>
               </h3>
               
               <p>Tag returns the i'th field tag for 0 <= i < NumFields().</p>
               
               <pre><code class="language-go">func (s *Struct) Tag(i int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Term" data-name="Term">
               <h3>
                  Term 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Term" class="anchor" title="Link to Term">#</a>
               </h3>
               
               <pre><code class="language-go">func (u *Union) Term(i int) *Term</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Tilde" data-name="Tilde">
               <h3>
                  Tilde 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Tilde" class="anchor" title="Link to Tilde">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *Term) Tilde() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) Type() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <p>Type returns the object's type.</p>
               
               <pre><code class="language-go">func (obj *object) Type() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *Term) Type() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <p>Type returns the type of x.f, which may be different from the type of f.
See Selection for more information.</p>
               
               <pre><code class="language-go">func (s *Selection) Type() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeArgs" data-name="TypeArgs">
               <h3>
                  TypeArgs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TypeArgs" class="anchor" title="Link to TypeArgs">#</a>
               </h3>
               
               <p>TypeArgs returns the type arguments used to instantiate the Alias type.
If a is not an instance of a generic alias, the result is nil.</p>
               
               <pre><code class="language-go">func (a *Alias) TypeArgs() *TypeList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeArgs" data-name="TypeArgs">
               <h3>
                  TypeArgs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TypeArgs" class="anchor" title="Link to TypeArgs">#</a>
               </h3>
               
               <p>TypeArgs returns the type arguments used to instantiate the named type t.</p>
               
               <pre><code class="language-go">func (t *Named) TypeArgs() *TypeList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeOf" data-name="TypeOf">
               <h3>
                  TypeOf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TypeOf" class="anchor" title="Link to TypeOf">#</a>
               </h3>
               
               <p>TypeOf returns the type of expression e, or nil if not found.
Precondition 1: the Types map is populated or StoreTypesInSyntax is set.
Precondition 2: Uses and Defs maps are populated.</p>
               
               <pre><code class="language-go">func (info *Info) TypeOf(e syntax.Expr) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeParams" data-name="TypeParams">
               <h3>
                  TypeParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TypeParams" class="anchor" title="Link to TypeParams">#</a>
               </h3>
               
               <p>TypeParams returns the type parameters of the alias type a, or nil.
A generic Alias and its instances have the same type parameters.</p>
               
               <pre><code class="language-go">func (a *Alias) TypeParams() *TypeParamList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeParams" data-name="TypeParams">
               <h3>
                  TypeParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TypeParams" class="anchor" title="Link to TypeParams">#</a>
               </h3>
               
               <p>TypeParams returns the type parameters of the named type t, or nil.
The result is non-nil for an (originally) generic type even if it is instantiated.</p>
               
               <pre><code class="language-go">func (t *Named) TypeParams() *TypeParamList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeParams" data-name="TypeParams">
               <h3>
                  TypeParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TypeParams" class="anchor" title="Link to TypeParams">#</a>
               </h3>
               
               <p>TypeParams returns the type parameters of signature s, or nil.</p>
               
               <pre><code class="language-go">func (s *Signature) TypeParams() *TypeParamList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeString" data-name="TypeString">
               <h3>
                  TypeString 
                  <span class="badge">function</span>
                  
                  <a href="#TypeString" class="anchor" title="Link to TypeString">#</a>
               </h3>
               
               <p>TypeString returns the string representation of typ.
The [Qualifier] controls the printing of
package-level objects, and may be nil.</p>
               
               <pre><code class="language-go">func TypeString(typ Type, qf Qualifier) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unalias" data-name="Unalias">
               <h3>
                  Unalias 
                  <span class="badge">function</span>
                  
                  <a href="#Unalias" class="anchor" title="Link to Unalias">#</a>
               </h3>
               
               <p>Unalias returns t if it is not an alias type;
otherwise it follows t's alias chain until it
reaches a non-alias type which is then returned.
Consequently, the result is never an alias type.</p>
               
               <pre><code class="language-go">func Unalias(t Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Underlying" data-name="Underlying">
               <h3>
                  Underlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Underlying" class="anchor" title="Link to Underlying">#</a>
               </h3>
               
               <p>Underlying returns the [underlying type] of the alias type a, which is the
underlying type of the aliased type. Underlying types are never Named,
TypeParam, or Alias types.
[underlying type]: https://go.dev/ref/spec#Underlying_types.</p>
               
               <pre><code class="language-go">func (a *Alias) Underlying() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Underlying" data-name="Underlying">
               <h3>
                  Underlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Underlying" class="anchor" title="Link to Underlying">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Slice) Underlying() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Underlying" data-name="Underlying">
               <h3>
                  Underlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Underlying" class="anchor" title="Link to Underlying">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Basic) Underlying() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Underlying" data-name="Underlying">
               <h3>
                  Underlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Underlying" class="anchor" title="Link to Underlying">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Signature) Underlying() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Underlying" data-name="Underlying">
               <h3>
                  Underlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Underlying" class="anchor" title="Link to Underlying">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *Tuple) Underlying() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Underlying" data-name="Underlying">
               <h3>
                  Underlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Underlying" class="anchor" title="Link to Underlying">#</a>
               </h3>
               
               <p>Underlying returns the [underlying type] of the named type t, resolving all
forwarding declarations. Underlying types are never Named, TypeParam, or
Alias types.
[underlying type]: https://go.dev/ref/spec#Underlying_types.</p>
               
               <pre><code class="language-go">func (t *Named) Underlying() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Underlying" data-name="Underlying">
               <h3>
                  Underlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Underlying" class="anchor" title="Link to Underlying">#</a>
               </h3>
               
               <pre><code class="language-go">func (u *Union) Underlying() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Underlying" data-name="Underlying">
               <h3>
                  Underlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Underlying" class="anchor" title="Link to Underlying">#</a>
               </h3>
               
               <p>Underlying returns the [underlying type] of the type parameter t, which is
the underlying type of its constraint. This type is always an interface.
[underlying type]: https://go.dev/ref/spec#Underlying_types.</p>
               
               <pre><code class="language-go">func (t *TypeParam) Underlying() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Underlying" data-name="Underlying">
               <h3>
                  Underlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Underlying" class="anchor" title="Link to Underlying">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *Interface) Underlying() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Underlying" data-name="Underlying">
               <h3>
                  Underlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Underlying" class="anchor" title="Link to Underlying">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Struct) Underlying() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Underlying" data-name="Underlying">
               <h3>
                  Underlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Underlying" class="anchor" title="Link to Underlying">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *Chan) Underlying() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Underlying" data-name="Underlying">
               <h3>
                  Underlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Underlying" class="anchor" title="Link to Underlying">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *Map) Underlying() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Underlying" data-name="Underlying">
               <h3>
                  Underlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Underlying" class="anchor" title="Link to Underlying">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Pointer) Underlying() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Underlying" data-name="Underlying">
               <h3>
                  Underlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Underlying" class="anchor" title="Link to Underlying">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Array) Underlying() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ArgumentError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Val" data-name="Val">
               <h3>
                  Val 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Val" class="anchor" title="Link to Val">#</a>
               </h3>
               
               <p>Val returns the constant's value.</p>
               
               <pre><code class="language-go">func (obj *Const) Val() constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Variadic" data-name="Variadic">
               <h3>
                  Variadic 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Variadic" class="anchor" title="Link to Variadic">#</a>
               </h3>
               
               <p>Variadic reports whether the signature s is variadic.</p>
               
               <pre><code class="language-go">func (s *Signature) Variadic() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteSignature" data-name="WriteSignature">
               <h3>
                  WriteSignature 
                  <span class="badge">function</span>
                  
                  <a href="#WriteSignature" class="anchor" title="Link to WriteSignature">#</a>
               </h3>
               
               <p>WriteSignature writes the representation of the signature sig to buf,
without a leading "func" keyword. The [Qualifier] controls the printing
of package-level objects, and may be nil.</p>
               
               <pre><code class="language-go">func WriteSignature(buf *bytes.Buffer, sig *Signature, qf Qualifier)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteTo" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteTo" class="anchor" title="Link to WriteTo">#</a>
               </h3>
               
               <p>WriteTo writes a string representation of the scope to w,
with the scope elements sorted by name.
The level of indentation is controlled by n >= 0, with
n == 0 for no indentation.
If recurse is set, it also writes nested (children) scopes.</p>
               
               <pre><code class="language-go">func (s *Scope) WriteTo(w io.Writer, n int, recurse bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteType" data-name="WriteType">
               <h3>
                  WriteType 
                  <span class="badge">function</span>
                  
                  <a href="#WriteType" class="anchor" title="Link to WriteType">#</a>
               </h3>
               
               <p>WriteType writes the string representation of typ to buf.
The [Qualifier] controls the printing of
package-level objects, and may be nil.</p>
               
               <pre><code class="language-go">func WriteType(buf *bytes.Buffer, typ Type, qf Qualifier)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *nodeSet) add(p *graphNode)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <pre><code class="language-go">func (l *instanceLookup) add(inst *Named)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addAltDecl" data-name="addAltDecl">
               <h3>
                  addAltDecl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addAltDecl" class="anchor" title="Link to addAltDecl">#</a>
               </h3>
               
               <p>addAltDecl is a specialized form of addf reporting another declaration of obj.</p>
               
               <pre><code class="language-go">func (err *error_) addAltDecl(obj Object)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addDeclDep" data-name="addDeclDep">
               <h3>
                  addDeclDep 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addDeclDep" class="anchor" title="Link to addDeclDep">#</a>
               </h3>
               
               <p>addDeclDep adds the dependency edge (check.decl -> to) if check.decl exists</p>
               
               <pre><code class="language-go">func (check *Checker) addDeclDep(to Object)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addDep" data-name="addDep">
               <h3>
                  addDep 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addDep" class="anchor" title="Link to addDep">#</a>
               </h3>
               
               <p>addDep adds obj to the set of objects d's init expression depends on.</p>
               
               <pre><code class="language-go">func (d *declInfo) addDep(obj Object)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addEdge" data-name="addEdge">
               <h3>
                  addEdge 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addEdge" class="anchor" title="Link to addEdge">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *monoGraph) addEdge(dst int, src int, weight int, pos syntax.Pos, typ Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addf" data-name="addf">
               <h3>
                  addf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addf" class="anchor" title="Link to addf">#</a>
               </h3>
               
               <p>addf adds formatted error information to err.
It may be called multiple times to provide additional information.
The position of the first call to addf determines the position of the reported Error.
Subsequent calls to addf provide additional information in the form of additional lines
in the error message (types2) or continuation errors identified by a tab-indented error
message (go/types).</p>
               
               <pre><code class="language-go">func (err *error_) addf(at poser, format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="aliasAny" data-name="aliasAny">
               <h3>
                  aliasAny 
                  <span class="badge">function</span>
                  
                  <a href="#aliasAny" class="anchor" title="Link to aliasAny">#</a>
               </h3>
               
               <pre><code class="language-go">func aliasAny() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="align" data-name="align">
               <h3>
                  align 
                  <span class="badge">function</span>
                  
                  <a href="#align" class="anchor" title="Link to align">#</a>
               </h3>
               
               <p>align returns the smallest y >= x such that y % a == 0.
a must be within 1 and 8 and it must be a power of 2.
The result may be negative due to overflow.</p>
               
               <pre><code class="language-go">func align(x int64, a int64) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="alignof" data-name="alignof">
               <h3>
                  alignof 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#alignof" class="anchor" title="Link to alignof">#</a>
               </h3>
               
               <pre><code class="language-go">func (conf *Config) alignof(T Type) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allBasic" data-name="allBasic">
               <h3>
                  allBasic 
                  <span class="badge">function</span>
                  
                  <a href="#allBasic" class="anchor" title="Link to allBasic">#</a>
               </h3>
               
               <p>allBasic reports whether under(t) is a basic type with the specified info.
If t is a type parameter, the result is true if isBasic(t, info) is true
for all specific types of the type parameter's type set.
allBasic(t, info) is an optimized version of isBasic(coreType(t), info).</p>
               
               <pre><code class="language-go">func allBasic(t Type, info BasicInfo) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allBoolean" data-name="allBoolean">
               <h3>
                  allBoolean 
                  <span class="badge">function</span>
                  
                  <a href="#allBoolean" class="anchor" title="Link to allBoolean">#</a>
               </h3>
               
               <pre><code class="language-go">func allBoolean(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allInteger" data-name="allInteger">
               <h3>
                  allInteger 
                  <span class="badge">function</span>
                  
                  <a href="#allInteger" class="anchor" title="Link to allInteger">#</a>
               </h3>
               
               <pre><code class="language-go">func allInteger(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allNumeric" data-name="allNumeric">
               <h3>
                  allNumeric 
                  <span class="badge">function</span>
                  
                  <a href="#allNumeric" class="anchor" title="Link to allNumeric">#</a>
               </h3>
               
               <pre><code class="language-go">func allNumeric(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allNumericOrString" data-name="allNumericOrString">
               <h3>
                  allNumericOrString 
                  <span class="badge">function</span>
                  
                  <a href="#allNumericOrString" class="anchor" title="Link to allNumericOrString">#</a>
               </h3>
               
               <pre><code class="language-go">func allNumericOrString(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allOrdered" data-name="allOrdered">
               <h3>
                  allOrdered 
                  <span class="badge">function</span>
                  
                  <a href="#allOrdered" class="anchor" title="Link to allOrdered">#</a>
               </h3>
               
               <pre><code class="language-go">func allOrdered(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allString" data-name="allString">
               <h3>
                  allString 
                  <span class="badge">function</span>
                  
                  <a href="#allString" class="anchor" title="Link to allString">#</a>
               </h3>
               
               <pre><code class="language-go">func allString(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allUnsigned" data-name="allUnsigned">
               <h3>
                  allUnsigned 
                  <span class="badge">function</span>
                  
                  <a href="#allUnsigned" class="anchor" title="Link to allUnsigned">#</a>
               </h3>
               
               <pre><code class="language-go">func allUnsigned(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allowVersion" data-name="allowVersion">
               <h3>
                  allowVersion 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#allowVersion" class="anchor" title="Link to allowVersion">#</a>
               </h3>
               
               <p>allowVersion reports whether the current effective Go version
(which may vary from one file to another) is allowed to use the
feature version (want).</p>
               
               <pre><code class="language-go">func (check *Checker) allowVersion(want goVersion) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="applyTypeFunc" data-name="applyTypeFunc">
               <h3>
                  applyTypeFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#applyTypeFunc" class="anchor" title="Link to applyTypeFunc">#</a>
               </h3>
               
               <p>applyTypeFunc applies f to x. If x is a type parameter,
the result is a type parameter constrained by a new
interface bound. The type bounds for that interface
are computed by applying f to each of the type bounds
of x. If any of these applications of f return nil,
applyTypeFunc returns nil.
If x is not a type parameter, the result is f(x).</p>
               
               <pre><code class="language-go">func (check *Checker) applyTypeFunc(f func(Type) Type, x *operand, id builtinId) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="argErrPos" data-name="argErrPos">
               <h3>
                  argErrPos 
                  <span class="badge">function</span>
                  
                  <a href="#argErrPos" class="anchor" title="Link to argErrPos">#</a>
               </h3>
               
               <p>argErrPos returns the node (poser) for reporting an invalid argument count.</p>
               
               <pre><code class="language-go">func argErrPos(call *syntax.CallExpr) *syntax.CallExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="arguments" data-name="arguments">
               <h3>
                  arguments 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#arguments" class="anchor" title="Link to arguments">#</a>
               </h3>
               
               <p>arguments type-checks arguments passed to a function call with the given signature.
The function and its arguments may be generic, and possibly partially instantiated.
targs and xlist are the function's type arguments (and corresponding expressions).
args are the function arguments. If an argument args[i] is a partially instantiated
generic function, atargs[i] and atxlist[i] are the corresponding type arguments
(and corresponding expressions).
If the callee is variadic, arguments adjusts its signature to match the provided
arguments. The type parameters and arguments of the callee and all its arguments
are used together to infer any missing type arguments, and the callee and argument
functions are instantiated as necessary.
The result signature is the (possibly adjusted and instantiated) function signature.
If an error occurred, the result signature is the incoming sig.</p>
               
               <pre><code class="language-go">func (check *Checker) arguments(call *syntax.CallExpr, sig *Signature, targs []Type, xlist []syntax.Expr, args []*operand, atargs [][]Type, atxlist [][]syntax.Expr) (rsig *Signature)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="arity" data-name="arity">
               <h3>
                  arity 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#arity" class="anchor" title="Link to arity">#</a>
               </h3>
               
               <p>arity checks that the lhs and rhs of a const or var decl
have a matching number of names and initialization values.
If inherited is set, the initialization values are from
another (constant) declaration.</p>
               
               <pre><code class="language-go">func (check *Checker) arity(pos syntax.Pos, names []*syntax.Name, inits []syntax.Expr, constDecl bool, inherited bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="arrayLength" data-name="arrayLength">
               <h3>
                  arrayLength 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#arrayLength" class="anchor" title="Link to arrayLength">#</a>
               </h3>
               
               <p>arrayLength type-checks the array length expression e
and returns the constant length >= 0, or a value < 0
to indicate an error (and thus an unknown length).</p>
               
               <pre><code class="language-go">func (check *Checker) arrayLength(e syntax.Expr) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="arrayPtrDeref" data-name="arrayPtrDeref">
               <h3>
                  arrayPtrDeref 
                  <span class="badge">function</span>
                  
                  <a href="#arrayPtrDeref" class="anchor" title="Link to arrayPtrDeref">#</a>
               </h3>
               
               <p>arrayPtrDeref returns A if typ is of the form *A and A is an array;
otherwise it returns typ.</p>
               
               <pre><code class="language-go">func arrayPtrDeref(typ Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="asBoundTypeParam" data-name="asBoundTypeParam">
               <h3>
                  asBoundTypeParam 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#asBoundTypeParam" class="anchor" title="Link to asBoundTypeParam">#</a>
               </h3>
               
               <p>asBoundTypeParam returns x.(*TypeParam) if x is a type parameter recorded with u.
Otherwise, the result is nil.</p>
               
               <pre><code class="language-go">func (u *unifier) asBoundTypeParam(x Type) *TypeParam</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="asGoVersion" data-name="asGoVersion">
               <h3>
                  asGoVersion 
                  <span class="badge">function</span>
                  
                  <a href="#asGoVersion" class="anchor" title="Link to asGoVersion">#</a>
               </h3>
               
               <p>asGoVersion returns v as a goVersion (e.g., "go1.20.1" becomes "go1.20").
If v is not a valid Go version, the result is the empty string.</p>
               
               <pre><code class="language-go">func asGoVersion(v string) goVersion</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="asInterface" data-name="asInterface">
               <h3>
                  asInterface 
                  <span class="badge">function</span>
                  
                  <a href="#asInterface" class="anchor" title="Link to asInterface">#</a>
               </h3>
               
               <p>asInterface returns the underlying type of x as an interface if
it is a non-type parameter interface. Otherwise it returns nil.</p>
               
               <pre><code class="language-go">func asInterface(x Type) (i *Interface)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="asNamed" data-name="asNamed">
               <h3>
                  asNamed 
                  <span class="badge">function</span>
                  
                  <a href="#asNamed" class="anchor" title="Link to asNamed">#</a>
               </h3>
               
               <p>asNamed returns t as *Named if that is t's
actual type. It returns nil otherwise.</p>
               
               <pre><code class="language-go">func asNamed(t Type) *Named</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assert" data-name="assert">
               <h3>
                  assert 
                  <span class="badge">function</span>
                  
                  <a href="#assert" class="anchor" title="Link to assert">#</a>
               </h3>
               
               <pre><code class="language-go">func assert(p bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assertSortedMethods" data-name="assertSortedMethods">
               <h3>
                  assertSortedMethods 
                  <span class="badge">function</span>
                  
                  <a href="#assertSortedMethods" class="anchor" title="Link to assertSortedMethods">#</a>
               </h3>
               
               <pre><code class="language-go">func assertSortedMethods(list []*Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assertableTo" data-name="assertableTo">
               <h3>
                  assertableTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assertableTo" class="anchor" title="Link to assertableTo">#</a>
               </h3>
               
               <p>assertableTo reports whether a value of type V can be asserted to have type T.
The receiver may be nil if assertableTo is invoked through an exported API call
(such as AssertableTo), i.e., when all methods have been type-checked.
The underlying type of V must be an interface.
If the result is false and cause is not nil, *cause describes the error.
TODO(gri) replace calls to this function with calls to newAssertableTo.</p>
               
               <pre><code class="language-go">func (check *Checker) assertableTo(V Type, T Type, cause *string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assign" data-name="assign">
               <h3>
                  assign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assign" class="anchor" title="Link to assign">#</a>
               </h3>
               
               <p>assign records that tpar was instantiated as targ at pos.</p>
               
               <pre><code class="language-go">func (w *monoGraph) assign(pkg *Package, pos syntax.Pos, tpar *TypeParam, targ Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignError" data-name="assignError">
               <h3>
                  assignError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignError" class="anchor" title="Link to assignError">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) assignError(rhs []syntax.Expr, l int, r int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignVar" data-name="assignVar">
               <h3>
                  assignVar 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignVar" class="anchor" title="Link to assignVar">#</a>
               </h3>
               
               <p>assignVar checks the assignment lhs = rhs (if x == nil), or lhs = x (if x != nil).
If x != nil, it must be the evaluation of rhs (and rhs will be ignored).
If the assignment check fails and x != nil, x.mode is set to invalid.</p>
               
               <pre><code class="language-go">func (check *Checker) assignVar(lhs syntax.Expr, rhs syntax.Expr, x *operand, context string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignVars" data-name="assignVars">
               <h3>
                  assignVars 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignVars" class="anchor" title="Link to assignVars">#</a>
               </h3>
               
               <p>assignVars type-checks assignments of expressions orig_rhs to variables lhs.</p>
               
               <pre><code class="language-go">func (check *Checker) assignVars(lhs []syntax.Expr, orig_rhs []syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignableTo" data-name="assignableTo">
               <h3>
                  assignableTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignableTo" class="anchor" title="Link to assignableTo">#</a>
               </h3>
               
               <p>assignableTo reports whether x is assignable to a variable of type T. If the
result is false and a non-nil cause is provided, it may be set to a more
detailed explanation of the failure (result != ""). The returned error code
is only valid if the (first) result is false. The check parameter may be nil
if assignableTo is invoked through an exported API call, i.e., when all
methods have been type-checked.</p>
               
               <pre><code class="language-go">func (x *operand) assignableTo(check *Checker, T Type, cause *string) (bool, Code)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignment" data-name="assignment">
               <h3>
                  assignment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignment" class="anchor" title="Link to assignment">#</a>
               </h3>
               
               <p>assignment reports whether x can be assigned to a variable of type T,
if necessary by attempting to convert untyped values to the appropriate
type. context describes the context in which the assignment takes place.
Use T == nil to indicate assignment to an untyped blank identifier.
If the assignment check fails, x.mode is set to invalid.</p>
               
               <pre><code class="language-go">func (check *Checker) assignment(x *operand, T Type, context string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="at" data-name="at">
               <h3>
                  at 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#at" class="anchor" title="Link to at">#</a>
               </h3>
               
               <p>at returns the (possibly nil) type for type parameter x.</p>
               
               <pre><code class="language-go">func (u *unifier) at(x *TypeParam) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atPos" data-name="atPos">
               <h3>
                  atPos 
                  <span class="badge">function</span>
                  
                  <a href="#atPos" class="anchor" title="Link to atPos">#</a>
               </h3>
               
               <p>atPos reports the left (= start) position of at.</p>
               
               <pre><code class="language-go">func atPos(at poser) syntax.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="basicLit" data-name="basicLit">
               <h3>
                  basicLit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#basicLit" class="anchor" title="Link to basicLit">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) basicLit(x *operand, e *syntax.BasicLit)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="binary" data-name="binary">
               <h3>
                  binary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#binary" class="anchor" title="Link to binary">#</a>
               </h3>
               
               <p>If e != nil, it must be the binary expression; it may be nil for non-constant expressions
(when invoked for an assignment operation where the binary expression is implicit).</p>
               
               <pre><code class="language-go">func (check *Checker) binary(x *operand, e syntax.Expr, lhs syntax.Expr, rhs syntax.Expr, op syntax.Operator)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bindTParams" data-name="bindTParams">
               <h3>
                  bindTParams 
                  <span class="badge">function</span>
                  
                  <a href="#bindTParams" class="anchor" title="Link to bindTParams">#</a>
               </h3>
               
               <pre><code class="language-go">func bindTParams(list []*TypeParam) *TypeParamList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="blockBranches" data-name="blockBranches">
               <h3>
                  blockBranches 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#blockBranches" class="anchor" title="Link to blockBranches">#</a>
               </h3>
               
               <p>blockBranches processes a block's statement list and returns the set of outgoing forward jumps.
all is the scope of all declared labels, parent the set of labels declared in the immediately
enclosing block, and lstmt is the labeled statement this block is associated with (or nil).</p>
               
               <pre><code class="language-go">func (check *Checker) blockBranches(all *Scope, parent *block, lstmt *syntax.LabeledStmt, list []syntax.Stmt) []*syntax.BranchStmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bound" data-name="bound">
               <h3>
                  bound 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bound" class="anchor" title="Link to bound">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) bound(x syntax.Expr) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="brokenAlias" data-name="brokenAlias">
               <h3>
                  brokenAlias 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#brokenAlias" class="anchor" title="Link to brokenAlias">#</a>
               </h3>
               
               <p>brokenAlias records that alias doesn't have a determined type yet.
It also sets alias.typ to Typ[Invalid].
Not used if check.conf.EnableAlias is set.</p>
               
               <pre><code class="language-go">func (check *Checker) brokenAlias(alias *TypeName)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="builtin" data-name="builtin">
               <h3>
                  builtin 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#builtin" class="anchor" title="Link to builtin">#</a>
               </h3>
               
               <p>builtin type-checks a call to the built-in specified by id and
reports whether the call is valid, with *x holding the result;
but x.expr is not set. If the call is invalid, the result is
false, and *x is undefined.</p>
               
               <pre><code class="language-go">func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (_ bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byte" data-name="byte">
               <h3>
                  byte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#byte" class="anchor" title="Link to byte">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *typeWriter) byte(b byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="callExpr" data-name="callExpr">
               <h3>
                  callExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#callExpr" class="anchor" title="Link to callExpr">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) callExpr(x *operand, call *syntax.CallExpr) exprKind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="caseTypes" data-name="caseTypes">
               <h3>
                  caseTypes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#caseTypes" class="anchor" title="Link to caseTypes">#</a>
               </h3>
               
               <p>caseTypes typechecks the type expressions of a type case, checks for duplicate types
using the seen map, and verifies that each type is valid with respect to the type of
the operand x corresponding to the type switch expression. If that expression is not
valid, x must be nil.
switch <x>.(type) {
case <types>: ...
...
}
caseTypes returns the case-specific type for a variable v introduced through a short
variable declaration by the type switch:
switch v := <x>.(type) {
case <types>: // T is the type of <v> in this case
...
}
If there is exactly one type expression, T is the type of that expression. If there
are multiple type expressions, or if predeclared nil is among the types, the result
is the type of x. If x is invalid (nil), the result is the invalid type.</p>
               
               <pre><code class="language-go">func (check *Checker) caseTypes(x *operand, types []syntax.Expr, seen map[Type]syntax.Expr) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="caseTypes_currently_unused" data-name="caseTypes_currently_unused">
               <h3>
                  caseTypes_currently_unused 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#caseTypes_currently_unused" class="anchor" title="Link to caseTypes_currently_unused">#</a>
               </h3>
               
               <p>TODO(gri) Once we are certain that typeHash is correct in all situations, use this version of caseTypes instead.
(Currently it may be possible that different types have identical names and import paths due to ImporterFrom.)</p>
               
               <pre><code class="language-go">func (check *Checker) caseTypes_currently_unused(x *operand, xtyp *Interface, types []syntax.Expr, seen map[string]syntax.Expr) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="caseValues" data-name="caseValues">
               <h3>
                  caseValues 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#caseValues" class="anchor" title="Link to caseValues">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) caseValues(x *operand, values []syntax.Expr, seen valueMap)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkFieldUniqueness" data-name="checkFieldUniqueness">
               <h3>
                  checkFieldUniqueness 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkFieldUniqueness" class="anchor" title="Link to checkFieldUniqueness">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) checkFieldUniqueness(base *Named)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkFiles" data-name="checkFiles">
               <h3>
                  checkFiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkFiles" class="anchor" title="Link to checkFiles">#</a>
               </h3>
               
               <p>checkFiles type-checks the specified files. Errors are reported as
a side effect, not by returning early, to ensure that well-formed
syntax is properly type annotated even in a package containing
errors.</p>
               
               <pre><code class="language-go">func (check *Checker) checkFiles(files []*syntax.File)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanup" data-name="cleanup">
               <h3>
                  cleanup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cleanup" class="anchor" title="Link to cleanup">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *Named) cleanup()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanup" data-name="cleanup">
               <h3>
                  cleanup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cleanup" class="anchor" title="Link to cleanup">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Alias) cleanup()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanup" data-name="cleanup">
               <h3>
                  cleanup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cleanup" class="anchor" title="Link to cleanup">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *TypeParam) cleanup()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanup" data-name="cleanup">
               <h3>
                  cleanup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cleanup" class="anchor" title="Link to cleanup">#</a>
               </h3>
               
               <p>cleanup runs cleanup for all collected cleaners.</p>
               
               <pre><code class="language-go">func (check *Checker) cleanup()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanup" data-name="cleanup">
               <h3>
                  cleanup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cleanup" class="anchor" title="Link to cleanup">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *Interface) cleanup()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clone" data-name="clone">
               <h3>
                  clone 
                  <span class="badge">function</span>
                  
                  <a href="#clone" class="anchor" title="Link to clone">#</a>
               </h3>
               
               <p>clone makes a "flat copy" of *p and returns a pointer to the copy.</p>
               
               <pre><code class="language-go">func clone(p P) P</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cloneFunc" data-name="cloneFunc">
               <h3>
                  cloneFunc 
                  <span class="badge">function</span>
                  
                  <a href="#cloneFunc" class="anchor" title="Link to cloneFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func cloneFunc(f *Func, typ Type) *Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cloneVar" data-name="cloneVar">
               <h3>
                  cloneVar 
                  <span class="badge">function</span>
                  
                  <a href="#cloneVar" class="anchor" title="Link to cloneVar">#</a>
               </h3>
               
               <pre><code class="language-go">func cloneVar(v *Var, typ Type) *Var</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeScope" data-name="closeScope">
               <h3>
                  closeScope 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeScope" class="anchor" title="Link to closeScope">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) closeScope()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cmp" data-name="cmp">
               <h3>
                  cmp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cmp" class="anchor" title="Link to cmp">#</a>
               </h3>
               
               <p>cmp reports whether object a is ordered before object b.
cmp returns:
-1 if a is before b
0 if a is equivalent to b
+1 if a is behind b
Objects are ordered nil before non-nil, exported before
non-exported, then by name, and finally (for non-exported
functions) by package path.</p>
               
               <pre><code class="language-go">func (a *object) cmp(b *object) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cmp" data-name="cmp">
               <h3>
                  cmp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cmp" class="anchor" title="Link to cmp">#</a>
               </h3>
               
               <p>cmp returns -1, 0, or +1 depending on whether x < y, x == y, or x > y,
interpreted as Go versions.</p>
               
               <pre><code class="language-go">func (x goVersion) cmp(y goVersion) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cmpPos" data-name="cmpPos">
               <h3>
                  cmpPos 
                  <span class="badge">function</span>
                  
                  <a href="#cmpPos" class="anchor" title="Link to cmpPos">#</a>
               </h3>
               
               <p>cmpPos compares the positions p and q and returns a result r as follows:
r <  0: p is before q
r == 0: p and q are the same position (but may not be identical)
r >  0: p is after q
If p and q are in different files, p is before q if the filename
of p sorts lexicographically before the filename of q.</p>
               
               <pre><code class="language-go">func cmpPos(p syntax.Pos, q syntax.Pos) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="collectMethods" data-name="collectMethods">
               <h3>
                  collectMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#collectMethods" class="anchor" title="Link to collectMethods">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) collectMethods(obj *TypeName)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="collectObjects" data-name="collectObjects">
               <h3>
                  collectObjects 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#collectObjects" class="anchor" title="Link to collectObjects">#</a>
               </h3>
               
               <p>collectObjects collects all file and package objects and inserts them
into their respective scopes. It also performs imports and associates
methods with receiver base type names.</p>
               
               <pre><code class="language-go">func (check *Checker) collectObjects()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="collectParams" data-name="collectParams">
               <h3>
                  collectParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#collectParams" class="anchor" title="Link to collectParams">#</a>
               </h3>
               
               <p>collectParams collects (but does not declare) all parameters of list and returns
the list of parameter names, corresponding parameter variables, and whether the
parameter list is variadic. Anonymous parameters are recorded with nil names.</p>
               
               <pre><code class="language-go">func (check *Checker) collectParams(list []*syntax.Field, variadicOk bool) (names []*syntax.Name, params []*Var, variadic bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="collectRecv" data-name="collectRecv">
               <h3>
                  collectRecv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#collectRecv" class="anchor" title="Link to collectRecv">#</a>
               </h3>
               
               <p>collectRecv extracts the method receiver and its type parameters (if any) from rparam.
It declares the type parameters (but not the receiver) in the current scope, and
returns the receiver variable and its type parameter list (if any).</p>
               
               <pre><code class="language-go">func (check *Checker) collectRecv(rparam *syntax.Field, scopePos syntax.Pos) (*Var, *TypeParamList)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="collectTypeParams" data-name="collectTypeParams">
               <h3>
                  collectTypeParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#collectTypeParams" class="anchor" title="Link to collectTypeParams">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) collectTypeParams(dst **TypeParamList, list []*syntax.Field)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="color" data-name="color">
               <h3>
                  color 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#color" class="anchor" title="Link to color">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *object) color() color</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="color" data-name="color">
               <h3>
                  color 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#color" class="anchor" title="Link to color">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) color() color</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="colorFor" data-name="colorFor">
               <h3>
                  colorFor 
                  <span class="badge">function</span>
                  
                  <a href="#colorFor" class="anchor" title="Link to colorFor">#</a>
               </h3>
               
               <p>colorFor returns the (initial) color for an object depending on
whether its type t is known or not.</p>
               
               <pre><code class="language-go">func colorFor(t Type) color</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="comparableType" data-name="comparableType">
               <h3>
                  comparableType 
                  <span class="badge">function</span>
                  
                  <a href="#comparableType" class="anchor" title="Link to comparableType">#</a>
               </h3>
               
               <p>If dynamic is set, non-type parameter interfaces are always comparable.
If reportf != nil, it may be used to report why T is not comparable.</p>
               
               <pre><code class="language-go">func comparableType(T Type, dynamic bool, seen map[Type]bool, reportf func(string, ...interface{})) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compareFunc" data-name="compareFunc">
               <h3>
                  compareFunc 
                  <span class="badge">function</span>
                  
                  <a href="#compareFunc" class="anchor" title="Link to compareFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func compareFunc(a *Func, b *Func) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="comparison" data-name="comparison">
               <h3>
                  comparison 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#comparison" class="anchor" title="Link to comparison">#</a>
               </h3>
               
               <p>If switchCase is true, the operator op is ignored.</p>
               
               <pre><code class="language-go">func (check *Checker) comparison(x *operand, y *operand, op syntax.Operator, switchCase bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compositeKind" data-name="compositeKind">
               <h3>
                  compositeKind 
                  <span class="badge">function</span>
                  
                  <a href="#compositeKind" class="anchor" title="Link to compositeKind">#</a>
               </h3>
               
               <p>compositeKind returns the kind of the given composite type
("array", "slice", etc.) or the empty string if typ is not
composite but a basic type.</p>
               
               <pre><code class="language-go">func compositeKind(typ Type) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compositeLit" data-name="compositeLit">
               <h3>
                  compositeLit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#compositeLit" class="anchor" title="Link to compositeLit">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) compositeLit(x *operand, e *syntax.CompositeLit, hint Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="computeInterfaceTypeSet" data-name="computeInterfaceTypeSet">
               <h3>
                  computeInterfaceTypeSet 
                  <span class="badge">function</span>
                  
                  <a href="#computeInterfaceTypeSet" class="anchor" title="Link to computeInterfaceTypeSet">#</a>
               </h3>
               
               <p>computeInterfaceTypeSet may be called with check == nil.</p>
               
               <pre><code class="language-go">func computeInterfaceTypeSet(check *Checker, pos syntax.Pos, ityp *Interface) *_TypeSet</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="computeUnionTypeSet" data-name="computeUnionTypeSet">
               <h3>
                  computeUnionTypeSet 
                  <span class="badge">function</span>
                  
                  <a href="#computeUnionTypeSet" class="anchor" title="Link to computeUnionTypeSet">#</a>
               </h3>
               
               <p>computeUnionTypeSet may be called with check == nil.
The result is &invalidTypeSet if the union overflows.</p>
               
               <pre><code class="language-go">func computeUnionTypeSet(check *Checker, unionSets map[*Union]*_TypeSet, pos syntax.Pos, utyp *Union) *_TypeSet</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="concat" data-name="concat">
               <h3>
                  concat 
                  <span class="badge">function</span>
                  
                  <a href="#concat" class="anchor" title="Link to concat">#</a>
               </h3>
               
               <p>concat returns the result of concatenating list and i.
The result does not share its underlying array with list.</p>
               
               <pre><code class="language-go">func concat(list []int, i int) []int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="consolidateMultiples" data-name="consolidateMultiples">
               <h3>
                  consolidateMultiples 
                  <span class="badge">function</span>
                  
                  <a href="#consolidateMultiples" class="anchor" title="Link to consolidateMultiples">#</a>
               </h3>
               
               <p>consolidateMultiples collects multiple list entries with the same type
into a single entry marked as containing multiples. The result is the
consolidated list.</p>
               
               <pre><code class="language-go">func consolidateMultiples(list []embeddedType) []embeddedType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constDecl" data-name="constDecl">
               <h3>
                  constDecl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constDecl" class="anchor" title="Link to constDecl">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) constDecl(obj *Const, typ syntax.Expr, init syntax.Expr, inherited bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="context" data-name="context">
               <h3>
                  context 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#context" class="anchor" title="Link to context">#</a>
               </h3>
               
               <p>context returns the type-checker context.</p>
               
               <pre><code class="language-go">func (check *Checker) context() *Context</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="conversion" data-name="conversion">
               <h3>
                  conversion 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#conversion" class="anchor" title="Link to conversion">#</a>
               </h3>
               
               <p>conversion type-checks the conversion T(x).
The result is in x.</p>
               
               <pre><code class="language-go">func (check *Checker) conversion(x *operand, T Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convertUntyped" data-name="convertUntyped">
               <h3>
                  convertUntyped 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#convertUntyped" class="anchor" title="Link to convertUntyped">#</a>
               </h3>
               
               <p>convertUntyped attempts to set the type of an untyped value to the target type.</p>
               
               <pre><code class="language-go">func (check *Checker) convertUntyped(x *operand, target Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convertibleTo" data-name="convertibleTo">
               <h3>
                  convertibleTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#convertibleTo" class="anchor" title="Link to convertibleTo">#</a>
               </h3>
               
               <p>convertibleTo reports whether T(x) is valid. In the failure case, *cause
may be set to the cause for the failure.
The check parameter may be nil if convertibleTo is invoked through an
exported API call, i.e., when all methods have been type-checked.</p>
               
               <pre><code class="language-go">func (x *operand) convertibleTo(check *Checker, T Type, cause *string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="coreString" data-name="coreString">
               <h3>
                  coreString 
                  <span class="badge">function</span>
                  
                  <a href="#coreString" class="anchor" title="Link to coreString">#</a>
               </h3>
               
               <p>coreString is like coreType but also considers []byte
and strings as identical. In this case, if successful and we saw
a string, the result is of type (possibly untyped) string.</p>
               
               <pre><code class="language-go">func coreString(t Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="coreTerm" data-name="coreTerm">
               <h3>
                  coreTerm 
                  <span class="badge">function</span>
                  
                  <a href="#coreTerm" class="anchor" title="Link to coreTerm">#</a>
               </h3>
               
               <p>If the type parameter has a single specific type S, coreTerm returns (S, true).
Otherwise, if tpar has a core type T, it returns a term corresponding to that
core type and false. In that case, if any term of tpar has a tilde, the core
term has a tilde. In all other cases coreTerm returns (nil, false).</p>
               
               <pre><code class="language-go">func coreTerm(tpar *TypeParam) (*term, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="coreType" data-name="coreType">
               <h3>
                  coreType 
                  <span class="badge">function</span>
                  
                  <a href="#coreType" class="anchor" title="Link to coreType">#</a>
               </h3>
               
               <p>If t is not a type parameter, coreType returns the underlying type.
If t is a type parameter, coreType returns the single underlying
type of all types in its type set if it exists, or nil otherwise. If the
type set contains only unrestricted and restricted channel types (with
identical element types), the single underlying type is the restricted
channel type if the restrictions are always the same, or nil otherwise.</p>
               
               <pre><code class="language-go">func coreType(t Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cost" data-name="cost">
               <h3>
                  cost 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cost" class="anchor" title="Link to cost">#</a>
               </h3>
               
               <p>cost returns the cost of removing this node, which involves copying each
predecessor to each successor (and vice-versa).</p>
               
               <pre><code class="language-go">func (n *graphNode) cost() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cycleError" data-name="cycleError">
               <h3>
                  cycleError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cycleError" class="anchor" title="Link to cycleError">#</a>
               </h3>
               
               <p>cycleError reports a declaration cycle starting with the object at cycle[start].</p>
               
               <pre><code class="language-go">func (check *Checker) cycleError(cycle []Object, start int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dddErrPos" data-name="dddErrPos">
               <h3>
                  dddErrPos 
                  <span class="badge">function</span>
                  
                  <a href="#dddErrPos" class="anchor" title="Link to dddErrPos">#</a>
               </h3>
               
               <p>dddErrPos returns the node (poser) for reporting an invalid ... use in a call.</p>
               
               <pre><code class="language-go">func dddErrPos(call *syntax.CallExpr) *syntax.CallExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="declStmt" data-name="declStmt">
               <h3>
                  declStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#declStmt" class="anchor" title="Link to declStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) declStmt(list []syntax.Decl)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="declare" data-name="declare">
               <h3>
                  declare 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#declare" class="anchor" title="Link to declare">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) declare(scope *Scope, id *syntax.Name, obj Object, pos syntax.Pos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="declareInSet" data-name="declareInSet">
               <h3>
                  declareInSet 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#declareInSet" class="anchor" title="Link to declareInSet">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) declareInSet(oset *objset, pos syntax.Pos, obj Object) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="declareParams" data-name="declareParams">
               <h3>
                  declareParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#declareParams" class="anchor" title="Link to declareParams">#</a>
               </h3>
               
               <p>declareParams declares each named parameter in the current scope.</p>
               
               <pre><code class="language-go">func (check *Checker) declareParams(names []*syntax.Name, params []*Var, scopePos syntax.Pos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="declarePkgObj" data-name="declarePkgObj">
               <h3>
                  declarePkgObj 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#declarePkgObj" class="anchor" title="Link to declarePkgObj">#</a>
               </h3>
               
               <p>declarePkgObj declares obj in the package scope, records its ident -> obj mapping,
and updates check.objMap. The object must not be a function or method.</p>
               
               <pre><code class="language-go">func (check *Checker) declarePkgObj(ident *syntax.Name, obj Object, d *declInfo)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="declareTypeParam" data-name="declareTypeParam">
               <h3>
                  declareTypeParam 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#declareTypeParam" class="anchor" title="Link to declareTypeParam">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) declareTypeParam(name *syntax.Name, scopePos syntax.Pos) *TypeParam</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="def" data-name="def">
               <h3>
                  def 
                  <span class="badge">function</span>
                  
                  <a href="#def" class="anchor" title="Link to def">#</a>
               </h3>
               
               <p>Objects with names containing blanks are internal and not entered into
a scope. Objects with exported names are inserted in the unsafe package
scope; other objects are inserted in the universe scope.</p>
               
               <pre><code class="language-go">func def(obj Object)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defPredeclaredConsts" data-name="defPredeclaredConsts">
               <h3>
                  defPredeclaredConsts 
                  <span class="badge">function</span>
                  
                  <a href="#defPredeclaredConsts" class="anchor" title="Link to defPredeclaredConsts">#</a>
               </h3>
               
               <pre><code class="language-go">func defPredeclaredConsts()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defPredeclaredFuncs" data-name="defPredeclaredFuncs">
               <h3>
                  defPredeclaredFuncs 
                  <span class="badge">function</span>
                  
                  <a href="#defPredeclaredFuncs" class="anchor" title="Link to defPredeclaredFuncs">#</a>
               </h3>
               
               <pre><code class="language-go">func defPredeclaredFuncs()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defPredeclaredNil" data-name="defPredeclaredNil">
               <h3>
                  defPredeclaredNil 
                  <span class="badge">function</span>
                  
                  <a href="#defPredeclaredNil" class="anchor" title="Link to defPredeclaredNil">#</a>
               </h3>
               
               <pre><code class="language-go">func defPredeclaredNil()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defPredeclaredTypes" data-name="defPredeclaredTypes">
               <h3>
                  defPredeclaredTypes 
                  <span class="badge">function</span>
                  
                  <a href="#defPredeclaredTypes" class="anchor" title="Link to defPredeclaredTypes">#</a>
               </h3>
               
               <pre><code class="language-go">func defPredeclaredTypes()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="definedType" data-name="definedType">
               <h3>
                  definedType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#definedType" class="anchor" title="Link to definedType">#</a>
               </h3>
               
               <p>definedType is like typ but also accepts a type name def.
If def != nil, e is the type specification for the type named def, declared
in a type declaration, and def.typ.underlying will be set to the type of e
before any components of e are type-checked.</p>
               
               <pre><code class="language-go">func (check *Checker) definedType(e syntax.Expr, def *TypeName) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dependencyGraph" data-name="dependencyGraph">
               <h3>
                  dependencyGraph 
                  <span class="badge">function</span>
                  
                  <a href="#dependencyGraph" class="anchor" title="Link to dependencyGraph">#</a>
               </h3>
               
               <p>dependencyGraph computes the object dependency graph from the given objMap,
with any function nodes removed. The resulting graph contains only constants
and variables.</p>
               
               <pre><code class="language-go">func dependencyGraph(objMap map[Object]*declInfo) []*graphNode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="deref" data-name="deref">
               <h3>
                  deref 
                  <span class="badge">function</span>
                  
                  <a href="#deref" class="anchor" title="Link to deref">#</a>
               </h3>
               
               <p>deref dereferences typ if it is a *Pointer (but not a *Named type
with an underlying pointer type!) and returns its base and true.
Otherwise it returns (typ, false).</p>
               
               <pre><code class="language-go">func deref(typ Type) (Type, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="derefStructPtr" data-name="derefStructPtr">
               <h3>
                  derefStructPtr 
                  <span class="badge">function</span>
                  
                  <a href="#derefStructPtr" class="anchor" title="Link to derefStructPtr">#</a>
               </h3>
               
               <p>derefStructPtr dereferences typ if it is a (named or unnamed) pointer to a
(named or unnamed) struct and returns its base. Otherwise it returns typ.</p>
               
               <pre><code class="language-go">func derefStructPtr(typ Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="describef" data-name="describef">
               <h3>
                  describef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#describef" class="anchor" title="Link to describef">#</a>
               </h3>
               
               <p>If debug is set, describef sets a printf-formatted description for action a.
Otherwise, it is a no-op.</p>
               
               <pre><code class="language-go">func (a *action) describef(pos poser, format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dir" data-name="dir">
               <h3>
                  dir 
                  <span class="badge">function</span>
                  
                  <a href="#dir" class="anchor" title="Link to dir">#</a>
               </h3>
               
               <p>dir makes a good-faith attempt to return the directory
portion of path. If path is empty, the result is ".".
(Per the go/build package dependency tests, we cannot import
path/filepath and simply use filepath.Dir.)</p>
               
               <pre><code class="language-go">func dir(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="disjoint" data-name="disjoint">
               <h3>
                  disjoint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#disjoint" class="anchor" title="Link to disjoint">#</a>
               </h3>
               
               <p>disjoint reports whether x ∩ y == ∅.
x.typ and y.typ must not be nil.</p>
               
               <pre><code class="language-go">func (x *term) disjoint(y *term) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dump" data-name="dump">
               <h3>
                  dump 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dump" class="anchor" title="Link to dump">#</a>
               </h3>
               
               <p>dump is only needed for debugging</p>
               
               <pre><code class="language-go">func (check *Checker) dump(format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="embeddedFieldIdent" data-name="embeddedFieldIdent">
               <h3>
                  embeddedFieldIdent 
                  <span class="badge">function</span>
                  
                  <a href="#embeddedFieldIdent" class="anchor" title="Link to embeddedFieldIdent">#</a>
               </h3>
               
               <pre><code class="language-go">func embeddedFieldIdent(e syntax.Expr) *syntax.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="empty" data-name="empty">
               <h3>
                  empty 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#empty" class="anchor" title="Link to empty">#</a>
               </h3>
               
               <pre><code class="language-go">func (err *error_) empty() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="empty" data-name="empty">
               <h3>
                  empty 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#empty" class="anchor" title="Link to empty">#</a>
               </h3>
               
               <pre><code class="language-go">func (m substMap) empty() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="enclosingTarget" data-name="enclosingTarget">
               <h3>
                  enclosingTarget 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#enclosingTarget" class="anchor" title="Link to enclosingTarget">#</a>
               </h3>
               
               <p>enclosingTarget returns the innermost enclosing labeled
statement with the given label name, or nil.</p>
               
               <pre><code class="language-go">func (b *block) enclosingTarget(name string) *syntax.LabeledStmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="endPos" data-name="endPos">
               <h3>
                  endPos 
                  <span class="badge">function</span>
                  
                  <a href="#endPos" class="anchor" title="Link to endPos">#</a>
               </h3>
               
               <p>endPos returns the position of the first character immediately after node n.</p>
               
               <pre><code class="language-go">func endPos(n syntax.Node) syntax.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="equal" data-name="equal">
               <h3>
                  equal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#equal" class="anchor" title="Link to equal">#</a>
               </h3>
               
               <p>equal reports whether x and y represent the same type set.</p>
               
               <pre><code class="language-go">func (x *term) equal(y *term) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="equal" data-name="equal">
               <h3>
                  equal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#equal" class="anchor" title="Link to equal">#</a>
               </h3>
               
               <p>equal reports whether xl and yl represent the same type set.</p>
               
               <pre><code class="language-go">func (xl termlist) equal(yl termlist) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="error" data-name="error">
               <h3>
                  error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#error" class="anchor" title="Link to error">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *typeWriter) error(msg string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="error" data-name="error">
               <h3>
                  error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#error" class="anchor" title="Link to error">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) error(at poser, code Code, msg string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errorUnusedPkg" data-name="errorUnusedPkg">
               <h3>
                  errorUnusedPkg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#errorUnusedPkg" class="anchor" title="Link to errorUnusedPkg">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) errorUnusedPkg(obj *PkgName)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errorf" data-name="errorf">
               <h3>
                  errorf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#errorf" class="anchor" title="Link to errorf">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) errorf(at poser, code Code, format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exclude" data-name="exclude">
               <h3>
                  exclude 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exclude" class="anchor" title="Link to exclude">#</a>
               </h3>
               
               <p>exclude reports an error if x.mode is in modeset and sets x.mode to invalid.
The modeset may contain any of 1<<novalue, 1<<builtin, 1<<typexpr.</p>
               
               <pre><code class="language-go">func (check *Checker) exclude(x *operand, modeset uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expandMethod" data-name="expandMethod">
               <h3>
                  expandMethod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expandMethod" class="anchor" title="Link to expandMethod">#</a>
               </h3>
               
               <p>expandMethod substitutes type arguments in the i'th method for an
instantiated receiver.</p>
               
               <pre><code class="language-go">func (t *Named) expandMethod(i int) *Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expandUnderlying" data-name="expandUnderlying">
               <h3>
                  expandUnderlying 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expandUnderlying" class="anchor" title="Link to expandUnderlying">#</a>
               </h3>
               
               <p>expandUnderlying substitutes type arguments in the underlying type n.orig,
returning the result. Returns Typ[Invalid] if there was an error.</p>
               
               <pre><code class="language-go">func (n *Named) expandUnderlying() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expr" data-name="expr">
               <h3>
                  expr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expr" class="anchor" title="Link to expr">#</a>
               </h3>
               
               <p>expr typechecks expression e and initializes x with the expression value.
If a non-nil target T is given and e is a generic function or
a function call, T is used to infer the type arguments for e.
The result must be a single value.
If an error occurred, x.mode is set to invalid.</p>
               
               <pre><code class="language-go">func (check *Checker) expr(T *target, x *operand, e syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprInternal" data-name="exprInternal">
               <h3>
                  exprInternal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprInternal" class="anchor" title="Link to exprInternal">#</a>
               </h3>
               
               <p>exprInternal contains the core of type checking of expressions.
Must only be called by rawExpr.
(See rawExpr for an explanation of the parameters.)</p>
               
               <pre><code class="language-go">func (check *Checker) exprInternal(T *target, x *operand, e syntax.Expr, hint Type) exprKind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprList" data-name="exprList">
               <h3>
                  exprList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprList" class="anchor" title="Link to exprList">#</a>
               </h3>
               
               <p>exprList evaluates a list of expressions and returns the corresponding operands.
A single-element expression list may evaluate to multiple operands.</p>
               
               <pre><code class="language-go">func (check *Checker) exprList(elist []syntax.Expr) (xlist []*operand)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprOrType" data-name="exprOrType">
               <h3>
                  exprOrType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprOrType" class="anchor" title="Link to exprOrType">#</a>
               </h3>
               
               <p>exprOrType typechecks expression or type e and initializes x with the expression value or type.
If allowGeneric is set, the operand type may be an uninstantiated parameterized type or function
value.
If an error occurred, x.mode is set to invalid.</p>
               
               <pre><code class="language-go">func (check *Checker) exprOrType(x *operand, e syntax.Expr, allowGeneric bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprWithHint" data-name="exprWithHint">
               <h3>
                  exprWithHint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprWithHint" class="anchor" title="Link to exprWithHint">#</a>
               </h3>
               
               <p>exprWithHint typechecks expression e and initializes x with the expression value;
hint is the type of a composite literal element.
If an error occurred, x.mode is set to invalid.</p>
               
               <pre><code class="language-go">func (check *Checker) exprWithHint(x *operand, e syntax.Expr, hint Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fieldIndex" data-name="fieldIndex">
               <h3>
                  fieldIndex 
                  <span class="badge">function</span>
                  
                  <a href="#fieldIndex" class="anchor" title="Link to fieldIndex">#</a>
               </h3>
               
               <p>fieldIndex returns the index for the field with matching package and name, or a value < 0.
See Object.sameId for the meaning of foldCase.</p>
               
               <pre><code class="language-go">func fieldIndex(fields []*Var, pkg *Package, name string, foldCase bool) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="filename" data-name="filename">
               <h3>
                  filename 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#filename" class="anchor" title="Link to filename">#</a>
               </h3>
               
               <p>filename returns a filename suitable for debugging output.</p>
               
               <pre><code class="language-go">func (check *Checker) filename(fileNo int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findPath" data-name="findPath">
               <h3>
                  findPath 
                  <span class="badge">function</span>
                  
                  <a href="#findPath" class="anchor" title="Link to findPath">#</a>
               </h3>
               
               <p>findPath returns the (reversed) list of objects []Object{to, ... from}
such that there is a path of object dependencies from 'from' to 'to'.
If there is no such path, the result is nil.</p>
               
               <pre><code class="language-go">func findPath(objMap map[Object]*declInfo, from Object, to Object, seen map[Object]bool) []Object</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="firstInSrc" data-name="firstInSrc">
               <h3>
                  firstInSrc 
                  <span class="badge">function</span>
                  
                  <a href="#firstInSrc" class="anchor" title="Link to firstInSrc">#</a>
               </h3>
               
               <p>firstInSrc reports the index of the object with the "smallest"
source position in path. path must not be empty.</p>
               
               <pre><code class="language-go">func firstInSrc(path []Object) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fitsFloat32" data-name="fitsFloat32">
               <h3>
                  fitsFloat32 
                  <span class="badge">function</span>
                  
                  <a href="#fitsFloat32" class="anchor" title="Link to fitsFloat32">#</a>
               </h3>
               
               <pre><code class="language-go">func fitsFloat32(x constant.Value) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fitsFloat64" data-name="fitsFloat64">
               <h3>
                  fitsFloat64 
                  <span class="badge">function</span>
                  
                  <a href="#fitsFloat64" class="anchor" title="Link to fitsFloat64">#</a>
               </h3>
               
               <pre><code class="language-go">func fitsFloat64(x constant.Value) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flattenUnion" data-name="flattenUnion">
               <h3>
                  flattenUnion 
                  <span class="badge">function</span>
                  
                  <a href="#flattenUnion" class="anchor" title="Link to flattenUnion">#</a>
               </h3>
               
               <p>flattenUnion walks a union type expression of the form A | B | C | ...,
extracting both the binary exprs (blist) and leaf types (tlist).</p>
               
               <pre><code class="language-go">func flattenUnion(list []syntax.Expr, x syntax.Expr) (blist []syntax.Expr, tlist []syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcBody" data-name="funcBody">
               <h3>
                  funcBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcBody" class="anchor" title="Link to funcBody">#</a>
               </h3>
               
               <p>decl may be nil</p>
               
               <pre><code class="language-go">func (check *Checker) funcBody(decl *declInfo, name string, sig *Signature, body *syntax.BlockStmt, iota constant.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcDecl" data-name="funcDecl">
               <h3>
                  funcDecl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcDecl" class="anchor" title="Link to funcDecl">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) funcDecl(obj *Func, decl *declInfo)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcInst" data-name="funcInst">
               <h3>
                  funcInst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcInst" class="anchor" title="Link to funcInst">#</a>
               </h3>
               
               <p>funcInst type-checks a function instantiation.
The incoming x must be a generic function.
If inst != nil, it provides some or all of the type arguments (inst.Index).
If target != nil, it may be used to infer missing type arguments of x, if any.
At least one of T or inst must be provided.
There are two modes of operation:
1. If infer == true, funcInst infers missing type arguments as needed and
instantiates the function x. The returned results are nil.
2. If infer == false and inst provides all type arguments, funcInst
instantiates the function x. The returned results are nil.
If inst doesn't provide enough type arguments, funcInst returns the
available arguments and the corresponding expression list; x remains
unchanged.
If an error (other than a version error) occurs in any case, it is reported
and x.mode is set to invalid.</p>
               
               <pre><code class="language-go">func (check *Checker) funcInst(T *target, pos syntax.Pos, x *operand, inst *syntax.IndexExpr, infer bool) ([]Type, []syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcLit" data-name="funcLit">
               <h3>
                  funcLit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcLit" class="anchor" title="Link to funcLit">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) funcLit(x *operand, e *syntax.FuncLit)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcString" data-name="funcString">
               <h3>
                  funcString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcString" class="anchor" title="Link to funcString">#</a>
               </h3>
               
               <p>funcString returns a string of the form name + signature for f.
check may be nil.</p>
               
               <pre><code class="language-go">func (check *Checker) funcString(f *Func, pkgInfo bool) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcType" data-name="funcType">
               <h3>
                  funcType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcType" class="anchor" title="Link to funcType">#</a>
               </h3>
               
               <p>funcType type-checks a function or method type.</p>
               
               <pre><code class="language-go">func (check *Checker) funcType(sig *Signature, recvPar *syntax.Field, tparams []*syntax.Field, ftyp *syntax.FuncType)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="func_" data-name="func_">
               <h3>
                  func_ 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#func_" class="anchor" title="Link to func_">#</a>
               </h3>
               
               <pre><code class="language-go">func (subst *subster) func_(f *Func) *Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gcSizesFor" data-name="gcSizesFor">
               <h3>
                  gcSizesFor 
                  <span class="badge">function</span>
                  
                  <a href="#gcSizesFor" class="anchor" title="Link to gcSizesFor">#</a>
               </h3>
               
               <p>gcSizesFor returns the Sizes used by gc for an architecture.
The result is a nil *gcSizes pointer (which is not a valid types.Sizes)
if a compiler/architecture pair is not known.</p>
               
               <pre><code class="language-go">func gcSizesFor(compiler string, arch string) *gcSizes</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="genericExpr" data-name="genericExpr">
               <h3>
                  genericExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#genericExpr" class="anchor" title="Link to genericExpr">#</a>
               </h3>
               
               <p>genericExpr is like expr but the result may also be generic.</p>
               
               <pre><code class="language-go">func (check *Checker) genericExpr(x *operand, e syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="genericExprList" data-name="genericExprList">
               <h3>
                  genericExprList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#genericExprList" class="anchor" title="Link to genericExprList">#</a>
               </h3>
               
               <p>genericExprList is like exprList but result operands may be uninstantiated or partially
instantiated generic functions (where constraint information is insufficient to infer
the missing type arguments) for Go 1.21 and later.
For each non-generic or uninstantiated generic operand, the corresponding targsList and
xlistList elements do not exist (targsList and xlistList are nil) or the elements are nil.
For each partially instantiated generic function operand, the corresponding targsList and
xlistList elements are the operand's partial type arguments and type expression lists.</p>
               
               <pre><code class="language-go">func (check *Checker) genericExprList(elist []syntax.Expr) (resList []*operand, targsList [][]Type, xlistList [][]syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="genericType" data-name="genericType">
               <h3>
                  genericType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#genericType" class="anchor" title="Link to genericType">#</a>
               </h3>
               
               <p>genericType is like typ but the type must be an (uninstantiated) generic
type. If cause is non-nil and the type expression was a valid type but not
generic, cause will be populated with a message describing the error.
Note: If the type expression was invalid and an error was reported before,
cause will not be populated; thus cause alone cannot be used to determine
if an error occurred.</p>
               
               <pre><code class="language-go">func (check *Checker) genericType(e syntax.Expr, cause *string) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getID" data-name="getID">
               <h3>
                  getID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getID" class="anchor" title="Link to getID">#</a>
               </h3>
               
               <p>getID returns a unique ID for the type t.</p>
               
               <pre><code class="language-go">func (ctxt *Context) getID(t Type) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goTypeName" data-name="goTypeName">
               <h3>
                  goTypeName 
                  <span class="badge">function</span>
                  
                  <a href="#goTypeName" class="anchor" title="Link to goTypeName">#</a>
               </h3>
               
               <p>goTypeName returns the Go type name for typ and
removes any occurrences of "types2." from that name.</p>
               
               <pre><code class="language-go">func goTypeName(typ Type) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goVal" data-name="goVal">
               <h3>
                  goVal 
                  <span class="badge">function</span>
                  
                  <a href="#goVal" class="anchor" title="Link to goVal">#</a>
               </h3>
               
               <p>goVal returns the Go value for val, or nil.</p>
               
               <pre><code class="language-go">func goVal(val constant.Value) interface{}</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gotoTarget" data-name="gotoTarget">
               <h3>
                  gotoTarget 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gotoTarget" class="anchor" title="Link to gotoTarget">#</a>
               </h3>
               
               <p>gotoTarget returns the labeled statement in the current
or an enclosing block with the given label name, or nil.</p>
               
               <pre><code class="language-go">func (b *block) gotoTarget(name string) *syntax.LabeledStmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handleBailout" data-name="handleBailout">
               <h3>
                  handleBailout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handleBailout" class="anchor" title="Link to handleBailout">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) handleBailout(err *error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handleError" data-name="handleError">
               <h3>
                  handleError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handleError" class="anchor" title="Link to handleError">#</a>
               </h3>
               
               <p>handleError should only be called by error_.report.</p>
               
               <pre><code class="language-go">func (check *Checker) handleError(index int, pos syntax.Pos, code Code, msg string, soft bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasAllMethods" data-name="hasAllMethods">
               <h3>
                  hasAllMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasAllMethods" class="anchor" title="Link to hasAllMethods">#</a>
               </h3>
               
               <p>hasAllMethods is similar to checkMissingMethod but instead reports whether all methods are present.
If V is not a valid type, or if it is a struct containing embedded fields with invalid types, the
result is true because it is not possible to say with certainty whether a method is missing or not
(an embedded field may have the method in question).
If the result is false and cause is not nil, *cause describes the error.
Use hasAllMethods to avoid follow-on errors due to incorrect types.</p>
               
               <pre><code class="language-go">func (check *Checker) hasAllMethods(V Type, T Type, static bool, equivalent func(x Type, y Type) bool, cause *string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasBreak" data-name="hasBreak">
               <h3>
                  hasBreak 
                  <span class="badge">function</span>
                  
                  <a href="#hasBreak" class="anchor" title="Link to hasBreak">#</a>
               </h3>
               
               <p>hasBreak reports if s is or contains a break statement
referring to the label-ed statement or implicit-ly the
closest outer breakable statement.</p>
               
               <pre><code class="language-go">func hasBreak(s syntax.Stmt, label string, implicit bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasBreakCaseList" data-name="hasBreakCaseList">
               <h3>
                  hasBreakCaseList 
                  <span class="badge">function</span>
                  
                  <a href="#hasBreakCaseList" class="anchor" title="Link to hasBreakCaseList">#</a>
               </h3>
               
               <pre><code class="language-go">func hasBreakCaseList(list []*syntax.CaseClause, label string, implicit bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasBreakCommList" data-name="hasBreakCommList">
               <h3>
                  hasBreakCommList 
                  <span class="badge">function</span>
                  
                  <a href="#hasBreakCommList" class="anchor" title="Link to hasBreakCommList">#</a>
               </h3>
               
               <pre><code class="language-go">func hasBreakCommList(list []*syntax.CommClause, label string, implicit bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasBreakList" data-name="hasBreakList">
               <h3>
                  hasBreakList 
                  <span class="badge">function</span>
                  
                  <a href="#hasBreakList" class="anchor" title="Link to hasBreakList">#</a>
               </h3>
               
               <pre><code class="language-go">func hasBreakList(list []syntax.Stmt, label string, implicit bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasDots" data-name="hasDots">
               <h3>
                  hasDots 
                  <span class="badge">function</span>
                  
                  <a href="#hasDots" class="anchor" title="Link to hasDots">#</a>
               </h3>
               
               <p>hasDots reports whether the last argument in the call is followed by ...</p>
               
               <pre><code class="language-go">func hasDots(call *syntax.CallExpr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasEmptyTypeset" data-name="hasEmptyTypeset">
               <h3>
                  hasEmptyTypeset 
                  <span class="badge">function</span>
                  
                  <a href="#hasEmptyTypeset" class="anchor" title="Link to hasEmptyTypeset">#</a>
               </h3>
               
               <p>hasEmptyTypeset reports whether t is a type parameter with an empty type set.
The function does not force the computation of the type set and so is safe to
use anywhere, but it may report a false negative if the type set has not been
computed yet.</p>
               
               <pre><code class="language-go">func hasEmptyTypeset(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasInitializer" data-name="hasInitializer">
               <h3>
                  hasInitializer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasInitializer" class="anchor" title="Link to hasInitializer">#</a>
               </h3>
               
               <p>hasInitializer reports whether the declared object has an initialization
expression or function body.</p>
               
               <pre><code class="language-go">func (d *declInfo) hasInitializer() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasInvalidEmbeddedFields" data-name="hasInvalidEmbeddedFields">
               <h3>
                  hasInvalidEmbeddedFields 
                  <span class="badge">function</span>
                  
                  <a href="#hasInvalidEmbeddedFields" class="anchor" title="Link to hasInvalidEmbeddedFields">#</a>
               </h3>
               
               <p>hasInvalidEmbeddedFields reports whether T is a struct (or a pointer to a struct) that contains
(directly or indirectly) embedded fields with invalid types.</p>
               
               <pre><code class="language-go">func hasInvalidEmbeddedFields(T Type, seen map[*Struct]bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasName" data-name="hasName">
               <h3>
                  hasName 
                  <span class="badge">function</span>
                  
                  <a href="#hasName" class="anchor" title="Link to hasName">#</a>
               </h3>
               
               <p>hasName reports whether t has a name. This includes
predeclared types, defined types, and type parameters.
hasName may be called with types that are not fully set up.</p>
               
               <pre><code class="language-go">func hasName(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasNil" data-name="hasNil">
               <h3>
                  hasNil 
                  <span class="badge">function</span>
                  
                  <a href="#hasNil" class="anchor" title="Link to hasNil">#</a>
               </h3>
               
               <p>hasNil reports whether type t includes the nil value.</p>
               
               <pre><code class="language-go">func hasNil(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasPtrRecv" data-name="hasPtrRecv">
               <h3>
                  hasPtrRecv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasPtrRecv" class="anchor" title="Link to hasPtrRecv">#</a>
               </h3>
               
               <p>hasPtrRecv reports whether the receiver is of the form *T for the given method obj.</p>
               
               <pre><code class="language-go">func (obj *Func) hasPtrRecv() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasTerms" data-name="hasTerms">
               <h3>
                  hasTerms 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasTerms" class="anchor" title="Link to hasTerms">#</a>
               </h3>
               
               <p>hasTerms reports whether s has specific type terms.</p>
               
               <pre><code class="language-go">func (s *_TypeSet) hasTerms() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasVarSize" data-name="hasVarSize">
               <h3>
                  hasVarSize 
                  <span class="badge">function</span>
                  
                  <a href="#hasVarSize" class="anchor" title="Link to hasVarSize">#</a>
               </h3>
               
               <p>hasVarSize reports if the size of type t is variable due to type parameters
or if the type is infinitely-sized due to a cycle for which the type has not
yet been checked.</p>
               
               <pre><code class="language-go">func hasVarSize(t Type, seen map[*Named]bool) (varSized bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ident" data-name="ident">
               <h3>
                  ident 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ident" class="anchor" title="Link to ident">#</a>
               </h3>
               
               <p>ident type-checks identifier e and initializes x with the value or type of e.
If an error occurred, x.mode is set to invalid.
For the meaning of def, see Checker.definedType, below.
If wantType is set, the identifier e is expected to denote a type.</p>
               
               <pre><code class="language-go">func (check *Checker) ident(x *operand, e *syntax.Name, def *TypeName, wantType bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="identical" data-name="identical">
               <h3>
                  identical 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#identical" class="anchor" title="Link to identical">#</a>
               </h3>
               
               <p>For changes to this code the corresponding changes should be made to unifier.nify.</p>
               
               <pre><code class="language-go">func (c *comparer) identical(x Type, y Type, p *ifacePair) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="identical" data-name="identical">
               <h3>
                  identical 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#identical" class="anchor" title="Link to identical">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *ifacePair) identical(q *ifacePair) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="identicalInstance" data-name="identicalInstance">
               <h3>
                  identicalInstance 
                  <span class="badge">function</span>
                  
                  <a href="#identicalInstance" class="anchor" title="Link to identicalInstance">#</a>
               </h3>
               
               <p>identicalInstance reports if two type instantiations are identical.
Instantiations are identical if their origin and type arguments are
identical.</p>
               
               <pre><code class="language-go">func identicalInstance(xorig Type, xargs []Type, yorig Type, yargs []Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="identicalOrigin" data-name="identicalOrigin">
               <h3>
                  identicalOrigin 
                  <span class="badge">function</span>
                  
                  <a href="#identicalOrigin" class="anchor" title="Link to identicalOrigin">#</a>
               </h3>
               
               <p>identicalOrigin reports whether x and y originated in the same declaration.</p>
               
               <pre><code class="language-go">func identicalOrigin(x *Named, y *Named) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="iface" data-name="iface">
               <h3>
                  iface 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#iface" class="anchor" title="Link to iface">#</a>
               </h3>
               
               <p>iface returns the constraint interface of t.</p>
               
               <pre><code class="language-go">func (t *TypeParam) iface() *Interface</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="implements" data-name="implements">
               <h3>
                  implements 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#implements" class="anchor" title="Link to implements">#</a>
               </h3>
               
               <p>implements checks if V implements T. The receiver may be nil if implements
is called through an exported API call such as AssignableTo. If constraint
is set, T is a type constraint.
If the provided cause is non-nil, it may be set to an error string
explaining why V does not implement (or satisfy, for constraints) T.</p>
               
               <pre><code class="language-go">func (check *Checker) implements(V Type, T Type, constraint bool, cause *string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="implicitTypeAndValue" data-name="implicitTypeAndValue">
               <h3>
                  implicitTypeAndValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#implicitTypeAndValue" class="anchor" title="Link to implicitTypeAndValue">#</a>
               </h3>
               
               <p>implicitTypeAndValue returns the implicit type of x when used in a context
where the target type is expected. If no such implicit conversion is
possible, it returns a nil Type and non-zero error code.
If x is a constant operand, the returned constant.Value will be the
representation of x in this context.</p>
               
               <pre><code class="language-go">func (check *Checker) implicitTypeAndValue(x *operand, target Type) (Type, constant.Value, Code)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="importPackage" data-name="importPackage">
               <h3>
                  importPackage 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#importPackage" class="anchor" title="Link to importPackage">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) importPackage(pos syntax.Pos, path string, dir string) *Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inNode" data-name="inNode">
               <h3>
                  inNode 
                  <span class="badge">function</span>
                  
                  <a href="#inNode" class="anchor" title="Link to inNode">#</a>
               </h3>
               
               <p>inNode is a dummy function returning pos.</p>
               
               <pre><code class="language-go">func inNode(_ syntax.Node, pos syntax.Pos) syntax.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="includes" data-name="includes">
               <h3>
                  includes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#includes" class="anchor" title="Link to includes">#</a>
               </h3>
               
               <p>includes reports whether t ∈ xl.</p>
               
               <pre><code class="language-go">func (xl termlist) includes(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="includes" data-name="includes">
               <h3>
                  includes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#includes" class="anchor" title="Link to includes">#</a>
               </h3>
               
               <p>includes reports whether t ∈ x.</p>
               
               <pre><code class="language-go">func (x *term) includes(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="incomparableCause" data-name="incomparableCause">
               <h3>
                  incomparableCause 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#incomparableCause" class="anchor" title="Link to incomparableCause">#</a>
               </h3>
               
               <p>incomparableCause returns a more specific cause why typ is not comparable.
If there is no more specific cause, the result is "".</p>
               
               <pre><code class="language-go">func (check *Checker) incomparableCause(typ Type) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="index" data-name="index">
               <h3>
                  index 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#index" class="anchor" title="Link to index">#</a>
               </h3>
               
               <p>index checks an index expression for validity.
If max >= 0, it is the upper bound for index.
If the result typ is != Typ[Invalid], index is valid and typ is its (possibly named) integer type.
If the result val >= 0, index is valid and val is its constant int value.</p>
               
               <pre><code class="language-go">func (check *Checker) index(index syntax.Expr, max int64) (typ Type, val int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indexExpr" data-name="indexExpr">
               <h3>
                  indexExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#indexExpr" class="anchor" title="Link to indexExpr">#</a>
               </h3>
               
               <p>If e is a valid function instantiation, indexExpr returns true.
In that case x represents the uninstantiated function value and
it is the caller's responsibility to instantiate the function.</p>
               
               <pre><code class="language-go">func (check *Checker) indexExpr(x *operand, e *syntax.IndexExpr) (isFuncInst bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indexedElts" data-name="indexedElts">
               <h3>
                  indexedElts 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#indexedElts" class="anchor" title="Link to indexedElts">#</a>
               </h3>
               
               <p>indexedElts checks the elements (elts) of an array or slice composite literal
against the literal's element type (typ), and the element indices against
the literal length if known (length >= 0). It returns the length of the
literal (maximum index value + 1).</p>
               
               <pre><code class="language-go">func (check *Checker) indexedElts(elts []syntax.Expr, typ Type, length int64) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="infer" data-name="infer">
               <h3>
                  infer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#infer" class="anchor" title="Link to infer">#</a>
               </h3>
               
               <p>infer attempts to infer the complete set of type arguments for generic function instantiation/call
based on the given type parameters tparams, type arguments targs, function parameters params, and
function arguments args, if any. There must be at least one type parameter, no more type arguments
than type parameters, and params and args must match in number (incl. zero).
If reverse is set, an error message's contents are reversed for a better error message for some
errors related to reverse type inference (where the function call is synthetic).
If successful, infer returns the complete list of given and inferred type arguments, one for each
type parameter. Otherwise the result is nil. Errors are reported through the err parameter.
Note: infer may fail (return nil) due to invalid args operands without reporting additional errors.</p>
               
               <pre><code class="language-go">func (check *Checker) infer(pos syntax.Pos, tparams []*TypeParam, targs []Type, params *Tuple, args []*operand, reverse bool, err *error_) (inferred []Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inferred" data-name="inferred">
               <h3>
                  inferred 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#inferred" class="anchor" title="Link to inferred">#</a>
               </h3>
               
               <p>inferred returns the list of inferred types for the given type parameter list.
The result is never nil and has the same length as tparams; result types that
could not be inferred are nil. Corresponding type parameters and result types
have identical indices.</p>
               
               <pre><code class="language-go">func (u *unifier) inferred(tparams []*TypeParam) []Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initConst" data-name="initConst">
               <h3>
                  initConst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initConst" class="anchor" title="Link to initConst">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) initConst(lhs *Const, x *operand)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initFiles" data-name="initFiles">
               <h3>
                  initFiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initFiles" class="anchor" title="Link to initFiles">#</a>
               </h3>
               
               <p>initFiles initializes the files-specific portion of checker.
The provided files must all belong to the same package.</p>
               
               <pre><code class="language-go">func (check *Checker) initFiles(files []*syntax.File)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initOrder" data-name="initOrder">
               <h3>
                  initOrder 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initOrder" class="anchor" title="Link to initOrder">#</a>
               </h3>
               
               <p>initOrder computes the Info.InitOrder for package variables.</p>
               
               <pre><code class="language-go">func (check *Checker) initOrder()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initVar" data-name="initVar">
               <h3>
                  initVar 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initVar" class="anchor" title="Link to initVar">#</a>
               </h3>
               
               <p>initVar checks the initialization lhs = x in a variable declaration.
If lhs doesn't have a type yet, it is given the type of x,
or Typ[Invalid] in case of an error.
If the initialization check fails, x.mode is set to invalid.</p>
               
               <pre><code class="language-go">func (check *Checker) initVar(lhs *Var, x *operand, context string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initVars" data-name="initVars">
               <h3>
                  initVars 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initVars" class="anchor" title="Link to initVars">#</a>
               </h3>
               
               <p>initVars type-checks assignments of initialization expressions orig_rhs
to variables lhs.
If returnStmt is non-nil, initVars type-checks the implicit assignment
of result expressions orig_rhs to function result parameters lhs.</p>
               
               <pre><code class="language-go">func (check *Checker) initVars(lhs []*Var, orig_rhs []syntax.Expr, returnStmt syntax.Stmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="insert" data-name="insert">
               <h3>
                  insert 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#insert" class="anchor" title="Link to insert">#</a>
               </h3>
               
               <p>insert records a new label declaration for the current block.
The label must not have been declared before in any block.</p>
               
               <pre><code class="language-go">func (b *block) insert(s *syntax.LabeledStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="insert" data-name="insert">
               <h3>
                  insert 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#insert" class="anchor" title="Link to insert">#</a>
               </h3>
               
               <p>insert attempts to insert an object obj into objset s.
If s already contains an alternative object alt with
the same name, insert leaves s unchanged and returns alt.
Otherwise it inserts obj and returns nil.</p>
               
               <pre><code class="language-go">func (s *objset) insert(obj Object) Object</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="insert" data-name="insert">
               <h3>
                  insert 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#insert" class="anchor" title="Link to insert">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Scope) insert(name string, obj Object)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="instance" data-name="instance">
               <h3>
                  instance 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#instance" class="anchor" title="Link to instance">#</a>
               </h3>
               
               <p>instance instantiates the given original (generic) function or type with the
provided type arguments and returns the resulting instance. If an identical
instance exists already in the given contexts, it returns that instance,
otherwise it creates a new one. If there is an error (such as wrong number
of type arguments), the result is Typ[Invalid].
If expanding is non-nil, it is the Named instance type currently being
expanded. If ctxt is non-nil, it is the context associated with the current
type-checking pass or call to Instantiate. At least one of expanding or ctxt
must be non-nil.
For Named types the resulting instance may be unexpanded.
check may be nil (when not type-checking syntax); pos is used only only if check is non-nil.</p>
               
               <pre><code class="language-go">func (check *Checker) instance(pos syntax.Pos, orig genericType, targs []Type, expanding *Named, ctxt *Context) (res Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="instanceHash" data-name="instanceHash">
               <h3>
                  instanceHash 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#instanceHash" class="anchor" title="Link to instanceHash">#</a>
               </h3>
               
               <p>instanceHash returns a string representation of typ instantiated with targs.
The hash should be a perfect hash, though out of caution the type checker
does not assume this. The result is guaranteed to not contain blanks.</p>
               
               <pre><code class="language-go">func (ctxt *Context) instanceHash(orig Type, targs []Type) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="instantiateSignature" data-name="instantiateSignature">
               <h3>
                  instantiateSignature 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#instantiateSignature" class="anchor" title="Link to instantiateSignature">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) instantiateSignature(pos syntax.Pos, expr syntax.Expr, typ *Signature, targs []Type, xlist []syntax.Expr) (res *Signature)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="instantiatedIdent" data-name="instantiatedIdent">
               <h3>
                  instantiatedIdent 
                  <span class="badge">function</span>
                  
                  <a href="#instantiatedIdent" class="anchor" title="Link to instantiatedIdent">#</a>
               </h3>
               
               <p>instantiatedIdent determines the identifier of the type instantiated in expr.
Helper function for recordInstance in recording.go.</p>
               
               <pre><code class="language-go">func instantiatedIdent(expr syntax.Expr) *syntax.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="instantiatedType" data-name="instantiatedType">
               <h3>
                  instantiatedType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#instantiatedType" class="anchor" title="Link to instantiatedType">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) instantiatedType(x syntax.Expr, xlist []syntax.Expr, def *TypeName) (res Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="interfacePtrError" data-name="interfacePtrError">
               <h3>
                  interfacePtrError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#interfacePtrError" class="anchor" title="Link to interfacePtrError">#</a>
               </h3>
               
               <p>check may be nil.</p>
               
               <pre><code class="language-go">func (check *Checker) interfacePtrError(T Type) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="interfaceType" data-name="interfaceType">
               <h3>
                  interfaceType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#interfaceType" class="anchor" title="Link to interfaceType">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) interfaceType(ityp *Interface, iface *syntax.InterfaceType, def *TypeName)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="intersect" data-name="intersect">
               <h3>
                  intersect 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#intersect" class="anchor" title="Link to intersect">#</a>
               </h3>
               
               <p>intersect returns the intersection xl ∩ yl.</p>
               
               <pre><code class="language-go">func (xl termlist) intersect(yl termlist) termlist</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="intersect" data-name="intersect">
               <h3>
                  intersect 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#intersect" class="anchor" title="Link to intersect">#</a>
               </h3>
               
               <p>intersect returns the intersection x ∩ y.</p>
               
               <pre><code class="language-go">func (x *term) intersect(y *term) *term</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="intersectTermLists" data-name="intersectTermLists">
               <h3>
                  intersectTermLists 
                  <span class="badge">function</span>
                  
                  <a href="#intersectTermLists" class="anchor" title="Link to intersectTermLists">#</a>
               </h3>
               
               <p>intersectTermLists computes the intersection of two term lists and respective comparable bits.
xcomp, ycomp are valid only if xterms.isAll() and yterms.isAll() respectively.</p>
               
               <pre><code class="language-go">func intersectTermLists(xterms termlist, xcomp bool, yterms termlist, ycomp bool) (termlist, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="invalidConversion" data-name="invalidConversion">
               <h3>
                  invalidConversion 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#invalidConversion" class="anchor" title="Link to invalidConversion">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) invalidConversion(code Code, x *operand, target Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="is" data-name="is">
               <h3>
                  is 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#is" class="anchor" title="Link to is">#</a>
               </h3>
               
               <p>is calls f with the specific type terms of s and reports whether
all calls to f returned true. If there are no specific terms, is
returns the result of f(nil).</p>
               
               <pre><code class="language-go">func (s *_TypeSet) is(f func(*term) bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="is" data-name="is">
               <h3>
                  is 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#is" class="anchor" title="Link to is">#</a>
               </h3>
               
               <p>is calls f with the specific type terms of t's constraint and reports whether
all calls to f returned true. If there are no specific terms, is
returns the result of f(nil).</p>
               
               <pre><code class="language-go">func (t *TypeParam) is(f func(*term) bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isAll" data-name="isAll">
               <h3>
                  isAll 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isAll" class="anchor" title="Link to isAll">#</a>
               </h3>
               
               <p>isAll reports whether the termlist xl represents the set of all types.</p>
               
               <pre><code class="language-go">func (xl termlist) isAll() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isBasic" data-name="isBasic">
               <h3>
                  isBasic 
                  <span class="badge">function</span>
                  
                  <a href="#isBasic" class="anchor" title="Link to isBasic">#</a>
               </h3>
               
               <p>isBasic reports whether under(t) is a basic type with the specified info.
If t is a type parameter the result is false; i.e.,
isBasic does not look inside a type parameter.</p>
               
               <pre><code class="language-go">func isBasic(t Type, info BasicInfo) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isBoolean" data-name="isBoolean">
               <h3>
                  isBoolean 
                  <span class="badge">function</span>
                  
                  <a href="#isBoolean" class="anchor" title="Link to isBoolean">#</a>
               </h3>
               
               <pre><code class="language-go">func isBoolean(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isBrokenAlias" data-name="isBrokenAlias">
               <h3>
                  isBrokenAlias 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isBrokenAlias" class="anchor" title="Link to isBrokenAlias">#</a>
               </h3>
               
               <p>isBrokenAlias reports whether alias doesn't have a determined type yet.</p>
               
               <pre><code class="language-go">func (check *Checker) isBrokenAlias(alias *TypeName) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isBytesOrRunes" data-name="isBytesOrRunes">
               <h3>
                  isBytesOrRunes 
                  <span class="badge">function</span>
                  
                  <a href="#isBytesOrRunes" class="anchor" title="Link to isBytesOrRunes">#</a>
               </h3>
               
               <pre><code class="language-go">func isBytesOrRunes(typ Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isCGoTypeObj" data-name="isCGoTypeObj">
               <h3>
                  isCGoTypeObj 
                  <span class="badge">function</span>
                  
                  <a href="#isCGoTypeObj" class="anchor" title="Link to isCGoTypeObj">#</a>
               </h3>
               
               <p>isCGoTypeObj reports whether the given type name was created by cgo.</p>
               
               <pre><code class="language-go">func isCGoTypeObj(obj *TypeName) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isComparison" data-name="isComparison">
               <h3>
                  isComparison 
                  <span class="badge">function</span>
                  
                  <a href="#isComparison" class="anchor" title="Link to isComparison">#</a>
               </h3>
               
               <pre><code class="language-go">func isComparison(op syntax.Operator) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isComplex" data-name="isComplex">
               <h3>
                  isComplex 
                  <span class="badge">function</span>
                  
                  <a href="#isComplex" class="anchor" title="Link to isComplex">#</a>
               </h3>
               
               <pre><code class="language-go">func isComplex(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isConstType" data-name="isConstType">
               <h3>
                  isConstType 
                  <span class="badge">function</span>
                  
                  <a href="#isConstType" class="anchor" title="Link to isConstType">#</a>
               </h3>
               
               <pre><code class="language-go">func isConstType(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDependency" data-name="isDependency">
               <h3>
                  isDependency 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isDependency" class="anchor" title="Link to isDependency">#</a>
               </h3>
               
               <pre><code class="language-go">func (*Func) isDependency()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDependency" data-name="isDependency">
               <h3>
                  isDependency 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isDependency" class="anchor" title="Link to isDependency">#</a>
               </h3>
               
               <pre><code class="language-go">func (*Var) isDependency()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDependency" data-name="isDependency">
               <h3>
                  isDependency 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isDependency" class="anchor" title="Link to isDependency">#</a>
               </h3>
               
               <pre><code class="language-go">func (*Const) isDependency()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isEmpty" data-name="isEmpty">
               <h3>
                  isEmpty 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isEmpty" class="anchor" title="Link to isEmpty">#</a>
               </h3>
               
               <p>isEmpty reports whether the termlist xl represents the empty set of types.</p>
               
               <pre><code class="language-go">func (xl termlist) isEmpty() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isExported" data-name="isExported">
               <h3>
                  isExported 
                  <span class="badge">function</span>
                  
                  <a href="#isExported" class="anchor" title="Link to isExported">#</a>
               </h3>
               
               <pre><code class="language-go">func isExported(name string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isFloat" data-name="isFloat">
               <h3>
                  isFloat 
                  <span class="badge">function</span>
                  
                  <a href="#isFloat" class="anchor" title="Link to isFloat">#</a>
               </h3>
               
               <pre><code class="language-go">func isFloat(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isGeneric" data-name="isGeneric">
               <h3>
                  isGeneric 
                  <span class="badge">function</span>
                  
                  <a href="#isGeneric" class="anchor" title="Link to isGeneric">#</a>
               </h3>
               
               <p>isGeneric reports whether a type is a generic, uninstantiated type
(generic signatures are not included).
TODO(gri) should we include signatures or assert that they are not present?</p>
               
               <pre><code class="language-go">func isGeneric(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isImportedConstraint" data-name="isImportedConstraint">
               <h3>
                  isImportedConstraint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isImportedConstraint" class="anchor" title="Link to isImportedConstraint">#</a>
               </h3>
               
               <p>isImportedConstraint reports whether typ is an imported type constraint.</p>
               
               <pre><code class="language-go">func (check *Checker) isImportedConstraint(typ Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isInteger" data-name="isInteger">
               <h3>
                  isInteger 
                  <span class="badge">function</span>
                  
                  <a href="#isInteger" class="anchor" title="Link to isInteger">#</a>
               </h3>
               
               <pre><code class="language-go">func isInteger(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isIntegerOrFloat" data-name="isIntegerOrFloat">
               <h3>
                  isIntegerOrFloat 
                  <span class="badge">function</span>
                  
                  <a href="#isIntegerOrFloat" class="anchor" title="Link to isIntegerOrFloat">#</a>
               </h3>
               
               <pre><code class="language-go">func isIntegerOrFloat(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isInterfacePtr" data-name="isInterfacePtr">
               <h3>
                  isInterfacePtr 
                  <span class="badge">function</span>
                  
                  <a href="#isInterfacePtr" class="anchor" title="Link to isInterfacePtr">#</a>
               </h3>
               
               <pre><code class="language-go">func isInterfacePtr(T Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNil" data-name="isNil">
               <h3>
                  isNil 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isNil" class="anchor" title="Link to isNil">#</a>
               </h3>
               
               <p>isNil reports whether the expression e denotes the predeclared value nil.</p>
               
               <pre><code class="language-go">func (check *Checker) isNil(e syntax.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNil" data-name="isNil">
               <h3>
                  isNil 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isNil" class="anchor" title="Link to isNil">#</a>
               </h3>
               
               <p>isNil reports whether x is the (untyped) nil value.</p>
               
               <pre><code class="language-go">func (x *operand) isNil() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNonTypeParamInterface" data-name="isNonTypeParamInterface">
               <h3>
                  isNonTypeParamInterface 
                  <span class="badge">function</span>
                  
                  <a href="#isNonTypeParamInterface" class="anchor" title="Link to isNonTypeParamInterface">#</a>
               </h3>
               
               <p>isNonTypeParamInterface reports whether t is an interface type but not a type parameter.</p>
               
               <pre><code class="language-go">func isNonTypeParamInterface(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNumeric" data-name="isNumeric">
               <h3>
                  isNumeric 
                  <span class="badge">function</span>
                  
                  <a href="#isNumeric" class="anchor" title="Link to isNumeric">#</a>
               </h3>
               
               <pre><code class="language-go">func isNumeric(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isParameterized" data-name="isParameterized">
               <h3>
                  isParameterized 
                  <span class="badge">function</span>
                  
                  <a href="#isParameterized" class="anchor" title="Link to isParameterized">#</a>
               </h3>
               
               <p>isParameterized reports whether typ contains any of the type parameters of tparams.
If typ is a generic function, isParameterized ignores the type parameter declarations;
it only considers the signature proper (incoming and result parameters).</p>
               
               <pre><code class="language-go">func isParameterized(tparams []*TypeParam, typ Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isParameterized" data-name="isParameterized">
               <h3>
                  isParameterized 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isParameterized" class="anchor" title="Link to isParameterized">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *tpWalker) isParameterized(typ Type) (res bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isPointer" data-name="isPointer">
               <h3>
                  isPointer 
                  <span class="badge">function</span>
                  
                  <a href="#isPointer" class="anchor" title="Link to isPointer">#</a>
               </h3>
               
               <pre><code class="language-go">func isPointer(typ Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isShift" data-name="isShift">
               <h3>
                  isShift 
                  <span class="badge">function</span>
                  
                  <a href="#isShift" class="anchor" title="Link to isShift">#</a>
               </h3>
               
               <pre><code class="language-go">func isShift(op syntax.Operator) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isString" data-name="isString">
               <h3>
                  isString 
                  <span class="badge">function</span>
                  
                  <a href="#isString" class="anchor" title="Link to isString">#</a>
               </h3>
               
               <pre><code class="language-go">func isString(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTerminating" data-name="isTerminating">
               <h3>
                  isTerminating 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isTerminating" class="anchor" title="Link to isTerminating">#</a>
               </h3>
               
               <p>isTerminating reports if s is a terminating statement.
If s is labeled, label is the label name; otherwise s
is "".</p>
               
               <pre><code class="language-go">func (check *Checker) isTerminating(s syntax.Stmt, label string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTerminatingList" data-name="isTerminatingList">
               <h3>
                  isTerminatingList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isTerminatingList" class="anchor" title="Link to isTerminatingList">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) isTerminatingList(list []syntax.Stmt, label string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTerminatingSwitch" data-name="isTerminatingSwitch">
               <h3>
                  isTerminatingSwitch 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isTerminatingSwitch" class="anchor" title="Link to isTerminatingSwitch">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) isTerminatingSwitch(body []*syntax.CaseClause, label string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTypeLit" data-name="isTypeLit">
               <h3>
                  isTypeLit 
                  <span class="badge">function</span>
                  
                  <a href="#isTypeLit" class="anchor" title="Link to isTypeLit">#</a>
               </h3>
               
               <p>isTypeLit reports whether t is a type literal.
This includes all non-defined types, but also basic types.
isTypeLit may be called with types that are not fully set up.</p>
               
               <pre><code class="language-go">func isTypeLit(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTypeParam" data-name="isTypeParam">
               <h3>
                  isTypeParam 
                  <span class="badge">function</span>
                  
                  <a href="#isTypeParam" class="anchor" title="Link to isTypeParam">#</a>
               </h3>
               
               <p>isTypeParam reports whether t is a type parameter.</p>
               
               <pre><code class="language-go">func isTypeParam(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTyped" data-name="isTyped">
               <h3>
                  isTyped 
                  <span class="badge">function</span>
                  
                  <a href="#isTyped" class="anchor" title="Link to isTyped">#</a>
               </h3>
               
               <p>isTyped reports whether t is typed; i.e., not an untyped
constant or boolean.
Safe to call from types that are not fully set up.</p>
               
               <pre><code class="language-go">func isTyped(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isUintptr" data-name="isUintptr">
               <h3>
                  isUintptr 
                  <span class="badge">function</span>
                  
                  <a href="#isUintptr" class="anchor" title="Link to isUintptr">#</a>
               </h3>
               
               <pre><code class="language-go">func isUintptr(typ Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isUnsafePointer" data-name="isUnsafePointer">
               <h3>
                  isUnsafePointer 
                  <span class="badge">function</span>
                  
                  <a href="#isUnsafePointer" class="anchor" title="Link to isUnsafePointer">#</a>
               </h3>
               
               <pre><code class="language-go">func isUnsafePointer(typ Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isUnsigned" data-name="isUnsigned">
               <h3>
                  isUnsigned 
                  <span class="badge">function</span>
                  
                  <a href="#isUnsigned" class="anchor" title="Link to isUnsigned">#</a>
               </h3>
               
               <pre><code class="language-go">func isUnsigned(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isUntyped" data-name="isUntyped">
               <h3>
                  isUntyped 
                  <span class="badge">function</span>
                  
                  <a href="#isUntyped" class="anchor" title="Link to isUntyped">#</a>
               </h3>
               
               <p>isUntyped(t) is the same as !isTyped(t).
Safe to call from types that are not fully set up.</p>
               
               <pre><code class="language-go">func isUntyped(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isUntypedNumeric" data-name="isUntypedNumeric">
               <h3>
                  isUntypedNumeric 
                  <span class="badge">function</span>
                  
                  <a href="#isUntypedNumeric" class="anchor" title="Link to isUntypedNumeric">#</a>
               </h3>
               
               <p>isUntypedNumeric reports whether t is an untyped numeric type.
Safe to call from types that are not fully set up.</p>
               
               <pre><code class="language-go">func isUntypedNumeric(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isValid" data-name="isValid">
               <h3>
                  isValid 
                  <span class="badge">function</span>
                  
                  <a href="#isValid" class="anchor" title="Link to isValid">#</a>
               </h3>
               
               <p>isValid reports whether t is a valid type.</p>
               
               <pre><code class="language-go">func isValid(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isValid" data-name="isValid">
               <h3>
                  isValid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isValid" class="anchor" title="Link to isValid">#</a>
               </h3>
               
               <p>isValid reports whether v is a valid Go version.</p>
               
               <pre><code class="language-go">func (v goVersion) isValid() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isValidIndex" data-name="isValidIndex">
               <h3>
                  isValidIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isValidIndex" class="anchor" title="Link to isValidIndex">#</a>
               </h3>
               
               <p>isValidIndex checks whether operand x satisfies the criteria for integer
index values. If allowNegative is set, a constant operand may be negative.
If the operand is not valid, an error is reported (using what as context)
and the result is false.</p>
               
               <pre><code class="language-go">func (check *Checker) isValidIndex(x *operand, code Code, what string, allowNegative bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isValidName" data-name="isValidName">
               <h3>
                  isValidName 
                  <span class="badge">function</span>
                  
                  <a href="#isValidName" class="anchor" title="Link to isValidName">#</a>
               </h3>
               
               <p>isValidName reports whether s is a valid Go identifier.</p>
               
               <pre><code class="language-go">func isValidName(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isdddArray" data-name="isdddArray">
               <h3>
                  isdddArray 
                  <span class="badge">function</span>
                  
                  <a href="#isdddArray" class="anchor" title="Link to isdddArray">#</a>
               </h3>
               
               <p>isdddArray reports whether atyp is of the form [...]E.</p>
               
               <pre><code class="language-go">func isdddArray(atyp *syntax.ArrayType) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="join" data-name="join">
               <h3>
                  join 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#join" class="anchor" title="Link to join">#</a>
               </h3>
               
               <p>join unifies the given type parameters x and y.
If both type parameters already have a type associated with them
and they are not joined, join fails and returns false.</p>
               
               <pre><code class="language-go">func (u *unifier) join(x *TypeParam, y *TypeParam) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="keyVal" data-name="keyVal">
               <h3>
                  keyVal 
                  <span class="badge">function</span>
                  
                  <a href="#keyVal" class="anchor" title="Link to keyVal">#</a>
               </h3>
               
               <p>keyVal maps a complex, float, integer, string or boolean constant value
to the corresponding complex128, float64, int64, uint64, string, or bool
Go value if possible; otherwise it returns x.
A complex constant that can be represented as a float (such as 1.2 + 0i)
is returned as a floating point value; if a floating point value can be
represented as an integer (such as 1.0) it is returned as an integer value.
This ensures that constants of different kind but equal value (such as
1.0 + 0i, 1.0, 1) result in the same value.</p>
               
               <pre><code class="language-go">func keyVal(x constant.Value) interface{}</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="killCycles" data-name="killCycles">
               <h3>
                  killCycles 
                  <span class="badge">function</span>
                  
                  <a href="#killCycles" class="anchor" title="Link to killCycles">#</a>
               </h3>
               
               <p>killCycles walks through the given type parameters and looks for cycles
created by type parameters whose inferred types refer back to that type
parameter, either directly or indirectly. If such a cycle is detected,
it is killed by setting the corresponding inferred type to nil.
TODO(gri) Determine if we can simply abort inference as soon as we have
found a single cycle.</p>
               
               <pre><code class="language-go">func killCycles(tparams []*TypeParam, inferred []Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="labels" data-name="labels">
               <h3>
                  labels 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#labels" class="anchor" title="Link to labels">#</a>
               </h3>
               
               <p>labels checks correct label use in body.</p>
               
               <pre><code class="language-go">func (check *Checker) labels(body *syntax.BlockStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="langCompat" data-name="langCompat">
               <h3>
                  langCompat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#langCompat" class="anchor" title="Link to langCompat">#</a>
               </h3>
               
               <p>langCompat reports an error if the representation of a numeric
literal is not compatible with the current language version.</p>
               
               <pre><code class="language-go">func (check *Checker) langCompat(lit *syntax.BasicLit)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="later" data-name="later">
               <h3>
                  later 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#later" class="anchor" title="Link to later">#</a>
               </h3>
               
               <p>later pushes f on to the stack of actions that will be processed later;
either at the end of the current statement, or in case of a local constant
or variable declaration, before the constant or variable is in scope
(so that f still sees the scope before any new declarations).
later returns the pushed action so one can provide a description
via action.describef for debugging, if desired.</p>
               
               <pre><code class="language-go">func (check *Checker) later(f func()) *action</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lhsVar" data-name="lhsVar">
               <h3>
                  lhsVar 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lhsVar" class="anchor" title="Link to lhsVar">#</a>
               </h3>
               
               <p>lhsVar checks a lhs variable in an assignment and returns its type.
lhsVar takes care of not counting a lhs identifier as a "use" of
that identifier. The result is nil if it is the blank identifier,
and Typ[Invalid] if it is an invalid lhs expression.</p>
               
               <pre><code class="language-go">func (check *Checker) lhsVar(lhs syntax.Expr) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="list" data-name="list">
               <h3>
                  list 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#list" class="anchor" title="Link to list">#</a>
               </h3>
               
               <p>list is for internal use where we expect a []*TypeParam.
TODO(rfindley): list should probably be eliminated: we can pass around a
TypeParamList instead.</p>
               
               <pre><code class="language-go">func (l *TypeParamList) list() []*TypeParam</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="list" data-name="list">
               <h3>
                  list 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#list" class="anchor" title="Link to list">#</a>
               </h3>
               
               <p>list is for internal use where we expect a []Type.
TODO(rfindley): list should probably be eliminated: we can pass around a
TypeList instead.</p>
               
               <pre><code class="language-go">func (l *TypeList) list() []Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="localNamedVertex" data-name="localNamedVertex">
               <h3>
                  localNamedVertex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#localNamedVertex" class="anchor" title="Link to localNamedVertex">#</a>
               </h3>
               
               <p>localNamedVertex returns the index of the vertex representing
named, or -1 if named doesn't need representation.</p>
               
               <pre><code class="language-go">func (w *monoGraph) localNamedVertex(pkg *Package, named *Named) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookup" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookup" class="anchor" title="Link to lookup">#</a>
               </h3>
               
               <p>lookup returns an existing instantiation of orig with targs, if it exists.
Otherwise, it returns nil.</p>
               
               <pre><code class="language-go">func (ctxt *Context) lookup(h string, orig Type, targs []Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookup" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookup" class="anchor" title="Link to lookup">#</a>
               </h3>
               
               <p>lookup is like lookupScope but it only returns the object (or nil).</p>
               
               <pre><code class="language-go">func (env *environment) lookup(name string) Object</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookup" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookup" class="anchor" title="Link to lookup">#</a>
               </h3>
               
               <pre><code class="language-go">func (m substMap) lookup(tpar *TypeParam) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookup" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookup" class="anchor" title="Link to lookup">#</a>
               </h3>
               
               <pre><code class="language-go">func (l *instanceLookup) lookup(inst *Named) *Named</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupError" data-name="lookupError">
               <h3>
                  lookupError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookupError" class="anchor" title="Link to lookupError">#</a>
               </h3>
               
               <p>lookupError returns a case-specific error when a lookup of selector sel in the
given type fails but an object with alternative spelling (case folding) is found.
If structLit is set, the error message is specifically for struct literal fields.</p>
               
               <pre><code class="language-go">func (check *Checker) lookupError(typ Type, sel string, obj Object, structLit bool) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupFieldOrMethod" data-name="lookupFieldOrMethod">
               <h3>
                  lookupFieldOrMethod 
                  <span class="badge">function</span>
                  
                  <a href="#lookupFieldOrMethod" class="anchor" title="Link to lookupFieldOrMethod">#</a>
               </h3>
               
               <p>lookupFieldOrMethod is like LookupFieldOrMethod but with the additional foldCase parameter
(see Object.sameId for the meaning of foldCase).</p>
               
               <pre><code class="language-go">func lookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string, foldCase bool) (obj Object, index []int, indirect bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupFieldOrMethodImpl" data-name="lookupFieldOrMethodImpl">
               <h3>
                  lookupFieldOrMethodImpl 
                  <span class="badge">function</span>
                  
                  <a href="#lookupFieldOrMethodImpl" class="anchor" title="Link to lookupFieldOrMethodImpl">#</a>
               </h3>
               
               <p>lookupFieldOrMethodImpl is the implementation of lookupFieldOrMethod.
Notably, in contrast to lookupFieldOrMethod, it won't find struct fields
in base types of defined (*Named) pointer types T. For instance, given
the declaration:
type T *struct{f int}
lookupFieldOrMethodImpl won't find the field f in the defined (*Named) type T
(methods on T are not permitted in the first place).
Thus, lookupFieldOrMethodImpl should only be called by lookupFieldOrMethod
and missingMethod (the latter doesn't care about struct fields).
The resulting object may not be fully type-checked.</p>
               
               <pre><code class="language-go">func lookupFieldOrMethodImpl(T Type, addressable bool, pkg *Package, name string, foldCase bool) (obj Object, index []int, indirect bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupMethod" data-name="lookupMethod">
               <h3>
                  lookupMethod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookupMethod" class="anchor" title="Link to lookupMethod">#</a>
               </h3>
               
               <pre><code class="language-go">func (n *Named) lookupMethod(pkg *Package, name string, foldCase bool) (int, *Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupScope" data-name="lookupScope">
               <h3>
                  lookupScope 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookupScope" class="anchor" title="Link to lookupScope">#</a>
               </h3>
               
               <p>lookupScope looks up name in the current environment and if an object
is found it returns the scope containing the object and the object.
Otherwise it returns (nil, nil).
Note that obj.Parent() may be different from the returned scope if the
object was inserted into the scope and already had a parent at that
time (see Scope.Insert). This can only happen for dot-imported objects
whose parent is the scope of the package that exported them.</p>
               
               <pre><code class="language-go">func (env *environment) lookupScope(name string) (*Scope, Object)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupType" data-name="lookupType">
               <h3>
                  lookupType 
                  <span class="badge">function</span>
                  
                  <a href="#lookupType" class="anchor" title="Link to lookupType">#</a>
               </h3>
               
               <pre><code class="language-go">func lookupType(m map[Type]int, typ Type) (int, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeFromLiteral" data-name="makeFromLiteral">
               <h3>
                  makeFromLiteral 
                  <span class="badge">function</span>
                  
                  <a href="#makeFromLiteral" class="anchor" title="Link to makeFromLiteral">#</a>
               </h3>
               
               <p>makeFromLiteral returns the constant value for the given literal string and kind.</p>
               
               <pre><code class="language-go">func makeFromLiteral(lit string, kind syntax.LitKind) constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeObjList" data-name="makeObjList">
               <h3>
                  makeObjList 
                  <span class="badge">function</span>
                  
                  <a href="#makeObjList" class="anchor" title="Link to makeObjList">#</a>
               </h3>
               
               <p>makeObjList returns the list of type name objects for the given
list of named types.</p>
               
               <pre><code class="language-go">func makeObjList(tlist []*Named) []Object</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeRenameMap" data-name="makeRenameMap">
               <h3>
                  makeRenameMap 
                  <span class="badge">function</span>
                  
                  <a href="#makeRenameMap" class="anchor" title="Link to makeRenameMap">#</a>
               </h3>
               
               <p>makeRenameMap is like makeSubstMap, but creates a map used to rename type
parameters in from with the type parameters in to.</p>
               
               <pre><code class="language-go">func makeRenameMap(from []*TypeParam, to []*TypeParam) substMap</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeSig" data-name="makeSig">
               <h3>
                  makeSig 
                  <span class="badge">function</span>
                  
                  <a href="#makeSig" class="anchor" title="Link to makeSig">#</a>
               </h3>
               
               <p>makeSig makes a signature for the given argument and result types.
Default types are used for untyped arguments, and res may be nil.</p>
               
               <pre><code class="language-go">func makeSig(res Type, args ...Type) *Signature</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeSubstMap" data-name="makeSubstMap">
               <h3>
                  makeSubstMap 
                  <span class="badge">function</span>
                  
                  <a href="#makeSubstMap" class="anchor" title="Link to makeSubstMap">#</a>
               </h3>
               
               <p>makeSubstMap creates a new substitution map mapping tpars[i] to targs[i].
If targs[i] is nil, tpars[i] is not substituted.</p>
               
               <pre><code class="language-go">func makeSubstMap(tpars []*TypeParam, targs []Type) substMap</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="markComplete" data-name="markComplete">
               <h3>
                  markComplete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#markComplete" class="anchor" title="Link to markComplete">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Struct) markComplete()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="markImports" data-name="markImports">
               <h3>
                  markImports 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#markImports" class="anchor" title="Link to markImports">#</a>
               </h3>
               
               <p>markImports recursively walks pkg and its imports, to record unique import
paths in pkgPathMap.</p>
               
               <pre><code class="language-go">func (check *Checker) markImports(pkg *Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge">function</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <p>If x and y are identical, match returns x.
If x and y are identical channels but for their direction
and one of them is unrestricted, match returns the channel
with the restricted direction.
In all other cases, match returns nil.</p>
               
               <pre><code class="language-go">func match(x Type, y Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchTypes" data-name="matchTypes">
               <h3>
                  matchTypes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchTypes" class="anchor" title="Link to matchTypes">#</a>
               </h3>
               
               <p>matchTypes attempts to convert any untyped types x and y such that they match.
If an error occurs, x.mode is set to invalid.</p>
               
               <pre><code class="language-go">func (check *Checker) matchTypes(x *operand, y *operand)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maxType" data-name="maxType">
               <h3>
                  maxType 
                  <span class="badge">function</span>
                  
                  <a href="#maxType" class="anchor" title="Link to maxType">#</a>
               </h3>
               
               <p>maxType returns the "largest" type that encompasses both x and y.
If x and y are different untyped numeric types, the result is the type of x or y
that appears later in this list: integer, rune, floating-point, complex.
Otherwise, if x != y, the result is nil.</p>
               
               <pre><code class="language-go">func maxType(x Type, y Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="measure" data-name="measure">
               <h3>
                  measure 
                  <span class="badge">function</span>
                  
                  <a href="#measure" class="anchor" title="Link to measure">#</a>
               </h3>
               
               <pre><code class="language-go">func measure(x int, unit string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mentions" data-name="mentions">
               <h3>
                  mentions 
                  <span class="badge">function</span>
                  
                  <a href="#mentions" class="anchor" title="Link to mentions">#</a>
               </h3>
               
               <p>mentions reports whether type T "mentions" typ in an (embedded) element or term
of T (whether typ is in the type set of T or not). For better error messages.</p>
               
               <pre><code class="language-go">func mentions(T Type, typ Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="methodIndex" data-name="methodIndex">
               <h3>
                  methodIndex 
                  <span class="badge">function</span>
                  
                  <a href="#methodIndex" class="anchor" title="Link to methodIndex">#</a>
               </h3>
               
               <p>methodIndex returns the index of and method with matching package and name, or (-1, nil).
See Object.sameId for the meaning of foldCase.</p>
               
               <pre><code class="language-go">func methodIndex(methods []*Func, pkg *Package, name string, foldCase bool) (int, *Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="methodIndex" data-name="methodIndex">
               <h3>
                  methodIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#methodIndex" class="anchor" title="Link to methodIndex">#</a>
               </h3>
               
               <p>methodIndex returns the index of the method with the given name.
If foldCase is set, capitalization in the name is ignored.
The result is negative if no such method exists.</p>
               
               <pre><code class="language-go">func (t *Named) methodIndex(name string, foldCase bool) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="missingMethod" data-name="missingMethod">
               <h3>
                  missingMethod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#missingMethod" class="anchor" title="Link to missingMethod">#</a>
               </h3>
               
               <p>missingMethod is like MissingMethod but accepts a *Checker as receiver,
a comparator equivalent for type comparison, and a *string for error causes.
The receiver may be nil if missingMethod is invoked through an exported
API call (such as MissingMethod), i.e., when all methods have been type-
checked.
The underlying type of T must be an interface; T (rather than its under-
lying type) is used for better error messages (reported through *cause).
The comparator is used to compare signatures.
If a method is missing and cause is not nil, *cause describes the error.</p>
               
               <pre><code class="language-go">func (check *Checker) missingMethod(V Type, T Type, static bool, equivalent func(x Type, y Type) bool, cause *string) (method *Func, wrongType bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="monomorph" data-name="monomorph">
               <h3>
                  monomorph 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#monomorph" class="anchor" title="Link to monomorph">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) monomorph()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="msg" data-name="msg">
               <h3>
                  msg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#msg" class="anchor" title="Link to msg">#</a>
               </h3>
               
               <p>msg returns the formatted error message without the primary error position pos().</p>
               
               <pre><code class="language-go">func (err *error_) msg() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="multiExpr" data-name="multiExpr">
               <h3>
                  multiExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#multiExpr" class="anchor" title="Link to multiExpr">#</a>
               </h3>
               
               <p>multiExpr typechecks e and returns its value (or values) in list.
If allowCommaOk is set and e is a map index, comma-ok, or comma-err
expression, the result is a two-element list containing the value
of e, and an untyped bool value or an error value, respectively.
If an error occurred, list[0] is not valid.</p>
               
               <pre><code class="language-go">func (check *Checker) multiExpr(e syntax.Expr, allowCommaOk bool) (list []*operand, commaOk bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="multipleSelectDefaults" data-name="multipleSelectDefaults">
               <h3>
                  multipleSelectDefaults 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#multipleSelectDefaults" class="anchor" title="Link to multipleSelectDefaults">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) multipleSelectDefaults(list []*syntax.CommClause)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="multipleSwitchDefaults" data-name="multipleSwitchDefaults">
               <h3>
                  multipleSwitchDefaults 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#multipleSwitchDefaults" class="anchor" title="Link to multipleSwitchDefaults">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) multipleSwitchDefaults(list []*syntax.CaseClause)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="needsCleanup" data-name="needsCleanup">
               <h3>
                  needsCleanup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#needsCleanup" class="anchor" title="Link to needsCleanup">#</a>
               </h3>
               
               <p>needsCleanup records objects/types that implement the cleanup method
which will be called at the end of type-checking.</p>
               
               <pre><code class="language-go">func (check *Checker) needsCleanup(c cleaner)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newAlias" data-name="newAlias">
               <h3>
                  newAlias 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newAlias" class="anchor" title="Link to newAlias">#</a>
               </h3>
               
               <p>newAlias creates a new Alias type with the given type name and rhs.
rhs must not be nil.</p>
               
               <pre><code class="language-go">func (check *Checker) newAlias(obj *TypeName, rhs Type) *Alias</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newAliasInstance" data-name="newAliasInstance">
               <h3>
                  newAliasInstance 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newAliasInstance" class="anchor" title="Link to newAliasInstance">#</a>
               </h3>
               
               <p>newAliasInstance creates a new alias instance for the given origin and type
arguments, recording pos as the position of its synthetic object (for error
reporting).</p>
               
               <pre><code class="language-go">func (check *Checker) newAliasInstance(pos syntax.Pos, orig *Alias, targs []Type, expanding *Named, ctxt *Context) *Alias</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newAssertableTo" data-name="newAssertableTo">
               <h3>
                  newAssertableTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newAssertableTo" class="anchor" title="Link to newAssertableTo">#</a>
               </h3>
               
               <p>newAssertableTo reports whether a value of type V can be asserted to have type T.
It also implements behavior for interfaces that currently are only permitted
in constraint position (we have not yet defined that behavior in the spec).
The underlying type of V must be an interface.
If the result is false and cause is not nil, *cause is set to the error cause.</p>
               
               <pre><code class="language-go">func (check *Checker) newAssertableTo(V Type, T Type, cause *string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newBuiltin" data-name="newBuiltin">
               <h3>
                  newBuiltin 
                  <span class="badge">function</span>
                  
                  <a href="#newBuiltin" class="anchor" title="Link to newBuiltin">#</a>
               </h3>
               
               <pre><code class="language-go">func newBuiltin(id builtinId) *Builtin</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newError" data-name="newError">
               <h3>
                  newError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newError" class="anchor" title="Link to newError">#</a>
               </h3>
               
               <p>newError returns a new error_ with the given error code.</p>
               
               <pre><code class="language-go">func (check *Checker) newError(code Code) *error_</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newInterface" data-name="newInterface">
               <h3>
                  newInterface 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newInterface" class="anchor" title="Link to newInterface">#</a>
               </h3>
               
               <p>check may be nil</p>
               
               <pre><code class="language-go">func (check *Checker) newInterface() *Interface</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newNamed" data-name="newNamed">
               <h3>
                  newNamed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newNamed" class="anchor" title="Link to newNamed">#</a>
               </h3>
               
               <p>newNamed is like NewNamed but with a *Checker receiver.</p>
               
               <pre><code class="language-go">func (check *Checker) newNamed(obj *TypeName, underlying Type, methods []*Func) *Named</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newNamedInstance" data-name="newNamedInstance">
               <h3>
                  newNamedInstance 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newNamedInstance" class="anchor" title="Link to newNamedInstance">#</a>
               </h3>
               
               <p>newNamedInstance creates a new named instance for the given origin and type
arguments, recording pos as the position of its synthetic object (for error
reporting).
If set, expanding is the named type instance currently being expanded, that
led to the creation of this instance.</p>
               
               <pre><code class="language-go">func (check *Checker) newNamedInstance(pos syntax.Pos, orig *Named, targs []Type, expanding *Named) *Named</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTarget" data-name="newTarget">
               <h3>
                  newTarget 
                  <span class="badge">function</span>
                  
                  <a href="#newTarget" class="anchor" title="Link to newTarget">#</a>
               </h3>
               
               <p>newTarget creates a new target for the given type and description.
The result is nil if typ is not a signature.</p>
               
               <pre><code class="language-go">func newTarget(typ Type, desc string) *target</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTypeHasher" data-name="newTypeHasher">
               <h3>
                  newTypeHasher 
                  <span class="badge">function</span>
                  
                  <a href="#newTypeHasher" class="anchor" title="Link to newTypeHasher">#</a>
               </h3>
               
               <pre><code class="language-go">func newTypeHasher(buf *bytes.Buffer, ctxt *Context) *typeWriter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTypeList" data-name="newTypeList">
               <h3>
                  newTypeList 
                  <span class="badge">function</span>
                  
                  <a href="#newTypeList" class="anchor" title="Link to newTypeList">#</a>
               </h3>
               
               <p>newTypeList returns a new TypeList with the types in list.</p>
               
               <pre><code class="language-go">func newTypeList(list []Type) *TypeList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTypeParam" data-name="newTypeParam">
               <h3>
                  newTypeParam 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newTypeParam" class="anchor" title="Link to newTypeParam">#</a>
               </h3>
               
               <p>check may be nil</p>
               
               <pre><code class="language-go">func (check *Checker) newTypeParam(obj *TypeName, constraint Type) *TypeParam</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTypeWriter" data-name="newTypeWriter">
               <h3>
                  newTypeWriter 
                  <span class="badge">function</span>
                  
                  <a href="#newTypeWriter" class="anchor" title="Link to newTypeWriter">#</a>
               </h3>
               
               <pre><code class="language-go">func newTypeWriter(buf *bytes.Buffer, qf Qualifier) *typeWriter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newUnifier" data-name="newUnifier">
               <h3>
                  newUnifier 
                  <span class="badge">function</span>
                  
                  <a href="#newUnifier" class="anchor" title="Link to newUnifier">#</a>
               </h3>
               
               <p>newUnifier returns a new unifier initialized with the given type parameter
and corresponding type argument lists. The type argument list may be shorter
than the type parameter list, and it may contain nil types. Matching type
parameters and arguments must have the same index.</p>
               
               <pre><code class="language-go">func newUnifier(tparams []*TypeParam, targs []Type, enableInterfaceInference bool) *unifier</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nextID" data-name="nextID">
               <h3>
                  nextID 
                  <span class="badge">function</span>
                  
                  <a href="#nextID" class="anchor" title="Link to nextID">#</a>
               </h3>
               
               <p>nextID returns a value increasing monotonically by 1 with
each call, starting with 1. It may be called concurrently.</p>
               
               <pre><code class="language-go">func nextID() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nify" data-name="nify">
               <h3>
                  nify 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nify" class="anchor" title="Link to nify">#</a>
               </h3>
               
               <p>nify implements the core unification algorithm which is an
adapted version of Checker.identical. For changes to that
code the corresponding changes should be made here.
Must not be called directly from outside the unifier.</p>
               
               <pre><code class="language-go">func (u *unifier) nify(x Type, y Type, mode unifyMode, p *ifacePair) (result bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nonGeneric" data-name="nonGeneric">
               <h3>
                  nonGeneric 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nonGeneric" class="anchor" title="Link to nonGeneric">#</a>
               </h3>
               
               <p>If x is a generic type, or a generic function whose type arguments cannot be inferred
from a non-nil target T, nonGeneric reports an error and invalidates x.mode and x.typ.
Otherwise it leaves x alone.</p>
               
               <pre><code class="language-go">func (check *Checker) nonGeneric(T *target, x *operand)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="norm" data-name="norm">
               <h3>
                  norm 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#norm" class="anchor" title="Link to norm">#</a>
               </h3>
               
               <p>norm returns the normal form of xl.</p>
               
               <pre><code class="language-go">func (xl termlist) norm() termlist</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="objDecl" data-name="objDecl">
               <h3>
                  objDecl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#objDecl" class="anchor" title="Link to objDecl">#</a>
               </h3>
               
               <p>objDecl type-checks the declaration of obj in its respective (file) environment.
For the meaning of def, see Checker.definedType, in typexpr.go.</p>
               
               <pre><code class="language-go">func (check *Checker) objDecl(obj Object, def *TypeName)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="offsetof" data-name="offsetof">
               <h3>
                  offsetof 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#offsetof" class="anchor" title="Link to offsetof">#</a>
               </h3>
               
               <p>offsetof returns the offset of the field specified via
the index sequence relative to T. All embedded fields
must be structs (rather than pointers to structs).
If the offset is too large (because T is too large),
the result is negative.</p>
               
               <pre><code class="language-go">func (conf *Config) offsetof(T Type, index []int) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="offsetsof" data-name="offsetsof">
               <h3>
                  offsetsof 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#offsetsof" class="anchor" title="Link to offsetsof">#</a>
               </h3>
               
               <pre><code class="language-go">func (conf *Config) offsetsof(T *Struct) []int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="op" data-name="op">
               <h3>
                  op 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#op" class="anchor" title="Link to op">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) op(m opPredicates, x *operand, op syntax.Operator) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="opName" data-name="opName">
               <h3>
                  opName 
                  <span class="badge">function</span>
                  
                  <a href="#opName" class="anchor" title="Link to opName">#</a>
               </h3>
               
               <p>opName returns the name of the operation if x is an operation
that might overflow; otherwise it returns the empty string.</p>
               
               <pre><code class="language-go">func opName(x syntax.Expr) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="opPos" data-name="opPos">
               <h3>
                  opPos 
                  <span class="badge">function</span>
                  
                  <a href="#opPos" class="anchor" title="Link to opPos">#</a>
               </h3>
               
               <p>opPos returns the position of the operator if x is an operation;
otherwise it returns the start position of x.</p>
               
               <pre><code class="language-go">func opPos(x syntax.Expr) syntax.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openScope" data-name="openScope">
               <h3>
                  openScope 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#openScope" class="anchor" title="Link to openScope">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) openScope(node syntax.Node, comment string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="operandString" data-name="operandString">
               <h3>
                  operandString 
                  <span class="badge">function</span>
                  
                  <a href="#operandString" class="anchor" title="Link to operandString">#</a>
               </h3>
               
               <p>Operand string formats
(not all "untyped" cases can appear due to the type system,
but they fall out naturally here)
mode       format
invalid    <expr> (               <mode>                    )
novalue    <expr> (               <mode>                    )
builtin    <expr> (               <mode>                    )
typexpr    <expr> (               <mode>                    )
constant   <expr> (<untyped kind> <mode>                    )
constant   <expr> (               <mode>       of type <typ>)
constant   <expr> (<untyped kind> <mode> <val>              )
constant   <expr> (               <mode> <val> of type <typ>)
variable   <expr> (<untyped kind> <mode>                    )
variable   <expr> (               <mode>       of type <typ>)
mapindex   <expr> (<untyped kind> <mode>                    )
mapindex   <expr> (               <mode>       of type <typ>)
value      <expr> (<untyped kind> <mode>                    )
value      <expr> (               <mode>       of type <typ>)
nilvalue   untyped nil
nilvalue   nil    (                            of type <typ>)
commaok    <expr> (<untyped kind> <mode>                    )
commaok    <expr> (               <mode>       of type <typ>)
commaerr   <expr> (<untyped kind> <mode>                    )
commaerr   <expr> (               <mode>       of type <typ>)
cgofunc    <expr> (<untyped kind> <mode>                    )
cgofunc    <expr> (               <mode>       of type <typ>)</p>
               
               <pre><code class="language-go">func operandString(x *operand, qf Qualifier) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="operandTypes" data-name="operandTypes">
               <h3>
                  operandTypes 
                  <span class="badge">function</span>
                  
                  <a href="#operandTypes" class="anchor" title="Link to operandTypes">#</a>
               </h3>
               
               <p>operandTypes returns the list of types for the given operands.</p>
               
               <pre><code class="language-go">func operandTypes(list []*operand) (res []Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="order" data-name="order">
               <h3>
                  order 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#order" class="anchor" title="Link to order">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) order() uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="order" data-name="order">
               <h3>
                  order 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#order" class="anchor" title="Link to order">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *object) order() uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="overflow" data-name="overflow">
               <h3>
                  overflow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#overflow" class="anchor" title="Link to overflow">#</a>
               </h3>
               
               <p>overflow checks that the constant x is representable by its type.
For untyped constants, it checks that the value doesn't become
arbitrarily large.</p>
               
               <pre><code class="language-go">func (check *Checker) overflow(x *operand, opPos syntax.Pos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="overlappingTerm" data-name="overlappingTerm">
               <h3>
                  overlappingTerm 
                  <span class="badge">function</span>
                  
                  <a href="#overlappingTerm" class="anchor" title="Link to overlappingTerm">#</a>
               </h3>
               
               <p>overlappingTerm reports the index of the term x in terms which is
overlapping (not disjoint) from y. The result is < 0 if there is no
such term. The type of term y must not be an interface, and terms
with an interface type are ignored in the terms list.</p>
               
               <pre><code class="language-go">func overlappingTerm(terms []*Term, y *Term) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="packageObjects" data-name="packageObjects">
               <h3>
                  packageObjects 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#packageObjects" class="anchor" title="Link to packageObjects">#</a>
               </h3>
               
               <p>packageObjects typechecks all package objects, but not function bodies.</p>
               
               <pre><code class="language-go">func (check *Checker) packageObjects()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="packagePrefix" data-name="packagePrefix">
               <h3>
                  packagePrefix 
                  <span class="badge">function</span>
                  
                  <a href="#packagePrefix" class="anchor" title="Link to packagePrefix">#</a>
               </h3>
               
               <pre><code class="language-go">func packagePrefix(pkg *Package, qf Qualifier) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseTilde" data-name="parseTilde">
               <h3>
                  parseTilde 
                  <span class="badge">function</span>
                  
                  <a href="#parseTilde" class="anchor" title="Link to parseTilde">#</a>
               </h3>
               
               <pre><code class="language-go">func parseTilde(check *Checker, tx syntax.Expr) *Term</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseUnion" data-name="parseUnion">
               <h3>
                  parseUnion 
                  <span class="badge">function</span>
                  
                  <a href="#parseUnion" class="anchor" title="Link to parseUnion">#</a>
               </h3>
               
               <p>parseUnion parses uexpr as a union of expressions.
The result is a Union type, or Typ[Invalid] for some errors.</p>
               
               <pre><code class="language-go">func parseUnion(check *Checker, uexpr syntax.Expr) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathString" data-name="pathString">
               <h3>
                  pathString 
                  <span class="badge">function</span>
                  
                  <a href="#pathString" class="anchor" title="Link to pathString">#</a>
               </h3>
               
               <p>pathString returns a string of the form a->b-> ... ->g for a path [a, b, ... g].</p>
               
               <pre><code class="language-go">func pathString(path []Object) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pop" data-name="pop">
               <h3>
                  pop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pop" class="anchor" title="Link to pop">#</a>
               </h3>
               
               <p>pop pops and returns the topmost object from the object path.</p>
               
               <pre><code class="language-go">func (check *Checker) pop() Object</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pos" data-name="pos">
               <h3>
                  pos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pos" class="anchor" title="Link to pos">#</a>
               </h3>
               
               <pre><code class="language-go">func (err *error_) pos() syntax.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processDelayed" data-name="processDelayed">
               <h3>
                  processDelayed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processDelayed" class="anchor" title="Link to processDelayed">#</a>
               </h3>
               
               <p>processDelayed processes all delayed actions pushed after top.</p>
               
               <pre><code class="language-go">func (check *Checker) processDelayed(top int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ptrBase" data-name="ptrBase">
               <h3>
                  ptrBase 
                  <span class="badge">function</span>
                  
                  <a href="#ptrBase" class="anchor" title="Link to ptrBase">#</a>
               </h3>
               
               <pre><code class="language-go">func ptrBase(x *syntax.Operation) syntax.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="push" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#push" class="anchor" title="Link to push">#</a>
               </h3>
               
               <p>push pushes obj onto the object path and returns its index in the path.</p>
               
               <pre><code class="language-go">func (check *Checker) push(obj Object) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="qualifier" data-name="qualifier">
               <h3>
                  qualifier 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#qualifier" class="anchor" title="Link to qualifier">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) qualifier(pkg *Package) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rangeKeyVal" data-name="rangeKeyVal">
               <h3>
                  rangeKeyVal 
                  <span class="badge">function</span>
                  
                  <a href="#rangeKeyVal" class="anchor" title="Link to rangeKeyVal">#</a>
               </h3>
               
               <p>rangeKeyVal returns the key and value type produced by a range clause
over an expression of type typ.
If allowVersion != nil, it is used to check the required language version.
If the range clause is not permitted, rangeKeyVal returns ok = false.
When ok = false, rangeKeyVal may also return a reason in cause.</p>
               
               <pre><code class="language-go">func rangeKeyVal(typ Type, allowVersion func(goVersion) bool) (key Type, val Type, cause string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rangeStmt" data-name="rangeStmt">
               <h3>
                  rangeStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rangeStmt" class="anchor" title="Link to rangeStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) rangeStmt(inner stmtContext, s *syntax.ForStmt, rclause *syntax.RangeClause)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rawExpr" data-name="rawExpr">
               <h3>
                  rawExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rawExpr" class="anchor" title="Link to rawExpr">#</a>
               </h3>
               
               <p>rawExpr typechecks expression e and initializes x with the expression
value or type. If an error occurred, x.mode is set to invalid.
If a non-nil target T is given and e is a generic function,
T is used to infer the type arguments for e.
If hint != nil, it is the type of a composite literal element.
If allowGeneric is set, the operand type may be an uninstantiated
parameterized type or function value.</p>
               
               <pre><code class="language-go">func (check *Checker) rawExpr(T *target, x *operand, e syntax.Expr, hint Type, allowGeneric bool) exprKind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="record" data-name="record">
               <h3>
                  record 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#record" class="anchor" title="Link to record">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) record(x *operand)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordBuiltinType" data-name="recordBuiltinType">
               <h3>
                  recordBuiltinType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordBuiltinType" class="anchor" title="Link to recordBuiltinType">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) recordBuiltinType(f syntax.Expr, sig *Signature)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordCanon" data-name="recordCanon">
               <h3>
                  recordCanon 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordCanon" class="anchor" title="Link to recordCanon">#</a>
               </h3>
               
               <p>recordCanon records that tpar is the canonical type parameter
corresponding to method type parameter mpar.</p>
               
               <pre><code class="language-go">func (w *monoGraph) recordCanon(mpar *TypeParam, tpar *TypeParam)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordCommaOkTypes" data-name="recordCommaOkTypes">
               <h3>
                  recordCommaOkTypes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordCommaOkTypes" class="anchor" title="Link to recordCommaOkTypes">#</a>
               </h3>
               
               <p>recordCommaOkTypes updates recorded types to reflect that x is used in a commaOk context
(and therefore has tuple type).</p>
               
               <pre><code class="language-go">func (check *Checker) recordCommaOkTypes(x syntax.Expr, a []*operand)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordCommaOkTypesInSyntax" data-name="recordCommaOkTypesInSyntax">
               <h3>
                  recordCommaOkTypesInSyntax 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordCommaOkTypesInSyntax" class="anchor" title="Link to recordCommaOkTypesInSyntax">#</a>
               </h3>
               
               <p>types2-specific support for recording type information in the syntax tree.</p>
               
               <pre><code class="language-go">func (check *Checker) recordCommaOkTypesInSyntax(x syntax.Expr, t0 Type, t1 Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordDef" data-name="recordDef">
               <h3>
                  recordDef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordDef" class="anchor" title="Link to recordDef">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) recordDef(id *syntax.Name, obj Object)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordImplicit" data-name="recordImplicit">
               <h3>
                  recordImplicit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordImplicit" class="anchor" title="Link to recordImplicit">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) recordImplicit(node syntax.Node, obj Object)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordInstance" data-name="recordInstance">
               <h3>
                  recordInstance 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordInstance" class="anchor" title="Link to recordInstance">#</a>
               </h3>
               
               <p>recordInstance records instantiation information into check.Info, if the
Instances map is non-nil. The given expr must be an ident, selector, or
index (list) expr with ident or selector operand.
TODO(rfindley): the expr parameter is fragile. See if we can access the
instantiated identifier in some other way.</p>
               
               <pre><code class="language-go">func (check *Checker) recordInstance(expr syntax.Expr, targs []Type, typ Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordInstance" data-name="recordInstance">
               <h3>
                  recordInstance 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordInstance" class="anchor" title="Link to recordInstance">#</a>
               </h3>
               
               <p>recordInstance records that the given type parameters were
instantiated with the corresponding type arguments.</p>
               
               <pre><code class="language-go">func (w *monoGraph) recordInstance(pkg *Package, pos syntax.Pos, tparams []*TypeParam, targs []Type, xlist []syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordParenthesizedRecvTypes" data-name="recordParenthesizedRecvTypes">
               <h3>
                  recordParenthesizedRecvTypes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordParenthesizedRecvTypes" class="anchor" title="Link to recordParenthesizedRecvTypes">#</a>
               </h3>
               
               <p>recordParenthesizedRecvTypes records parenthesized intermediate receiver type
expressions that all map to the same type, by recursively unpacking expr and
recording the corresponding type for it. Example:
expression  -->  type
----------------------
(*(T[P]))        *T[P]
*(T[P])         *T[P]
(T[P])          T[P]
T[P]           T[P]</p>
               
               <pre><code class="language-go">func (check *Checker) recordParenthesizedRecvTypes(expr syntax.Expr, typ Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordScope" data-name="recordScope">
               <h3>
                  recordScope 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordScope" class="anchor" title="Link to recordScope">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) recordScope(node syntax.Node, scope *Scope)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordSelection" data-name="recordSelection">
               <h3>
                  recordSelection 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordSelection" class="anchor" title="Link to recordSelection">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) recordSelection(x *syntax.SelectorExpr, kind SelectionKind, recv Type, obj Object, index []int, indirect bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordTypeAndValue" data-name="recordTypeAndValue">
               <h3>
                  recordTypeAndValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordTypeAndValue" class="anchor" title="Link to recordTypeAndValue">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) recordTypeAndValue(x syntax.Expr, mode operandMode, typ Type, val constant.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordTypeAndValueInSyntax" data-name="recordTypeAndValueInSyntax">
               <h3>
                  recordTypeAndValueInSyntax 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordTypeAndValueInSyntax" class="anchor" title="Link to recordTypeAndValueInSyntax">#</a>
               </h3>
               
               <p>types2-specific support for recording type information in the syntax tree.</p>
               
               <pre><code class="language-go">func (check *Checker) recordTypeAndValueInSyntax(x syntax.Expr, mode operandMode, typ Type, val constant.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordTypes" data-name="recordTypes">
               <h3>
                  recordTypes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordTypes" class="anchor" title="Link to recordTypes">#</a>
               </h3>
               
               <pre><code class="language-go">func (info *Info) recordTypes() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordUntyped" data-name="recordUntyped">
               <h3>
                  recordUntyped 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordUntyped" class="anchor" title="Link to recordUntyped">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) recordUntyped()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordUse" data-name="recordUse">
               <h3>
                  recordUse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordUse" class="anchor" title="Link to recordUse">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) recordUse(id *syntax.Name, obj Object)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rememberUntyped" data-name="rememberUntyped">
               <h3>
                  rememberUntyped 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rememberUntyped" class="anchor" title="Link to rememberUntyped">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) rememberUntyped(e syntax.Expr, lhs bool, mode operandMode, typ *Basic, val constant.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="renameTParams" data-name="renameTParams">
               <h3>
                  renameTParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#renameTParams" class="anchor" title="Link to renameTParams">#</a>
               </h3>
               
               <p>renameTParams renames the type parameters in the given type such that each type
parameter is given a new identity. renameTParams returns the new type parameters
and updated type. If the result type is unchanged from the argument type, none
of the type parameters in tparams occurred in the type.
If typ is a generic function, type parameters held with typ are not changed and
must be updated separately if desired.
The positions is only used for debug traces.</p>
               
               <pre><code class="language-go">func (check *Checker) renameTParams(pos syntax.Pos, tparams []*TypeParam, typ Type) ([]*TypeParam, Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="replaceRecvType" data-name="replaceRecvType">
               <h3>
                  replaceRecvType 
                  <span class="badge">function</span>
                  
                  <a href="#replaceRecvType" class="anchor" title="Link to replaceRecvType">#</a>
               </h3>
               
               <p>replaceRecvType updates any function receivers that have type old to have
type new. It does not modify the input slice; if modifications are required,
the input slice and any affected signatures will be copied before mutating.
The resulting out slice contains the updated functions, and copied reports
if anything was modified.</p>
               
               <pre><code class="language-go">func replaceRecvType(in []*Func, old Type, new Type) (out []*Func, copied bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="report" data-name="report">
               <h3>
                  report 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#report" class="anchor" title="Link to report">#</a>
               </h3>
               
               <p>report reports the error err, setting check.firstError if necessary.</p>
               
               <pre><code class="language-go">func (err *error_) report()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reportCycle" data-name="reportCycle">
               <h3>
                  reportCycle 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reportCycle" class="anchor" title="Link to reportCycle">#</a>
               </h3>
               
               <p>reportCycle reports an error for the given cycle.</p>
               
               <pre><code class="language-go">func (check *Checker) reportCycle(cycle []Object)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reportInstanceLoop" data-name="reportInstanceLoop">
               <h3>
                  reportInstanceLoop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reportInstanceLoop" class="anchor" title="Link to reportInstanceLoop">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) reportInstanceLoop(v int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="representable" data-name="representable">
               <h3>
                  representable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#representable" class="anchor" title="Link to representable">#</a>
               </h3>
               
               <p>representable checks that a constant operand is representable in the given
basic type.</p>
               
               <pre><code class="language-go">func (check *Checker) representable(x *operand, typ *Basic)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="representableConst" data-name="representableConst">
               <h3>
                  representableConst 
                  <span class="badge">function</span>
                  
                  <a href="#representableConst" class="anchor" title="Link to representableConst">#</a>
               </h3>
               
               <p>representableConst reports whether x can be represented as
value of the given basic type and for the configuration
provided (only needed for int/uint sizes).
If rounded != nil, *rounded is set to the rounded value of x for
representable floating-point and complex values, and to an Int
value for integer values; it is left alone otherwise.
It is ok to provide the addressof the first argument for rounded.
The check parameter may be nil if representableConst is invoked
(indirectly) through an exported API call (AssignableTo, ConvertibleTo)
because we don't need the Checker's config for those calls.</p>
               
               <pre><code class="language-go">func representableConst(x constant.Value, check *Checker, typ *Basic, rounded *constant.Value) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="representation" data-name="representation">
               <h3>
                  representation 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#representation" class="anchor" title="Link to representation">#</a>
               </h3>
               
               <p>representation returns the representation of the constant operand x as the
basic type typ.
If no such representation is possible, it returns a non-zero error code.</p>
               
               <pre><code class="language-go">func (check *Checker) representation(x *operand, typ *Basic) (constant.Value, Code)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolve" data-name="resolve">
               <h3>
                  resolve 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#resolve" class="anchor" title="Link to resolve">#</a>
               </h3>
               
               <p>resolve resolves the type parameters, methods, and underlying type of n.
This information may be loaded from a provided loader function, or computed
from an origin type (in the case of instances).
After resolution, the type parameters, methods, and underlying type of n are
accessible; but if n is an instantiated type, its methods may still be
unexpanded.</p>
               
               <pre><code class="language-go">func (n *Named) resolve() *Named</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolve" data-name="resolve">
               <h3>
                  resolve 
                  <span class="badge">function</span>
                  
                  <a href="#resolve" class="anchor" title="Link to resolve">#</a>
               </h3>
               
               <p>resolve returns the Object represented by obj, resolving lazy
objects as appropriate.</p>
               
               <pre><code class="language-go">func resolve(name string, obj Object) Object</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveBaseTypeName" data-name="resolveBaseTypeName">
               <h3>
                  resolveBaseTypeName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#resolveBaseTypeName" class="anchor" title="Link to resolveBaseTypeName">#</a>
               </h3>
               
               <p>resolveBaseTypeName returns the non-alias base type name for the given name, and whether
there was a pointer indirection to get to it. The base type name must be declared
in package scope, and there can be at most one pointer indirection. Traversals
through generic alias types are not permitted. If no such type name exists, the
returned base is nil.</p>
               
               <pre><code class="language-go">func (check *Checker) resolveBaseTypeName(ptr bool, name *syntax.Name) (ptr_ bool, base *TypeName)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="returnError" data-name="returnError">
               <h3>
                  returnError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#returnError" class="anchor" title="Link to returnError">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) returnError(at poser, lhs []*Var, rhs []*operand)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="roundFloat32" data-name="roundFloat32">
               <h3>
                  roundFloat32 
                  <span class="badge">function</span>
                  
                  <a href="#roundFloat32" class="anchor" title="Link to roundFloat32">#</a>
               </h3>
               
               <pre><code class="language-go">func roundFloat32(x constant.Value) constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="roundFloat64" data-name="roundFloat64">
               <h3>
                  roundFloat64 
                  <span class="badge">function</span>
                  
                  <a href="#roundFloat64" class="anchor" title="Link to roundFloat64">#</a>
               </h3>
               
               <pre><code class="language-go">func roundFloat64(x constant.Value) constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="safeUnderlying" data-name="safeUnderlying">
               <h3>
                  safeUnderlying 
                  <span class="badge">function</span>
                  
                  <a href="#safeUnderlying" class="anchor" title="Link to safeUnderlying">#</a>
               </h3>
               
               <p>safeUnderlying returns the underlying type of typ without expanding
instances, to avoid infinite recursion.
TODO(rfindley): eliminate this function or give it a better name.</p>
               
               <pre><code class="language-go">func safeUnderlying(typ Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sameId" data-name="sameId">
               <h3>
                  sameId 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sameId" class="anchor" title="Link to sameId">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) sameId(*Package, string, bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sameId" data-name="sameId">
               <h3>
                  sameId 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sameId" class="anchor" title="Link to sameId">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *object) sameId(pkg *Package, name string, foldCase bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="samePkg" data-name="samePkg">
               <h3>
                  samePkg 
                  <span class="badge">function</span>
                  
                  <a href="#samePkg" class="anchor" title="Link to samePkg">#</a>
               </h3>
               
               <p>samePkg reports whether packages a and b are the same.</p>
               
               <pre><code class="language-go">func samePkg(a *Package, b *Package) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scopePos" data-name="scopePos">
               <h3>
                  scopePos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scopePos" class="anchor" title="Link to scopePos">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *object) scopePos() syntax.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scopePos" data-name="scopePos">
               <h3>
                  scopePos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scopePos" class="anchor" title="Link to scopePos">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) scopePos() syntax.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="selector" data-name="selector">
               <h3>
                  selector 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#selector" class="anchor" title="Link to selector">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) selector(x *operand, e *syntax.SelectorExpr, def *TypeName, wantType bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="set" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#set" class="anchor" title="Link to set">#</a>
               </h3>
               
               <p>set sets the type t for type parameter x;
t must not be nil.</p>
               
               <pre><code class="language-go">func (u *unifier) set(x *TypeParam, t Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setColor" data-name="setColor">
               <h3>
                  setColor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setColor" class="anchor" title="Link to setColor">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) setColor(color color)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setColor" data-name="setColor">
               <h3>
                  setColor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setColor" class="anchor" title="Link to setColor">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *object) setColor(color color)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setConst" data-name="setConst">
               <h3>
                  setConst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setConst" class="anchor" title="Link to setConst">#</a>
               </h3>
               
               <p>setConst sets x to the untyped constant for literal lit.</p>
               
               <pre><code class="language-go">func (x *operand) setConst(k syntax.LitKind, lit string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setDefType" data-name="setDefType">
               <h3>
                  setDefType 
                  <span class="badge">function</span>
                  
                  <a href="#setDefType" class="anchor" title="Link to setDefType">#</a>
               </h3>
               
               <pre><code class="language-go">func setDefType(def *TypeName, typ Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setHandle" data-name="setHandle">
               <h3>
                  setHandle 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setHandle" class="anchor" title="Link to setHandle">#</a>
               </h3>
               
               <p>setHandle sets the handle for type parameter x
(and all its joined type parameters) to h.</p>
               
               <pre><code class="language-go">func (u *unifier) setHandle(x *TypeParam, h *Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setOrder" data-name="setOrder">
               <h3>
                  setOrder 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setOrder" class="anchor" title="Link to setOrder">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) setOrder(uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setOrder" data-name="setOrder">
               <h3>
                  setOrder 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setOrder" class="anchor" title="Link to setOrder">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *object) setOrder(order uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setParent" data-name="setParent">
               <h3>
                  setParent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setParent" class="anchor" title="Link to setParent">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *object) setParent(parent *Scope)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setParent" data-name="setParent">
               <h3>
                  setParent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setParent" class="anchor" title="Link to setParent">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) setParent(*Scope)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setScopePos" data-name="setScopePos">
               <h3>
                  setScopePos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setScopePos" class="anchor" title="Link to setScopePos">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) setScopePos(syntax.Pos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setScopePos" data-name="setScopePos">
               <h3>
                  setScopePos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setScopePos" class="anchor" title="Link to setScopePos">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *object) setScopePos(pos syntax.Pos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setState" data-name="setState">
               <h3>
                  setState 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setState" class="anchor" title="Link to setState">#</a>
               </h3>
               
               <p>setState atomically stores the given state for n.
Must only be called while holding n.mu.</p>
               
               <pre><code class="language-go">func (n *Named) setState(state namedState)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setType" data-name="setType">
               <h3>
                  setType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setType" class="anchor" title="Link to setType">#</a>
               </h3>
               
               <pre><code class="language-go">func (*lazyObject) setType(Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setType" data-name="setType">
               <h3>
                  setType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setType" class="anchor" title="Link to setType">#</a>
               </h3>
               
               <pre><code class="language-go">func (obj *object) setType(typ Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shift" data-name="shift">
               <h3>
                  shift 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shift" class="anchor" title="Link to shift">#</a>
               </h3>
               
               <p>If e != nil, it must be the shift expression; it may be nil for non-constant shifts.</p>
               
               <pre><code class="language-go">func (check *Checker) shift(x *operand, y *operand, e syntax.Expr, op syntax.Operator)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shortVarDecl" data-name="shortVarDecl">
               <h3>
                  shortVarDecl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shortVarDecl" class="anchor" title="Link to shortVarDecl">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) shortVarDecl(pos poser, lhs []syntax.Expr, rhs []syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="signature" data-name="signature">
               <h3>
                  signature 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#signature" class="anchor" title="Link to signature">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *typeWriter) signature(sig *Signature)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="simpleStmt" data-name="simpleStmt">
               <h3>
                  simpleStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#simpleStmt" class="anchor" title="Link to simpleStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) simpleStmt(s syntax.Stmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="singleIndex" data-name="singleIndex">
               <h3>
                  singleIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#singleIndex" class="anchor" title="Link to singleIndex">#</a>
               </h3>
               
               <p>singleIndex returns the (single) index from the index expression e.
If the index is missing, or if there are multiple indices, an error
is reported and the result is nil.</p>
               
               <pre><code class="language-go">func (check *Checker) singleIndex(e *syntax.IndexExpr) syntax.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="singleValue" data-name="singleValue">
               <h3>
                  singleValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#singleValue" class="anchor" title="Link to singleValue">#</a>
               </h3>
               
               <p>singleValue reports an error if x describes a tuple and sets x.mode to invalid.</p>
               
               <pre><code class="language-go">func (check *Checker) singleValue(x *operand)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sizeof" data-name="sizeof">
               <h3>
                  sizeof 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sizeof" class="anchor" title="Link to sizeof">#</a>
               </h3>
               
               <p>sizeof returns the size of T.
If T is too large, the result is negative.</p>
               
               <pre><code class="language-go">func (conf *Config) sizeof(T Type) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sliceExpr" data-name="sliceExpr">
               <h3>
                  sliceExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sliceExpr" class="anchor" title="Link to sliceExpr">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) sliceExpr(x *operand, e *syntax.SliceExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="softErrorf" data-name="softErrorf">
               <h3>
                  softErrorf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#softErrorf" class="anchor" title="Link to softErrorf">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) softErrorf(at poser, code Code, format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sortMethods" data-name="sortMethods">
               <h3>
                  sortMethods 
                  <span class="badge">function</span>
                  
                  <a href="#sortMethods" class="anchor" title="Link to sortMethods">#</a>
               </h3>
               
               <pre><code class="language-go">func sortMethods(list []*Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sprintf" data-name="sprintf">
               <h3>
                  sprintf 
                  <span class="badge">function</span>
                  
                  <a href="#sprintf" class="anchor" title="Link to sprintf">#</a>
               </h3>
               
               <pre><code class="language-go">func sprintf(qf Qualifier, tpSubscripts bool, format string, args ...any) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sprintf" data-name="sprintf">
               <h3>
                  sprintf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sprintf" class="anchor" title="Link to sprintf">#</a>
               </h3>
               
               <p>check may be nil.</p>
               
               <pre><code class="language-go">func (check *Checker) sprintf(format string, args ...any) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="srcimporter_setUsesCgo" data-name="srcimporter_setUsesCgo">
               <h3>
                  srcimporter_setUsesCgo 
                  <span class="badge">function</span>
                  
                  <a href="#srcimporter_setUsesCgo" class="anchor" title="Link to srcimporter_setUsesCgo">#</a>
               </h3>
               
               <pre><code class="language-go">func srcimporter_setUsesCgo(conf *Config)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startPos" data-name="startPos">
               <h3>
                  startPos 
                  <span class="badge">function</span>
                  
                  <a href="#startPos" class="anchor" title="Link to startPos">#</a>
               </h3>
               
               <p>startPos returns the start position of node n.</p>
               
               <pre><code class="language-go">func startPos(n syntax.Node) syntax.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="state" data-name="state">
               <h3>
                  state 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#state" class="anchor" title="Link to state">#</a>
               </h3>
               
               <p>state atomically accesses the current state of the receiver.</p>
               
               <pre><code class="language-go">func (n *Named) state() namedState</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmt" data-name="stmt">
               <h3>
                  stmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmt" class="anchor" title="Link to stmt">#</a>
               </h3>
               
               <p>stmt typechecks statement s.</p>
               
               <pre><code class="language-go">func (check *Checker) stmt(ctxt stmtContext, s syntax.Stmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmtList" data-name="stmtList">
               <h3>
                  stmtList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmtList" class="anchor" title="Link to stmtList">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) stmtList(ctxt stmtContext, list []syntax.Stmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="string" data-name="string">
               <h3>
                  string 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#string" class="anchor" title="Link to string">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *typeWriter) string(s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stripAnnotations" data-name="stripAnnotations">
               <h3>
                  stripAnnotations 
                  <span class="badge">function</span>
                  
                  <a href="#stripAnnotations" class="anchor" title="Link to stripAnnotations">#</a>
               </h3>
               
               <p>stripAnnotations removes internal (type) annotations from s.</p>
               
               <pre><code class="language-go">func stripAnnotations(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="structType" data-name="structType">
               <h3>
                  structType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#structType" class="anchor" title="Link to structType">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) structType(styp *Struct, e *syntax.StructType)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subscript" data-name="subscript">
               <h3>
                  subscript 
                  <span class="badge">function</span>
                  
                  <a href="#subscript" class="anchor" title="Link to subscript">#</a>
               </h3>
               
               <p>subscript returns the decimal (utf8) representation of x using subscript digits.</p>
               
               <pre><code class="language-go">func subscript(x uint64) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subsetOf" data-name="subsetOf">
               <h3>
                  subsetOf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#subsetOf" class="anchor" title="Link to subsetOf">#</a>
               </h3>
               
               <p>subsetOf reports whether s1 ⊆ s2.</p>
               
               <pre><code class="language-go">func (s1 *_TypeSet) subsetOf(s2 *_TypeSet) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subsetOf" data-name="subsetOf">
               <h3>
                  subsetOf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#subsetOf" class="anchor" title="Link to subsetOf">#</a>
               </h3>
               
               <p>subsetOf reports whether x ⊆ y.</p>
               
               <pre><code class="language-go">func (x *term) subsetOf(y *term) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subsetOf" data-name="subsetOf">
               <h3>
                  subsetOf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#subsetOf" class="anchor" title="Link to subsetOf">#</a>
               </h3>
               
               <p>subsetOf reports whether xl ⊆ yl.</p>
               
               <pre><code class="language-go">func (xl termlist) subsetOf(yl termlist) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subst" data-name="subst">
               <h3>
                  subst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#subst" class="anchor" title="Link to subst">#</a>
               </h3>
               
               <p>subst returns the type typ with its type parameters tpars replaced by the
corresponding type arguments targs, recursively. subst doesn't modify the
incoming type. If a substitution took place, the result type is different
from the incoming type.
If expanding is non-nil, it is the instance type currently being expanded.
One of expanding or ctxt must be non-nil.</p>
               
               <pre><code class="language-go">func (check *Checker) subst(pos syntax.Pos, typ Type, smap substMap, expanding *Named, ctxt *Context) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="substList" data-name="substList">
               <h3>
                  substList 
                  <span class="badge">function</span>
                  
                  <a href="#substList" class="anchor" title="Link to substList">#</a>
               </h3>
               
               <p>substList applies subst to each element of the incoming slice.
If at least one element changes, the result is a new slice with
all the (possibly updated) elements of the incoming slice;
otherwise the result it nil. The incoming slice is unchanged.</p>
               
               <pre><code class="language-go">func substList(in []T, subst func(T) T) (out []T)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="supersetOf" data-name="supersetOf">
               <h3>
                  supersetOf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#supersetOf" class="anchor" title="Link to supersetOf">#</a>
               </h3>
               
               <p>supersetOf reports whether y ⊆ xl.</p>
               
               <pre><code class="language-go">func (xl termlist) supersetOf(y *term) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="suspendedCall" data-name="suspendedCall">
               <h3>
                  suspendedCall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#suspendedCall" class="anchor" title="Link to suspendedCall">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) suspendedCall(keyword string, call syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="switchStmt" data-name="switchStmt">
               <h3>
                  switchStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#switchStmt" class="anchor" title="Link to switchStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) switchStmt(inner stmtContext, s *syntax.SwitchStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tParamList" data-name="tParamList">
               <h3>
                  tParamList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tParamList" class="anchor" title="Link to tParamList">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *typeWriter) tParamList(list []*TypeParam)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tag" data-name="tag">
               <h3>
                  tag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tag" class="anchor" title="Link to tag">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) tag(t *syntax.BasicLit) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tail" data-name="tail">
               <h3>
                  tail 
                  <span class="badge">function</span>
                  
                  <a href="#tail" class="anchor" title="Link to tail">#</a>
               </h3>
               
               <p>tail returns the string s without its first (UTF-8) character.
If len(s) == 0, the result is s.</p>
               
               <pre><code class="language-go">func tail(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="term" data-name="term">
               <h3>
                  term 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#term" class="anchor" title="Link to term">#</a>
               </h3>
               
               <pre><code class="language-go">func (subst *subster) term(t *Term) *Term</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trace" data-name="trace">
               <h3>
                  trace 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#trace" class="anchor" title="Link to trace">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) trace(pos syntax.Pos, format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tracef" data-name="tracef">
               <h3>
                  tracef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tracef" class="anchor" title="Link to tracef">#</a>
               </h3>
               
               <pre><code class="language-go">func (u *unifier) tracef(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimTrailingEmptyStmts" data-name="trimTrailingEmptyStmts">
               <h3>
                  trimTrailingEmptyStmts 
                  <span class="badge">function</span>
                  
                  <a href="#trimTrailingEmptyStmts" class="anchor" title="Link to trimTrailingEmptyStmts">#</a>
               </h3>
               
               <pre><code class="language-go">func trimTrailingEmptyStmts(list []syntax.Stmt) []syntax.Stmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tuple" data-name="tuple">
               <h3>
                  tuple 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tuple" class="anchor" title="Link to tuple">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *typeWriter) tuple(tup *Tuple, variadic bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tuple" data-name="tuple">
               <h3>
                  tuple 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tuple" class="anchor" title="Link to tuple">#</a>
               </h3>
               
               <pre><code class="language-go">func (subst *subster) tuple(t *Tuple) *Tuple</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typ" data-name="typ">
               <h3>
                  typ 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typ" class="anchor" title="Link to typ">#</a>
               </h3>
               
               <pre><code class="language-go">func (subst *subster) typ(typ Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typ" data-name="typ">
               <h3>
                  typ 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typ" class="anchor" title="Link to typ">#</a>
               </h3>
               
               <p>typ type-checks the type expression e and returns its type, or Typ[Invalid].
The type must not be an (uninstantiated) generic type.</p>
               
               <pre><code class="language-go">func (check *Checker) typ(e syntax.Expr) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typ" data-name="typ">
               <h3>
                  typ 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typ" class="anchor" title="Link to typ">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *cycleFinder) typ(typ Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typ" data-name="typ">
               <h3>
                  typ 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typ" class="anchor" title="Link to typ">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *typeWriter) typ(typ Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typInternal" data-name="typInternal">
               <h3>
                  typInternal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typInternal" class="anchor" title="Link to typInternal">#</a>
               </h3>
               
               <p>typInternal drives type checking of types.
Must only be called by definedType or genericType.</p>
               
               <pre><code class="language-go">func (check *Checker) typInternal(e0 syntax.Expr, def *TypeName) (T Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typOrNil" data-name="typOrNil">
               <h3>
                  typOrNil 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typOrNil" class="anchor" title="Link to typOrNil">#</a>
               </h3>
               
               <p>typOrNil is like typ but if the argument is nil it is replaced with Typ[Invalid].
A nil type may appear in pathological cases such as type T[P any] []func(_ T([]_))
where an array/slice element is accessed before it is set up.</p>
               
               <pre><code class="language-go">func (subst *subster) typOrNil(typ Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeAssertion" data-name="typeAssertion">
               <h3>
                  typeAssertion 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeAssertion" class="anchor" title="Link to typeAssertion">#</a>
               </h3>
               
               <p>typeAssertion checks x.(T). The type of x must be an interface.</p>
               
               <pre><code class="language-go">func (check *Checker) typeAssertion(e syntax.Expr, x *operand, T Type, typeSwitch bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeDecl" data-name="typeDecl">
               <h3>
                  typeDecl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeDecl" class="anchor" title="Link to typeDecl">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) typeDecl(obj *TypeName, tdecl *syntax.TypeDecl, def *TypeName)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeList" data-name="typeList">
               <h3>
                  typeList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeList" class="anchor" title="Link to typeList">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *typeWriter) typeList(list []Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeList" data-name="typeList">
               <h3>
                  typeList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeList" class="anchor" title="Link to typeList">#</a>
               </h3>
               
               <p>typeList provides the list of types corresponding to the incoming expression list.
If an error occurred, the result is nil, but all list elements were type-checked.</p>
               
               <pre><code class="language-go">func (check *Checker) typeList(list []syntax.Expr) []Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeName" data-name="typeName">
               <h3>
                  typeName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeName" class="anchor" title="Link to typeName">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *typeWriter) typeName(obj *TypeName)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeParamVertex" data-name="typeParamVertex">
               <h3>
                  typeParamVertex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeParamVertex" class="anchor" title="Link to typeParamVertex">#</a>
               </h3>
               
               <p>typeParamVertex returns the index of the vertex representing tpar.</p>
               
               <pre><code class="language-go">func (w *monoGraph) typeParamVertex(tpar *TypeParam) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeParamsString" data-name="typeParamsString">
               <h3>
                  typeParamsString 
                  <span class="badge">function</span>
                  
                  <a href="#typeParamsString" class="anchor" title="Link to typeParamsString">#</a>
               </h3>
               
               <p>typeParamsString produces a string containing all the type parameter names
in list suitable for human consumption.</p>
               
               <pre><code class="language-go">func typeParamsString(list []*TypeParam) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeSet" data-name="typeSet">
               <h3>
                  typeSet 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeSet" class="anchor" title="Link to typeSet">#</a>
               </h3>
               
               <p>typeSet returns the type set for interface t.</p>
               
               <pre><code class="language-go">func (t *Interface) typeSet() *_TypeSet</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeSet" data-name="typeSet">
               <h3>
                  typeSet 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeSet" class="anchor" title="Link to typeSet">#</a>
               </h3>
               
               <p>typeSet writes a canonical hash for an interface type set.</p>
               
               <pre><code class="language-go">func (w *typeWriter) typeSet(s *_TypeSet)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeSwitchStmt" data-name="typeSwitchStmt">
               <h3>
                  typeSwitchStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeSwitchStmt" class="anchor" title="Link to typeSwitchStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) typeSwitchStmt(inner stmtContext, s *syntax.SwitchStmt, guard *syntax.TypeSwitchGuard)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typesSummary" data-name="typesSummary">
               <h3>
                  typesSummary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typesSummary" class="anchor" title="Link to typesSummary">#</a>
               </h3>
               
               <p>typesSummary returns a string of the form "(t1, t2, ...)" where the
ti's are user-friendly string representations for the given types.
If variadic is set and the last type is a slice, its string is of
the form "...E" where E is the slice's element type.
If hasDots is set, the last argument string is of the form "T..."
where T is the last type.
Only one of variadic and hasDots may be set.</p>
               
               <pre><code class="language-go">func (check *Checker) typesSummary(list []Type, variadic bool, hasDots bool) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeset" data-name="typeset">
               <h3>
                  typeset 
                  <span class="badge">function</span>
                  
                  <a href="#typeset" class="anchor" title="Link to typeset">#</a>
               </h3>
               
               <p>typeset is an iterator over the (type/underlying type) pairs of the
specific type terms of the type set implied by t.
If t is a type parameter, the implied type set is the type set of t's constraint.
In that case, if there are no specific terms, typeset calls yield with (nil, nil).
If t is not a type parameter, the implied type set consists of just t.
In any case, typeset is guaranteed to call yield at least once.</p>
               
               <pre><code class="language-go">func typeset(t Type, yield func(t Type, u Type) bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeset" data-name="typeset">
               <h3>
                  typeset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeset" class="anchor" title="Link to typeset">#</a>
               </h3>
               
               <p>typeset is an iterator over the (type/underlying type) pairs of the
specific type terms of t's constraint.
If there are no specific terms, typeset calls yield with (nil, nil).
In any case, typeset is guaranteed to call yield at least once.</p>
               
               <pre><code class="language-go">func (t *TypeParam) typeset(yield func(t Type, u Type) bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeset" data-name="typeset">
               <h3>
                  typeset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeset" class="anchor" title="Link to typeset">#</a>
               </h3>
               
               <p>typeset is an iterator over the (type/underlying type) pairs in s.
If s has no specific terms, typeset calls yield with (nil, nil).
In any case, typeset is guaranteed to call yield at least once.</p>
               
               <pre><code class="language-go">func (s *_TypeSet) typeset(yield func(t Type, u Type) bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unalias" data-name="unalias">
               <h3>
                  unalias 
                  <span class="badge">function</span>
                  
                  <a href="#unalias" class="anchor" title="Link to unalias">#</a>
               </h3>
               
               <pre><code class="language-go">func unalias(a0 *Alias) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unary" data-name="unary">
               <h3>
                  unary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unary" class="anchor" title="Link to unary">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) unary(x *operand, e *syntax.Operation)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="under" data-name="under">
               <h3>
                  under 
                  <span class="badge">function</span>
                  
                  <a href="#under" class="anchor" title="Link to under">#</a>
               </h3>
               
               <p>under returns the true expanded underlying type.
If it doesn't exist, the result is Typ[Invalid].
under must only be called when a type is known
to be fully set up.</p>
               
               <pre><code class="language-go">func under(t Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="under" data-name="under">
               <h3>
                  under 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#under" class="anchor" title="Link to under">#</a>
               </h3>
               
               <p>under returns the expanded underlying type of n0; possibly by following
forward chains of named types. If an underlying type is found, resolve
the chain by setting the underlying type for each defined type in the
chain before returning it. If no underlying type is found or a cycle
is detected, the result is Typ[Invalid]. If a cycle is detected and
n0.check != nil, the cycle is reported.
This is necessary because the underlying type of named may be itself a
named type that is incomplete:
type (
A B
B *C
C A
)
The type of C is the (named) type of A which is incomplete,
and which has as its underlying type the named type B.</p>
               
               <pre><code class="language-go">func (n0 *Named) under() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="underIs" data-name="underIs">
               <h3>
                  underIs 
                  <span class="badge">function</span>
                  
                  <a href="#underIs" class="anchor" title="Link to underIs">#</a>
               </h3>
               
               <p>If typ is a type parameter, underIs returns the result of typ.underIs(f).
Otherwise, underIs returns the result of f(under(typ)).</p>
               
               <pre><code class="language-go">func underIs(typ Type, f func(Type) bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unify" data-name="unify">
               <h3>
                  unify 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unify" class="anchor" title="Link to unify">#</a>
               </h3>
               
               <p>unify attempts to unify x and y and reports whether it succeeded.
As a side-effect, types may be inferred for type parameters.
The mode parameter controls how types are compared.</p>
               
               <pre><code class="language-go">func (u *unifier) unify(x Type, y Type, mode unifyMode) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="union" data-name="union">
               <h3>
                  union 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#union" class="anchor" title="Link to union">#</a>
               </h3>
               
               <p>union returns the union xl ∪ yl.</p>
               
               <pre><code class="language-go">func (xl termlist) union(yl termlist) termlist</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="union" data-name="union">
               <h3>
                  union 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#union" class="anchor" title="Link to union">#</a>
               </h3>
               
               <p>union returns the union x ∪ y: zero, one, or two non-nil terms.</p>
               
               <pre><code class="language-go">func (x *term) union(y *term) (_ *term, _ *term)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unknowns" data-name="unknowns">
               <h3>
                  unknowns 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unknowns" class="anchor" title="Link to unknowns">#</a>
               </h3>
               
               <p>unknowns returns the number of type parameters for which no type has been set yet.</p>
               
               <pre><code class="language-go">func (u *unifier) unknowns() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unpackRecv" data-name="unpackRecv">
               <h3>
                  unpackRecv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unpackRecv" class="anchor" title="Link to unpackRecv">#</a>
               </h3>
               
               <p>unpackRecv unpacks a receiver type expression and returns its components: ptr indicates
whether rtyp is a pointer receiver, base is the receiver base type expression stripped
of its type parameters (if any), and tparams are its type parameter names, if any. The
type parameters are only unpacked if unpackParams is set. For instance, given the rtyp
*T[A, _]
ptr is true, base is T, and tparams is [A, _] (assuming unpackParams is set).
Note that base may not be a *syntax.Name for erroneous programs.</p>
               
               <pre><code class="language-go">func (check *Checker) unpackRecv(rtyp syntax.Expr, unpackParams bool) (ptr bool, base syntax.Expr, tparams []*syntax.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unpointer" data-name="unpointer">
               <h3>
                  unpointer 
                  <span class="badge">function</span>
                  
                  <a href="#unpointer" class="anchor" title="Link to unpointer">#</a>
               </h3>
               
               <pre><code class="language-go">func unpointer(t Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unusedImports" data-name="unusedImports">
               <h3>
                  unusedImports 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unusedImports" class="anchor" title="Link to unusedImports">#</a>
               </h3>
               
               <p>unusedImports checks for unused imports.</p>
               
               <pre><code class="language-go">func (check *Checker) unusedImports()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="update" data-name="update">
               <h3>
                  update 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#update" class="anchor" title="Link to update">#</a>
               </h3>
               
               <p>update de-duplicates inst against previously seen types with the hash h.
If an identical type is found with the type hash h, the previously seen
type is returned. Otherwise, inst is returned, and recorded in the Context
for the hash h.</p>
               
               <pre><code class="language-go">func (ctxt *Context) update(h string, orig Type, targs []Type, inst Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateExprType" data-name="updateExprType">
               <h3>
                  updateExprType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#updateExprType" class="anchor" title="Link to updateExprType">#</a>
               </h3>
               
               <p>updateExprType updates the type of x to typ and invokes itself
recursively for the operands of x, depending on expression kind.
If typ is still an untyped and not the final type, updateExprType
only updates the recorded untyped type for x and possibly its
operands. Otherwise (i.e., typ is not an untyped type anymore,
or it is the final type for x), the type and value are recorded.
Also, if x is a constant, it must be representable as a value of typ,
and if x is the (formerly untyped) lhs operand of a non-constant
shift, it must be an integer value.</p>
               
               <pre><code class="language-go">func (check *Checker) updateExprType(x syntax.Expr, typ Type, final bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateExprVal" data-name="updateExprVal">
               <h3>
                  updateExprVal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#updateExprVal" class="anchor" title="Link to updateExprVal">#</a>
               </h3>
               
               <p>updateExprVal updates the value of x to val.</p>
               
               <pre><code class="language-go">func (check *Checker) updateExprVal(x syntax.Expr, val constant.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="usage" data-name="usage">
               <h3>
                  usage 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#usage" class="anchor" title="Link to usage">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) usage(scope *Scope)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="use" data-name="use">
               <h3>
                  use 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#use" class="anchor" title="Link to use">#</a>
               </h3>
               
               <p>use type-checks each argument.
Useful to make sure expressions are evaluated
(and variables are "used") in the presence of
other errors. Arguments may be nil.
Reports if all arguments evaluated without error.</p>
               
               <pre><code class="language-go">func (check *Checker) use(args ...syntax.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="use1" data-name="use1">
               <h3>
                  use1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#use1" class="anchor" title="Link to use1">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) use1(e syntax.Expr, lhs bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="useLHS" data-name="useLHS">
               <h3>
                  useLHS 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#useLHS" class="anchor" title="Link to useLHS">#</a>
               </h3>
               
               <p>useLHS is like use, but doesn't "use" top-level identifiers.
It should be called instead of use if the arguments are
expressions on the lhs of an assignment.</p>
               
               <pre><code class="language-go">func (check *Checker) useLHS(args ...syntax.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="useN" data-name="useN">
               <h3>
                  useN 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#useN" class="anchor" title="Link to useN">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) useN(args []syntax.Expr, lhs bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validAlias" data-name="validAlias">
               <h3>
                  validAlias 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#validAlias" class="anchor" title="Link to validAlias">#</a>
               </h3>
               
               <p>validAlias records that alias has the valid type typ (possibly Typ[Invalid]).</p>
               
               <pre><code class="language-go">func (check *Checker) validAlias(alias *TypeName, typ Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validCycle" data-name="validCycle">
               <h3>
                  validCycle 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#validCycle" class="anchor" title="Link to validCycle">#</a>
               </h3>
               
               <p>validCycle reports whether the cycle starting with obj is valid and
reports an error if it is not.</p>
               
               <pre><code class="language-go">func (check *Checker) validCycle(obj Object) (valid bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validRecv" data-name="validRecv">
               <h3>
                  validRecv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#validRecv" class="anchor" title="Link to validRecv">#</a>
               </h3>
               
               <p>validRecv verifies that the receiver satisfies its respective spec requirements
and reports an error otherwise.</p>
               
               <pre><code class="language-go">func (check *Checker) validRecv(pos poser, recv *Var)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validType" data-name="validType">
               <h3>
                  validType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#validType" class="anchor" title="Link to validType">#</a>
               </h3>
               
               <p>validType verifies that the given type does not "expand" indefinitely
producing a cycle in the type graph.
(Cycles involving alias types, as in "type A = [10]A" are detected
earlier, via the objDecl cycle detection mechanism.)</p>
               
               <pre><code class="language-go">func (check *Checker) validType(typ *Named)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validType0" data-name="validType0">
               <h3>
                  validType0 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#validType0" class="anchor" title="Link to validType0">#</a>
               </h3>
               
               <p>validType0 checks if the given type is valid. If typ is a type parameter
its value is looked up in the type argument list of the instantiated
(enclosing) type, if it exists. Otherwise the type parameter must be from
an enclosing function and can be ignored.
The nest list describes the stack (the "nest in memory") of types which
contain (or embed in the case of interfaces) other types. For instance, a
struct named S which contains a field of named type F contains (the memory
of) F in S, leading to the nest S->F. If a type appears in its own nest
(say S->F->S) we have an invalid recursive type. The path list is the full
path of named types in a cycle, it is only needed for error reporting.</p>
               
               <pre><code class="language-go">func (check *Checker) validType0(pos syntax.Pos, typ Type, nest []*Named, path []*Named) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validVarType" data-name="validVarType">
               <h3>
                  validVarType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#validVarType" class="anchor" title="Link to validVarType">#</a>
               </h3>
               
               <p>validVarType reports an error if typ is a constraint interface.
The expression e is used for error reporting, if any.</p>
               
               <pre><code class="language-go">func (check *Checker) validVarType(e syntax.Expr, typ Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validateTArgLen" data-name="validateTArgLen">
               <h3>
                  validateTArgLen 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#validateTArgLen" class="anchor" title="Link to validateTArgLen">#</a>
               </h3>
               
               <p>validateTArgLen checks that the number of type arguments (got) matches the
number of type parameters (want); if they don't match an error is reported.
If validation fails and check is nil, validateTArgLen panics.</p>
               
               <pre><code class="language-go">func (check *Checker) validateTArgLen(pos syntax.Pos, name string, want int, got int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validatedImportPath" data-name="validatedImportPath">
               <h3>
                  validatedImportPath 
                  <span class="badge">function</span>
                  
                  <a href="#validatedImportPath" class="anchor" title="Link to validatedImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func validatedImportPath(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="varDecl" data-name="varDecl">
               <h3>
                  varDecl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#varDecl" class="anchor" title="Link to varDecl">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) varDecl(obj *Var, lhs []*Var, typ syntax.Expr, init syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="varList" data-name="varList">
               <h3>
                  varList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#varList" class="anchor" title="Link to varList">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *cycleFinder) varList(list []*Var)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="varList" data-name="varList">
               <h3>
                  varList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#varList" class="anchor" title="Link to varList">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *tpWalker) varList(list []*Var) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="varType" data-name="varType">
               <h3>
                  varType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#varType" class="anchor" title="Link to varType">#</a>
               </h3>
               
               <p>varType type-checks the type expression e and returns its type, or Typ[Invalid].
The type must not be an (uninstantiated) generic type and it must not be a
constraint interface.</p>
               
               <pre><code class="language-go">func (check *Checker) varType(e syntax.Expr) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="varTypes" data-name="varTypes">
               <h3>
                  varTypes 
                  <span class="badge">function</span>
                  
                  <a href="#varTypes" class="anchor" title="Link to varTypes">#</a>
               </h3>
               
               <p>varTypes returns the list of types for the given variables.</p>
               
               <pre><code class="language-go">func varTypes(list []*Var) (res []Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="var_" data-name="var_">
               <h3>
                  var_ 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#var_" class="anchor" title="Link to var_">#</a>
               </h3>
               
               <pre><code class="language-go">func (subst *subster) var_(v *Var) *Var</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="verify" data-name="verify">
               <h3>
                  verify 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#verify" class="anchor" title="Link to verify">#</a>
               </h3>
               
               <p>check may be nil; pos is used only if check is non-nil.</p>
               
               <pre><code class="language-go">func (check *Checker) verify(pos syntax.Pos, tparams []*TypeParam, targs []Type, ctxt *Context) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="verifyVersionf" data-name="verifyVersionf">
               <h3>
                  verifyVersionf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#verifyVersionf" class="anchor" title="Link to verifyVersionf">#</a>
               </h3>
               
               <p>verifyVersionf is like allowVersion but also accepts a format string and arguments
which are used to report a version error if allowVersion returns false.</p>
               
               <pre><code class="language-go">func (check *Checker) verifyVersionf(at poser, v goVersion, format string, args ...interface{}) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="versionErrorf" data-name="versionErrorf">
               <h3>
                  versionErrorf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#versionErrorf" class="anchor" title="Link to versionErrorf">#</a>
               </h3>
               
               <pre><code class="language-go">func (check *Checker) versionErrorf(at poser, v goVersion, format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="versionMax" data-name="versionMax">
               <h3>
                  versionMax 
                  <span class="badge">function</span>
                  
                  <a href="#versionMax" class="anchor" title="Link to versionMax">#</a>
               </h3>
               
               <pre><code class="language-go">func versionMax(a goVersion, b goVersion) goVersion</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFuncName" data-name="writeFuncName">
               <h3>
                  writeFuncName 
                  <span class="badge">function</span>
                  
                  <a href="#writeFuncName" class="anchor" title="Link to writeFuncName">#</a>
               </h3>
               
               <pre><code class="language-go">func writeFuncName(buf *bytes.Buffer, f *Func, qf Qualifier)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeObject" data-name="writeObject">
               <h3>
                  writeObject 
                  <span class="badge">function</span>
                  
                  <a href="#writeObject" class="anchor" title="Link to writeObject">#</a>
               </h3>
               
               <pre><code class="language-go">func writeObject(buf *bytes.Buffer, obj Object, qf Qualifier)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();

               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);

               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;

               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               // Apply Prism highlighting again
               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>