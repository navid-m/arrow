<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - types2_test</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="cmd_compile_internal_types2_testdata-docs.html">testdata</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>types2_test</code>
         </h1>
         <hr />
         
         <article class="global" data-name="gcSizesTests">
            <h2>gcSizesTests</h2>
            <hr />
            
            <pre><code>gcSizesTests</code></pre>
         </article>
         
         <article class="global" data-name="nopos">
            <h2>nopos</h2>
            <hr />
            
            <p>nopos indicates an unknown position</p>
            
            <pre><code>nopos syntax.Pos</code></pre>
         </article>
         
         <article class="global" data-name="errorfMinArgCount">
            <h2>errorfMinArgCount</h2>
            <hr />
            
            <pre><code>errorfMinArgCount</code></pre>
         </article>
         
         <article class="global" data-name="errorfFormatIndex">
            <h2>errorfFormatIndex</h2>
            <hr />
            
            <pre><code>errorfFormatIndex</code></pre>
         </article>
         
         <article class="global" data-name="goods">
            <h2>goods</h2>
            <hr />
            
            <pre><code>goods</code></pre>
         </article>
         
         <article class="global" data-name="bads">
            <h2>bads</h2>
            <hr />
            
            <pre><code>bads</code></pre>
         </article>
         
         <article class="global" data-name="stdLibImporter">
            <h2>stdLibImporter</h2>
            <hr />
            
            <pre><code>stdLibImporter</code></pre>
         </article>
         
         <article class="global" data-name="excluded">
            <h2>excluded</h2>
            <hr />
            
            <p>Package paths of excluded packages.</p>
            
            <pre><code>excluded</code></pre>
         </article>
         
         <article class="global" data-name="printPackageMu">
            <h2>printPackageMu</h2>
            <hr />
            
            <p>printPackageMu synchronizes the printing of type-checked package files in
the typecheckFiles function.

Without synchronization, package files may be interleaved during concurrent
type-checking.</p>
            
            <pre><code>printPackageMu sync.Mutex</code></pre>
         </article>
         
         <article class="global" data-name="filename">
            <h2>filename</h2>
            <hr />
            
            <pre><code>filename</code></pre>
         </article>
         
         <article class="global" data-name="independentTestTypes">
            <h2>independentTestTypes</h2>
            <hr />
            
            <p>types that don't depend on any other type declarations</p>
            
            <pre><code>independentTestTypes</code></pre>
         </article>
         
         <article class="global" data-name="dependentTestTypes">
            <h2>dependentTestTypes</h2>
            <hr />
            
            <p>types that depend on other type declarations (src in TestTypes)</p>
            
            <pre><code>dependentTestTypes</code></pre>
         </article>
         
         <article class="global" data-name="haltOnError">
            <h2>haltOnError</h2>
            <hr />
            
            <pre><code>haltOnError</code></pre>
         </article>
         
         <article class="global" data-name="verifyErrors">
            <h2>verifyErrors</h2>
            <hr />
            
            <pre><code>verifyErrors</code></pre>
         </article>
         
         <article class="global" data-name="H">
            <h2>H</h2>
            <hr />
            
            <pre><code>H</code></pre>
         </article>
         
         <article class="global" data-name="out">
            <h2>out</h2>
            <hr />
            
            <pre><code>out</code></pre>
         </article>
         
         <article class="global" data-name="testObjects">
            <h2>testObjects</h2>
            <hr />
            
            <pre><code>testObjects</code></pre>
         </article>
         
         <article class="global" data-name="builtinCalls">
            <h2>builtinCalls</h2>
            <hr />
            
            <pre><code>builtinCalls</code></pre>
         </article>
          
         <article class="struct" data-name="importHelper">
            <h2>type importHelper struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pkg *Package
fallback Importer</code></pre>
         </article>
         
         <article class="struct" data-name="gcSizeTest">
            <h2>type gcSizeTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
src string</code></pre>
         </article>
         
         <article class="struct" data-name="recordedInstance">
            <h2>type recordedInstance struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name *syntax.Name
Inst Instance</code></pre>
         </article>
         
         <article class="struct" data-name="stdlibChecker">
            <h2>type stdlibChecker struct</h2>
            <hr />
            
            <p>stdlibChecker implements concurrent type-checking of the packages defined by
dirFiles, which must define a closed set of packages (such as GOROOT/src).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">dirFiles *ast.MapType
mu sync.Mutex
pkgs *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="futurePackage">
            <h2>type futurePackage struct</h2>
            <hr />
            
            <p>A futurePackage is a future result of type-checking.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">done *ast.ChanType
pkg *Package
err error</code></pre>
         </article>
         
         <article class="struct" data-name="walker">
            <h2>type walker struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pkgh func
errh func</code></pre>
         </article>
         
         <article class="struct" data-name="testEntry">
            <h2>type testEntry struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">src string
str string</code></pre>
         </article>
         
         <article class="struct" data-name="gen">
            <h2>type gen struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">bytes.Buffer</code></pre>
         </article>
         
         <article class="struct" data-name="gcimports">
            <h2>type gcimports struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">packages *ast.MapType
lookup func</code></pre>
         </article>
         
         <article class="struct" data-name="resolveTestImporter">
            <h2>type resolveTestImporter struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">importer ImporterFrom
imported *ast.MapType</code></pre>
         </article>
          
         <article class="function" data-name="TestIssue5770">
            <h2>TestIssue5770</h2>
            <hr />
            
            <pre><code>func TestIssue5770(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue5849">
            <h2>TestIssue5849</h2>
            <hr />
            
            <pre><code>func TestIssue5849(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue6413">
            <h2>TestIssue6413</h2>
            <hr />
            
            <pre><code>func TestIssue6413(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue7245">
            <h2>TestIssue7245</h2>
            <hr />
            
            <pre><code>func TestIssue7245(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue7827">
            <h2>TestIssue7827</h2>
            <hr />
            
            <p>This tests that uses of existing vars on the LHS of an assignment
are Uses, not Defs; and also that the (illegal) use of a non-var on
the LHS of an assignment is a Use nonetheless.</p>
            
            <pre><code>func TestIssue7827(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue13898">
            <h2>TestIssue13898</h2>
            <hr />
            
            <p>This tests that the package associated with the types2.Object.Pkg method
is the type's package independent of the order in which the imports are
listed in the sources src1, src2 below.
The actual issue is in go/internal/gcimporter which has a corresponding
test; we leave this test here to verify correct behavior at the go/types
level.</p>
            
            <pre><code>func TestIssue13898(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue22525">
            <h2>TestIssue22525</h2>
            <hr />
            
            <pre><code>func TestIssue22525(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue25627">
            <h2>TestIssue25627</h2>
            <hr />
            
            <pre><code>func TestIssue25627(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue28005">
            <h2>TestIssue28005</h2>
            <hr />
            
            <pre><code>func TestIssue28005(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue28282">
            <h2>TestIssue28282</h2>
            <hr />
            
            <pre><code>func TestIssue28282(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue29029">
            <h2>TestIssue29029</h2>
            <hr />
            
            <pre><code>func TestIssue29029(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue34151">
            <h2>TestIssue34151</h2>
            <hr />
            
            <pre><code>func TestIssue34151(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Import">
            <h2>Import</h2>
            <hr />
            
            <pre><code>func Import(path string) (*Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue34921">
            <h2>TestIssue34921</h2>
            <hr />
            
            <p>TestIssue34921 verifies that we don't update an imported type's underlying
type when resolving an underlying type. Specifically, when determining the
underlying type of b.T (which is the underlying type of a.T, which is int)
we must not set the underlying type of a.T again since that would lead to
a race condition if package b is imported elsewhere, in a package that is
concurrently type-checked.</p>
            
            <pre><code>func TestIssue34921(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue43088">
            <h2>TestIssue43088</h2>
            <hr />
            
            <pre><code>func TestIssue43088(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue44515">
            <h2>TestIssue44515</h2>
            <hr />
            
            <pre><code>func TestIssue44515(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue43124">
            <h2>TestIssue43124</h2>
            <hr />
            
            <pre><code>func TestIssue43124(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue50646">
            <h2>TestIssue50646</h2>
            <hr />
            
            <pre><code>func TestIssue50646(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue55030">
            <h2>TestIssue55030</h2>
            <hr />
            
            <pre><code>func TestIssue55030(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue51093">
            <h2>TestIssue51093</h2>
            <hr />
            
            <pre><code>func TestIssue51093(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue54258">
            <h2>TestIssue54258</h2>
            <hr />
            
            <pre><code>func TestIssue54258(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue59944">
            <h2>TestIssue59944</h2>
            <hr />
            
            <pre><code>func TestIssue59944(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue61931">
            <h2>TestIssue61931</h2>
            <hr />
            
            <pre><code>func TestIssue61931(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue61938">
            <h2>TestIssue61938</h2>
            <hr />
            
            <pre><code>func TestIssue61938(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue63260">
            <h2>TestIssue63260</h2>
            <hr />
            
            <pre><code>func TestIssue63260(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue44410">
            <h2>TestIssue44410</h2>
            <hr />
            
            <pre><code>func TestIssue44410(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue59831">
            <h2>TestIssue59831</h2>
            <hr />
            
            <pre><code>func TestIssue59831(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue64759">
            <h2>TestIssue64759</h2>
            <hr />
            
            <pre><code>func TestIssue64759(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue68334">
            <h2>TestIssue68334</h2>
            <hr />
            
            <pre><code>func TestIssue68334(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue68877">
            <h2>TestIssue68877</h2>
            <hr />
            
            <pre><code>func TestIssue68877(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue69092">
            <h2>TestIssue69092</h2>
            <hr />
            
            <pre><code>func TestIssue69092(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkNamed">
            <h2>BenchmarkNamed</h2>
            <hr />
            
            <pre><code>func BenchmarkNamed(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="mustInstantiate">
            <h2>mustInstantiate</h2>
            <hr />
            
            <pre><code>func mustInstantiate(tb testing.TB, orig Type, targs ...Type) Type</code></pre>
         </article>
         
         <article class="function" data-name="TestFiniteTypeExpansion">
            <h2>TestFiniteTypeExpansion</h2>
            <hr />
            
            <p>Test that types do not expand infinitely, as in go.dev/issue/52715.</p>
            
            <pre><code>func TestFiniteTypeExpansion(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMethodOrdering">
            <h2>TestMethodOrdering</h2>
            <hr />
            
            <p>TestMethodOrdering is a simple test verifying that the indices of methods of
a named type remain the same as long as the same source and AddMethod calls
are presented to the type checker in the same order (go.dev/issue/61298).</p>
            
            <pre><code>func TestMethodOrdering(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSelf">
            <h2>TestSelf</h2>
            <hr />
            
            <pre><code>func TestSelf(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkCheck">
            <h2>BenchmarkCheck</h2>
            <hr />
            
            <pre><code>func BenchmarkCheck(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="runbench">
            <h2>runbench</h2>
            <hr />
            
            <pre><code>func runbench(b *testing.B, path string, ignoreFuncBodies bool, writeInfo bool)</code></pre>
         </article>
         
         <article class="function" data-name="pkgFiles">
            <h2>pkgFiles</h2>
            <hr />
            
            <pre><code>func pkgFiles(path string) ([]*syntax.File, error)</code></pre>
         </article>
         
         <article class="function" data-name="findStructType">
            <h2>findStructType</h2>
            <hr />
            
            <p>findStructType typechecks src and returns the first struct type encountered.</p>
            
            <pre><code>func findStructType(t *testing.T, src string) *types2.Struct</code></pre>
         </article>
         
         <article class="function" data-name="findStructTypeConfig">
            <h2>findStructTypeConfig</h2>
            <hr />
            
            <pre><code>func findStructTypeConfig(t *testing.T, src string, conf *types2.Config) *types2.Struct</code></pre>
         </article>
         
         <article class="function" data-name="TestMultipleSizeUse">
            <h2>TestMultipleSizeUse</h2>
            <hr />
            
            <p>go.dev/issue/16316</p>
            
            <pre><code>func TestMultipleSizeUse(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAlignofNaclSlice">
            <h2>TestAlignofNaclSlice</h2>
            <hr />
            
            <p>go.dev/issue/16464</p>
            
            <pre><code>func TestAlignofNaclSlice(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue16902">
            <h2>TestIssue16902</h2>
            <hr />
            
            <pre><code>func TestIssue16902(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAtomicAlign">
            <h2>TestAtomicAlign</h2>
            <hr />
            
            <p>go.dev/issue/53884.</p>
            
            <pre><code>func TestAtomicAlign(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestGCSizes">
            <h2>TestGCSizes</h2>
            <hr />
            
            <pre><code>func TestGCSizes(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="mustParse">
            <h2>mustParse</h2>
            <hr />
            
            <pre><code>func mustParse(src string) *syntax.File</code></pre>
         </article>
         
         <article class="function" data-name="typecheck">
            <h2>typecheck</h2>
            <hr />
            
            <pre><code>func typecheck(src string, conf *Config, info *Info) (*Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="mustTypecheck">
            <h2>mustTypecheck</h2>
            <hr />
            
            <pre><code>func mustTypecheck(src string, conf *Config, info *Info) *Package</code></pre>
         </article>
         
         <article class="function" data-name="pkgName">
            <h2>pkgName</h2>
            <hr />
            
            <p>pkgName extracts the package name from src, which must contain a package header.</p>
            
            <pre><code>func pkgName(src string) string</code></pre>
         </article>
         
         <article class="function" data-name="TestValuesInfo">
            <h2>TestValuesInfo</h2>
            <hr />
            
            <pre><code>func TestValuesInfo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestTypesInfo">
            <h2>TestTypesInfo</h2>
            <hr />
            
            <pre><code>func TestTypesInfo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInstanceInfo">
            <h2>TestInstanceInfo</h2>
            <hr />
            
            <pre><code>func TestInstanceInfo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="sortedInstances">
            <h2>sortedInstances</h2>
            <hr />
            
            <pre><code>func sortedInstances(m *ast.MapType) instances []recordedInstance</code></pre>
         </article>
         
         <article class="function" data-name="TestDefsInfo">
            <h2>TestDefsInfo</h2>
            <hr />
            
            <pre><code>func TestDefsInfo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUsesInfo">
            <h2>TestUsesInfo</h2>
            <hr />
            
            <pre><code>func TestUsesInfo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestGenericMethodInfo">
            <h2>TestGenericMethodInfo</h2>
            <hr />
            
            <pre><code>func TestGenericMethodInfo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestImplicitsInfo">
            <h2>TestImplicitsInfo</h2>
            <hr />
            
            <pre><code>func TestImplicitsInfo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPkgNameOf">
            <h2>TestPkgNameOf</h2>
            <hr />
            
            <pre><code>func TestPkgNameOf(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="predString">
            <h2>predString</h2>
            <hr />
            
            <pre><code>func predString(tv TypeAndValue) string</code></pre>
         </article>
         
         <article class="function" data-name="TestPredicatesInfo">
            <h2>TestPredicatesInfo</h2>
            <hr />
            
            <pre><code>func TestPredicatesInfo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScopesInfo">
            <h2>TestScopesInfo</h2>
            <hr />
            
            <pre><code>func TestScopesInfo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInitOrderInfo">
            <h2>TestInitOrderInfo</h2>
            <hr />
            
            <pre><code>func TestInitOrderInfo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMultiFileInitOrder">
            <h2>TestMultiFileInitOrder</h2>
            <hr />
            
            <pre><code>func TestMultiFileInitOrder(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestFiles">
            <h2>TestFiles</h2>
            <hr />
            
            <pre><code>func TestFiles(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Import">
            <h2>Import</h2>
            <hr />
            
            <pre><code>func Import(path string) (*Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestSelection">
            <h2>TestSelection</h2>
            <hr />
            
            <pre><code>func TestSelection(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="indexFor">
            <h2>indexFor</h2>
            <hr />
            
            <p>indexFor returns the index into s corresponding to the position pos.</p>
            
            <pre><code>func indexFor(s string, pos syntax.Pos) int</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue8518">
            <h2>TestIssue8518</h2>
            <hr />
            
            <pre><code>func TestIssue8518(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue59603">
            <h2>TestIssue59603</h2>
            <hr />
            
            <pre><code>func TestIssue59603(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLookupFieldOrMethodOnNil">
            <h2>TestLookupFieldOrMethodOnNil</h2>
            <hr />
            
            <pre><code>func TestLookupFieldOrMethodOnNil(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLookupFieldOrMethod">
            <h2>TestLookupFieldOrMethod</h2>
            <hr />
            
            <pre><code>func TestLookupFieldOrMethod(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLookupFieldOrMethod_RecursiveGeneric">
            <h2>TestLookupFieldOrMethod_RecursiveGeneric</h2>
            <hr />
            
            <p>Test for go.dev/issue/52715</p>
            
            <pre><code>func TestLookupFieldOrMethod_RecursiveGeneric(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="newDefined">
            <h2>newDefined</h2>
            <hr />
            
            <p>newDefined creates a new defined type named T with the given underlying type.</p>
            
            <pre><code>func newDefined(underlying Type) *Named</code></pre>
         </article>
         
         <article class="function" data-name="TestConvertibleTo">
            <h2>TestConvertibleTo</h2>
            <hr />
            
            <pre><code>func TestConvertibleTo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAssignableTo">
            <h2>TestAssignableTo</h2>
            <hr />
            
            <pre><code>func TestAssignableTo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIdentical">
            <h2>TestIdentical</h2>
            <hr />
            
            <pre><code>func TestIdentical(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIdentical_issue15173">
            <h2>TestIdentical_issue15173</h2>
            <hr />
            
            <pre><code>func TestIdentical_issue15173(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIdenticalUnions">
            <h2>TestIdenticalUnions</h2>
            <hr />
            
            <pre><code>func TestIdenticalUnions(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue61737">
            <h2>TestIssue61737</h2>
            <hr />
            
            <pre><code>func TestIssue61737(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNewAlias_Issue65455">
            <h2>TestNewAlias_Issue65455</h2>
            <hr />
            
            <pre><code>func TestNewAlias_Issue65455(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue15305">
            <h2>TestIssue15305</h2>
            <hr />
            
            <pre><code>func TestIssue15305(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCompositeLitTypes">
            <h2>TestCompositeLitTypes</h2>
            <hr />
            
            <p>TestCompositeLitTypes verifies that Info.Types registers the correct
types for composite literal expressions and composite literal type
expressions.</p>
            
            <pre><code>func TestCompositeLitTypes(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestObjectParents">
            <h2>TestObjectParents</h2>
            <hr />
            
            <p>TestObjectParents verifies that objects have parent scopes or not
as specified by the Object interface.</p>
            
            <pre><code>func TestObjectParents(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestFailedImport">
            <h2>TestFailedImport</h2>
            <hr />
            
            <p>TestFailedImport tests that we don't get follow-on errors
elsewhere in a package due to failing to import a package.</p>
            
            <pre><code>func TestFailedImport(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInstantiate">
            <h2>TestInstantiate</h2>
            <hr />
            
            <pre><code>func TestInstantiate(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInstantiateConcurrent">
            <h2>TestInstantiateConcurrent</h2>
            <hr />
            
            <pre><code>func TestInstantiateConcurrent(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInstantiateErrors">
            <h2>TestInstantiateErrors</h2>
            <hr />
            
            <pre><code>func TestInstantiateErrors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestArgumentErrorUnwrapping">
            <h2>TestArgumentErrorUnwrapping</h2>
            <hr />
            
            <pre><code>func TestArgumentErrorUnwrapping(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInstanceIdentity">
            <h2>TestInstanceIdentity</h2>
            <hr />
            
            <pre><code>func TestInstanceIdentity(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInstantiatedObjects">
            <h2>TestInstantiatedObjects</h2>
            <hr />
            
            <p>TestInstantiatedObjects verifies properties of instantiated objects.</p>
            
            <pre><code>func TestInstantiatedObjects(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="originObject">
            <h2>originObject</h2>
            <hr />
            
            <pre><code>func originObject(obj Object) Object</code></pre>
         </article>
         
         <article class="function" data-name="TestImplements">
            <h2>TestImplements</h2>
            <hr />
            
            <pre><code>func TestImplements(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMissingMethodAlternative">
            <h2>TestMissingMethodAlternative</h2>
            <hr />
            
            <pre><code>func TestMissingMethodAlternative(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestErrorURL">
            <h2>TestErrorURL</h2>
            <hr />
            
            <pre><code>func TestErrorURL(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestModuleVersion">
            <h2>TestModuleVersion</h2>
            <hr />
            
            <pre><code>func TestModuleVersion(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestFileVersions">
            <h2>TestFileVersions</h2>
            <hr />
            
            <pre><code>func TestFileVersions(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestTooNew">
            <h2>TestTooNew</h2>
            <hr />
            
            <p>TestTooNew ensures that "too new" errors are emitted when the file
or module is tagged with a newer version of Go than this go/types.</p>
            
            <pre><code>func TestTooNew(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnaliasTooSoonInCycle">
            <h2>TestUnaliasTooSoonInCycle</h2>
            <hr />
            
            <p>This is a regression test for #66704.</p>
            
            <pre><code>func TestUnaliasTooSoonInCycle(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAlias_Rhs">
            <h2>TestAlias_Rhs</h2>
            <hr />
            
            <pre><code>func TestAlias_Rhs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAnyHijacking_Check">
            <h2>TestAnyHijacking_Check</h2>
            <hr />
            
            <p>Test the hijacking described of "any" described in golang/go#66921, for
(concurrent) type checking.</p>
            
            <pre><code>func TestAnyHijacking_Check(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestVersionWithoutPos">
            <h2>TestVersionWithoutPos</h2>
            <hr />
            
            <p>TestVersionWithoutPos is a regression test for issue #69477,
in which the type checker would use position information
to compute which file it is "in" based on syntax position.

As a rule the type checker should not depend on position
information for correctness, only for error messages and
Object.Pos. (Scope.LookupParent was a mistake.)

The Checker now holds the effective version in a state variable.</p>
            
            <pre><code>func TestVersionWithoutPos(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestErrorCalls">
            <h2>TestErrorCalls</h2>
            <hr />
            
            <p>TestErrorCalls makes sure that check.errorf calls have at least
errorfMinArgCount arguments (otherwise we should use check.error)
and use balanced parentheses/brackets.</p>
            
            <pre><code>func TestErrorCalls(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="isName">
            <h2>isName</h2>
            <hr />
            
            <pre><code>func isName(n syntax.Node, name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="balancedParentheses">
            <h2>balancedParentheses</h2>
            <hr />
            
            <pre><code>func balancedParentheses(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="checkMono">
            <h2>checkMono</h2>
            <hr />
            
            <pre><code>func checkMono(t *testing.T, body string) error</code></pre>
         </article>
         
         <article class="function" data-name="TestMonoGood">
            <h2>TestMonoGood</h2>
            <hr />
            
            <pre><code>func TestMonoGood(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMonoBad">
            <h2>TestMonoBad</h2>
            <hr />
            
            <pre><code>func TestMonoBad(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestStdlib">
            <h2>TestStdlib</h2>
            <hr />
            
            <pre><code>func TestStdlib(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Import">
            <h2>Import</h2>
            <hr />
            
            <pre><code>func Import(path string) (*Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="ImportFrom">
            <h2>ImportFrom</h2>
            <hr />
            
            <pre><code>func ImportFrom(path string, dir string, _ ImportMode) (*Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="getDirPackage">
            <h2>getDirPackage</h2>
            <hr />
            
            <p>getDirPackage gets the package defined in dir from the future cache.

If this is the first goroutine requesting the package, getDirPackage
type-checks.</p>
            
            <pre><code>func getDirPackage(dir string) (*Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="firstComment">
            <h2>firstComment</h2>
            <hr />
            
            <p>firstComment returns the contents of the first non-empty comment in
the given file, "skip", or the empty string. No matter the present
comments, if any of them contains a build tag, the result is always
"skip". Only comments within the first 4K of the file are considered.
TODO(gri) should only read until we see "package" token.</p>
            
            <pre><code>func firstComment(filename string) first string</code></pre>
         </article>
         
         <article class="function" data-name="testTestDir">
            <h2>testTestDir</h2>
            <hr />
            
            <pre><code>func testTestDir(t *testing.T, path string, ignore ...string)</code></pre>
         </article>
         
         <article class="function" data-name="TestStdTest">
            <h2>TestStdTest</h2>
            <hr />
            
            <pre><code>func TestStdTest(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestStdFixed">
            <h2>TestStdFixed</h2>
            <hr />
            
            <pre><code>func TestStdFixed(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestStdKen">
            <h2>TestStdKen</h2>
            <hr />
            
            <pre><code>func TestStdKen(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="typecheckFiles">
            <h2>typecheckFiles</h2>
            <hr />
            
            <p>typecheckFiles typechecks the given package files.</p>
            
            <pre><code>func typecheckFiles(path string, filenames []string, importer Importer) (*Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="pkgFilenames">
            <h2>pkgFilenames</h2>
            <hr />
            
            <p>pkgFilenames returns the list of package filenames for the given directory.</p>
            
            <pre><code>func pkgFilenames(dir string, includeTest bool) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="walkPkgDirs">
            <h2>walkPkgDirs</h2>
            <hr />
            
            <pre><code>func walkPkgDirs(dir string, pkgh func, errh func)</code></pre>
         </article>
         
         <article class="function" data-name="walk">
            <h2>walk</h2>
            <hr />
            
            <pre><code>func walk(dir string)</code></pre>
         </article>
         
         <article class="function" data-name="TestInstantiateEquality">
            <h2>TestInstantiateEquality</h2>
            <hr />
            
            <pre><code>func TestInstantiateEquality(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInstantiateNonEquality">
            <h2>TestInstantiateNonEquality</h2>
            <hr />
            
            <pre><code>func TestInstantiateNonEquality(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMethodInstantiation">
            <h2>TestMethodInstantiation</h2>
            <hr />
            
            <pre><code>func TestMethodInstantiation(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestImmutableSignatures">
            <h2>TestImmutableSignatures</h2>
            <hr />
            
            <pre><code>func TestImmutableSignatures(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="stripAnnotations">
            <h2>stripAnnotations</h2>
            <hr />
            
            <p>Copied from errors.go.</p>
            
            <pre><code>func stripAnnotations(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkLookupFieldOrMethod">
            <h2>BenchmarkLookupFieldOrMethod</h2>
            <hr />
            
            <p>BenchmarkLookupFieldOrMethod measures types.LookupFieldOrMethod performance.
LookupFieldOrMethod is a performance hotspot for both type-checking and
external API calls.</p>
            
            <pre><code>func BenchmarkLookupFieldOrMethod(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="TestMain">
            <h2>TestMain</h2>
            <hr />
            
            <pre><code>func TestMain(m *testing.M)</code></pre>
         </article>
         
         <article class="function" data-name="dup">
            <h2>dup</h2>
            <hr />
            
            <p>dup returns a testEntry where both src and str are the same.</p>
            
            <pre><code>func dup(s string) testEntry</code></pre>
         </article>
         
         <article class="function" data-name="TestTypeString">
            <h2>TestTypeString</h2>
            <hr />
            
            <pre><code>func TestTypeString(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestQualifiedTypeString">
            <h2>TestQualifiedTypeString</h2>
            <hr />
            
            <pre><code>func TestQualifiedTypeString(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="parseFiles">
            <h2>parseFiles</h2>
            <hr />
            
            <pre><code>func parseFiles(t *testing.T, filenames []string, srcs [][]byte, mode syntax.Mode) ([]*syntax.File, []error)</code></pre>
         </article>
         
         <article class="function" data-name="unpackError">
            <h2>unpackError</h2>
            <hr />
            
            <pre><code>func unpackError(err error) (syntax.Pos, string)</code></pre>
         </article>
         
         <article class="function" data-name="absDiff">
            <h2>absDiff</h2>
            <hr />
            
            <p>absDiff returns the absolute difference between x and y.</p>
            
            <pre><code>func absDiff(x uint, y uint) uint</code></pre>
         </article>
         
         <article class="function" data-name="parseFlags">
            <h2>parseFlags</h2>
            <hr />
            
            <p>parseFlags parses flags from the first line of the given source if the line
starts with "//" (line comment) followed by "-" (possibly with spaces
between). Otherwise the line is ignored.</p>
            
            <pre><code>func parseFlags(src []byte, flags *flag.FlagSet) error</code></pre>
         </article>
         
         <article class="function" data-name="testFiles">
            <h2>testFiles</h2>
            <hr />
            
            <p>testFiles type-checks the package consisting of the given files, and
compares the resulting errors with the ERROR annotations in the source.
Except for manual tests, each package is type-checked twice, once without
use of Alias types, and once with Alias types.

The srcs slice contains the file content for the files named in the
filenames slice. The colDelta parameter specifies the tolerance for position
mismatch when comparing errors. The manual parameter specifies whether this
is a 'manual' test.

If provided, opts may be used to mutate the Config before type-checking.</p>
            
            <pre><code>func testFiles(t *testing.T, filenames []string, srcs [][]byte, colDelta uint, manual bool, opts ...func)</code></pre>
         </article>
         
         <article class="function" data-name="testFilesImpl">
            <h2>testFilesImpl</h2>
            <hr />
            
            <pre><code>func testFilesImpl(t *testing.T, filenames []string, srcs [][]byte, colDelta uint, manual bool, opts ...func)</code></pre>
         </article>
         
         <article class="function" data-name="boolFieldAddr">
            <h2>boolFieldAddr</h2>
            <hr />
            
            <p>boolFieldAddr(conf, name) returns the address of the boolean field conf.<name>.
For accessing unexported fields.</p>
            
            <pre><code>func boolFieldAddr(conf *Config, name string) *bool</code></pre>
         </article>
         
         <article class="function" data-name="setGOEXPERIMENT">
            <h2>setGOEXPERIMENT</h2>
            <hr />
            
            <p>setGOEXPERIMENT overwrites the existing buildcfg.Experiment with a new one
based on the provided goexperiment string. Calling the result function
(typically via defer), reverts buildcfg.Experiment to the prior value.
For testing use, only.</p>
            
            <pre><code>func setGOEXPERIMENT(goexperiment string) func</code></pre>
         </article>
         
         <article class="function" data-name="TestManual">
            <h2>TestManual</h2>
            <hr />
            
            <p>TestManual is for manual testing of a package - either provided
as a list of filenames belonging to the package, or a directory
name containing the package files - after the test arguments
(and a separating "--"). For instance, to test the package made
of the files foo.go and bar.go, use:

	go test -run Manual -- foo.go bar.go

If no source arguments are provided, the file testdata/manual.go
is used instead.
Provide the -verify flag to verify errors against ERROR comments
in the input files rather than having a list of errors reported.
The accepted Go language version can be controlled with the -lang
flag.</p>
            
            <pre><code>func TestManual(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLongConstants">
            <h2>TestLongConstants</h2>
            <hr />
            
            <pre><code>func TestLongConstants(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="withSizes">
            <h2>withSizes</h2>
            <hr />
            
            <pre><code>func withSizes(sizes Sizes) func</code></pre>
         </article>
         
         <article class="function" data-name="TestIndexRepresentability">
            <h2>TestIndexRepresentability</h2>
            <hr />
            
            <p>TestIndexRepresentability tests that constant index operands must
be representable as int even if they already have a type that can
represent larger values.</p>
            
            <pre><code>func TestIndexRepresentability(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue47243_TypedRHS">
            <h2>TestIssue47243_TypedRHS</h2>
            <hr />
            
            <pre><code>func TestIssue47243_TypedRHS(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCheck">
            <h2>TestCheck</h2>
            <hr />
            
            <pre><code>func TestCheck(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSpec">
            <h2>TestSpec</h2>
            <hr />
            
            <pre><code>func TestSpec(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestExamples">
            <h2>TestExamples</h2>
            <hr />
            
            <pre><code>func TestExamples(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestFixedbugs">
            <h2>TestFixedbugs</h2>
            <hr />
            
            <pre><code>func TestFixedbugs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLocal">
            <h2>TestLocal</h2>
            <hr />
            
            <pre><code>func TestLocal(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testDirFiles">
            <h2>testDirFiles</h2>
            <hr />
            
            <pre><code>func testDirFiles(t *testing.T, dir string, colDelta uint, manual bool)</code></pre>
         </article>
         
         <article class="function" data-name="testDir">
            <h2>testDir</h2>
            <hr />
            
            <pre><code>func testDir(t *testing.T, dir string, colDelta uint, manual bool)</code></pre>
         </article>
         
         <article class="function" data-name="testPkg">
            <h2>testPkg</h2>
            <hr />
            
            <pre><code>func testPkg(t *testing.T, filenames []string, colDelta uint, manual bool)</code></pre>
         </article>
         
         <article class="function" data-name="TestHilbert">
            <h2>TestHilbert</h2>
            <hr />
            
            <pre><code>func TestHilbert(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="program">
            <h2>program</h2>
            <hr />
            
            <pre><code>func program(n int, out string) []byte</code></pre>
         </article>
         
         <article class="function" data-name="p">
            <h2>p</h2>
            <hr />
            
            <pre><code>func p(format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="hilbert">
            <h2>hilbert</h2>
            <hr />
            
            <pre><code>func hilbert(n int)</code></pre>
         </article>
         
         <article class="function" data-name="inverse">
            <h2>inverse</h2>
            <hr />
            
            <pre><code>func inverse(n int)</code></pre>
         </article>
         
         <article class="function" data-name="product">
            <h2>product</h2>
            <hr />
            
            <pre><code>func product(n int)</code></pre>
         </article>
         
         <article class="function" data-name="verify">
            <h2>verify</h2>
            <hr />
            
            <pre><code>func verify(n int)</code></pre>
         </article>
         
         <article class="function" data-name="printProduct">
            <h2>printProduct</h2>
            <hr />
            
            <pre><code>func printProduct(n int)</code></pre>
         </article>
         
         <article class="function" data-name="binomials">
            <h2>binomials</h2>
            <hr />
            
            <pre><code>func binomials(n int)</code></pre>
         </article>
         
         <article class="function" data-name="factorials">
            <h2>factorials</h2>
            <hr />
            
            <pre><code>func factorials(n int)</code></pre>
         </article>
         
         <article class="function" data-name="defaultImporter">
            <h2>defaultImporter</h2>
            <hr />
            
            <pre><code>func defaultImporter() types2.Importer</code></pre>
         </article>
         
         <article class="function" data-name="Import">
            <h2>Import</h2>
            <hr />
            
            <pre><code>func Import(path string) (*types2.Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="ImportFrom">
            <h2>ImportFrom</h2>
            <hr />
            
            <pre><code>func ImportFrom(path string, srcDir string, mode types2.ImportMode) (*types2.Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestIsAlias">
            <h2>TestIsAlias</h2>
            <hr />
            
            <pre><code>func TestIsAlias(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEmbeddedMethod">
            <h2>TestEmbeddedMethod</h2>
            <hr />
            
            <p>TestEmbeddedMethod checks that an embedded method is represented by
the same Func Object as the original method. See also go.dev/issue/34421.</p>
            
            <pre><code>func TestEmbeddedMethod(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestObjectString">
            <h2>TestObjectString</h2>
            <hr />
            
            <pre><code>func TestObjectString(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="lookupTypeParamObj">
            <h2>lookupTypeParamObj</h2>
            <hr />
            
            <pre><code>func lookupTypeParamObj(list *TypeParamList, name string) Object</code></pre>
         </article>
         
         <article class="function" data-name="Import">
            <h2>Import</h2>
            <hr />
            
            <pre><code>func Import(string) (*Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="ImportFrom">
            <h2>ImportFrom</h2>
            <hr />
            
            <pre><code>func ImportFrom(path string, srcDir string, mode ImportMode) (*Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestResolveIdents">
            <h2>TestResolveIdents</h2>
            <hr />
            
            <pre><code>func TestResolveIdents(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBuiltinSignatures">
            <h2>TestBuiltinSignatures</h2>
            <hr />
            
            <pre><code>func TestBuiltinSignatures(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testBuiltinSignature">
            <h2>testBuiltinSignature</h2>
            <hr />
            
            <pre><code>func testBuiltinSignature(t *testing.T, name string, src0 string, want string)</code></pre>
         </article>
         
         <article class="function" data-name="ExampleScope">
            <h2>ExampleScope</h2>
            <hr />
            
            <p>ExampleScope prints the tree of Scopes of a package created from a
set of parsed files.</p>
            
            <pre><code>func ExampleScope()</code></pre>
         </article>
         
         <article class="function" data-name="ExampleInfo">
            <h2>ExampleInfo</h2>
            <hr />
            
            <p>ExampleInfo prints various facts recorded by the type checker in a
types2.Info struct: definitions of and references to each named object,
and the type, value, and mode of every expression in the package.</p>
            
            <pre><code>func ExampleInfo()</code></pre>
         </article>
         
         <article class="function" data-name="mode">
            <h2>mode</h2>
            <hr />
            
            <pre><code>func mode(tv types2.TypeAndValue) string</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
