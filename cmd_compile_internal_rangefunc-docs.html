<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - rangefunc</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>rangefunc</code>
         </h1>
         <hr />
         
         <article class="global" data-name="nopos">
            <h2>nopos</h2>
            <hr />
            
            <p>nopos is the zero syntax.Pos.</p>
            
            <pre><code>nopos syntax.Pos</code></pre>
         </article>
         
         <article class="global" data-name="perLoopStep">
            <h2>perLoopStep</h2>
            <hr />
            
            <p>perLoopStep is part of the encoding of loop-spanning control flow
for function range iterators.  Each multiple of two encodes a "return false"
passing control to an enclosing iterator; a terminal value of 1 encodes
"return true" (i.e., local continue) from the body function, and a terminal
value of 0 encodes executing the remainder of the body function.</p>
            
            <pre><code>perLoopStep</code></pre>
         </article>
         
         <article class="global" data-name="runtimePkg">
            <h2>runtimePkg</h2>
            <hr />
            
            <p>runtimePkg is a fake runtime package that contains what we need to refer to in package runtime.</p>
            
            <pre><code>runtimePkg</code></pre>
         </article>
          
         <article class="struct" data-name="rewriter">
            <h2>type rewriter struct</h2>
            <hr />
            
            <p>A rewriter implements rewriting the range-over-funcs in a given function.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pkg *types2.Package
info *types2.Info
sig *types2.Signature
outer *syntax.FuncType
body *syntax.BlockStmt
any types2.Object
bool types2.Object
int types2.Object
true types2.Object
false types2.Object
branchNext *ast.MapType
labelLoop *ast.MapType
stack []syntax.Node
forStack []*forLoop
rewritten *ast.MapType
declStmt *syntax.DeclStmt
nextVar types2.Object
defers types2.Object
stateVarCount int
bodyClosureCount int
rangefuncBodyClosures *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="branch">
            <h2>type branch struct</h2>
            <hr />
            
            <p>A branch is a single labeled branch.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">tok syntax.Token
label string</code></pre>
         </article>
         
         <article class="struct" data-name="forLoop">
            <h2>type forLoop struct</h2>
            <hr />
            
            <p>A forLoop describes a single range-over-func loop being processed.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">nfor *syntax.ForStmt
stateVar *types2.Var
stateVarDecl *syntax.VarDecl
depth int
checkRet bool
checkBreak bool
checkContinue bool
checkBranch []branch</code></pre>
         </article>
          
         <article class="function" data-name="Rewrite">
            <h2>Rewrite</h2>
            <hr />
            
            <p>Rewrite rewrites all the range-over-funcs in the files.
It returns the set of function literals generated from rangefunc loop bodies.
This allows for rangefunc loop bodies to be distinguished by debuggers.</p>
            
            <pre><code>func Rewrite(pkg *types2.Package, info *types2.Info, files []*syntax.File) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="rewriteFunc">
            <h2>rewriteFunc</h2>
            <hr />
            
            <p>rewriteFunc rewrites all the range-over-funcs in a single function (a top-level func or a func literal).
The typ and body are the function's type and body.</p>
            
            <pre><code>func rewriteFunc(pkg *types2.Package, info *types2.Info, typ *syntax.FuncType, body *syntax.BlockStmt, sig *types2.Signature, ri *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="checkFuncMisuse">
            <h2>checkFuncMisuse</h2>
            <hr />
            
            <p>checkFuncMisuse reports whether to check for misuse of iterator callbacks functions.</p>
            
            <pre><code>func checkFuncMisuse() bool</code></pre>
         </article>
         
         <article class="function" data-name="inspect">
            <h2>inspect</h2>
            <hr />
            
            <p>inspect is a callback for syntax.Inspect that drives the actual rewriting.
If it sees a func literal, it kicks off a separate rewrite for that literal.
Otherwise, it maintains a stack of range-over-func loops and
converts each in turn.</p>
            
            <pre><code>func inspect(n syntax.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="startLoop">
            <h2>startLoop</h2>
            <hr />
            
            <p>startLoop sets up for converting a range-over-func loop.</p>
            
            <pre><code>func startLoop(loop *forLoop)</code></pre>
         </article>
         
         <article class="function" data-name="editStmt">
            <h2>editStmt</h2>
            <hr />
            
            <p>editStmt returns the replacement for the statement x,
or x itself if it should be left alone.
This includes the for loops we are converting,
as left in x.rewritten by r.endLoop.</p>
            
            <pre><code>func editStmt(x syntax.Stmt) syntax.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="editDefer">
            <h2>editDefer</h2>
            <hr />
            
            <p>editDefer returns the replacement for the defer statement x.
See the "Defers" section in the package doc comment above for more context.</p>
            
            <pre><code>func editDefer(x *syntax.CallStmt) syntax.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="stateVar">
            <h2>stateVar</h2>
            <hr />
            
            <pre><code>func stateVar(pos syntax.Pos) (*types2.Var, *syntax.VarDecl)</code></pre>
         </article>
         
         <article class="function" data-name="editReturn">
            <h2>editReturn</h2>
            <hr />
            
            <p>editReturn returns the replacement for the return statement x.
See the "Return" section in the package doc comment above for more context.</p>
            
            <pre><code>func editReturn(x *syntax.ReturnStmt) syntax.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="editBranch">
            <h2>editBranch</h2>
            <hr />
            
            <p>editBranch returns the replacement for the branch statement x,
or x itself if it should be left alone.
See the package doc comment above for more context.</p>
            
            <pre><code>func editBranch(x *syntax.BranchStmt) syntax.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="computeBranchNext">
            <h2>computeBranchNext</h2>
            <hr />
            
            <p>computeBranchNext computes the branchNext numbering
and determines which labels end up inside which range-over-func loop bodies.</p>
            
            <pre><code>func computeBranchNext()</code></pre>
         </article>
         
         <article class="function" data-name="endLoop">
            <h2>endLoop</h2>
            <hr />
            
            <p>endLoop finishes the conversion of a range-over-func loop.
We have inspected and rewritten the body of the loop and can now
construct the body function and rewrite the for loop into a call
bracketed by any declarations and checks it requires.</p>
            
            <pre><code>func endLoop(loop *forLoop)</code></pre>
         </article>
         
         <article class="function" data-name="cond">
            <h2>cond</h2>
            <hr />
            
            <pre><code>func cond(op syntax.Operator, x syntax.Expr, y syntax.Expr) *syntax.Operation</code></pre>
         </article>
         
         <article class="function" data-name="setState">
            <h2>setState</h2>
            <hr />
            
            <pre><code>func setState(val abi.RF_State, pos syntax.Pos) *syntax.AssignStmt</code></pre>
         </article>
         
         <article class="function" data-name="setStateAt">
            <h2>setStateAt</h2>
            <hr />
            
            <pre><code>func setStateAt(index int, stateVal abi.RF_State) *syntax.AssignStmt</code></pre>
         </article>
         
         <article class="function" data-name="bodyFunc">
            <h2>bodyFunc</h2>
            <hr />
            
            <p>bodyFunc converts the loop body (control flow has already been updated)
to a func literal that can be passed to the range function.

vars is the range variables from the range statement.
def indicates whether this is a := range statement.
ftyp is the type of the function we are creating
start and end are the syntax positions to use for new nodes
that should be at the start or end of the loop.</p>
            
            <pre><code>func bodyFunc(body []syntax.Stmt, lhs []syntax.Expr, def bool, ftyp *types2.Signature, start syntax.Pos, end syntax.Pos) *syntax.FuncLit</code></pre>
         </article>
         
         <article class="function" data-name="checks">
            <h2>checks</h2>
            <hr />
            
            <p>checks returns the post-call checks that need to be done for the given loop.</p>
            
            <pre><code>func checks(loop *forLoop, pos syntax.Pos) []syntax.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="retStmt">
            <h2>retStmt</h2>
            <hr />
            
            <p>retStmt returns a return statement returning the given return values.</p>
            
            <pre><code>func retStmt(results syntax.Expr) *syntax.ReturnStmt</code></pre>
         </article>
         
         <article class="function" data-name="ifNext">
            <h2>ifNext</h2>
            <hr />
            
            <p>ifNext returns the statement:

	if #next op c { [#next = 0;] thens... }</p>
            
            <pre><code>func ifNext(op syntax.Operator, c int, zeroNext bool, thens ...syntax.Stmt) syntax.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="setValueType">
            <h2>setValueType</h2>
            <hr />
            
            <p>setValueType marks x as a value with type typ.</p>
            
            <pre><code>func setValueType(x syntax.Expr, typ syntax.Type)</code></pre>
         </article>
         
         <article class="function" data-name="assertReady">
            <h2>assertReady</h2>
            <hr />
            
            <p>assertReady returns the statement:

	if #tmpState != abi.RF_READY { runtime.panicrangestate(#tmpState) }</p>
            
            <pre><code>func assertReady(start syntax.Pos, tmpState *types2.Var) syntax.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="callPanic">
            <h2>callPanic</h2>
            <hr />
            
            <pre><code>func callPanic(start syntax.Pos, arg syntax.Expr) syntax.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="next">
            <h2>next</h2>
            <hr />
            
            <p>next returns a reference to the #next variable.</p>
            
            <pre><code>func next() *syntax.Name</code></pre>
         </article>
         
         <article class="function" data-name="forRangeFunc">
            <h2>forRangeFunc</h2>
            <hr />
            
            <p>forRangeFunc checks whether n is a range-over-func.
If so, it returns n.(*syntax.ForStmt), true.
Otherwise it returns nil, false.</p>
            
            <pre><code>func forRangeFunc(n syntax.Node) (*syntax.ForStmt, bool)</code></pre>
         </article>
         
         <article class="function" data-name="intConst">
            <h2>intConst</h2>
            <hr />
            
            <p>intConst returns syntax for an integer literal with the given value.</p>
            
            <pre><code>func intConst(c int) *syntax.BasicLit</code></pre>
         </article>
         
         <article class="function" data-name="stateConst">
            <h2>stateConst</h2>
            <hr />
            
            <pre><code>func stateConst(s abi.RF_State) *syntax.BasicLit</code></pre>
         </article>
         
         <article class="function" data-name="useObj">
            <h2>useObj</h2>
            <hr />
            
            <p>useObj returns syntax for a reference to decl, which should be its declaration.</p>
            
            <pre><code>func useObj(obj types2.Object) *syntax.Name</code></pre>
         </article>
         
         <article class="function" data-name="useList">
            <h2>useList</h2>
            <hr />
            
            <p>useList is useVar for a list of decls.</p>
            
            <pre><code>func useList(vars []types2.Object) syntax.Expr</code></pre>
         </article>
         
         <article class="function" data-name="makeVarName">
            <h2>makeVarName</h2>
            <hr />
            
            <pre><code>func makeVarName(pos syntax.Pos, name string, typ types2.Type) (*types2.Var, *syntax.Name)</code></pre>
         </article>
         
         <article class="function" data-name="generateParamName">
            <h2>generateParamName</h2>
            <hr />
            
            <pre><code>func generateParamName(results []*syntax.Field, i int)</code></pre>
         </article>
         
         <article class="function" data-name="declOuterVar">
            <h2>declOuterVar</h2>
            <hr />
            
            <p>declOuterVar declares a variable with a given name, type, and initializer value,
in the same scope as the outermost loop in a loop nest.</p>
            
            <pre><code>func declOuterVar(name string, typ types2.Type, init syntax.Expr) *types2.Var</code></pre>
         </article>
         
         <article class="function" data-name="declSingleVar">
            <h2>declSingleVar</h2>
            <hr />
            
            <p>declSingleVar declares a variable with a given name, type, and initializer value,
and returns both the declaration and variable, so that the declaration can be placed
in a specific scope.</p>
            
            <pre><code>func declSingleVar(name string, typ types2.Type, init syntax.Expr) (*syntax.DeclStmt, *types2.Var)</code></pre>
         </article>
         
         <article class="function" data-name="runtimeSym">
            <h2>runtimeSym</h2>
            <hr />
            
            <p>runtimeSym returns a reference to a symbol in the fake runtime package.</p>
            
            <pre><code>func runtimeSym(info *types2.Info, name string) *syntax.Name</code></pre>
         </article>
         
         <article class="function" data-name="setPos">
            <h2>setPos</h2>
            <hr />
            
            <p>setPos walks the top structure of x that has no position assigned
and assigns it all to have position pos.
When setPos encounters a syntax node with a position assigned,
setPos does not look inside that node.
setPos only needs to handle syntax we create in this package;
all other syntax should have positions assigned already.</p>
            
            <pre><code>func setPos(x syntax.Node, pos syntax.Pos)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
