<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>rangefunc - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>rangefunc</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"cmd/compile/internal/base"
"cmd/compile/internal/syntax"
"cmd/compile/internal/types2"
"fmt"
"go/constant"
"internal/abi"
"os"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="nopos" data-name="nopos">
               <h3>
                  nopos 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#nopos" class="anchor" title="Link to nopos">#</a>
               </h3>
               
                  <p class="doc-comment">nopos is the zero syntax.Pos.</p>
               
               <pre><code class="language-go">var nopos syntax.Pos</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="perLoopStep" data-name="perLoopStep">
               <h3>
                  perLoopStep 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#perLoopStep" class="anchor" title="Link to perLoopStep">#</a>
               </h3>
               
                  <p class="doc-comment">perLoopStep is part of the encoding of loop-spanning control flow
for function range iterators.  Each multiple of two encodes a "return false"
passing control to an enclosing iterator; a terminal value of 1 encodes
"return true" (i.e., local continue) from the body function, and a terminal
value of 0 encodes executing the remainder of the body function.</p>
               
               <pre><code class="language-go">const perLoopStep = 2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="runtimePkg" data-name="runtimePkg">
               <h3>
                  runtimePkg 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#runtimePkg" class="anchor" title="Link to runtimePkg">#</a>
               </h3>
               
                  <p class="doc-comment">runtimePkg is a fake runtime package that contains what we need to refer to in package runtime.</p>
               
               <pre><code class="language-go">var runtimePkg = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="State" data-name="State">
               <h3>
                  State
                  <span class="badge type-badge">type</span>
                  <a href="#State" class="anchor" title="Link to State">#</a>
               </h3>
               
               <pre><code class="language-go">type State int</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="branch" data-name="branch">
               <h3>
                  branch
                  <span class="badge">struct</span>
                  <a href="#branch" class="anchor" title="Link to branch">#</a>
               </h3>
               
               <p>A branch is a single labeled branch.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type branch struct {
tok syntax.Token
label string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="forLoop" data-name="forLoop">
               <h3>
                  forLoop
                  <span class="badge">struct</span>
                  <a href="#forLoop" class="anchor" title="Link to forLoop">#</a>
               </h3>
               
               <p>A forLoop describes a single range-over-func loop being processed.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type forLoop struct {
nfor *syntax.ForStmt
stateVar *types2.Var
stateVarDecl *syntax.VarDecl
depth int
checkRet bool
checkBreak bool
checkContinue bool
checkBranch []branch
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="rewriter" data-name="rewriter">
               <h3>
                  rewriter
                  <span class="badge">struct</span>
                  <a href="#rewriter" class="anchor" title="Link to rewriter">#</a>
               </h3>
               
               <p>A rewriter implements rewriting the range-over-funcs in a given function.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type rewriter struct {
pkg *types2.Package
info *types2.Info
sig *types2.Signature
outer *syntax.FuncType
body *syntax.BlockStmt
any types2.Object
bool types2.Object
int types2.Object
true types2.Object
false types2.Object
branchNext map[branch]int
labelLoop map[string]*syntax.ForStmt
stack []syntax.Node
forStack []*forLoop
rewritten map[*syntax.ForStmt]syntax.Stmt
declStmt *syntax.DeclStmt
nextVar types2.Object
defers types2.Object
stateVarCount int
bodyClosureCount int
rangefuncBodyClosures map[*syntax.FuncLit]bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Rewrite" data-name="Rewrite">
               <h3>
                  Rewrite 
                  <span class="badge">function</span>
                  
                  <a href="#Rewrite" class="anchor" title="Link to Rewrite">#</a>
               </h3>
               
               <p>Rewrite rewrites all the range-over-funcs in the files.
It returns the set of function literals generated from rangefunc loop bodies.
This allows for rangefunc loop bodies to be distinguished by debuggers.</p>
               
               <pre><code class="language-go">func Rewrite(pkg *types2.Package, info *types2.Info, files []*syntax.File) map[*syntax.FuncLit]bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assertReady" data-name="assertReady">
               <h3>
                  assertReady 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assertReady" class="anchor" title="Link to assertReady">#</a>
               </h3>
               
               <p>assertReady returns the statement:
if #tmpState != abi.RF_READY { runtime.panicrangestate(#tmpState) }</p>
               
               <pre><code class="language-go">func (r *rewriter) assertReady(start syntax.Pos, tmpState *types2.Var) syntax.Stmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bodyFunc" data-name="bodyFunc">
               <h3>
                  bodyFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bodyFunc" class="anchor" title="Link to bodyFunc">#</a>
               </h3>
               
               <p>bodyFunc converts the loop body (control flow has already been updated)
to a func literal that can be passed to the range function.
vars is the range variables from the range statement.
def indicates whether this is a := range statement.
ftyp is the type of the function we are creating
start and end are the syntax positions to use for new nodes
that should be at the start or end of the loop.</p>
               
               <pre><code class="language-go">func (r *rewriter) bodyFunc(body []syntax.Stmt, lhs []syntax.Expr, def bool, ftyp *types2.Signature, start syntax.Pos, end syntax.Pos) *syntax.FuncLit</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="callPanic" data-name="callPanic">
               <h3>
                  callPanic 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#callPanic" class="anchor" title="Link to callPanic">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *rewriter) callPanic(start syntax.Pos, arg syntax.Expr) syntax.Stmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkFuncMisuse" data-name="checkFuncMisuse">
               <h3>
                  checkFuncMisuse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkFuncMisuse" class="anchor" title="Link to checkFuncMisuse">#</a>
               </h3>
               
               <p>checkFuncMisuse reports whether to check for misuse of iterator callbacks functions.</p>
               
               <pre><code class="language-go">func (r *rewriter) checkFuncMisuse() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checks" data-name="checks">
               <h3>
                  checks 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checks" class="anchor" title="Link to checks">#</a>
               </h3>
               
               <p>checks returns the post-call checks that need to be done for the given loop.</p>
               
               <pre><code class="language-go">func (r *rewriter) checks(loop *forLoop, pos syntax.Pos) []syntax.Stmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="computeBranchNext" data-name="computeBranchNext">
               <h3>
                  computeBranchNext 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#computeBranchNext" class="anchor" title="Link to computeBranchNext">#</a>
               </h3>
               
               <p>computeBranchNext computes the branchNext numbering
and determines which labels end up inside which range-over-func loop bodies.</p>
               
               <pre><code class="language-go">func (r *rewriter) computeBranchNext()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cond" data-name="cond">
               <h3>
                  cond 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cond" class="anchor" title="Link to cond">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *rewriter) cond(op syntax.Operator, x syntax.Expr, y syntax.Expr) *syntax.Operation</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="declOuterVar" data-name="declOuterVar">
               <h3>
                  declOuterVar 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#declOuterVar" class="anchor" title="Link to declOuterVar">#</a>
               </h3>
               
               <p>declOuterVar declares a variable with a given name, type, and initializer value,
in the same scope as the outermost loop in a loop nest.</p>
               
               <pre><code class="language-go">func (r *rewriter) declOuterVar(name string, typ types2.Type, init syntax.Expr) *types2.Var</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="declSingleVar" data-name="declSingleVar">
               <h3>
                  declSingleVar 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#declSingleVar" class="anchor" title="Link to declSingleVar">#</a>
               </h3>
               
               <p>declSingleVar declares a variable with a given name, type, and initializer value,
and returns both the declaration and variable, so that the declaration can be placed
in a specific scope.</p>
               
               <pre><code class="language-go">func (r *rewriter) declSingleVar(name string, typ types2.Type, init syntax.Expr) (*syntax.DeclStmt, *types2.Var)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="editBranch" data-name="editBranch">
               <h3>
                  editBranch 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#editBranch" class="anchor" title="Link to editBranch">#</a>
               </h3>
               
               <p>editBranch returns the replacement for the branch statement x,
or x itself if it should be left alone.
See the package doc comment above for more context.</p>
               
               <pre><code class="language-go">func (r *rewriter) editBranch(x *syntax.BranchStmt) syntax.Stmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="editDefer" data-name="editDefer">
               <h3>
                  editDefer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#editDefer" class="anchor" title="Link to editDefer">#</a>
               </h3>
               
               <p>editDefer returns the replacement for the defer statement x.
See the "Defers" section in the package doc comment above for more context.</p>
               
               <pre><code class="language-go">func (r *rewriter) editDefer(x *syntax.CallStmt) syntax.Stmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="editReturn" data-name="editReturn">
               <h3>
                  editReturn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#editReturn" class="anchor" title="Link to editReturn">#</a>
               </h3>
               
               <p>editReturn returns the replacement for the return statement x.
See the "Return" section in the package doc comment above for more context.</p>
               
               <pre><code class="language-go">func (r *rewriter) editReturn(x *syntax.ReturnStmt) syntax.Stmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="editStmt" data-name="editStmt">
               <h3>
                  editStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#editStmt" class="anchor" title="Link to editStmt">#</a>
               </h3>
               
               <p>editStmt returns the replacement for the statement x,
or x itself if it should be left alone.
This includes the for loops we are converting,
as left in x.rewritten by r.endLoop.</p>
               
               <pre><code class="language-go">func (r *rewriter) editStmt(x syntax.Stmt) syntax.Stmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="endLoop" data-name="endLoop">
               <h3>
                  endLoop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#endLoop" class="anchor" title="Link to endLoop">#</a>
               </h3>
               
               <p>endLoop finishes the conversion of a range-over-func loop.
We have inspected and rewritten the body of the loop and can now
construct the body function and rewrite the for loop into a call
bracketed by any declarations and checks it requires.</p>
               
               <pre><code class="language-go">func (r *rewriter) endLoop(loop *forLoop)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="forRangeFunc" data-name="forRangeFunc">
               <h3>
                  forRangeFunc 
                  <span class="badge">function</span>
                  
                  <a href="#forRangeFunc" class="anchor" title="Link to forRangeFunc">#</a>
               </h3>
               
               <p>forRangeFunc checks whether n is a range-over-func.
If so, it returns n.(*syntax.ForStmt), true.
Otherwise it returns nil, false.</p>
               
               <pre><code class="language-go">func forRangeFunc(n syntax.Node) (*syntax.ForStmt, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="generateParamName" data-name="generateParamName">
               <h3>
                  generateParamName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#generateParamName" class="anchor" title="Link to generateParamName">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *rewriter) generateParamName(results []*syntax.Field, i int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ifNext" data-name="ifNext">
               <h3>
                  ifNext 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ifNext" class="anchor" title="Link to ifNext">#</a>
               </h3>
               
               <p>ifNext returns the statement:
if #next op c { [#next = 0;] thens... }</p>
               
               <pre><code class="language-go">func (r *rewriter) ifNext(op syntax.Operator, c int, zeroNext bool, thens ...syntax.Stmt) syntax.Stmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inspect" data-name="inspect">
               <h3>
                  inspect 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#inspect" class="anchor" title="Link to inspect">#</a>
               </h3>
               
               <p>inspect is a callback for syntax.Inspect that drives the actual rewriting.
If it sees a func literal, it kicks off a separate rewrite for that literal.
Otherwise, it maintains a stack of range-over-func loops and
converts each in turn.</p>
               
               <pre><code class="language-go">func (r *rewriter) inspect(n syntax.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="intConst" data-name="intConst">
               <h3>
                  intConst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#intConst" class="anchor" title="Link to intConst">#</a>
               </h3>
               
               <p>intConst returns syntax for an integer literal with the given value.</p>
               
               <pre><code class="language-go">func (r *rewriter) intConst(c int) *syntax.BasicLit</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeVarName" data-name="makeVarName">
               <h3>
                  makeVarName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#makeVarName" class="anchor" title="Link to makeVarName">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *rewriter) makeVarName(pos syntax.Pos, name string, typ types2.Type) (*types2.Var, *syntax.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="next" data-name="next">
               <h3>
                  next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#next" class="anchor" title="Link to next">#</a>
               </h3>
               
               <p>next returns a reference to the #next variable.</p>
               
               <pre><code class="language-go">func (r *rewriter) next() *syntax.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="retStmt" data-name="retStmt">
               <h3>
                  retStmt 
                  <span class="badge">function</span>
                  
                  <a href="#retStmt" class="anchor" title="Link to retStmt">#</a>
               </h3>
               
               <p>retStmt returns a return statement returning the given return values.</p>
               
               <pre><code class="language-go">func retStmt(results syntax.Expr) *syntax.ReturnStmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rewriteFunc" data-name="rewriteFunc">
               <h3>
                  rewriteFunc 
                  <span class="badge">function</span>
                  
                  <a href="#rewriteFunc" class="anchor" title="Link to rewriteFunc">#</a>
               </h3>
               
               <p>rewriteFunc rewrites all the range-over-funcs in a single function (a top-level func or a func literal).
The typ and body are the function's type and body.</p>
               
               <pre><code class="language-go">func rewriteFunc(pkg *types2.Package, info *types2.Info, typ *syntax.FuncType, body *syntax.BlockStmt, sig *types2.Signature, ri map[*syntax.FuncLit]bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtimeSym" data-name="runtimeSym">
               <h3>
                  runtimeSym 
                  <span class="badge">function</span>
                  
                  <a href="#runtimeSym" class="anchor" title="Link to runtimeSym">#</a>
               </h3>
               
               <p>runtimeSym returns a reference to a symbol in the fake runtime package.</p>
               
               <pre><code class="language-go">func runtimeSym(info *types2.Info, name string) *syntax.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setPos" data-name="setPos">
               <h3>
                  setPos 
                  <span class="badge">function</span>
                  
                  <a href="#setPos" class="anchor" title="Link to setPos">#</a>
               </h3>
               
               <p>setPos walks the top structure of x that has no position assigned
and assigns it all to have position pos.
When setPos encounters a syntax node with a position assigned,
setPos does not look inside that node.
setPos only needs to handle syntax we create in this package;
all other syntax should have positions assigned already.</p>
               
               <pre><code class="language-go">func setPos(x syntax.Node, pos syntax.Pos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setState" data-name="setState">
               <h3>
                  setState 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setState" class="anchor" title="Link to setState">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *rewriter) setState(val abi.RF_State, pos syntax.Pos) *syntax.AssignStmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setStateAt" data-name="setStateAt">
               <h3>
                  setStateAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setStateAt" class="anchor" title="Link to setStateAt">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *rewriter) setStateAt(index int, stateVal abi.RF_State) *syntax.AssignStmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setValueType" data-name="setValueType">
               <h3>
                  setValueType 
                  <span class="badge">function</span>
                  
                  <a href="#setValueType" class="anchor" title="Link to setValueType">#</a>
               </h3>
               
               <p>setValueType marks x as a value with type typ.</p>
               
               <pre><code class="language-go">func setValueType(x syntax.Expr, typ syntax.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startLoop" data-name="startLoop">
               <h3>
                  startLoop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startLoop" class="anchor" title="Link to startLoop">#</a>
               </h3>
               
               <p>startLoop sets up for converting a range-over-func loop.</p>
               
               <pre><code class="language-go">func (r *rewriter) startLoop(loop *forLoop)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stateConst" data-name="stateConst">
               <h3>
                  stateConst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stateConst" class="anchor" title="Link to stateConst">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *rewriter) stateConst(s abi.RF_State) *syntax.BasicLit</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stateVar" data-name="stateVar">
               <h3>
                  stateVar 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stateVar" class="anchor" title="Link to stateVar">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *rewriter) stateVar(pos syntax.Pos) (*types2.Var, *syntax.VarDecl)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="useList" data-name="useList">
               <h3>
                  useList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#useList" class="anchor" title="Link to useList">#</a>
               </h3>
               
               <p>useList is useVar for a list of decls.</p>
               
               <pre><code class="language-go">func (r *rewriter) useList(vars []types2.Object) syntax.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="useObj" data-name="useObj">
               <h3>
                  useObj 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#useObj" class="anchor" title="Link to useObj">#</a>
               </h3>
               
               <p>useObj returns syntax for a reference to decl, which should be its declaration.</p>
               
               <pre><code class="language-go">func (r *rewriter) useObj(obj types2.Object) *syntax.Name</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>