<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - sync</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="sync_atomic-docs.html">atomic</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>sync</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"sync/atomic"
"sync/atomic"
"unsafe"
"unsafe"
"unsafe"
"internal/race"
"sync/atomic"
"unsafe"
"sync/atomic"
"unsafe"
"sync/atomic"
"internal/race"
"runtime"
"sync/atomic"
"unsafe"
"unsafe"
"internal/race"
"sync/atomic"
"unsafe"
isync "internal/sync"
isync "internal/sync"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="allPools" data-name="allPools">
               <h3>
                  allPools 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#allPools" class="anchor" title="Link to allPools">#</a>
               </h3>
               
               <p>allPools is the set of pools that have non-empty primary
caches. Protected by either 1) allPoolsMu and pinning or 2)
STW.</p>
               
               <pre><code>var allPools []*Pool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="allPoolsMu" data-name="allPoolsMu">
               <h3>
                  allPoolsMu 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#allPoolsMu" class="anchor" title="Link to allPoolsMu">#</a>
               </h3>
               
               <pre><code>var allPoolsMu Mutex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dequeueBits" data-name="dequeueBits">
               <h3>
                  dequeueBits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#dequeueBits" class="anchor" title="Link to dequeueBits">#</a>
               </h3>
               
               <pre><code>const dequeueBits = 32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dequeueLimit" data-name="dequeueLimit">
               <h3>
                  dequeueLimit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#dequeueLimit" class="anchor" title="Link to dequeueLimit">#</a>
               </h3>
               
               <p>dequeueLimit is the maximum size of a poolDequeue.
This must be at most (1<<dequeueBits)/2 because detecting fullness
depends on wrapping around the ring buffer without wrapping around
the index. We divide by 4 so this fits in an int on 32-bit.</p>
               
               <pre><code>const dequeueLimit = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="expunged" data-name="expunged">
               <h3>
                  expunged 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#expunged" class="anchor" title="Link to expunged">#</a>
               </h3>
               
               <p>expunged is an arbitrary pointer that marks entries which have been deleted
from the dirty map.</p>
               
               <pre><code>var expunged = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="oldPools" data-name="oldPools">
               <h3>
                  oldPools 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#oldPools" class="anchor" title="Link to oldPools">#</a>
               </h3>
               
               <p>oldPools is the set of pools that may have non-empty victim
caches. Protected by STW.</p>
               
               <pre><code>var oldPools []*Pool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="poolRaceHash" data-name="poolRaceHash">
               <h3>
                  poolRaceHash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#poolRaceHash" class="anchor" title="Link to poolRaceHash">#</a>
               </h3>
               
               <pre><code>var poolRaceHash [128]uint64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="rwmutexMaxReaders" data-name="rwmutexMaxReaders">
               <h3>
                  rwmutexMaxReaders 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#rwmutexMaxReaders" class="anchor" title="Link to rwmutexMaxReaders">#</a>
               </h3>
               
               <pre><code>const rwmutexMaxReaders = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="copyChecker" data-name="copyChecker">
               <h3>
                  copyChecker
                  <span class="badge type-badge">type</span>
                  <a href="#copyChecker" class="anchor" title="Link to copyChecker">#</a>
               </h3>
               
               <p>copyChecker holds back pointer to itself to detect object copying.</p>
               
               <pre><code>type copyChecker uintptr</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="dequeueNil" data-name="dequeueNil">
               <h3>
                  dequeueNil
                  <span class="badge type-badge">type</span>
                  <a href="#dequeueNil" class="anchor" title="Link to dequeueNil">#</a>
               </h3>
               
               <p>dequeueNil is used in poolDequeue to represent interface{}(nil).
Since we use nil to represent empty slots, we need a sentinel value
to represent nil.</p>
               
               <pre><code>type dequeueNil *struct{...}</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="rlocker" data-name="rlocker">
               <h3>
                  rlocker
                  <span class="badge type-badge">type</span>
                  <a href="#rlocker" class="anchor" title="Link to rlocker">#</a>
               </h3>
               
               <pre><code>type rlocker RWMutex</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Locker" data-name="Locker">
               <h3>
                  Locker
                  <span class="badge interface-badge">interface</span>
                  <a href="#Locker" class="anchor" title="Link to Locker">#</a>
               </h3>
               
               <p>A Locker represents an object that can be locked and unlocked.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Locker interface {
Lock()
Unlock()
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Cond" data-name="Cond">
               <h3>
                  Cond
                  <span class="badge">struct</span>
                  <a href="#Cond" class="anchor" title="Link to Cond">#</a>
               </h3>
               
               <p>Cond implements a condition variable, a rendezvous point
for goroutines waiting for or announcing the occurrence
of an event.
Each Cond has an associated Locker L (often a [*Mutex] or [*RWMutex]),
which must be held when changing the condition and
when calling the [Cond.Wait] method.
A Cond must not be copied after first use.
In the terminology of [the Go memory model], Cond arranges that
a call to [Cond.Broadcast] or [Cond.Signal] “synchronizes before” any Wait call
that it unblocks.
For many simple use cases, users will be better off using channels than a
Cond (Broadcast corresponds to closing a channel, and Signal corresponds to
sending on a channel).
For more on replacements for [sync.Cond], see [Roberto Clapis's series on
advanced concurrency patterns], as well as [Bryan Mills's talk on concurrency
patterns].
[the Go memory model]: https://go.dev/ref/mem
[Roberto Clapis's series on advanced concurrency patterns]: https://blogtitle.github.io/categories/concurrency/
[Bryan Mills's talk on concurrency patterns]: https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Cond struct {
noCopy noCopy
L Locker
notify notifyList
checker copyChecker
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Map" data-name="Map">
               <h3>
                  Map
                  <span class="badge">struct</span>
                  <a href="#Map" class="anchor" title="Link to Map">#</a>
               </h3>
               
               <p>Map is like a Go map[any]any but is safe for concurrent use
by multiple goroutines without additional locking or coordination.
Loads, stores, and deletes run in amortized constant time.
The Map type is specialized. Most code should use a plain Go map instead,
with separate locking or coordination, for better type safety and to make it
easier to maintain other invariants along with the map content.
The Map type is optimized for two common use cases: (1) when the entry for a given
key is only ever written once but read many times, as in caches that only grow,
or (2) when multiple goroutines read, write, and overwrite entries for disjoint
sets of keys. In these two cases, use of a Map may significantly reduce lock
contention compared to a Go map paired with a separate [Mutex] or [RWMutex].
The zero Map is empty and ready for use. A Map must not be copied after first use.
In the terminology of [the Go memory model], Map arranges that a write operation
“synchronizes before” any read operation that observes the effect of the write, where
read and write operations are defined as follows.
[Map.Load], [Map.LoadAndDelete], [Map.LoadOrStore], [Map.Swap], [Map.CompareAndSwap],
and [Map.CompareAndDelete] are read operations;
[Map.Delete], [Map.LoadAndDelete], [Map.Store], and [Map.Swap] are write operations;
[Map.LoadOrStore] is a write operation when it returns loaded set to false;
[Map.CompareAndSwap] is a write operation when it returns swapped set to true;
and [Map.CompareAndDelete] is a write operation when it returns deleted set to true.
[the Go memory model]: https://go.dev/ref/mem</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Map struct {
_ noCopy
mu Mutex
read *ast.IndexExpr
dirty map[any]*entry
misses int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Map" data-name="Map">
               <h3>
                  Map
                  <span class="badge">struct</span>
                  <a href="#Map" class="anchor" title="Link to Map">#</a>
               </h3>
               
               <p>Map is like a Go map[any]any but is safe for concurrent use
by multiple goroutines without additional locking or coordination.
Loads, stores, and deletes run in amortized constant time.
The Map type is specialized. Most code should use a plain Go map instead,
with separate locking or coordination, for better type safety and to make it
easier to maintain other invariants along with the map content.
The Map type is optimized for two common use cases: (1) when the entry for a given
key is only ever written once but read many times, as in caches that only grow,
or (2) when multiple goroutines read, write, and overwrite entries for disjoint
sets of keys. In these two cases, use of a Map may significantly reduce lock
contention compared to a Go map paired with a separate [Mutex] or [RWMutex].
The zero Map is empty and ready for use. A Map must not be copied after first use.
In the terminology of [the Go memory model], Map arranges that a write operation
“synchronizes before” any read operation that observes the effect of the write, where
read and write operations are defined as follows.
[Map.Load], [Map.LoadAndDelete], [Map.LoadOrStore], [Map.Swap], [Map.CompareAndSwap],
and [Map.CompareAndDelete] are read operations;
[Map.Delete], [Map.LoadAndDelete], [Map.Store], and [Map.Swap] are write operations;
[Map.LoadOrStore] is a write operation when it returns loaded set to false;
[Map.CompareAndSwap] is a write operation when it returns swapped set to true;
and [Map.CompareAndDelete] is a write operation when it returns deleted set to true.
[the Go memory model]: https://go.dev/ref/mem</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Map struct {
_ noCopy
m *ast.IndexListExpr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Mutex" data-name="Mutex">
               <h3>
                  Mutex
                  <span class="badge">struct</span>
                  <a href="#Mutex" class="anchor" title="Link to Mutex">#</a>
               </h3>
               
               <p>A Mutex is a mutual exclusion lock.
The zero value for a Mutex is an unlocked mutex.
A Mutex must not be copied after first use.
In the terminology of [the Go memory model],
the n'th call to [Mutex.Unlock] “synchronizes before” the m'th call to [Mutex.Lock]
for any n < m.
A successful call to [Mutex.TryLock] is equivalent to a call to Lock.
A failed call to TryLock does not establish any “synchronizes before”
relation at all.
[the Go memory model]: https://go.dev/ref/mem</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Mutex struct {
_ noCopy
mu isync.Mutex
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Once" data-name="Once">
               <h3>
                  Once
                  <span class="badge">struct</span>
                  <a href="#Once" class="anchor" title="Link to Once">#</a>
               </h3>
               
               <p>Once is an object that will perform exactly one action.
A Once must not be copied after first use.
In the terminology of [the Go memory model],
the return from f “synchronizes before”
the return from any call of once.Do(f).
[the Go memory model]: https://go.dev/ref/mem</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Once struct {
_ noCopy
done atomic.Uint32
m Mutex
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Pool" data-name="Pool">
               <h3>
                  Pool
                  <span class="badge">struct</span>
                  <a href="#Pool" class="anchor" title="Link to Pool">#</a>
               </h3>
               
               <p>A Pool is a set of temporary objects that may be individually saved and
retrieved.
Any item stored in the Pool may be removed automatically at any time without
notification. If the Pool holds the only reference when this happens, the
item might be deallocated.
A Pool is safe for use by multiple goroutines simultaneously.
Pool's purpose is to cache allocated but unused items for later reuse,
relieving pressure on the garbage collector. That is, it makes it easy to
build efficient, thread-safe free lists. However, it is not suitable for all
free lists.
An appropriate use of a Pool is to manage a group of temporary items
silently shared among and potentially reused by concurrent independent
clients of a package. Pool provides a way to amortize allocation overhead
across many clients.
An example of good use of a Pool is in the fmt package, which maintains a
dynamically-sized store of temporary output buffers. The store scales under
load (when many goroutines are actively printing) and shrinks when
quiescent.
On the other hand, a free list maintained as part of a short-lived object is
not a suitable use for a Pool, since the overhead does not amortize well in
that scenario. It is more efficient to have such objects implement their own
free list.
A Pool must not be copied after first use.
In the terminology of [the Go memory model], a call to Put(x) “synchronizes before”
a call to [Pool.Get] returning that same value x.
Similarly, a call to New returning x “synchronizes before”
a call to Get returning that same value x.
[the Go memory model]: https://go.dev/ref/mem</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Pool struct {
noCopy noCopy
local unsafe.Pointer
localSize uintptr
victim unsafe.Pointer
victimSize uintptr
New func() any
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="RWMutex" data-name="RWMutex">
               <h3>
                  RWMutex
                  <span class="badge">struct</span>
                  <a href="#RWMutex" class="anchor" title="Link to RWMutex">#</a>
               </h3>
               
               <p>A RWMutex is a reader/writer mutual exclusion lock.
The lock can be held by an arbitrary number of readers or a single writer.
The zero value for a RWMutex is an unlocked mutex.
A RWMutex must not be copied after first use.
If any goroutine calls [RWMutex.Lock] while the lock is already held by
one or more readers, concurrent calls to [RWMutex.RLock] will block until
the writer has acquired (and released) the lock, to ensure that
the lock eventually becomes available to the writer.
Note that this prohibits recursive read-locking.
A [RWMutex.RLock] cannot be upgraded into a [RWMutex.Lock],
nor can a [RWMutex.Lock] be downgraded into a [RWMutex.RLock].
In the terminology of [the Go memory model],
the n'th call to [RWMutex.Unlock] “synchronizes before” the m'th call to Lock
for any n < m, just as for [Mutex].
For any call to RLock, there exists an n such that
the n'th call to Unlock “synchronizes before” that call to RLock,
and the corresponding call to [RWMutex.RUnlock] “synchronizes before”
the n+1'th call to Lock.
[the Go memory model]: https://go.dev/ref/mem</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type RWMutex struct {
w Mutex
writerSem uint32
readerSem uint32
readerCount atomic.Int32
readerWait atomic.Int32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="WaitGroup" data-name="WaitGroup">
               <h3>
                  WaitGroup
                  <span class="badge">struct</span>
                  <a href="#WaitGroup" class="anchor" title="Link to WaitGroup">#</a>
               </h3>
               
               <p>A WaitGroup waits for a collection of goroutines to finish.
The main goroutine calls [WaitGroup.Add] to set the number of
goroutines to wait for. Then each of the goroutines
runs and calls [WaitGroup.Done] when finished. At the same time,
[WaitGroup.Wait] can be used to block until all goroutines have finished.
A WaitGroup must not be copied after first use.
In the terminology of [the Go memory model], a call to [WaitGroup.Done]
“synchronizes before” the return of any Wait call that it unblocks.
[the Go memory model]: https://go.dev/ref/mem</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type WaitGroup struct {
noCopy noCopy
state atomic.Uint64
sema uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="eface" data-name="eface">
               <h3>
                  eface
                  <span class="badge">struct</span>
                  <a href="#eface" class="anchor" title="Link to eface">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type eface struct {
typ unsafe.Pointer
val unsafe.Pointer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="entry" data-name="entry">
               <h3>
                  entry
                  <span class="badge">struct</span>
                  <a href="#entry" class="anchor" title="Link to entry">#</a>
               </h3>
               
               <p>An entry is a slot in the map corresponding to a particular key.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type entry struct {
p *ast.IndexExpr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="noCopy" data-name="noCopy">
               <h3>
                  noCopy
                  <span class="badge">struct</span>
                  <a href="#noCopy" class="anchor" title="Link to noCopy">#</a>
               </h3>
               
               <p>noCopy may be added to structs which must not be copied
after the first use.
See https://golang.org/issues/8005#issuecomment-190753527
for details.
Note that it must not be embedded, due to the Lock and Unlock methods.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type noCopy struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="notifyList" data-name="notifyList">
               <h3>
                  notifyList
                  <span class="badge">struct</span>
                  <a href="#notifyList" class="anchor" title="Link to notifyList">#</a>
               </h3>
               
               <p>Approximation of notifyList in runtime/sema.go. Size and alignment must
agree.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type notifyList struct {
wait uint32
notify uint32
rank int
pad int
lock uintptr
head unsafe.Pointer
tail unsafe.Pointer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="notifyList" data-name="notifyList">
               <h3>
                  notifyList
                  <span class="badge">struct</span>
                  <a href="#notifyList" class="anchor" title="Link to notifyList">#</a>
               </h3>
               
               <p>Approximation of notifyList in runtime/sema.go. Size and alignment must
agree.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type notifyList struct {
wait uint32
notify uint32
lock uintptr
head unsafe.Pointer
tail unsafe.Pointer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="poolChain" data-name="poolChain">
               <h3>
                  poolChain
                  <span class="badge">struct</span>
                  <a href="#poolChain" class="anchor" title="Link to poolChain">#</a>
               </h3>
               
               <p>poolChain is a dynamically-sized version of poolDequeue.
This is implemented as a doubly-linked list queue of poolDequeues
where each dequeue is double the size of the previous one. Once a
dequeue fills up, this allocates a new one and only ever pushes to
the latest dequeue. Pops happen from the other end of the list and
once a dequeue is exhausted, it gets removed from the list.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type poolChain struct {
head *poolChainElt
tail *ast.IndexExpr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="poolChainElt" data-name="poolChainElt">
               <h3>
                  poolChainElt
                  <span class="badge">struct</span>
                  <a href="#poolChainElt" class="anchor" title="Link to poolChainElt">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type poolChainElt struct {
poolDequeue
next *ast.IndexExpr
prev *ast.IndexExpr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="poolDequeue" data-name="poolDequeue">
               <h3>
                  poolDequeue
                  <span class="badge">struct</span>
                  <a href="#poolDequeue" class="anchor" title="Link to poolDequeue">#</a>
               </h3>
               
               <p>poolDequeue is a lock-free fixed-size single-producer,
multi-consumer queue. The single producer can both push and pop
from the head, and consumers can pop from the tail.
It has the added feature that it nils out unused slots to avoid
unnecessary retention of objects. This is important for sync.Pool,
but not typically a property considered in the literature.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type poolDequeue struct {
headTail atomic.Uint64
vals []eface
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="poolLocal" data-name="poolLocal">
               <h3>
                  poolLocal
                  <span class="badge">struct</span>
                  <a href="#poolLocal" class="anchor" title="Link to poolLocal">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type poolLocal struct {
poolLocalInternal
pad [*ast.BinaryExpr]byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="poolLocalInternal" data-name="poolLocalInternal">
               <h3>
                  poolLocalInternal
                  <span class="badge">struct</span>
                  <a href="#poolLocalInternal" class="anchor" title="Link to poolLocalInternal">#</a>
               </h3>
               
               <p>Local per-P Pool appendix.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type poolLocalInternal struct {
private any
shared poolChain
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="readOnly" data-name="readOnly">
               <h3>
                  readOnly
                  <span class="badge">struct</span>
                  <a href="#readOnly" class="anchor" title="Link to readOnly">#</a>
               </h3>
               
               <p>readOnly is an immutable struct stored atomically in the Map.read field.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type readOnly struct {
m map[any]*entry
amended bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add adds delta, which may be negative, to the [WaitGroup] counter.
If the counter becomes zero, all goroutines blocked on [WaitGroup.Wait] are released.
If the counter goes negative, Add panics.
Note that calls with a positive delta that occur when the counter is zero
must happen before a Wait. Calls with a negative delta, or calls with a
positive delta that start when the counter is greater than zero, may happen
at any time.
Typically this means the calls to Add should execute before the statement
creating the goroutine or other event to be waited for.
If a WaitGroup is reused to wait for several independent sets of events,
new Add calls must happen after all previous Wait calls have returned.
See the WaitGroup example.</p>
               
               <pre><code>func (wg *WaitGroup) Add(delta int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Broadcast" data-name="Broadcast">
               <h3>
                  Broadcast 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Broadcast" class="anchor" title="Link to Broadcast">#</a>
               </h3>
               
               <p>Broadcast wakes all goroutines waiting on c.
It is allowed but not required for the caller to hold c.L
during the call.</p>
               
               <pre><code>func (c *Cond) Broadcast()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Clear" data-name="Clear">
               <h3>
                  Clear 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Clear" class="anchor" title="Link to Clear">#</a>
               </h3>
               
               <p>Clear deletes all the entries, resulting in an empty Map.</p>
               
               <pre><code>func (m *Map) Clear()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Clear" data-name="Clear">
               <h3>
                  Clear 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Clear" class="anchor" title="Link to Clear">#</a>
               </h3>
               
               <p>Clear deletes all the entries, resulting in an empty Map.</p>
               
               <pre><code>func (m *Map) Clear()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CompareAndDelete" data-name="CompareAndDelete">
               <h3>
                  CompareAndDelete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CompareAndDelete" class="anchor" title="Link to CompareAndDelete">#</a>
               </h3>
               
               <p>CompareAndDelete deletes the entry for key if its value is equal to old.
The old value must be of a comparable type.
If there is no current value for key in the map, CompareAndDelete
returns false (even if the old value is the nil interface value).</p>
               
               <pre><code>func (m *Map) CompareAndDelete(key any, old any) (deleted bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CompareAndDelete" data-name="CompareAndDelete">
               <h3>
                  CompareAndDelete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CompareAndDelete" class="anchor" title="Link to CompareAndDelete">#</a>
               </h3>
               
               <p>CompareAndDelete deletes the entry for key if its value is equal to old.
The old value must be of a comparable type.
If there is no current value for key in the map, CompareAndDelete
returns false (even if the old value is the nil interface value).</p>
               
               <pre><code>func (m *Map) CompareAndDelete(key any, old any) (deleted bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CompareAndSwap" data-name="CompareAndSwap">
               <h3>
                  CompareAndSwap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CompareAndSwap" class="anchor" title="Link to CompareAndSwap">#</a>
               </h3>
               
               <p>CompareAndSwap swaps the old and new values for key
if the value stored in the map is equal to old.
The old value must be of a comparable type.</p>
               
               <pre><code>func (m *Map) CompareAndSwap(key any, old any, new any) (swapped bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CompareAndSwap" data-name="CompareAndSwap">
               <h3>
                  CompareAndSwap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CompareAndSwap" class="anchor" title="Link to CompareAndSwap">#</a>
               </h3>
               
               <p>CompareAndSwap swaps the old and new values for key
if the value stored in the map is equal to old.
The old value must be of a comparable type.</p>
               
               <pre><code>func (m *Map) CompareAndSwap(key any, old any, new any) (swapped bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Delete" data-name="Delete">
               <h3>
                  Delete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Delete" class="anchor" title="Link to Delete">#</a>
               </h3>
               
               <p>Delete deletes the value for a key.</p>
               
               <pre><code>func (m *Map) Delete(key any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Delete" data-name="Delete">
               <h3>
                  Delete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Delete" class="anchor" title="Link to Delete">#</a>
               </h3>
               
               <p>Delete deletes the value for a key.</p>
               
               <pre><code>func (m *Map) Delete(key any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Do" data-name="Do">
               <h3>
                  Do 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Do" class="anchor" title="Link to Do">#</a>
               </h3>
               
               <p>Do calls the function f if and only if Do is being called for the
first time for this instance of [Once]. In other words, given
var once Once
if once.Do(f) is called multiple times, only the first call will invoke f,
even if f has a different value in each invocation. A new instance of
Once is required for each function to execute.
Do is intended for initialization that must be run exactly once. Since f
is niladic, it may be necessary to use a function literal to capture the
arguments to a function to be invoked by Do:
config.once.Do(func() { config.init(filename) })
Because no call to Do returns until the one call to f returns, if f causes
Do to be called, it will deadlock.
If f panics, Do considers it to have returned; future calls of Do return
without calling f.</p>
               
               <pre><code>func (o *Once) Do(f func())</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Done" data-name="Done">
               <h3>
                  Done 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Done" class="anchor" title="Link to Done">#</a>
               </h3>
               
               <p>Done decrements the [WaitGroup] counter by one.</p>
               
               <pre><code>func (wg *WaitGroup) Done()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Get" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Get" class="anchor" title="Link to Get">#</a>
               </h3>
               
               <p>Get selects an arbitrary item from the [Pool], removes it from the
Pool, and returns it to the caller.
Get may choose to ignore the pool and treat it as empty.
Callers should not assume any relation between values passed to [Pool.Put] and
the values returned by Get.
If Get would otherwise return nil and p.New is non-nil, Get returns
the result of calling p.New.</p>
               
               <pre><code>func (p *Pool) Get() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Load" data-name="Load">
               <h3>
                  Load 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Load" class="anchor" title="Link to Load">#</a>
               </h3>
               
               <p>Load returns the value stored in the map for a key, or nil if no
value is present.
The ok result indicates whether value was found in the map.</p>
               
               <pre><code>func (m *Map) Load(key any) (value any, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Load" data-name="Load">
               <h3>
                  Load 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Load" class="anchor" title="Link to Load">#</a>
               </h3>
               
               <p>Load returns the value stored in the map for a key, or nil if no
value is present.
The ok result indicates whether value was found in the map.</p>
               
               <pre><code>func (m *Map) Load(key any) (value any, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LoadAndDelete" data-name="LoadAndDelete">
               <h3>
                  LoadAndDelete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LoadAndDelete" class="anchor" title="Link to LoadAndDelete">#</a>
               </h3>
               
               <p>LoadAndDelete deletes the value for a key, returning the previous value if any.
The loaded result reports whether the key was present.</p>
               
               <pre><code>func (m *Map) LoadAndDelete(key any) (value any, loaded bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LoadAndDelete" data-name="LoadAndDelete">
               <h3>
                  LoadAndDelete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LoadAndDelete" class="anchor" title="Link to LoadAndDelete">#</a>
               </h3>
               
               <p>LoadAndDelete deletes the value for a key, returning the previous value if any.
The loaded result reports whether the key was present.</p>
               
               <pre><code>func (m *Map) LoadAndDelete(key any) (value any, loaded bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LoadOrStore" data-name="LoadOrStore">
               <h3>
                  LoadOrStore 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LoadOrStore" class="anchor" title="Link to LoadOrStore">#</a>
               </h3>
               
               <p>LoadOrStore returns the existing value for the key if present.
Otherwise, it stores and returns the given value.
The loaded result is true if the value was loaded, false if stored.</p>
               
               <pre><code>func (m *Map) LoadOrStore(key any, value any) (actual any, loaded bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LoadOrStore" data-name="LoadOrStore">
               <h3>
                  LoadOrStore 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LoadOrStore" class="anchor" title="Link to LoadOrStore">#</a>
               </h3>
               
               <p>LoadOrStore returns the existing value for the key if present.
Otherwise, it stores and returns the given value.
The loaded result is true if the value was loaded, false if stored.</p>
               
               <pre><code>func (m *Map) LoadOrStore(key any, value any) (actual any, loaded bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lock" data-name="Lock">
               <h3>
                  Lock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lock" class="anchor" title="Link to Lock">#</a>
               </h3>
               
               <p>Lock locks rw for writing.
If the lock is already locked for reading or writing,
Lock blocks until the lock is available.</p>
               
               <pre><code>func (rw *RWMutex) Lock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lock" data-name="Lock">
               <h3>
                  Lock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lock" class="anchor" title="Link to Lock">#</a>
               </h3>
               
               <pre><code>func (r *rlocker) Lock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lock" data-name="Lock">
               <h3>
                  Lock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lock" class="anchor" title="Link to Lock">#</a>
               </h3>
               
               <p>Lock locks m.
If the lock is already in use, the calling goroutine
blocks until the mutex is available.</p>
               
               <pre><code>func (m *Mutex) Lock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lock" data-name="Lock">
               <h3>
                  Lock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lock" class="anchor" title="Link to Lock">#</a>
               </h3>
               
               <p>Lock is a no-op used by -copylocks checker from `go vet`.</p>
               
               <pre><code>func (*noCopy) Lock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewCond" data-name="NewCond">
               <h3>
                  NewCond 
                  <span class="badge">function</span>
                  
                  <a href="#NewCond" class="anchor" title="Link to NewCond">#</a>
               </h3>
               
               <p>NewCond returns a new Cond with Locker l.</p>
               
               <pre><code>func NewCond(l Locker) *Cond</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OnceFunc" data-name="OnceFunc">
               <h3>
                  OnceFunc 
                  <span class="badge">function</span>
                  
                  <a href="#OnceFunc" class="anchor" title="Link to OnceFunc">#</a>
               </h3>
               
               <p>OnceFunc returns a function that invokes f only once. The returned function
may be called concurrently.
If f panics, the returned function will panic with the same value on every call.</p>
               
               <pre><code>func OnceFunc(f func()) func()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OnceValue" data-name="OnceValue">
               <h3>
                  OnceValue 
                  <span class="badge">function</span>
                  
                  <a href="#OnceValue" class="anchor" title="Link to OnceValue">#</a>
               </h3>
               
               <p>OnceValue returns a function that invokes f only once and returns the value
returned by f. The returned function may be called concurrently.
If f panics, the returned function will panic with the same value on every call.</p>
               
               <pre><code>func OnceValue(f func() T) (func() T)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OnceValues" data-name="OnceValues">
               <h3>
                  OnceValues 
                  <span class="badge">function</span>
                  
                  <a href="#OnceValues" class="anchor" title="Link to OnceValues">#</a>
               </h3>
               
               <p>OnceValues returns a function that invokes f only once and returns the values
returned by f. The returned function may be called concurrently.
If f panics, the returned function will panic with the same value on every call.</p>
               
               <pre><code>func OnceValues(f func() (T1, T2)) (func() (T1, T2))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Put" data-name="Put">
               <h3>
                  Put 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Put" class="anchor" title="Link to Put">#</a>
               </h3>
               
               <p>Put adds x to the pool.</p>
               
               <pre><code>func (p *Pool) Put(x any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RLock" data-name="RLock">
               <h3>
                  RLock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RLock" class="anchor" title="Link to RLock">#</a>
               </h3>
               
               <p>RLock locks rw for reading.
It should not be used for recursive read locking; a blocked Lock
call excludes new readers from acquiring the lock. See the
documentation on the [RWMutex] type.</p>
               
               <pre><code>func (rw *RWMutex) RLock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RLocker" data-name="RLocker">
               <h3>
                  RLocker 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RLocker" class="anchor" title="Link to RLocker">#</a>
               </h3>
               
               <p>RLocker returns a [Locker] interface that implements
the [Locker.Lock] and [Locker.Unlock] methods by calling rw.RLock and rw.RUnlock.</p>
               
               <pre><code>func (rw *RWMutex) RLocker() Locker</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RUnlock" data-name="RUnlock">
               <h3>
                  RUnlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RUnlock" class="anchor" title="Link to RUnlock">#</a>
               </h3>
               
               <p>RUnlock undoes a single [RWMutex.RLock] call;
it does not affect other simultaneous readers.
It is a run-time error if rw is not locked for reading
on entry to RUnlock.</p>
               
               <pre><code>func (rw *RWMutex) RUnlock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Range" data-name="Range">
               <h3>
                  Range 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Range" class="anchor" title="Link to Range">#</a>
               </h3>
               
               <p>Range calls f sequentially for each key and value present in the map.
If f returns false, range stops the iteration.
Range does not necessarily correspond to any consistent snapshot of the Map's
contents: no key will be visited more than once, but if the value for any key
is stored or deleted concurrently (including by f), Range may reflect any
mapping for that key from any point during the Range call. Range does not
block other methods on the receiver; even f itself may call any method on m.
Range may be O(N) with the number of elements in the map even if f returns
false after a constant number of calls.</p>
               
               <pre><code>func (m *Map) Range(f func(key any, value any) bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Range" data-name="Range">
               <h3>
                  Range 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Range" class="anchor" title="Link to Range">#</a>
               </h3>
               
               <p>Range calls f sequentially for each key and value present in the map.
If f returns false, range stops the iteration.
Range does not necessarily correspond to any consistent snapshot of the Map's
contents: no key will be visited more than once, but if the value for any key
is stored or deleted concurrently (including by f), Range may reflect any
mapping for that key from any point during the Range call. Range does not
block other methods on the receiver; even f itself may call any method on m.
Range may be O(N) with the number of elements in the map even if f returns
false after a constant number of calls.</p>
               
               <pre><code>func (m *Map) Range(f func(key any, value any) bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Signal" data-name="Signal">
               <h3>
                  Signal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Signal" class="anchor" title="Link to Signal">#</a>
               </h3>
               
               <p>Signal wakes one goroutine waiting on c, if there is any.
It is allowed but not required for the caller to hold c.L
during the call.
Signal() does not affect goroutine scheduling priority; if other goroutines
are attempting to lock c.L, they may be awoken before a "waiting" goroutine.</p>
               
               <pre><code>func (c *Cond) Signal()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Store" data-name="Store">
               <h3>
                  Store 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Store" class="anchor" title="Link to Store">#</a>
               </h3>
               
               <p>Store sets the value for a key.</p>
               
               <pre><code>func (m *Map) Store(key any, value any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Store" data-name="Store">
               <h3>
                  Store 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Store" class="anchor" title="Link to Store">#</a>
               </h3>
               
               <p>Store sets the value for a key.</p>
               
               <pre><code>func (m *Map) Store(key any, value any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <p>Swap swaps the value for a key and returns the previous value if any.
The loaded result reports whether the key was present.</p>
               
               <pre><code>func (m *Map) Swap(key any, value any) (previous any, loaded bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <p>Swap swaps the value for a key and returns the previous value if any.
The loaded result reports whether the key was present.</p>
               
               <pre><code>func (m *Map) Swap(key any, value any) (previous any, loaded bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TryLock" data-name="TryLock">
               <h3>
                  TryLock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TryLock" class="anchor" title="Link to TryLock">#</a>
               </h3>
               
               <p>TryLock tries to lock m and reports whether it succeeded.
Note that while correct uses of TryLock do exist, they are rare,
and use of TryLock is often a sign of a deeper problem
in a particular use of mutexes.</p>
               
               <pre><code>func (m *Mutex) TryLock() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TryLock" data-name="TryLock">
               <h3>
                  TryLock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TryLock" class="anchor" title="Link to TryLock">#</a>
               </h3>
               
               <p>TryLock tries to lock rw for writing and reports whether it succeeded.
Note that while correct uses of TryLock do exist, they are rare,
and use of TryLock is often a sign of a deeper problem
in a particular use of mutexes.</p>
               
               <pre><code>func (rw *RWMutex) TryLock() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TryRLock" data-name="TryRLock">
               <h3>
                  TryRLock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TryRLock" class="anchor" title="Link to TryRLock">#</a>
               </h3>
               
               <p>TryRLock tries to lock rw for reading and reports whether it succeeded.
Note that while correct uses of TryRLock do exist, they are rare,
and use of TryRLock is often a sign of a deeper problem
in a particular use of mutexes.</p>
               
               <pre><code>func (rw *RWMutex) TryRLock() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unlock" data-name="Unlock">
               <h3>
                  Unlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unlock" class="anchor" title="Link to Unlock">#</a>
               </h3>
               
               <pre><code>func (r *rlocker) Unlock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unlock" data-name="Unlock">
               <h3>
                  Unlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unlock" class="anchor" title="Link to Unlock">#</a>
               </h3>
               
               <p>Unlock unlocks m.
It is a run-time error if m is not locked on entry to Unlock.
A locked [Mutex] is not associated with a particular goroutine.
It is allowed for one goroutine to lock a Mutex and then
arrange for another goroutine to unlock it.</p>
               
               <pre><code>func (m *Mutex) Unlock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unlock" data-name="Unlock">
               <h3>
                  Unlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unlock" class="anchor" title="Link to Unlock">#</a>
               </h3>
               
               <pre><code>func (*noCopy) Unlock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unlock" data-name="Unlock">
               <h3>
                  Unlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unlock" class="anchor" title="Link to Unlock">#</a>
               </h3>
               
               <p>Unlock unlocks rw for writing. It is a run-time error if rw is
not locked for writing on entry to Unlock.
As with Mutexes, a locked [RWMutex] is not associated with a particular
goroutine. One goroutine may [RWMutex.RLock] ([RWMutex.Lock]) a RWMutex and then
arrange for another goroutine to [RWMutex.RUnlock] ([RWMutex.Unlock]) it.</p>
               
               <pre><code>func (rw *RWMutex) Unlock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Wait" data-name="Wait">
               <h3>
                  Wait 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Wait" class="anchor" title="Link to Wait">#</a>
               </h3>
               
               <p>Wait atomically unlocks c.L and suspends execution
of the calling goroutine. After later resuming execution,
Wait locks c.L before returning. Unlike in other systems,
Wait cannot return unless awoken by [Cond.Broadcast] or [Cond.Signal].
Because c.L is not locked while Wait is waiting, the caller
typically cannot assume that the condition is true when
Wait returns. Instead, the caller should Wait in a loop:
c.L.Lock()
for !condition() {
c.Wait()
}
... make use of condition ...
c.L.Unlock()</p>
               
               <pre><code>func (c *Cond) Wait()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Wait" data-name="Wait">
               <h3>
                  Wait 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Wait" class="anchor" title="Link to Wait">#</a>
               </h3>
               
               <p>Wait blocks until the [WaitGroup] counter is zero.</p>
               
               <pre><code>func (wg *WaitGroup) Wait()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="check" data-name="check">
               <h3>
                  check 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#check" class="anchor" title="Link to check">#</a>
               </h3>
               
               <pre><code>func (c *copyChecker) check()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="delete" data-name="delete">
               <h3>
                  delete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#delete" class="anchor" title="Link to delete">#</a>
               </h3>
               
               <pre><code>func (e *entry) delete() (value any, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dirtyLocked" data-name="dirtyLocked">
               <h3>
                  dirtyLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dirtyLocked" class="anchor" title="Link to dirtyLocked">#</a>
               </h3>
               
               <pre><code>func (m *Map) dirtyLocked()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doSlow" data-name="doSlow">
               <h3>
                  doSlow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doSlow" class="anchor" title="Link to doSlow">#</a>
               </h3>
               
               <pre><code>func (o *Once) doSlow(f func())</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fatal" data-name="fatal">
               <h3>
                  fatal 
                  <span class="badge">function</span>
                  
                  <a href="#fatal" class="anchor" title="Link to fatal">#</a>
               </h3>
               
               <pre><code>func fatal(string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getSlow" data-name="getSlow">
               <h3>
                  getSlow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getSlow" class="anchor" title="Link to getSlow">#</a>
               </h3>
               
               <pre><code>func (p *Pool) getSlow(pid int) any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indexLocal" data-name="indexLocal">
               <h3>
                  indexLocal 
                  <span class="badge">function</span>
                  
                  <a href="#indexLocal" class="anchor" title="Link to indexLocal">#</a>
               </h3>
               
               <pre><code>func indexLocal(l unsafe.Pointer, i int) *poolLocal</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="load" data-name="load">
               <h3>
                  load 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#load" class="anchor" title="Link to load">#</a>
               </h3>
               
               <pre><code>func (e *entry) load() (value any, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadReadOnly" data-name="loadReadOnly">
               <h3>
                  loadReadOnly 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#loadReadOnly" class="anchor" title="Link to loadReadOnly">#</a>
               </h3>
               
               <pre><code>func (m *Map) loadReadOnly() readOnly</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="missLocked" data-name="missLocked">
               <h3>
                  missLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#missLocked" class="anchor" title="Link to missLocked">#</a>
               </h3>
               
               <pre><code>func (m *Map) missLocked()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newEntry" data-name="newEntry">
               <h3>
                  newEntry 
                  <span class="badge">function</span>
                  
                  <a href="#newEntry" class="anchor" title="Link to newEntry">#</a>
               </h3>
               
               <pre><code>func newEntry(i any) *entry</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pack" data-name="pack">
               <h3>
                  pack 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pack" class="anchor" title="Link to pack">#</a>
               </h3>
               
               <pre><code>func (d *poolDequeue) pack(head uint32, tail uint32) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pin" data-name="pin">
               <h3>
                  pin 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pin" class="anchor" title="Link to pin">#</a>
               </h3>
               
               <p>pin pins the current goroutine to P, disables preemption and
returns poolLocal pool for the P and the P's id.
Caller must call runtime_procUnpin() when done with the pool.</p>
               
               <pre><code>func (p *Pool) pin() (*poolLocal, int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pinSlow" data-name="pinSlow">
               <h3>
                  pinSlow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pinSlow" class="anchor" title="Link to pinSlow">#</a>
               </h3>
               
               <pre><code>func (p *Pool) pinSlow() (*poolLocal, int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="poolCleanup" data-name="poolCleanup">
               <h3>
                  poolCleanup 
                  <span class="badge">function</span>
                  
                  <a href="#poolCleanup" class="anchor" title="Link to poolCleanup">#</a>
               </h3>
               
               <p>poolCleanup should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/bytedance/gopkg
- github.com/songzhibin97/gkit
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname poolCleanup</p>
               
               <pre><code>func poolCleanup()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="poolRaceAddr" data-name="poolRaceAddr">
               <h3>
                  poolRaceAddr 
                  <span class="badge">function</span>
                  
                  <a href="#poolRaceAddr" class="anchor" title="Link to poolRaceAddr">#</a>
               </h3>
               
               <p>poolRaceAddr returns an address to use as the synchronization point
for race detector logic. We don't use the actual pointer stored in x
directly, for fear of conflicting with other synchronization on that address.
Instead, we hash the pointer to get an index into poolRaceHash.
See discussion on golang.org/cl/31589.</p>
               
               <pre><code>func poolRaceAddr(x any) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="popHead" data-name="popHead">
               <h3>
                  popHead 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#popHead" class="anchor" title="Link to popHead">#</a>
               </h3>
               
               <p>popHead removes and returns the element at the head of the queue.
It returns false if the queue is empty. It must only be called by a
single producer.</p>
               
               <pre><code>func (d *poolDequeue) popHead() (any, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="popHead" data-name="popHead">
               <h3>
                  popHead 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#popHead" class="anchor" title="Link to popHead">#</a>
               </h3>
               
               <pre><code>func (c *poolChain) popHead() (any, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="popTail" data-name="popTail">
               <h3>
                  popTail 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#popTail" class="anchor" title="Link to popTail">#</a>
               </h3>
               
               <p>popTail removes and returns the element at the tail of the queue.
It returns false if the queue is empty. It may be called by any
number of consumers.</p>
               
               <pre><code>func (d *poolDequeue) popTail() (any, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="popTail" data-name="popTail">
               <h3>
                  popTail 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#popTail" class="anchor" title="Link to popTail">#</a>
               </h3>
               
               <pre><code>func (c *poolChain) popTail() (any, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pushHead" data-name="pushHead">
               <h3>
                  pushHead 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pushHead" class="anchor" title="Link to pushHead">#</a>
               </h3>
               
               <p>pushHead adds val at the head of the queue. It returns false if the
queue is full. It must only be called by a single producer.</p>
               
               <pre><code>func (d *poolDequeue) pushHead(val any) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pushHead" data-name="pushHead">
               <h3>
                  pushHead 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pushHead" class="anchor" title="Link to pushHead">#</a>
               </h3>
               
               <pre><code>func (c *poolChain) pushHead(val any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rUnlockSlow" data-name="rUnlockSlow">
               <h3>
                  rUnlockSlow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rUnlockSlow" class="anchor" title="Link to rUnlockSlow">#</a>
               </h3>
               
               <pre><code>func (rw *RWMutex) rUnlockSlow(r int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_LoadAcquintptr" data-name="runtime_LoadAcquintptr">
               <h3>
                  runtime_LoadAcquintptr 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_LoadAcquintptr" class="anchor" title="Link to runtime_LoadAcquintptr">#</a>
               </h3>
               
               <p>go:linkname runtime_LoadAcquintptr internal/runtime/atomic.LoadAcquintptr</p>
               
               <pre><code>func runtime_LoadAcquintptr(ptr *uintptr) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_Semacquire" data-name="runtime_Semacquire">
               <h3>
                  runtime_Semacquire 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_Semacquire" class="anchor" title="Link to runtime_Semacquire">#</a>
               </h3>
               
               <p>Semacquire waits until *s > 0 and then atomically decrements it.
It is intended as a simple sleep primitive for use by the synchronization
library and should not be used directly.</p>
               
               <pre><code>func runtime_Semacquire(s *uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_SemacquireRWMutex" data-name="runtime_SemacquireRWMutex">
               <h3>
                  runtime_SemacquireRWMutex 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_SemacquireRWMutex" class="anchor" title="Link to runtime_SemacquireRWMutex">#</a>
               </h3>
               
               <pre><code>func runtime_SemacquireRWMutex(s *uint32, lifo bool, skipframes int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_SemacquireRWMutexR" data-name="runtime_SemacquireRWMutexR">
               <h3>
                  runtime_SemacquireRWMutexR 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_SemacquireRWMutexR" class="anchor" title="Link to runtime_SemacquireRWMutexR">#</a>
               </h3>
               
               <p>Semacquire(RW)Mutex(R) is like Semacquire, but for profiling contended
Mutexes and RWMutexes.
If lifo is true, queue waiter at the head of wait queue.
skipframes is the number of frames to omit during tracing, counting from
runtime_SemacquireMutex's caller.
The different forms of this function just tell the runtime how to present
the reason for waiting in a backtrace, and is used to compute some metrics.
Otherwise they're functionally identical.</p>
               
               <pre><code>func runtime_SemacquireRWMutexR(s *uint32, lifo bool, skipframes int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_SemacquireWaitGroup" data-name="runtime_SemacquireWaitGroup">
               <h3>
                  runtime_SemacquireWaitGroup 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_SemacquireWaitGroup" class="anchor" title="Link to runtime_SemacquireWaitGroup">#</a>
               </h3>
               
               <p>SemacquireWaitGroup is like Semacquire, but for WaitGroup.Wait.</p>
               
               <pre><code>func runtime_SemacquireWaitGroup(s *uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_Semrelease" data-name="runtime_Semrelease">
               <h3>
                  runtime_Semrelease 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_Semrelease" class="anchor" title="Link to runtime_Semrelease">#</a>
               </h3>
               
               <p>Semrelease atomically increments *s and notifies a waiting goroutine
if one is blocked in Semacquire.
It is intended as a simple wakeup primitive for use by the synchronization
library and should not be used directly.
If handoff is true, pass count directly to the first waiter.
skipframes is the number of frames to omit during tracing, counting from
runtime_Semrelease's caller.</p>
               
               <pre><code>func runtime_Semrelease(s *uint32, handoff bool, skipframes int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_StoreReluintptr" data-name="runtime_StoreReluintptr">
               <h3>
                  runtime_StoreReluintptr 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_StoreReluintptr" class="anchor" title="Link to runtime_StoreReluintptr">#</a>
               </h3>
               
               <p>go:linkname runtime_StoreReluintptr internal/runtime/atomic.StoreReluintptr</p>
               
               <pre><code>func runtime_StoreReluintptr(ptr *uintptr, val uintptr) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_notifyListAdd" data-name="runtime_notifyListAdd">
               <h3>
                  runtime_notifyListAdd 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_notifyListAdd" class="anchor" title="Link to runtime_notifyListAdd">#</a>
               </h3>
               
               <p>See runtime/sema.go for documentation.</p>
               
               <pre><code>func runtime_notifyListAdd(l *notifyList) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_notifyListCheck" data-name="runtime_notifyListCheck">
               <h3>
                  runtime_notifyListCheck 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_notifyListCheck" class="anchor" title="Link to runtime_notifyListCheck">#</a>
               </h3>
               
               <p>Ensure that sync and runtime agree on size of notifyList.</p>
               
               <pre><code>func runtime_notifyListCheck(size uintptr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_notifyListNotifyAll" data-name="runtime_notifyListNotifyAll">
               <h3>
                  runtime_notifyListNotifyAll 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_notifyListNotifyAll" class="anchor" title="Link to runtime_notifyListNotifyAll">#</a>
               </h3>
               
               <p>See runtime/sema.go for documentation.</p>
               
               <pre><code>func runtime_notifyListNotifyAll(l *notifyList)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_notifyListNotifyOne" data-name="runtime_notifyListNotifyOne">
               <h3>
                  runtime_notifyListNotifyOne 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_notifyListNotifyOne" class="anchor" title="Link to runtime_notifyListNotifyOne">#</a>
               </h3>
               
               <p>See runtime/sema.go for documentation.</p>
               
               <pre><code>func runtime_notifyListNotifyOne(l *notifyList)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_notifyListWait" data-name="runtime_notifyListWait">
               <h3>
                  runtime_notifyListWait 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_notifyListWait" class="anchor" title="Link to runtime_notifyListWait">#</a>
               </h3>
               
               <p>See runtime/sema.go for documentation.</p>
               
               <pre><code>func runtime_notifyListWait(l *notifyList, t uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_procPin" data-name="runtime_procPin">
               <h3>
                  runtime_procPin 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_procPin" class="anchor" title="Link to runtime_procPin">#</a>
               </h3>
               
               <pre><code>func runtime_procPin() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_procUnpin" data-name="runtime_procUnpin">
               <h3>
                  runtime_procUnpin 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_procUnpin" class="anchor" title="Link to runtime_procUnpin">#</a>
               </h3>
               
               <pre><code>func runtime_procUnpin()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_randn" data-name="runtime_randn">
               <h3>
                  runtime_randn 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_randn" class="anchor" title="Link to runtime_randn">#</a>
               </h3>
               
               <p>from runtime
go:linkname runtime_randn runtime.randn</p>
               
               <pre><code>func runtime_randn(n uint32) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_registerPoolCleanup" data-name="runtime_registerPoolCleanup">
               <h3>
                  runtime_registerPoolCleanup 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_registerPoolCleanup" class="anchor" title="Link to runtime_registerPoolCleanup">#</a>
               </h3>
               
               <p>Implemented in runtime.</p>
               
               <pre><code>func runtime_registerPoolCleanup(cleanup func())</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="swapLocked" data-name="swapLocked">
               <h3>
                  swapLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#swapLocked" class="anchor" title="Link to swapLocked">#</a>
               </h3>
               
               <p>swapLocked unconditionally swaps a value into the entry.
The entry must be known not to be expunged.</p>
               
               <pre><code>func (e *entry) swapLocked(i *any) *any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="syscall_hasWaitingReaders" data-name="syscall_hasWaitingReaders">
               <h3>
                  syscall_hasWaitingReaders 
                  <span class="badge">function</span>
                  
                  <a href="#syscall_hasWaitingReaders" class="anchor" title="Link to syscall_hasWaitingReaders">#</a>
               </h3>
               
               <p>syscall_hasWaitingReaders reports whether any goroutine is waiting
to acquire a read lock on rw. This exists because syscall.ForkLock
is an RWMutex, and we can't change that without breaking compatibility.
We don't need or want RWMutex semantics for ForkLock, and we use
this private API to avoid having to change the type of ForkLock.
For more details see the syscall package.
go:linkname syscall_hasWaitingReaders syscall.hasWaitingReaders</p>
               
               <pre><code>func syscall_hasWaitingReaders(rw *RWMutex) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="throw" data-name="throw">
               <h3>
                  throw 
                  <span class="badge">function</span>
                  
                  <a href="#throw" class="anchor" title="Link to throw">#</a>
               </h3>
               
               <pre><code>func throw(string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tryCompareAndSwap" data-name="tryCompareAndSwap">
               <h3>
                  tryCompareAndSwap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tryCompareAndSwap" class="anchor" title="Link to tryCompareAndSwap">#</a>
               </h3>
               
               <p>tryCompareAndSwap compare the entry with the given old value and swaps
it with a new value if the entry is equal to the old value, and the entry
has not been expunged.
If the entry is expunged, tryCompareAndSwap returns false and leaves
the entry unchanged.</p>
               
               <pre><code>func (e *entry) tryCompareAndSwap(old any, new any) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tryExpungeLocked" data-name="tryExpungeLocked">
               <h3>
                  tryExpungeLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tryExpungeLocked" class="anchor" title="Link to tryExpungeLocked">#</a>
               </h3>
               
               <pre><code>func (e *entry) tryExpungeLocked() (isExpunged bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tryLoadOrStore" data-name="tryLoadOrStore">
               <h3>
                  tryLoadOrStore 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tryLoadOrStore" class="anchor" title="Link to tryLoadOrStore">#</a>
               </h3>
               
               <p>tryLoadOrStore atomically loads or stores a value if the entry is not
expunged.
If the entry is expunged, tryLoadOrStore leaves the entry unchanged and
returns with ok==false.</p>
               
               <pre><code>func (e *entry) tryLoadOrStore(i any) (actual any, loaded bool, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trySwap" data-name="trySwap">
               <h3>
                  trySwap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#trySwap" class="anchor" title="Link to trySwap">#</a>
               </h3>
               
               <p>trySwap swaps a value if the entry has not been expunged.
If the entry is expunged, trySwap returns false and leaves the entry
unchanged.</p>
               
               <pre><code>func (e *entry) trySwap(i *any) (*any, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unexpungeLocked" data-name="unexpungeLocked">
               <h3>
                  unexpungeLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unexpungeLocked" class="anchor" title="Link to unexpungeLocked">#</a>
               </h3>
               
               <p>unexpungeLocked ensures that the entry is not marked as expunged.
If the entry was previously expunged, it must be added to the dirty map
before m.mu is unlocked.</p>
               
               <pre><code>func (e *entry) unexpungeLocked() (wasExpunged bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unpack" data-name="unpack">
               <h3>
                  unpack 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unpack" class="anchor" title="Link to unpack">#</a>
               </h3>
               
               <pre><code>func (d *poolDequeue) unpack(ptrs uint64) (head uint32, tail uint32)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>