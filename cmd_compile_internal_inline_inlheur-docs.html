<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - inlheur</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>inlheur</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmp"
"encoding/json"
"fmt"
"internal/buildcfg"
"io"
"os"
"path/filepath"
"slices"
"strings"
"fmt"
"strings"
"bytes"
"strconv"
"cmd/compile/internal/ir"
"fmt"
"os"
"strconv"
"bytes"
"cmd/compile/internal/ir"
"cmd/compile/internal/pgoir"
"cmd/compile/internal/typecheck"
"fmt"
"os"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"fmt"
"os"
"strconv"
"bytes"
"cmd/compile/internal/ir"
"fmt"
"os"
"bytes"
"strconv"
"strconv"
"bytes"
"strings"
"cmd/compile/internal/ir"
"fmt"
"os"
"cmd/compile/internal/ir"
"fmt"
"go/constant"
"go/token"
"os"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/internal/src"
"fmt"
"io"
"path/filepath"
"sort"
"strings"
"bytes"
"strconv"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/pgoir"
"cmd/compile/internal/types"
"cmp"
"fmt"
"os"
"slices"
"strconv"
"strings"
"os"
"strconv"
"cmd/compile/internal/ir"
"go/constant"
"strconv"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="ActualExprConstant">
               <h3>
                  ActualExprConstant 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ActualExprConstant ActualExprPropBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="ActualExprIsConcreteConvIface">
               <h3>
                  ActualExprIsConcreteConvIface 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ActualExprIsConcreteConvIface</code></pre>
            </article>
            
            <article class="global" data-name="ActualExprIsFunc">
               <h3>
                  ActualExprIsFunc 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ActualExprIsFunc</code></pre>
            </article>
            
            <article class="global" data-name="ActualExprIsInlinableFunc">
               <h3>
                  ActualExprIsInlinableFunc 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ActualExprIsInlinableFunc</code></pre>
            </article>
            
            <article class="global" data-name="CallSiteInInitFunc">
               <h3>
                  CallSiteInInitFunc 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const CallSiteInInitFunc</code></pre>
            </article>
            
            <article class="global" data-name="CallSiteInLoop">
               <h3>
                  CallSiteInLoop 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const CallSiteInLoop CSPropBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="CallSiteOnPanicPath">
               <h3>
                  CallSiteOnPanicPath 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const CallSiteOnPanicPath</code></pre>
            </article>
            
            <article class="global" data-name="FuncPropNeverReturns">
               <h3>
                  FuncPropNeverReturns 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Function always panics or invokes os.Exit() or a func that does
likewise.</p>
               
               <pre><code>const FuncPropNeverReturns FuncPropBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="ParamFeedsIfOrSwitch">
               <h3>
                  ParamFeedsIfOrSwitch 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Parameter value feeds unmodified into a top level "switch"
statement or "if" statement simple expressions (see more on
"simple" expression classification below).</p>
               
               <pre><code>const ParamFeedsIfOrSwitch</code></pre>
            </article>
            
            <article class="global" data-name="ParamFeedsIndirectCall">
               <h3>
                  ParamFeedsIndirectCall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Parameter value feeds unmodified into a top level indirect
function call (assumes parameter is of function type).</p>
               
               <pre><code>const ParamFeedsIndirectCall</code></pre>
            </article>
            
            <article class="global" data-name="ParamFeedsInterfaceMethodCall">
               <h3>
                  ParamFeedsInterfaceMethodCall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Parameter value feeds unmodified into a top-level interface
call (this assumes the parameter is of interface type).</p>
               
               <pre><code>const ParamFeedsInterfaceMethodCall ParamPropBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="ParamMayFeedIfOrSwitch">
               <h3>
                  ParamMayFeedIfOrSwitch 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Parameter value feeds unmodified into a "switch" or "if"
statement simple expressions (see more on "simple" expression
classification below), where the if/switch is
conditional/nested.</p>
               
               <pre><code>const ParamMayFeedIfOrSwitch</code></pre>
            </article>
            
            <article class="global" data-name="ParamMayFeedIndirectCall">
               <h3>
                  ParamMayFeedIndirectCall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Parameter value feeds unmodified into an indirect function call
that is conditional/nested (not guaranteed to execute). Assumes
parameter is of function type.</p>
               
               <pre><code>const ParamMayFeedIndirectCall</code></pre>
            </article>
            
            <article class="global" data-name="ParamMayFeedInterfaceMethodCall">
               <h3>
                  ParamMayFeedInterfaceMethodCall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Parameter value feeds unmodified into an interface call that
may be conditional/nested and not always executed (this assumes
the parameter is of interface type).</p>
               
               <pre><code>const ParamMayFeedInterfaceMethodCall ParamPropBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="ParamNoInfo">
               <h3>
                  ParamNoInfo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>No info about this param</p>
               
               <pre><code>const ParamNoInfo ParamPropBits = 0</code></pre>
            </article>
            
            <article class="global" data-name="ResultAlwaysSameConstant">
               <h3>
                  ResultAlwaysSameConstant 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Result is always the same non-composite compile time constant.</p>
               
               <pre><code>const ResultAlwaysSameConstant</code></pre>
            </article>
            
            <article class="global" data-name="ResultAlwaysSameFunc">
               <h3>
                  ResultAlwaysSameFunc 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Result is always the same function or closure.</p>
               
               <pre><code>const ResultAlwaysSameFunc</code></pre>
            </article>
            
            <article class="global" data-name="ResultAlwaysSameInlinableFunc">
               <h3>
                  ResultAlwaysSameInlinableFunc 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Result is always the same (potentially) inlinable function or closure.</p>
               
               <pre><code>const ResultAlwaysSameInlinableFunc</code></pre>
            </article>
            
            <article class="global" data-name="ResultIsAllocatedMem">
               <h3>
                  ResultIsAllocatedMem 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>This result always contains allocated memory.</p>
               
               <pre><code>const ResultIsAllocatedMem ResultPropBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="ResultIsConcreteTypeConvertedToInterface">
               <h3>
                  ResultIsConcreteTypeConvertedToInterface 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>This result is always a single concrete type that is
implicitly converted to interface.</p>
               
               <pre><code>const ResultIsConcreteTypeConvertedToInterface</code></pre>
            </article>
            
            <article class="global" data-name="ResultNoInfo">
               <h3>
                  ResultNoInfo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>No info about this result</p>
               
               <pre><code>const ResultNoInfo ResultPropBits = 0</code></pre>
            </article>
            
            <article class="global" data-name="_ActualExprPropBits_index">
               <h3>
                  _ActualExprPropBits_index 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ActualExprPropBits_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="_ActualExprPropBits_name">
               <h3>
                  _ActualExprPropBits_name 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _ActualExprPropBits_name = "ActualExprConstantActualExprIsConcreteConvIfaceActualExprIsFuncActualExprIsInlinableFunc"</code></pre>
            </article>
            
            <article class="global" data-name="_ActualExprPropBits_value">
               <h3>
                  _ActualExprPropBits_value 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ActualExprPropBits_value = [...]uint64{...}</code></pre>
            </article>
            
            <article class="global" data-name="_CSPropBits_index">
               <h3>
                  _CSPropBits_index 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _CSPropBits_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="_CSPropBits_name">
               <h3>
                  _CSPropBits_name 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _CSPropBits_name = "CallSiteInLoopCallSiteOnPanicPathCallSiteInInitFunc"</code></pre>
            </article>
            
            <article class="global" data-name="_CSPropBits_value">
               <h3>
                  _CSPropBits_value 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _CSPropBits_value = [...]uint64{...}</code></pre>
            </article>
            
            <article class="global" data-name="_FuncPropBits_index">
               <h3>
                  _FuncPropBits_index 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _FuncPropBits_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="_FuncPropBits_name">
               <h3>
                  _FuncPropBits_name 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _FuncPropBits_name = "FuncPropNeverReturns"</code></pre>
            </article>
            
            <article class="global" data-name="_FuncPropBits_value">
               <h3>
                  _FuncPropBits_value 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _FuncPropBits_value = [...]uint64{...}</code></pre>
            </article>
            
            <article class="global" data-name="_ParamPropBits_index">
               <h3>
                  _ParamPropBits_index 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ParamPropBits_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="_ParamPropBits_name">
               <h3>
                  _ParamPropBits_name 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _ParamPropBits_name = "ParamNoInfoParamFeedsInterfaceMethodCallParamMayFeedInterfaceMethodCallParamFeedsIndirectCallParamMayFeedIndirectCallParamFeedsIfOrSwitchParamMayFeedIfOrSwitch"</code></pre>
            </article>
            
            <article class="global" data-name="_ParamPropBits_value">
               <h3>
                  _ParamPropBits_value 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ParamPropBits_value = [...]uint64{...}</code></pre>
            </article>
            
            <article class="global" data-name="_ResultPropBits_index">
               <h3>
                  _ResultPropBits_index 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ResultPropBits_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="_ResultPropBits_name">
               <h3>
                  _ResultPropBits_name 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _ResultPropBits_name = "ResultNoInfoResultIsAllocatedMemResultIsConcreteTypeConvertedToInterfaceResultAlwaysSameConstantResultAlwaysSameFuncResultAlwaysSameInlinableFunc"</code></pre>
            </article>
            
            <article class="global" data-name="_ResultPropBits_value">
               <h3>
                  _ResultPropBits_value 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ResultPropBits_value = [...]uint64{...}</code></pre>
            </article>
            
            <article class="global" data-name="_pstate_index">
               <h3>
                  _pstate_index 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _pstate_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="_pstate_name">
               <h3>
                  _pstate_name 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _pstate_name = "psNoInfopsCallsPanicpsMayReturnpsTop"</code></pre>
            </article>
            
            <article class="global" data-name="_scoreAdjustTyp_index">
               <h3>
                  _scoreAdjustTyp_index 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _scoreAdjustTyp_index = [...]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="_scoreAdjustTyp_name">
               <h3>
                  _scoreAdjustTyp_name 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _scoreAdjustTyp_name = "panicPathAdjinitFuncAdjinLoopAdjpassConstToIfAdjpassConstToNestedIfAdjpassConcreteToItfCallAdjpassConcreteToNestedItfCallAdjpassFuncToIndCallAdjpassFuncToNestedIndCallAdjpassInlinableFuncToIndCallAdjpassInlinableFuncToNestedIndCallAdjreturnFeedsConstToIfAdjreturnFeedsFuncToIndCallAdjreturnFeedsInlinableFuncToIndCallAdjreturnFeedsConcreteToInterfaceCallAdj"</code></pre>
            </article>
            
            <article class="global" data-name="_scoreAdjustTyp_value">
               <h3>
                  _scoreAdjustTyp_value 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _scoreAdjustTyp_value = [...]uint64{...}</code></pre>
            </article>
            
            <article class="global" data-name="adjValues">
               <h3>
                  adjValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var adjValues = map[scoreAdjustTyp]int{...}</code></pre>
            </article>
            
            <article class="global" data-name="allCallSites">
               <h3>
                  allCallSites 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var allCallSites CallSiteTab</code></pre>
            </article>
            
            <article class="global" data-name="callSiteTab">
               <h3>
                  callSiteTab 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>callSiteTab contains entries for each call in the function
currently being processed by InlineCalls; this variable will either
be set to 'cstabCache' below (for non-inlinable routines) or to the
local 'cstab' entry in the fnInlHeur object for inlinable routines.
NOTE: this assumes that inlining operations are happening in a serial,
single-threaded fashion,f which is true today but probably won't hold
in the future (for example, we might want to score the callsites
in multiple functions in parallel); if the inliner evolves in this
direction we'll need to come up with a different approach here.</p>
               
               <pre><code>var callSiteTab CallSiteTab</code></pre>
            </article>
            
            <article class="global" data-name="comDelimiter">
               <h3>
                  comDelimiter 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const comDelimiter = "<endpropsdump>"</code></pre>
            </article>
            
            <article class="global" data-name="csAuxInlined">
               <h3>
                  csAuxInlined 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const csAuxInlined = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="csDelimiter">
               <h3>
                  csDelimiter 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const csDelimiter = "<endcallsites>"</code></pre>
            </article>
            
            <article class="global" data-name="debugTrace">
               <h3>
                  debugTrace 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const debugTrace = 0</code></pre>
            </article>
            
            <article class="global" data-name="debugTrace">
               <h3>
                  debugTrace 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var debugTrace = 0</code></pre>
            </article>
            
            <article class="global" data-name="debugTraceCalls">
               <h3>
                  debugTraceCalls 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const debugTraceCalls</code></pre>
            </article>
            
            <article class="global" data-name="debugTraceExprClassify">
               <h3>
                  debugTraceExprClassify 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const debugTraceExprClassify</code></pre>
            </article>
            
            <article class="global" data-name="debugTraceFuncFlags">
               <h3>
                  debugTraceFuncFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const debugTraceFuncFlags</code></pre>
            </article>
            
            <article class="global" data-name="debugTraceFuncs">
               <h3>
                  debugTraceFuncs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const debugTraceFuncs = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="debugTraceParams">
               <h3>
                  debugTraceParams 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const debugTraceParams</code></pre>
            </article>
            
            <article class="global" data-name="debugTraceResults">
               <h3>
                  debugTraceResults 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const debugTraceResults</code></pre>
            </article>
            
            <article class="global" data-name="debugTraceScoring">
               <h3>
                  debugTraceScoring 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const debugTraceScoring</code></pre>
            </article>
            
            <article class="global" data-name="dumpBuffer">
               <h3>
                  dumpBuffer 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>dumpBuffer stores up function properties dumps when
"-d=dumpinlfuncprops=..." is in effect.</p>
               
               <pre><code>var dumpBuffer map[*ir.Func]fnInlHeur</code></pre>
            </article>
            
            <article class="global" data-name="exprLiterals">
               <h3>
                  exprLiterals 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>expr contains only literals</p>
               
               <pre><code>const exprLiterals</code></pre>
            </article>
            
            <article class="global" data-name="exprNoInfo">
               <h3>
                  exprNoInfo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>no info on this expr</p>
               
               <pre><code>const exprNoInfo disp = iota</code></pre>
            </article>
            
            <article class="global" data-name="exprSimple">
               <h3>
                  exprSimple 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>expr is legal combination of literals and specified names</p>
               
               <pre><code>const exprSimple</code></pre>
            </article>
            
            <article class="global" data-name="fnDelimiter">
               <h3>
                  fnDelimiter 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fnDelimiter = "<endfuncpreamble>"</code></pre>
            </article>
            
            <article class="global" data-name="fpmap">
               <h3>
                  fpmap 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var fpmap = map[*ir.Func]fnInlHeur{...}</code></pre>
            </article>
            
            <article class="global" data-name="inLoopAdj">
               <h3>
                  inLoopAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code>const inLoopAdj</code></pre>
            </article>
            
            <article class="global" data-name="initFuncAdj">
               <h3>
                  initFuncAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code>const initFuncAdj</code></pre>
            </article>
            
            <article class="global" data-name="mayMustAdj">
               <h3>
                  mayMustAdj 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var mayMustAdj = [...]struct{...}{...}</code></pre>
            </article>
            
            <article class="global" data-name="panicPathAdj">
               <h3>
                  panicPathAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Category 1 adjustments (see above)</p>
               
               <pre><code>const panicPathAdj scoreAdjustTyp = *ast.ParenExpr</code></pre>
            </article>
            
            <article class="global" data-name="paramFlagToPositiveAdj">
               <h3>
                  paramFlagToPositiveAdj 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var paramFlagToPositiveAdj map[ParamPropBits]scoreAdjustTyp</code></pre>
            </article>
            
            <article class="global" data-name="passConcreteToItfCallAdj">
               <h3>
                  passConcreteToItfCallAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code>const passConcreteToItfCallAdj</code></pre>
            </article>
            
            <article class="global" data-name="passConcreteToNestedItfCallAdj">
               <h3>
                  passConcreteToNestedItfCallAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code>const passConcreteToNestedItfCallAdj</code></pre>
            </article>
            
            <article class="global" data-name="passConstToIfAdj">
               <h3>
                  passConstToIfAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Category 2 adjustments (see above).</p>
               
               <pre><code>const passConstToIfAdj</code></pre>
            </article>
            
            <article class="global" data-name="passConstToNestedIfAdj">
               <h3>
                  passConstToNestedIfAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code>const passConstToNestedIfAdj</code></pre>
            </article>
            
            <article class="global" data-name="passFuncToIndCallAdj">
               <h3>
                  passFuncToIndCallAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code>const passFuncToIndCallAdj</code></pre>
            </article>
            
            <article class="global" data-name="passFuncToNestedIndCallAdj">
               <h3>
                  passFuncToNestedIndCallAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code>const passFuncToNestedIndCallAdj</code></pre>
            </article>
            
            <article class="global" data-name="passInlinableFuncToIndCallAdj">
               <h3>
                  passInlinableFuncToIndCallAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code>const passInlinableFuncToIndCallAdj</code></pre>
            </article>
            
            <article class="global" data-name="passInlinableFuncToNestedIndCallAdj">
               <h3>
                  passInlinableFuncToNestedIndCallAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code>const passInlinableFuncToNestedIndCallAdj</code></pre>
            </article>
            
            <article class="global" data-name="preambleDelimiter">
               <h3>
                  preambleDelimiter 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>delimiters written to various preambles to make parsing of
dumps easier.</p>
               
               <pre><code>const preambleDelimiter = "<endfilepreamble>"</code></pre>
            </article>
            
            <article class="global" data-name="psCallsPanic">
               <h3>
                  psCallsPanic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const psCallsPanic</code></pre>
            </article>
            
            <article class="global" data-name="psMayReturn">
               <h3>
                  psMayReturn 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const psMayReturn</code></pre>
            </article>
            
            <article class="global" data-name="psNoInfo">
               <h3>
                  psNoInfo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const psNoInfo pstate = iota</code></pre>
            </article>
            
            <article class="global" data-name="psTop">
               <h3>
                  psTop 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const psTop</code></pre>
            </article>
            
            <article class="global" data-name="resultFlagToPositiveAdj">
               <h3>
                  resultFlagToPositiveAdj 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var resultFlagToPositiveAdj map[ResultPropBits]scoreAdjustTyp</code></pre>
            </article>
            
            <article class="global" data-name="returnFeedsConcreteToInterfaceCallAdj">
               <h3>
                  returnFeedsConcreteToInterfaceCallAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code>const returnFeedsConcreteToInterfaceCallAdj</code></pre>
            </article>
            
            <article class="global" data-name="returnFeedsConstToIfAdj">
               <h3>
                  returnFeedsConstToIfAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Category 3 adjustments.</p>
               
               <pre><code>const returnFeedsConstToIfAdj</code></pre>
            </article>
            
            <article class="global" data-name="returnFeedsFuncToIndCallAdj">
               <h3>
                  returnFeedsFuncToIndCallAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code>const returnFeedsFuncToIndCallAdj</code></pre>
            </article>
            
            <article class="global" data-name="returnFeedsInlinableFuncToIndCallAdj">
               <h3>
                  returnFeedsInlinableFuncToIndCallAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code>const returnFeedsInlinableFuncToIndCallAdj</code></pre>
            </article>
            
            <article class="global" data-name="scoreCallsCache">
               <h3>
                  scoreCallsCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>scoreCallsCache caches a call site table and call site list between
invocations of ScoreCalls so that we can reuse previously allocated
storage.</p>
               
               <pre><code>var scoreCallsCache scoreCallsCacheType</code></pre>
            </article>
            
            <article class="global" data-name="sentinelScoreAdj">
               <h3>
                  sentinelScoreAdj 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code>const sentinelScoreAdj</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="ActualExprPropBits">
               <h3>
                  ActualExprPropBits
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>ActualExprPropBits describes a property of an actual expression (value
passed to some specific func argument at a call site).</p>
               
               <pre><code>type ActualExprPropBits uint8</code></pre>
            </article>
            
            <article class="type" data-name="CSPropBits">
               <h3>
                  CSPropBits
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type CSPropBits uint32</code></pre>
            </article>
            
            <article class="type" data-name="CallSiteTab">
               <h3>
                  CallSiteTab
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>CallSiteTab is a table of call sites, keyed by call expr.
Ideally it would be nice to key the table by src.XPos, but
this results in collisions for calls on very long lines (the
front end saturates column numbers at 255). We also wind up
with many calls that share the same auto-generated pos.</p>
               
               <pre><code>type CallSiteTab map[*ir.CallExpr]*CallSite</code></pre>
            </article>
            
            <article class="type" data-name="FuncPropBits">
               <h3>
                  FuncPropBits
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type FuncPropBits uint32</code></pre>
            </article>
            
            <article class="type" data-name="ParamPropBits">
               <h3>
                  ParamPropBits
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type ParamPropBits uint32</code></pre>
            </article>
            
            <article class="type" data-name="ResultPropBits">
               <h3>
                  ResultPropBits
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type ResultPropBits uint32</code></pre>
            </article>
            
            <article class="type" data-name="csAuxBits">
               <h3>
                  csAuxBits
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type csAuxBits uint8</code></pre>
            </article>
            
            <article class="type" data-name="disp">
               <h3>
                  disp
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type disp int</code></pre>
            </article>
            
            <article class="type" data-name="encodedCallSiteTab">
               <h3>
                  encodedCallSiteTab
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>encodedCallSiteTab is a table keyed by "encoded" callsite
(stringified src.XPos plus call site ID) mapping to a value of call
property bits and score.</p>
               
               <pre><code>type encodedCallSiteTab map[string]propsAndScore</code></pre>
            </article>
            
            <article class="type" data-name="pstate">
               <h3>
                  pstate
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>pstate keeps track of the disposition of a given node and its
children with respect to panic/exit calls.</p>
               
               <pre><code>type pstate int</code></pre>
            </article>
            
            <article class="type" data-name="scoreAdjustTyp">
               <h3>
                  scoreAdjustTyp
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>These constants enumerate the set of possible ways/scenarios
in which we'll adjust the score of a given callsite.</p>
               
               <pre><code>type scoreAdjustTyp uint</code></pre>
            </article>
            
            <article class="type" data-name="testfType">
               <h3>
                  testfType
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type testfType func(x ir.Node, param *ir.Name, idx int) (bool, bool)</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="propAnalyzer">
               <h3>
                  propAnalyzer
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>propAnalyzer interface is used for defining one or more analyzer
helper objects, each tasked with computing some specific subset of
the properties we're interested in. The assumption is that
properties are independent, so each new analyzer that implements
this interface can operate entirely on its own. For a given analyzer
there will be a sequence of calls to nodeVisitPre and nodeVisitPost
as the nodes within a function are visited, then a followup call to
setResults so that the analyzer can transfer its results into the
final properties object.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type propAnalyzer interface {
nodeVisitPre(n ir.Node)
nodeVisitPost(n ir.Node)
setResults(funcProps *FuncProps)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="CallSite">
               <h3>
                  CallSite
                  <span class="badge">struct</span>
               </h3>
               
               <p>CallSite records useful information about a potentially inlinable
(direct) function call. "Callee" is the target of the call, "Call"
is the ir node corresponding to the call itself, "Assign" is
the top-level assignment statement containing the call (if the call
appears in the form of a top-level statement, e.g. "x := foo()"),
"Flags" contains properties of the call that might be useful for
making inlining decisions, "Score" is the final score assigned to
the site, and "ID" is a numeric ID for the site within its
containing function.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CallSite struct {
Callee *ir.Func
Call *ir.CallExpr
parent *CallSite
Assign ir.Node
Flags CSPropBits
ArgProps []ActualExprPropBits
Score int
ScoreMask scoreAdjustTyp
ID uint
aux uint8
}</code></pre>
            </article>
            
            <article class="struct" data-name="FuncProps">
               <h3>
                  FuncProps
                  <span class="badge">struct</span>
               </h3>
               
               <p>FuncProps describes a set of function or method properties that may
be useful for inlining heuristics. Here 'Flags' are properties that
we think apply to the entire function; 'RecvrParamFlags' are
properties of specific function params (or the receiver), and
'ResultFlags' are things properties we think will apply to values
of specific results. Note that 'ParamFlags' includes and entry for
the receiver if applicable, and does include etries for blank
params; for a function such as "func foo(_ int, b byte, _ float32)"
the length of ParamFlags will be 3.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FuncProps struct {
Flags FuncPropBits
ParamFlags []ParamPropBits
ResultFlags []ResultPropBits
}</code></pre>
            </article>
            
            <article class="struct" data-name="callSiteAnalyzer">
               <h3>
                  callSiteAnalyzer
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type callSiteAnalyzer struct {
fn *ir.Func
*nameFinder
}</code></pre>
            </article>
            
            <article class="struct" data-name="callSiteTableBuilder">
               <h3>
                  callSiteTableBuilder
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type callSiteTableBuilder struct {
fn *ir.Func
*nameFinder
cstab CallSiteTab
ptab map[ir.Node]pstate
nstack []ir.Node
loopNest int
isInit bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="condLevelTracker">
               <h3>
                  condLevelTracker
                  <span class="badge">struct</span>
               </h3>
               
               <p>condLevelTracker helps keeps track very roughly of "level of conditional
nesting", e.g. how many "if" statements you have to go through to
get to the point where a given stmt executes. Example:
cond nesting level
func foo() {
G = 1                   0
if x < 10 {             0
if y < 10 {            1
G = 0                 2
}
}
}
The intent here is to provide some sort of very abstract relative
hotness metric, e.g. "G = 1" above is expected to be executed more
often than "G = 0" (in the aggregate, across large numbers of
functions).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type condLevelTracker struct {
condLevel int
}</code></pre>
            </article>
            
            <article class="struct" data-name="exprClassifier">
               <h3>
                  exprClassifier
                  <span class="badge">struct</span>
               </h3>
               
               <p>exprClassifier holds intermediate state about nodes within an
expression tree being analyzed by ShouldFoldIfNameConstant. Here
"name" is the name node passed in, and "disposition" stores the
result of classifying a given IR node.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type exprClassifier struct {
names map[*ir.Name]bool
disposition map[ir.Node]disp
}</code></pre>
            </article>
            
            <article class="struct" data-name="fnInlHeur">
               <h3>
                  fnInlHeur
                  <span class="badge">struct</span>
               </h3>
               
               <p>fnInlHeur contains inline heuristics state information about a
specific Go function being analyzed/considered by the inliner. Note
that in addition to constructing a fnInlHeur object by analyzing a
specific *ir.Func, there is also code in the test harness
(funcprops_test.go) that builds up fnInlHeur's by reading in and
parsing a dump. This is the reason why we have file/fname/line
fields below instead of just an *ir.Func field.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fnInlHeur struct {
props *FuncProps
cstab CallSiteTab
fname string
file string
line uint
}</code></pre>
            </article>
            
            <article class="struct" data-name="funcFlagsAnalyzer">
               <h3>
                  funcFlagsAnalyzer
                  <span class="badge">struct</span>
               </h3>
               
               <p>funcFlagsAnalyzer computes the "Flags" value for the FuncProps
object we're computing. The main item of interest here is "nstate",
which stores the disposition of a given ir Node with respect to the
flags/properties we're trying to compute.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type funcFlagsAnalyzer struct {
fn *ir.Func
nstate map[ir.Node]pstate
noInfo bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="nameFinder">
               <h3>
                  nameFinder
                  <span class="badge">struct</span>
               </h3>
               
               <p>nameFinder provides a set of "isXXX" query methods for clients to
ask whether a given AST node corresponds to a function, a constant
value, and so on. These methods use an underlying ir.ReassignOracle
to return more precise results in cases where an "interesting"
value is assigned to a singly-defined local temp. Example:
const q = 101
fq := func() int { return q }
copyOfConstant := q
copyOfFunc := f
interestingCall(copyOfConstant, copyOfFunc)
A name finder query method invoked on the arguments being passed to
"interestingCall" will be able detect that 'copyOfConstant' always
evaluates to a constant (even though it is in fact a PAUTO local
variable). A given nameFinder can also operate without using
ir.ReassignOracle (in cases where it is not practical to look
at the entire function); in such cases queries will still work
for explicit constant values and functions.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nameFinder struct {
ro *ir.ReassignOracle
}</code></pre>
            </article>
            
            <article class="struct" data-name="paramsAnalyzer">
               <h3>
                  paramsAnalyzer
                  <span class="badge">struct</span>
               </h3>
               
               <p>paramsAnalyzer holds state information for the phase that computes
flags for a Go functions parameters, for use in inline heuristics.
Note that the params slice below includes entries for blanks.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type paramsAnalyzer struct {
fname string
values []ParamPropBits
params []*ir.Name
top []bool
*condLevelTracker
*nameFinder
}</code></pre>
            </article>
            
            <article class="struct" data-name="propsAndScore">
               <h3>
                  propsAndScore
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type propsAndScore struct {
props CSPropBits
score int
mask scoreAdjustTyp
}</code></pre>
            </article>
            
            <article class="struct" data-name="resultPropAndCS">
               <h3>
                  resultPropAndCS
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type resultPropAndCS struct {
defcs *CallSite
props ResultPropBits
}</code></pre>
            </article>
            
            <article class="struct" data-name="resultUseAnalyzer">
               <h3>
                  resultUseAnalyzer
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type resultUseAnalyzer struct {
resultNameTab map[*ir.Name]resultPropAndCS
fn *ir.Func
cstab CallSiteTab
*condLevelTracker
}</code></pre>
            </article>
            
            <article class="struct" data-name="resultVal">
               <h3>
                  resultVal
                  <span class="badge">struct</span>
               </h3>
               
               <p>resultVal captures information about a specific result returned from
the function we're analyzing; we are interested in cases where
the func always returns the same constant, or always returns
the same function, etc. This container stores info on a the specific
scenarios we're looking for.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type resultVal struct {
cval constant.Value
fn *ir.Name
fnClo bool
top bool
derived bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="resultsAnalyzer">
               <h3>
                  resultsAnalyzer
                  <span class="badge">struct</span>
               </h3>
               
               <p>resultsAnalyzer stores state information for the process of
computing flags/properties for the return values of a specific Go
function, as part of inline heuristics synthesis.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type resultsAnalyzer struct {
fname string
props []ResultPropBits
values []resultVal
inlineMaxBudget int
*nameFinder
}</code></pre>
            </article>
            
            <article class="struct" data-name="scoreCallsCacheType">
               <h3>
                  scoreCallsCacheType
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type scoreCallsCacheType struct {
tab CallSiteTab
csl []*CallSite
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="AnalyzeFunc">
               <h3>
                  AnalyzeFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AnalyzeFunc computes function properties for fn and its contained
closures, updating the global 'fpmap' table. It is assumed that
"CanInline" has been run on fn and on the closures that feed
directly into calls; other closures not directly called will also
be checked inlinability for inlinability here in case they are
returned as a result.</p>
               
               <pre><code>func AnalyzeFunc(fn *ir.Func, canInline func(*ir.Func), budgetForFunc func(*ir.Func) int32, inlineMaxBudget int)</code></pre>
            </article>
            
            <article class="function" data-name="BudgetExpansion">
               <h3>
                  BudgetExpansion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>BudgetExpansion returns the amount to relax/expand the base
inlining budget when the new inliner is turned on; the inliner
will add the returned value to the hairiness budget.
Background: with the new inliner, the score for a given callsite
can be adjusted down by some amount due to heuristics, however we
won't know whether this is going to happen until much later after
the CanInline call. This function returns the amount to relax the
budget initially (to allow for a large score adjustment); later on
in RevisitInlinability we'll look at each individual function to
demote it if needed.</p>
               
               <pre><code>func BudgetExpansion(maxBudget int32) int32</code></pre>
            </article>
            
            <article class="function" data-name="DeserializeFromString">
               <h3>
                  DeserializeFromString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func DeserializeFromString(s string) *FuncProps</code></pre>
            </article>
            
            <article class="function" data-name="DumpFuncProps">
               <h3>
                  DumpFuncProps 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DumpFuncProps computes and caches function properties for the func
'fn', writing out a description of the previously computed set of
properties to the file given in 'dumpfile'. Used for the
"-d=dumpinlfuncprops=..." command line flag, intended for use
primarily in unit testing.</p>
               
               <pre><code>func DumpFuncProps(fn *ir.Func, dumpfile string)</code></pre>
            </article>
            
            <article class="function" data-name="DumpInlCallSiteScores">
               <h3>
                  DumpInlCallSiteScores 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DumpInlCallSiteScores is invoked by the inliner if the debug flag
"-d=dumpinlcallsitescores" is set; it dumps out a human-readable
summary of all (potentially) inlinable callsites in the package,
along with info on call site scoring and the adjustments made to a
given score. Here profile is the PGO profile in use (may be
nil), budgetCallback is a callback that can be invoked to find out
the original pre-adjustment hairiness limit for the function, and
inlineHotMaxBudget is the constant of the same name used in the
inliner. Sample output lines:
Score  Adjustment  Status  Callee  CallerPos ScoreFlags
115    40          DEMOTED cmd/compile/internal/abi.(*ABIParamAssignment).Offset     expand_calls.go:1679:14|6       panicPathAdj
76     -5n         PROMOTED runtime.persistentalloc   mcheckmark.go:48:45|3   inLoopAdj
201    0           --- PGO  unicode.DecodeRuneInString        utf8.go:312:30|1
7      -5          --- PGO  internal/abi.Name.DataChecked     type.go:625:22|0        inLoopAdj
In the dump above, "Score" is the final score calculated for the
callsite, "Adjustment" is the amount added to or subtracted from
the original hairiness estimate to form the score. "Status" shows
whether anything changed with the site -- did the adjustment bump
it down just below the threshold ("PROMOTED") or instead bump it
above the threshold ("DEMOTED"); this will be blank ("---") if no
threshold was crossed as a result of the heuristics. Note that
"Status" also shows whether PGO was involved. "Callee" is the name
of the function called, "CallerPos" is the position of the
callsite, and "ScoreFlags" is a digest of the specific properties
we used to make adjustments to callsite score via heuristics.</p>
               
               <pre><code>func DumpInlCallSiteScores(profile *pgoir.Profile, budgetCallback func(fn *ir.Func, profile *pgoir.Profile) (int32, bool))</code></pre>
            </article>
            
            <article class="function" data-name="Enabled">
               <h3>
                  Enabled 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func Enabled() bool</code></pre>
            </article>
            
            <article class="function" data-name="EncodeCallSiteKey">
               <h3>
                  EncodeCallSiteKey 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func EncodeCallSiteKey(cs *CallSite) string</code></pre>
            </article>
            
            <article class="function" data-name="GetCallSiteScore">
               <h3>
                  GetCallSiteScore 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>GetCallSiteScore returns the previously calculated score for call
within fn.</p>
               
               <pre><code>func GetCallSiteScore(fn *ir.Func, call *ir.CallExpr) (int, bool)</code></pre>
            </article>
            
            <article class="function" data-name="LargestNegativeScoreAdjustment">
               <h3>
                  LargestNegativeScoreAdjustment 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LargestNegativeScoreAdjustment tries to estimate the largest possible
negative score adjustment that could be applied to a call of the
function with the specified props. Example:
func foo() {                  func bar(x int, p *int) int {
...                          if x < 0 { *p = x }
}                               return 99
}
Function 'foo' above on the left has no interesting properties,
thus as a result the most we'll adjust any call to is the value for
"call in loop". If the calculated cost of the function is 150, and
the in-loop adjustment is 5 (for example), then there is not much
point treating it as inlinable. On the other hand "bar" has a param
property (parameter "x" feeds unmodified to an "if" statement) and
a return property (always returns same constant) meaning that a
given call _could_ be rescored down as much as -35 points-- thus if
the size of "bar" is 100 (for example) then there is at least a
chance that scoring will enable inlining.</p>
               
               <pre><code>func LargestNegativeScoreAdjustment(fn *ir.Func, props *FuncProps) int</code></pre>
            </article>
            
            <article class="function" data-name="LargestPositiveScoreAdjustment">
               <h3>
                  LargestPositiveScoreAdjustment 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LargestPositiveScoreAdjustment tries to estimate the largest possible
positive score adjustment that could be applied to a given callsite.
At the moment we don't have very many positive score adjustments, so
this is just hard-coded, not table-driven.</p>
               
               <pre><code>func LargestPositiveScoreAdjustment(fn *ir.Func) int</code></pre>
            </article>
            
            <article class="function" data-name="ScoreCalls">
               <h3>
                  ScoreCalls 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ScoreCalls assigns numeric scores to each of the callsites in
function 'fn'; the lower the score, the more helpful we think it
will be to inline.
Unlike a lot of the other inline heuristics machinery, callsite
scoring can't be done as part of the CanInline call for a function,
due to fact that we may be working on a non-trivial SCC. So for
example with this SCC:
func foo(x int) {           func bar(x int, f func()) {
if x != 0 {                  f()
bar(x, func(){})           foo(x-1)
}                         }
}
We don't want to perform scoring for the 'foo' call in "bar" until
after foo has been analyzed, but it's conceivable that CanInline
might visit bar before foo for this SCC.</p>
               
               <pre><code>func ScoreCalls(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function" data-name="ScoreCallsCleanup">
               <h3>
                  ScoreCallsCleanup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ScoreCallsCleanup resets the state of the callsite cache
once ScoreCalls is done with a function.</p>
               
               <pre><code>func ScoreCallsCleanup()</code></pre>
            </article>
            
            <article class="function" data-name="SerializeToString">
               <h3>
                  SerializeToString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (funcProps *FuncProps) SerializeToString() string</code></pre>
            </article>
            
            <article class="function" data-name="SetupScoreAdjustments">
               <h3>
                  SetupScoreAdjustments 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SetupScoreAdjustments interprets the value of the -d=inlscoreadj
debugging option, if set. The value of this flag is expected to be
a series of "/"-separated clauses of the form adj1:value1. Example:
-d=inlscoreadj=inLoopAdj=0/passConstToIfAdj=-99</p>
               
               <pre><code>func SetupScoreAdjustments()</code></pre>
            </article>
            
            <article class="function" data-name="ShouldFoldIfNameConstant">
               <h3>
                  ShouldFoldIfNameConstant 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ShouldFoldIfNameConstant analyzes expression tree 'e' to see
whether it contains only combinations of simple references to all
of the names in 'names' with selected constants + operators. The
intent is to identify expression that could be folded away to a
constant if the value of 'n' were available. Return value is TRUE
if 'e' does look foldable given the value of 'n', and given that
'e' actually makes reference to 'n'. Some examples where the type
of "n" is int64, type of "s" is string, and type of "p" is *byte:
Simple?		Expr
yes			n<10
yes			n*n-100
yes			(n < 10 || n > 100) && (n >= 12 || n <= 99 || n != 101)
yes			s == "foo"
yes			p == nil
no			n<foo()
no			n<1 || n>m
no			float32(n)<1.0
no			*p == 1
no			1 + 100
no			1 / n
no			1 + unsafe.Sizeof(n)
To avoid complexities (e.g. nan, inf) we stay way from folding and
floating point or complex operations (integers, bools, and strings
only). We also try to be conservative about avoiding any operation
that might result in a panic at runtime, e.g. for "n" with type
int64:
1<<(n-9) < 100/(n<<9999)
we would return FALSE due to the negative shift count and/or
potential divide by zero.</p>
               
               <pre><code>func ShouldFoldIfNameConstant(n ir.Node, names []*ir.Name) bool</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i pstate) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fp *FuncProps) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i CSPropBits) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pas propsAndScore) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d disp) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i ResultPropBits) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i ActualExprPropBits) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i scoreAdjustTyp) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i ParamPropBits) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i FuncPropBits) String() string</code></pre>
            </article>
            
            <article class="function" data-name="TearDown">
               <h3>
                  TearDown 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TearDown is invoked at the end of the main inlining pass; doing
function analysis and call site scoring is unlikely to help a lot
after this point, so nil out fpmap and other globals to reclaim
storage.</p>
               
               <pre><code>func TearDown()</code></pre>
            </article>
            
            <article class="function" data-name="ToString">
               <h3>
                  ToString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fp *FuncProps) ToString(prefix string) string</code></pre>
            </article>
            
            <article class="function" data-name="UnitTesting">
               <h3>
                  UnitTesting 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func UnitTesting() bool</code></pre>
            </article>
            
            <article class="function" data-name="UpdateCallsiteTable">
               <h3>
                  UpdateCallsiteTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>UpdateCallsiteTable handles updating of callerfn's call site table
after an inlined has been carried out, e.g. the call at 'n' as been
turned into the inlined call expression 'ic' within function
callerfn. The chief thing of interest here is to make sure that any
call nodes within 'ic' are added to the call site table for
'callerfn' and scored appropriately.</p>
               
               <pre><code>func UpdateCallsiteTable(callerfn *ir.Func, n *ir.CallExpr, ic *ir.InlinedCallExpr)</code></pre>
            </article>
            
            <article class="function" data-name="Visit">
               <h3>
                  Visit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Visit sets the classification for 'n' based on the previously
calculated classifications for n's children, as part of a bottom-up
walk over an expression tree.</p>
               
               <pre><code>func (ec *exprClassifier) Visit(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _()</code></pre>
            </article>
            
            <article class="function" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _()</code></pre>
            </article>
            
            <article class="function" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _()</code></pre>
            </article>
            
            <article class="function" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _()</code></pre>
            </article>
            
            <article class="function" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _()</code></pre>
            </article>
            
            <article class="function" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _()</code></pre>
            </article>
            
            <article class="function" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _()</code></pre>
            </article>
            
            <article class="function" data-name="addCallSite">
               <h3>
                  addCallSite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (cstb *callSiteTableBuilder) addCallSite(callee *ir.Func, call *ir.CallExpr)</code></pre>
            </article>
            
            <article class="function" data-name="addParamsAnalyzer">
               <h3>
                  addParamsAnalyzer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addParamsAnalyzer creates a new paramsAnalyzer helper object for
the function fn, appends it to the analyzers list, and returns the
new list. If the function in question doesn't have any interesting
parameters then the analyzer list is returned unchanged, and the
params flags in "fp" are updated accordingly.</p>
               
               <pre><code>func addParamsAnalyzer(fn *ir.Func, analyzers []propAnalyzer, fp *FuncProps, nf *nameFinder) []propAnalyzer</code></pre>
            </article>
            
            <article class="function" data-name="addResultsAnalyzer">
               <h3>
                  addResultsAnalyzer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addResultsAnalyzer creates a new resultsAnalyzer helper object for
the function fn, appends it to the analyzers list, and returns the
new list. If the function in question doesn't have any returns (or
any interesting returns) then the analyzer list is left as is, and
the result flags in "fp" are updated accordingly.</p>
               
               <pre><code>func addResultsAnalyzer(fn *ir.Func, analyzers []propAnalyzer, fp *FuncProps, inlineMaxBudget int, nf *nameFinder) []propAnalyzer</code></pre>
            </article>
            
            <article class="function" data-name="adjStringToVal">
               <h3>
                  adjStringToVal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func adjStringToVal(s string) (scoreAdjustTyp, bool)</code></pre>
            </article>
            
            <article class="function" data-name="adjValue">
               <h3>
                  adjValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func adjValue(x scoreAdjustTyp) int</code></pre>
            </article>
            
            <article class="function" data-name="adjustScore">
               <h3>
                  adjustScore 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func adjustScore(typ scoreAdjustTyp, score int, mask scoreAdjustTyp) (int, scoreAdjustTyp)</code></pre>
            </article>
            
            <article class="function" data-name="analyzeFunc">
               <h3>
                  analyzeFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func analyzeFunc(fn *ir.Func, inlineMaxBudget int, nf *nameFinder) *FuncProps</code></pre>
            </article>
            
            <article class="function" data-name="analyzeResult">
               <h3>
                  analyzeResult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>analyzeResult examines the expression 'n' being returned as the
'ii'th argument in some return statement to see whether has
interesting characteristics (for example, returns a constant), then
applies a dataflow "meet" operation to combine this result with any
previous result (for the given return slot) that we've already
processed.</p>
               
               <pre><code>func (ra *resultsAnalyzer) analyzeResult(ii int, n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="argPropsForCall">
               <h3>
                  argPropsForCall 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>argPropsForCall returns a slice of argument properties for the
expressions being passed to the callee in the specific call
expression; these will be stored in the CallSite object for a given
call and then consulted when scoring. If no arg has any interesting
properties we try to save some space and return a nil slice.</p>
               
               <pre><code>func (cstb *callSiteTableBuilder) argPropsForCall(ce *ir.CallExpr) []ActualExprPropBits</code></pre>
            </article>
            
            <article class="function" data-name="blockCombine">
               <h3>
                  blockCombine 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>blockCombine merges together states as part of a linear sequence of
statements, where 'pred' and 'succ' are analysis results for a pair
of consecutive statements. Examples:
case 1:             case 2:
panic("foo")      if q { return x }        <-pred
return x          panic("boo")             <-succ
In case 1, since the pred state is "always panic" it doesn't matter
what the succ state is, hence the state for the combination of the
two blocks is "always panics". In case 2, because there is a path
to return that avoids the panic in succ, the state for the
combination of the two statements is "may return".</p>
               
               <pre><code>func blockCombine(pred pstate, succ pstate) pstate</code></pre>
            </article>
            
            <article class="function" data-name="branchCombine">
               <h3>
                  branchCombine 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>branchCombine combines two states at a control flow branch point where
either p1 or p2 executes (as in an "if" statement).</p>
               
               <pre><code>func branchCombine(p1 pstate, p2 pstate) pstate</code></pre>
            </article>
            
            <article class="function" data-name="buildEncodedCallSiteTab">
               <h3>
                  buildEncodedCallSiteTab 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func buildEncodedCallSiteTab(tab CallSiteTab) encodedCallSiteTab</code></pre>
            </article>
            
            <article class="function" data-name="callCheckParams">
               <h3>
                  callCheckParams 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>callCheckParams examines the target of call expression 'ce' to see
if it is making a call to the value passed in for some parameter.</p>
               
               <pre><code>func (pa *paramsAnalyzer) callCheckParams(ce *ir.CallExpr)</code></pre>
            </article>
            
            <article class="function" data-name="callTargetCheckResults">
               <h3>
                  callTargetCheckResults 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>callTargetCheckResults examines a given call to see whether the
callee expression is potentially an inlinable function returned
from a potentially inlinable call. Examples:
Scenario 1: named intermediate
fn1 := foo()         conc := bar()
fn1("blah")          conc.MyMethod()
Scenario 2: returned func or concrete object feeds directly to call
foo()("blah")        bar().MyMethod()
In the second case although at the source level the result of the
direct call feeds right into the method call or indirect call,
we're relying on the front end having inserted an auto-temp to
capture the value.</p>
               
               <pre><code>func (rua *resultUseAnalyzer) callTargetCheckResults(call ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="captureFuncDumpEntry">
               <h3>
                  captureFuncDumpEntry 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>captureFuncDumpEntry grabs the function properties object for 'fn'
and enqueues it for later dumping. Used for the
"-d=dumpinlfuncprops=..." command line flag, intended for use
primarily in unit testing.</p>
               
               <pre><code>func captureFuncDumpEntry(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function" data-name="checkParams">
               <h3>
                  checkParams 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>paramsAnalyzer invokes function 'testf' on the specified expression
'x' for each parameter, and if the result is TRUE, or's 'flag' into
the flags for that param.</p>
               
               <pre><code>func (pa *paramsAnalyzer) checkParams(x ir.Node, flag ParamPropBits, mayflag ParamPropBits, testf testfType)</code></pre>
            </article>
            
            <article class="function" data-name="collectNamesUsed">
               <h3>
                  collectNamesUsed 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func collectNamesUsed(expr ir.Node) []*ir.Name</code></pre>
            </article>
            
            <article class="function" data-name="computeCallSiteScore">
               <h3>
                  computeCallSiteScore 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>computeCallSiteScore takes a given call site whose ir node is
'call' and callee function is 'callee' and with previously computed
call site properties 'csflags', then computes a score for the
callsite that combines the size cost of the callee with heuristics
based on previously computed argument and function properties,
then stores the score and the adjustment mask in the appropriate
fields in 'cs'</p>
               
               <pre><code>func (cs *CallSite) computeCallSiteScore(csa *callSiteAnalyzer, calleeProps *FuncProps)</code></pre>
            </article>
            
            <article class="function" data-name="computeCallSiteTable">
               <h3>
                  computeCallSiteTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>computeCallSiteTable builds and returns a table of call sites for
the specified region in function fn. A region here corresponds to a
specific subtree within the AST for a function. The main intended
use cases are for 'region' to be either A) an entire function body,
or B) an inlined call expression.</p>
               
               <pre><code>func computeCallSiteTable(fn *ir.Func, region ir.Nodes, cstab CallSiteTab, ptab map[ir.Node]pstate, loopNestingLevel int, nf *nameFinder) CallSiteTab</code></pre>
            </article>
            
            <article class="function" data-name="computeFuncProps">
               <h3>
                  computeFuncProps 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>computeFuncProps examines the Go function 'fn' and computes for it
a function "properties" object, to be used to drive inlining
heuristics. See comments on the FuncProps type for more info.</p>
               
               <pre><code>func computeFuncProps(fn *ir.Func, inlineMaxBudget int, nf *nameFinder) (*FuncProps, CallSiteTab)</code></pre>
            </article>
            
            <article class="function" data-name="constValue">
               <h3>
                  constValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>constValue returns the underlying constant.Value for an AST node n
if n is itself a constant value/expr, or if n is a singly assigned
local containing constant expr/value (or nil not constant).</p>
               
               <pre><code>func (nf *nameFinder) constValue(n ir.Node) constant.Value</code></pre>
            </article>
            
            <article class="function" data-name="containingAssignment">
               <h3>
                  containingAssignment 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>containingAssignment returns the top-level assignment statement
for a statement level function call "n". Examples:
x := foo()
x, y := bar(z, baz())
if blah() { ...
Here the top-level assignment statement for the foo() call is the
statement assigning to "x"; the top-level assignment for "bar()"
call is the assignment to x,y. For the baz() and blah() calls,
there is no top level assignment statement.
The unstated goal here is that we want to use the containing
assignment to establish a connection between a given call and the
variables to which its results/returns are being assigned.
Note that for the "bar" command above, the front end sometimes
decomposes this into two assignments, the first one assigning the
call to a pair of auto-temps, then the second one assigning the
auto-temps to the user-visible vars. This helper will return the
second (outer) of these two.</p>
               
               <pre><code>func (cstb *callSiteTableBuilder) containingAssignment(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="deriveFlagsFromCallee">
               <h3>
                  deriveFlagsFromCallee 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>deriveFlagsFromCallee tries to derive flags for the current
function based on a call this function makes to some other
function. Example:
/* Simple */                /* Derived from callee
func foo(f func(int)) {     func foo(f func(int)) {
f(2)                        bar(32, f)
}                           }
func bar(x int, f func()) {
f(x)
}
Here we can set the "param feeds indirect call" flag for
foo's param 'f' since we know that bar has that flag set for
its second param, and we're passing that param a function.</p>
               
               <pre><code>func (pa *paramsAnalyzer) deriveFlagsFromCallee(ce *ir.CallExpr, callee *ir.Func)</code></pre>
            </article>
            
            <article class="function" data-name="deriveReturnFlagsFromCallee">
               <h3>
                  deriveReturnFlagsFromCallee 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>deriveReturnFlagsFromCallee tries to set properties for a given
return result where we're returning call expression; return value
is a return property value and a boolean indicating whether the
prop is valid. Examples:
func foo() int { return bar() }
func bar() int { return 42 }
func blix() int { return 43 }
func two(y int) int {
if y < 0 { return bar() } else { return blix() }
}
Since "foo" always returns the result of a call to "bar", we can
set foo's return property to that of bar. In the case of "two", however,
even though each return path returns a constant, we don't know
whether the constants are identical, hence we need to be conservative.</p>
               
               <pre><code>func (ra *resultsAnalyzer) deriveReturnFlagsFromCallee(n ir.Node) (ResultPropBits, bool)</code></pre>
            </article>
            
            <article class="function" data-name="determinePanicPathBits">
               <h3>
                  determinePanicPathBits 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>determinePanicPathBits updates the CallSiteOnPanicPath bit within
"r" if we think this call is on an unconditional path to
panic/exit. Do this by walking back up the node stack to see if we
can find either A) an enclosing panic, or B) a statement node that
we've determined leads to a panic/exit.</p>
               
               <pre><code>func (cstb *callSiteTableBuilder) determinePanicPathBits(call ir.Node, r CSPropBits) CSPropBits</code></pre>
            </article>
            
            <article class="function" data-name="disableDebugTrace">
               <h3>
                  disableDebugTrace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func disableDebugTrace()</code></pre>
            </article>
            
            <article class="function" data-name="disableDebugTrace">
               <h3>
                  disableDebugTrace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func disableDebugTrace()</code></pre>
            </article>
            
            <article class="function" data-name="dispmeet">
               <h3>
                  dispmeet 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>dispmeet performs a "meet" operation on the data flow states of
node x and y (where the term "meet" is being drawn from traditional
lattice-theoretical data flow analysis terminology).</p>
               
               <pre><code>func (ec *exprClassifier) dispmeet(x ir.Node, y ir.Node) disp</code></pre>
            </article>
            
            <article class="function" data-name="dumpCallSiteComments">
               <h3>
                  dumpCallSiteComments 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dumpCallSiteComments emits comments into the dump file for the
callsites in the function of interest. If "ecst" is non-nil, we use
that, otherwise generated a fresh encodedCallSiteTab from "tab".</p>
               
               <pre><code>func dumpCallSiteComments(w io.Writer, tab CallSiteTab, ecst encodedCallSiteTab)</code></pre>
            </article>
            
            <article class="function" data-name="dumpFilePreamble">
               <h3>
                  dumpFilePreamble 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dumpFilePreamble writes out a file-level preamble for a given
Go function as part of a function properties dump.</p>
               
               <pre><code>func dumpFilePreamble(w io.Writer)</code></pre>
            </article>
            
            <article class="function" data-name="dumpFnPreamble">
               <h3>
                  dumpFnPreamble 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dumpFnPreamble writes out a function-level preamble for a given
Go function as part of a function properties dump. See the
README.txt file in testdata/props for more on the format of
this preamble.</p>
               
               <pre><code>func dumpFnPreamble(w io.Writer, funcInlHeur *fnInlHeur, ecst encodedCallSiteTab, idx uint, atl uint) error</code></pre>
            </article>
            
            <article class="function" data-name="emitDumpToFile">
               <h3>
                  emitDumpToFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>emitDumpToFile writes out the buffer function property dump entries
to a file, for unit testing. Dump entries need to be sorted by
definition line, and due to generics we need to account for the
possibility that several ir.Func's will have the same def line.</p>
               
               <pre><code>func emitDumpToFile(dumpfile string)</code></pre>
            </article>
            
            <article class="function" data-name="enableDebugTrace">
               <h3>
                  enableDebugTrace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func enableDebugTrace(x int)</code></pre>
            </article>
            
            <article class="function" data-name="enableDebugTrace">
               <h3>
                  enableDebugTrace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func enableDebugTrace(x int)</code></pre>
            </article>
            
            <article class="function" data-name="enableDebugTraceIfEnv">
               <h3>
                  enableDebugTraceIfEnv 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func enableDebugTraceIfEnv()</code></pre>
            </article>
            
            <article class="function" data-name="enableDebugTraceIfEnv">
               <h3>
                  enableDebugTraceIfEnv 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func enableDebugTraceIfEnv()</code></pre>
            </article>
            
            <article class="function" data-name="examineCallResults">
               <h3>
                  examineCallResults 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (csa *callSiteAnalyzer) examineCallResults(cs *CallSite, resultNameTab map[*ir.Name]resultPropAndCS) map[*ir.Name]resultPropAndCS</code></pre>
            </article>
            
            <article class="function" data-name="findParamIdx">
               <h3>
                  findParamIdx 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pa *paramsAnalyzer) findParamIdx(n *ir.Name) int</code></pre>
            </article>
            
            <article class="function" data-name="flagSliceToSB">
               <h3>
                  flagSliceToSB 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func flagSliceToSB(sb *strings.Builder, sl []T, prefix string, tag string)</code></pre>
            </article>
            
            <article class="function" data-name="flagsForNode">
               <h3>
                  flagsForNode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (cstb *callSiteTableBuilder) flagsForNode(call *ir.CallExpr) CSPropBits</code></pre>
            </article>
            
            <article class="function" data-name="fmtFullPos">
               <h3>
                  fmtFullPos 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fmtFullPos(p src.XPos) string</code></pre>
            </article>
            
            <article class="function" data-name="fnFileLine">
               <h3>
                  fnFileLine 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fnFileLine(fn *ir.Func) (string, uint)</code></pre>
            </article>
            
            <article class="function" data-name="foldCheckParams">
               <h3>
                  foldCheckParams 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>foldCheckParams checks expression 'x' (an 'if' condition or
'switch' stmt expr) to see if the expr would fold away if a
specific parameter had a constant value.</p>
               
               <pre><code>func (pa *paramsAnalyzer) foldCheckParams(x ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="foldCheckResults">
               <h3>
                  foldCheckResults 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>foldCheckResults examines the specified if/switch condition 'cond'
to see if it refers to locals defined by a (potentially inlinable)
function call at call site C, and if so, whether 'cond' contains
only combinations of simple references to all of the names in
'names' with selected constants + operators. If these criteria are
met, then we adjust the score for call site C to reflect the
fact that inlining will enable deadcode and/or constant propagation.
Note: for this heuristic to kick in, the names in question have to
be all from the same callsite. Examples:
q, r := baz()	    x, y := foo()
switch q+r {		a, b, c := bar()
...			    if x && y && a && b && c {
}					   ...
}
For the call to "baz" above we apply a score adjustment, but not
for the calls to "foo" or "bar".</p>
               
               <pre><code>func (rua *resultUseAnalyzer) foldCheckResults(cond ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="funcName">
               <h3>
                  funcName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>funcName returns the *ir.Name for the func or method
corresponding to node 'n', or nil if n can't be proven
to contain a function value.</p>
               
               <pre><code>func (nf *nameFinder) funcName(n ir.Node) *ir.Name</code></pre>
            </article>
            
            <article class="function" data-name="getCallResultName">
               <h3>
                  getCallResultName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rua *resultUseAnalyzer) getCallResultName(ce *ir.CallExpr) *ir.Name</code></pre>
            </article>
            
            <article class="function" data-name="getParams">
               <h3>
                  getParams 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>getParams returns an *ir.Name slice containing all params for the
function (plus rcvr as well if applicable).</p>
               
               <pre><code>func getParams(fn *ir.Func) []*ir.Name</code></pre>
            </article>
            
            <article class="function" data-name="getState">
               <h3>
                  getState 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffa *funcFlagsAnalyzer) getState(n ir.Node) pstate</code></pre>
            </article>
            
            <article class="function" data-name="getdisp">
               <h3>
                  getdisp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ec *exprClassifier) getdisp(x ir.Node) disp</code></pre>
            </article>
            
            <article class="function" data-name="hasTopLevelLoopBodyReturnOrBreak">
               <h3>
                  hasTopLevelLoopBodyReturnOrBreak 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hasTopLevelLoopBodyReturnOrBreak examines the body of a "for" or
"range" loop to try to verify that it is a real loop, as opposed to
a construct that is syntactically loopy but doesn't actually iterate
multiple times, like:
for {
blah()
return 1
}
[Remark: the pattern above crops up quite a bit in the source code
for the compiler itself, e.g. the auto-generated rewrite code]
Note that we don't look for GOTO statements here, so it's possible
we'll get the wrong result for a loop with complicated control
jumps via gotos.</p>
               
               <pre><code>func hasTopLevelLoopBodyReturnOrBreak(loopBody ir.Nodes) bool</code></pre>
            </article>
            
            <article class="function" data-name="isAllocatedMem">
               <h3>
                  isAllocatedMem 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isAllocatedMem returns true if node n corresponds to a memory
allocation expression (make, new, or equivalent).</p>
               
               <pre><code>func (nf *nameFinder) isAllocatedMem(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="isConcreteConvIface">
               <h3>
                  isConcreteConvIface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (nf *nameFinder) isConcreteConvIface(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="isExitCall">
               <h3>
                  isExitCall 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isExitCall reports TRUE if the node itself is an unconditional
call to os.Exit(), a panic, or a function that does likewise.</p>
               
               <pre><code>func isExitCall(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="isMainMain">
               <h3>
                  isMainMain 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isMainMain(fn *ir.Func) bool</code></pre>
            </article>
            
            <article class="function" data-name="isMay">
               <h3>
                  isMay 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isMay(x scoreAdjustTyp) bool</code></pre>
            </article>
            
            <article class="function" data-name="isMust">
               <h3>
                  isMust 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isMust(x scoreAdjustTyp) bool</code></pre>
            </article>
            
            <article class="function" data-name="isNil">
               <h3>
                  isNil 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isNil returns whether n is nil (or singly
assigned local containing nil).</p>
               
               <pre><code>func (nf *nameFinder) isNil(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="isSameFuncName">
               <h3>
                  isSameFuncName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isSameFuncName(v1 *ir.Name, v2 *ir.Name) bool</code></pre>
            </article>
            
            <article class="function" data-name="isWellKnownFunc">
               <h3>
                  isWellKnownFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isWellKnownFunc(s *types.Sym, pkg string, name string) bool</code></pre>
            </article>
            
            <article class="function" data-name="loopBody">
               <h3>
                  loopBody 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func loopBody(n ir.Node) ir.Nodes</code></pre>
            </article>
            
            <article class="function" data-name="makeCallSiteAnalyzer">
               <h3>
                  makeCallSiteAnalyzer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeCallSiteAnalyzer(fn *ir.Func) *callSiteAnalyzer</code></pre>
            </article>
            
            <article class="function" data-name="makeCallSiteTableBuilder">
               <h3>
                  makeCallSiteTableBuilder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeCallSiteTableBuilder(fn *ir.Func, cstab CallSiteTab, ptab map[ir.Node]pstate, loopNestingLevel int, nf *nameFinder) *callSiteTableBuilder</code></pre>
            </article>
            
            <article class="function" data-name="makeExprClassifier">
               <h3>
                  makeExprClassifier 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeExprClassifier(names []*ir.Name) *exprClassifier</code></pre>
            </article>
            
            <article class="function" data-name="makeFuncFlagsAnalyzer">
               <h3>
                  makeFuncFlagsAnalyzer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeFuncFlagsAnalyzer(fn *ir.Func) *funcFlagsAnalyzer</code></pre>
            </article>
            
            <article class="function" data-name="makeParamsAnalyzer">
               <h3>
                  makeParamsAnalyzer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeParamsAnalyzer creates a new helper object to analyze parameters
of function fn. If the function doesn't have any interesting
params, a nil helper is returned along with a set of default param
flags for the func.</p>
               
               <pre><code>func makeParamsAnalyzer(fn *ir.Func, nf *nameFinder) (*paramsAnalyzer, []ParamPropBits)</code></pre>
            </article>
            
            <article class="function" data-name="makeResultsAnalyzer">
               <h3>
                  makeResultsAnalyzer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeResultsAnalyzer creates a new helper object to analyze results
in function fn. If the function doesn't have any interesting
results, a nil helper is returned along with a set of default
result flags for the func.</p>
               
               <pre><code>func makeResultsAnalyzer(fn *ir.Func, inlineMaxBudget int, nf *nameFinder) (*resultsAnalyzer, []ResultPropBits)</code></pre>
            </article>
            
            <article class="function" data-name="mayToMust">
               <h3>
                  mayToMust 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func mayToMust(x scoreAdjustTyp) scoreAdjustTyp</code></pre>
            </article>
            
            <article class="function" data-name="merge">
               <h3>
                  merge 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (cst CallSiteTab) merge(other CallSiteTab) error</code></pre>
            </article>
            
            <article class="function" data-name="mustToMay">
               <h3>
                  mustToMay 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func mustToMay(x scoreAdjustTyp) scoreAdjustTyp</code></pre>
            </article>
            
            <article class="function" data-name="namesDefined">
               <h3>
                  namesDefined 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>namesDefined returns a list of ir.Name's corresponding to locals
that receive the results from the call at site 'cs', plus the
properties object for the called function. If a given result
isn't cleanly assigned to a newly defined local, the
slot for that result in the returned list will be nil. Example:
call                             returned name list
x := foo()                       [ x ]
z, y := bar()                    [ nil, nil ]
_, q := baz()                    [ nil, q ]
In the case of a multi-return call, such as "x, y := foo()",
the pattern we see from the front end will be a call op
assigning to auto-temps, and then an assignment of the auto-temps
to the user-level variables. In such cases we return
first the user-level variable (in the first func result)
and then the auto-temp name in the second result.</p>
               
               <pre><code>func namesDefined(cs *CallSite) ([]*ir.Name, []*ir.Name, *FuncProps)</code></pre>
            </article>
            
            <article class="function" data-name="newNameFinder">
               <h3>
                  newNameFinder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newNameFinder returns a new nameFinder object with a reassignment
oracle initialized based on the function fn, or if fn is nil,
without an underlying ReassignOracle.</p>
               
               <pre><code>func newNameFinder(fn *ir.Func) *nameFinder</code></pre>
            </article>
            
            <article class="function" data-name="nodeVisitPost">
               <h3>
                  nodeVisitPost 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pa *paramsAnalyzer) nodeVisitPost(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="nodeVisitPost">
               <h3>
                  nodeVisitPost 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ra *resultsAnalyzer) nodeVisitPost(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="nodeVisitPost">
               <h3>
                  nodeVisitPost 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rua *resultUseAnalyzer) nodeVisitPost(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="nodeVisitPost">
               <h3>
                  nodeVisitPost 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (cstb *callSiteTableBuilder) nodeVisitPost(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="nodeVisitPost">
               <h3>
                  nodeVisitPost 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>nodeVisitPost helps implement the propAnalyzer interface; when
called on a given node, it decides the disposition of that node
based on the state(s) of the node's children.</p>
               
               <pre><code>func (ffa *funcFlagsAnalyzer) nodeVisitPost(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="nodeVisitPre">
               <h3>
                  nodeVisitPre 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ra *resultsAnalyzer) nodeVisitPre(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="nodeVisitPre">
               <h3>
                  nodeVisitPre 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pa *paramsAnalyzer) nodeVisitPre(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="nodeVisitPre">
               <h3>
                  nodeVisitPre 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffa *funcFlagsAnalyzer) nodeVisitPre(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="nodeVisitPre">
               <h3>
                  nodeVisitPre 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rua *resultUseAnalyzer) nodeVisitPre(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="nodeVisitPre">
               <h3>
                  nodeVisitPre 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (cstb *callSiteTableBuilder) nodeVisitPre(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="panicPathTable">
               <h3>
                  panicPathTable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffa *funcFlagsAnalyzer) panicPathTable() map[ir.Node]pstate</code></pre>
            </article>
            
            <article class="function" data-name="parseScoreAdj">
               <h3>
                  parseScoreAdj 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseScoreAdj(val string) error</code></pre>
            </article>
            
            <article class="function" data-name="pessimize">
               <h3>
                  pessimize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ra *resultsAnalyzer) pessimize()</code></pre>
            </article>
            
            <article class="function" data-name="pessimize">
               <h3>
                  pessimize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>pessimize is called to record the fact that we saw something in the
function that renders it entirely impossible to analyze.</p>
               
               <pre><code>func (ffa *funcFlagsAnalyzer) pessimize()</code></pre>
            </article>
            
            <article class="function" data-name="post">
               <h3>
                  post 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *condLevelTracker) post(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="pre">
               <h3>
                  pre 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *condLevelTracker) pre(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="propsForArg">
               <h3>
                  propsForArg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>propsForArg returns property bits for a given call argument expression arg.</p>
               
               <pre><code>func (cstb *callSiteTableBuilder) propsForArg(arg ir.Node) ActualExprPropBits</code></pre>
            </article>
            
            <article class="function" data-name="propsForFunc">
               <h3>
                  propsForFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func propsForFunc(fn *ir.Func) *FuncProps</code></pre>
            </article>
            
            <article class="function" data-name="readULEB128">
               <h3>
                  readULEB128 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func readULEB128(sl []byte) (value uint64, rsl []byte)</code></pre>
            </article>
            
            <article class="function" data-name="reassigned">
               <h3>
                  reassigned 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (nf *nameFinder) reassigned(n *ir.Name) bool</code></pre>
            </article>
            
            <article class="function" data-name="rescoreBasedOnCallResultUses">
               <h3>
                  rescoreBasedOnCallResultUses 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>rescoreBasedOnCallResultUses examines how call results are used,
and tries to update the scores of calls based on how their results
are used in the function.</p>
               
               <pre><code>func (csa *callSiteAnalyzer) rescoreBasedOnCallResultUses(fn *ir.Func, resultNameTab map[*ir.Name]resultPropAndCS, cstab CallSiteTab)</code></pre>
            </article>
            
            <article class="function" data-name="returnHasProp">
               <h3>
                  returnHasProp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rua *resultUseAnalyzer) returnHasProp(name *ir.Name, prop ResultPropBits) *CallSite</code></pre>
            </article>
            
            <article class="function" data-name="revisitInlinability">
               <h3>
                  revisitInlinability 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>revisitInlinability revisits the question of whether to continue to
treat function 'fn' as an inline candidate based on the set of
properties we've computed for it. If (for example) it has an
initial size score of 150 and no interesting properties to speak
of, then there isn't really any point to moving ahead with it as an
inline candidate.</p>
               
               <pre><code>func revisitInlinability(fn *ir.Func, funcProps *FuncProps, budgetForFunc func(*ir.Func) int32)</code></pre>
            </article>
            
            <article class="function" data-name="runAnalyzersOnFunction">
               <h3>
                  runAnalyzersOnFunction 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runAnalyzersOnFunction(fn *ir.Func, analyzers []propAnalyzer)</code></pre>
            </article>
            
            <article class="function" data-name="scoreCallsRegion">
               <h3>
                  scoreCallsRegion 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>scoreCallsRegion assigns numeric scores to each of the callsites in
region 'region' within function 'fn'. This can be called on
an entire function, or with 'region' set to a chunk of
code corresponding to an inlined call.</p>
               
               <pre><code>func (csa *callSiteAnalyzer) scoreCallsRegion(fn *ir.Func, region ir.Nodes, cstab CallSiteTab, doCallResults bool, ic *ir.InlinedCallExpr)</code></pre>
            </article>
            
            <article class="function" data-name="setResults">
               <h3>
                  setResults 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setResults transfers func flag results to 'funcProps'.</p>
               
               <pre><code>func (ffa *funcFlagsAnalyzer) setResults(funcProps *FuncProps)</code></pre>
            </article>
            
            <article class="function" data-name="setResults">
               <h3>
                  setResults 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pa *paramsAnalyzer) setResults(funcProps *FuncProps)</code></pre>
            </article>
            
            <article class="function" data-name="setResults">
               <h3>
                  setResults 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setResults transfers the calculated result properties for this
function to 'funcProps'.</p>
               
               <pre><code>func (ra *resultsAnalyzer) setResults(funcProps *FuncProps)</code></pre>
            </article>
            
            <article class="function" data-name="setState">
               <h3>
                  setState 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffa *funcFlagsAnalyzer) setState(n ir.Node, st pstate)</code></pre>
            </article>
            
            <article class="function" data-name="setupFlagToAdjMaps">
               <h3>
                  setupFlagToAdjMaps 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setupFlagToAdjMaps()</code></pre>
            </article>
            
            <article class="function" data-name="shouldVisit">
               <h3>
                  shouldVisit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>shouldVisit reports TRUE if this is an interesting node from the
perspective of computing function flags. NB: due to the fact that
ir.CallExpr implements the Stmt interface, we wind up visiting
a lot of nodes that we don't really need to, but these can
simply be screened out as part of the visit.</p>
               
               <pre><code>func shouldVisit(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="sortFnInlHeurSlice">
               <h3>
                  sortFnInlHeurSlice 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>sortFnInlHeurSlice sorts a slice of fnInlHeur based on
the starting line of the function definition, then by name.</p>
               
               <pre><code>func sortFnInlHeurSlice(sl []fnInlHeur) []fnInlHeur</code></pre>
            </article>
            
            <article class="function" data-name="stateForList">
               <h3>
                  stateForList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>stateForList walks through a list of statements and computes the
state/disposition for the entire list as a whole, as well
as updating disposition of intermediate nodes.</p>
               
               <pre><code>func (ffa *funcFlagsAnalyzer) stateForList(list ir.Nodes) pstate</code></pre>
            </article>
            
            <article class="function" data-name="staticValue">
               <h3>
                  staticValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (nf *nameFinder) staticValue(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function" data-name="updateState">
               <h3>
                  updateState 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffa *funcFlagsAnalyzer) updateState(n ir.Node, st pstate)</code></pre>
            </article>
            
            <article class="function" data-name="writeUleb128">
               <h3>
                  writeUleb128 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func writeUleb128(sb *strings.Builder, v uint64)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
