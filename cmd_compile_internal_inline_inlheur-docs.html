<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - inlheur</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>inlheur</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"strconv"
"bytes"
"strconv"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/pgoir"
"cmd/compile/internal/types"
"cmp"
"fmt"
"os"
"slices"
"strconv"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmp"
"encoding/json"
"fmt"
"internal/buildcfg"
"io"
"os"
"path/filepath"
"slices"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"fmt"
"os"
"cmd/compile/internal/ir"
"fmt"
"os"
"cmd/compile/internal/ir"
"go/constant"
"cmd/compile/internal/ir"
"fmt"
"os"
"os"
"strconv"
"strconv"
"bytes"
"cmd/compile/internal/ir"
"cmd/compile/internal/pgoir"
"cmd/compile/internal/typecheck"
"fmt"
"os"
"strings"
"cmd/compile/internal/ir"
"fmt"
"go/constant"
"go/token"
"os"
"strconv"
"bytes"
"cmd/compile/internal/ir"
"fmt"
"os"
"bytes"
"strconv"
"bytes"
"strconv"
"strings"
"strconv"
"bytes"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/internal/src"
"fmt"
"io"
"path/filepath"
"sort"
"strings"
"fmt"
"strings"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ActualExprConstant" data-name="ActualExprConstant">
               <h3>
                  ActualExprConstant 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ActualExprConstant" class="anchor" title="Link to ActualExprConstant">#</a>
               </h3>
               
               <pre><code class="language-go">const ActualExprConstant ActualExprPropBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ActualExprIsConcreteConvIface" data-name="ActualExprIsConcreteConvIface">
               <h3>
                  ActualExprIsConcreteConvIface 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ActualExprIsConcreteConvIface" class="anchor" title="Link to ActualExprIsConcreteConvIface">#</a>
               </h3>
               
               <pre><code class="language-go">const ActualExprIsConcreteConvIface</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ActualExprIsFunc" data-name="ActualExprIsFunc">
               <h3>
                  ActualExprIsFunc 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ActualExprIsFunc" class="anchor" title="Link to ActualExprIsFunc">#</a>
               </h3>
               
               <pre><code class="language-go">const ActualExprIsFunc</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ActualExprIsInlinableFunc" data-name="ActualExprIsInlinableFunc">
               <h3>
                  ActualExprIsInlinableFunc 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ActualExprIsInlinableFunc" class="anchor" title="Link to ActualExprIsInlinableFunc">#</a>
               </h3>
               
               <pre><code class="language-go">const ActualExprIsInlinableFunc</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="CallSiteInInitFunc" data-name="CallSiteInInitFunc">
               <h3>
                  CallSiteInInitFunc 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#CallSiteInInitFunc" class="anchor" title="Link to CallSiteInInitFunc">#</a>
               </h3>
               
               <pre><code class="language-go">const CallSiteInInitFunc</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="CallSiteInLoop" data-name="CallSiteInLoop">
               <h3>
                  CallSiteInLoop 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#CallSiteInLoop" class="anchor" title="Link to CallSiteInLoop">#</a>
               </h3>
               
               <pre><code class="language-go">const CallSiteInLoop CSPropBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="CallSiteOnPanicPath" data-name="CallSiteOnPanicPath">
               <h3>
                  CallSiteOnPanicPath 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#CallSiteOnPanicPath" class="anchor" title="Link to CallSiteOnPanicPath">#</a>
               </h3>
               
               <pre><code class="language-go">const CallSiteOnPanicPath</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncPropNeverReturns" data-name="FuncPropNeverReturns">
               <h3>
                  FuncPropNeverReturns 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncPropNeverReturns" class="anchor" title="Link to FuncPropNeverReturns">#</a>
               </h3>
               
               <p>Function always panics or invokes os.Exit() or a func that does
likewise.</p>
               
               <pre><code class="language-go">const FuncPropNeverReturns FuncPropBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ParamFeedsIfOrSwitch" data-name="ParamFeedsIfOrSwitch">
               <h3>
                  ParamFeedsIfOrSwitch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ParamFeedsIfOrSwitch" class="anchor" title="Link to ParamFeedsIfOrSwitch">#</a>
               </h3>
               
               <p>Parameter value feeds unmodified into a top level "switch"
statement or "if" statement simple expressions (see more on
"simple" expression classification below).</p>
               
               <pre><code class="language-go">const ParamFeedsIfOrSwitch</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ParamFeedsIndirectCall" data-name="ParamFeedsIndirectCall">
               <h3>
                  ParamFeedsIndirectCall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ParamFeedsIndirectCall" class="anchor" title="Link to ParamFeedsIndirectCall">#</a>
               </h3>
               
               <p>Parameter value feeds unmodified into a top level indirect
function call (assumes parameter is of function type).</p>
               
               <pre><code class="language-go">const ParamFeedsIndirectCall</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ParamFeedsInterfaceMethodCall" data-name="ParamFeedsInterfaceMethodCall">
               <h3>
                  ParamFeedsInterfaceMethodCall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ParamFeedsInterfaceMethodCall" class="anchor" title="Link to ParamFeedsInterfaceMethodCall">#</a>
               </h3>
               
               <p>Parameter value feeds unmodified into a top-level interface
call (this assumes the parameter is of interface type).</p>
               
               <pre><code class="language-go">const ParamFeedsInterfaceMethodCall ParamPropBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ParamMayFeedIfOrSwitch" data-name="ParamMayFeedIfOrSwitch">
               <h3>
                  ParamMayFeedIfOrSwitch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ParamMayFeedIfOrSwitch" class="anchor" title="Link to ParamMayFeedIfOrSwitch">#</a>
               </h3>
               
               <p>Parameter value feeds unmodified into a "switch" or "if"
statement simple expressions (see more on "simple" expression
classification below), where the if/switch is
conditional/nested.</p>
               
               <pre><code class="language-go">const ParamMayFeedIfOrSwitch</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ParamMayFeedIndirectCall" data-name="ParamMayFeedIndirectCall">
               <h3>
                  ParamMayFeedIndirectCall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ParamMayFeedIndirectCall" class="anchor" title="Link to ParamMayFeedIndirectCall">#</a>
               </h3>
               
               <p>Parameter value feeds unmodified into an indirect function call
that is conditional/nested (not guaranteed to execute). Assumes
parameter is of function type.</p>
               
               <pre><code class="language-go">const ParamMayFeedIndirectCall</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ParamMayFeedInterfaceMethodCall" data-name="ParamMayFeedInterfaceMethodCall">
               <h3>
                  ParamMayFeedInterfaceMethodCall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ParamMayFeedInterfaceMethodCall" class="anchor" title="Link to ParamMayFeedInterfaceMethodCall">#</a>
               </h3>
               
               <p>Parameter value feeds unmodified into an interface call that
may be conditional/nested and not always executed (this assumes
the parameter is of interface type).</p>
               
               <pre><code class="language-go">const ParamMayFeedInterfaceMethodCall ParamPropBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ParamNoInfo" data-name="ParamNoInfo">
               <h3>
                  ParamNoInfo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ParamNoInfo" class="anchor" title="Link to ParamNoInfo">#</a>
               </h3>
               
               <p>No info about this param</p>
               
               <pre><code class="language-go">const ParamNoInfo ParamPropBits = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ResultAlwaysSameConstant" data-name="ResultAlwaysSameConstant">
               <h3>
                  ResultAlwaysSameConstant 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ResultAlwaysSameConstant" class="anchor" title="Link to ResultAlwaysSameConstant">#</a>
               </h3>
               
               <p>Result is always the same non-composite compile time constant.</p>
               
               <pre><code class="language-go">const ResultAlwaysSameConstant</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ResultAlwaysSameFunc" data-name="ResultAlwaysSameFunc">
               <h3>
                  ResultAlwaysSameFunc 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ResultAlwaysSameFunc" class="anchor" title="Link to ResultAlwaysSameFunc">#</a>
               </h3>
               
               <p>Result is always the same function or closure.</p>
               
               <pre><code class="language-go">const ResultAlwaysSameFunc</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ResultAlwaysSameInlinableFunc" data-name="ResultAlwaysSameInlinableFunc">
               <h3>
                  ResultAlwaysSameInlinableFunc 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ResultAlwaysSameInlinableFunc" class="anchor" title="Link to ResultAlwaysSameInlinableFunc">#</a>
               </h3>
               
               <p>Result is always the same (potentially) inlinable function or closure.</p>
               
               <pre><code class="language-go">const ResultAlwaysSameInlinableFunc</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ResultIsAllocatedMem" data-name="ResultIsAllocatedMem">
               <h3>
                  ResultIsAllocatedMem 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ResultIsAllocatedMem" class="anchor" title="Link to ResultIsAllocatedMem">#</a>
               </h3>
               
               <p>This result always contains allocated memory.</p>
               
               <pre><code class="language-go">const ResultIsAllocatedMem ResultPropBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ResultIsConcreteTypeConvertedToInterface" data-name="ResultIsConcreteTypeConvertedToInterface">
               <h3>
                  ResultIsConcreteTypeConvertedToInterface 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ResultIsConcreteTypeConvertedToInterface" class="anchor" title="Link to ResultIsConcreteTypeConvertedToInterface">#</a>
               </h3>
               
               <p>This result is always a single concrete type that is
implicitly converted to interface.</p>
               
               <pre><code class="language-go">const ResultIsConcreteTypeConvertedToInterface</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ResultNoInfo" data-name="ResultNoInfo">
               <h3>
                  ResultNoInfo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ResultNoInfo" class="anchor" title="Link to ResultNoInfo">#</a>
               </h3>
               
               <p>No info about this result</p>
               
               <pre><code class="language-go">const ResultNoInfo ResultPropBits = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_ActualExprPropBits_index" data-name="_ActualExprPropBits_index">
               <h3>
                  _ActualExprPropBits_index 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_ActualExprPropBits_index" class="anchor" title="Link to _ActualExprPropBits_index">#</a>
               </h3>
               
               <pre><code class="language-go">var _ActualExprPropBits_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_ActualExprPropBits_name" data-name="_ActualExprPropBits_name">
               <h3>
                  _ActualExprPropBits_name 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_ActualExprPropBits_name" class="anchor" title="Link to _ActualExprPropBits_name">#</a>
               </h3>
               
               <pre><code class="language-go">const _ActualExprPropBits_name = "ActualExprConstantActualExprIsConcreteConvIfaceActualExprIsFuncActualExprIsInlinableFunc"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_ActualExprPropBits_value" data-name="_ActualExprPropBits_value">
               <h3>
                  _ActualExprPropBits_value 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_ActualExprPropBits_value" class="anchor" title="Link to _ActualExprPropBits_value">#</a>
               </h3>
               
               <pre><code class="language-go">var _ActualExprPropBits_value = [...]uint64{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_CSPropBits_index" data-name="_CSPropBits_index">
               <h3>
                  _CSPropBits_index 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_CSPropBits_index" class="anchor" title="Link to _CSPropBits_index">#</a>
               </h3>
               
               <pre><code class="language-go">var _CSPropBits_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_CSPropBits_name" data-name="_CSPropBits_name">
               <h3>
                  _CSPropBits_name 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_CSPropBits_name" class="anchor" title="Link to _CSPropBits_name">#</a>
               </h3>
               
               <pre><code class="language-go">const _CSPropBits_name = "CallSiteInLoopCallSiteOnPanicPathCallSiteInInitFunc"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_CSPropBits_value" data-name="_CSPropBits_value">
               <h3>
                  _CSPropBits_value 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_CSPropBits_value" class="anchor" title="Link to _CSPropBits_value">#</a>
               </h3>
               
               <pre><code class="language-go">var _CSPropBits_value = [...]uint64{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_FuncPropBits_index" data-name="_FuncPropBits_index">
               <h3>
                  _FuncPropBits_index 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_FuncPropBits_index" class="anchor" title="Link to _FuncPropBits_index">#</a>
               </h3>
               
               <pre><code class="language-go">var _FuncPropBits_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_FuncPropBits_name" data-name="_FuncPropBits_name">
               <h3>
                  _FuncPropBits_name 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_FuncPropBits_name" class="anchor" title="Link to _FuncPropBits_name">#</a>
               </h3>
               
               <pre><code class="language-go">const _FuncPropBits_name = "FuncPropNeverReturns"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_FuncPropBits_value" data-name="_FuncPropBits_value">
               <h3>
                  _FuncPropBits_value 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_FuncPropBits_value" class="anchor" title="Link to _FuncPropBits_value">#</a>
               </h3>
               
               <pre><code class="language-go">var _FuncPropBits_value = [...]uint64{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_ParamPropBits_index" data-name="_ParamPropBits_index">
               <h3>
                  _ParamPropBits_index 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_ParamPropBits_index" class="anchor" title="Link to _ParamPropBits_index">#</a>
               </h3>
               
               <pre><code class="language-go">var _ParamPropBits_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_ParamPropBits_name" data-name="_ParamPropBits_name">
               <h3>
                  _ParamPropBits_name 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_ParamPropBits_name" class="anchor" title="Link to _ParamPropBits_name">#</a>
               </h3>
               
               <pre><code class="language-go">const _ParamPropBits_name = "ParamNoInfoParamFeedsInterfaceMethodCallParamMayFeedInterfaceMethodCallParamFeedsIndirectCallParamMayFeedIndirectCallParamFeedsIfOrSwitchParamMayFeedIfOrSwitch"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_ParamPropBits_value" data-name="_ParamPropBits_value">
               <h3>
                  _ParamPropBits_value 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_ParamPropBits_value" class="anchor" title="Link to _ParamPropBits_value">#</a>
               </h3>
               
               <pre><code class="language-go">var _ParamPropBits_value = [...]uint64{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_ResultPropBits_index" data-name="_ResultPropBits_index">
               <h3>
                  _ResultPropBits_index 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_ResultPropBits_index" class="anchor" title="Link to _ResultPropBits_index">#</a>
               </h3>
               
               <pre><code class="language-go">var _ResultPropBits_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_ResultPropBits_name" data-name="_ResultPropBits_name">
               <h3>
                  _ResultPropBits_name 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_ResultPropBits_name" class="anchor" title="Link to _ResultPropBits_name">#</a>
               </h3>
               
               <pre><code class="language-go">const _ResultPropBits_name = "ResultNoInfoResultIsAllocatedMemResultIsConcreteTypeConvertedToInterfaceResultAlwaysSameConstantResultAlwaysSameFuncResultAlwaysSameInlinableFunc"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_ResultPropBits_value" data-name="_ResultPropBits_value">
               <h3>
                  _ResultPropBits_value 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_ResultPropBits_value" class="anchor" title="Link to _ResultPropBits_value">#</a>
               </h3>
               
               <pre><code class="language-go">var _ResultPropBits_value = [...]uint64{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_pstate_index" data-name="_pstate_index">
               <h3>
                  _pstate_index 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_pstate_index" class="anchor" title="Link to _pstate_index">#</a>
               </h3>
               
               <pre><code class="language-go">var _pstate_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_pstate_name" data-name="_pstate_name">
               <h3>
                  _pstate_name 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_pstate_name" class="anchor" title="Link to _pstate_name">#</a>
               </h3>
               
               <pre><code class="language-go">const _pstate_name = "psNoInfopsCallsPanicpsMayReturnpsTop"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_scoreAdjustTyp_index" data-name="_scoreAdjustTyp_index">
               <h3>
                  _scoreAdjustTyp_index 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_scoreAdjustTyp_index" class="anchor" title="Link to _scoreAdjustTyp_index">#</a>
               </h3>
               
               <pre><code class="language-go">var _scoreAdjustTyp_index = [...]uint16{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_scoreAdjustTyp_name" data-name="_scoreAdjustTyp_name">
               <h3>
                  _scoreAdjustTyp_name 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_scoreAdjustTyp_name" class="anchor" title="Link to _scoreAdjustTyp_name">#</a>
               </h3>
               
               <pre><code class="language-go">const _scoreAdjustTyp_name = "panicPathAdjinitFuncAdjinLoopAdjpassConstToIfAdjpassConstToNestedIfAdjpassConcreteToItfCallAdjpassConcreteToNestedItfCallAdjpassFuncToIndCallAdjpassFuncToNestedIndCallAdjpassInlinableFuncToIndCallAdjpassInlinableFuncToNestedIndCallAdjreturnFeedsConstToIfAdjreturnFeedsFuncToIndCallAdjreturnFeedsInlinableFuncToIndCallAdjreturnFeedsConcreteToInterfaceCallAdj"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_scoreAdjustTyp_value" data-name="_scoreAdjustTyp_value">
               <h3>
                  _scoreAdjustTyp_value 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_scoreAdjustTyp_value" class="anchor" title="Link to _scoreAdjustTyp_value">#</a>
               </h3>
               
               <pre><code class="language-go">var _scoreAdjustTyp_value = [...]uint64{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="adjValues" data-name="adjValues">
               <h3>
                  adjValues 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#adjValues" class="anchor" title="Link to adjValues">#</a>
               </h3>
               
               <pre><code class="language-go">var adjValues = map[scoreAdjustTyp]int{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="allCallSites" data-name="allCallSites">
               <h3>
                  allCallSites 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#allCallSites" class="anchor" title="Link to allCallSites">#</a>
               </h3>
               
               <pre><code class="language-go">var allCallSites CallSiteTab</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="callSiteTab" data-name="callSiteTab">
               <h3>
                  callSiteTab 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#callSiteTab" class="anchor" title="Link to callSiteTab">#</a>
               </h3>
               
               <p>callSiteTab contains entries for each call in the function
currently being processed by InlineCalls; this variable will either
be set to 'cstabCache' below (for non-inlinable routines) or to the
local 'cstab' entry in the fnInlHeur object for inlinable routines.
NOTE: this assumes that inlining operations are happening in a serial,
single-threaded fashion,f which is true today but probably won't hold
in the future (for example, we might want to score the callsites
in multiple functions in parallel); if the inliner evolves in this
direction we'll need to come up with a different approach here.</p>
               
               <pre><code class="language-go">var callSiteTab CallSiteTab</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="comDelimiter" data-name="comDelimiter">
               <h3>
                  comDelimiter 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#comDelimiter" class="anchor" title="Link to comDelimiter">#</a>
               </h3>
               
               <pre><code class="language-go">const comDelimiter = "<endpropsdump>"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="csAuxInlined" data-name="csAuxInlined">
               <h3>
                  csAuxInlined 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#csAuxInlined" class="anchor" title="Link to csAuxInlined">#</a>
               </h3>
               
               <pre><code class="language-go">const csAuxInlined = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="csDelimiter" data-name="csDelimiter">
               <h3>
                  csDelimiter 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#csDelimiter" class="anchor" title="Link to csDelimiter">#</a>
               </h3>
               
               <pre><code class="language-go">const csDelimiter = "<endcallsites>"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugTrace" data-name="debugTrace">
               <h3>
                  debugTrace 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#debugTrace" class="anchor" title="Link to debugTrace">#</a>
               </h3>
               
               <pre><code class="language-go">var debugTrace = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugTrace" data-name="debugTrace">
               <h3>
                  debugTrace 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debugTrace" class="anchor" title="Link to debugTrace">#</a>
               </h3>
               
               <pre><code class="language-go">const debugTrace = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugTraceCalls" data-name="debugTraceCalls">
               <h3>
                  debugTraceCalls 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debugTraceCalls" class="anchor" title="Link to debugTraceCalls">#</a>
               </h3>
               
               <pre><code class="language-go">const debugTraceCalls</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugTraceExprClassify" data-name="debugTraceExprClassify">
               <h3>
                  debugTraceExprClassify 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debugTraceExprClassify" class="anchor" title="Link to debugTraceExprClassify">#</a>
               </h3>
               
               <pre><code class="language-go">const debugTraceExprClassify</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugTraceFuncFlags" data-name="debugTraceFuncFlags">
               <h3>
                  debugTraceFuncFlags 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debugTraceFuncFlags" class="anchor" title="Link to debugTraceFuncFlags">#</a>
               </h3>
               
               <pre><code class="language-go">const debugTraceFuncFlags</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugTraceFuncs" data-name="debugTraceFuncs">
               <h3>
                  debugTraceFuncs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debugTraceFuncs" class="anchor" title="Link to debugTraceFuncs">#</a>
               </h3>
               
               <pre><code class="language-go">const debugTraceFuncs = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugTraceParams" data-name="debugTraceParams">
               <h3>
                  debugTraceParams 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debugTraceParams" class="anchor" title="Link to debugTraceParams">#</a>
               </h3>
               
               <pre><code class="language-go">const debugTraceParams</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugTraceResults" data-name="debugTraceResults">
               <h3>
                  debugTraceResults 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debugTraceResults" class="anchor" title="Link to debugTraceResults">#</a>
               </h3>
               
               <pre><code class="language-go">const debugTraceResults</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugTraceScoring" data-name="debugTraceScoring">
               <h3>
                  debugTraceScoring 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debugTraceScoring" class="anchor" title="Link to debugTraceScoring">#</a>
               </h3>
               
               <pre><code class="language-go">const debugTraceScoring</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dumpBuffer" data-name="dumpBuffer">
               <h3>
                  dumpBuffer 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dumpBuffer" class="anchor" title="Link to dumpBuffer">#</a>
               </h3>
               
               <p>dumpBuffer stores up function properties dumps when
"-d=dumpinlfuncprops=..." is in effect.</p>
               
               <pre><code class="language-go">var dumpBuffer map[*ir.Func]fnInlHeur</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprLiterals" data-name="exprLiterals">
               <h3>
                  exprLiterals 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprLiterals" class="anchor" title="Link to exprLiterals">#</a>
               </h3>
               
               <p>expr contains only literals</p>
               
               <pre><code class="language-go">const exprLiterals</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprNoInfo" data-name="exprNoInfo">
               <h3>
                  exprNoInfo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprNoInfo" class="anchor" title="Link to exprNoInfo">#</a>
               </h3>
               
               <p>no info on this expr</p>
               
               <pre><code class="language-go">const exprNoInfo disp = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprSimple" data-name="exprSimple">
               <h3>
                  exprSimple 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprSimple" class="anchor" title="Link to exprSimple">#</a>
               </h3>
               
               <p>expr is legal combination of literals and specified names</p>
               
               <pre><code class="language-go">const exprSimple</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fnDelimiter" data-name="fnDelimiter">
               <h3>
                  fnDelimiter 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#fnDelimiter" class="anchor" title="Link to fnDelimiter">#</a>
               </h3>
               
               <pre><code class="language-go">const fnDelimiter = "<endfuncpreamble>"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fpmap" data-name="fpmap">
               <h3>
                  fpmap 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#fpmap" class="anchor" title="Link to fpmap">#</a>
               </h3>
               
               <pre><code class="language-go">var fpmap = map[*ir.Func]fnInlHeur{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inLoopAdj" data-name="inLoopAdj">
               <h3>
                  inLoopAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inLoopAdj" class="anchor" title="Link to inLoopAdj">#</a>
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code class="language-go">const inLoopAdj</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initFuncAdj" data-name="initFuncAdj">
               <h3>
                  initFuncAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#initFuncAdj" class="anchor" title="Link to initFuncAdj">#</a>
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code class="language-go">const initFuncAdj</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mayMustAdj" data-name="mayMustAdj">
               <h3>
                  mayMustAdj 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#mayMustAdj" class="anchor" title="Link to mayMustAdj">#</a>
               </h3>
               
               <pre><code class="language-go">var mayMustAdj = [...]struct{...}{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="panicPathAdj" data-name="panicPathAdj">
               <h3>
                  panicPathAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#panicPathAdj" class="anchor" title="Link to panicPathAdj">#</a>
               </h3>
               
               <p>Category 1 adjustments (see above)</p>
               
               <pre><code class="language-go">const panicPathAdj scoreAdjustTyp = *ast.ParenExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="paramFlagToPositiveAdj" data-name="paramFlagToPositiveAdj">
               <h3>
                  paramFlagToPositiveAdj 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#paramFlagToPositiveAdj" class="anchor" title="Link to paramFlagToPositiveAdj">#</a>
               </h3>
               
               <pre><code class="language-go">var paramFlagToPositiveAdj map[ParamPropBits]scoreAdjustTyp</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="passConcreteToItfCallAdj" data-name="passConcreteToItfCallAdj">
               <h3>
                  passConcreteToItfCallAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#passConcreteToItfCallAdj" class="anchor" title="Link to passConcreteToItfCallAdj">#</a>
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code class="language-go">const passConcreteToItfCallAdj</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="passConcreteToNestedItfCallAdj" data-name="passConcreteToNestedItfCallAdj">
               <h3>
                  passConcreteToNestedItfCallAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#passConcreteToNestedItfCallAdj" class="anchor" title="Link to passConcreteToNestedItfCallAdj">#</a>
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code class="language-go">const passConcreteToNestedItfCallAdj</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="passConstToIfAdj" data-name="passConstToIfAdj">
               <h3>
                  passConstToIfAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#passConstToIfAdj" class="anchor" title="Link to passConstToIfAdj">#</a>
               </h3>
               
               <p>Category 2 adjustments (see above).</p>
               
               <pre><code class="language-go">const passConstToIfAdj</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="passConstToNestedIfAdj" data-name="passConstToNestedIfAdj">
               <h3>
                  passConstToNestedIfAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#passConstToNestedIfAdj" class="anchor" title="Link to passConstToNestedIfAdj">#</a>
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code class="language-go">const passConstToNestedIfAdj</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="passFuncToIndCallAdj" data-name="passFuncToIndCallAdj">
               <h3>
                  passFuncToIndCallAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#passFuncToIndCallAdj" class="anchor" title="Link to passFuncToIndCallAdj">#</a>
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code class="language-go">const passFuncToIndCallAdj</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="passFuncToNestedIndCallAdj" data-name="passFuncToNestedIndCallAdj">
               <h3>
                  passFuncToNestedIndCallAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#passFuncToNestedIndCallAdj" class="anchor" title="Link to passFuncToNestedIndCallAdj">#</a>
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code class="language-go">const passFuncToNestedIndCallAdj</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="passInlinableFuncToIndCallAdj" data-name="passInlinableFuncToIndCallAdj">
               <h3>
                  passInlinableFuncToIndCallAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#passInlinableFuncToIndCallAdj" class="anchor" title="Link to passInlinableFuncToIndCallAdj">#</a>
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code class="language-go">const passInlinableFuncToIndCallAdj</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="passInlinableFuncToNestedIndCallAdj" data-name="passInlinableFuncToNestedIndCallAdj">
               <h3>
                  passInlinableFuncToNestedIndCallAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#passInlinableFuncToNestedIndCallAdj" class="anchor" title="Link to passInlinableFuncToNestedIndCallAdj">#</a>
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code class="language-go">const passInlinableFuncToNestedIndCallAdj</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="preambleDelimiter" data-name="preambleDelimiter">
               <h3>
                  preambleDelimiter 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#preambleDelimiter" class="anchor" title="Link to preambleDelimiter">#</a>
               </h3>
               
               <p>delimiters written to various preambles to make parsing of
dumps easier.</p>
               
               <pre><code class="language-go">const preambleDelimiter = "<endfilepreamble>"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="psCallsPanic" data-name="psCallsPanic">
               <h3>
                  psCallsPanic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#psCallsPanic" class="anchor" title="Link to psCallsPanic">#</a>
               </h3>
               
               <pre><code class="language-go">const psCallsPanic</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="psMayReturn" data-name="psMayReturn">
               <h3>
                  psMayReturn 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#psMayReturn" class="anchor" title="Link to psMayReturn">#</a>
               </h3>
               
               <pre><code class="language-go">const psMayReturn</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="psNoInfo" data-name="psNoInfo">
               <h3>
                  psNoInfo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#psNoInfo" class="anchor" title="Link to psNoInfo">#</a>
               </h3>
               
               <pre><code class="language-go">const psNoInfo pstate = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="psTop" data-name="psTop">
               <h3>
                  psTop 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#psTop" class="anchor" title="Link to psTop">#</a>
               </h3>
               
               <pre><code class="language-go">const psTop</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="resultFlagToPositiveAdj" data-name="resultFlagToPositiveAdj">
               <h3>
                  resultFlagToPositiveAdj 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#resultFlagToPositiveAdj" class="anchor" title="Link to resultFlagToPositiveAdj">#</a>
               </h3>
               
               <pre><code class="language-go">var resultFlagToPositiveAdj map[ResultPropBits]scoreAdjustTyp</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="returnFeedsConcreteToInterfaceCallAdj" data-name="returnFeedsConcreteToInterfaceCallAdj">
               <h3>
                  returnFeedsConcreteToInterfaceCallAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#returnFeedsConcreteToInterfaceCallAdj" class="anchor" title="Link to returnFeedsConcreteToInterfaceCallAdj">#</a>
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code class="language-go">const returnFeedsConcreteToInterfaceCallAdj</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="returnFeedsConstToIfAdj" data-name="returnFeedsConstToIfAdj">
               <h3>
                  returnFeedsConstToIfAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#returnFeedsConstToIfAdj" class="anchor" title="Link to returnFeedsConstToIfAdj">#</a>
               </h3>
               
               <p>Category 3 adjustments.</p>
               
               <pre><code class="language-go">const returnFeedsConstToIfAdj</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="returnFeedsFuncToIndCallAdj" data-name="returnFeedsFuncToIndCallAdj">
               <h3>
                  returnFeedsFuncToIndCallAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#returnFeedsFuncToIndCallAdj" class="anchor" title="Link to returnFeedsFuncToIndCallAdj">#</a>
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code class="language-go">const returnFeedsFuncToIndCallAdj</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="returnFeedsInlinableFuncToIndCallAdj" data-name="returnFeedsInlinableFuncToIndCallAdj">
               <h3>
                  returnFeedsInlinableFuncToIndCallAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#returnFeedsInlinableFuncToIndCallAdj" class="anchor" title="Link to returnFeedsInlinableFuncToIndCallAdj">#</a>
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code class="language-go">const returnFeedsInlinableFuncToIndCallAdj</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="scoreCallsCache" data-name="scoreCallsCache">
               <h3>
                  scoreCallsCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#scoreCallsCache" class="anchor" title="Link to scoreCallsCache">#</a>
               </h3>
               
               <p>scoreCallsCache caches a call site table and call site list between
invocations of ScoreCalls so that we can reuse previously allocated
storage.</p>
               
               <pre><code class="language-go">var scoreCallsCache scoreCallsCacheType</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sentinelScoreAdj" data-name="sentinelScoreAdj">
               <h3>
                  sentinelScoreAdj 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sentinelScoreAdj" class="anchor" title="Link to sentinelScoreAdj">#</a>
               </h3>
               
               <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:
1) adjustments based solely on the callsite context (ex: call
appears on panic path)
2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)
3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)
For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
               
               <pre><code class="language-go">const sentinelScoreAdj</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="ActualExprPropBits" data-name="ActualExprPropBits">
               <h3>
                  ActualExprPropBits
                  <span class="badge type-badge">type</span>
                  <a href="#ActualExprPropBits" class="anchor" title="Link to ActualExprPropBits">#</a>
               </h3>
               
               <p>ActualExprPropBits describes a property of an actual expression (value
passed to some specific func argument at a call site).</p>
               
               <pre><code class="language-go">type ActualExprPropBits uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="CSPropBits" data-name="CSPropBits">
               <h3>
                  CSPropBits
                  <span class="badge type-badge">type</span>
                  <a href="#CSPropBits" class="anchor" title="Link to CSPropBits">#</a>
               </h3>
               
               <pre><code class="language-go">type CSPropBits uint32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="CallSiteTab" data-name="CallSiteTab">
               <h3>
                  CallSiteTab
                  <span class="badge type-badge">type</span>
                  <a href="#CallSiteTab" class="anchor" title="Link to CallSiteTab">#</a>
               </h3>
               
               <p>CallSiteTab is a table of call sites, keyed by call expr.
Ideally it would be nice to key the table by src.XPos, but
this results in collisions for calls on very long lines (the
front end saturates column numbers at 255). We also wind up
with many calls that share the same auto-generated pos.</p>
               
               <pre><code class="language-go">type CallSiteTab map[*ir.CallExpr]*CallSite</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="FuncPropBits" data-name="FuncPropBits">
               <h3>
                  FuncPropBits
                  <span class="badge type-badge">type</span>
                  <a href="#FuncPropBits" class="anchor" title="Link to FuncPropBits">#</a>
               </h3>
               
               <pre><code class="language-go">type FuncPropBits uint32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="ParamPropBits" data-name="ParamPropBits">
               <h3>
                  ParamPropBits
                  <span class="badge type-badge">type</span>
                  <a href="#ParamPropBits" class="anchor" title="Link to ParamPropBits">#</a>
               </h3>
               
               <pre><code class="language-go">type ParamPropBits uint32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="ResultPropBits" data-name="ResultPropBits">
               <h3>
                  ResultPropBits
                  <span class="badge type-badge">type</span>
                  <a href="#ResultPropBits" class="anchor" title="Link to ResultPropBits">#</a>
               </h3>
               
               <pre><code class="language-go">type ResultPropBits uint32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="csAuxBits" data-name="csAuxBits">
               <h3>
                  csAuxBits
                  <span class="badge type-badge">type</span>
                  <a href="#csAuxBits" class="anchor" title="Link to csAuxBits">#</a>
               </h3>
               
               <pre><code class="language-go">type csAuxBits uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="disp" data-name="disp">
               <h3>
                  disp
                  <span class="badge type-badge">type</span>
                  <a href="#disp" class="anchor" title="Link to disp">#</a>
               </h3>
               
               <pre><code class="language-go">type disp int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="encodedCallSiteTab" data-name="encodedCallSiteTab">
               <h3>
                  encodedCallSiteTab
                  <span class="badge type-badge">type</span>
                  <a href="#encodedCallSiteTab" class="anchor" title="Link to encodedCallSiteTab">#</a>
               </h3>
               
               <p>encodedCallSiteTab is a table keyed by "encoded" callsite
(stringified src.XPos plus call site ID) mapping to a value of call
property bits and score.</p>
               
               <pre><code class="language-go">type encodedCallSiteTab map[string]propsAndScore</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="pstate" data-name="pstate">
               <h3>
                  pstate
                  <span class="badge type-badge">type</span>
                  <a href="#pstate" class="anchor" title="Link to pstate">#</a>
               </h3>
               
               <p>pstate keeps track of the disposition of a given node and its
children with respect to panic/exit calls.</p>
               
               <pre><code class="language-go">type pstate int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="scoreAdjustTyp" data-name="scoreAdjustTyp">
               <h3>
                  scoreAdjustTyp
                  <span class="badge type-badge">type</span>
                  <a href="#scoreAdjustTyp" class="anchor" title="Link to scoreAdjustTyp">#</a>
               </h3>
               
               <p>These constants enumerate the set of possible ways/scenarios
in which we'll adjust the score of a given callsite.</p>
               
               <pre><code class="language-go">type scoreAdjustTyp uint</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="testfType" data-name="testfType">
               <h3>
                  testfType
                  <span class="badge type-badge">type</span>
                  <a href="#testfType" class="anchor" title="Link to testfType">#</a>
               </h3>
               
               <pre><code class="language-go">type testfType func(x ir.Node, param *ir.Name, idx int) (bool, bool)</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="propAnalyzer" data-name="propAnalyzer">
               <h3>
                  propAnalyzer
                  <span class="badge interface-badge">interface</span>
                  <a href="#propAnalyzer" class="anchor" title="Link to propAnalyzer">#</a>
               </h3>
               
               <p>propAnalyzer interface is used for defining one or more analyzer
helper objects, each tasked with computing some specific subset of
the properties we're interested in. The assumption is that
properties are independent, so each new analyzer that implements
this interface can operate entirely on its own. For a given analyzer
there will be a sequence of calls to nodeVisitPre and nodeVisitPost
as the nodes within a function are visited, then a followup call to
setResults so that the analyzer can transfer its results into the
final properties object.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type propAnalyzer interface {
nodeVisitPre(n ir.Node)
nodeVisitPost(n ir.Node)
setResults(funcProps *FuncProps)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="CallSite" data-name="CallSite">
               <h3>
                  CallSite
                  <span class="badge">struct</span>
                  <a href="#CallSite" class="anchor" title="Link to CallSite">#</a>
               </h3>
               
               <p>CallSite records useful information about a potentially inlinable
(direct) function call. "Callee" is the target of the call, "Call"
is the ir node corresponding to the call itself, "Assign" is
the top-level assignment statement containing the call (if the call
appears in the form of a top-level statement, e.g. "x := foo()"),
"Flags" contains properties of the call that might be useful for
making inlining decisions, "Score" is the final score assigned to
the site, and "ID" is a numeric ID for the site within its
containing function.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type CallSite struct {
Callee *ir.Func
Call *ir.CallExpr
parent *CallSite
Assign ir.Node
Flags CSPropBits
ArgProps []ActualExprPropBits
Score int
ScoreMask scoreAdjustTyp
ID uint
aux uint8
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="FuncProps" data-name="FuncProps">
               <h3>
                  FuncProps
                  <span class="badge">struct</span>
                  <a href="#FuncProps" class="anchor" title="Link to FuncProps">#</a>
               </h3>
               
               <p>FuncProps describes a set of function or method properties that may
be useful for inlining heuristics. Here 'Flags' are properties that
we think apply to the entire function; 'RecvrParamFlags' are
properties of specific function params (or the receiver), and
'ResultFlags' are things properties we think will apply to values
of specific results. Note that 'ParamFlags' includes and entry for
the receiver if applicable, and does include etries for blank
params; for a function such as "func foo(_ int, b byte, _ float32)"
the length of ParamFlags will be 3.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type FuncProps struct {
Flags FuncPropBits
ParamFlags []ParamPropBits
ResultFlags []ResultPropBits
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="callSiteAnalyzer" data-name="callSiteAnalyzer">
               <h3>
                  callSiteAnalyzer
                  <span class="badge">struct</span>
                  <a href="#callSiteAnalyzer" class="anchor" title="Link to callSiteAnalyzer">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type callSiteAnalyzer struct {
fn *ir.Func
*nameFinder
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="callSiteTableBuilder" data-name="callSiteTableBuilder">
               <h3>
                  callSiteTableBuilder
                  <span class="badge">struct</span>
                  <a href="#callSiteTableBuilder" class="anchor" title="Link to callSiteTableBuilder">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type callSiteTableBuilder struct {
fn *ir.Func
*nameFinder
cstab CallSiteTab
ptab map[ir.Node]pstate
nstack []ir.Node
loopNest int
isInit bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="condLevelTracker" data-name="condLevelTracker">
               <h3>
                  condLevelTracker
                  <span class="badge">struct</span>
                  <a href="#condLevelTracker" class="anchor" title="Link to condLevelTracker">#</a>
               </h3>
               
               <p>condLevelTracker helps keeps track very roughly of "level of conditional
nesting", e.g. how many "if" statements you have to go through to
get to the point where a given stmt executes. Example:
cond nesting level
func foo() {
G = 1                   0
if x < 10 {             0
if y < 10 {            1
G = 0                 2
}
}
}
The intent here is to provide some sort of very abstract relative
hotness metric, e.g. "G = 1" above is expected to be executed more
often than "G = 0" (in the aggregate, across large numbers of
functions).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type condLevelTracker struct {
condLevel int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="exprClassifier" data-name="exprClassifier">
               <h3>
                  exprClassifier
                  <span class="badge">struct</span>
                  <a href="#exprClassifier" class="anchor" title="Link to exprClassifier">#</a>
               </h3>
               
               <p>exprClassifier holds intermediate state about nodes within an
expression tree being analyzed by ShouldFoldIfNameConstant. Here
"name" is the name node passed in, and "disposition" stores the
result of classifying a given IR node.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type exprClassifier struct {
names map[*ir.Name]bool
disposition map[ir.Node]disp
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fnInlHeur" data-name="fnInlHeur">
               <h3>
                  fnInlHeur
                  <span class="badge">struct</span>
                  <a href="#fnInlHeur" class="anchor" title="Link to fnInlHeur">#</a>
               </h3>
               
               <p>fnInlHeur contains inline heuristics state information about a
specific Go function being analyzed/considered by the inliner. Note
that in addition to constructing a fnInlHeur object by analyzing a
specific *ir.Func, there is also code in the test harness
(funcprops_test.go) that builds up fnInlHeur's by reading in and
parsing a dump. This is the reason why we have file/fname/line
fields below instead of just an *ir.Func field.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fnInlHeur struct {
props *FuncProps
cstab CallSiteTab
fname string
file string
line uint
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="funcFlagsAnalyzer" data-name="funcFlagsAnalyzer">
               <h3>
                  funcFlagsAnalyzer
                  <span class="badge">struct</span>
                  <a href="#funcFlagsAnalyzer" class="anchor" title="Link to funcFlagsAnalyzer">#</a>
               </h3>
               
               <p>funcFlagsAnalyzer computes the "Flags" value for the FuncProps
object we're computing. The main item of interest here is "nstate",
which stores the disposition of a given ir Node with respect to the
flags/properties we're trying to compute.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type funcFlagsAnalyzer struct {
fn *ir.Func
nstate map[ir.Node]pstate
noInfo bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="nameFinder" data-name="nameFinder">
               <h3>
                  nameFinder
                  <span class="badge">struct</span>
                  <a href="#nameFinder" class="anchor" title="Link to nameFinder">#</a>
               </h3>
               
               <p>nameFinder provides a set of "isXXX" query methods for clients to
ask whether a given AST node corresponds to a function, a constant
value, and so on. These methods use an underlying ir.ReassignOracle
to return more precise results in cases where an "interesting"
value is assigned to a singly-defined local temp. Example:
const q = 101
fq := func() int { return q }
copyOfConstant := q
copyOfFunc := f
interestingCall(copyOfConstant, copyOfFunc)
A name finder query method invoked on the arguments being passed to
"interestingCall" will be able detect that 'copyOfConstant' always
evaluates to a constant (even though it is in fact a PAUTO local
variable). A given nameFinder can also operate without using
ir.ReassignOracle (in cases where it is not practical to look
at the entire function); in such cases queries will still work
for explicit constant values and functions.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type nameFinder struct {
ro *ir.ReassignOracle
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="paramsAnalyzer" data-name="paramsAnalyzer">
               <h3>
                  paramsAnalyzer
                  <span class="badge">struct</span>
                  <a href="#paramsAnalyzer" class="anchor" title="Link to paramsAnalyzer">#</a>
               </h3>
               
               <p>paramsAnalyzer holds state information for the phase that computes
flags for a Go functions parameters, for use in inline heuristics.
Note that the params slice below includes entries for blanks.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type paramsAnalyzer struct {
fname string
values []ParamPropBits
params []*ir.Name
top []bool
*condLevelTracker
*nameFinder
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="propsAndScore" data-name="propsAndScore">
               <h3>
                  propsAndScore
                  <span class="badge">struct</span>
                  <a href="#propsAndScore" class="anchor" title="Link to propsAndScore">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type propsAndScore struct {
props CSPropBits
score int
mask scoreAdjustTyp
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="resultPropAndCS" data-name="resultPropAndCS">
               <h3>
                  resultPropAndCS
                  <span class="badge">struct</span>
                  <a href="#resultPropAndCS" class="anchor" title="Link to resultPropAndCS">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type resultPropAndCS struct {
defcs *CallSite
props ResultPropBits
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="resultUseAnalyzer" data-name="resultUseAnalyzer">
               <h3>
                  resultUseAnalyzer
                  <span class="badge">struct</span>
                  <a href="#resultUseAnalyzer" class="anchor" title="Link to resultUseAnalyzer">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type resultUseAnalyzer struct {
resultNameTab map[*ir.Name]resultPropAndCS
fn *ir.Func
cstab CallSiteTab
*condLevelTracker
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="resultVal" data-name="resultVal">
               <h3>
                  resultVal
                  <span class="badge">struct</span>
                  <a href="#resultVal" class="anchor" title="Link to resultVal">#</a>
               </h3>
               
               <p>resultVal captures information about a specific result returned from
the function we're analyzing; we are interested in cases where
the func always returns the same constant, or always returns
the same function, etc. This container stores info on a the specific
scenarios we're looking for.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type resultVal struct {
cval constant.Value
fn *ir.Name
fnClo bool
top bool
derived bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="resultsAnalyzer" data-name="resultsAnalyzer">
               <h3>
                  resultsAnalyzer
                  <span class="badge">struct</span>
                  <a href="#resultsAnalyzer" class="anchor" title="Link to resultsAnalyzer">#</a>
               </h3>
               
               <p>resultsAnalyzer stores state information for the process of
computing flags/properties for the return values of a specific Go
function, as part of inline heuristics synthesis.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type resultsAnalyzer struct {
fname string
props []ResultPropBits
values []resultVal
inlineMaxBudget int
*nameFinder
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="scoreCallsCacheType" data-name="scoreCallsCacheType">
               <h3>
                  scoreCallsCacheType
                  <span class="badge">struct</span>
                  <a href="#scoreCallsCacheType" class="anchor" title="Link to scoreCallsCacheType">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type scoreCallsCacheType struct {
tab CallSiteTab
csl []*CallSite
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AnalyzeFunc" data-name="AnalyzeFunc">
               <h3>
                  AnalyzeFunc 
                  <span class="badge">function</span>
                  
                  <a href="#AnalyzeFunc" class="anchor" title="Link to AnalyzeFunc">#</a>
               </h3>
               
               <p>AnalyzeFunc computes function properties for fn and its contained
closures, updating the global 'fpmap' table. It is assumed that
"CanInline" has been run on fn and on the closures that feed
directly into calls; other closures not directly called will also
be checked inlinability for inlinability here in case they are
returned as a result.</p>
               
               <pre><code class="language-go">func AnalyzeFunc(fn *ir.Func, canInline func(*ir.Func), budgetForFunc func(*ir.Func) int32, inlineMaxBudget int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BudgetExpansion" data-name="BudgetExpansion">
               <h3>
                  BudgetExpansion 
                  <span class="badge">function</span>
                  
                  <a href="#BudgetExpansion" class="anchor" title="Link to BudgetExpansion">#</a>
               </h3>
               
               <p>BudgetExpansion returns the amount to relax/expand the base
inlining budget when the new inliner is turned on; the inliner
will add the returned value to the hairiness budget.
Background: with the new inliner, the score for a given callsite
can be adjusted down by some amount due to heuristics, however we
won't know whether this is going to happen until much later after
the CanInline call. This function returns the amount to relax the
budget initially (to allow for a large score adjustment); later on
in RevisitInlinability we'll look at each individual function to
demote it if needed.</p>
               
               <pre><code class="language-go">func BudgetExpansion(maxBudget int32) int32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DeserializeFromString" data-name="DeserializeFromString">
               <h3>
                  DeserializeFromString 
                  <span class="badge">function</span>
                  
                  <a href="#DeserializeFromString" class="anchor" title="Link to DeserializeFromString">#</a>
               </h3>
               
               <pre><code class="language-go">func DeserializeFromString(s string) *FuncProps</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DumpFuncProps" data-name="DumpFuncProps">
               <h3>
                  DumpFuncProps 
                  <span class="badge">function</span>
                  
                  <a href="#DumpFuncProps" class="anchor" title="Link to DumpFuncProps">#</a>
               </h3>
               
               <p>DumpFuncProps computes and caches function properties for the func
'fn', writing out a description of the previously computed set of
properties to the file given in 'dumpfile'. Used for the
"-d=dumpinlfuncprops=..." command line flag, intended for use
primarily in unit testing.</p>
               
               <pre><code class="language-go">func DumpFuncProps(fn *ir.Func, dumpfile string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DumpInlCallSiteScores" data-name="DumpInlCallSiteScores">
               <h3>
                  DumpInlCallSiteScores 
                  <span class="badge">function</span>
                  
                  <a href="#DumpInlCallSiteScores" class="anchor" title="Link to DumpInlCallSiteScores">#</a>
               </h3>
               
               <p>DumpInlCallSiteScores is invoked by the inliner if the debug flag
"-d=dumpinlcallsitescores" is set; it dumps out a human-readable
summary of all (potentially) inlinable callsites in the package,
along with info on call site scoring and the adjustments made to a
given score. Here profile is the PGO profile in use (may be
nil), budgetCallback is a callback that can be invoked to find out
the original pre-adjustment hairiness limit for the function, and
inlineHotMaxBudget is the constant of the same name used in the
inliner. Sample output lines:
Score  Adjustment  Status  Callee  CallerPos ScoreFlags
115    40          DEMOTED cmd/compile/internal/abi.(*ABIParamAssignment).Offset     expand_calls.go:1679:14|6       panicPathAdj
76     -5n         PROMOTED runtime.persistentalloc   mcheckmark.go:48:45|3   inLoopAdj
201    0           --- PGO  unicode.DecodeRuneInString        utf8.go:312:30|1
7      -5          --- PGO  internal/abi.Name.DataChecked     type.go:625:22|0        inLoopAdj
In the dump above, "Score" is the final score calculated for the
callsite, "Adjustment" is the amount added to or subtracted from
the original hairiness estimate to form the score. "Status" shows
whether anything changed with the site -- did the adjustment bump
it down just below the threshold ("PROMOTED") or instead bump it
above the threshold ("DEMOTED"); this will be blank ("---") if no
threshold was crossed as a result of the heuristics. Note that
"Status" also shows whether PGO was involved. "Callee" is the name
of the function called, "CallerPos" is the position of the
callsite, and "ScoreFlags" is a digest of the specific properties
we used to make adjustments to callsite score via heuristics.</p>
               
               <pre><code class="language-go">func DumpInlCallSiteScores(profile *pgoir.Profile, budgetCallback func(fn *ir.Func, profile *pgoir.Profile) (int32, bool))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Enabled" data-name="Enabled">
               <h3>
                  Enabled 
                  <span class="badge">function</span>
                  
                  <a href="#Enabled" class="anchor" title="Link to Enabled">#</a>
               </h3>
               
               <pre><code class="language-go">func Enabled() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EncodeCallSiteKey" data-name="EncodeCallSiteKey">
               <h3>
                  EncodeCallSiteKey 
                  <span class="badge">function</span>
                  
                  <a href="#EncodeCallSiteKey" class="anchor" title="Link to EncodeCallSiteKey">#</a>
               </h3>
               
               <pre><code class="language-go">func EncodeCallSiteKey(cs *CallSite) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetCallSiteScore" data-name="GetCallSiteScore">
               <h3>
                  GetCallSiteScore 
                  <span class="badge">function</span>
                  
                  <a href="#GetCallSiteScore" class="anchor" title="Link to GetCallSiteScore">#</a>
               </h3>
               
               <p>GetCallSiteScore returns the previously calculated score for call
within fn.</p>
               
               <pre><code class="language-go">func GetCallSiteScore(fn *ir.Func, call *ir.CallExpr) (int, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LargestNegativeScoreAdjustment" data-name="LargestNegativeScoreAdjustment">
               <h3>
                  LargestNegativeScoreAdjustment 
                  <span class="badge">function</span>
                  
                  <a href="#LargestNegativeScoreAdjustment" class="anchor" title="Link to LargestNegativeScoreAdjustment">#</a>
               </h3>
               
               <p>LargestNegativeScoreAdjustment tries to estimate the largest possible
negative score adjustment that could be applied to a call of the
function with the specified props. Example:
func foo() {                  func bar(x int, p *int) int {
...                          if x < 0 { *p = x }
}                               return 99
}
Function 'foo' above on the left has no interesting properties,
thus as a result the most we'll adjust any call to is the value for
"call in loop". If the calculated cost of the function is 150, and
the in-loop adjustment is 5 (for example), then there is not much
point treating it as inlinable. On the other hand "bar" has a param
property (parameter "x" feeds unmodified to an "if" statement) and
a return property (always returns same constant) meaning that a
given call _could_ be rescored down as much as -35 points-- thus if
the size of "bar" is 100 (for example) then there is at least a
chance that scoring will enable inlining.</p>
               
               <pre><code class="language-go">func LargestNegativeScoreAdjustment(fn *ir.Func, props *FuncProps) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LargestPositiveScoreAdjustment" data-name="LargestPositiveScoreAdjustment">
               <h3>
                  LargestPositiveScoreAdjustment 
                  <span class="badge">function</span>
                  
                  <a href="#LargestPositiveScoreAdjustment" class="anchor" title="Link to LargestPositiveScoreAdjustment">#</a>
               </h3>
               
               <p>LargestPositiveScoreAdjustment tries to estimate the largest possible
positive score adjustment that could be applied to a given callsite.
At the moment we don't have very many positive score adjustments, so
this is just hard-coded, not table-driven.</p>
               
               <pre><code class="language-go">func LargestPositiveScoreAdjustment(fn *ir.Func) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScoreCalls" data-name="ScoreCalls">
               <h3>
                  ScoreCalls 
                  <span class="badge">function</span>
                  
                  <a href="#ScoreCalls" class="anchor" title="Link to ScoreCalls">#</a>
               </h3>
               
               <p>ScoreCalls assigns numeric scores to each of the callsites in
function 'fn'; the lower the score, the more helpful we think it
will be to inline.
Unlike a lot of the other inline heuristics machinery, callsite
scoring can't be done as part of the CanInline call for a function,
due to fact that we may be working on a non-trivial SCC. So for
example with this SCC:
func foo(x int) {           func bar(x int, f func()) {
if x != 0 {                  f()
bar(x, func(){})           foo(x-1)
}                         }
}
We don't want to perform scoring for the 'foo' call in "bar" until
after foo has been analyzed, but it's conceivable that CanInline
might visit bar before foo for this SCC.</p>
               
               <pre><code class="language-go">func ScoreCalls(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScoreCallsCleanup" data-name="ScoreCallsCleanup">
               <h3>
                  ScoreCallsCleanup 
                  <span class="badge">function</span>
                  
                  <a href="#ScoreCallsCleanup" class="anchor" title="Link to ScoreCallsCleanup">#</a>
               </h3>
               
               <p>ScoreCallsCleanup resets the state of the callsite cache
once ScoreCalls is done with a function.</p>
               
               <pre><code class="language-go">func ScoreCallsCleanup()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SerializeToString" data-name="SerializeToString">
               <h3>
                  SerializeToString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SerializeToString" class="anchor" title="Link to SerializeToString">#</a>
               </h3>
               
               <pre><code class="language-go">func (funcProps *FuncProps) SerializeToString() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetupScoreAdjustments" data-name="SetupScoreAdjustments">
               <h3>
                  SetupScoreAdjustments 
                  <span class="badge">function</span>
                  
                  <a href="#SetupScoreAdjustments" class="anchor" title="Link to SetupScoreAdjustments">#</a>
               </h3>
               
               <p>SetupScoreAdjustments interprets the value of the -d=inlscoreadj
debugging option, if set. The value of this flag is expected to be
a series of "/"-separated clauses of the form adj1:value1. Example:
-d=inlscoreadj=inLoopAdj=0/passConstToIfAdj=-99</p>
               
               <pre><code class="language-go">func SetupScoreAdjustments()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ShouldFoldIfNameConstant" data-name="ShouldFoldIfNameConstant">
               <h3>
                  ShouldFoldIfNameConstant 
                  <span class="badge">function</span>
                  
                  <a href="#ShouldFoldIfNameConstant" class="anchor" title="Link to ShouldFoldIfNameConstant">#</a>
               </h3>
               
               <p>ShouldFoldIfNameConstant analyzes expression tree 'e' to see
whether it contains only combinations of simple references to all
of the names in 'names' with selected constants + operators. The
intent is to identify expression that could be folded away to a
constant if the value of 'n' were available. Return value is TRUE
if 'e' does look foldable given the value of 'n', and given that
'e' actually makes reference to 'n'. Some examples where the type
of "n" is int64, type of "s" is string, and type of "p" is *byte:
Simple?		Expr
yes			n<10
yes			n*n-100
yes			(n < 10 || n > 100) && (n >= 12 || n <= 99 || n != 101)
yes			s == "foo"
yes			p == nil
no			n<foo()
no			n<1 || n>m
no			float32(n)<1.0
no			*p == 1
no			1 + 100
no			1 / n
no			1 + unsafe.Sizeof(n)
To avoid complexities (e.g. nan, inf) we stay way from folding and
floating point or complex operations (integers, bools, and strings
only). We also try to be conservative about avoiding any operation
that might result in a panic at runtime, e.g. for "n" with type
int64:
1<<(n-9) < 100/(n<<9999)
we would return FALSE due to the negative shift count and/or
potential divide by zero.</p>
               
               <pre><code class="language-go">func ShouldFoldIfNameConstant(n ir.Node, names []*ir.Name) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (d disp) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (i FuncPropBits) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (pas propsAndScore) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (i ActualExprPropBits) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (i CSPropBits) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (i ParamPropBits) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (i scoreAdjustTyp) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (i ResultPropBits) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (i pstate) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (fp *FuncProps) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TearDown" data-name="TearDown">
               <h3>
                  TearDown 
                  <span class="badge">function</span>
                  
                  <a href="#TearDown" class="anchor" title="Link to TearDown">#</a>
               </h3>
               
               <p>TearDown is invoked at the end of the main inlining pass; doing
function analysis and call site scoring is unlikely to help a lot
after this point, so nil out fpmap and other globals to reclaim
storage.</p>
               
               <pre><code class="language-go">func TearDown()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ToString" data-name="ToString">
               <h3>
                  ToString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ToString" class="anchor" title="Link to ToString">#</a>
               </h3>
               
               <pre><code class="language-go">func (fp *FuncProps) ToString(prefix string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnitTesting" data-name="UnitTesting">
               <h3>
                  UnitTesting 
                  <span class="badge">function</span>
                  
                  <a href="#UnitTesting" class="anchor" title="Link to UnitTesting">#</a>
               </h3>
               
               <pre><code class="language-go">func UnitTesting() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UpdateCallsiteTable" data-name="UpdateCallsiteTable">
               <h3>
                  UpdateCallsiteTable 
                  <span class="badge">function</span>
                  
                  <a href="#UpdateCallsiteTable" class="anchor" title="Link to UpdateCallsiteTable">#</a>
               </h3>
               
               <p>UpdateCallsiteTable handles updating of callerfn's call site table
after an inlined has been carried out, e.g. the call at 'n' as been
turned into the inlined call expression 'ic' within function
callerfn. The chief thing of interest here is to make sure that any
call nodes within 'ic' are added to the call site table for
'callerfn' and scored appropriately.</p>
               
               <pre><code class="language-go">func UpdateCallsiteTable(callerfn *ir.Func, n *ir.CallExpr, ic *ir.InlinedCallExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Visit" data-name="Visit">
               <h3>
                  Visit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Visit" class="anchor" title="Link to Visit">#</a>
               </h3>
               
               <p>Visit sets the classification for 'n' based on the previously
calculated classifications for n's children, as part of a bottom-up
walk over an expression tree.</p>
               
               <pre><code class="language-go">func (ec *exprClassifier) Visit(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">func _()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">func _()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">func _()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">func _()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">func _()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">func _()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">func _()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addCallSite" data-name="addCallSite">
               <h3>
                  addCallSite 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addCallSite" class="anchor" title="Link to addCallSite">#</a>
               </h3>
               
               <pre><code class="language-go">func (cstb *callSiteTableBuilder) addCallSite(callee *ir.Func, call *ir.CallExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addParamsAnalyzer" data-name="addParamsAnalyzer">
               <h3>
                  addParamsAnalyzer 
                  <span class="badge">function</span>
                  
                  <a href="#addParamsAnalyzer" class="anchor" title="Link to addParamsAnalyzer">#</a>
               </h3>
               
               <p>addParamsAnalyzer creates a new paramsAnalyzer helper object for
the function fn, appends it to the analyzers list, and returns the
new list. If the function in question doesn't have any interesting
parameters then the analyzer list is returned unchanged, and the
params flags in "fp" are updated accordingly.</p>
               
               <pre><code class="language-go">func addParamsAnalyzer(fn *ir.Func, analyzers []propAnalyzer, fp *FuncProps, nf *nameFinder) []propAnalyzer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addResultsAnalyzer" data-name="addResultsAnalyzer">
               <h3>
                  addResultsAnalyzer 
                  <span class="badge">function</span>
                  
                  <a href="#addResultsAnalyzer" class="anchor" title="Link to addResultsAnalyzer">#</a>
               </h3>
               
               <p>addResultsAnalyzer creates a new resultsAnalyzer helper object for
the function fn, appends it to the analyzers list, and returns the
new list. If the function in question doesn't have any returns (or
any interesting returns) then the analyzer list is left as is, and
the result flags in "fp" are updated accordingly.</p>
               
               <pre><code class="language-go">func addResultsAnalyzer(fn *ir.Func, analyzers []propAnalyzer, fp *FuncProps, inlineMaxBudget int, nf *nameFinder) []propAnalyzer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="adjStringToVal" data-name="adjStringToVal">
               <h3>
                  adjStringToVal 
                  <span class="badge">function</span>
                  
                  <a href="#adjStringToVal" class="anchor" title="Link to adjStringToVal">#</a>
               </h3>
               
               <pre><code class="language-go">func adjStringToVal(s string) (scoreAdjustTyp, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="adjValue" data-name="adjValue">
               <h3>
                  adjValue 
                  <span class="badge">function</span>
                  
                  <a href="#adjValue" class="anchor" title="Link to adjValue">#</a>
               </h3>
               
               <pre><code class="language-go">func adjValue(x scoreAdjustTyp) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="adjustScore" data-name="adjustScore">
               <h3>
                  adjustScore 
                  <span class="badge">function</span>
                  
                  <a href="#adjustScore" class="anchor" title="Link to adjustScore">#</a>
               </h3>
               
               <pre><code class="language-go">func adjustScore(typ scoreAdjustTyp, score int, mask scoreAdjustTyp) (int, scoreAdjustTyp)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="analyzeFunc" data-name="analyzeFunc">
               <h3>
                  analyzeFunc 
                  <span class="badge">function</span>
                  
                  <a href="#analyzeFunc" class="anchor" title="Link to analyzeFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func analyzeFunc(fn *ir.Func, inlineMaxBudget int, nf *nameFinder) *FuncProps</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="analyzeResult" data-name="analyzeResult">
               <h3>
                  analyzeResult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#analyzeResult" class="anchor" title="Link to analyzeResult">#</a>
               </h3>
               
               <p>analyzeResult examines the expression 'n' being returned as the
'ii'th argument in some return statement to see whether has
interesting characteristics (for example, returns a constant), then
applies a dataflow "meet" operation to combine this result with any
previous result (for the given return slot) that we've already
processed.</p>
               
               <pre><code class="language-go">func (ra *resultsAnalyzer) analyzeResult(ii int, n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="argPropsForCall" data-name="argPropsForCall">
               <h3>
                  argPropsForCall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#argPropsForCall" class="anchor" title="Link to argPropsForCall">#</a>
               </h3>
               
               <p>argPropsForCall returns a slice of argument properties for the
expressions being passed to the callee in the specific call
expression; these will be stored in the CallSite object for a given
call and then consulted when scoring. If no arg has any interesting
properties we try to save some space and return a nil slice.</p>
               
               <pre><code class="language-go">func (cstb *callSiteTableBuilder) argPropsForCall(ce *ir.CallExpr) []ActualExprPropBits</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="blockCombine" data-name="blockCombine">
               <h3>
                  blockCombine 
                  <span class="badge">function</span>
                  
                  <a href="#blockCombine" class="anchor" title="Link to blockCombine">#</a>
               </h3>
               
               <p>blockCombine merges together states as part of a linear sequence of
statements, where 'pred' and 'succ' are analysis results for a pair
of consecutive statements. Examples:
case 1:             case 2:
panic("foo")      if q { return x }        <-pred
return x          panic("boo")             <-succ
In case 1, since the pred state is "always panic" it doesn't matter
what the succ state is, hence the state for the combination of the
two blocks is "always panics". In case 2, because there is a path
to return that avoids the panic in succ, the state for the
combination of the two statements is "may return".</p>
               
               <pre><code class="language-go">func blockCombine(pred pstate, succ pstate) pstate</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="branchCombine" data-name="branchCombine">
               <h3>
                  branchCombine 
                  <span class="badge">function</span>
                  
                  <a href="#branchCombine" class="anchor" title="Link to branchCombine">#</a>
               </h3>
               
               <p>branchCombine combines two states at a control flow branch point where
either p1 or p2 executes (as in an "if" statement).</p>
               
               <pre><code class="language-go">func branchCombine(p1 pstate, p2 pstate) pstate</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="buildEncodedCallSiteTab" data-name="buildEncodedCallSiteTab">
               <h3>
                  buildEncodedCallSiteTab 
                  <span class="badge">function</span>
                  
                  <a href="#buildEncodedCallSiteTab" class="anchor" title="Link to buildEncodedCallSiteTab">#</a>
               </h3>
               
               <pre><code class="language-go">func buildEncodedCallSiteTab(tab CallSiteTab) encodedCallSiteTab</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="callCheckParams" data-name="callCheckParams">
               <h3>
                  callCheckParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#callCheckParams" class="anchor" title="Link to callCheckParams">#</a>
               </h3>
               
               <p>callCheckParams examines the target of call expression 'ce' to see
if it is making a call to the value passed in for some parameter.</p>
               
               <pre><code class="language-go">func (pa *paramsAnalyzer) callCheckParams(ce *ir.CallExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="callTargetCheckResults" data-name="callTargetCheckResults">
               <h3>
                  callTargetCheckResults 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#callTargetCheckResults" class="anchor" title="Link to callTargetCheckResults">#</a>
               </h3>
               
               <p>callTargetCheckResults examines a given call to see whether the
callee expression is potentially an inlinable function returned
from a potentially inlinable call. Examples:
Scenario 1: named intermediate
fn1 := foo()         conc := bar()
fn1("blah")          conc.MyMethod()
Scenario 2: returned func or concrete object feeds directly to call
foo()("blah")        bar().MyMethod()
In the second case although at the source level the result of the
direct call feeds right into the method call or indirect call,
we're relying on the front end having inserted an auto-temp to
capture the value.</p>
               
               <pre><code class="language-go">func (rua *resultUseAnalyzer) callTargetCheckResults(call ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="captureFuncDumpEntry" data-name="captureFuncDumpEntry">
               <h3>
                  captureFuncDumpEntry 
                  <span class="badge">function</span>
                  
                  <a href="#captureFuncDumpEntry" class="anchor" title="Link to captureFuncDumpEntry">#</a>
               </h3>
               
               <p>captureFuncDumpEntry grabs the function properties object for 'fn'
and enqueues it for later dumping. Used for the
"-d=dumpinlfuncprops=..." command line flag, intended for use
primarily in unit testing.</p>
               
               <pre><code class="language-go">func captureFuncDumpEntry(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkParams" data-name="checkParams">
               <h3>
                  checkParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkParams" class="anchor" title="Link to checkParams">#</a>
               </h3>
               
               <p>paramsAnalyzer invokes function 'testf' on the specified expression
'x' for each parameter, and if the result is TRUE, or's 'flag' into
the flags for that param.</p>
               
               <pre><code class="language-go">func (pa *paramsAnalyzer) checkParams(x ir.Node, flag ParamPropBits, mayflag ParamPropBits, testf testfType)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="collectNamesUsed" data-name="collectNamesUsed">
               <h3>
                  collectNamesUsed 
                  <span class="badge">function</span>
                  
                  <a href="#collectNamesUsed" class="anchor" title="Link to collectNamesUsed">#</a>
               </h3>
               
               <pre><code class="language-go">func collectNamesUsed(expr ir.Node) []*ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="computeCallSiteScore" data-name="computeCallSiteScore">
               <h3>
                  computeCallSiteScore 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#computeCallSiteScore" class="anchor" title="Link to computeCallSiteScore">#</a>
               </h3>
               
               <p>computeCallSiteScore takes a given call site whose ir node is
'call' and callee function is 'callee' and with previously computed
call site properties 'csflags', then computes a score for the
callsite that combines the size cost of the callee with heuristics
based on previously computed argument and function properties,
then stores the score and the adjustment mask in the appropriate
fields in 'cs'</p>
               
               <pre><code class="language-go">func (cs *CallSite) computeCallSiteScore(csa *callSiteAnalyzer, calleeProps *FuncProps)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="computeCallSiteTable" data-name="computeCallSiteTable">
               <h3>
                  computeCallSiteTable 
                  <span class="badge">function</span>
                  
                  <a href="#computeCallSiteTable" class="anchor" title="Link to computeCallSiteTable">#</a>
               </h3>
               
               <p>computeCallSiteTable builds and returns a table of call sites for
the specified region in function fn. A region here corresponds to a
specific subtree within the AST for a function. The main intended
use cases are for 'region' to be either A) an entire function body,
or B) an inlined call expression.</p>
               
               <pre><code class="language-go">func computeCallSiteTable(fn *ir.Func, region ir.Nodes, cstab CallSiteTab, ptab map[ir.Node]pstate, loopNestingLevel int, nf *nameFinder) CallSiteTab</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="computeFuncProps" data-name="computeFuncProps">
               <h3>
                  computeFuncProps 
                  <span class="badge">function</span>
                  
                  <a href="#computeFuncProps" class="anchor" title="Link to computeFuncProps">#</a>
               </h3>
               
               <p>computeFuncProps examines the Go function 'fn' and computes for it
a function "properties" object, to be used to drive inlining
heuristics. See comments on the FuncProps type for more info.</p>
               
               <pre><code class="language-go">func computeFuncProps(fn *ir.Func, inlineMaxBudget int, nf *nameFinder) (*FuncProps, CallSiteTab)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constValue" data-name="constValue">
               <h3>
                  constValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constValue" class="anchor" title="Link to constValue">#</a>
               </h3>
               
               <p>constValue returns the underlying constant.Value for an AST node n
if n is itself a constant value/expr, or if n is a singly assigned
local containing constant expr/value (or nil not constant).</p>
               
               <pre><code class="language-go">func (nf *nameFinder) constValue(n ir.Node) constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="containingAssignment" data-name="containingAssignment">
               <h3>
                  containingAssignment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#containingAssignment" class="anchor" title="Link to containingAssignment">#</a>
               </h3>
               
               <p>containingAssignment returns the top-level assignment statement
for a statement level function call "n". Examples:
x := foo()
x, y := bar(z, baz())
if blah() { ...
Here the top-level assignment statement for the foo() call is the
statement assigning to "x"; the top-level assignment for "bar()"
call is the assignment to x,y. For the baz() and blah() calls,
there is no top level assignment statement.
The unstated goal here is that we want to use the containing
assignment to establish a connection between a given call and the
variables to which its results/returns are being assigned.
Note that for the "bar" command above, the front end sometimes
decomposes this into two assignments, the first one assigning the
call to a pair of auto-temps, then the second one assigning the
auto-temps to the user-visible vars. This helper will return the
second (outer) of these two.</p>
               
               <pre><code class="language-go">func (cstb *callSiteTableBuilder) containingAssignment(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="deriveFlagsFromCallee" data-name="deriveFlagsFromCallee">
               <h3>
                  deriveFlagsFromCallee 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#deriveFlagsFromCallee" class="anchor" title="Link to deriveFlagsFromCallee">#</a>
               </h3>
               
               <p>deriveFlagsFromCallee tries to derive flags for the current
function based on a call this function makes to some other
function. Example:
/* Simple */                /* Derived from callee
func foo(f func(int)) {     func foo(f func(int)) {
f(2)                        bar(32, f)
}                           }
func bar(x int, f func()) {
f(x)
}
Here we can set the "param feeds indirect call" flag for
foo's param 'f' since we know that bar has that flag set for
its second param, and we're passing that param a function.</p>
               
               <pre><code class="language-go">func (pa *paramsAnalyzer) deriveFlagsFromCallee(ce *ir.CallExpr, callee *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="deriveReturnFlagsFromCallee" data-name="deriveReturnFlagsFromCallee">
               <h3>
                  deriveReturnFlagsFromCallee 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#deriveReturnFlagsFromCallee" class="anchor" title="Link to deriveReturnFlagsFromCallee">#</a>
               </h3>
               
               <p>deriveReturnFlagsFromCallee tries to set properties for a given
return result where we're returning call expression; return value
is a return property value and a boolean indicating whether the
prop is valid. Examples:
func foo() int { return bar() }
func bar() int { return 42 }
func blix() int { return 43 }
func two(y int) int {
if y < 0 { return bar() } else { return blix() }
}
Since "foo" always returns the result of a call to "bar", we can
set foo's return property to that of bar. In the case of "two", however,
even though each return path returns a constant, we don't know
whether the constants are identical, hence we need to be conservative.</p>
               
               <pre><code class="language-go">func (ra *resultsAnalyzer) deriveReturnFlagsFromCallee(n ir.Node) (ResultPropBits, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="determinePanicPathBits" data-name="determinePanicPathBits">
               <h3>
                  determinePanicPathBits 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#determinePanicPathBits" class="anchor" title="Link to determinePanicPathBits">#</a>
               </h3>
               
               <p>determinePanicPathBits updates the CallSiteOnPanicPath bit within
"r" if we think this call is on an unconditional path to
panic/exit. Do this by walking back up the node stack to see if we
can find either A) an enclosing panic, or B) a statement node that
we've determined leads to a panic/exit.</p>
               
               <pre><code class="language-go">func (cstb *callSiteTableBuilder) determinePanicPathBits(call ir.Node, r CSPropBits) CSPropBits</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="disableDebugTrace" data-name="disableDebugTrace">
               <h3>
                  disableDebugTrace 
                  <span class="badge">function</span>
                  
                  <a href="#disableDebugTrace" class="anchor" title="Link to disableDebugTrace">#</a>
               </h3>
               
               <pre><code class="language-go">func disableDebugTrace()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="disableDebugTrace" data-name="disableDebugTrace">
               <h3>
                  disableDebugTrace 
                  <span class="badge">function</span>
                  
                  <a href="#disableDebugTrace" class="anchor" title="Link to disableDebugTrace">#</a>
               </h3>
               
               <pre><code class="language-go">func disableDebugTrace()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dispmeet" data-name="dispmeet">
               <h3>
                  dispmeet 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dispmeet" class="anchor" title="Link to dispmeet">#</a>
               </h3>
               
               <p>dispmeet performs a "meet" operation on the data flow states of
node x and y (where the term "meet" is being drawn from traditional
lattice-theoretical data flow analysis terminology).</p>
               
               <pre><code class="language-go">func (ec *exprClassifier) dispmeet(x ir.Node, y ir.Node) disp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dumpCallSiteComments" data-name="dumpCallSiteComments">
               <h3>
                  dumpCallSiteComments 
                  <span class="badge">function</span>
                  
                  <a href="#dumpCallSiteComments" class="anchor" title="Link to dumpCallSiteComments">#</a>
               </h3>
               
               <p>dumpCallSiteComments emits comments into the dump file for the
callsites in the function of interest. If "ecst" is non-nil, we use
that, otherwise generated a fresh encodedCallSiteTab from "tab".</p>
               
               <pre><code class="language-go">func dumpCallSiteComments(w io.Writer, tab CallSiteTab, ecst encodedCallSiteTab)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dumpFilePreamble" data-name="dumpFilePreamble">
               <h3>
                  dumpFilePreamble 
                  <span class="badge">function</span>
                  
                  <a href="#dumpFilePreamble" class="anchor" title="Link to dumpFilePreamble">#</a>
               </h3>
               
               <p>dumpFilePreamble writes out a file-level preamble for a given
Go function as part of a function properties dump.</p>
               
               <pre><code class="language-go">func dumpFilePreamble(w io.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dumpFnPreamble" data-name="dumpFnPreamble">
               <h3>
                  dumpFnPreamble 
                  <span class="badge">function</span>
                  
                  <a href="#dumpFnPreamble" class="anchor" title="Link to dumpFnPreamble">#</a>
               </h3>
               
               <p>dumpFnPreamble writes out a function-level preamble for a given
Go function as part of a function properties dump. See the
README.txt file in testdata/props for more on the format of
this preamble.</p>
               
               <pre><code class="language-go">func dumpFnPreamble(w io.Writer, funcInlHeur *fnInlHeur, ecst encodedCallSiteTab, idx uint, atl uint) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitDumpToFile" data-name="emitDumpToFile">
               <h3>
                  emitDumpToFile 
                  <span class="badge">function</span>
                  
                  <a href="#emitDumpToFile" class="anchor" title="Link to emitDumpToFile">#</a>
               </h3>
               
               <p>emitDumpToFile writes out the buffer function property dump entries
to a file, for unit testing. Dump entries need to be sorted by
definition line, and due to generics we need to account for the
possibility that several ir.Func's will have the same def line.</p>
               
               <pre><code class="language-go">func emitDumpToFile(dumpfile string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="enableDebugTrace" data-name="enableDebugTrace">
               <h3>
                  enableDebugTrace 
                  <span class="badge">function</span>
                  
                  <a href="#enableDebugTrace" class="anchor" title="Link to enableDebugTrace">#</a>
               </h3>
               
               <pre><code class="language-go">func enableDebugTrace(x int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="enableDebugTrace" data-name="enableDebugTrace">
               <h3>
                  enableDebugTrace 
                  <span class="badge">function</span>
                  
                  <a href="#enableDebugTrace" class="anchor" title="Link to enableDebugTrace">#</a>
               </h3>
               
               <pre><code class="language-go">func enableDebugTrace(x int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="enableDebugTraceIfEnv" data-name="enableDebugTraceIfEnv">
               <h3>
                  enableDebugTraceIfEnv 
                  <span class="badge">function</span>
                  
                  <a href="#enableDebugTraceIfEnv" class="anchor" title="Link to enableDebugTraceIfEnv">#</a>
               </h3>
               
               <pre><code class="language-go">func enableDebugTraceIfEnv()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="enableDebugTraceIfEnv" data-name="enableDebugTraceIfEnv">
               <h3>
                  enableDebugTraceIfEnv 
                  <span class="badge">function</span>
                  
                  <a href="#enableDebugTraceIfEnv" class="anchor" title="Link to enableDebugTraceIfEnv">#</a>
               </h3>
               
               <pre><code class="language-go">func enableDebugTraceIfEnv()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="examineCallResults" data-name="examineCallResults">
               <h3>
                  examineCallResults 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#examineCallResults" class="anchor" title="Link to examineCallResults">#</a>
               </h3>
               
               <pre><code class="language-go">func (csa *callSiteAnalyzer) examineCallResults(cs *CallSite, resultNameTab map[*ir.Name]resultPropAndCS) map[*ir.Name]resultPropAndCS</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findParamIdx" data-name="findParamIdx">
               <h3>
                  findParamIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findParamIdx" class="anchor" title="Link to findParamIdx">#</a>
               </h3>
               
               <pre><code class="language-go">func (pa *paramsAnalyzer) findParamIdx(n *ir.Name) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flagSliceToSB" data-name="flagSliceToSB">
               <h3>
                  flagSliceToSB 
                  <span class="badge">function</span>
                  
                  <a href="#flagSliceToSB" class="anchor" title="Link to flagSliceToSB">#</a>
               </h3>
               
               <pre><code class="language-go">func flagSliceToSB(sb *strings.Builder, sl []T, prefix string, tag string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flagsForNode" data-name="flagsForNode">
               <h3>
                  flagsForNode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flagsForNode" class="anchor" title="Link to flagsForNode">#</a>
               </h3>
               
               <pre><code class="language-go">func (cstb *callSiteTableBuilder) flagsForNode(call *ir.CallExpr) CSPropBits</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtFullPos" data-name="fmtFullPos">
               <h3>
                  fmtFullPos 
                  <span class="badge">function</span>
                  
                  <a href="#fmtFullPos" class="anchor" title="Link to fmtFullPos">#</a>
               </h3>
               
               <pre><code class="language-go">func fmtFullPos(p src.XPos) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fnFileLine" data-name="fnFileLine">
               <h3>
                  fnFileLine 
                  <span class="badge">function</span>
                  
                  <a href="#fnFileLine" class="anchor" title="Link to fnFileLine">#</a>
               </h3>
               
               <pre><code class="language-go">func fnFileLine(fn *ir.Func) (string, uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="foldCheckParams" data-name="foldCheckParams">
               <h3>
                  foldCheckParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#foldCheckParams" class="anchor" title="Link to foldCheckParams">#</a>
               </h3>
               
               <p>foldCheckParams checks expression 'x' (an 'if' condition or
'switch' stmt expr) to see if the expr would fold away if a
specific parameter had a constant value.</p>
               
               <pre><code class="language-go">func (pa *paramsAnalyzer) foldCheckParams(x ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="foldCheckResults" data-name="foldCheckResults">
               <h3>
                  foldCheckResults 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#foldCheckResults" class="anchor" title="Link to foldCheckResults">#</a>
               </h3>
               
               <p>foldCheckResults examines the specified if/switch condition 'cond'
to see if it refers to locals defined by a (potentially inlinable)
function call at call site C, and if so, whether 'cond' contains
only combinations of simple references to all of the names in
'names' with selected constants + operators. If these criteria are
met, then we adjust the score for call site C to reflect the
fact that inlining will enable deadcode and/or constant propagation.
Note: for this heuristic to kick in, the names in question have to
be all from the same callsite. Examples:
q, r := baz()	    x, y := foo()
switch q+r {		a, b, c := bar()
...			    if x && y && a && b && c {
}					   ...
}
For the call to "baz" above we apply a score adjustment, but not
for the calls to "foo" or "bar".</p>
               
               <pre><code class="language-go">func (rua *resultUseAnalyzer) foldCheckResults(cond ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcName" data-name="funcName">
               <h3>
                  funcName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcName" class="anchor" title="Link to funcName">#</a>
               </h3>
               
               <p>funcName returns the *ir.Name for the func or method
corresponding to node 'n', or nil if n can't be proven
to contain a function value.</p>
               
               <pre><code class="language-go">func (nf *nameFinder) funcName(n ir.Node) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getCallResultName" data-name="getCallResultName">
               <h3>
                  getCallResultName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getCallResultName" class="anchor" title="Link to getCallResultName">#</a>
               </h3>
               
               <pre><code class="language-go">func (rua *resultUseAnalyzer) getCallResultName(ce *ir.CallExpr) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getParams" data-name="getParams">
               <h3>
                  getParams 
                  <span class="badge">function</span>
                  
                  <a href="#getParams" class="anchor" title="Link to getParams">#</a>
               </h3>
               
               <p>getParams returns an *ir.Name slice containing all params for the
function (plus rcvr as well if applicable).</p>
               
               <pre><code class="language-go">func getParams(fn *ir.Func) []*ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getState" data-name="getState">
               <h3>
                  getState 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getState" class="anchor" title="Link to getState">#</a>
               </h3>
               
               <pre><code class="language-go">func (ffa *funcFlagsAnalyzer) getState(n ir.Node) pstate</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getdisp" data-name="getdisp">
               <h3>
                  getdisp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getdisp" class="anchor" title="Link to getdisp">#</a>
               </h3>
               
               <pre><code class="language-go">func (ec *exprClassifier) getdisp(x ir.Node) disp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasTopLevelLoopBodyReturnOrBreak" data-name="hasTopLevelLoopBodyReturnOrBreak">
               <h3>
                  hasTopLevelLoopBodyReturnOrBreak 
                  <span class="badge">function</span>
                  
                  <a href="#hasTopLevelLoopBodyReturnOrBreak" class="anchor" title="Link to hasTopLevelLoopBodyReturnOrBreak">#</a>
               </h3>
               
               <p>hasTopLevelLoopBodyReturnOrBreak examines the body of a "for" or
"range" loop to try to verify that it is a real loop, as opposed to
a construct that is syntactically loopy but doesn't actually iterate
multiple times, like:
for {
blah()
return 1
}
[Remark: the pattern above crops up quite a bit in the source code
for the compiler itself, e.g. the auto-generated rewrite code]
Note that we don't look for GOTO statements here, so it's possible
we'll get the wrong result for a loop with complicated control
jumps via gotos.</p>
               
               <pre><code class="language-go">func hasTopLevelLoopBodyReturnOrBreak(loopBody ir.Nodes) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isAllocatedMem" data-name="isAllocatedMem">
               <h3>
                  isAllocatedMem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isAllocatedMem" class="anchor" title="Link to isAllocatedMem">#</a>
               </h3>
               
               <p>isAllocatedMem returns true if node n corresponds to a memory
allocation expression (make, new, or equivalent).</p>
               
               <pre><code class="language-go">func (nf *nameFinder) isAllocatedMem(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isConcreteConvIface" data-name="isConcreteConvIface">
               <h3>
                  isConcreteConvIface 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isConcreteConvIface" class="anchor" title="Link to isConcreteConvIface">#</a>
               </h3>
               
               <pre><code class="language-go">func (nf *nameFinder) isConcreteConvIface(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isExitCall" data-name="isExitCall">
               <h3>
                  isExitCall 
                  <span class="badge">function</span>
                  
                  <a href="#isExitCall" class="anchor" title="Link to isExitCall">#</a>
               </h3>
               
               <p>isExitCall reports TRUE if the node itself is an unconditional
call to os.Exit(), a panic, or a function that does likewise.</p>
               
               <pre><code class="language-go">func isExitCall(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isMainMain" data-name="isMainMain">
               <h3>
                  isMainMain 
                  <span class="badge">function</span>
                  
                  <a href="#isMainMain" class="anchor" title="Link to isMainMain">#</a>
               </h3>
               
               <pre><code class="language-go">func isMainMain(fn *ir.Func) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isMay" data-name="isMay">
               <h3>
                  isMay 
                  <span class="badge">function</span>
                  
                  <a href="#isMay" class="anchor" title="Link to isMay">#</a>
               </h3>
               
               <pre><code class="language-go">func isMay(x scoreAdjustTyp) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isMust" data-name="isMust">
               <h3>
                  isMust 
                  <span class="badge">function</span>
                  
                  <a href="#isMust" class="anchor" title="Link to isMust">#</a>
               </h3>
               
               <pre><code class="language-go">func isMust(x scoreAdjustTyp) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNil" data-name="isNil">
               <h3>
                  isNil 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isNil" class="anchor" title="Link to isNil">#</a>
               </h3>
               
               <p>isNil returns whether n is nil (or singly
assigned local containing nil).</p>
               
               <pre><code class="language-go">func (nf *nameFinder) isNil(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isSameFuncName" data-name="isSameFuncName">
               <h3>
                  isSameFuncName 
                  <span class="badge">function</span>
                  
                  <a href="#isSameFuncName" class="anchor" title="Link to isSameFuncName">#</a>
               </h3>
               
               <pre><code class="language-go">func isSameFuncName(v1 *ir.Name, v2 *ir.Name) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isWellKnownFunc" data-name="isWellKnownFunc">
               <h3>
                  isWellKnownFunc 
                  <span class="badge">function</span>
                  
                  <a href="#isWellKnownFunc" class="anchor" title="Link to isWellKnownFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func isWellKnownFunc(s *types.Sym, pkg string, name string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loopBody" data-name="loopBody">
               <h3>
                  loopBody 
                  <span class="badge">function</span>
                  
                  <a href="#loopBody" class="anchor" title="Link to loopBody">#</a>
               </h3>
               
               <pre><code class="language-go">func loopBody(n ir.Node) ir.Nodes</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeCallSiteAnalyzer" data-name="makeCallSiteAnalyzer">
               <h3>
                  makeCallSiteAnalyzer 
                  <span class="badge">function</span>
                  
                  <a href="#makeCallSiteAnalyzer" class="anchor" title="Link to makeCallSiteAnalyzer">#</a>
               </h3>
               
               <pre><code class="language-go">func makeCallSiteAnalyzer(fn *ir.Func) *callSiteAnalyzer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeCallSiteTableBuilder" data-name="makeCallSiteTableBuilder">
               <h3>
                  makeCallSiteTableBuilder 
                  <span class="badge">function</span>
                  
                  <a href="#makeCallSiteTableBuilder" class="anchor" title="Link to makeCallSiteTableBuilder">#</a>
               </h3>
               
               <pre><code class="language-go">func makeCallSiteTableBuilder(fn *ir.Func, cstab CallSiteTab, ptab map[ir.Node]pstate, loopNestingLevel int, nf *nameFinder) *callSiteTableBuilder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeExprClassifier" data-name="makeExprClassifier">
               <h3>
                  makeExprClassifier 
                  <span class="badge">function</span>
                  
                  <a href="#makeExprClassifier" class="anchor" title="Link to makeExprClassifier">#</a>
               </h3>
               
               <pre><code class="language-go">func makeExprClassifier(names []*ir.Name) *exprClassifier</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeFuncFlagsAnalyzer" data-name="makeFuncFlagsAnalyzer">
               <h3>
                  makeFuncFlagsAnalyzer 
                  <span class="badge">function</span>
                  
                  <a href="#makeFuncFlagsAnalyzer" class="anchor" title="Link to makeFuncFlagsAnalyzer">#</a>
               </h3>
               
               <pre><code class="language-go">func makeFuncFlagsAnalyzer(fn *ir.Func) *funcFlagsAnalyzer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeParamsAnalyzer" data-name="makeParamsAnalyzer">
               <h3>
                  makeParamsAnalyzer 
                  <span class="badge">function</span>
                  
                  <a href="#makeParamsAnalyzer" class="anchor" title="Link to makeParamsAnalyzer">#</a>
               </h3>
               
               <p>makeParamsAnalyzer creates a new helper object to analyze parameters
of function fn. If the function doesn't have any interesting
params, a nil helper is returned along with a set of default param
flags for the func.</p>
               
               <pre><code class="language-go">func makeParamsAnalyzer(fn *ir.Func, nf *nameFinder) (*paramsAnalyzer, []ParamPropBits)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeResultsAnalyzer" data-name="makeResultsAnalyzer">
               <h3>
                  makeResultsAnalyzer 
                  <span class="badge">function</span>
                  
                  <a href="#makeResultsAnalyzer" class="anchor" title="Link to makeResultsAnalyzer">#</a>
               </h3>
               
               <p>makeResultsAnalyzer creates a new helper object to analyze results
in function fn. If the function doesn't have any interesting
results, a nil helper is returned along with a set of default
result flags for the func.</p>
               
               <pre><code class="language-go">func makeResultsAnalyzer(fn *ir.Func, inlineMaxBudget int, nf *nameFinder) (*resultsAnalyzer, []ResultPropBits)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mayToMust" data-name="mayToMust">
               <h3>
                  mayToMust 
                  <span class="badge">function</span>
                  
                  <a href="#mayToMust" class="anchor" title="Link to mayToMust">#</a>
               </h3>
               
               <pre><code class="language-go">func mayToMust(x scoreAdjustTyp) scoreAdjustTyp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="merge" data-name="merge">
               <h3>
                  merge 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#merge" class="anchor" title="Link to merge">#</a>
               </h3>
               
               <pre><code class="language-go">func (cst CallSiteTab) merge(other CallSiteTab) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustToMay" data-name="mustToMay">
               <h3>
                  mustToMay 
                  <span class="badge">function</span>
                  
                  <a href="#mustToMay" class="anchor" title="Link to mustToMay">#</a>
               </h3>
               
               <pre><code class="language-go">func mustToMay(x scoreAdjustTyp) scoreAdjustTyp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="namesDefined" data-name="namesDefined">
               <h3>
                  namesDefined 
                  <span class="badge">function</span>
                  
                  <a href="#namesDefined" class="anchor" title="Link to namesDefined">#</a>
               </h3>
               
               <p>namesDefined returns a list of ir.Name's corresponding to locals
that receive the results from the call at site 'cs', plus the
properties object for the called function. If a given result
isn't cleanly assigned to a newly defined local, the
slot for that result in the returned list will be nil. Example:
call                             returned name list
x := foo()                       [ x ]
z, y := bar()                    [ nil, nil ]
_, q := baz()                    [ nil, q ]
In the case of a multi-return call, such as "x, y := foo()",
the pattern we see from the front end will be a call op
assigning to auto-temps, and then an assignment of the auto-temps
to the user-level variables. In such cases we return
first the user-level variable (in the first func result)
and then the auto-temp name in the second result.</p>
               
               <pre><code class="language-go">func namesDefined(cs *CallSite) ([]*ir.Name, []*ir.Name, *FuncProps)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newNameFinder" data-name="newNameFinder">
               <h3>
                  newNameFinder 
                  <span class="badge">function</span>
                  
                  <a href="#newNameFinder" class="anchor" title="Link to newNameFinder">#</a>
               </h3>
               
               <p>newNameFinder returns a new nameFinder object with a reassignment
oracle initialized based on the function fn, or if fn is nil,
without an underlying ReassignOracle.</p>
               
               <pre><code class="language-go">func newNameFinder(fn *ir.Func) *nameFinder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nodeVisitPost" data-name="nodeVisitPost">
               <h3>
                  nodeVisitPost 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nodeVisitPost" class="anchor" title="Link to nodeVisitPost">#</a>
               </h3>
               
               <pre><code class="language-go">func (ra *resultsAnalyzer) nodeVisitPost(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nodeVisitPost" data-name="nodeVisitPost">
               <h3>
                  nodeVisitPost 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nodeVisitPost" class="anchor" title="Link to nodeVisitPost">#</a>
               </h3>
               
               <p>nodeVisitPost helps implement the propAnalyzer interface; when
called on a given node, it decides the disposition of that node
based on the state(s) of the node's children.</p>
               
               <pre><code class="language-go">func (ffa *funcFlagsAnalyzer) nodeVisitPost(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nodeVisitPost" data-name="nodeVisitPost">
               <h3>
                  nodeVisitPost 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nodeVisitPost" class="anchor" title="Link to nodeVisitPost">#</a>
               </h3>
               
               <pre><code class="language-go">func (rua *resultUseAnalyzer) nodeVisitPost(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nodeVisitPost" data-name="nodeVisitPost">
               <h3>
                  nodeVisitPost 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nodeVisitPost" class="anchor" title="Link to nodeVisitPost">#</a>
               </h3>
               
               <pre><code class="language-go">func (cstb *callSiteTableBuilder) nodeVisitPost(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nodeVisitPost" data-name="nodeVisitPost">
               <h3>
                  nodeVisitPost 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nodeVisitPost" class="anchor" title="Link to nodeVisitPost">#</a>
               </h3>
               
               <pre><code class="language-go">func (pa *paramsAnalyzer) nodeVisitPost(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nodeVisitPre" data-name="nodeVisitPre">
               <h3>
                  nodeVisitPre 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nodeVisitPre" class="anchor" title="Link to nodeVisitPre">#</a>
               </h3>
               
               <pre><code class="language-go">func (pa *paramsAnalyzer) nodeVisitPre(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nodeVisitPre" data-name="nodeVisitPre">
               <h3>
                  nodeVisitPre 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nodeVisitPre" class="anchor" title="Link to nodeVisitPre">#</a>
               </h3>
               
               <pre><code class="language-go">func (ra *resultsAnalyzer) nodeVisitPre(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nodeVisitPre" data-name="nodeVisitPre">
               <h3>
                  nodeVisitPre 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nodeVisitPre" class="anchor" title="Link to nodeVisitPre">#</a>
               </h3>
               
               <pre><code class="language-go">func (ffa *funcFlagsAnalyzer) nodeVisitPre(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nodeVisitPre" data-name="nodeVisitPre">
               <h3>
                  nodeVisitPre 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nodeVisitPre" class="anchor" title="Link to nodeVisitPre">#</a>
               </h3>
               
               <pre><code class="language-go">func (rua *resultUseAnalyzer) nodeVisitPre(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nodeVisitPre" data-name="nodeVisitPre">
               <h3>
                  nodeVisitPre 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nodeVisitPre" class="anchor" title="Link to nodeVisitPre">#</a>
               </h3>
               
               <pre><code class="language-go">func (cstb *callSiteTableBuilder) nodeVisitPre(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="panicPathTable" data-name="panicPathTable">
               <h3>
                  panicPathTable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#panicPathTable" class="anchor" title="Link to panicPathTable">#</a>
               </h3>
               
               <pre><code class="language-go">func (ffa *funcFlagsAnalyzer) panicPathTable() map[ir.Node]pstate</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseScoreAdj" data-name="parseScoreAdj">
               <h3>
                  parseScoreAdj 
                  <span class="badge">function</span>
                  
                  <a href="#parseScoreAdj" class="anchor" title="Link to parseScoreAdj">#</a>
               </h3>
               
               <pre><code class="language-go">func parseScoreAdj(val string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pessimize" data-name="pessimize">
               <h3>
                  pessimize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pessimize" class="anchor" title="Link to pessimize">#</a>
               </h3>
               
               <p>pessimize is called to record the fact that we saw something in the
function that renders it entirely impossible to analyze.</p>
               
               <pre><code class="language-go">func (ffa *funcFlagsAnalyzer) pessimize()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pessimize" data-name="pessimize">
               <h3>
                  pessimize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pessimize" class="anchor" title="Link to pessimize">#</a>
               </h3>
               
               <pre><code class="language-go">func (ra *resultsAnalyzer) pessimize()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="post" data-name="post">
               <h3>
                  post 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#post" class="anchor" title="Link to post">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *condLevelTracker) post(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pre" data-name="pre">
               <h3>
                  pre 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pre" class="anchor" title="Link to pre">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *condLevelTracker) pre(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="propsForArg" data-name="propsForArg">
               <h3>
                  propsForArg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#propsForArg" class="anchor" title="Link to propsForArg">#</a>
               </h3>
               
               <p>propsForArg returns property bits for a given call argument expression arg.</p>
               
               <pre><code class="language-go">func (cstb *callSiteTableBuilder) propsForArg(arg ir.Node) ActualExprPropBits</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="propsForFunc" data-name="propsForFunc">
               <h3>
                  propsForFunc 
                  <span class="badge">function</span>
                  
                  <a href="#propsForFunc" class="anchor" title="Link to propsForFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func propsForFunc(fn *ir.Func) *FuncProps</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readULEB128" data-name="readULEB128">
               <h3>
                  readULEB128 
                  <span class="badge">function</span>
                  
                  <a href="#readULEB128" class="anchor" title="Link to readULEB128">#</a>
               </h3>
               
               <pre><code class="language-go">func readULEB128(sl []byte) (value uint64, rsl []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reassigned" data-name="reassigned">
               <h3>
                  reassigned 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reassigned" class="anchor" title="Link to reassigned">#</a>
               </h3>
               
               <pre><code class="language-go">func (nf *nameFinder) reassigned(n *ir.Name) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rescoreBasedOnCallResultUses" data-name="rescoreBasedOnCallResultUses">
               <h3>
                  rescoreBasedOnCallResultUses 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rescoreBasedOnCallResultUses" class="anchor" title="Link to rescoreBasedOnCallResultUses">#</a>
               </h3>
               
               <p>rescoreBasedOnCallResultUses examines how call results are used,
and tries to update the scores of calls based on how their results
are used in the function.</p>
               
               <pre><code class="language-go">func (csa *callSiteAnalyzer) rescoreBasedOnCallResultUses(fn *ir.Func, resultNameTab map[*ir.Name]resultPropAndCS, cstab CallSiteTab)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="returnHasProp" data-name="returnHasProp">
               <h3>
                  returnHasProp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#returnHasProp" class="anchor" title="Link to returnHasProp">#</a>
               </h3>
               
               <pre><code class="language-go">func (rua *resultUseAnalyzer) returnHasProp(name *ir.Name, prop ResultPropBits) *CallSite</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="revisitInlinability" data-name="revisitInlinability">
               <h3>
                  revisitInlinability 
                  <span class="badge">function</span>
                  
                  <a href="#revisitInlinability" class="anchor" title="Link to revisitInlinability">#</a>
               </h3>
               
               <p>revisitInlinability revisits the question of whether to continue to
treat function 'fn' as an inline candidate based on the set of
properties we've computed for it. If (for example) it has an
initial size score of 150 and no interesting properties to speak
of, then there isn't really any point to moving ahead with it as an
inline candidate.</p>
               
               <pre><code class="language-go">func revisitInlinability(fn *ir.Func, funcProps *FuncProps, budgetForFunc func(*ir.Func) int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runAnalyzersOnFunction" data-name="runAnalyzersOnFunction">
               <h3>
                  runAnalyzersOnFunction 
                  <span class="badge">function</span>
                  
                  <a href="#runAnalyzersOnFunction" class="anchor" title="Link to runAnalyzersOnFunction">#</a>
               </h3>
               
               <pre><code class="language-go">func runAnalyzersOnFunction(fn *ir.Func, analyzers []propAnalyzer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scoreCallsRegion" data-name="scoreCallsRegion">
               <h3>
                  scoreCallsRegion 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scoreCallsRegion" class="anchor" title="Link to scoreCallsRegion">#</a>
               </h3>
               
               <p>scoreCallsRegion assigns numeric scores to each of the callsites in
region 'region' within function 'fn'. This can be called on
an entire function, or with 'region' set to a chunk of
code corresponding to an inlined call.</p>
               
               <pre><code class="language-go">func (csa *callSiteAnalyzer) scoreCallsRegion(fn *ir.Func, region ir.Nodes, cstab CallSiteTab, doCallResults bool, ic *ir.InlinedCallExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setResults" data-name="setResults">
               <h3>
                  setResults 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setResults" class="anchor" title="Link to setResults">#</a>
               </h3>
               
               <pre><code class="language-go">func (pa *paramsAnalyzer) setResults(funcProps *FuncProps)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setResults" data-name="setResults">
               <h3>
                  setResults 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setResults" class="anchor" title="Link to setResults">#</a>
               </h3>
               
               <p>setResults transfers func flag results to 'funcProps'.</p>
               
               <pre><code class="language-go">func (ffa *funcFlagsAnalyzer) setResults(funcProps *FuncProps)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setResults" data-name="setResults">
               <h3>
                  setResults 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setResults" class="anchor" title="Link to setResults">#</a>
               </h3>
               
               <p>setResults transfers the calculated result properties for this
function to 'funcProps'.</p>
               
               <pre><code class="language-go">func (ra *resultsAnalyzer) setResults(funcProps *FuncProps)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setState" data-name="setState">
               <h3>
                  setState 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setState" class="anchor" title="Link to setState">#</a>
               </h3>
               
               <pre><code class="language-go">func (ffa *funcFlagsAnalyzer) setState(n ir.Node, st pstate)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setupFlagToAdjMaps" data-name="setupFlagToAdjMaps">
               <h3>
                  setupFlagToAdjMaps 
                  <span class="badge">function</span>
                  
                  <a href="#setupFlagToAdjMaps" class="anchor" title="Link to setupFlagToAdjMaps">#</a>
               </h3>
               
               <pre><code class="language-go">func setupFlagToAdjMaps()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldVisit" data-name="shouldVisit">
               <h3>
                  shouldVisit 
                  <span class="badge">function</span>
                  
                  <a href="#shouldVisit" class="anchor" title="Link to shouldVisit">#</a>
               </h3>
               
               <p>shouldVisit reports TRUE if this is an interesting node from the
perspective of computing function flags. NB: due to the fact that
ir.CallExpr implements the Stmt interface, we wind up visiting
a lot of nodes that we don't really need to, but these can
simply be screened out as part of the visit.</p>
               
               <pre><code class="language-go">func shouldVisit(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sortFnInlHeurSlice" data-name="sortFnInlHeurSlice">
               <h3>
                  sortFnInlHeurSlice 
                  <span class="badge">function</span>
                  
                  <a href="#sortFnInlHeurSlice" class="anchor" title="Link to sortFnInlHeurSlice">#</a>
               </h3>
               
               <p>sortFnInlHeurSlice sorts a slice of fnInlHeur based on
the starting line of the function definition, then by name.</p>
               
               <pre><code class="language-go">func sortFnInlHeurSlice(sl []fnInlHeur) []fnInlHeur</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stateForList" data-name="stateForList">
               <h3>
                  stateForList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stateForList" class="anchor" title="Link to stateForList">#</a>
               </h3>
               
               <p>stateForList walks through a list of statements and computes the
state/disposition for the entire list as a whole, as well
as updating disposition of intermediate nodes.</p>
               
               <pre><code class="language-go">func (ffa *funcFlagsAnalyzer) stateForList(list ir.Nodes) pstate</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staticValue" data-name="staticValue">
               <h3>
                  staticValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staticValue" class="anchor" title="Link to staticValue">#</a>
               </h3>
               
               <pre><code class="language-go">func (nf *nameFinder) staticValue(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateState" data-name="updateState">
               <h3>
                  updateState 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#updateState" class="anchor" title="Link to updateState">#</a>
               </h3>
               
               <pre><code class="language-go">func (ffa *funcFlagsAnalyzer) updateState(n ir.Node, st pstate)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeUleb128" data-name="writeUleb128">
               <h3>
                  writeUleb128 
                  <span class="badge">function</span>
                  
                  <a href="#writeUleb128" class="anchor" title="Link to writeUleb128">#</a>
               </h3>
               
               <pre><code class="language-go">func writeUleb128(sb *strings.Builder, v uint64)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();

               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);

               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;

               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               // Apply Prism highlighting again
               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>