<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - inlheur</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="cmd_compile_internal_inline_inlheur_testdata-docs.html">testdata</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>inlheur</code>
         </h1>
         <hr />
         
         <article class="global" data-name="pos">
            <h2>pos</h2>
            <hr />
            
            <pre><code>pos src.XPos</code></pre>
         </article>
         
         <article class="global" data-name="local">
            <h2>local</h2>
            <hr />
            
            <pre><code>local *types.Pkg</code></pre>
         </article>
         
         <article class="global" data-name="f">
            <h2>f</h2>
            <hr />
            
            <pre><code>f *ir.Func</code></pre>
         </article>
         
         <article class="global" data-name="_ActualExprPropBits_value">
            <h2>_ActualExprPropBits_value</h2>
            <hr />
            
            <pre><code>_ActualExprPropBits_value</code></pre>
         </article>
         
         <article class="global" data-name="_ActualExprPropBits_name">
            <h2>_ActualExprPropBits_name</h2>
            <hr />
            
            <pre><code>_ActualExprPropBits_name</code></pre>
         </article>
         
         <article class="global" data-name="_ActualExprPropBits_index">
            <h2>_ActualExprPropBits_index</h2>
            <hr />
            
            <pre><code>_ActualExprPropBits_index</code></pre>
         </article>
         
         <article class="global" data-name="exprNoInfo">
            <h2>exprNoInfo</h2>
            <hr />
            
            <p>no info on this expr</p>
            
            <pre><code>exprNoInfo disp</code></pre>
         </article>
         
         <article class="global" data-name="exprLiterals">
            <h2>exprLiterals</h2>
            <hr />
            
            <p>expr contains only literals</p>
            
            <pre><code>exprLiterals</code></pre>
         </article>
         
         <article class="global" data-name="exprSimple">
            <h2>exprSimple</h2>
            <hr />
            
            <p>expr is legal combination of literals and specified names</p>
            
            <pre><code>exprSimple</code></pre>
         </article>
         
         <article class="global" data-name="remasterflag">
            <h2>remasterflag</h2>
            <hr />
            
            <pre><code>remasterflag</code></pre>
         </article>
         
         <article class="global" data-name="debugTrace">
            <h2>debugTrace</h2>
            <hr />
            
            <pre><code>debugTrace</code></pre>
         </article>
         
         <article class="global" data-name="psNoInfo">
            <h2>psNoInfo</h2>
            <hr />
            
            <pre><code>psNoInfo pstate</code></pre>
         </article>
         
         <article class="global" data-name="psCallsPanic">
            <h2>psCallsPanic</h2>
            <hr />
            
            <pre><code>psCallsPanic</code></pre>
         </article>
         
         <article class="global" data-name="psMayReturn">
            <h2>psMayReturn</h2>
            <hr />
            
            <pre><code>psMayReturn</code></pre>
         </article>
         
         <article class="global" data-name="psTop">
            <h2>psTop</h2>
            <hr />
            
            <pre><code>psTop</code></pre>
         </article>
         
         <article class="global" data-name="_ResultPropBits_value">
            <h2>_ResultPropBits_value</h2>
            <hr />
            
            <pre><code>_ResultPropBits_value</code></pre>
         </article>
         
         <article class="global" data-name="_ResultPropBits_name">
            <h2>_ResultPropBits_name</h2>
            <hr />
            
            <pre><code>_ResultPropBits_name</code></pre>
         </article>
         
         <article class="global" data-name="_ResultPropBits_index">
            <h2>_ResultPropBits_index</h2>
            <hr />
            
            <pre><code>_ResultPropBits_index</code></pre>
         </article>
         
         <article class="global" data-name="_scoreAdjustTyp_value">
            <h2>_scoreAdjustTyp_value</h2>
            <hr />
            
            <pre><code>_scoreAdjustTyp_value</code></pre>
         </article>
         
         <article class="global" data-name="_scoreAdjustTyp_name">
            <h2>_scoreAdjustTyp_name</h2>
            <hr />
            
            <pre><code>_scoreAdjustTyp_name</code></pre>
         </article>
         
         <article class="global" data-name="_scoreAdjustTyp_index">
            <h2>_scoreAdjustTyp_index</h2>
            <hr />
            
            <pre><code>_scoreAdjustTyp_index</code></pre>
         </article>
         
         <article class="global" data-name="panicPathAdj">
            <h2>panicPathAdj</h2>
            <hr />
            
            <p>Category 1 adjustments (see above)</p>
            
            <pre><code>panicPathAdj scoreAdjustTyp</code></pre>
         </article>
         
         <article class="global" data-name="initFuncAdj">
            <h2>initFuncAdj</h2>
            <hr />
            
            <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:

1) adjustments based solely on the callsite context (ex: call
appears on panic path)

2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)

3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)

For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
            
            <pre><code>initFuncAdj</code></pre>
         </article>
         
         <article class="global" data-name="inLoopAdj">
            <h2>inLoopAdj</h2>
            <hr />
            
            <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:

1) adjustments based solely on the callsite context (ex: call
appears on panic path)

2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)

3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)

For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
            
            <pre><code>inLoopAdj</code></pre>
         </article>
         
         <article class="global" data-name="passConstToIfAdj">
            <h2>passConstToIfAdj</h2>
            <hr />
            
            <p>Category 2 adjustments (see above).</p>
            
            <pre><code>passConstToIfAdj</code></pre>
         </article>
         
         <article class="global" data-name="passConstToNestedIfAdj">
            <h2>passConstToNestedIfAdj</h2>
            <hr />
            
            <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:

1) adjustments based solely on the callsite context (ex: call
appears on panic path)

2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)

3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)

For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
            
            <pre><code>passConstToNestedIfAdj</code></pre>
         </article>
         
         <article class="global" data-name="passConcreteToItfCallAdj">
            <h2>passConcreteToItfCallAdj</h2>
            <hr />
            
            <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:

1) adjustments based solely on the callsite context (ex: call
appears on panic path)

2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)

3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)

For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
            
            <pre><code>passConcreteToItfCallAdj</code></pre>
         </article>
         
         <article class="global" data-name="passConcreteToNestedItfCallAdj">
            <h2>passConcreteToNestedItfCallAdj</h2>
            <hr />
            
            <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:

1) adjustments based solely on the callsite context (ex: call
appears on panic path)

2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)

3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)

For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
            
            <pre><code>passConcreteToNestedItfCallAdj</code></pre>
         </article>
         
         <article class="global" data-name="passFuncToIndCallAdj">
            <h2>passFuncToIndCallAdj</h2>
            <hr />
            
            <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:

1) adjustments based solely on the callsite context (ex: call
appears on panic path)

2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)

3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)

For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
            
            <pre><code>passFuncToIndCallAdj</code></pre>
         </article>
         
         <article class="global" data-name="passFuncToNestedIndCallAdj">
            <h2>passFuncToNestedIndCallAdj</h2>
            <hr />
            
            <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:

1) adjustments based solely on the callsite context (ex: call
appears on panic path)

2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)

3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)

For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
            
            <pre><code>passFuncToNestedIndCallAdj</code></pre>
         </article>
         
         <article class="global" data-name="passInlinableFuncToIndCallAdj">
            <h2>passInlinableFuncToIndCallAdj</h2>
            <hr />
            
            <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:

1) adjustments based solely on the callsite context (ex: call
appears on panic path)

2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)

3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)

For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
            
            <pre><code>passInlinableFuncToIndCallAdj</code></pre>
         </article>
         
         <article class="global" data-name="passInlinableFuncToNestedIndCallAdj">
            <h2>passInlinableFuncToNestedIndCallAdj</h2>
            <hr />
            
            <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:

1) adjustments based solely on the callsite context (ex: call
appears on panic path)

2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)

3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)

For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
            
            <pre><code>passInlinableFuncToNestedIndCallAdj</code></pre>
         </article>
         
         <article class="global" data-name="returnFeedsConstToIfAdj">
            <h2>returnFeedsConstToIfAdj</h2>
            <hr />
            
            <p>Category 3 adjustments.</p>
            
            <pre><code>returnFeedsConstToIfAdj</code></pre>
         </article>
         
         <article class="global" data-name="returnFeedsFuncToIndCallAdj">
            <h2>returnFeedsFuncToIndCallAdj</h2>
            <hr />
            
            <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:

1) adjustments based solely on the callsite context (ex: call
appears on panic path)

2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)

3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)

For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
            
            <pre><code>returnFeedsFuncToIndCallAdj</code></pre>
         </article>
         
         <article class="global" data-name="returnFeedsInlinableFuncToIndCallAdj">
            <h2>returnFeedsInlinableFuncToIndCallAdj</h2>
            <hr />
            
            <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:

1) adjustments based solely on the callsite context (ex: call
appears on panic path)

2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)

3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)

For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
            
            <pre><code>returnFeedsInlinableFuncToIndCallAdj</code></pre>
         </article>
         
         <article class="global" data-name="returnFeedsConcreteToInterfaceCallAdj">
            <h2>returnFeedsConcreteToInterfaceCallAdj</h2>
            <hr />
            
            <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:

1) adjustments based solely on the callsite context (ex: call
appears on panic path)

2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)

3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)

For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
            
            <pre><code>returnFeedsConcreteToInterfaceCallAdj</code></pre>
         </article>
         
         <article class="global" data-name="sentinelScoreAdj">
            <h2>sentinelScoreAdj</h2>
            <hr />
            
            <p>These constants capture the various ways in which the inliner's
scoring phase can adjust a callsite score based on heuristics. They
fall broadly into three categories:

1) adjustments based solely on the callsite context (ex: call
appears on panic path)

2) adjustments that take into account specific interesting values
passed at a call site (ex: passing a constant that could result in
cprop/deadcode in the caller)

3) adjustments that take into account values returned from the call
at a callsite (ex: call always returns the same inlinable function,
and return value flows unmodified into an indirect call)

For categories 2 and 3 above, each adjustment can have either a
"must" version and a "may" version (but not both). Here the idea is
that in the "must" version the value flow is unconditional: if the
callsite executes, then the condition we're interested in (ex:
param feeding call) is guaranteed to happen. For the "may" version,
there may be control flow that could cause the benefit to be
bypassed.</p>
            
            <pre><code>sentinelScoreAdj</code></pre>
         </article>
         
         <article class="global" data-name="adjValues">
            <h2>adjValues</h2>
            <hr />
            
            <pre><code>adjValues</code></pre>
         </article>
         
         <article class="global" data-name="mayMustAdj">
            <h2>mayMustAdj</h2>
            <hr />
            
            <pre><code>mayMustAdj</code></pre>
         </article>
         
         <article class="global" data-name="resultFlagToPositiveAdj">
            <h2>resultFlagToPositiveAdj</h2>
            <hr />
            
            <pre><code>resultFlagToPositiveAdj *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="paramFlagToPositiveAdj">
            <h2>paramFlagToPositiveAdj</h2>
            <hr />
            
            <pre><code>paramFlagToPositiveAdj *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="callSiteTab">
            <h2>callSiteTab</h2>
            <hr />
            
            <p>callSiteTab contains entries for each call in the function
currently being processed by InlineCalls; this variable will either
be set to 'cstabCache' below (for non-inlinable routines) or to the
local 'cstab' entry in the fnInlHeur object for inlinable routines.

NOTE: this assumes that inlining operations are happening in a serial,
single-threaded fashion,f which is true today but probably won't hold
in the future (for example, we might want to score the callsites
in multiple functions in parallel); if the inliner evolves in this
direction we'll need to come up with a different approach here.</p>
            
            <pre><code>callSiteTab CallSiteTab</code></pre>
         </article>
         
         <article class="global" data-name="scoreCallsCache">
            <h2>scoreCallsCache</h2>
            <hr />
            
            <p>scoreCallsCache caches a call site table and call site list between
invocations of ScoreCalls so that we can reuse previously allocated
storage.</p>
            
            <pre><code>scoreCallsCache scoreCallsCacheType</code></pre>
         </article>
         
         <article class="global" data-name="allCallSites">
            <h2>allCallSites</h2>
            <hr />
            
            <pre><code>allCallSites CallSiteTab</code></pre>
         </article>
         
         <article class="global" data-name="debugTraceFuncs">
            <h2>debugTraceFuncs</h2>
            <hr />
            
            <pre><code>debugTraceFuncs</code></pre>
         </article>
         
         <article class="global" data-name="debugTraceFuncFlags">
            <h2>debugTraceFuncFlags</h2>
            <hr />
            
            <pre><code>debugTraceFuncFlags</code></pre>
         </article>
         
         <article class="global" data-name="debugTraceResults">
            <h2>debugTraceResults</h2>
            <hr />
            
            <pre><code>debugTraceResults</code></pre>
         </article>
         
         <article class="global" data-name="debugTraceParams">
            <h2>debugTraceParams</h2>
            <hr />
            
            <pre><code>debugTraceParams</code></pre>
         </article>
         
         <article class="global" data-name="debugTraceExprClassify">
            <h2>debugTraceExprClassify</h2>
            <hr />
            
            <pre><code>debugTraceExprClassify</code></pre>
         </article>
         
         <article class="global" data-name="debugTraceCalls">
            <h2>debugTraceCalls</h2>
            <hr />
            
            <pre><code>debugTraceCalls</code></pre>
         </article>
         
         <article class="global" data-name="debugTraceScoring">
            <h2>debugTraceScoring</h2>
            <hr />
            
            <pre><code>debugTraceScoring</code></pre>
         </article>
         
         <article class="global" data-name="fpmap">
            <h2>fpmap</h2>
            <hr />
            
            <pre><code>fpmap</code></pre>
         </article>
         
         <article class="global" data-name="preambleDelimiter">
            <h2>preambleDelimiter</h2>
            <hr />
            
            <p>delimiters written to various preambles to make parsing of
dumps easier.</p>
            
            <pre><code>preambleDelimiter</code></pre>
         </article>
         
         <article class="global" data-name="fnDelimiter">
            <h2>fnDelimiter</h2>
            <hr />
            
            <pre><code>fnDelimiter</code></pre>
         </article>
         
         <article class="global" data-name="comDelimiter">
            <h2>comDelimiter</h2>
            <hr />
            
            <pre><code>comDelimiter</code></pre>
         </article>
         
         <article class="global" data-name="csDelimiter">
            <h2>csDelimiter</h2>
            <hr />
            
            <pre><code>csDelimiter</code></pre>
         </article>
         
         <article class="global" data-name="dumpBuffer">
            <h2>dumpBuffer</h2>
            <hr />
            
            <p>dumpBuffer stores up function properties dumps when
"-d=dumpinlfuncprops=..." is in effect.</p>
            
            <pre><code>dumpBuffer *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="_FuncPropBits_value">
            <h2>_FuncPropBits_value</h2>
            <hr />
            
            <pre><code>_FuncPropBits_value</code></pre>
         </article>
         
         <article class="global" data-name="_FuncPropBits_name">
            <h2>_FuncPropBits_name</h2>
            <hr />
            
            <pre><code>_FuncPropBits_name</code></pre>
         </article>
         
         <article class="global" data-name="_FuncPropBits_index">
            <h2>_FuncPropBits_index</h2>
            <hr />
            
            <pre><code>_FuncPropBits_index</code></pre>
         </article>
         
         <article class="global" data-name="FuncPropNeverReturns">
            <h2>FuncPropNeverReturns</h2>
            <hr />
            
            <p>Function always panics or invokes os.Exit() or a func that does
likewise.</p>
            
            <pre><code>FuncPropNeverReturns FuncPropBits</code></pre>
         </article>
         
         <article class="global" data-name="ParamNoInfo">
            <h2>ParamNoInfo</h2>
            <hr />
            
            <p>No info about this param</p>
            
            <pre><code>ParamNoInfo ParamPropBits</code></pre>
         </article>
         
         <article class="global" data-name="ParamFeedsInterfaceMethodCall">
            <h2>ParamFeedsInterfaceMethodCall</h2>
            <hr />
            
            <p>Parameter value feeds unmodified into a top-level interface
call (this assumes the parameter is of interface type).</p>
            
            <pre><code>ParamFeedsInterfaceMethodCall ParamPropBits</code></pre>
         </article>
         
         <article class="global" data-name="ParamMayFeedInterfaceMethodCall">
            <h2>ParamMayFeedInterfaceMethodCall</h2>
            <hr />
            
            <p>Parameter value feeds unmodified into an interface call that
may be conditional/nested and not always executed (this assumes
the parameter is of interface type).</p>
            
            <pre><code>ParamMayFeedInterfaceMethodCall ParamPropBits</code></pre>
         </article>
         
         <article class="global" data-name="ParamFeedsIndirectCall">
            <h2>ParamFeedsIndirectCall</h2>
            <hr />
            
            <p>Parameter value feeds unmodified into a top level indirect
function call (assumes parameter is of function type).</p>
            
            <pre><code>ParamFeedsIndirectCall</code></pre>
         </article>
         
         <article class="global" data-name="ParamMayFeedIndirectCall">
            <h2>ParamMayFeedIndirectCall</h2>
            <hr />
            
            <p>Parameter value feeds unmodified into an indirect function call
that is conditional/nested (not guaranteed to execute). Assumes
parameter is of function type.</p>
            
            <pre><code>ParamMayFeedIndirectCall</code></pre>
         </article>
         
         <article class="global" data-name="ParamFeedsIfOrSwitch">
            <h2>ParamFeedsIfOrSwitch</h2>
            <hr />
            
            <p>Parameter value feeds unmodified into a top level "switch"
statement or "if" statement simple expressions (see more on
"simple" expression classification below).</p>
            
            <pre><code>ParamFeedsIfOrSwitch</code></pre>
         </article>
         
         <article class="global" data-name="ParamMayFeedIfOrSwitch">
            <h2>ParamMayFeedIfOrSwitch</h2>
            <hr />
            
            <p>Parameter value feeds unmodified into a "switch" or "if"
statement simple expressions (see more on "simple" expression
classification below), where the if/switch is
conditional/nested.</p>
            
            <pre><code>ParamMayFeedIfOrSwitch</code></pre>
         </article>
         
         <article class="global" data-name="ResultNoInfo">
            <h2>ResultNoInfo</h2>
            <hr />
            
            <p>No info about this result</p>
            
            <pre><code>ResultNoInfo ResultPropBits</code></pre>
         </article>
         
         <article class="global" data-name="ResultIsAllocatedMem">
            <h2>ResultIsAllocatedMem</h2>
            <hr />
            
            <p>This result always contains allocated memory.</p>
            
            <pre><code>ResultIsAllocatedMem ResultPropBits</code></pre>
         </article>
         
         <article class="global" data-name="ResultIsConcreteTypeConvertedToInterface">
            <h2>ResultIsConcreteTypeConvertedToInterface</h2>
            <hr />
            
            <p>This result is always a single concrete type that is
implicitly converted to interface.</p>
            
            <pre><code>ResultIsConcreteTypeConvertedToInterface</code></pre>
         </article>
         
         <article class="global" data-name="ResultAlwaysSameConstant">
            <h2>ResultAlwaysSameConstant</h2>
            <hr />
            
            <p>Result is always the same non-composite compile time constant.</p>
            
            <pre><code>ResultAlwaysSameConstant</code></pre>
         </article>
         
         <article class="global" data-name="ResultAlwaysSameFunc">
            <h2>ResultAlwaysSameFunc</h2>
            <hr />
            
            <p>Result is always the same function or closure.</p>
            
            <pre><code>ResultAlwaysSameFunc</code></pre>
         </article>
         
         <article class="global" data-name="ResultAlwaysSameInlinableFunc">
            <h2>ResultAlwaysSameInlinableFunc</h2>
            <hr />
            
            <p>Result is always the same (potentially) inlinable function or closure.</p>
            
            <pre><code>ResultAlwaysSameInlinableFunc</code></pre>
         </article>
         
         <article class="global" data-name="_ParamPropBits_value">
            <h2>_ParamPropBits_value</h2>
            <hr />
            
            <pre><code>_ParamPropBits_value</code></pre>
         </article>
         
         <article class="global" data-name="_ParamPropBits_name">
            <h2>_ParamPropBits_name</h2>
            <hr />
            
            <pre><code>_ParamPropBits_name</code></pre>
         </article>
         
         <article class="global" data-name="_ParamPropBits_index">
            <h2>_ParamPropBits_index</h2>
            <hr />
            
            <pre><code>_ParamPropBits_index</code></pre>
         </article>
         
         <article class="global" data-name="_pstate_name">
            <h2>_pstate_name</h2>
            <hr />
            
            <pre><code>_pstate_name</code></pre>
         </article>
         
         <article class="global" data-name="_pstate_index">
            <h2>_pstate_index</h2>
            <hr />
            
            <pre><code>_pstate_index</code></pre>
         </article>
         
         <article class="global" data-name="debugTrace">
            <h2>debugTrace</h2>
            <hr />
            
            <pre><code>debugTrace</code></pre>
         </article>
         
         <article class="global" data-name="ActualExprConstant">
            <h2>ActualExprConstant</h2>
            <hr />
            
            <pre><code>ActualExprConstant ActualExprPropBits</code></pre>
         </article>
         
         <article class="global" data-name="ActualExprIsConcreteConvIface">
            <h2>ActualExprIsConcreteConvIface</h2>
            <hr />
            
            <pre><code>ActualExprIsConcreteConvIface</code></pre>
         </article>
         
         <article class="global" data-name="ActualExprIsFunc">
            <h2>ActualExprIsFunc</h2>
            <hr />
            
            <pre><code>ActualExprIsFunc</code></pre>
         </article>
         
         <article class="global" data-name="ActualExprIsInlinableFunc">
            <h2>ActualExprIsInlinableFunc</h2>
            <hr />
            
            <pre><code>ActualExprIsInlinableFunc</code></pre>
         </article>
         
         <article class="global" data-name="CallSiteInLoop">
            <h2>CallSiteInLoop</h2>
            <hr />
            
            <pre><code>CallSiteInLoop CSPropBits</code></pre>
         </article>
         
         <article class="global" data-name="CallSiteOnPanicPath">
            <h2>CallSiteOnPanicPath</h2>
            <hr />
            
            <pre><code>CallSiteOnPanicPath</code></pre>
         </article>
         
         <article class="global" data-name="CallSiteInInitFunc">
            <h2>CallSiteInInitFunc</h2>
            <hr />
            
            <pre><code>CallSiteInInitFunc</code></pre>
         </article>
         
         <article class="global" data-name="csAuxInlined">
            <h2>csAuxInlined</h2>
            <hr />
            
            <pre><code>csAuxInlined</code></pre>
         </article>
         
         <article class="global" data-name="_CSPropBits_value">
            <h2>_CSPropBits_value</h2>
            <hr />
            
            <pre><code>_CSPropBits_value</code></pre>
         </article>
         
         <article class="global" data-name="_CSPropBits_name">
            <h2>_CSPropBits_name</h2>
            <hr />
            
            <pre><code>_CSPropBits_name</code></pre>
         </article>
         
         <article class="global" data-name="_CSPropBits_index">
            <h2>_CSPropBits_index</h2>
            <hr />
            
            <pre><code>_CSPropBits_index</code></pre>
         </article>
          
         <article class="struct" data-name="nameFinder">
            <h2>type nameFinder struct</h2>
            <hr />
            
            <p>nameFinder provides a set of "isXXX" query methods for clients to
ask whether a given AST node corresponds to a function, a constant
value, and so on. These methods use an underlying ir.ReassignOracle
to return more precise results in cases where an "interesting"
value is assigned to a singly-defined local temp. Example:

	const q = 101
	fq := func() int { return q }
	copyOfConstant := q
	copyOfFunc := f
	interestingCall(copyOfConstant, copyOfFunc)

A name finder query method invoked on the arguments being passed to
"interestingCall" will be able detect that 'copyOfConstant' always
evaluates to a constant (even though it is in fact a PAUTO local
variable). A given nameFinder can also operate without using
ir.ReassignOracle (in cases where it is not practical to look
at the entire function); in such cases queries will still work
for explicit constant values and functions.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ro *ir.ReassignOracle</code></pre>
         </article>
         
         <article class="struct" data-name="resultPropAndCS">
            <h2>type resultPropAndCS struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">defcs *CallSite
props ResultPropBits</code></pre>
         </article>
         
         <article class="struct" data-name="resultUseAnalyzer">
            <h2>type resultUseAnalyzer struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">resultNameTab *ast.MapType
fn *ir.Func
cstab CallSiteTab
*condLevelTracker</code></pre>
         </article>
         
         <article class="struct" data-name="state">
            <h2>type state struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">ntab *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="exprClassifier">
            <h2>type exprClassifier struct</h2>
            <hr />
            
            <p>exprClassifier holds intermediate state about nodes within an
expression tree being analyzed by ShouldFoldIfNameConstant. Here
"name" is the name node passed in, and "disposition" stores the
result of classifying a given IR node.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">names *ast.MapType
disposition *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="dumpReader">
            <h2>type dumpReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">s *bufio.Scanner
t *testing.T
p string
ln int</code></pre>
         </article>
         
         <article class="struct" data-name="upexState">
            <h2>type upexState struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">dentries []fnInlHeur
newgolines []string
atline *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="callSiteAnalyzer">
            <h2>type callSiteAnalyzer struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">fn *ir.Func
*nameFinder</code></pre>
         </article>
         
         <article class="struct" data-name="callSiteTableBuilder">
            <h2>type callSiteTableBuilder struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">fn *ir.Func
*nameFinder
cstab CallSiteTab
ptab *ast.MapType
nstack []ir.Node
loopNest int
isInit bool</code></pre>
         </article>
         
         <article class="struct" data-name="funcFlagsAnalyzer">
            <h2>type funcFlagsAnalyzer struct</h2>
            <hr />
            
            <p>funcFlagsAnalyzer computes the "Flags" value for the FuncProps
object we're computing. The main item of interest here is "nstate",
which stores the disposition of a given ir Node with respect to the
flags/properties we're trying to compute.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">fn *ir.Func
nstate *ast.MapType
noInfo bool</code></pre>
         </article>
         
         <article class="struct" data-name="resultsAnalyzer">
            <h2>type resultsAnalyzer struct</h2>
            <hr />
            
            <p>resultsAnalyzer stores state information for the process of
computing flags/properties for the return values of a specific Go
function, as part of inline heuristics synthesis.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">fname string
props []ResultPropBits
values []resultVal
inlineMaxBudget int
*nameFinder</code></pre>
         </article>
         
         <article class="struct" data-name="resultVal">
            <h2>type resultVal struct</h2>
            <hr />
            
            <p>resultVal captures information about a specific result returned from
the function we're analyzing; we are interested in cases where
the func always returns the same constant, or always returns
the same function, etc. This container stores info on a the specific
scenarios we're looking for.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">cval constant.Value
fn *ir.Name
fnClo bool
top bool
derived bool</code></pre>
         </article>
         
         <article class="struct" data-name="scoreCallsCacheType">
            <h2>type scoreCallsCacheType struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">tab CallSiteTab
csl []*CallSite</code></pre>
         </article>
         
         <article class="struct" data-name="fnInlHeur">
            <h2>type fnInlHeur struct</h2>
            <hr />
            
            <p>fnInlHeur contains inline heuristics state information about a
specific Go function being analyzed/considered by the inliner. Note
that in addition to constructing a fnInlHeur object by analyzing a
specific *ir.Func, there is also code in the test harness
(funcprops_test.go) that builds up fnInlHeur's by reading in and
parsing a dump. This is the reason why we have file/fname/line
fields below instead of just an *ir.Func field.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">props *FuncProps
cstab CallSiteTab
fname string
file string
line uint</code></pre>
         </article>
         
         <article class="struct" data-name="FuncProps">
            <h2>type FuncProps struct</h2>
            <hr />
            
            <p>FuncProps describes a set of function or method properties that may
be useful for inlining heuristics. Here 'Flags' are properties that
we think apply to the entire function; 'RecvrParamFlags' are
properties of specific function params (or the receiver), and
'ResultFlags' are things properties we think will apply to values
of specific results. Note that 'ParamFlags' includes and entry for
the receiver if applicable, and does include etries for blank
params; for a function such as "func foo(_ int, b byte, _ float32)"
the length of ParamFlags will be 3.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Flags FuncPropBits
ParamFlags []ParamPropBits
ResultFlags []ResultPropBits</code></pre>
         </article>
         
         <article class="struct" data-name="paramsAnalyzer">
            <h2>type paramsAnalyzer struct</h2>
            <hr />
            
            <p>paramsAnalyzer holds state information for the phase that computes
flags for a Go functions parameters, for use in inline heuristics.
Note that the params slice below includes entries for blanks.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">fname string
values []ParamPropBits
params []*ir.Name
top []bool
*condLevelTracker
*nameFinder</code></pre>
         </article>
         
         <article class="struct" data-name="condLevelTracker">
            <h2>type condLevelTracker struct</h2>
            <hr />
            
            <p>condLevelTracker helps keeps track very roughly of "level of conditional
nesting", e.g. how many "if" statements you have to go through to
get to the point where a given stmt executes. Example:

	                      cond nesting level
	func foo() {
	 G = 1                   0
	 if x < 10 {             0
	  if y < 10 {            1
	   G = 0                 2
	  }
	 }
	}

The intent here is to provide some sort of very abstract relative
hotness metric, e.g. "G = 1" above is expected to be executed more
often than "G = 0" (in the aggregate, across large numbers of
functions).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">condLevel int</code></pre>
         </article>
         
         <article class="struct" data-name="CallSite">
            <h2>type CallSite struct</h2>
            <hr />
            
            <p>CallSite records useful information about a potentially inlinable
(direct) function call. "Callee" is the target of the call, "Call"
is the ir node corresponding to the call itself, "Assign" is
the top-level assignment statement containing the call (if the call
appears in the form of a top-level statement, e.g. "x := foo()"),
"Flags" contains properties of the call that might be useful for
making inlining decisions, "Score" is the final score assigned to
the site, and "ID" is a numeric ID for the site within its
containing function.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Callee *ir.Func
Call *ir.CallExpr
parent *CallSite
Assign ir.Node
Flags CSPropBits
ArgProps []ActualExprPropBits
Score int
ScoreMask scoreAdjustTyp
ID uint
aux uint8</code></pre>
         </article>
         
         <article class="struct" data-name="propsAndScore">
            <h2>type propsAndScore struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">props CSPropBits
score int
mask scoreAdjustTyp</code></pre>
         </article>
          
         <article class="function" data-name="newNameFinder">
            <h2>newNameFinder</h2>
            <hr />
            
            <p>newNameFinder returns a new nameFinder object with a reassignment
oracle initialized based on the function fn, or if fn is nil,
without an underlying ReassignOracle.</p>
            
            <pre><code>func newNameFinder(fn *ir.Func) *nameFinder</code></pre>
         </article>
         
         <article class="function" data-name="funcName">
            <h2>funcName</h2>
            <hr />
            
            <p>funcName returns the *ir.Name for the func or method
corresponding to node 'n', or nil if n can't be proven
to contain a function value.</p>
            
            <pre><code>func funcName(n ir.Node) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="isAllocatedMem">
            <h2>isAllocatedMem</h2>
            <hr />
            
            <p>isAllocatedMem returns true if node n corresponds to a memory
allocation expression (make, new, or equivalent).</p>
            
            <pre><code>func isAllocatedMem(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="constValue">
            <h2>constValue</h2>
            <hr />
            
            <p>constValue returns the underlying constant.Value for an AST node n
if n is itself a constant value/expr, or if n is a singly assigned
local containing constant expr/value (or nil not constant).</p>
            
            <pre><code>func constValue(n ir.Node) constant.Value</code></pre>
         </article>
         
         <article class="function" data-name="isNil">
            <h2>isNil</h2>
            <hr />
            
            <p>isNil returns whether n is nil (or singly
assigned local containing nil).</p>
            
            <pre><code>func isNil(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="staticValue">
            <h2>staticValue</h2>
            <hr />
            
            <pre><code>func staticValue(n ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="reassigned">
            <h2>reassigned</h2>
            <hr />
            
            <pre><code>func reassigned(n *ir.Name) bool</code></pre>
         </article>
         
         <article class="function" data-name="isConcreteConvIface">
            <h2>isConcreteConvIface</h2>
            <hr />
            
            <pre><code>func isConcreteConvIface(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="isSameFuncName">
            <h2>isSameFuncName</h2>
            <hr />
            
            <pre><code>func isSameFuncName(v1 *ir.Name, v2 *ir.Name) bool</code></pre>
         </article>
         
         <article class="function" data-name="rescoreBasedOnCallResultUses">
            <h2>rescoreBasedOnCallResultUses</h2>
            <hr />
            
            <p>rescoreBasedOnCallResultUses examines how call results are used,
and tries to update the scores of calls based on how their results
are used in the function.</p>
            
            <pre><code>func rescoreBasedOnCallResultUses(fn *ir.Func, resultNameTab *ast.MapType, cstab CallSiteTab)</code></pre>
         </article>
         
         <article class="function" data-name="examineCallResults">
            <h2>examineCallResults</h2>
            <hr />
            
            <pre><code>func examineCallResults(cs *CallSite, resultNameTab *ast.MapType) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="namesDefined">
            <h2>namesDefined</h2>
            <hr />
            
            <p>namesDefined returns a list of ir.Name's corresponding to locals
that receive the results from the call at site 'cs', plus the
properties object for the called function. If a given result
isn't cleanly assigned to a newly defined local, the
slot for that result in the returned list will be nil. Example:

	call                             returned name list

	x := foo()                       [ x ]
	z, y := bar()                    [ nil, nil ]
	_, q := baz()                    [ nil, q ]

In the case of a multi-return call, such as "x, y := foo()",
the pattern we see from the front end will be a call op
assigning to auto-temps, and then an assignment of the auto-temps
to the user-level variables. In such cases we return
first the user-level variable (in the first func result)
and then the auto-temp name in the second result.</p>
            
            <pre><code>func namesDefined(cs *CallSite) ([]*ir.Name, []*ir.Name, *FuncProps)</code></pre>
         </article>
         
         <article class="function" data-name="nodeVisitPost">
            <h2>nodeVisitPost</h2>
            <hr />
            
            <pre><code>func nodeVisitPost(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="nodeVisitPre">
            <h2>nodeVisitPre</h2>
            <hr />
            
            <pre><code>func nodeVisitPre(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="callTargetCheckResults">
            <h2>callTargetCheckResults</h2>
            <hr />
            
            <p>callTargetCheckResults examines a given call to see whether the
callee expression is potentially an inlinable function returned
from a potentially inlinable call. Examples:

	Scenario 1: named intermediate

	   fn1 := foo()         conc := bar()
	   fn1("blah")          conc.MyMethod()

	Scenario 2: returned func or concrete object feeds directly to call

	   foo()("blah")        bar().MyMethod()

In the second case although at the source level the result of the
direct call feeds right into the method call or indirect call,
we're relying on the front end having inserted an auto-temp to
capture the value.</p>
            
            <pre><code>func callTargetCheckResults(call ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="foldCheckResults">
            <h2>foldCheckResults</h2>
            <hr />
            
            <p>foldCheckResults examines the specified if/switch condition 'cond'
to see if it refers to locals defined by a (potentially inlinable)
function call at call site C, and if so, whether 'cond' contains
only combinations of simple references to all of the names in
'names' with selected constants + operators. If these criteria are
met, then we adjust the score for call site C to reflect the
fact that inlining will enable deadcode and/or constant propagation.
Note: for this heuristic to kick in, the names in question have to
be all from the same callsite. Examples:

	  q, r := baz()	    x, y := foo()
	  switch q+r {		a, b, c := bar()
		...			    if x && y && a && b && c {
	  }					   ...
					    }

For the call to "baz" above we apply a score adjustment, but not
for the calls to "foo" or "bar".</p>
            
            <pre><code>func foldCheckResults(cond ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="collectNamesUsed">
            <h2>collectNamesUsed</h2>
            <hr />
            
            <pre><code>func collectNamesUsed(expr ir.Node) []*ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="returnHasProp">
            <h2>returnHasProp</h2>
            <hr />
            
            <pre><code>func returnHasProp(name *ir.Name, prop ResultPropBits) *CallSite</code></pre>
         </article>
         
         <article class="function" data-name="getCallResultName">
            <h2>getCallResultName</h2>
            <hr />
            
            <pre><code>func getCallResultName(ce *ir.CallExpr) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="mkstate">
            <h2>mkstate</h2>
            <hr />
            
            <pre><code>func mkstate() *state</code></pre>
         </article>
         
         <article class="function" data-name="bin">
            <h2>bin</h2>
            <hr />
            
            <pre><code>func bin(x ir.Node, op ir.Op, y ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="conv">
            <h2>conv</h2>
            <hr />
            
            <pre><code>func conv(x ir.Node, t *types.Type) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="logical">
            <h2>logical</h2>
            <hr />
            
            <pre><code>func logical(x ir.Node, op ir.Op, y ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="un">
            <h2>un</h2>
            <hr />
            
            <pre><code>func un(op ir.Op, x ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="liti">
            <h2>liti</h2>
            <hr />
            
            <pre><code>func liti(i int64) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="lits">
            <h2>lits</h2>
            <hr />
            
            <pre><code>func lits(s string) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="nm">
            <h2>nm</h2>
            <hr />
            
            <pre><code>func nm(name string, t *types.Type) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="nmi64">
            <h2>nmi64</h2>
            <hr />
            
            <pre><code>func nmi64(name string) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="nms">
            <h2>nms</h2>
            <hr />
            
            <pre><code>func nms(name string) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="TestClassifyIntegerCompare">
            <h2>TestClassifyIntegerCompare</h2>
            <hr />
            
            <pre><code>func TestClassifyIntegerCompare(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestClassifyStringCompare">
            <h2>TestClassifyStringCompare</h2>
            <hr />
            
            <pre><code>func TestClassifyStringCompare(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestClassifyIntegerArith">
            <h2>TestClassifyIntegerArith</h2>
            <hr />
            
            <pre><code>func TestClassifyIntegerArith(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestClassifyAssortedShifts">
            <h2>TestClassifyAssortedShifts</h2>
            <hr />
            
            <pre><code>func TestClassifyAssortedShifts(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestClassifyFloat">
            <h2>TestClassifyFloat</h2>
            <hr />
            
            <pre><code>func TestClassifyFloat(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMultipleNamesAllUsed">
            <h2>TestMultipleNamesAllUsed</h2>
            <hr />
            
            <pre><code>func TestMultipleNamesAllUsed(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="fpeq">
            <h2>fpeq</h2>
            <hr />
            
            <pre><code>func fpeq(fp1 FuncProps, fp2 FuncProps) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestSerDeser">
            <h2>TestSerDeser</h2>
            <hr />
            
            <pre><code>func TestSerDeser(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>func _()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="ShouldFoldIfNameConstant">
            <h2>ShouldFoldIfNameConstant</h2>
            <hr />
            
            <p>ShouldFoldIfNameConstant analyzes expression tree 'e' to see
whether it contains only combinations of simple references to all
of the names in 'names' with selected constants + operators. The
intent is to identify expression that could be folded away to a
constant if the value of 'n' were available. Return value is TRUE
if 'e' does look foldable given the value of 'n', and given that
'e' actually makes reference to 'n'. Some examples where the type
of "n" is int64, type of "s" is string, and type of "p" is *byte:

	Simple?		Expr
	yes			n<10
	yes			n*n-100
	yes			(n < 10 || n > 100) && (n >= 12 || n <= 99 || n != 101)
	yes			s == "foo"
	yes			p == nil
	no			n<foo()
	no			n<1 || n>m
	no			float32(n)<1.0
	no			*p == 1
	no			1 + 100
	no			1 / n
	no			1 + unsafe.Sizeof(n)

To avoid complexities (e.g. nan, inf) we stay way from folding and
floating point or complex operations (integers, bools, and strings
only). We also try to be conservative about avoiding any operation
that might result in a panic at runtime, e.g. for "n" with type
int64:

	1<<(n-9) < 100/(n<<9999)

we would return FALSE due to the negative shift count and/or
potential divide by zero.</p>
            
            <pre><code>func ShouldFoldIfNameConstant(n ir.Node, names []*ir.Name) bool</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="makeExprClassifier">
            <h2>makeExprClassifier</h2>
            <hr />
            
            <pre><code>func makeExprClassifier(names []*ir.Name) *exprClassifier</code></pre>
         </article>
         
         <article class="function" data-name="Visit">
            <h2>Visit</h2>
            <hr />
            
            <p>Visit sets the classification for 'n' based on the previously
calculated classifications for n's children, as part of a bottom-up
walk over an expression tree.</p>
            
            <pre><code>func Visit(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="getdisp">
            <h2>getdisp</h2>
            <hr />
            
            <pre><code>func getdisp(x ir.Node) disp</code></pre>
         </article>
         
         <article class="function" data-name="dispmeet">
            <h2>dispmeet</h2>
            <hr />
            
            <p>dispmeet performs a "meet" operation on the data flow states of
node x and y (where the term "meet" is being drawn from traditional
lattice-theoretical data flow analysis terminology).</p>
            
            <pre><code>func dispmeet(x ir.Node, y ir.Node) disp</code></pre>
         </article>
         
         <article class="function" data-name="TestFuncProperties">
            <h2>TestFuncProperties</h2>
            <hr />
            
            <pre><code>func TestFuncProperties(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="propBitsToString">
            <h2>propBitsToString</h2>
            <hr />
            
            <pre><code>func propBitsToString(sl []T) string</code></pre>
         </article>
         
         <article class="function" data-name="compareEntries">
            <h2>compareEntries</h2>
            <hr />
            
            <pre><code>func compareEntries(t *testing.T, tc string, dentry *fnInlHeur, dcsites encodedCallSiteTab, eentry *fnInlHeur, ecsites encodedCallSiteTab)</code></pre>
         </article>
         
         <article class="function" data-name="readDump">
            <h2>readDump</h2>
            <hr />
            
            <p>readDump reads in the contents of a dump file produced
by the "-d=dumpinlfuncprops=..." command line flag by the Go
compiler. It breaks the dump down into separate sections
by function, then deserializes each func section into a
fnInlHeur object and returns a slice of those objects.</p>
            
            <pre><code>func readDump(t *testing.T, path string) ([]fnInlHeur, []encodedCallSiteTab, error)</code></pre>
         </article>
         
         <article class="function" data-name="scan">
            <h2>scan</h2>
            <hr />
            
            <pre><code>func scan() bool</code></pre>
         </article>
         
         <article class="function" data-name="curLine">
            <h2>curLine</h2>
            <hr />
            
            <pre><code>func curLine() string</code></pre>
         </article>
         
         <article class="function" data-name="readObjBlob">
            <h2>readObjBlob</h2>
            <hr />
            
            <p>readObjBlob reads in a series of commented lines until
it hits a delimiter, then returns the contents of the comments.</p>
            
            <pre><code>func readObjBlob(delim string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="readEntry">
            <h2>readEntry</h2>
            <hr />
            
            <p>readEntry reads a single function's worth of material from
a file produced by the "-d=dumpinlfuncprops=..." command line
flag. It deserializes the json for the func properties and
returns the resulting properties and function name. EOF is
signaled by a nil FuncProps return (with no error</p>
            
            <pre><code>func readEntry() (fnInlHeur, encodedCallSiteTab, error)</code></pre>
         </article>
         
         <article class="function" data-name="gatherPropsDumpForFile">
            <h2>gatherPropsDumpForFile</h2>
            <hr />
            
            <p>gatherPropsDumpForFile builds the specified testcase 'testcase' from
testdata/props passing the "-d=dumpinlfuncprops=..." compiler option,
to produce a properties dump, then returns the path of the newly
created file. NB: we can't use "go tool compile" here, since
some of the test cases import stdlib packages (such as "os").
This means using "go build", which is problematic since the
Go command can potentially cache the results of the compile step,
causing the test to fail when being run interactively. E.g.

	$ rm -f dump.txt
	$ go build -o foo.a -gcflags=-d=dumpinlfuncprops=dump.txt foo.go
	$ rm -f dump.txt foo.a
	$ go build -o foo.a -gcflags=-d=dumpinlfuncprops=dump.txt foo.go
	$ ls foo.a dump.txt > /dev/null
	ls : cannot access 'dump.txt': No such file or directory
	$

For this reason, pick a unique filename for the dump, so as to
defeat the caching.</p>
            
            <pre><code>func gatherPropsDumpForFile(t *testing.T, testcase string, td string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="genExpected">
            <h2>genExpected</h2>
            <hr />
            
            <p>genExpected reads in a given Go testcase file, strips out all the
unindented (column 0) commands, writes them out to a new file, and
returns the path of that new file. By picking out just the comments
from the Go file we wind up with something that resembles the
output from a "-d=dumpinlfuncprops=..." compilation.</p>
            
            <pre><code>func genExpected(td string, testcase string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="mkUpexState">
            <h2>mkUpexState</h2>
            <hr />
            
            <pre><code>func mkUpexState(dentries []fnInlHeur) *upexState</code></pre>
         </article>
         
         <article class="function" data-name="updateExpected">
            <h2>updateExpected</h2>
            <hr />
            
            <p>updateExpected takes a given Go testcase file X.go and writes out a
new/updated version of the file to X.go.new, where the column-0
"expected" comments have been updated using fresh data from
"dentries".

Writing of expected results is complicated by closures and by
generics, where you can have multiple functions that all share the
same starting line. Currently we combine up all the dups and
closures into the single pre-func comment.</p>
            
            <pre><code>func updateExpected(t *testing.T, testcase string, dentries []fnInlHeur, dcsites []encodedCallSiteTab)</code></pre>
         </article>
         
         <article class="function" data-name="interestingToCompare">
            <h2>interestingToCompare</h2>
            <hr />
            
            <p>interestingToCompare returns TRUE if we want to compare results
for function 'fname'.</p>
            
            <pre><code>func interestingToCompare(fname string) bool</code></pre>
         </article>
         
         <article class="function" data-name="enableDebugTrace">
            <h2>enableDebugTrace</h2>
            <hr />
            
            <pre><code>func enableDebugTrace(x int)</code></pre>
         </article>
         
         <article class="function" data-name="enableDebugTraceIfEnv">
            <h2>enableDebugTraceIfEnv</h2>
            <hr />
            
            <pre><code>func enableDebugTraceIfEnv()</code></pre>
         </article>
         
         <article class="function" data-name="disableDebugTrace">
            <h2>disableDebugTrace</h2>
            <hr />
            
            <pre><code>func disableDebugTrace()</code></pre>
         </article>
         
         <article class="function" data-name="makeCallSiteAnalyzer">
            <h2>makeCallSiteAnalyzer</h2>
            <hr />
            
            <pre><code>func makeCallSiteAnalyzer(fn *ir.Func) *callSiteAnalyzer</code></pre>
         </article>
         
         <article class="function" data-name="makeCallSiteTableBuilder">
            <h2>makeCallSiteTableBuilder</h2>
            <hr />
            
            <pre><code>func makeCallSiteTableBuilder(fn *ir.Func, cstab CallSiteTab, ptab *ast.MapType, loopNestingLevel int, nf *nameFinder) *callSiteTableBuilder</code></pre>
         </article>
         
         <article class="function" data-name="computeCallSiteTable">
            <h2>computeCallSiteTable</h2>
            <hr />
            
            <p>computeCallSiteTable builds and returns a table of call sites for
the specified region in function fn. A region here corresponds to a
specific subtree within the AST for a function. The main intended
use cases are for 'region' to be either A) an entire function body,
or B) an inlined call expression.</p>
            
            <pre><code>func computeCallSiteTable(fn *ir.Func, region ir.Nodes, cstab CallSiteTab, ptab *ast.MapType, loopNestingLevel int, nf *nameFinder) CallSiteTab</code></pre>
         </article>
         
         <article class="function" data-name="flagsForNode">
            <h2>flagsForNode</h2>
            <hr />
            
            <pre><code>func flagsForNode(call *ir.CallExpr) CSPropBits</code></pre>
         </article>
         
         <article class="function" data-name="determinePanicPathBits">
            <h2>determinePanicPathBits</h2>
            <hr />
            
            <p>determinePanicPathBits updates the CallSiteOnPanicPath bit within
"r" if we think this call is on an unconditional path to
panic/exit. Do this by walking back up the node stack to see if we
can find either A) an enclosing panic, or B) a statement node that
we've determined leads to a panic/exit.</p>
            
            <pre><code>func determinePanicPathBits(call ir.Node, r CSPropBits) CSPropBits</code></pre>
         </article>
         
         <article class="function" data-name="propsForArg">
            <h2>propsForArg</h2>
            <hr />
            
            <p>propsForArg returns property bits for a given call argument expression arg.</p>
            
            <pre><code>func propsForArg(arg ir.Node) ActualExprPropBits</code></pre>
         </article>
         
         <article class="function" data-name="argPropsForCall">
            <h2>argPropsForCall</h2>
            <hr />
            
            <p>argPropsForCall returns a slice of argument properties for the
expressions being passed to the callee in the specific call
expression; these will be stored in the CallSite object for a given
call and then consulted when scoring. If no arg has any interesting
properties we try to save some space and return a nil slice.</p>
            
            <pre><code>func argPropsForCall(ce *ir.CallExpr) []ActualExprPropBits</code></pre>
         </article>
         
         <article class="function" data-name="addCallSite">
            <h2>addCallSite</h2>
            <hr />
            
            <pre><code>func addCallSite(callee *ir.Func, call *ir.CallExpr)</code></pre>
         </article>
         
         <article class="function" data-name="nodeVisitPre">
            <h2>nodeVisitPre</h2>
            <hr />
            
            <pre><code>func nodeVisitPre(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="nodeVisitPost">
            <h2>nodeVisitPost</h2>
            <hr />
            
            <pre><code>func nodeVisitPost(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="loopBody">
            <h2>loopBody</h2>
            <hr />
            
            <pre><code>func loopBody(n ir.Node) ir.Nodes</code></pre>
         </article>
         
         <article class="function" data-name="hasTopLevelLoopBodyReturnOrBreak">
            <h2>hasTopLevelLoopBodyReturnOrBreak</h2>
            <hr />
            
            <p>hasTopLevelLoopBodyReturnOrBreak examines the body of a "for" or
"range" loop to try to verify that it is a real loop, as opposed to
a construct that is syntactically loopy but doesn't actually iterate
multiple times, like:

	for {
	  blah()
	  return 1
	}

[Remark: the pattern above crops up quite a bit in the source code
for the compiler itself, e.g. the auto-generated rewrite code]

Note that we don't look for GOTO statements here, so it's possible
we'll get the wrong result for a loop with complicated control
jumps via gotos.</p>
            
            <pre><code>func hasTopLevelLoopBodyReturnOrBreak(loopBody ir.Nodes) bool</code></pre>
         </article>
         
         <article class="function" data-name="containingAssignment">
            <h2>containingAssignment</h2>
            <hr />
            
            <p>containingAssignment returns the top-level assignment statement
for a statement level function call "n". Examples:

	x := foo()
	x, y := bar(z, baz())
	if blah() { ...

Here the top-level assignment statement for the foo() call is the
statement assigning to "x"; the top-level assignment for "bar()"
call is the assignment to x,y. For the baz() and blah() calls,
there is no top level assignment statement.

The unstated goal here is that we want to use the containing
assignment to establish a connection between a given call and the
variables to which its results/returns are being assigned.

Note that for the "bar" command above, the front end sometimes
decomposes this into two assignments, the first one assigning the
call to a pair of auto-temps, then the second one assigning the
auto-temps to the user-visible vars. This helper will return the
second (outer) of these two.</p>
            
            <pre><code>func containingAssignment(n ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="UpdateCallsiteTable">
            <h2>UpdateCallsiteTable</h2>
            <hr />
            
            <p>UpdateCallsiteTable handles updating of callerfn's call site table
after an inlined has been carried out, e.g. the call at 'n' as been
turned into the inlined call expression 'ic' within function
callerfn. The chief thing of interest here is to make sure that any
call nodes within 'ic' are added to the call site table for
'callerfn' and scored appropriately.</p>
            
            <pre><code>func UpdateCallsiteTable(callerfn *ir.Func, n *ir.CallExpr, ic *ir.InlinedCallExpr)</code></pre>
         </article>
         
         <article class="function" data-name="makeFuncFlagsAnalyzer">
            <h2>makeFuncFlagsAnalyzer</h2>
            <hr />
            
            <pre><code>func makeFuncFlagsAnalyzer(fn *ir.Func) *funcFlagsAnalyzer</code></pre>
         </article>
         
         <article class="function" data-name="setResults">
            <h2>setResults</h2>
            <hr />
            
            <p>setResults transfers func flag results to 'funcProps'.</p>
            
            <pre><code>func setResults(funcProps *FuncProps)</code></pre>
         </article>
         
         <article class="function" data-name="getState">
            <h2>getState</h2>
            <hr />
            
            <pre><code>func getState(n ir.Node) pstate</code></pre>
         </article>
         
         <article class="function" data-name="setState">
            <h2>setState</h2>
            <hr />
            
            <pre><code>func setState(n ir.Node, st pstate)</code></pre>
         </article>
         
         <article class="function" data-name="updateState">
            <h2>updateState</h2>
            <hr />
            
            <pre><code>func updateState(n ir.Node, st pstate)</code></pre>
         </article>
         
         <article class="function" data-name="panicPathTable">
            <h2>panicPathTable</h2>
            <hr />
            
            <pre><code>func panicPathTable() *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="blockCombine">
            <h2>blockCombine</h2>
            <hr />
            
            <p>blockCombine merges together states as part of a linear sequence of
statements, where 'pred' and 'succ' are analysis results for a pair
of consecutive statements. Examples:

	case 1:             case 2:
	    panic("foo")      if q { return x }        <-pred
	    return x          panic("boo")             <-succ

In case 1, since the pred state is "always panic" it doesn't matter
what the succ state is, hence the state for the combination of the
two blocks is "always panics". In case 2, because there is a path
to return that avoids the panic in succ, the state for the
combination of the two statements is "may return".</p>
            
            <pre><code>func blockCombine(pred pstate, succ pstate) pstate</code></pre>
         </article>
         
         <article class="function" data-name="branchCombine">
            <h2>branchCombine</h2>
            <hr />
            
            <p>branchCombine combines two states at a control flow branch point where
either p1 or p2 executes (as in an "if" statement).</p>
            
            <pre><code>func branchCombine(p1 pstate, p2 pstate) pstate</code></pre>
         </article>
         
         <article class="function" data-name="stateForList">
            <h2>stateForList</h2>
            <hr />
            
            <p>stateForList walks through a list of statements and computes the
state/disposition for the entire list as a whole, as well
as updating disposition of intermediate nodes.</p>
            
            <pre><code>func stateForList(list ir.Nodes) pstate</code></pre>
         </article>
         
         <article class="function" data-name="isMainMain">
            <h2>isMainMain</h2>
            <hr />
            
            <pre><code>func isMainMain(fn *ir.Func) bool</code></pre>
         </article>
         
         <article class="function" data-name="isWellKnownFunc">
            <h2>isWellKnownFunc</h2>
            <hr />
            
            <pre><code>func isWellKnownFunc(s *types.Sym, pkg string, name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="isExitCall">
            <h2>isExitCall</h2>
            <hr />
            
            <p>isExitCall reports TRUE if the node itself is an unconditional
call to os.Exit(), a panic, or a function that does likewise.</p>
            
            <pre><code>func isExitCall(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="pessimize">
            <h2>pessimize</h2>
            <hr />
            
            <p>pessimize is called to record the fact that we saw something in the
function that renders it entirely impossible to analyze.</p>
            
            <pre><code>func pessimize()</code></pre>
         </article>
         
         <article class="function" data-name="shouldVisit">
            <h2>shouldVisit</h2>
            <hr />
            
            <p>shouldVisit reports TRUE if this is an interesting node from the
perspective of computing function flags. NB: due to the fact that
ir.CallExpr implements the Stmt interface, we wind up visiting
a lot of nodes that we don't really need to, but these can
simply be screened out as part of the visit.</p>
            
            <pre><code>func shouldVisit(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="nodeVisitPost">
            <h2>nodeVisitPost</h2>
            <hr />
            
            <p>nodeVisitPost helps implement the propAnalyzer interface; when
called on a given node, it decides the disposition of that node
based on the state(s) of the node's children.</p>
            
            <pre><code>func nodeVisitPost(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="nodeVisitPre">
            <h2>nodeVisitPre</h2>
            <hr />
            
            <pre><code>func nodeVisitPre(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="addResultsAnalyzer">
            <h2>addResultsAnalyzer</h2>
            <hr />
            
            <p>addResultsAnalyzer creates a new resultsAnalyzer helper object for
the function fn, appends it to the analyzers list, and returns the
new list. If the function in question doesn't have any returns (or
any interesting returns) then the analyzer list is left as is, and
the result flags in "fp" are updated accordingly.</p>
            
            <pre><code>func addResultsAnalyzer(fn *ir.Func, analyzers []propAnalyzer, fp *FuncProps, inlineMaxBudget int, nf *nameFinder) []propAnalyzer</code></pre>
         </article>
         
         <article class="function" data-name="makeResultsAnalyzer">
            <h2>makeResultsAnalyzer</h2>
            <hr />
            
            <p>makeResultsAnalyzer creates a new helper object to analyze results
in function fn. If the function doesn't have any interesting
results, a nil helper is returned along with a set of default
result flags for the func.</p>
            
            <pre><code>func makeResultsAnalyzer(fn *ir.Func, inlineMaxBudget int, nf *nameFinder) (*resultsAnalyzer, []ResultPropBits)</code></pre>
         </article>
         
         <article class="function" data-name="setResults">
            <h2>setResults</h2>
            <hr />
            
            <p>setResults transfers the calculated result properties for this
function to 'funcProps'.</p>
            
            <pre><code>func setResults(funcProps *FuncProps)</code></pre>
         </article>
         
         <article class="function" data-name="pessimize">
            <h2>pessimize</h2>
            <hr />
            
            <pre><code>func pessimize()</code></pre>
         </article>
         
         <article class="function" data-name="nodeVisitPre">
            <h2>nodeVisitPre</h2>
            <hr />
            
            <pre><code>func nodeVisitPre(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="nodeVisitPost">
            <h2>nodeVisitPost</h2>
            <hr />
            
            <pre><code>func nodeVisitPost(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="analyzeResult">
            <h2>analyzeResult</h2>
            <hr />
            
            <p>analyzeResult examines the expression 'n' being returned as the
'ii'th argument in some return statement to see whether has
interesting characteristics (for example, returns a constant), then
applies a dataflow "meet" operation to combine this result with any
previous result (for the given return slot) that we've already
processed.</p>
            
            <pre><code>func analyzeResult(ii int, n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="deriveReturnFlagsFromCallee">
            <h2>deriveReturnFlagsFromCallee</h2>
            <hr />
            
            <p>deriveReturnFlagsFromCallee tries to set properties for a given
return result where we're returning call expression; return value
is a return property value and a boolean indicating whether the
prop is valid. Examples:

	func foo() int { return bar() }
	func bar() int { return 42 }
	func blix() int { return 43 }
	func two(y int) int {
	  if y < 0 { return bar() } else { return blix() }
	}

Since "foo" always returns the result of a call to "bar", we can
set foo's return property to that of bar. In the case of "two", however,
even though each return path returns a constant, we don't know
whether the constants are identical, hence we need to be conservative.</p>
            
            <pre><code>func deriveReturnFlagsFromCallee(n ir.Node) (ResultPropBits, bool)</code></pre>
         </article>
         
         <article class="function" data-name="TestInlScoreAdjFlagParse">
            <h2>TestInlScoreAdjFlagParse</h2>
            <hr />
            
            <pre><code>func TestInlScoreAdjFlagParse(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="ToString">
            <h2>ToString</h2>
            <hr />
            
            <pre><code>func ToString(prefix string) string</code></pre>
         </article>
         
         <article class="function" data-name="flagSliceToSB">
            <h2>flagSliceToSB</h2>
            <hr />
            
            <pre><code>func flagSliceToSB(sb *strings.Builder, sl []T, prefix string, tag string)</code></pre>
         </article>
         
         <article class="function" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>func _()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>func _()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="SetupScoreAdjustments">
            <h2>SetupScoreAdjustments</h2>
            <hr />
            
            <p>SetupScoreAdjustments interprets the value of the -d=inlscoreadj
debugging option, if set. The value of this flag is expected to be
a series of "/"-separated clauses of the form adj1:value1. Example:
-d=inlscoreadj=inLoopAdj=0/passConstToIfAdj=-99</p>
            
            <pre><code>func SetupScoreAdjustments()</code></pre>
         </article>
         
         <article class="function" data-name="adjStringToVal">
            <h2>adjStringToVal</h2>
            <hr />
            
            <pre><code>func adjStringToVal(s string) (scoreAdjustTyp, bool)</code></pre>
         </article>
         
         <article class="function" data-name="parseScoreAdj">
            <h2>parseScoreAdj</h2>
            <hr />
            
            <pre><code>func parseScoreAdj(val string) error</code></pre>
         </article>
         
         <article class="function" data-name="adjValue">
            <h2>adjValue</h2>
            <hr />
            
            <pre><code>func adjValue(x scoreAdjustTyp) int</code></pre>
         </article>
         
         <article class="function" data-name="isMay">
            <h2>isMay</h2>
            <hr />
            
            <pre><code>func isMay(x scoreAdjustTyp) bool</code></pre>
         </article>
         
         <article class="function" data-name="isMust">
            <h2>isMust</h2>
            <hr />
            
            <pre><code>func isMust(x scoreAdjustTyp) bool</code></pre>
         </article>
         
         <article class="function" data-name="mayToMust">
            <h2>mayToMust</h2>
            <hr />
            
            <pre><code>func mayToMust(x scoreAdjustTyp) scoreAdjustTyp</code></pre>
         </article>
         
         <article class="function" data-name="mustToMay">
            <h2>mustToMay</h2>
            <hr />
            
            <pre><code>func mustToMay(x scoreAdjustTyp) scoreAdjustTyp</code></pre>
         </article>
         
         <article class="function" data-name="computeCallSiteScore">
            <h2>computeCallSiteScore</h2>
            <hr />
            
            <p>computeCallSiteScore takes a given call site whose ir node is
'call' and callee function is 'callee' and with previously computed
call site properties 'csflags', then computes a score for the
callsite that combines the size cost of the callee with heuristics
based on previously computed argument and function properties,
then stores the score and the adjustment mask in the appropriate
fields in 'cs'</p>
            
            <pre><code>func computeCallSiteScore(csa *callSiteAnalyzer, calleeProps *FuncProps)</code></pre>
         </article>
         
         <article class="function" data-name="adjustScore">
            <h2>adjustScore</h2>
            <hr />
            
            <pre><code>func adjustScore(typ scoreAdjustTyp, score int, mask scoreAdjustTyp) (int, scoreAdjustTyp)</code></pre>
         </article>
         
         <article class="function" data-name="setupFlagToAdjMaps">
            <h2>setupFlagToAdjMaps</h2>
            <hr />
            
            <pre><code>func setupFlagToAdjMaps()</code></pre>
         </article>
         
         <article class="function" data-name="LargestNegativeScoreAdjustment">
            <h2>LargestNegativeScoreAdjustment</h2>
            <hr />
            
            <p>LargestNegativeScoreAdjustment tries to estimate the largest possible
negative score adjustment that could be applied to a call of the
function with the specified props. Example:

	func foo() {                  func bar(x int, p *int) int {
	   ...                          if x < 0 { *p = x }
	}                               return 99
	                              }

Function 'foo' above on the left has no interesting properties,
thus as a result the most we'll adjust any call to is the value for
"call in loop". If the calculated cost of the function is 150, and
the in-loop adjustment is 5 (for example), then there is not much
point treating it as inlinable. On the other hand "bar" has a param
property (parameter "x" feeds unmodified to an "if" statement) and
a return property (always returns same constant) meaning that a
given call _could_ be rescored down as much as -35 points-- thus if
the size of "bar" is 100 (for example) then there is at least a
chance that scoring will enable inlining.</p>
            
            <pre><code>func LargestNegativeScoreAdjustment(fn *ir.Func, props *FuncProps) int</code></pre>
         </article>
         
         <article class="function" data-name="LargestPositiveScoreAdjustment">
            <h2>LargestPositiveScoreAdjustment</h2>
            <hr />
            
            <p>LargestPositiveScoreAdjustment tries to estimate the largest possible
positive score adjustment that could be applied to a given callsite.
At the moment we don't have very many positive score adjustments, so
this is just hard-coded, not table-driven.</p>
            
            <pre><code>func LargestPositiveScoreAdjustment(fn *ir.Func) int</code></pre>
         </article>
         
         <article class="function" data-name="ScoreCalls">
            <h2>ScoreCalls</h2>
            <hr />
            
            <p>ScoreCalls assigns numeric scores to each of the callsites in
function 'fn'; the lower the score, the more helpful we think it
will be to inline.

Unlike a lot of the other inline heuristics machinery, callsite
scoring can't be done as part of the CanInline call for a function,
due to fact that we may be working on a non-trivial SCC. So for
example with this SCC:

	func foo(x int) {           func bar(x int, f func()) {
	  if x != 0 {                  f()
	    bar(x, func(){})           foo(x-1)
	  }                         }
	}

We don't want to perform scoring for the 'foo' call in "bar" until
after foo has been analyzed, but it's conceivable that CanInline
might visit bar before foo for this SCC.</p>
            
            <pre><code>func ScoreCalls(fn *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="scoreCallsRegion">
            <h2>scoreCallsRegion</h2>
            <hr />
            
            <p>scoreCallsRegion assigns numeric scores to each of the callsites in
region 'region' within function 'fn'. This can be called on
an entire function, or with 'region' set to a chunk of
code corresponding to an inlined call.</p>
            
            <pre><code>func scoreCallsRegion(fn *ir.Func, region ir.Nodes, cstab CallSiteTab, doCallResults bool, ic *ir.InlinedCallExpr)</code></pre>
         </article>
         
         <article class="function" data-name="ScoreCallsCleanup">
            <h2>ScoreCallsCleanup</h2>
            <hr />
            
            <p>ScoreCallsCleanup resets the state of the callsite cache
once ScoreCalls is done with a function.</p>
            
            <pre><code>func ScoreCallsCleanup()</code></pre>
         </article>
         
         <article class="function" data-name="GetCallSiteScore">
            <h2>GetCallSiteScore</h2>
            <hr />
            
            <p>GetCallSiteScore returns the previously calculated score for call
within fn.</p>
            
            <pre><code>func GetCallSiteScore(fn *ir.Func, call *ir.CallExpr) (int, bool)</code></pre>
         </article>
         
         <article class="function" data-name="BudgetExpansion">
            <h2>BudgetExpansion</h2>
            <hr />
            
            <p>BudgetExpansion returns the amount to relax/expand the base
inlining budget when the new inliner is turned on; the inliner
will add the returned value to the hairiness budget.

Background: with the new inliner, the score for a given callsite
can be adjusted down by some amount due to heuristics, however we
won't know whether this is going to happen until much later after
the CanInline call. This function returns the amount to relax the
budget initially (to allow for a large score adjustment); later on
in RevisitInlinability we'll look at each individual function to
demote it if needed.</p>
            
            <pre><code>func BudgetExpansion(maxBudget int32) int32</code></pre>
         </article>
         
         <article class="function" data-name="DumpInlCallSiteScores">
            <h2>DumpInlCallSiteScores</h2>
            <hr />
            
            <p>DumpInlCallSiteScores is invoked by the inliner if the debug flag
"-d=dumpinlcallsitescores" is set; it dumps out a human-readable
summary of all (potentially) inlinable callsites in the package,
along with info on call site scoring and the adjustments made to a
given score. Here profile is the PGO profile in use (may be
nil), budgetCallback is a callback that can be invoked to find out
the original pre-adjustment hairiness limit for the function, and
inlineHotMaxBudget is the constant of the same name used in the
inliner. Sample output lines:

Score  Adjustment  Status  Callee  CallerPos ScoreFlags
115    40          DEMOTED cmd/compile/internal/abi.(*ABIParamAssignment).Offset     expand_calls.go:1679:14|6       panicPathAdj
76     -5n         PROMOTED runtime.persistentalloc   mcheckmark.go:48:45|3   inLoopAdj
201    0           --- PGO  unicode.DecodeRuneInString        utf8.go:312:30|1
7      -5          --- PGO  internal/abi.Name.DataChecked     type.go:625:22|0        inLoopAdj

In the dump above, "Score" is the final score calculated for the
callsite, "Adjustment" is the amount added to or subtracted from
the original hairiness estimate to form the score. "Status" shows
whether anything changed with the site -- did the adjustment bump
it down just below the threshold ("PROMOTED") or instead bump it
above the threshold ("DEMOTED"); this will be blank ("---") if no
threshold was crossed as a result of the heuristics. Note that
"Status" also shows whether PGO was involved. "Callee" is the name
of the function called, "CallerPos" is the position of the
callsite, and "ScoreFlags" is a digest of the specific properties
we used to make adjustments to callsite score via heuristics.</p>
            
            <pre><code>func DumpInlCallSiteScores(profile *pgoir.Profile, budgetCallback func)</code></pre>
         </article>
         
         <article class="function" data-name="AnalyzeFunc">
            <h2>AnalyzeFunc</h2>
            <hr />
            
            <p>AnalyzeFunc computes function properties for fn and its contained
closures, updating the global 'fpmap' table. It is assumed that
"CanInline" has been run on fn and on the closures that feed
directly into calls; other closures not directly called will also
be checked inlinability for inlinability here in case they are
returned as a result.</p>
            
            <pre><code>func AnalyzeFunc(fn *ir.Func, canInline func, budgetForFunc func, inlineMaxBudget int)</code></pre>
         </article>
         
         <article class="function" data-name="TearDown">
            <h2>TearDown</h2>
            <hr />
            
            <p>TearDown is invoked at the end of the main inlining pass; doing
function analysis and call site scoring is unlikely to help a lot
after this point, so nil out fpmap and other globals to reclaim
storage.</p>
            
            <pre><code>func TearDown()</code></pre>
         </article>
         
         <article class="function" data-name="analyzeFunc">
            <h2>analyzeFunc</h2>
            <hr />
            
            <pre><code>func analyzeFunc(fn *ir.Func, inlineMaxBudget int, nf *nameFinder) *FuncProps</code></pre>
         </article>
         
         <article class="function" data-name="revisitInlinability">
            <h2>revisitInlinability</h2>
            <hr />
            
            <p>revisitInlinability revisits the question of whether to continue to
treat function 'fn' as an inline candidate based on the set of
properties we've computed for it. If (for example) it has an
initial size score of 150 and no interesting properties to speak
of, then there isn't really any point to moving ahead with it as an
inline candidate.</p>
            
            <pre><code>func revisitInlinability(fn *ir.Func, funcProps *FuncProps, budgetForFunc func)</code></pre>
         </article>
         
         <article class="function" data-name="computeFuncProps">
            <h2>computeFuncProps</h2>
            <hr />
            
            <p>computeFuncProps examines the Go function 'fn' and computes for it
a function "properties" object, to be used to drive inlining
heuristics. See comments on the FuncProps type for more info.</p>
            
            <pre><code>func computeFuncProps(fn *ir.Func, inlineMaxBudget int, nf *nameFinder) (*FuncProps, CallSiteTab)</code></pre>
         </article>
         
         <article class="function" data-name="runAnalyzersOnFunction">
            <h2>runAnalyzersOnFunction</h2>
            <hr />
            
            <pre><code>func runAnalyzersOnFunction(fn *ir.Func, analyzers []propAnalyzer)</code></pre>
         </article>
         
         <article class="function" data-name="propsForFunc">
            <h2>propsForFunc</h2>
            <hr />
            
            <pre><code>func propsForFunc(fn *ir.Func) *FuncProps</code></pre>
         </article>
         
         <article class="function" data-name="fnFileLine">
            <h2>fnFileLine</h2>
            <hr />
            
            <pre><code>func fnFileLine(fn *ir.Func) (string, uint)</code></pre>
         </article>
         
         <article class="function" data-name="Enabled">
            <h2>Enabled</h2>
            <hr />
            
            <pre><code>func Enabled() bool</code></pre>
         </article>
         
         <article class="function" data-name="UnitTesting">
            <h2>UnitTesting</h2>
            <hr />
            
            <pre><code>func UnitTesting() bool</code></pre>
         </article>
         
         <article class="function" data-name="DumpFuncProps">
            <h2>DumpFuncProps</h2>
            <hr />
            
            <p>DumpFuncProps computes and caches function properties for the func
'fn', writing out a description of the previously computed set of
properties to the file given in 'dumpfile'. Used for the
"-d=dumpinlfuncprops=..." command line flag, intended for use
primarily in unit testing.</p>
            
            <pre><code>func DumpFuncProps(fn *ir.Func, dumpfile string)</code></pre>
         </article>
         
         <article class="function" data-name="emitDumpToFile">
            <h2>emitDumpToFile</h2>
            <hr />
            
            <p>emitDumpToFile writes out the buffer function property dump entries
to a file, for unit testing. Dump entries need to be sorted by
definition line, and due to generics we need to account for the
possibility that several ir.Func's will have the same def line.</p>
            
            <pre><code>func emitDumpToFile(dumpfile string)</code></pre>
         </article>
         
         <article class="function" data-name="captureFuncDumpEntry">
            <h2>captureFuncDumpEntry</h2>
            <hr />
            
            <p>captureFuncDumpEntry grabs the function properties object for 'fn'
and enqueues it for later dumping. Used for the
"-d=dumpinlfuncprops=..." command line flag, intended for use
primarily in unit testing.</p>
            
            <pre><code>func captureFuncDumpEntry(fn *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="dumpFilePreamble">
            <h2>dumpFilePreamble</h2>
            <hr />
            
            <p>dumpFilePreamble writes out a file-level preamble for a given
Go function as part of a function properties dump.</p>
            
            <pre><code>func dumpFilePreamble(w io.Writer)</code></pre>
         </article>
         
         <article class="function" data-name="dumpFnPreamble">
            <h2>dumpFnPreamble</h2>
            <hr />
            
            <p>dumpFnPreamble writes out a function-level preamble for a given
Go function as part of a function properties dump. See the
README.txt file in testdata/props for more on the format of
this preamble.</p>
            
            <pre><code>func dumpFnPreamble(w io.Writer, funcInlHeur *fnInlHeur, ecst encodedCallSiteTab, idx uint, atl uint) error</code></pre>
         </article>
         
         <article class="function" data-name="sortFnInlHeurSlice">
            <h2>sortFnInlHeurSlice</h2>
            <hr />
            
            <p>sortFnInlHeurSlice sorts a slice of fnInlHeur based on
the starting line of the function definition, then by name.</p>
            
            <pre><code>func sortFnInlHeurSlice(sl []fnInlHeur) []fnInlHeur</code></pre>
         </article>
         
         <article class="function" data-name="TestDumpCallSiteScoreDump">
            <h2>TestDumpCallSiteScoreDump</h2>
            <hr />
            
            <pre><code>func TestDumpCallSiteScoreDump(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="gatherInlCallSitesScoresForFile">
            <h2>gatherInlCallSitesScoresForFile</h2>
            <hr />
            
            <p>gatherInlCallSitesScoresForFile builds the specified testcase 'testcase'
from testdata/props passing the "-d=dumpinlcallsitescores=1"
compiler option, to produce a dump, then returns the path of the
newly created file.</p>
            
            <pre><code>func gatherInlCallSitesScoresForFile(t *testing.T, testcase string, td string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>func _()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>func _()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>func _()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="SerializeToString">
            <h2>SerializeToString</h2>
            <hr />
            
            <pre><code>func SerializeToString() string</code></pre>
         </article>
         
         <article class="function" data-name="DeserializeFromString">
            <h2>DeserializeFromString</h2>
            <hr />
            
            <pre><code>func DeserializeFromString(s string) *FuncProps</code></pre>
         </article>
         
         <article class="function" data-name="readULEB128">
            <h2>readULEB128</h2>
            <hr />
            
            <pre><code>func readULEB128(sl []byte) (value uint64, rsl []byte)</code></pre>
         </article>
         
         <article class="function" data-name="writeUleb128">
            <h2>writeUleb128</h2>
            <hr />
            
            <pre><code>func writeUleb128(sb *strings.Builder, v uint64)</code></pre>
         </article>
         
         <article class="function" data-name="enableDebugTrace">
            <h2>enableDebugTrace</h2>
            <hr />
            
            <pre><code>func enableDebugTrace(x int)</code></pre>
         </article>
         
         <article class="function" data-name="enableDebugTraceIfEnv">
            <h2>enableDebugTraceIfEnv</h2>
            <hr />
            
            <pre><code>func enableDebugTraceIfEnv()</code></pre>
         </article>
         
         <article class="function" data-name="disableDebugTrace">
            <h2>disableDebugTrace</h2>
            <hr />
            
            <pre><code>func disableDebugTrace()</code></pre>
         </article>
         
         <article class="function" data-name="getParams">
            <h2>getParams</h2>
            <hr />
            
            <p>getParams returns an *ir.Name slice containing all params for the
function (plus rcvr as well if applicable).</p>
            
            <pre><code>func getParams(fn *ir.Func) []*ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="addParamsAnalyzer">
            <h2>addParamsAnalyzer</h2>
            <hr />
            
            <p>addParamsAnalyzer creates a new paramsAnalyzer helper object for
the function fn, appends it to the analyzers list, and returns the
new list. If the function in question doesn't have any interesting
parameters then the analyzer list is returned unchanged, and the
params flags in "fp" are updated accordingly.</p>
            
            <pre><code>func addParamsAnalyzer(fn *ir.Func, analyzers []propAnalyzer, fp *FuncProps, nf *nameFinder) []propAnalyzer</code></pre>
         </article>
         
         <article class="function" data-name="makeParamsAnalyzer">
            <h2>makeParamsAnalyzer</h2>
            <hr />
            
            <p>makeParamsAnalyzer creates a new helper object to analyze parameters
of function fn. If the function doesn't have any interesting
params, a nil helper is returned along with a set of default param
flags for the func.</p>
            
            <pre><code>func makeParamsAnalyzer(fn *ir.Func, nf *nameFinder) (*paramsAnalyzer, []ParamPropBits)</code></pre>
         </article>
         
         <article class="function" data-name="setResults">
            <h2>setResults</h2>
            <hr />
            
            <pre><code>func setResults(funcProps *FuncProps)</code></pre>
         </article>
         
         <article class="function" data-name="findParamIdx">
            <h2>findParamIdx</h2>
            <hr />
            
            <pre><code>func findParamIdx(n *ir.Name) int</code></pre>
         </article>
         
         <article class="function" data-name="checkParams">
            <h2>checkParams</h2>
            <hr />
            
            <p>paramsAnalyzer invokes function 'testf' on the specified expression
'x' for each parameter, and if the result is TRUE, or's 'flag' into
the flags for that param.</p>
            
            <pre><code>func checkParams(x ir.Node, flag ParamPropBits, mayflag ParamPropBits, testf testfType)</code></pre>
         </article>
         
         <article class="function" data-name="foldCheckParams">
            <h2>foldCheckParams</h2>
            <hr />
            
            <p>foldCheckParams checks expression 'x' (an 'if' condition or
'switch' stmt expr) to see if the expr would fold away if a
specific parameter had a constant value.</p>
            
            <pre><code>func foldCheckParams(x ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="callCheckParams">
            <h2>callCheckParams</h2>
            <hr />
            
            <p>callCheckParams examines the target of call expression 'ce' to see
if it is making a call to the value passed in for some parameter.</p>
            
            <pre><code>func callCheckParams(ce *ir.CallExpr)</code></pre>
         </article>
         
         <article class="function" data-name="deriveFlagsFromCallee">
            <h2>deriveFlagsFromCallee</h2>
            <hr />
            
            <p>deriveFlagsFromCallee tries to derive flags for the current
function based on a call this function makes to some other
function. Example:

	/* Simple */                /* Derived from callee */
	func foo(f func(int)) {     func foo(f func(int)) {
	  f(2)                        bar(32, f)
	}                           }
	                            func bar(x int, f func()) {
	                              f(x)
	                            }

Here we can set the "param feeds indirect call" flag for
foo's param 'f' since we know that bar has that flag set for
its second param, and we're passing that param a function.</p>
            
            <pre><code>func deriveFlagsFromCallee(ce *ir.CallExpr, callee *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="nodeVisitPost">
            <h2>nodeVisitPost</h2>
            <hr />
            
            <pre><code>func nodeVisitPost(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="nodeVisitPre">
            <h2>nodeVisitPre</h2>
            <hr />
            
            <pre><code>func nodeVisitPre(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="pre">
            <h2>pre</h2>
            <hr />
            
            <pre><code>func pre(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="post">
            <h2>post</h2>
            <hr />
            
            <pre><code>func post(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="merge">
            <h2>merge</h2>
            <hr />
            
            <pre><code>func merge(other CallSiteTab) error</code></pre>
         </article>
         
         <article class="function" data-name="fmtFullPos">
            <h2>fmtFullPos</h2>
            <hr />
            
            <pre><code>func fmtFullPos(p src.XPos) string</code></pre>
         </article>
         
         <article class="function" data-name="EncodeCallSiteKey">
            <h2>EncodeCallSiteKey</h2>
            <hr />
            
            <pre><code>func EncodeCallSiteKey(cs *CallSite) string</code></pre>
         </article>
         
         <article class="function" data-name="buildEncodedCallSiteTab">
            <h2>buildEncodedCallSiteTab</h2>
            <hr />
            
            <pre><code>func buildEncodedCallSiteTab(tab CallSiteTab) encodedCallSiteTab</code></pre>
         </article>
         
         <article class="function" data-name="dumpCallSiteComments">
            <h2>dumpCallSiteComments</h2>
            <hr />
            
            <p>dumpCallSiteComments emits comments into the dump file for the
callsites in the function of interest. If "ecst" is non-nil, we use
that, otherwise generated a fresh encodedCallSiteTab from "tab".</p>
            
            <pre><code>func dumpCallSiteComments(w io.Writer, tab CallSiteTab, ecst encodedCallSiteTab)</code></pre>
         </article>
         
         <article class="function" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>func _()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
