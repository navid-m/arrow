<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - walk</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>walk</code>
         </h1>
         <hr />
         
         <article class="global" data-name="interfaceSwitchGen">
            <h2>interfaceSwitchGen</h2>
            <hr />
            
            <pre><code>interfaceSwitchGen int</code></pre>
         </article>
         
         <article class="global" data-name="rtypeHashField">
            <h2>rtypeHashField</h2>
            <hr />
            
            <pre><code>rtypeHashField *types.Field</code></pre>
         </article>
         
         <article class="global" data-name="itabHashField">
            <h2>itabHashField</h2>
            <hr />
            
            <pre><code>itabHashField *types.Field</code></pre>
         </article>
         
         <article class="global" data-name="tmpstringbufsize">
            <h2>tmpstringbufsize</h2>
            <hr />
            
            <p>The constant is known to runtime.</p>
            
            <pre><code>tmpstringbufsize</code></pre>
         </article>
         
         <article class="global" data-name="mapslow">
            <h2>mapslow</h2>
            <hr />
            
            <pre><code>mapslow</code></pre>
         </article>
         
         <article class="global" data-name="mapfast32">
            <h2>mapfast32</h2>
            <hr />
            
            <pre><code>mapfast32</code></pre>
         </article>
         
         <article class="global" data-name="mapfast32ptr">
            <h2>mapfast32ptr</h2>
            <hr />
            
            <pre><code>mapfast32ptr</code></pre>
         </article>
         
         <article class="global" data-name="mapfast64">
            <h2>mapfast64</h2>
            <hr />
            
            <pre><code>mapfast64</code></pre>
         </article>
         
         <article class="global" data-name="mapfast64ptr">
            <h2>mapfast64ptr</h2>
            <hr />
            
            <pre><code>mapfast64ptr</code></pre>
         </article>
         
         <article class="global" data-name="mapfaststr">
            <h2>mapfaststr</h2>
            <hr />
            
            <pre><code>mapfaststr</code></pre>
         </article>
         
         <article class="global" data-name="nmapfast">
            <h2>nmapfast</h2>
            <hr />
            
            <pre><code>nmapfast</code></pre>
         </article>
         
         <article class="global" data-name="mapaccess1">
            <h2>mapaccess1</h2>
            <hr />
            
            <pre><code>mapaccess1</code></pre>
         </article>
         
         <article class="global" data-name="mapaccess2">
            <h2>mapaccess2</h2>
            <hr />
            
            <pre><code>mapaccess2</code></pre>
         </article>
         
         <article class="global" data-name="mapassign">
            <h2>mapassign</h2>
            <hr />
            
            <pre><code>mapassign</code></pre>
         </article>
         
         <article class="global" data-name="mapdelete">
            <h2>mapdelete</h2>
            <hr />
            
            <pre><code>mapdelete</code></pre>
         </article>
         
         <article class="global" data-name="maxOpenDefers">
            <h2>maxOpenDefers</h2>
            <hr />
            
            <p>The max number of defers in a function using open-coded defers. We enforce this
limit because the deferBits bitmask is currently a single byte (to minimize code size)</p>
            
            <pre><code>maxOpenDefers</code></pre>
         </article>
         
         <article class="global" data-name="itabTypeField">
            <h2>itabTypeField</h2>
            <hr />
            
            <pre><code>itabTypeField *types.Field</code></pre>
         </article>
         
         <article class="global" data-name="inInitFunction">
            <h2>inInitFunction</h2>
            <hr />
            
            <pre><code>inInitFunction initContext</code></pre>
         </article>
         
         <article class="global" data-name="inNonInitFunction">
            <h2>inNonInitFunction</h2>
            <hr />
            
            <pre><code>inNonInitFunction</code></pre>
         </article>
         
         <article class="global" data-name="initDynamic">
            <h2>initDynamic</h2>
            <hr />
            
            <pre><code>initDynamic initGenType</code></pre>
         </article>
         
         <article class="global" data-name="initConst">
            <h2>initConst</h2>
            <hr />
            
            <pre><code>initConst</code></pre>
         </article>
         
         <article class="global" data-name="initKindStatic">
            <h2>initKindStatic</h2>
            <hr />
            
            <pre><code>initKindStatic initKind</code></pre>
         </article>
         
         <article class="global" data-name="initKindDynamic">
            <h2>initKindDynamic</h2>
            <hr />
            
            <pre><code>initKindDynamic</code></pre>
         </article>
         
         <article class="global" data-name="initKindLocalCode">
            <h2>initKindLocalCode</h2>
            <hr />
            
            <pre><code>initKindLocalCode</code></pre>
         </article>
         
         <article class="global" data-name="hooks">
            <h2>hooks</h2>
            <hr />
            
            <pre><code>hooks</code></pre>
         </article>
         
         <article class="global" data-name="typeAssertGen">
            <h2>typeAssertGen</h2>
            <hr />
            
            <pre><code>typeAssertGen int</code></pre>
         </article>
         
         <article class="global" data-name="scase">
            <h2>scase</h2>
            <hr />
            
            <pre><code>scase *types.Type</code></pre>
         </article>
         
         <article class="global" data-name="math_MulUintptr">
            <h2>math_MulUintptr</h2>
            <hr />
            
            <pre><code>math_MulUintptr</code></pre>
         </article>
          
         <article class="struct" data-name="orderState">
            <h2>type orderState struct</h2>
            <hr />
            
            <p>orderState holds state during the ordering process.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">out []ir.Node
temp []*ir.Name
free *ast.MapType
edit func</code></pre>
         </article>
         
         <article class="struct" data-name="exprSwitch">
            <h2>type exprSwitch struct</h2>
            <hr />
            
            <p>An exprSwitch walks an expression switch.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pos src.XPos
exprname ir.Node
done ir.Nodes
clauses []exprClause</code></pre>
         </article>
         
         <article class="struct" data-name="exprClause">
            <h2>type exprClause struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pos src.XPos
lo ir.Node
hi ir.Node
rtype ir.Node
jmp ir.Node</code></pre>
         </article>
         
         <article class="struct" data-name="typeSwitch">
            <h2>type typeSwitch struct</h2>
            <hr />
            
            <p>A typeSwitch walks a type switch.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">srcName ir.Node
hashName ir.Node
okName ir.Node
itabName ir.Node</code></pre>
         </article>
         
         <article class="struct" data-name="typeClause">
            <h2>type typeClause struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">hash uint32
body ir.Nodes</code></pre>
         </article>
         
         <article class="struct" data-name="hookInfo">
            <h2>type hookInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">paramType types.Kind
argsNum int
runtimeFunc string</code></pre>
         </article>
          
         <article class="function" data-name="walkConv">
            <h2>walkConv</h2>
            <hr />
            
            <p>walkConv walks an OCONV or OCONVNOP (but not OCONVIFACE) node.</p>
            
            <pre><code>func walkConv(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkConvInterface">
            <h2>walkConvInterface</h2>
            <hr />
            
            <p>walkConvInterface walks an OCONVIFACE node.</p>
            
            <pre><code>func walkConvInterface(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="dataWord">
            <h2>dataWord</h2>
            <hr />
            
            <p>Returns the data word (the second word) used to represent conv.X in
an interface.</p>
            
            <pre><code>func dataWord(conv *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkBytesRunesToString">
            <h2>walkBytesRunesToString</h2>
            <hr />
            
            <p>walkBytesRunesToString walks an OBYTES2STR or ORUNES2STR node.</p>
            
            <pre><code>func walkBytesRunesToString(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkBytesToStringTemp">
            <h2>walkBytesToStringTemp</h2>
            <hr />
            
            <p>walkBytesToStringTemp walks an OBYTES2STRTMP node.</p>
            
            <pre><code>func walkBytesToStringTemp(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkRuneToString">
            <h2>walkRuneToString</h2>
            <hr />
            
            <p>walkRuneToString walks an ORUNESTR node.</p>
            
            <pre><code>func walkRuneToString(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkStringToBytes">
            <h2>walkStringToBytes</h2>
            <hr />
            
            <p>walkStringToBytes walks an OSTR2BYTES node.</p>
            
            <pre><code>func walkStringToBytes(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkStringToBytesTemp">
            <h2>walkStringToBytesTemp</h2>
            <hr />
            
            <p>walkStringToBytesTemp walks an OSTR2BYTESTMP node.</p>
            
            <pre><code>func walkStringToBytesTemp(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkStringToRunes">
            <h2>walkStringToRunes</h2>
            <hr />
            
            <p>walkStringToRunes walks an OSTR2RUNES node.</p>
            
            <pre><code>func walkStringToRunes(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="dataWordFuncName">
            <h2>dataWordFuncName</h2>
            <hr />
            
            <p>dataWordFuncName returns the name of the function used to convert a value of type "from"
to the data word of an interface.
argType is the type the argument needs to be coerced to.
needsaddr reports whether the value should be passed (needaddr==false) or its address (needsaddr==true).</p>
            
            <pre><code>func dataWordFuncName(from *types.Type) (fnname string, argType *types.Type, needsaddr bool)</code></pre>
         </article>
         
         <article class="function" data-name="rtconvfn">
            <h2>rtconvfn</h2>
            <hr />
            
            <p>rtconvfn returns the parameter and result types that will be used by a
runtime function to convert from type src to type dst. The runtime function
name can be derived from the names of the returned types.

If no such function is necessary, it returns (Txxx, Txxx).</p>
            
            <pre><code>func rtconvfn(src *types.Type, dst *types.Type) (param types.Kind, result types.Kind)</code></pre>
         </article>
         
         <article class="function" data-name="soleComponent">
            <h2>soleComponent</h2>
            <hr />
            
            <pre><code>func soleComponent(init *ir.Nodes, n ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="byteindex">
            <h2>byteindex</h2>
            <hr />
            
            <p>byteindex converts n, which is byte-sized, to an int used to index into an array.
We cannot use conv, because we allow converting bool to int here,
which is forbidden in user code.</p>
            
            <pre><code>func byteindex(n ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkCheckPtrArithmetic">
            <h2>walkCheckPtrArithmetic</h2>
            <hr />
            
            <pre><code>func walkCheckPtrArithmetic(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkSliceToArray">
            <h2>walkSliceToArray</h2>
            <hr />
            
            <p>walkSliceToArray walks an OSLICE2ARR expression.</p>
            
            <pre><code>func walkSliceToArray(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="order">
            <h2>order</h2>
            <hr />
            
            <p>order rewrites fn.Nbody to apply the ordering constraints
described in the comment at the top of the file.</p>
            
            <pre><code>func order(fn *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="append">
            <h2>append</h2>
            <hr />
            
            <p>append typechecks stmt and appends it to out.</p>
            
            <pre><code>func append(stmt ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="newTemp">
            <h2>newTemp</h2>
            <hr />
            
            <p>newTemp allocates a new temporary with the given type,
pushes it onto the temp stack, and returns it.
If clear is true, newTemp emits code to zero the temporary.</p>
            
            <pre><code>func newTemp(t *types.Type, clear bool) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="copyExpr">
            <h2>copyExpr</h2>
            <hr />
            
            <p>copyExpr behaves like newTemp but also emits
code to initialize the temporary to the value n.</p>
            
            <pre><code>func copyExpr(n ir.Node) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="copyExprClear">
            <h2>copyExprClear</h2>
            <hr />
            
            <p>copyExprClear is like copyExpr but clears the temp before assignment.
It is provided for use when the evaluation of tmp = n turns into
a function call that is passed a pointer to the temporary as the output space.
If the call blocks before tmp has been written,
the garbage collector will still treat the temporary as live,
so we must zero it before entering that call.
Today, this only happens for channel receive operations.
(The other candidate would be map access, but map access
returns a pointer to the result data instead of taking a pointer
to be filled in.)</p>
            
            <pre><code>func copyExprClear(n ir.Node) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="copyExpr1">
            <h2>copyExpr1</h2>
            <hr />
            
            <pre><code>func copyExpr1(n ir.Node, clear bool) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="cheapExpr">
            <h2>cheapExpr</h2>
            <hr />
            
            <p>cheapExpr returns a cheap version of n.
The definition of cheap is that n is a variable or constant.
If not, cheapExpr allocates a new tmp, emits tmp = n,
and then returns tmp.</p>
            
            <pre><code>func cheapExpr(n ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="safeExpr">
            <h2>safeExpr</h2>
            <hr />
            
            <p>safeExpr returns a safe version of n.
The definition of safe is that n can appear multiple times
without violating the semantics of the original program,
and that assigning to the safe version has the same effect
as assigning to the original n.

The intended use is to apply to x when rewriting x += y into x = x + y.</p>
            
            <pre><code>func safeExpr(n ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="addrTemp">
            <h2>addrTemp</h2>
            <hr />
            
            <p>addrTemp ensures that n is okay to pass by address to runtime routines.
If the original argument n is not okay, addrTemp creates a tmp, emits
tmp = n, and then returns tmp.
The result of addrTemp MUST be assigned back to n, e.g.

	n.Left = o.addrTemp(n.Left)</p>
            
            <pre><code>func addrTemp(n ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="mapKeyTemp">
            <h2>mapKeyTemp</h2>
            <hr />
            
            <p>mapKeyTemp prepares n to be a key in a map runtime call and returns n.
The first parameter is the position of n's containing node, for use in case
that n's position is not unique (e.g., if n is an ONAME).</p>
            
            <pre><code>func mapKeyTemp(outerPos src.XPos, t *types.Type, n ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="mapKeyReplaceStrConv">
            <h2>mapKeyReplaceStrConv</h2>
            <hr />
            
            <p>mapKeyReplaceStrConv replaces OBYTES2STR by OBYTES2STRTMP
in n to avoid string allocations for keys in map lookups.
Returns a bool that signals if a modification was made.

For:

	x = m[string(k)]
	x = m[T1{... Tn{..., string(k), ...}}]

where k is []byte, T1 to Tn is a nesting of struct and array literals,
the allocation of backing bytes for the string can be avoided
by reusing the []byte backing array. These are special cases
for avoiding allocations when converting byte slices to strings.
It would be nice to handle these generally, but because
[]byte keys are not allowed in maps, the use of string(k)
comes up in important cases in practice. See issue 3512.</p>
            
            <pre><code>func mapKeyReplaceStrConv(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="markTemp">
            <h2>markTemp</h2>
            <hr />
            
            <p>markTemp returns the top of the temporary variable stack.</p>
            
            <pre><code>func markTemp() ordermarker</code></pre>
         </article>
         
         <article class="function" data-name="popTemp">
            <h2>popTemp</h2>
            <hr />
            
            <p>popTemp pops temporaries off the stack until reaching the mark,
which must have been returned by markTemp.</p>
            
            <pre><code>func popTemp(mark ordermarker)</code></pre>
         </article>
         
         <article class="function" data-name="stmtList">
            <h2>stmtList</h2>
            <hr />
            
            <p>stmtList orders each of the statements in the list.</p>
            
            <pre><code>func stmtList(l ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="orderMakeSliceCopy">
            <h2>orderMakeSliceCopy</h2>
            <hr />
            
            <p>orderMakeSliceCopy matches the pattern:

	m = OMAKESLICE([]T, x); OCOPY(m, s)

and rewrites it to:

	m = OMAKESLICECOPY([]T, x, s); nil</p>
            
            <pre><code>func orderMakeSliceCopy(s []ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="edge">
            <h2>edge</h2>
            <hr />
            
            <p>edge inserts coverage instrumentation for libfuzzer.</p>
            
            <pre><code>func edge()</code></pre>
         </article>
         
         <article class="function" data-name="orderBlock">
            <h2>orderBlock</h2>
            <hr />
            
            <p>orderBlock orders the block of statements in n into a new slice,
and then replaces the old slice in n with the new slice.
free is a map that can be used to obtain temporary variables by type.</p>
            
            <pre><code>func orderBlock(n *ir.Nodes, free *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="exprInPlace">
            <h2>exprInPlace</h2>
            <hr />
            
            <p>exprInPlace orders the side effects in *np and
leaves them as the init list of the final *np.
The result of exprInPlace MUST be assigned back to n, e.g.

	n.Left = o.exprInPlace(n.Left)</p>
            
            <pre><code>func exprInPlace(n ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="orderStmtInPlace">
            <h2>orderStmtInPlace</h2>
            <hr />
            
            <p>orderStmtInPlace orders the side effects of the single statement *np
and replaces it with the resulting statement list.
The result of orderStmtInPlace MUST be assigned back to n, e.g.

	n.Left = orderStmtInPlace(n.Left)

free is a map that can be used to obtain temporary variables by type.</p>
            
            <pre><code>func orderStmtInPlace(n ir.Node, free *ast.MapType) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <p>init moves n's init list to o.out.</p>
            
            <pre><code>func init(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="call">
            <h2>call</h2>
            <hr />
            
            <p>call orders the call expression n.
n.Op is OCALLFUNC/OCALLINTER or a builtin like OCOPY.</p>
            
            <pre><code>func call(nn ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="mapAssign">
            <h2>mapAssign</h2>
            <hr />
            
            <p>mapAssign appends n to o.out.</p>
            
            <pre><code>func mapAssign(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="safeMapRHS">
            <h2>safeMapRHS</h2>
            <hr />
            
            <pre><code>func safeMapRHS(r ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="stmt">
            <h2>stmt</h2>
            <hr />
            
            <p>stmt orders the statement n, appending to o.out.</p>
            
            <pre><code>func stmt(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="hasDefaultCase">
            <h2>hasDefaultCase</h2>
            <hr />
            
            <pre><code>func hasDefaultCase(n *ir.SwitchStmt) bool</code></pre>
         </article>
         
         <article class="function" data-name="exprList">
            <h2>exprList</h2>
            <hr />
            
            <p>exprList orders the expression list l into o.</p>
            
            <pre><code>func exprList(l ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="exprListInPlace">
            <h2>exprListInPlace</h2>
            <hr />
            
            <p>exprListInPlace orders the expression list l but saves
the side effects on the individual expression ninit lists.</p>
            
            <pre><code>func exprListInPlace(l ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="exprNoLHS">
            <h2>exprNoLHS</h2>
            <hr />
            
            <pre><code>func exprNoLHS(n ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="expr">
            <h2>expr</h2>
            <hr />
            
            <p>expr orders a single expression, appending side
effects to o.out as needed.
If this is part of an assignment lhs = *np, lhs is given.
Otherwise lhs == nil. (When lhs != nil it may be possible
to avoid copying the result of the expression to a temporary.)
The result of expr MUST be assigned back to n, e.g.

	n.Left = o.expr(n.Left, lhs)</p>
            
            <pre><code>func expr(n ir.Node, lhs ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="expr1">
            <h2>expr1</h2>
            <hr />
            
            <pre><code>func expr1(n ir.Node, lhs ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="as2func">
            <h2>as2func</h2>
            <hr />
            
            <p>as2func orders OAS2FUNC nodes. It creates temporaries to ensure left-to-right assignment.
The caller should order the right-hand side of the assignment before calling order.as2func.
It rewrites,

	a, b, a = ...

as

	tmp1, tmp2, tmp3 = ...
	a, b, a = tmp1, tmp2, tmp3

This is necessary to ensure left to right assignment order.</p>
            
            <pre><code>func as2func(n *ir.AssignListStmt)</code></pre>
         </article>
         
         <article class="function" data-name="as2ok">
            <h2>as2ok</h2>
            <hr />
            
            <p>as2ok orders OAS2XXX with ok.
Just like as2func, this also adds temporaries to ensure left-to-right assignment.</p>
            
            <pre><code>func as2ok(n *ir.AssignListStmt)</code></pre>
         </article>
         
         <article class="function" data-name="walkSwitch">
            <h2>walkSwitch</h2>
            <hr />
            
            <p>walkSwitch walks a switch statement.</p>
            
            <pre><code>func walkSwitch(sw *ir.SwitchStmt)</code></pre>
         </article>
         
         <article class="function" data-name="walkSwitchExpr">
            <h2>walkSwitchExpr</h2>
            <hr />
            
            <p>walkSwitchExpr generates an AST implementing sw.  sw is an
expression switch.</p>
            
            <pre><code>func walkSwitchExpr(sw *ir.SwitchStmt)</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <pre><code>func Add(pos src.XPos, expr ir.Node, rtype ir.Node, jmp ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="Emit">
            <h2>Emit</h2>
            <hr />
            
            <pre><code>func Emit(out *ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="flush">
            <h2>flush</h2>
            <hr />
            
            <pre><code>func flush()</code></pre>
         </article>
         
         <article class="function" data-name="search">
            <h2>search</h2>
            <hr />
            
            <pre><code>func search(cc []exprClause, out *ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="tryJumpTable">
            <h2>tryJumpTable</h2>
            <hr />
            
            <p>Try to implement the clauses with a jump table. Returns true if successful.</p>
            
            <pre><code>func tryJumpTable(cc []exprClause, out *ir.Nodes) bool</code></pre>
         </article>
         
         <article class="function" data-name="test">
            <h2>test</h2>
            <hr />
            
            <pre><code>func test(exprname ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="allCaseExprsAreSideEffectFree">
            <h2>allCaseExprsAreSideEffectFree</h2>
            <hr />
            
            <pre><code>func allCaseExprsAreSideEffectFree(sw *ir.SwitchStmt) bool</code></pre>
         </article>
         
         <article class="function" data-name="endsInFallthrough">
            <h2>endsInFallthrough</h2>
            <hr />
            
            <p>endsInFallthrough reports whether stmts ends with a "fallthrough" statement.</p>
            
            <pre><code>func endsInFallthrough(stmts []ir.Node) (bool, src.XPos)</code></pre>
         </article>
         
         <article class="function" data-name="walkSwitchType">
            <h2>walkSwitchType</h2>
            <hr />
            
            <p>walkSwitchType generates an AST that implements sw, where sw is a
type switch.</p>
            
            <pre><code>func walkSwitchType(sw *ir.SwitchStmt)</code></pre>
         </article>
         
         <article class="function" data-name="typeHashFieldOf">
            <h2>typeHashFieldOf</h2>
            <hr />
            
            <p>typeHashFieldOf returns an expression to select the type hash field
from an interface's descriptor word (whether a *runtime._type or
*runtime.itab pointer).</p>
            
            <pre><code>func typeHashFieldOf(pos src.XPos, itab *ir.UnaryExpr) *ir.SelectorExpr</code></pre>
         </article>
         
         <article class="function" data-name="flush">
            <h2>flush</h2>
            <hr />
            
            <pre><code>func flush(cc []typeClause, compiled *ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="tryJumpTable">
            <h2>tryJumpTable</h2>
            <hr />
            
            <p>Try to implement the clauses with a jump table. Returns true if successful.</p>
            
            <pre><code>func tryJumpTable(cc []typeClause, out *ir.Nodes) bool</code></pre>
         </article>
         
         <article class="function" data-name="binarySearch">
            <h2>binarySearch</h2>
            <hr />
            
            <p>binarySearch constructs a binary search tree for handling n cases,
and appends it to out. It's used for efficiently implementing
switch statements.

less(i) should return a boolean expression. If it evaluates true,
then cases before i will be tested; otherwise, cases i and later.

leaf(i, nif) should setup nif (an OIF node) to test case i. In
particular, it should set nif.Cond and nif.Body.</p>
            
            <pre><code>func binarySearch(n int, out *ir.Nodes, less func, leaf func)</code></pre>
         </article>
         
         <article class="function" data-name="stringSearch">
            <h2>stringSearch</h2>
            <hr />
            
            <pre><code>func stringSearch(expr ir.Node, cc []exprClause, out *ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="Walk">
            <h2>Walk</h2>
            <hr />
            
            <pre><code>func Walk(fn *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="walkRecv">
            <h2>walkRecv</h2>
            <hr />
            
            <p>walkRecv walks an ORECV node.</p>
            
            <pre><code>func walkRecv(n *ir.UnaryExpr) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="convas">
            <h2>convas</h2>
            <hr />
            
            <pre><code>func convas(n *ir.AssignStmt, init *ir.Nodes) *ir.AssignStmt</code></pre>
         </article>
         
         <article class="function" data-name="vmkcall">
            <h2>vmkcall</h2>
            <hr />
            
            <pre><code>func vmkcall(fn ir.Node, t *types.Type, init *ir.Nodes, va []ir.Node) *ir.CallExpr</code></pre>
         </article>
         
         <article class="function" data-name="mkcall">
            <h2>mkcall</h2>
            <hr />
            
            <pre><code>func mkcall(name string, t *types.Type, init *ir.Nodes, args ...ir.Node) *ir.CallExpr</code></pre>
         </article>
         
         <article class="function" data-name="mkcallstmt">
            <h2>mkcallstmt</h2>
            <hr />
            
            <pre><code>func mkcallstmt(name string, args ...ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="mkcall1">
            <h2>mkcall1</h2>
            <hr />
            
            <pre><code>func mkcall1(fn ir.Node, t *types.Type, init *ir.Nodes, args ...ir.Node) *ir.CallExpr</code></pre>
         </article>
         
         <article class="function" data-name="mkcallstmt1">
            <h2>mkcallstmt1</h2>
            <hr />
            
            <pre><code>func mkcallstmt1(fn ir.Node, args ...ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="chanfn">
            <h2>chanfn</h2>
            <hr />
            
            <pre><code>func chanfn(name string, n int, t *types.Type) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="mapfn">
            <h2>mapfn</h2>
            <hr />
            
            <pre><code>func mapfn(name string, t *types.Type, isfat bool) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="mapfndel">
            <h2>mapfndel</h2>
            <hr />
            
            <pre><code>func mapfndel(name string, t *types.Type) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="mkmapnames">
            <h2>mkmapnames</h2>
            <hr />
            
            <pre><code>func mkmapnames(base string, ptr string) mapnames</code></pre>
         </article>
         
         <article class="function" data-name="mapfast">
            <h2>mapfast</h2>
            <hr />
            
            <pre><code>func mapfast(t *types.Type) int</code></pre>
         </article>
         
         <article class="function" data-name="mapfastSwiss">
            <h2>mapfastSwiss</h2>
            <hr />
            
            <pre><code>func mapfastSwiss(t *types.Type) int</code></pre>
         </article>
         
         <article class="function" data-name="mapfastOld">
            <h2>mapfastOld</h2>
            <hr />
            
            <pre><code>func mapfastOld(t *types.Type) int</code></pre>
         </article>
         
         <article class="function" data-name="walkAppendArgs">
            <h2>walkAppendArgs</h2>
            <hr />
            
            <pre><code>func walkAppendArgs(n *ir.CallExpr, init *ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="appendWalkStmt">
            <h2>appendWalkStmt</h2>
            <hr />
            
            <p>appendWalkStmt typechecks and walks stmt and then appends it to init.</p>
            
            <pre><code>func appendWalkStmt(init *ir.Nodes, stmt ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="backingArrayPtrLen">
            <h2>backingArrayPtrLen</h2>
            <hr />
            
            <p>backingArrayPtrLen extracts the pointer and length from a slice or string.
This constructs two nodes referring to n, so n must be a cheapExpr.</p>
            
            <pre><code>func backingArrayPtrLen(n ir.Node) (ptr ir.Node, length ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="mayCall">
            <h2>mayCall</h2>
            <hr />
            
            <p>mayCall reports whether evaluating expression n may require
function calls, which could clobber function call arguments/results
currently on the stack.</p>
            
            <pre><code>func mayCall(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="itabType">
            <h2>itabType</h2>
            <hr />
            
            <p>itabType loads the _type field from a runtime.itab struct.</p>
            
            <pre><code>func itabType(itab ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="boundedDotPtr">
            <h2>boundedDotPtr</h2>
            <hr />
            
            <p>boundedDotPtr returns a selector expression representing ptr.field
and omits nil-pointer checks for ptr.</p>
            
            <pre><code>func boundedDotPtr(pos src.XPos, ptr ir.Node, field *types.Field) *ir.SelectorExpr</code></pre>
         </article>
         
         <article class="function" data-name="runtimeField">
            <h2>runtimeField</h2>
            <hr />
            
            <pre><code>func runtimeField(name string, offset int64, typ *types.Type) *types.Field</code></pre>
         </article>
         
         <article class="function" data-name="ifaceData">
            <h2>ifaceData</h2>
            <hr />
            
            <p>ifaceData loads the data field from an interface.
The concrete type must be known to have type t.
It follows the pointer if !IsDirectIface(t).</p>
            
            <pre><code>func ifaceData(pos src.XPos, n ir.Node, t *types.Type) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="directClosureCall">
            <h2>directClosureCall</h2>
            <hr />
            
            <p>directClosureCall rewrites a direct call of a function literal into
a normal function call with closure variables passed as arguments.
This avoids allocation of a closure object.

For illustration, the following call:

	func(a int) {
		println(byval)
		byref++
	}(42)

becomes:

	func(byval int, &byref *int, a int) {
		println(byval)
		(*&byref)++
	}(byval, &byref, 42)</p>
            
            <pre><code>func directClosureCall(n *ir.CallExpr)</code></pre>
         </article>
         
         <article class="function" data-name="walkClosure">
            <h2>walkClosure</h2>
            <hr />
            
            <pre><code>func walkClosure(clo *ir.ClosureExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="closureArgs">
            <h2>closureArgs</h2>
            <hr />
            
            <p>closureArgs returns a slice of expressions that can be used to
initialize the given closure's free variables. These correspond
one-to-one with the variables in clo.Func.ClosureVars, and will be
either an ONAME node (if the variable is captured by value) or an
OADDR-of-ONAME node (if not).</p>
            
            <pre><code>func closureArgs(clo *ir.ClosureExpr) []ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkMethodValue">
            <h2>walkMethodValue</h2>
            <hr />
            
            <pre><code>func walkMethodValue(n *ir.SelectorExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="methodValueWrapper">
            <h2>methodValueWrapper</h2>
            <hr />
            
            <p>methodValueWrapper returns the ONAME node representing the
wrapper function (*-fm) needed for the given method value. If the
wrapper function hasn't already been created yet, it's created and
added to typecheck.Target.Decls.</p>
            
            <pre><code>func methodValueWrapper(dot *ir.SelectorExpr) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="fakePC">
            <h2>fakePC</h2>
            <hr />
            
            <pre><code>func fakePC(n ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkCompare">
            <h2>walkCompare</h2>
            <hr />
            
            <p>The result of walkCompare MUST be assigned back to n, e.g.

	n.Left = walkCompare(n.Left, init)</p>
            
            <pre><code>func walkCompare(n *ir.BinaryExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkCompareInterface">
            <h2>walkCompareInterface</h2>
            <hr />
            
            <pre><code>func walkCompareInterface(n *ir.BinaryExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkCompareString">
            <h2>walkCompareString</h2>
            <hr />
            
            <pre><code>func walkCompareString(n *ir.BinaryExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="finishCompare">
            <h2>finishCompare</h2>
            <hr />
            
            <p>The result of finishCompare MUST be assigned back to n, e.g.

	n.Left = finishCompare(n.Left, x, r, init)</p>
            
            <pre><code>func finishCompare(n *ir.BinaryExpr, r ir.Node, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="brcom">
            <h2>brcom</h2>
            <hr />
            
            <p>brcom returns !(op).
For example, brcom(==) is !=.</p>
            
            <pre><code>func brcom(op ir.Op) ir.Op</code></pre>
         </article>
         
         <article class="function" data-name="brrev">
            <h2>brrev</h2>
            <hr />
            
            <p>brrev returns reverse(op).
For example, Brrev(<) is >.</p>
            
            <pre><code>func brrev(op ir.Op) ir.Op</code></pre>
         </article>
         
         <article class="function" data-name="tracecmpArg">
            <h2>tracecmpArg</h2>
            <hr />
            
            <pre><code>func tracecmpArg(n ir.Node, t *types.Type, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkCompLit">
            <h2>walkCompLit</h2>
            <hr />
            
            <p>walkCompLit walks a composite literal node:
OARRAYLIT, OSLICELIT, OMAPLIT, OSTRUCTLIT (all CompLitExpr), or OPTRLIT (AddrExpr).</p>
            
            <pre><code>func walkCompLit(n ir.Node, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="readonlystaticname">
            <h2>readonlystaticname</h2>
            <hr />
            
            <p>readonlystaticname returns a name backed by a read-only static data symbol.</p>
            
            <pre><code>func readonlystaticname(t *types.Type) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="isSimpleName">
            <h2>isSimpleName</h2>
            <hr />
            
            <pre><code>func isSimpleName(nn ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="getdyn">
            <h2>getdyn</h2>
            <hr />
            
            <p>getdyn calculates the initGenType for n.
If top is false, getdyn is recursing.</p>
            
            <pre><code>func getdyn(n ir.Node, top bool) initGenType</code></pre>
         </article>
         
         <article class="function" data-name="isStaticCompositeLiteral">
            <h2>isStaticCompositeLiteral</h2>
            <hr />
            
            <p>isStaticCompositeLiteral reports whether n is a compile-time constant.</p>
            
            <pre><code>func isStaticCompositeLiteral(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="fixedlit">
            <h2>fixedlit</h2>
            <hr />
            
            <p>fixedlit handles struct, array, and slice literals.
TODO: expand documentation.</p>
            
            <pre><code>func fixedlit(ctxt initContext, kind initKind, n *ir.CompLitExpr, var_ ir.Node, init *ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="isSmallSliceLit">
            <h2>isSmallSliceLit</h2>
            <hr />
            
            <pre><code>func isSmallSliceLit(n *ir.CompLitExpr) bool</code></pre>
         </article>
         
         <article class="function" data-name="slicelit">
            <h2>slicelit</h2>
            <hr />
            
            <pre><code>func slicelit(ctxt initContext, n *ir.CompLitExpr, var_ ir.Node, init *ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="maplit">
            <h2>maplit</h2>
            <hr />
            
            <pre><code>func maplit(n *ir.CompLitExpr, m ir.Node, init *ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="anylit">
            <h2>anylit</h2>
            <hr />
            
            <pre><code>func anylit(n ir.Node, var_ ir.Node, init *ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="oaslit">
            <h2>oaslit</h2>
            <hr />
            
            <p>oaslit handles special composite literal assignments.
It returns true if n's effects have been added to init,
in which case n should be dropped from the program by the caller.</p>
            
            <pre><code>func oaslit(n *ir.AssignStmt, init *ir.Nodes) bool</code></pre>
         </article>
         
         <article class="function" data-name="genAsStatic">
            <h2>genAsStatic</h2>
            <hr />
            
            <pre><code>func genAsStatic(as *ir.AssignStmt)</code></pre>
         </article>
         
         <article class="function" data-name="walkExpr">
            <h2>walkExpr</h2>
            <hr />
            
            <p>The result of walkExpr MUST be assigned back to n, e.g.

	n.Left = walkExpr(n.Left, init)</p>
            
            <pre><code>func walkExpr(n ir.Node, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkExpr1">
            <h2>walkExpr1</h2>
            <hr />
            
            <pre><code>func walkExpr1(n ir.Node, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkExprList">
            <h2>walkExprList</h2>
            <hr />
            
            <p>walk the whole tree of the body of an
expression or simple statement.
the types expressions are calculated.
compile-time constants are evaluated.
complex side effects like statements are appended to init.</p>
            
            <pre><code>func walkExprList(s []ir.Node, init *ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="walkExprListCheap">
            <h2>walkExprListCheap</h2>
            <hr />
            
            <pre><code>func walkExprListCheap(s []ir.Node, init *ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="walkExprListSafe">
            <h2>walkExprListSafe</h2>
            <hr />
            
            <pre><code>func walkExprListSafe(s []ir.Node, init *ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="cheapExpr">
            <h2>cheapExpr</h2>
            <hr />
            
            <p>return side-effect free and cheap n, appending side effects to init.
result may not be assignable.</p>
            
            <pre><code>func cheapExpr(n ir.Node, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="safeExpr">
            <h2>safeExpr</h2>
            <hr />
            
            <p>return side effect-free n, appending side effects to init.
result is assignable if n is.</p>
            
            <pre><code>func safeExpr(n ir.Node, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="copyExpr">
            <h2>copyExpr</h2>
            <hr />
            
            <pre><code>func copyExpr(n ir.Node, t *types.Type, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkAddString">
            <h2>walkAddString</h2>
            <hr />
            
            <pre><code>func walkAddString(typ *types.Type, n *ir.AddStringExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkCall">
            <h2>walkCall</h2>
            <hr />
            
            <p>walkCall walks an OCALLFUNC or OCALLINTER node.</p>
            
            <pre><code>func walkCall(n *ir.CallExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkCall1">
            <h2>walkCall1</h2>
            <hr />
            
            <pre><code>func walkCall1(n *ir.CallExpr, init *ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="walkDivMod">
            <h2>walkDivMod</h2>
            <hr />
            
            <p>walkDivMod walks an ODIV or OMOD node.</p>
            
            <pre><code>func walkDivMod(n *ir.BinaryExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkDot">
            <h2>walkDot</h2>
            <hr />
            
            <p>walkDot walks an ODOT or ODOTPTR node.</p>
            
            <pre><code>func walkDot(n *ir.SelectorExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkDotType">
            <h2>walkDotType</h2>
            <hr />
            
            <p>walkDotType walks an ODOTTYPE or ODOTTYPE2 node.</p>
            
            <pre><code>func walkDotType(n *ir.TypeAssertExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="makeTypeAssertDescriptor">
            <h2>makeTypeAssertDescriptor</h2>
            <hr />
            
            <pre><code>func makeTypeAssertDescriptor(target *types.Type, canFail bool) *obj.LSym</code></pre>
         </article>
         
         <article class="function" data-name="walkDynamicDotType">
            <h2>walkDynamicDotType</h2>
            <hr />
            
            <p>walkDynamicDotType walks an ODYNAMICDOTTYPE or ODYNAMICDOTTYPE2 node.</p>
            
            <pre><code>func walkDynamicDotType(n *ir.DynamicTypeAssertExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkIndex">
            <h2>walkIndex</h2>
            <hr />
            
            <p>walkIndex walks an OINDEX node.</p>
            
            <pre><code>func walkIndex(n *ir.IndexExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="mapKeyArg">
            <h2>mapKeyArg</h2>
            <hr />
            
            <p>mapKeyArg returns an expression for key that is suitable to be passed
as the key argument for runtime map* functions.
n is the map indexing or delete Node (to provide Pos).</p>
            
            <pre><code>func mapKeyArg(fast int, n ir.Node, key ir.Node, assigned bool) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkIndexMap">
            <h2>walkIndexMap</h2>
            <hr />
            
            <p>walkIndexMap walks an OINDEXMAP node.
It replaces m[k] with *map{access1,assign}(maptype, m, &k)</p>
            
            <pre><code>func walkIndexMap(n *ir.IndexExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkLogical">
            <h2>walkLogical</h2>
            <hr />
            
            <p>walkLogical walks an OANDAND or OOROR node.</p>
            
            <pre><code>func walkLogical(n *ir.LogicalExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkSend">
            <h2>walkSend</h2>
            <hr />
            
            <p>walkSend walks an OSEND node.</p>
            
            <pre><code>func walkSend(n *ir.SendStmt, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkSlice">
            <h2>walkSlice</h2>
            <hr />
            
            <p>walkSlice walks an OSLICE, OSLICEARR, OSLICESTR, OSLICE3, or OSLICE3ARR node.</p>
            
            <pre><code>func walkSlice(n *ir.SliceExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkSliceHeader">
            <h2>walkSliceHeader</h2>
            <hr />
            
            <p>walkSliceHeader walks an OSLICEHEADER node.</p>
            
            <pre><code>func walkSliceHeader(n *ir.SliceHeaderExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkStringHeader">
            <h2>walkStringHeader</h2>
            <hr />
            
            <p>walkStringHeader walks an OSTRINGHEADER node.</p>
            
            <pre><code>func walkStringHeader(n *ir.StringHeaderExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="bounded">
            <h2>bounded</h2>
            <hr />
            
            <p>return 1 if integer n must be in range [0, max), 0 otherwise.</p>
            
            <pre><code>func bounded(n ir.Node, max int64) bool</code></pre>
         </article>
         
         <article class="function" data-name="usemethod">
            <h2>usemethod</h2>
            <hr />
            
            <p>usemethod checks calls for uses of Method and MethodByName of reflect.Value,
reflect.Type, reflect.(*rtype), and reflect.(*interfaceType).</p>
            
            <pre><code>func usemethod(n *ir.CallExpr)</code></pre>
         </article>
         
         <article class="function" data-name="usefield">
            <h2>usefield</h2>
            <hr />
            
            <pre><code>func usefield(n *ir.SelectorExpr)</code></pre>
         </article>
         
         <article class="function" data-name="cheapComputableIndex">
            <h2>cheapComputableIndex</h2>
            <hr />
            
            <pre><code>func cheapComputableIndex(width int64) bool</code></pre>
         </article>
         
         <article class="function" data-name="walkRange">
            <h2>walkRange</h2>
            <hr />
            
            <p>walkRange transforms various forms of ORANGE into
simpler forms.  The result must be assigned back to n.
Node n may also be modified in place, and may also be
the returned node.</p>
            
            <pre><code>func walkRange(nrange *ir.RangeStmt) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="rangeAssign">
            <h2>rangeAssign</h2>
            <hr />
            
            <p>rangeAssign returns "n.Key = key".</p>
            
            <pre><code>func rangeAssign(n *ir.RangeStmt, key ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="rangeAssign2">
            <h2>rangeAssign2</h2>
            <hr />
            
            <p>rangeAssign2 returns "n.Key, n.Value = key, value".</p>
            
            <pre><code>func rangeAssign2(n *ir.RangeStmt, key ir.Node, value ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="rangeConvert">
            <h2>rangeConvert</h2>
            <hr />
            
            <p>rangeConvert returns src, converted to dst if necessary. If a
conversion is necessary, then typeWord and srcRType are copied to
their respective ConvExpr fields.</p>
            
            <pre><code>func rangeConvert(nrange *ir.RangeStmt, dst *types.Type, src ir.Node, typeWord ir.Node, srcRType ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="isMapClear">
            <h2>isMapClear</h2>
            <hr />
            
            <p>isMapClear checks if n is of the form:

	for k := range m {
		delete(m, k)
	}

where == for keys of map m is reflexive.</p>
            
            <pre><code>func isMapClear(n *ir.RangeStmt) bool</code></pre>
         </article>
         
         <article class="function" data-name="mapRangeClear">
            <h2>mapRangeClear</h2>
            <hr />
            
            <p>mapRangeClear constructs a call to runtime.mapclear for the map range idiom.</p>
            
            <pre><code>func mapRangeClear(nrange *ir.RangeStmt) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="mapClear">
            <h2>mapClear</h2>
            <hr />
            
            <p>mapClear constructs a call to runtime.mapclear for the map m.</p>
            
            <pre><code>func mapClear(m ir.Node, rtyp ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="arrayRangeClear">
            <h2>arrayRangeClear</h2>
            <hr />
            
            <p>Lower n into runtime·memclr if possible, for
fast zeroing of slices and arrays (issue 5373).
Look for instances of

	for i := range a {
		a[i] = zero
	}

in which the evaluation of a is side-effect-free.

Parameters are as in walkRange: "for v1, v2 = range a".</p>
            
            <pre><code>func arrayRangeClear(loop *ir.RangeStmt, v1 ir.Node, v2 ir.Node, a ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="arrayClear">
            <h2>arrayClear</h2>
            <hr />
            
            <p>arrayClear constructs a call to runtime.memclr for fast zeroing of slices and arrays.</p>
            
            <pre><code>func arrayClear(wbPos src.XPos, a ir.Node, nrange *ir.RangeStmt) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkSelect">
            <h2>walkSelect</h2>
            <hr />
            
            <pre><code>func walkSelect(sel *ir.SelectStmt)</code></pre>
         </article>
         
         <article class="function" data-name="walkSelectCases">
            <h2>walkSelectCases</h2>
            <hr />
            
            <pre><code>func walkSelectCases(cases []*ir.CommClause) []ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="bytePtrToIndex">
            <h2>bytePtrToIndex</h2>
            <hr />
            
            <p>bytePtrToIndex returns a Node representing "(*byte)(&n[i])".</p>
            
            <pre><code>func bytePtrToIndex(n ir.Node, i int64) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="scasetype">
            <h2>scasetype</h2>
            <hr />
            
            <p>Keep in sync with src/runtime/select.go.</p>
            
            <pre><code>func scasetype() *types.Type</code></pre>
         </article>
         
         <article class="function" data-name="walkStmt">
            <h2>walkStmt</h2>
            <hr />
            
            <p>The result of walkStmt MUST be assigned back to n, e.g.

	n.Left = walkStmt(n.Left)</p>
            
            <pre><code>func walkStmt(n ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkStmtList">
            <h2>walkStmtList</h2>
            <hr />
            
            <pre><code>func walkStmtList(s []ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="walkFor">
            <h2>walkFor</h2>
            <hr />
            
            <p>walkFor walks an OFOR node.</p>
            
            <pre><code>func walkFor(n *ir.ForStmt) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="validGoDeferCall">
            <h2>validGoDeferCall</h2>
            <hr />
            
            <p>validGoDeferCall reports whether call is a valid call to appear in
a go or defer statement; that is, whether it's a regular function
call without arguments or results.</p>
            
            <pre><code>func validGoDeferCall(call ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="walkGoDefer">
            <h2>walkGoDefer</h2>
            <hr />
            
            <p>walkGoDefer walks an OGO or ODEFER node.</p>
            
            <pre><code>func walkGoDefer(n *ir.GoDeferStmt) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkIf">
            <h2>walkIf</h2>
            <hr />
            
            <p>walkIf walks an OIF node.</p>
            
            <pre><code>func walkIf(n *ir.IfStmt) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="initStackTemp">
            <h2>initStackTemp</h2>
            <hr />
            
            <p>initStackTemp appends statements to init to initialize the given
temporary variable to val, and then returns the expression &tmp.</p>
            
            <pre><code>func initStackTemp(init *ir.Nodes, tmp *ir.Name, val ir.Node) *ir.AddrExpr</code></pre>
         </article>
         
         <article class="function" data-name="stackTempAddr">
            <h2>stackTempAddr</h2>
            <hr />
            
            <p>stackTempAddr returns the expression &tmp, where tmp is a newly
allocated temporary variable of the given type. Statements to
zero-initialize tmp are appended to init.</p>
            
            <pre><code>func stackTempAddr(init *ir.Nodes, typ *types.Type) *ir.AddrExpr</code></pre>
         </article>
         
         <article class="function" data-name="stackBufAddr">
            <h2>stackBufAddr</h2>
            <hr />
            
            <p>stackBufAddr returns the expression &tmp, where tmp is a newly
allocated temporary variable of type [len]elem. This variable is
initialized, and elem must not contain pointers.</p>
            
            <pre><code>func stackBufAddr(len int64, elem *types.Type) *ir.AddrExpr</code></pre>
         </article>
         
         <article class="function" data-name="walkAssign">
            <h2>walkAssign</h2>
            <hr />
            
            <p>walkAssign walks an OAS (AssignExpr) or OASOP (AssignOpExpr) node.</p>
            
            <pre><code>func walkAssign(init *ir.Nodes, n ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkAssignDotType">
            <h2>walkAssignDotType</h2>
            <hr />
            
            <p>walkAssignDotType walks an OAS2DOTTYPE node.</p>
            
            <pre><code>func walkAssignDotType(n *ir.AssignListStmt, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkAssignFunc">
            <h2>walkAssignFunc</h2>
            <hr />
            
            <p>walkAssignFunc walks an OAS2FUNC node.</p>
            
            <pre><code>func walkAssignFunc(init *ir.Nodes, n *ir.AssignListStmt) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkAssignList">
            <h2>walkAssignList</h2>
            <hr />
            
            <p>walkAssignList walks an OAS2 node.</p>
            
            <pre><code>func walkAssignList(init *ir.Nodes, n *ir.AssignListStmt) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkAssignMapRead">
            <h2>walkAssignMapRead</h2>
            <hr />
            
            <p>walkAssignMapRead walks an OAS2MAPR node.</p>
            
            <pre><code>func walkAssignMapRead(init *ir.Nodes, n *ir.AssignListStmt) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkAssignRecv">
            <h2>walkAssignRecv</h2>
            <hr />
            
            <p>walkAssignRecv walks an OAS2RECV node.</p>
            
            <pre><code>func walkAssignRecv(init *ir.Nodes, n *ir.AssignListStmt) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkReturn">
            <h2>walkReturn</h2>
            <hr />
            
            <p>walkReturn walks an ORETURN node.</p>
            
            <pre><code>func walkReturn(n *ir.ReturnStmt) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="ascompatet">
            <h2>ascompatet</h2>
            <hr />
            
            <p>check assign type list to
an expression list. called in

	expr-list = func()</p>
            
            <pre><code>func ascompatet(nl ir.Nodes, nr *types.Type) []ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="ascompatee">
            <h2>ascompatee</h2>
            <hr />
            
            <p>check assign expression list to
an expression list. called in

	expr-list = expr-list</p>
            
            <pre><code>func ascompatee(op ir.Op, nl []ir.Node, nr []ir.Node) []ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="readsMemory">
            <h2>readsMemory</h2>
            <hr />
            
            <p>readsMemory reports whether the evaluation n directly reads from
memory that might be written to indirectly.</p>
            
            <pre><code>func readsMemory(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="appendSlice">
            <h2>appendSlice</h2>
            <hr />
            
            <p>expand append(l1, l2...) to

	init {
	  s := l1
	  newLen := s.len + l2.len
	  // Compare as uint so growslice can panic on overflow.
	  if uint(newLen) <= uint(s.cap) {
	    s = s[:newLen]
	  } else {
	    s = growslice(s.ptr, s.len, s.cap, l2.len, T)
	  }
	  memmove(&s[s.len-l2.len], &l2[0], l2.len*sizeof(T))
	}
	s

l2 is allowed to be a string.</p>
            
            <pre><code>func appendSlice(n *ir.CallExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="isAppendOfMake">
            <h2>isAppendOfMake</h2>
            <hr />
            
            <p>isAppendOfMake reports whether n is of the form append(x, make([]T, y)...).
isAppendOfMake assumes n has already been typechecked.</p>
            
            <pre><code>func isAppendOfMake(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="extendSlice">
            <h2>extendSlice</h2>
            <hr />
            
            <pre><code>func extendSlice(n *ir.CallExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkAppend">
            <h2>walkAppend</h2>
            <hr />
            
            <p>Rewrite append(src, x, y, z) so that any side effects in
x, y, z (including runtime panics) are evaluated in
initialization statements before the append.
For normal code generation, stop there and leave the
rest to ssagen.

For race detector, expand append(src, a [, b]* ) to

	init {
	  s := src
	  const argc = len(args) - 1
	  newLen := s.len + argc
	  if uint(newLen) <= uint(s.cap) {
	    s = s[:newLen]
	  } else {
	    s = growslice(s.ptr, newLen, s.cap, argc, elemType)
	  }
	  s[s.len - argc] = a
	  s[s.len - argc + 1] = b
	  ...
	}
	s</p>
            
            <pre><code>func walkAppend(n *ir.CallExpr, init *ir.Nodes, dst ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkGrowslice">
            <h2>walkGrowslice</h2>
            <hr />
            
            <p>growslice(ptr *T, newLen, oldCap, num int, <type>) (ret []T)</p>
            
            <pre><code>func walkGrowslice(slice *ir.Name, init *ir.Nodes, oldPtr ir.Node, newLen ir.Node, oldCap ir.Node, num ir.Node) *ir.CallExpr</code></pre>
         </article>
         
         <article class="function" data-name="walkClear">
            <h2>walkClear</h2>
            <hr />
            
            <p>walkClear walks an OCLEAR node.</p>
            
            <pre><code>func walkClear(n *ir.UnaryExpr) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkClose">
            <h2>walkClose</h2>
            <hr />
            
            <p>walkClose walks an OCLOSE node.</p>
            
            <pre><code>func walkClose(n *ir.UnaryExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkCopy">
            <h2>walkCopy</h2>
            <hr />
            
            <p>Lower copy(a, b) to a memmove call or a runtime call.

	init {
	  n := len(a)
	  if n > len(b) { n = len(b) }
	  if a.ptr != b.ptr { memmove(a.ptr, b.ptr, n*sizeof(elem(a))) }
	}
	n;

Also works if b is a string.</p>
            
            <pre><code>func walkCopy(n *ir.BinaryExpr, init *ir.Nodes, runtimecall bool) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkDelete">
            <h2>walkDelete</h2>
            <hr />
            
            <p>walkDelete walks an ODELETE node.</p>
            
            <pre><code>func walkDelete(init *ir.Nodes, n *ir.CallExpr) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkLenCap">
            <h2>walkLenCap</h2>
            <hr />
            
            <p>walkLenCap walks an OLEN or OCAP node.</p>
            
            <pre><code>func walkLenCap(n *ir.UnaryExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkMakeChan">
            <h2>walkMakeChan</h2>
            <hr />
            
            <p>walkMakeChan walks an OMAKECHAN node.</p>
            
            <pre><code>func walkMakeChan(n *ir.MakeExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkMakeMap">
            <h2>walkMakeMap</h2>
            <hr />
            
            <p>walkMakeMap walks an OMAKEMAP node.</p>
            
            <pre><code>func walkMakeMap(n *ir.MakeExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkMakeSwissMap">
            <h2>walkMakeSwissMap</h2>
            <hr />
            
            <pre><code>func walkMakeSwissMap(n *ir.MakeExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkMakeOldMap">
            <h2>walkMakeOldMap</h2>
            <hr />
            
            <pre><code>func walkMakeOldMap(n *ir.MakeExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkMakeSlice">
            <h2>walkMakeSlice</h2>
            <hr />
            
            <p>walkMakeSlice walks an OMAKESLICE node.</p>
            
            <pre><code>func walkMakeSlice(n *ir.MakeExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkMakeSliceCopy">
            <h2>walkMakeSliceCopy</h2>
            <hr />
            
            <p>walkMakeSliceCopy walks an OMAKESLICECOPY node.</p>
            
            <pre><code>func walkMakeSliceCopy(n *ir.MakeExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkNew">
            <h2>walkNew</h2>
            <hr />
            
            <p>walkNew walks an ONEW node.</p>
            
            <pre><code>func walkNew(n *ir.UnaryExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkMinMax">
            <h2>walkMinMax</h2>
            <hr />
            
            <pre><code>func walkMinMax(n *ir.CallExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkPrint">
            <h2>walkPrint</h2>
            <hr />
            
            <p>generate code for print.</p>
            
            <pre><code>func walkPrint(nn *ir.CallExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkRecoverFP">
            <h2>walkRecoverFP</h2>
            <hr />
            
            <p>walkRecoverFP walks an ORECOVERFP node.</p>
            
            <pre><code>func walkRecoverFP(nn *ir.CallExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkUnsafeData">
            <h2>walkUnsafeData</h2>
            <hr />
            
            <p>walkUnsafeData walks an OUNSAFESLICEDATA or OUNSAFESTRINGDATA expression.</p>
            
            <pre><code>func walkUnsafeData(n *ir.UnaryExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkUnsafeSlice">
            <h2>walkUnsafeSlice</h2>
            <hr />
            
            <pre><code>func walkUnsafeSlice(n *ir.BinaryExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="walkUnsafeString">
            <h2>walkUnsafeString</h2>
            <hr />
            
            <pre><code>func walkUnsafeString(n *ir.BinaryExpr, init *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="badtype">
            <h2>badtype</h2>
            <hr />
            
            <pre><code>func badtype(op ir.Op, tl *types.Type, tr *types.Type)</code></pre>
         </article>
         
         <article class="function" data-name="writebarrierfn">
            <h2>writebarrierfn</h2>
            <hr />
            
            <pre><code>func writebarrierfn(name string, l *types.Type, r *types.Type) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="isRuneCount">
            <h2>isRuneCount</h2>
            <hr />
            
            <p>isRuneCount reports whether n is of the form len([]rune(string)).
These are optimized into a call to runtime.countrunes.</p>
            
            <pre><code>func isRuneCount(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="isByteCount">
            <h2>isByteCount</h2>
            <hr />
            
            <p>isByteCount reports whether n is of the form len(string([]byte)).</p>
            
            <pre><code>func isByteCount(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="isChanLenCap">
            <h2>isChanLenCap</h2>
            <hr />
            
            <p>isChanLenCap reports whether n is of the form len(c) or cap(c) for a channel c.
Note that this does not check for -n or instrumenting because this
is a correctness rewrite, not an optimization.</p>
            
            <pre><code>func isChanLenCap(n ir.Node) bool</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
