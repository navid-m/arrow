<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>walk - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>walk</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"fmt"
"go/constant"
"internal/abi"
"internal/buildcfg"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/objw"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/rttype"
"cmd/compile/internal/staticdata"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/objabi"
"internal/buildcfg"
"unicode/utf8"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/ssagen"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/src"
"cmd/internal/sys"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmp"
"fmt"
"go/constant"
"go/token"
"math/bits"
"slices"
"sort"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/objw"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/rttype"
"cmd/compile/internal/ssagen"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/src"
"go/constant"
"internal/abi"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/src"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/ssa"
"cmd/compile/internal/staticdata"
"cmd/compile/internal/staticinit"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"fmt"
"go/constant"
"internal/buildcfg"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/ssa"
"cmd/compile/internal/staticinit"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/objabi"
"cmd/internal/src"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/src"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"fmt"
"internal/abi"
"internal/buildcfg"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/rttype"
"cmd/compile/internal/ssagen"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/src"
"fmt"
"go/constant"
"go/token"
"internal/abi"
"internal/buildcfg"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/escape"
"cmd/compile/internal/ir"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/src"
"encoding/binary"
"fmt"
"go/constant"
"hash/fnv"
"io"
"cmd/compile/internal/base"
"cmd/compile/internal/compare"
"cmd/compile/internal/ir"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/ssagen"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"encoding/binary"
"go/constant"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/ssagen"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/sys"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="hooks" data-name="hooks">
               <h3>
                  hooks 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#hooks" class="anchor" title="Link to hooks">#</a>
               </h3>
               
               <pre><code class="language-go">var hooks = map[string]hookInfo{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inInitFunction" data-name="inInitFunction">
               <h3>
                  inInitFunction 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inInitFunction" class="anchor" title="Link to inInitFunction">#</a>
               </h3>
               
               <pre><code class="language-go">const inInitFunction initContext = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inNonInitFunction" data-name="inNonInitFunction">
               <h3>
                  inNonInitFunction 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inNonInitFunction" class="anchor" title="Link to inNonInitFunction">#</a>
               </h3>
               
               <pre><code class="language-go">const inNonInitFunction</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initConst" data-name="initConst">
               <h3>
                  initConst 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#initConst" class="anchor" title="Link to initConst">#</a>
               </h3>
               
               <pre><code class="language-go">const initConst</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initDynamic" data-name="initDynamic">
               <h3>
                  initDynamic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#initDynamic" class="anchor" title="Link to initDynamic">#</a>
               </h3>
               
               <pre><code class="language-go">const initDynamic initGenType = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initKindDynamic" data-name="initKindDynamic">
               <h3>
                  initKindDynamic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#initKindDynamic" class="anchor" title="Link to initKindDynamic">#</a>
               </h3>
               
               <pre><code class="language-go">const initKindDynamic</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initKindLocalCode" data-name="initKindLocalCode">
               <h3>
                  initKindLocalCode 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#initKindLocalCode" class="anchor" title="Link to initKindLocalCode">#</a>
               </h3>
               
               <pre><code class="language-go">const initKindLocalCode</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initKindStatic" data-name="initKindStatic">
               <h3>
                  initKindStatic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#initKindStatic" class="anchor" title="Link to initKindStatic">#</a>
               </h3>
               
               <pre><code class="language-go">const initKindStatic initKind = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="interfaceSwitchGen" data-name="interfaceSwitchGen">
               <h3>
                  interfaceSwitchGen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#interfaceSwitchGen" class="anchor" title="Link to interfaceSwitchGen">#</a>
               </h3>
               
               <pre><code class="language-go">var interfaceSwitchGen int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="itabHashField" data-name="itabHashField">
               <h3>
                  itabHashField 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#itabHashField" class="anchor" title="Link to itabHashField">#</a>
               </h3>
               
               <pre><code class="language-go">var itabHashField *types.Field</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="itabTypeField" data-name="itabTypeField">
               <h3>
                  itabTypeField 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#itabTypeField" class="anchor" title="Link to itabTypeField">#</a>
               </h3>
               
               <pre><code class="language-go">var itabTypeField *types.Field</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapaccess1" data-name="mapaccess1">
               <h3>
                  mapaccess1 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#mapaccess1" class="anchor" title="Link to mapaccess1">#</a>
               </h3>
               
               <pre><code class="language-go">var mapaccess1 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapaccess2" data-name="mapaccess2">
               <h3>
                  mapaccess2 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#mapaccess2" class="anchor" title="Link to mapaccess2">#</a>
               </h3>
               
               <pre><code class="language-go">var mapaccess2 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapassign" data-name="mapassign">
               <h3>
                  mapassign 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#mapassign" class="anchor" title="Link to mapassign">#</a>
               </h3>
               
               <pre><code class="language-go">var mapassign = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapdelete" data-name="mapdelete">
               <h3>
                  mapdelete 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#mapdelete" class="anchor" title="Link to mapdelete">#</a>
               </h3>
               
               <pre><code class="language-go">var mapdelete = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapfast32" data-name="mapfast32">
               <h3>
                  mapfast32 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mapfast32" class="anchor" title="Link to mapfast32">#</a>
               </h3>
               
               <pre><code class="language-go">const mapfast32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapfast32ptr" data-name="mapfast32ptr">
               <h3>
                  mapfast32ptr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mapfast32ptr" class="anchor" title="Link to mapfast32ptr">#</a>
               </h3>
               
               <pre><code class="language-go">const mapfast32ptr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapfast64" data-name="mapfast64">
               <h3>
                  mapfast64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mapfast64" class="anchor" title="Link to mapfast64">#</a>
               </h3>
               
               <pre><code class="language-go">const mapfast64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapfast64ptr" data-name="mapfast64ptr">
               <h3>
                  mapfast64ptr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mapfast64ptr" class="anchor" title="Link to mapfast64ptr">#</a>
               </h3>
               
               <pre><code class="language-go">const mapfast64ptr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapfaststr" data-name="mapfaststr">
               <h3>
                  mapfaststr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mapfaststr" class="anchor" title="Link to mapfaststr">#</a>
               </h3>
               
               <pre><code class="language-go">const mapfaststr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapslow" data-name="mapslow">
               <h3>
                  mapslow 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mapslow" class="anchor" title="Link to mapslow">#</a>
               </h3>
               
               <pre><code class="language-go">const mapslow = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="math_MulUintptr" data-name="math_MulUintptr">
               <h3>
                  math_MulUintptr 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#math_MulUintptr" class="anchor" title="Link to math_MulUintptr">#</a>
               </h3>
               
               <pre><code class="language-go">var math_MulUintptr = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxOpenDefers" data-name="maxOpenDefers">
               <h3>
                  maxOpenDefers 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxOpenDefers" class="anchor" title="Link to maxOpenDefers">#</a>
               </h3>
               
                  <p class="doc-comment">The max number of defers in a function using open-coded defers. We enforce this
limit because the deferBits bitmask is currently a single byte (to minimize code size)</p>
               
               <pre><code class="language-go">const maxOpenDefers = 8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nmapfast" data-name="nmapfast">
               <h3>
                  nmapfast 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#nmapfast" class="anchor" title="Link to nmapfast">#</a>
               </h3>
               
               <pre><code class="language-go">const nmapfast</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="rtypeHashField" data-name="rtypeHashField">
               <h3>
                  rtypeHashField 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#rtypeHashField" class="anchor" title="Link to rtypeHashField">#</a>
               </h3>
               
               <pre><code class="language-go">var rtypeHashField *types.Field</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="scase" data-name="scase">
               <h3>
                  scase 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#scase" class="anchor" title="Link to scase">#</a>
               </h3>
               
               <pre><code class="language-go">var scase *types.Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="tmpstringbufsize" data-name="tmpstringbufsize">
               <h3>
                  tmpstringbufsize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#tmpstringbufsize" class="anchor" title="Link to tmpstringbufsize">#</a>
               </h3>
               
                  <p class="doc-comment">The constant is known to runtime.</p>
               
               <pre><code class="language-go">const tmpstringbufsize = 32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="typeAssertGen" data-name="typeAssertGen">
               <h3>
                  typeAssertGen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#typeAssertGen" class="anchor" title="Link to typeAssertGen">#</a>
               </h3>
               
               <pre><code class="language-go">var typeAssertGen int</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="initContext" data-name="initContext">
               <h3>
                  initContext
                  <span class="badge type-badge">type</span>
                  <a href="#initContext" class="anchor" title="Link to initContext">#</a>
               </h3>
               
               <p>initContext is the context in which static data is populated.
It is either in an init function or in any other function.
Static data populated in an init function will be written either
zero times (as a readonly, static data symbol) or
one time (during init function execution).
Either way, there is no opportunity for races or further modification,
so the data can be written to a (possibly readonly) data symbol.
Static data populated in any other function needs to be local to
that function to allow multiple instances of that function
to execute concurrently without clobbering each others' data.</p>
               
               <pre><code class="language-go">type initContext uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="initGenType" data-name="initGenType">
               <h3>
                  initGenType
                  <span class="badge type-badge">type</span>
                  <a href="#initGenType" class="anchor" title="Link to initGenType">#</a>
               </h3>
               
               <p>initGenType is a bitmap indicating the types of generation that will occur for a static value.</p>
               
               <pre><code class="language-go">type initGenType uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="initKind" data-name="initKind">
               <h3>
                  initKind
                  <span class="badge type-badge">type</span>
                  <a href="#initKind" class="anchor" title="Link to initKind">#</a>
               </h3>
               
               <p>initKind is a kind of static initialization: static, dynamic, or local.
Static initialization represents literals and
literal components of composite literals.
Dynamic initialization represents non-literals and
non-literal components of composite literals.
LocalCode initialization represents initialization
that occurs purely in generated code local to the function of use.
Initialization code is sometimes generated in passes,
first static then dynamic.</p>
               
               <pre><code class="language-go">type initKind uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="mapnames" data-name="mapnames">
               <h3>
                  mapnames
                  <span class="badge type-badge">type</span>
                  <a href="#mapnames" class="anchor" title="Link to mapnames">#</a>
               </h3>
               
               <pre><code class="language-go">type mapnames [nmapfast]string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="ordermarker" data-name="ordermarker">
               <h3>
                  ordermarker
                  <span class="badge type-badge">type</span>
                  <a href="#ordermarker" class="anchor" title="Link to ordermarker">#</a>
               </h3>
               
               <pre><code class="language-go">type ordermarker int</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="exprClause" data-name="exprClause">
               <h3>
                  exprClause
                  <span class="badge">struct</span>
                  <a href="#exprClause" class="anchor" title="Link to exprClause">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type exprClause struct {
pos src.XPos
lo ir.Node
hi ir.Node
rtype ir.Node
jmp ir.Node
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="exprSwitch" data-name="exprSwitch">
               <h3>
                  exprSwitch
                  <span class="badge">struct</span>
                  <a href="#exprSwitch" class="anchor" title="Link to exprSwitch">#</a>
               </h3>
               
               <p>An exprSwitch walks an expression switch.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type exprSwitch struct {
pos src.XPos
exprname ir.Node
done ir.Nodes
clauses []exprClause
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="hookInfo" data-name="hookInfo">
               <h3>
                  hookInfo
                  <span class="badge">struct</span>
                  <a href="#hookInfo" class="anchor" title="Link to hookInfo">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type hookInfo struct {
paramType types.Kind
argsNum int
runtimeFunc string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="orderState" data-name="orderState">
               <h3>
                  orderState
                  <span class="badge">struct</span>
                  <a href="#orderState" class="anchor" title="Link to orderState">#</a>
               </h3>
               
               <p>orderState holds state during the ordering process.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type orderState struct {
out []ir.Node
temp []*ir.Name
free map[string][]*ir.Name
edit func(ir.Node) ir.Node
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="typeClause" data-name="typeClause">
               <h3>
                  typeClause
                  <span class="badge">struct</span>
                  <a href="#typeClause" class="anchor" title="Link to typeClause">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type typeClause struct {
hash uint32
body ir.Nodes
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="typeSwitch" data-name="typeSwitch">
               <h3>
                  typeSwitch
                  <span class="badge">struct</span>
                  <a href="#typeSwitch" class="anchor" title="Link to typeSwitch">#</a>
               </h3>
               
               <p>A typeSwitch walks a type switch.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type typeSwitch struct {
srcName ir.Node
hashName ir.Node
okName ir.Node
itabName ir.Node
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *exprSwitch) Add(pos src.XPos, expr ir.Node, rtype ir.Node, jmp ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Emit" data-name="Emit">
               <h3>
                  Emit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Emit" class="anchor" title="Link to Emit">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *exprSwitch) Emit(out *ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (c initContext) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Walk" data-name="Walk">
               <h3>
                  Walk 
                  <span class="badge">function</span>
                  
                  <a href="#Walk" class="anchor" title="Link to Walk">#</a>
               </h3>
               
               <pre><code class="language-go">func Walk(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addrTemp" data-name="addrTemp">
               <h3>
                  addrTemp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addrTemp" class="anchor" title="Link to addrTemp">#</a>
               </h3>
               
               <p>addrTemp ensures that n is okay to pass by address to runtime routines.
If the original argument n is not okay, addrTemp creates a tmp, emits
tmp = n, and then returns tmp.
The result of addrTemp MUST be assigned back to n, e.g.
n.Left = o.addrTemp(n.Left)</p>
               
               <pre><code class="language-go">func (o *orderState) addrTemp(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allCaseExprsAreSideEffectFree" data-name="allCaseExprsAreSideEffectFree">
               <h3>
                  allCaseExprsAreSideEffectFree 
                  <span class="badge">function</span>
                  
                  <a href="#allCaseExprsAreSideEffectFree" class="anchor" title="Link to allCaseExprsAreSideEffectFree">#</a>
               </h3>
               
               <pre><code class="language-go">func allCaseExprsAreSideEffectFree(sw *ir.SwitchStmt) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="anylit" data-name="anylit">
               <h3>
                  anylit 
                  <span class="badge">function</span>
                  
                  <a href="#anylit" class="anchor" title="Link to anylit">#</a>
               </h3>
               
               <pre><code class="language-go">func anylit(n ir.Node, var_ ir.Node, init *ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="append" data-name="append">
               <h3>
                  append 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#append" class="anchor" title="Link to append">#</a>
               </h3>
               
               <p>append typechecks stmt and appends it to out.</p>
               
               <pre><code class="language-go">func (o *orderState) append(stmt ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendSlice" data-name="appendSlice">
               <h3>
                  appendSlice 
                  <span class="badge">function</span>
                  
                  <a href="#appendSlice" class="anchor" title="Link to appendSlice">#</a>
               </h3>
               
               <p>expand append(l1, l2...) to
init {
s := l1
newLen := s.len + l2.len
// Compare as uint so growslice can panic on overflow.
if uint(newLen) <= uint(s.cap) {
s = s[:newLen]
} else {
s = growslice(s.ptr, s.len, s.cap, l2.len, T)
}
memmove(&s[s.len-l2.len], &l2[0], l2.len*sizeof(T))
}
s
l2 is allowed to be a string.</p>
               
               <pre><code class="language-go">func appendSlice(n *ir.CallExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendWalkStmt" data-name="appendWalkStmt">
               <h3>
                  appendWalkStmt 
                  <span class="badge">function</span>
                  
                  <a href="#appendWalkStmt" class="anchor" title="Link to appendWalkStmt">#</a>
               </h3>
               
               <p>appendWalkStmt typechecks and walks stmt and then appends it to init.</p>
               
               <pre><code class="language-go">func appendWalkStmt(init *ir.Nodes, stmt ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="arrayClear" data-name="arrayClear">
               <h3>
                  arrayClear 
                  <span class="badge">function</span>
                  
                  <a href="#arrayClear" class="anchor" title="Link to arrayClear">#</a>
               </h3>
               
               <p>arrayClear constructs a call to runtime.memclr for fast zeroing of slices and arrays.</p>
               
               <pre><code class="language-go">func arrayClear(wbPos src.XPos, a ir.Node, nrange *ir.RangeStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="arrayRangeClear" data-name="arrayRangeClear">
               <h3>
                  arrayRangeClear 
                  <span class="badge">function</span>
                  
                  <a href="#arrayRangeClear" class="anchor" title="Link to arrayRangeClear">#</a>
               </h3>
               
               <p>Lower n into runtime·memclr if possible, for
fast zeroing of slices and arrays (issue 5373).
Look for instances of
for i := range a {
a[i] = zero
}
in which the evaluation of a is side-effect-free.
Parameters are as in walkRange: "for v1, v2 = range a".</p>
               
               <pre><code class="language-go">func arrayRangeClear(loop *ir.RangeStmt, v1 ir.Node, v2 ir.Node, a ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="as2func" data-name="as2func">
               <h3>
                  as2func 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#as2func" class="anchor" title="Link to as2func">#</a>
               </h3>
               
               <p>as2func orders OAS2FUNC nodes. It creates temporaries to ensure left-to-right assignment.
The caller should order the right-hand side of the assignment before calling order.as2func.
It rewrites,
a, b, a = ...
as
tmp1, tmp2, tmp3 = ...
a, b, a = tmp1, tmp2, tmp3
This is necessary to ensure left to right assignment order.</p>
               
               <pre><code class="language-go">func (o *orderState) as2func(n *ir.AssignListStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="as2ok" data-name="as2ok">
               <h3>
                  as2ok 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#as2ok" class="anchor" title="Link to as2ok">#</a>
               </h3>
               
               <p>as2ok orders OAS2XXX with ok.
Just like as2func, this also adds temporaries to ensure left-to-right assignment.</p>
               
               <pre><code class="language-go">func (o *orderState) as2ok(n *ir.AssignListStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ascompatee" data-name="ascompatee">
               <h3>
                  ascompatee 
                  <span class="badge">function</span>
                  
                  <a href="#ascompatee" class="anchor" title="Link to ascompatee">#</a>
               </h3>
               
               <p>check assign expression list to
an expression list. called in
expr-list = expr-list</p>
               
               <pre><code class="language-go">func ascompatee(op ir.Op, nl []ir.Node, nr []ir.Node) []ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ascompatet" data-name="ascompatet">
               <h3>
                  ascompatet 
                  <span class="badge">function</span>
                  
                  <a href="#ascompatet" class="anchor" title="Link to ascompatet">#</a>
               </h3>
               
               <p>check assign type list to
an expression list. called in
expr-list = func()</p>
               
               <pre><code class="language-go">func ascompatet(nl ir.Nodes, nr *types.Type) []ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="backingArrayPtrLen" data-name="backingArrayPtrLen">
               <h3>
                  backingArrayPtrLen 
                  <span class="badge">function</span>
                  
                  <a href="#backingArrayPtrLen" class="anchor" title="Link to backingArrayPtrLen">#</a>
               </h3>
               
               <p>backingArrayPtrLen extracts the pointer and length from a slice or string.
This constructs two nodes referring to n, so n must be a cheapExpr.</p>
               
               <pre><code class="language-go">func backingArrayPtrLen(n ir.Node) (ptr ir.Node, length ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badtype" data-name="badtype">
               <h3>
                  badtype 
                  <span class="badge">function</span>
                  
                  <a href="#badtype" class="anchor" title="Link to badtype">#</a>
               </h3>
               
               <pre><code class="language-go">func badtype(op ir.Op, tl *types.Type, tr *types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="binarySearch" data-name="binarySearch">
               <h3>
                  binarySearch 
                  <span class="badge">function</span>
                  
                  <a href="#binarySearch" class="anchor" title="Link to binarySearch">#</a>
               </h3>
               
               <p>binarySearch constructs a binary search tree for handling n cases,
and appends it to out. It's used for efficiently implementing
switch statements.
less(i) should return a boolean expression. If it evaluates true,
then cases before i will be tested; otherwise, cases i and later.
leaf(i, nif) should setup nif (an OIF node) to test case i. In
particular, it should set nif.Cond and nif.Body.</p>
               
               <pre><code class="language-go">func binarySearch(n int, out *ir.Nodes, less func(i int) ir.Node, leaf func(i int, nif *ir.IfStmt))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bounded" data-name="bounded">
               <h3>
                  bounded 
                  <span class="badge">function</span>
                  
                  <a href="#bounded" class="anchor" title="Link to bounded">#</a>
               </h3>
               
               <p>return 1 if integer n must be in range [0, max), 0 otherwise.</p>
               
               <pre><code class="language-go">func bounded(n ir.Node, max int64) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="boundedDotPtr" data-name="boundedDotPtr">
               <h3>
                  boundedDotPtr 
                  <span class="badge">function</span>
                  
                  <a href="#boundedDotPtr" class="anchor" title="Link to boundedDotPtr">#</a>
               </h3>
               
               <p>boundedDotPtr returns a selector expression representing ptr.field
and omits nil-pointer checks for ptr.</p>
               
               <pre><code class="language-go">func boundedDotPtr(pos src.XPos, ptr ir.Node, field *types.Field) *ir.SelectorExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="brcom" data-name="brcom">
               <h3>
                  brcom 
                  <span class="badge">function</span>
                  
                  <a href="#brcom" class="anchor" title="Link to brcom">#</a>
               </h3>
               
               <p>brcom returns !(op).
For example, brcom(==) is !=.</p>
               
               <pre><code class="language-go">func brcom(op ir.Op) ir.Op</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="brrev" data-name="brrev">
               <h3>
                  brrev 
                  <span class="badge">function</span>
                  
                  <a href="#brrev" class="anchor" title="Link to brrev">#</a>
               </h3>
               
               <p>brrev returns reverse(op).
For example, Brrev(<) is >.</p>
               
               <pre><code class="language-go">func brrev(op ir.Op) ir.Op</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytePtrToIndex" data-name="bytePtrToIndex">
               <h3>
                  bytePtrToIndex 
                  <span class="badge">function</span>
                  
                  <a href="#bytePtrToIndex" class="anchor" title="Link to bytePtrToIndex">#</a>
               </h3>
               
               <p>bytePtrToIndex returns a Node representing "(*byte)(&n[i])".</p>
               
               <pre><code class="language-go">func bytePtrToIndex(n ir.Node, i int64) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteindex" data-name="byteindex">
               <h3>
                  byteindex 
                  <span class="badge">function</span>
                  
                  <a href="#byteindex" class="anchor" title="Link to byteindex">#</a>
               </h3>
               
               <p>byteindex converts n, which is byte-sized, to an int used to index into an array.
We cannot use conv, because we allow converting bool to int here,
which is forbidden in user code.</p>
               
               <pre><code class="language-go">func byteindex(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="call" data-name="call">
               <h3>
                  call 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#call" class="anchor" title="Link to call">#</a>
               </h3>
               
               <p>call orders the call expression n.
n.Op is OCALLFUNC/OCALLINTER or a builtin like OCOPY.</p>
               
               <pre><code class="language-go">func (o *orderState) call(nn ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chanfn" data-name="chanfn">
               <h3>
                  chanfn 
                  <span class="badge">function</span>
                  
                  <a href="#chanfn" class="anchor" title="Link to chanfn">#</a>
               </h3>
               
               <pre><code class="language-go">func chanfn(name string, n int, t *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cheapComputableIndex" data-name="cheapComputableIndex">
               <h3>
                  cheapComputableIndex 
                  <span class="badge">function</span>
                  
                  <a href="#cheapComputableIndex" class="anchor" title="Link to cheapComputableIndex">#</a>
               </h3>
               
               <pre><code class="language-go">func cheapComputableIndex(width int64) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cheapExpr" data-name="cheapExpr">
               <h3>
                  cheapExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cheapExpr" class="anchor" title="Link to cheapExpr">#</a>
               </h3>
               
               <p>cheapExpr returns a cheap version of n.
The definition of cheap is that n is a variable or constant.
If not, cheapExpr allocates a new tmp, emits tmp = n,
and then returns tmp.</p>
               
               <pre><code class="language-go">func (o *orderState) cheapExpr(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cheapExpr" data-name="cheapExpr">
               <h3>
                  cheapExpr 
                  <span class="badge">function</span>
                  
                  <a href="#cheapExpr" class="anchor" title="Link to cheapExpr">#</a>
               </h3>
               
               <p>return side-effect free and cheap n, appending side effects to init.
result may not be assignable.</p>
               
               <pre><code class="language-go">func cheapExpr(n ir.Node, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closureArgs" data-name="closureArgs">
               <h3>
                  closureArgs 
                  <span class="badge">function</span>
                  
                  <a href="#closureArgs" class="anchor" title="Link to closureArgs">#</a>
               </h3>
               
               <p>closureArgs returns a slice of expressions that can be used to
initialize the given closure's free variables. These correspond
one-to-one with the variables in clo.Func.ClosureVars, and will be
either an ONAME node (if the variable is captured by value) or an
OADDR-of-ONAME node (if not).</p>
               
               <pre><code class="language-go">func closureArgs(clo *ir.ClosureExpr) []ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convas" data-name="convas">
               <h3>
                  convas 
                  <span class="badge">function</span>
                  
                  <a href="#convas" class="anchor" title="Link to convas">#</a>
               </h3>
               
               <pre><code class="language-go">func convas(n *ir.AssignStmt, init *ir.Nodes) *ir.AssignStmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyExpr" data-name="copyExpr">
               <h3>
                  copyExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#copyExpr" class="anchor" title="Link to copyExpr">#</a>
               </h3>
               
               <p>copyExpr behaves like newTemp but also emits
code to initialize the temporary to the value n.</p>
               
               <pre><code class="language-go">func (o *orderState) copyExpr(n ir.Node) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyExpr" data-name="copyExpr">
               <h3>
                  copyExpr 
                  <span class="badge">function</span>
                  
                  <a href="#copyExpr" class="anchor" title="Link to copyExpr">#</a>
               </h3>
               
               <pre><code class="language-go">func copyExpr(n ir.Node, t *types.Type, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyExpr1" data-name="copyExpr1">
               <h3>
                  copyExpr1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#copyExpr1" class="anchor" title="Link to copyExpr1">#</a>
               </h3>
               
               <pre><code class="language-go">func (o *orderState) copyExpr1(n ir.Node, clear bool) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyExprClear" data-name="copyExprClear">
               <h3>
                  copyExprClear 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#copyExprClear" class="anchor" title="Link to copyExprClear">#</a>
               </h3>
               
               <p>copyExprClear is like copyExpr but clears the temp before assignment.
It is provided for use when the evaluation of tmp = n turns into
a function call that is passed a pointer to the temporary as the output space.
If the call blocks before tmp has been written,
the garbage collector will still treat the temporary as live,
so we must zero it before entering that call.
Today, this only happens for channel receive operations.
(The other candidate would be map access, but map access
returns a pointer to the result data instead of taking a pointer
to be filled in.)</p>
               
               <pre><code class="language-go">func (o *orderState) copyExprClear(n ir.Node) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dataWord" data-name="dataWord">
               <h3>
                  dataWord 
                  <span class="badge">function</span>
                  
                  <a href="#dataWord" class="anchor" title="Link to dataWord">#</a>
               </h3>
               
               <p>Returns the data word (the second word) used to represent conv.X in
an interface.</p>
               
               <pre><code class="language-go">func dataWord(conv *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dataWordFuncName" data-name="dataWordFuncName">
               <h3>
                  dataWordFuncName 
                  <span class="badge">function</span>
                  
                  <a href="#dataWordFuncName" class="anchor" title="Link to dataWordFuncName">#</a>
               </h3>
               
               <p>dataWordFuncName returns the name of the function used to convert a value of type "from"
to the data word of an interface.
argType is the type the argument needs to be coerced to.
needsaddr reports whether the value should be passed (needaddr==false) or its address (needsaddr==true).</p>
               
               <pre><code class="language-go">func dataWordFuncName(from *types.Type) (fnname string, argType *types.Type, needsaddr bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="directClosureCall" data-name="directClosureCall">
               <h3>
                  directClosureCall 
                  <span class="badge">function</span>
                  
                  <a href="#directClosureCall" class="anchor" title="Link to directClosureCall">#</a>
               </h3>
               
               <p>directClosureCall rewrites a direct call of a function literal into
a normal function call with closure variables passed as arguments.
This avoids allocation of a closure object.
For illustration, the following call:
func(a int) {
println(byval)
byref++
}(42)
becomes:
func(byval int, &byref *int, a int) {
println(byval)
(*&byref)++
}(byval, &byref, 42)</p>
               
               <pre><code class="language-go">func directClosureCall(n *ir.CallExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="edge" data-name="edge">
               <h3>
                  edge 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#edge" class="anchor" title="Link to edge">#</a>
               </h3>
               
               <p>edge inserts coverage instrumentation for libfuzzer.</p>
               
               <pre><code class="language-go">func (o *orderState) edge()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="endsInFallthrough" data-name="endsInFallthrough">
               <h3>
                  endsInFallthrough 
                  <span class="badge">function</span>
                  
                  <a href="#endsInFallthrough" class="anchor" title="Link to endsInFallthrough">#</a>
               </h3>
               
               <p>endsInFallthrough reports whether stmts ends with a "fallthrough" statement.</p>
               
               <pre><code class="language-go">func endsInFallthrough(stmts []ir.Node) (bool, src.XPos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expr" data-name="expr">
               <h3>
                  expr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expr" class="anchor" title="Link to expr">#</a>
               </h3>
               
               <p>expr orders a single expression, appending side
effects to o.out as needed.
If this is part of an assignment lhs = *np, lhs is given.
Otherwise lhs == nil. (When lhs != nil it may be possible
to avoid copying the result of the expression to a temporary.)
The result of expr MUST be assigned back to n, e.g.
n.Left = o.expr(n.Left, lhs)</p>
               
               <pre><code class="language-go">func (o *orderState) expr(n ir.Node, lhs ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expr1" data-name="expr1">
               <h3>
                  expr1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expr1" class="anchor" title="Link to expr1">#</a>
               </h3>
               
               <pre><code class="language-go">func (o *orderState) expr1(n ir.Node, lhs ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprInPlace" data-name="exprInPlace">
               <h3>
                  exprInPlace 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprInPlace" class="anchor" title="Link to exprInPlace">#</a>
               </h3>
               
               <p>exprInPlace orders the side effects in *np and
leaves them as the init list of the final *np.
The result of exprInPlace MUST be assigned back to n, e.g.
n.Left = o.exprInPlace(n.Left)</p>
               
               <pre><code class="language-go">func (o *orderState) exprInPlace(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprList" data-name="exprList">
               <h3>
                  exprList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprList" class="anchor" title="Link to exprList">#</a>
               </h3>
               
               <p>exprList orders the expression list l into o.</p>
               
               <pre><code class="language-go">func (o *orderState) exprList(l ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprListInPlace" data-name="exprListInPlace">
               <h3>
                  exprListInPlace 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprListInPlace" class="anchor" title="Link to exprListInPlace">#</a>
               </h3>
               
               <p>exprListInPlace orders the expression list l but saves
the side effects on the individual expression ninit lists.</p>
               
               <pre><code class="language-go">func (o *orderState) exprListInPlace(l ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprNoLHS" data-name="exprNoLHS">
               <h3>
                  exprNoLHS 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprNoLHS" class="anchor" title="Link to exprNoLHS">#</a>
               </h3>
               
               <pre><code class="language-go">func (o *orderState) exprNoLHS(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="extendSlice" data-name="extendSlice">
               <h3>
                  extendSlice 
                  <span class="badge">function</span>
                  
                  <a href="#extendSlice" class="anchor" title="Link to extendSlice">#</a>
               </h3>
               
               <pre><code class="language-go">func extendSlice(n *ir.CallExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fakePC" data-name="fakePC">
               <h3>
                  fakePC 
                  <span class="badge">function</span>
                  
                  <a href="#fakePC" class="anchor" title="Link to fakePC">#</a>
               </h3>
               
               <pre><code class="language-go">func fakePC(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="finishCompare" data-name="finishCompare">
               <h3>
                  finishCompare 
                  <span class="badge">function</span>
                  
                  <a href="#finishCompare" class="anchor" title="Link to finishCompare">#</a>
               </h3>
               
               <p>The result of finishCompare MUST be assigned back to n, e.g.
n.Left = finishCompare(n.Left, x, r, init)</p>
               
               <pre><code class="language-go">func finishCompare(n *ir.BinaryExpr, r ir.Node, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fixedlit" data-name="fixedlit">
               <h3>
                  fixedlit 
                  <span class="badge">function</span>
                  
                  <a href="#fixedlit" class="anchor" title="Link to fixedlit">#</a>
               </h3>
               
               <p>fixedlit handles struct, array, and slice literals.
TODO: expand documentation.</p>
               
               <pre><code class="language-go">func fixedlit(ctxt initContext, kind initKind, n *ir.CompLitExpr, var_ ir.Node, init *ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flush" data-name="flush">
               <h3>
                  flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flush" class="anchor" title="Link to flush">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *typeSwitch) flush(cc []typeClause, compiled *ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flush" data-name="flush">
               <h3>
                  flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flush" class="anchor" title="Link to flush">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *exprSwitch) flush()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="genAsStatic" data-name="genAsStatic">
               <h3>
                  genAsStatic 
                  <span class="badge">function</span>
                  
                  <a href="#genAsStatic" class="anchor" title="Link to genAsStatic">#</a>
               </h3>
               
               <pre><code class="language-go">func genAsStatic(as *ir.AssignStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getdyn" data-name="getdyn">
               <h3>
                  getdyn 
                  <span class="badge">function</span>
                  
                  <a href="#getdyn" class="anchor" title="Link to getdyn">#</a>
               </h3>
               
               <p>getdyn calculates the initGenType for n.
If top is false, getdyn is recursing.</p>
               
               <pre><code class="language-go">func getdyn(n ir.Node, top bool) initGenType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasDefaultCase" data-name="hasDefaultCase">
               <h3>
                  hasDefaultCase 
                  <span class="badge">function</span>
                  
                  <a href="#hasDefaultCase" class="anchor" title="Link to hasDefaultCase">#</a>
               </h3>
               
               <pre><code class="language-go">func hasDefaultCase(n *ir.SwitchStmt) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ifaceData" data-name="ifaceData">
               <h3>
                  ifaceData 
                  <span class="badge">function</span>
                  
                  <a href="#ifaceData" class="anchor" title="Link to ifaceData">#</a>
               </h3>
               
               <p>ifaceData loads the data field from an interface.
The concrete type must be known to have type t.
It follows the pointer if !IsDirectIface(t).</p>
               
               <pre><code class="language-go">func ifaceData(pos src.XPos, n ir.Node, t *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <p>init moves n's init list to o.out.</p>
               
               <pre><code class="language-go">func (o *orderState) init(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initStackTemp" data-name="initStackTemp">
               <h3>
                  initStackTemp 
                  <span class="badge">function</span>
                  
                  <a href="#initStackTemp" class="anchor" title="Link to initStackTemp">#</a>
               </h3>
               
               <p>initStackTemp appends statements to init to initialize the given
temporary variable to val, and then returns the expression &tmp.</p>
               
               <pre><code class="language-go">func initStackTemp(init *ir.Nodes, tmp *ir.Name, val ir.Node) *ir.AddrExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isAppendOfMake" data-name="isAppendOfMake">
               <h3>
                  isAppendOfMake 
                  <span class="badge">function</span>
                  
                  <a href="#isAppendOfMake" class="anchor" title="Link to isAppendOfMake">#</a>
               </h3>
               
               <p>isAppendOfMake reports whether n is of the form append(x, make([]T, y)...).
isAppendOfMake assumes n has already been typechecked.</p>
               
               <pre><code class="language-go">func isAppendOfMake(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isByteCount" data-name="isByteCount">
               <h3>
                  isByteCount 
                  <span class="badge">function</span>
                  
                  <a href="#isByteCount" class="anchor" title="Link to isByteCount">#</a>
               </h3>
               
               <p>isByteCount reports whether n is of the form len(string([]byte)).</p>
               
               <pre><code class="language-go">func isByteCount(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isChanLenCap" data-name="isChanLenCap">
               <h3>
                  isChanLenCap 
                  <span class="badge">function</span>
                  
                  <a href="#isChanLenCap" class="anchor" title="Link to isChanLenCap">#</a>
               </h3>
               
               <p>isChanLenCap reports whether n is of the form len(c) or cap(c) for a channel c.
Note that this does not check for -n or instrumenting because this
is a correctness rewrite, not an optimization.</p>
               
               <pre><code class="language-go">func isChanLenCap(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isMapClear" data-name="isMapClear">
               <h3>
                  isMapClear 
                  <span class="badge">function</span>
                  
                  <a href="#isMapClear" class="anchor" title="Link to isMapClear">#</a>
               </h3>
               
               <p>isMapClear checks if n is of the form:
for k := range m {
delete(m, k)
}
where == for keys of map m is reflexive.</p>
               
               <pre><code class="language-go">func isMapClear(n *ir.RangeStmt) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isRuneCount" data-name="isRuneCount">
               <h3>
                  isRuneCount 
                  <span class="badge">function</span>
                  
                  <a href="#isRuneCount" class="anchor" title="Link to isRuneCount">#</a>
               </h3>
               
               <p>isRuneCount reports whether n is of the form len([]rune(string)).
These are optimized into a call to runtime.countrunes.</p>
               
               <pre><code class="language-go">func isRuneCount(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isSimpleName" data-name="isSimpleName">
               <h3>
                  isSimpleName 
                  <span class="badge">function</span>
                  
                  <a href="#isSimpleName" class="anchor" title="Link to isSimpleName">#</a>
               </h3>
               
               <pre><code class="language-go">func isSimpleName(nn ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isSmallSliceLit" data-name="isSmallSliceLit">
               <h3>
                  isSmallSliceLit 
                  <span class="badge">function</span>
                  
                  <a href="#isSmallSliceLit" class="anchor" title="Link to isSmallSliceLit">#</a>
               </h3>
               
               <pre><code class="language-go">func isSmallSliceLit(n *ir.CompLitExpr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isStaticCompositeLiteral" data-name="isStaticCompositeLiteral">
               <h3>
                  isStaticCompositeLiteral 
                  <span class="badge">function</span>
                  
                  <a href="#isStaticCompositeLiteral" class="anchor" title="Link to isStaticCompositeLiteral">#</a>
               </h3>
               
               <p>isStaticCompositeLiteral reports whether n is a compile-time constant.</p>
               
               <pre><code class="language-go">func isStaticCompositeLiteral(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="itabType" data-name="itabType">
               <h3>
                  itabType 
                  <span class="badge">function</span>
                  
                  <a href="#itabType" class="anchor" title="Link to itabType">#</a>
               </h3>
               
               <p>itabType loads the _type field from a runtime.itab struct.</p>
               
               <pre><code class="language-go">func itabType(itab ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeTypeAssertDescriptor" data-name="makeTypeAssertDescriptor">
               <h3>
                  makeTypeAssertDescriptor 
                  <span class="badge">function</span>
                  
                  <a href="#makeTypeAssertDescriptor" class="anchor" title="Link to makeTypeAssertDescriptor">#</a>
               </h3>
               
               <pre><code class="language-go">func makeTypeAssertDescriptor(target *types.Type, canFail bool) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapAssign" data-name="mapAssign">
               <h3>
                  mapAssign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mapAssign" class="anchor" title="Link to mapAssign">#</a>
               </h3>
               
               <p>mapAssign appends n to o.out.</p>
               
               <pre><code class="language-go">func (o *orderState) mapAssign(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapClear" data-name="mapClear">
               <h3>
                  mapClear 
                  <span class="badge">function</span>
                  
                  <a href="#mapClear" class="anchor" title="Link to mapClear">#</a>
               </h3>
               
               <p>mapClear constructs a call to runtime.mapclear for the map m.</p>
               
               <pre><code class="language-go">func mapClear(m ir.Node, rtyp ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapKeyArg" data-name="mapKeyArg">
               <h3>
                  mapKeyArg 
                  <span class="badge">function</span>
                  
                  <a href="#mapKeyArg" class="anchor" title="Link to mapKeyArg">#</a>
               </h3>
               
               <p>mapKeyArg returns an expression for key that is suitable to be passed
as the key argument for runtime map* functions.
n is the map indexing or delete Node (to provide Pos).</p>
               
               <pre><code class="language-go">func mapKeyArg(fast int, n ir.Node, key ir.Node, assigned bool) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapKeyReplaceStrConv" data-name="mapKeyReplaceStrConv">
               <h3>
                  mapKeyReplaceStrConv 
                  <span class="badge">function</span>
                  
                  <a href="#mapKeyReplaceStrConv" class="anchor" title="Link to mapKeyReplaceStrConv">#</a>
               </h3>
               
               <p>mapKeyReplaceStrConv replaces OBYTES2STR by OBYTES2STRTMP
in n to avoid string allocations for keys in map lookups.
Returns a bool that signals if a modification was made.
For:
x = m[string(k)]
x = m[T1{... Tn{..., string(k), ...}}]
where k is []byte, T1 to Tn is a nesting of struct and array literals,
the allocation of backing bytes for the string can be avoided
by reusing the []byte backing array. These are special cases
for avoiding allocations when converting byte slices to strings.
It would be nice to handle these generally, but because
[]byte keys are not allowed in maps, the use of string(k)
comes up in important cases in practice. See issue 3512.</p>
               
               <pre><code class="language-go">func mapKeyReplaceStrConv(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapKeyTemp" data-name="mapKeyTemp">
               <h3>
                  mapKeyTemp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mapKeyTemp" class="anchor" title="Link to mapKeyTemp">#</a>
               </h3>
               
               <p>mapKeyTemp prepares n to be a key in a map runtime call and returns n.
The first parameter is the position of n's containing node, for use in case
that n's position is not unique (e.g., if n is an ONAME).</p>
               
               <pre><code class="language-go">func (o *orderState) mapKeyTemp(outerPos src.XPos, t *types.Type, n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapRangeClear" data-name="mapRangeClear">
               <h3>
                  mapRangeClear 
                  <span class="badge">function</span>
                  
                  <a href="#mapRangeClear" class="anchor" title="Link to mapRangeClear">#</a>
               </h3>
               
               <p>mapRangeClear constructs a call to runtime.mapclear for the map range idiom.</p>
               
               <pre><code class="language-go">func mapRangeClear(nrange *ir.RangeStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapfast" data-name="mapfast">
               <h3>
                  mapfast 
                  <span class="badge">function</span>
                  
                  <a href="#mapfast" class="anchor" title="Link to mapfast">#</a>
               </h3>
               
               <pre><code class="language-go">func mapfast(t *types.Type) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapfastOld" data-name="mapfastOld">
               <h3>
                  mapfastOld 
                  <span class="badge">function</span>
                  
                  <a href="#mapfastOld" class="anchor" title="Link to mapfastOld">#</a>
               </h3>
               
               <pre><code class="language-go">func mapfastOld(t *types.Type) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapfastSwiss" data-name="mapfastSwiss">
               <h3>
                  mapfastSwiss 
                  <span class="badge">function</span>
                  
                  <a href="#mapfastSwiss" class="anchor" title="Link to mapfastSwiss">#</a>
               </h3>
               
               <pre><code class="language-go">func mapfastSwiss(t *types.Type) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapfn" data-name="mapfn">
               <h3>
                  mapfn 
                  <span class="badge">function</span>
                  
                  <a href="#mapfn" class="anchor" title="Link to mapfn">#</a>
               </h3>
               
               <pre><code class="language-go">func mapfn(name string, t *types.Type, isfat bool) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapfndel" data-name="mapfndel">
               <h3>
                  mapfndel 
                  <span class="badge">function</span>
                  
                  <a href="#mapfndel" class="anchor" title="Link to mapfndel">#</a>
               </h3>
               
               <pre><code class="language-go">func mapfndel(name string, t *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maplit" data-name="maplit">
               <h3>
                  maplit 
                  <span class="badge">function</span>
                  
                  <a href="#maplit" class="anchor" title="Link to maplit">#</a>
               </h3>
               
               <pre><code class="language-go">func maplit(n *ir.CompLitExpr, m ir.Node, init *ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="markTemp" data-name="markTemp">
               <h3>
                  markTemp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#markTemp" class="anchor" title="Link to markTemp">#</a>
               </h3>
               
               <p>markTemp returns the top of the temporary variable stack.</p>
               
               <pre><code class="language-go">func (o *orderState) markTemp() ordermarker</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mayCall" data-name="mayCall">
               <h3>
                  mayCall 
                  <span class="badge">function</span>
                  
                  <a href="#mayCall" class="anchor" title="Link to mayCall">#</a>
               </h3>
               
               <p>mayCall reports whether evaluating expression n may require
function calls, which could clobber function call arguments/results
currently on the stack.</p>
               
               <pre><code class="language-go">func mayCall(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="methodValueWrapper" data-name="methodValueWrapper">
               <h3>
                  methodValueWrapper 
                  <span class="badge">function</span>
                  
                  <a href="#methodValueWrapper" class="anchor" title="Link to methodValueWrapper">#</a>
               </h3>
               
               <p>methodValueWrapper returns the ONAME node representing the
wrapper function (*-fm) needed for the given method value. If the
wrapper function hasn't already been created yet, it's created and
added to typecheck.Target.Decls.</p>
               
               <pre><code class="language-go">func methodValueWrapper(dot *ir.SelectorExpr) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mkcall" data-name="mkcall">
               <h3>
                  mkcall 
                  <span class="badge">function</span>
                  
                  <a href="#mkcall" class="anchor" title="Link to mkcall">#</a>
               </h3>
               
               <pre><code class="language-go">func mkcall(name string, t *types.Type, init *ir.Nodes, args ...ir.Node) *ir.CallExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mkcall1" data-name="mkcall1">
               <h3>
                  mkcall1 
                  <span class="badge">function</span>
                  
                  <a href="#mkcall1" class="anchor" title="Link to mkcall1">#</a>
               </h3>
               
               <pre><code class="language-go">func mkcall1(fn ir.Node, t *types.Type, init *ir.Nodes, args ...ir.Node) *ir.CallExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mkcallstmt" data-name="mkcallstmt">
               <h3>
                  mkcallstmt 
                  <span class="badge">function</span>
                  
                  <a href="#mkcallstmt" class="anchor" title="Link to mkcallstmt">#</a>
               </h3>
               
               <pre><code class="language-go">func mkcallstmt(name string, args ...ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mkcallstmt1" data-name="mkcallstmt1">
               <h3>
                  mkcallstmt1 
                  <span class="badge">function</span>
                  
                  <a href="#mkcallstmt1" class="anchor" title="Link to mkcallstmt1">#</a>
               </h3>
               
               <pre><code class="language-go">func mkcallstmt1(fn ir.Node, args ...ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mkmapnames" data-name="mkmapnames">
               <h3>
                  mkmapnames 
                  <span class="badge">function</span>
                  
                  <a href="#mkmapnames" class="anchor" title="Link to mkmapnames">#</a>
               </h3>
               
               <pre><code class="language-go">func mkmapnames(base string, ptr string) mapnames</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTemp" data-name="newTemp">
               <h3>
                  newTemp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newTemp" class="anchor" title="Link to newTemp">#</a>
               </h3>
               
               <p>newTemp allocates a new temporary with the given type,
pushes it onto the temp stack, and returns it.
If clear is true, newTemp emits code to zero the temporary.</p>
               
               <pre><code class="language-go">func (o *orderState) newTemp(t *types.Type, clear bool) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="oaslit" data-name="oaslit">
               <h3>
                  oaslit 
                  <span class="badge">function</span>
                  
                  <a href="#oaslit" class="anchor" title="Link to oaslit">#</a>
               </h3>
               
               <p>oaslit handles special composite literal assignments.
It returns true if n's effects have been added to init,
in which case n should be dropped from the program by the caller.</p>
               
               <pre><code class="language-go">func oaslit(n *ir.AssignStmt, init *ir.Nodes) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="order" data-name="order">
               <h3>
                  order 
                  <span class="badge">function</span>
                  
                  <a href="#order" class="anchor" title="Link to order">#</a>
               </h3>
               
               <p>order rewrites fn.Nbody to apply the ordering constraints
described in the comment at the top of the file.</p>
               
               <pre><code class="language-go">func order(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="orderBlock" data-name="orderBlock">
               <h3>
                  orderBlock 
                  <span class="badge">function</span>
                  
                  <a href="#orderBlock" class="anchor" title="Link to orderBlock">#</a>
               </h3>
               
               <p>orderBlock orders the block of statements in n into a new slice,
and then replaces the old slice in n with the new slice.
free is a map that can be used to obtain temporary variables by type.</p>
               
               <pre><code class="language-go">func orderBlock(n *ir.Nodes, free map[string][]*ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="orderMakeSliceCopy" data-name="orderMakeSliceCopy">
               <h3>
                  orderMakeSliceCopy 
                  <span class="badge">function</span>
                  
                  <a href="#orderMakeSliceCopy" class="anchor" title="Link to orderMakeSliceCopy">#</a>
               </h3>
               
               <p>orderMakeSliceCopy matches the pattern:
m = OMAKESLICE([]T, x); OCOPY(m, s)
and rewrites it to:
m = OMAKESLICECOPY([]T, x, s); nil</p>
               
               <pre><code class="language-go">func orderMakeSliceCopy(s []ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="orderStmtInPlace" data-name="orderStmtInPlace">
               <h3>
                  orderStmtInPlace 
                  <span class="badge">function</span>
                  
                  <a href="#orderStmtInPlace" class="anchor" title="Link to orderStmtInPlace">#</a>
               </h3>
               
               <p>orderStmtInPlace orders the side effects of the single statement *np
and replaces it with the resulting statement list.
The result of orderStmtInPlace MUST be assigned back to n, e.g.
n.Left = orderStmtInPlace(n.Left)
free is a map that can be used to obtain temporary variables by type.</p>
               
               <pre><code class="language-go">func orderStmtInPlace(n ir.Node, free map[string][]*ir.Name) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="popTemp" data-name="popTemp">
               <h3>
                  popTemp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#popTemp" class="anchor" title="Link to popTemp">#</a>
               </h3>
               
               <p>popTemp pops temporaries off the stack until reaching the mark,
which must have been returned by markTemp.</p>
               
               <pre><code class="language-go">func (o *orderState) popTemp(mark ordermarker)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rangeAssign" data-name="rangeAssign">
               <h3>
                  rangeAssign 
                  <span class="badge">function</span>
                  
                  <a href="#rangeAssign" class="anchor" title="Link to rangeAssign">#</a>
               </h3>
               
               <p>rangeAssign returns "n.Key = key".</p>
               
               <pre><code class="language-go">func rangeAssign(n *ir.RangeStmt, key ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rangeAssign2" data-name="rangeAssign2">
               <h3>
                  rangeAssign2 
                  <span class="badge">function</span>
                  
                  <a href="#rangeAssign2" class="anchor" title="Link to rangeAssign2">#</a>
               </h3>
               
               <p>rangeAssign2 returns "n.Key, n.Value = key, value".</p>
               
               <pre><code class="language-go">func rangeAssign2(n *ir.RangeStmt, key ir.Node, value ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rangeConvert" data-name="rangeConvert">
               <h3>
                  rangeConvert 
                  <span class="badge">function</span>
                  
                  <a href="#rangeConvert" class="anchor" title="Link to rangeConvert">#</a>
               </h3>
               
               <p>rangeConvert returns src, converted to dst if necessary. If a
conversion is necessary, then typeWord and srcRType are copied to
their respective ConvExpr fields.</p>
               
               <pre><code class="language-go">func rangeConvert(nrange *ir.RangeStmt, dst *types.Type, src ir.Node, typeWord ir.Node, srcRType ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readonlystaticname" data-name="readonlystaticname">
               <h3>
                  readonlystaticname 
                  <span class="badge">function</span>
                  
                  <a href="#readonlystaticname" class="anchor" title="Link to readonlystaticname">#</a>
               </h3>
               
               <p>readonlystaticname returns a name backed by a read-only static data symbol.</p>
               
               <pre><code class="language-go">func readonlystaticname(t *types.Type) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readsMemory" data-name="readsMemory">
               <h3>
                  readsMemory 
                  <span class="badge">function</span>
                  
                  <a href="#readsMemory" class="anchor" title="Link to readsMemory">#</a>
               </h3>
               
               <p>readsMemory reports whether the evaluation n directly reads from
memory that might be written to indirectly.</p>
               
               <pre><code class="language-go">func readsMemory(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rtconvfn" data-name="rtconvfn">
               <h3>
                  rtconvfn 
                  <span class="badge">function</span>
                  
                  <a href="#rtconvfn" class="anchor" title="Link to rtconvfn">#</a>
               </h3>
               
               <p>rtconvfn returns the parameter and result types that will be used by a
runtime function to convert from type src to type dst. The runtime function
name can be derived from the names of the returned types.
If no such function is necessary, it returns (Txxx, Txxx).</p>
               
               <pre><code class="language-go">func rtconvfn(src *types.Type, dst *types.Type) (param types.Kind, result types.Kind)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtimeField" data-name="runtimeField">
               <h3>
                  runtimeField 
                  <span class="badge">function</span>
                  
                  <a href="#runtimeField" class="anchor" title="Link to runtimeField">#</a>
               </h3>
               
               <pre><code class="language-go">func runtimeField(name string, offset int64, typ *types.Type) *types.Field</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="safeExpr" data-name="safeExpr">
               <h3>
                  safeExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#safeExpr" class="anchor" title="Link to safeExpr">#</a>
               </h3>
               
               <p>safeExpr returns a safe version of n.
The definition of safe is that n can appear multiple times
without violating the semantics of the original program,
and that assigning to the safe version has the same effect
as assigning to the original n.
The intended use is to apply to x when rewriting x += y into x = x + y.</p>
               
               <pre><code class="language-go">func (o *orderState) safeExpr(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="safeExpr" data-name="safeExpr">
               <h3>
                  safeExpr 
                  <span class="badge">function</span>
                  
                  <a href="#safeExpr" class="anchor" title="Link to safeExpr">#</a>
               </h3>
               
               <p>return side effect-free n, appending side effects to init.
result is assignable if n is.</p>
               
               <pre><code class="language-go">func safeExpr(n ir.Node, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="safeMapRHS" data-name="safeMapRHS">
               <h3>
                  safeMapRHS 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#safeMapRHS" class="anchor" title="Link to safeMapRHS">#</a>
               </h3>
               
               <pre><code class="language-go">func (o *orderState) safeMapRHS(r ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scasetype" data-name="scasetype">
               <h3>
                  scasetype 
                  <span class="badge">function</span>
                  
                  <a href="#scasetype" class="anchor" title="Link to scasetype">#</a>
               </h3>
               
               <p>Keep in sync with src/runtime/select.go.</p>
               
               <pre><code class="language-go">func scasetype() *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="search" data-name="search">
               <h3>
                  search 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#search" class="anchor" title="Link to search">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *exprSwitch) search(cc []exprClause, out *ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="slicelit" data-name="slicelit">
               <h3>
                  slicelit 
                  <span class="badge">function</span>
                  
                  <a href="#slicelit" class="anchor" title="Link to slicelit">#</a>
               </h3>
               
               <pre><code class="language-go">func slicelit(ctxt initContext, n *ir.CompLitExpr, var_ ir.Node, init *ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="soleComponent" data-name="soleComponent">
               <h3>
                  soleComponent 
                  <span class="badge">function</span>
                  
                  <a href="#soleComponent" class="anchor" title="Link to soleComponent">#</a>
               </h3>
               
               <pre><code class="language-go">func soleComponent(init *ir.Nodes, n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stackBufAddr" data-name="stackBufAddr">
               <h3>
                  stackBufAddr 
                  <span class="badge">function</span>
                  
                  <a href="#stackBufAddr" class="anchor" title="Link to stackBufAddr">#</a>
               </h3>
               
               <p>stackBufAddr returns the expression &tmp, where tmp is a newly
allocated temporary variable of type [len]elem. This variable is
initialized, and elem must not contain pointers.</p>
               
               <pre><code class="language-go">func stackBufAddr(len int64, elem *types.Type) *ir.AddrExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stackTempAddr" data-name="stackTempAddr">
               <h3>
                  stackTempAddr 
                  <span class="badge">function</span>
                  
                  <a href="#stackTempAddr" class="anchor" title="Link to stackTempAddr">#</a>
               </h3>
               
               <p>stackTempAddr returns the expression &tmp, where tmp is a newly
allocated temporary variable of the given type. Statements to
zero-initialize tmp are appended to init.</p>
               
               <pre><code class="language-go">func stackTempAddr(init *ir.Nodes, typ *types.Type) *ir.AddrExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmt" data-name="stmt">
               <h3>
                  stmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmt" class="anchor" title="Link to stmt">#</a>
               </h3>
               
               <p>stmt orders the statement n, appending to o.out.</p>
               
               <pre><code class="language-go">func (o *orderState) stmt(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmtList" data-name="stmtList">
               <h3>
                  stmtList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmtList" class="anchor" title="Link to stmtList">#</a>
               </h3>
               
               <p>stmtList orders each of the statements in the list.</p>
               
               <pre><code class="language-go">func (o *orderState) stmtList(l ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stringSearch" data-name="stringSearch">
               <h3>
                  stringSearch 
                  <span class="badge">function</span>
                  
                  <a href="#stringSearch" class="anchor" title="Link to stringSearch">#</a>
               </h3>
               
               <pre><code class="language-go">func stringSearch(expr ir.Node, cc []exprClause, out *ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="test" data-name="test">
               <h3>
                  test 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#test" class="anchor" title="Link to test">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *exprClause) test(exprname ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tracecmpArg" data-name="tracecmpArg">
               <h3>
                  tracecmpArg 
                  <span class="badge">function</span>
                  
                  <a href="#tracecmpArg" class="anchor" title="Link to tracecmpArg">#</a>
               </h3>
               
               <pre><code class="language-go">func tracecmpArg(n ir.Node, t *types.Type, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tryJumpTable" data-name="tryJumpTable">
               <h3>
                  tryJumpTable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tryJumpTable" class="anchor" title="Link to tryJumpTable">#</a>
               </h3>
               
               <p>Try to implement the clauses with a jump table. Returns true if successful.</p>
               
               <pre><code class="language-go">func (s *exprSwitch) tryJumpTable(cc []exprClause, out *ir.Nodes) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tryJumpTable" data-name="tryJumpTable">
               <h3>
                  tryJumpTable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tryJumpTable" class="anchor" title="Link to tryJumpTable">#</a>
               </h3>
               
               <p>Try to implement the clauses with a jump table. Returns true if successful.</p>
               
               <pre><code class="language-go">func (s *typeSwitch) tryJumpTable(cc []typeClause, out *ir.Nodes) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeHashFieldOf" data-name="typeHashFieldOf">
               <h3>
                  typeHashFieldOf 
                  <span class="badge">function</span>
                  
                  <a href="#typeHashFieldOf" class="anchor" title="Link to typeHashFieldOf">#</a>
               </h3>
               
               <p>typeHashFieldOf returns an expression to select the type hash field
from an interface's descriptor word (whether a *runtime._type or
*runtime.itab pointer).</p>
               
               <pre><code class="language-go">func typeHashFieldOf(pos src.XPos, itab *ir.UnaryExpr) *ir.SelectorExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="usefield" data-name="usefield">
               <h3>
                  usefield 
                  <span class="badge">function</span>
                  
                  <a href="#usefield" class="anchor" title="Link to usefield">#</a>
               </h3>
               
               <pre><code class="language-go">func usefield(n *ir.SelectorExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="usemethod" data-name="usemethod">
               <h3>
                  usemethod 
                  <span class="badge">function</span>
                  
                  <a href="#usemethod" class="anchor" title="Link to usemethod">#</a>
               </h3>
               
               <p>usemethod checks calls for uses of Method and MethodByName of reflect.Value,
reflect.Type, reflect.(*rtype), and reflect.(*interfaceType).</p>
               
               <pre><code class="language-go">func usemethod(n *ir.CallExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validGoDeferCall" data-name="validGoDeferCall">
               <h3>
                  validGoDeferCall 
                  <span class="badge">function</span>
                  
                  <a href="#validGoDeferCall" class="anchor" title="Link to validGoDeferCall">#</a>
               </h3>
               
               <p>validGoDeferCall reports whether call is a valid call to appear in
a go or defer statement; that is, whether it's a regular function
call without arguments or results.</p>
               
               <pre><code class="language-go">func validGoDeferCall(call ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="vmkcall" data-name="vmkcall">
               <h3>
                  vmkcall 
                  <span class="badge">function</span>
                  
                  <a href="#vmkcall" class="anchor" title="Link to vmkcall">#</a>
               </h3>
               
               <pre><code class="language-go">func vmkcall(fn ir.Node, t *types.Type, init *ir.Nodes, va []ir.Node) *ir.CallExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkAddString" data-name="walkAddString">
               <h3>
                  walkAddString 
                  <span class="badge">function</span>
                  
                  <a href="#walkAddString" class="anchor" title="Link to walkAddString">#</a>
               </h3>
               
               <pre><code class="language-go">func walkAddString(typ *types.Type, n *ir.AddStringExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkAppend" data-name="walkAppend">
               <h3>
                  walkAppend 
                  <span class="badge">function</span>
                  
                  <a href="#walkAppend" class="anchor" title="Link to walkAppend">#</a>
               </h3>
               
               <p>Rewrite append(src, x, y, z) so that any side effects in
x, y, z (including runtime panics) are evaluated in
initialization statements before the append.
For normal code generation, stop there and leave the
rest to ssagen.
For race detector, expand append(src, a [, b]* ) to
init {
s := src
const argc = len(args) - 1
newLen := s.len + argc
if uint(newLen) <= uint(s.cap) {
s = s[:newLen]
} else {
s = growslice(s.ptr, newLen, s.cap, argc, elemType)
}
s[s.len - argc] = a
s[s.len - argc + 1] = b
...
}
s</p>
               
               <pre><code class="language-go">func walkAppend(n *ir.CallExpr, init *ir.Nodes, dst ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkAppendArgs" data-name="walkAppendArgs">
               <h3>
                  walkAppendArgs 
                  <span class="badge">function</span>
                  
                  <a href="#walkAppendArgs" class="anchor" title="Link to walkAppendArgs">#</a>
               </h3>
               
               <pre><code class="language-go">func walkAppendArgs(n *ir.CallExpr, init *ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkAssign" data-name="walkAssign">
               <h3>
                  walkAssign 
                  <span class="badge">function</span>
                  
                  <a href="#walkAssign" class="anchor" title="Link to walkAssign">#</a>
               </h3>
               
               <p>walkAssign walks an OAS (AssignExpr) or OASOP (AssignOpExpr) node.</p>
               
               <pre><code class="language-go">func walkAssign(init *ir.Nodes, n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkAssignDotType" data-name="walkAssignDotType">
               <h3>
                  walkAssignDotType 
                  <span class="badge">function</span>
                  
                  <a href="#walkAssignDotType" class="anchor" title="Link to walkAssignDotType">#</a>
               </h3>
               
               <p>walkAssignDotType walks an OAS2DOTTYPE node.</p>
               
               <pre><code class="language-go">func walkAssignDotType(n *ir.AssignListStmt, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkAssignFunc" data-name="walkAssignFunc">
               <h3>
                  walkAssignFunc 
                  <span class="badge">function</span>
                  
                  <a href="#walkAssignFunc" class="anchor" title="Link to walkAssignFunc">#</a>
               </h3>
               
               <p>walkAssignFunc walks an OAS2FUNC node.</p>
               
               <pre><code class="language-go">func walkAssignFunc(init *ir.Nodes, n *ir.AssignListStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkAssignList" data-name="walkAssignList">
               <h3>
                  walkAssignList 
                  <span class="badge">function</span>
                  
                  <a href="#walkAssignList" class="anchor" title="Link to walkAssignList">#</a>
               </h3>
               
               <p>walkAssignList walks an OAS2 node.</p>
               
               <pre><code class="language-go">func walkAssignList(init *ir.Nodes, n *ir.AssignListStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkAssignMapRead" data-name="walkAssignMapRead">
               <h3>
                  walkAssignMapRead 
                  <span class="badge">function</span>
                  
                  <a href="#walkAssignMapRead" class="anchor" title="Link to walkAssignMapRead">#</a>
               </h3>
               
               <p>walkAssignMapRead walks an OAS2MAPR node.</p>
               
               <pre><code class="language-go">func walkAssignMapRead(init *ir.Nodes, n *ir.AssignListStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkAssignRecv" data-name="walkAssignRecv">
               <h3>
                  walkAssignRecv 
                  <span class="badge">function</span>
                  
                  <a href="#walkAssignRecv" class="anchor" title="Link to walkAssignRecv">#</a>
               </h3>
               
               <p>walkAssignRecv walks an OAS2RECV node.</p>
               
               <pre><code class="language-go">func walkAssignRecv(init *ir.Nodes, n *ir.AssignListStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkBytesRunesToString" data-name="walkBytesRunesToString">
               <h3>
                  walkBytesRunesToString 
                  <span class="badge">function</span>
                  
                  <a href="#walkBytesRunesToString" class="anchor" title="Link to walkBytesRunesToString">#</a>
               </h3>
               
               <p>walkBytesRunesToString walks an OBYTES2STR or ORUNES2STR node.</p>
               
               <pre><code class="language-go">func walkBytesRunesToString(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkBytesToStringTemp" data-name="walkBytesToStringTemp">
               <h3>
                  walkBytesToStringTemp 
                  <span class="badge">function</span>
                  
                  <a href="#walkBytesToStringTemp" class="anchor" title="Link to walkBytesToStringTemp">#</a>
               </h3>
               
               <p>walkBytesToStringTemp walks an OBYTES2STRTMP node.</p>
               
               <pre><code class="language-go">func walkBytesToStringTemp(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkCall" data-name="walkCall">
               <h3>
                  walkCall 
                  <span class="badge">function</span>
                  
                  <a href="#walkCall" class="anchor" title="Link to walkCall">#</a>
               </h3>
               
               <p>walkCall walks an OCALLFUNC or OCALLINTER node.</p>
               
               <pre><code class="language-go">func walkCall(n *ir.CallExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkCall1" data-name="walkCall1">
               <h3>
                  walkCall1 
                  <span class="badge">function</span>
                  
                  <a href="#walkCall1" class="anchor" title="Link to walkCall1">#</a>
               </h3>
               
               <pre><code class="language-go">func walkCall1(n *ir.CallExpr, init *ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkCheckPtrArithmetic" data-name="walkCheckPtrArithmetic">
               <h3>
                  walkCheckPtrArithmetic 
                  <span class="badge">function</span>
                  
                  <a href="#walkCheckPtrArithmetic" class="anchor" title="Link to walkCheckPtrArithmetic">#</a>
               </h3>
               
               <pre><code class="language-go">func walkCheckPtrArithmetic(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkClear" data-name="walkClear">
               <h3>
                  walkClear 
                  <span class="badge">function</span>
                  
                  <a href="#walkClear" class="anchor" title="Link to walkClear">#</a>
               </h3>
               
               <p>walkClear walks an OCLEAR node.</p>
               
               <pre><code class="language-go">func walkClear(n *ir.UnaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkClose" data-name="walkClose">
               <h3>
                  walkClose 
                  <span class="badge">function</span>
                  
                  <a href="#walkClose" class="anchor" title="Link to walkClose">#</a>
               </h3>
               
               <p>walkClose walks an OCLOSE node.</p>
               
               <pre><code class="language-go">func walkClose(n *ir.UnaryExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkClosure" data-name="walkClosure">
               <h3>
                  walkClosure 
                  <span class="badge">function</span>
                  
                  <a href="#walkClosure" class="anchor" title="Link to walkClosure">#</a>
               </h3>
               
               <pre><code class="language-go">func walkClosure(clo *ir.ClosureExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkCompLit" data-name="walkCompLit">
               <h3>
                  walkCompLit 
                  <span class="badge">function</span>
                  
                  <a href="#walkCompLit" class="anchor" title="Link to walkCompLit">#</a>
               </h3>
               
               <p>walkCompLit walks a composite literal node:
OARRAYLIT, OSLICELIT, OMAPLIT, OSTRUCTLIT (all CompLitExpr), or OPTRLIT (AddrExpr).</p>
               
               <pre><code class="language-go">func walkCompLit(n ir.Node, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkCompare" data-name="walkCompare">
               <h3>
                  walkCompare 
                  <span class="badge">function</span>
                  
                  <a href="#walkCompare" class="anchor" title="Link to walkCompare">#</a>
               </h3>
               
               <p>The result of walkCompare MUST be assigned back to n, e.g.
n.Left = walkCompare(n.Left, init)</p>
               
               <pre><code class="language-go">func walkCompare(n *ir.BinaryExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkCompareInterface" data-name="walkCompareInterface">
               <h3>
                  walkCompareInterface 
                  <span class="badge">function</span>
                  
                  <a href="#walkCompareInterface" class="anchor" title="Link to walkCompareInterface">#</a>
               </h3>
               
               <pre><code class="language-go">func walkCompareInterface(n *ir.BinaryExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkCompareString" data-name="walkCompareString">
               <h3>
                  walkCompareString 
                  <span class="badge">function</span>
                  
                  <a href="#walkCompareString" class="anchor" title="Link to walkCompareString">#</a>
               </h3>
               
               <pre><code class="language-go">func walkCompareString(n *ir.BinaryExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkConv" data-name="walkConv">
               <h3>
                  walkConv 
                  <span class="badge">function</span>
                  
                  <a href="#walkConv" class="anchor" title="Link to walkConv">#</a>
               </h3>
               
               <p>walkConv walks an OCONV or OCONVNOP (but not OCONVIFACE) node.</p>
               
               <pre><code class="language-go">func walkConv(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkConvInterface" data-name="walkConvInterface">
               <h3>
                  walkConvInterface 
                  <span class="badge">function</span>
                  
                  <a href="#walkConvInterface" class="anchor" title="Link to walkConvInterface">#</a>
               </h3>
               
               <p>walkConvInterface walks an OCONVIFACE node.</p>
               
               <pre><code class="language-go">func walkConvInterface(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkCopy" data-name="walkCopy">
               <h3>
                  walkCopy 
                  <span class="badge">function</span>
                  
                  <a href="#walkCopy" class="anchor" title="Link to walkCopy">#</a>
               </h3>
               
               <p>Lower copy(a, b) to a memmove call or a runtime call.
init {
n := len(a)
if n > len(b) { n = len(b) }
if a.ptr != b.ptr { memmove(a.ptr, b.ptr, n*sizeof(elem(a))) }
}
n;
Also works if b is a string.</p>
               
               <pre><code class="language-go">func walkCopy(n *ir.BinaryExpr, init *ir.Nodes, runtimecall bool) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkDelete" data-name="walkDelete">
               <h3>
                  walkDelete 
                  <span class="badge">function</span>
                  
                  <a href="#walkDelete" class="anchor" title="Link to walkDelete">#</a>
               </h3>
               
               <p>walkDelete walks an ODELETE node.</p>
               
               <pre><code class="language-go">func walkDelete(init *ir.Nodes, n *ir.CallExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkDivMod" data-name="walkDivMod">
               <h3>
                  walkDivMod 
                  <span class="badge">function</span>
                  
                  <a href="#walkDivMod" class="anchor" title="Link to walkDivMod">#</a>
               </h3>
               
               <p>walkDivMod walks an ODIV or OMOD node.</p>
               
               <pre><code class="language-go">func walkDivMod(n *ir.BinaryExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkDot" data-name="walkDot">
               <h3>
                  walkDot 
                  <span class="badge">function</span>
                  
                  <a href="#walkDot" class="anchor" title="Link to walkDot">#</a>
               </h3>
               
               <p>walkDot walks an ODOT or ODOTPTR node.</p>
               
               <pre><code class="language-go">func walkDot(n *ir.SelectorExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkDotType" data-name="walkDotType">
               <h3>
                  walkDotType 
                  <span class="badge">function</span>
                  
                  <a href="#walkDotType" class="anchor" title="Link to walkDotType">#</a>
               </h3>
               
               <p>walkDotType walks an ODOTTYPE or ODOTTYPE2 node.</p>
               
               <pre><code class="language-go">func walkDotType(n *ir.TypeAssertExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkDynamicDotType" data-name="walkDynamicDotType">
               <h3>
                  walkDynamicDotType 
                  <span class="badge">function</span>
                  
                  <a href="#walkDynamicDotType" class="anchor" title="Link to walkDynamicDotType">#</a>
               </h3>
               
               <p>walkDynamicDotType walks an ODYNAMICDOTTYPE or ODYNAMICDOTTYPE2 node.</p>
               
               <pre><code class="language-go">func walkDynamicDotType(n *ir.DynamicTypeAssertExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkExpr" data-name="walkExpr">
               <h3>
                  walkExpr 
                  <span class="badge">function</span>
                  
                  <a href="#walkExpr" class="anchor" title="Link to walkExpr">#</a>
               </h3>
               
               <p>The result of walkExpr MUST be assigned back to n, e.g.
n.Left = walkExpr(n.Left, init)</p>
               
               <pre><code class="language-go">func walkExpr(n ir.Node, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkExpr1" data-name="walkExpr1">
               <h3>
                  walkExpr1 
                  <span class="badge">function</span>
                  
                  <a href="#walkExpr1" class="anchor" title="Link to walkExpr1">#</a>
               </h3>
               
               <pre><code class="language-go">func walkExpr1(n ir.Node, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkExprList" data-name="walkExprList">
               <h3>
                  walkExprList 
                  <span class="badge">function</span>
                  
                  <a href="#walkExprList" class="anchor" title="Link to walkExprList">#</a>
               </h3>
               
               <p>walk the whole tree of the body of an
expression or simple statement.
the types expressions are calculated.
compile-time constants are evaluated.
complex side effects like statements are appended to init.</p>
               
               <pre><code class="language-go">func walkExprList(s []ir.Node, init *ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkExprListCheap" data-name="walkExprListCheap">
               <h3>
                  walkExprListCheap 
                  <span class="badge">function</span>
                  
                  <a href="#walkExprListCheap" class="anchor" title="Link to walkExprListCheap">#</a>
               </h3>
               
               <pre><code class="language-go">func walkExprListCheap(s []ir.Node, init *ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkExprListSafe" data-name="walkExprListSafe">
               <h3>
                  walkExprListSafe 
                  <span class="badge">function</span>
                  
                  <a href="#walkExprListSafe" class="anchor" title="Link to walkExprListSafe">#</a>
               </h3>
               
               <pre><code class="language-go">func walkExprListSafe(s []ir.Node, init *ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkFor" data-name="walkFor">
               <h3>
                  walkFor 
                  <span class="badge">function</span>
                  
                  <a href="#walkFor" class="anchor" title="Link to walkFor">#</a>
               </h3>
               
               <p>walkFor walks an OFOR node.</p>
               
               <pre><code class="language-go">func walkFor(n *ir.ForStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkGoDefer" data-name="walkGoDefer">
               <h3>
                  walkGoDefer 
                  <span class="badge">function</span>
                  
                  <a href="#walkGoDefer" class="anchor" title="Link to walkGoDefer">#</a>
               </h3>
               
               <p>walkGoDefer walks an OGO or ODEFER node.</p>
               
               <pre><code class="language-go">func walkGoDefer(n *ir.GoDeferStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkGrowslice" data-name="walkGrowslice">
               <h3>
                  walkGrowslice 
                  <span class="badge">function</span>
                  
                  <a href="#walkGrowslice" class="anchor" title="Link to walkGrowslice">#</a>
               </h3>
               
               <p>growslice(ptr *T, newLen, oldCap, num int, <type>) (ret []T)</p>
               
               <pre><code class="language-go">func walkGrowslice(slice *ir.Name, init *ir.Nodes, oldPtr ir.Node, newLen ir.Node, oldCap ir.Node, num ir.Node) *ir.CallExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkIf" data-name="walkIf">
               <h3>
                  walkIf 
                  <span class="badge">function</span>
                  
                  <a href="#walkIf" class="anchor" title="Link to walkIf">#</a>
               </h3>
               
               <p>walkIf walks an OIF node.</p>
               
               <pre><code class="language-go">func walkIf(n *ir.IfStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkIndex" data-name="walkIndex">
               <h3>
                  walkIndex 
                  <span class="badge">function</span>
                  
                  <a href="#walkIndex" class="anchor" title="Link to walkIndex">#</a>
               </h3>
               
               <p>walkIndex walks an OINDEX node.</p>
               
               <pre><code class="language-go">func walkIndex(n *ir.IndexExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkIndexMap" data-name="walkIndexMap">
               <h3>
                  walkIndexMap 
                  <span class="badge">function</span>
                  
                  <a href="#walkIndexMap" class="anchor" title="Link to walkIndexMap">#</a>
               </h3>
               
               <p>walkIndexMap walks an OINDEXMAP node.
It replaces m[k] with *map{access1,assign}(maptype, m, &k)</p>
               
               <pre><code class="language-go">func walkIndexMap(n *ir.IndexExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkLenCap" data-name="walkLenCap">
               <h3>
                  walkLenCap 
                  <span class="badge">function</span>
                  
                  <a href="#walkLenCap" class="anchor" title="Link to walkLenCap">#</a>
               </h3>
               
               <p>walkLenCap walks an OLEN or OCAP node.</p>
               
               <pre><code class="language-go">func walkLenCap(n *ir.UnaryExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkLogical" data-name="walkLogical">
               <h3>
                  walkLogical 
                  <span class="badge">function</span>
                  
                  <a href="#walkLogical" class="anchor" title="Link to walkLogical">#</a>
               </h3>
               
               <p>walkLogical walks an OANDAND or OOROR node.</p>
               
               <pre><code class="language-go">func walkLogical(n *ir.LogicalExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkMakeChan" data-name="walkMakeChan">
               <h3>
                  walkMakeChan 
                  <span class="badge">function</span>
                  
                  <a href="#walkMakeChan" class="anchor" title="Link to walkMakeChan">#</a>
               </h3>
               
               <p>walkMakeChan walks an OMAKECHAN node.</p>
               
               <pre><code class="language-go">func walkMakeChan(n *ir.MakeExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkMakeMap" data-name="walkMakeMap">
               <h3>
                  walkMakeMap 
                  <span class="badge">function</span>
                  
                  <a href="#walkMakeMap" class="anchor" title="Link to walkMakeMap">#</a>
               </h3>
               
               <p>walkMakeMap walks an OMAKEMAP node.</p>
               
               <pre><code class="language-go">func walkMakeMap(n *ir.MakeExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkMakeOldMap" data-name="walkMakeOldMap">
               <h3>
                  walkMakeOldMap 
                  <span class="badge">function</span>
                  
                  <a href="#walkMakeOldMap" class="anchor" title="Link to walkMakeOldMap">#</a>
               </h3>
               
               <pre><code class="language-go">func walkMakeOldMap(n *ir.MakeExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkMakeSlice" data-name="walkMakeSlice">
               <h3>
                  walkMakeSlice 
                  <span class="badge">function</span>
                  
                  <a href="#walkMakeSlice" class="anchor" title="Link to walkMakeSlice">#</a>
               </h3>
               
               <p>walkMakeSlice walks an OMAKESLICE node.</p>
               
               <pre><code class="language-go">func walkMakeSlice(n *ir.MakeExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkMakeSliceCopy" data-name="walkMakeSliceCopy">
               <h3>
                  walkMakeSliceCopy 
                  <span class="badge">function</span>
                  
                  <a href="#walkMakeSliceCopy" class="anchor" title="Link to walkMakeSliceCopy">#</a>
               </h3>
               
               <p>walkMakeSliceCopy walks an OMAKESLICECOPY node.</p>
               
               <pre><code class="language-go">func walkMakeSliceCopy(n *ir.MakeExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkMakeSwissMap" data-name="walkMakeSwissMap">
               <h3>
                  walkMakeSwissMap 
                  <span class="badge">function</span>
                  
                  <a href="#walkMakeSwissMap" class="anchor" title="Link to walkMakeSwissMap">#</a>
               </h3>
               
               <pre><code class="language-go">func walkMakeSwissMap(n *ir.MakeExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkMethodValue" data-name="walkMethodValue">
               <h3>
                  walkMethodValue 
                  <span class="badge">function</span>
                  
                  <a href="#walkMethodValue" class="anchor" title="Link to walkMethodValue">#</a>
               </h3>
               
               <pre><code class="language-go">func walkMethodValue(n *ir.SelectorExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkMinMax" data-name="walkMinMax">
               <h3>
                  walkMinMax 
                  <span class="badge">function</span>
                  
                  <a href="#walkMinMax" class="anchor" title="Link to walkMinMax">#</a>
               </h3>
               
               <pre><code class="language-go">func walkMinMax(n *ir.CallExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkNew" data-name="walkNew">
               <h3>
                  walkNew 
                  <span class="badge">function</span>
                  
                  <a href="#walkNew" class="anchor" title="Link to walkNew">#</a>
               </h3>
               
               <p>walkNew walks an ONEW node.</p>
               
               <pre><code class="language-go">func walkNew(n *ir.UnaryExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkPrint" data-name="walkPrint">
               <h3>
                  walkPrint 
                  <span class="badge">function</span>
                  
                  <a href="#walkPrint" class="anchor" title="Link to walkPrint">#</a>
               </h3>
               
               <p>generate code for print.</p>
               
               <pre><code class="language-go">func walkPrint(nn *ir.CallExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkRange" data-name="walkRange">
               <h3>
                  walkRange 
                  <span class="badge">function</span>
                  
                  <a href="#walkRange" class="anchor" title="Link to walkRange">#</a>
               </h3>
               
               <p>walkRange transforms various forms of ORANGE into
simpler forms.  The result must be assigned back to n.
Node n may also be modified in place, and may also be
the returned node.</p>
               
               <pre><code class="language-go">func walkRange(nrange *ir.RangeStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkRecoverFP" data-name="walkRecoverFP">
               <h3>
                  walkRecoverFP 
                  <span class="badge">function</span>
                  
                  <a href="#walkRecoverFP" class="anchor" title="Link to walkRecoverFP">#</a>
               </h3>
               
               <p>walkRecoverFP walks an ORECOVERFP node.</p>
               
               <pre><code class="language-go">func walkRecoverFP(nn *ir.CallExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkRecv" data-name="walkRecv">
               <h3>
                  walkRecv 
                  <span class="badge">function</span>
                  
                  <a href="#walkRecv" class="anchor" title="Link to walkRecv">#</a>
               </h3>
               
               <p>walkRecv walks an ORECV node.</p>
               
               <pre><code class="language-go">func walkRecv(n *ir.UnaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkReturn" data-name="walkReturn">
               <h3>
                  walkReturn 
                  <span class="badge">function</span>
                  
                  <a href="#walkReturn" class="anchor" title="Link to walkReturn">#</a>
               </h3>
               
               <p>walkReturn walks an ORETURN node.</p>
               
               <pre><code class="language-go">func walkReturn(n *ir.ReturnStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkRuneToString" data-name="walkRuneToString">
               <h3>
                  walkRuneToString 
                  <span class="badge">function</span>
                  
                  <a href="#walkRuneToString" class="anchor" title="Link to walkRuneToString">#</a>
               </h3>
               
               <p>walkRuneToString walks an ORUNESTR node.</p>
               
               <pre><code class="language-go">func walkRuneToString(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkSelect" data-name="walkSelect">
               <h3>
                  walkSelect 
                  <span class="badge">function</span>
                  
                  <a href="#walkSelect" class="anchor" title="Link to walkSelect">#</a>
               </h3>
               
               <pre><code class="language-go">func walkSelect(sel *ir.SelectStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkSelectCases" data-name="walkSelectCases">
               <h3>
                  walkSelectCases 
                  <span class="badge">function</span>
                  
                  <a href="#walkSelectCases" class="anchor" title="Link to walkSelectCases">#</a>
               </h3>
               
               <pre><code class="language-go">func walkSelectCases(cases []*ir.CommClause) []ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkSend" data-name="walkSend">
               <h3>
                  walkSend 
                  <span class="badge">function</span>
                  
                  <a href="#walkSend" class="anchor" title="Link to walkSend">#</a>
               </h3>
               
               <p>walkSend walks an OSEND node.</p>
               
               <pre><code class="language-go">func walkSend(n *ir.SendStmt, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkSlice" data-name="walkSlice">
               <h3>
                  walkSlice 
                  <span class="badge">function</span>
                  
                  <a href="#walkSlice" class="anchor" title="Link to walkSlice">#</a>
               </h3>
               
               <p>walkSlice walks an OSLICE, OSLICEARR, OSLICESTR, OSLICE3, or OSLICE3ARR node.</p>
               
               <pre><code class="language-go">func walkSlice(n *ir.SliceExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkSliceHeader" data-name="walkSliceHeader">
               <h3>
                  walkSliceHeader 
                  <span class="badge">function</span>
                  
                  <a href="#walkSliceHeader" class="anchor" title="Link to walkSliceHeader">#</a>
               </h3>
               
               <p>walkSliceHeader walks an OSLICEHEADER node.</p>
               
               <pre><code class="language-go">func walkSliceHeader(n *ir.SliceHeaderExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkSliceToArray" data-name="walkSliceToArray">
               <h3>
                  walkSliceToArray 
                  <span class="badge">function</span>
                  
                  <a href="#walkSliceToArray" class="anchor" title="Link to walkSliceToArray">#</a>
               </h3>
               
               <p>walkSliceToArray walks an OSLICE2ARR expression.</p>
               
               <pre><code class="language-go">func walkSliceToArray(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkStmt" data-name="walkStmt">
               <h3>
                  walkStmt 
                  <span class="badge">function</span>
                  
                  <a href="#walkStmt" class="anchor" title="Link to walkStmt">#</a>
               </h3>
               
               <p>The result of walkStmt MUST be assigned back to n, e.g.
n.Left = walkStmt(n.Left)</p>
               
               <pre><code class="language-go">func walkStmt(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkStmtList" data-name="walkStmtList">
               <h3>
                  walkStmtList 
                  <span class="badge">function</span>
                  
                  <a href="#walkStmtList" class="anchor" title="Link to walkStmtList">#</a>
               </h3>
               
               <pre><code class="language-go">func walkStmtList(s []ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkStringHeader" data-name="walkStringHeader">
               <h3>
                  walkStringHeader 
                  <span class="badge">function</span>
                  
                  <a href="#walkStringHeader" class="anchor" title="Link to walkStringHeader">#</a>
               </h3>
               
               <p>walkStringHeader walks an OSTRINGHEADER node.</p>
               
               <pre><code class="language-go">func walkStringHeader(n *ir.StringHeaderExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkStringToBytes" data-name="walkStringToBytes">
               <h3>
                  walkStringToBytes 
                  <span class="badge">function</span>
                  
                  <a href="#walkStringToBytes" class="anchor" title="Link to walkStringToBytes">#</a>
               </h3>
               
               <p>walkStringToBytes walks an OSTR2BYTES node.</p>
               
               <pre><code class="language-go">func walkStringToBytes(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkStringToBytesTemp" data-name="walkStringToBytesTemp">
               <h3>
                  walkStringToBytesTemp 
                  <span class="badge">function</span>
                  
                  <a href="#walkStringToBytesTemp" class="anchor" title="Link to walkStringToBytesTemp">#</a>
               </h3>
               
               <p>walkStringToBytesTemp walks an OSTR2BYTESTMP node.</p>
               
               <pre><code class="language-go">func walkStringToBytesTemp(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkStringToRunes" data-name="walkStringToRunes">
               <h3>
                  walkStringToRunes 
                  <span class="badge">function</span>
                  
                  <a href="#walkStringToRunes" class="anchor" title="Link to walkStringToRunes">#</a>
               </h3>
               
               <p>walkStringToRunes walks an OSTR2RUNES node.</p>
               
               <pre><code class="language-go">func walkStringToRunes(n *ir.ConvExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkSwitch" data-name="walkSwitch">
               <h3>
                  walkSwitch 
                  <span class="badge">function</span>
                  
                  <a href="#walkSwitch" class="anchor" title="Link to walkSwitch">#</a>
               </h3>
               
               <p>walkSwitch walks a switch statement.</p>
               
               <pre><code class="language-go">func walkSwitch(sw *ir.SwitchStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkSwitchExpr" data-name="walkSwitchExpr">
               <h3>
                  walkSwitchExpr 
                  <span class="badge">function</span>
                  
                  <a href="#walkSwitchExpr" class="anchor" title="Link to walkSwitchExpr">#</a>
               </h3>
               
               <p>walkSwitchExpr generates an AST implementing sw.  sw is an
expression switch.</p>
               
               <pre><code class="language-go">func walkSwitchExpr(sw *ir.SwitchStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkSwitchType" data-name="walkSwitchType">
               <h3>
                  walkSwitchType 
                  <span class="badge">function</span>
                  
                  <a href="#walkSwitchType" class="anchor" title="Link to walkSwitchType">#</a>
               </h3>
               
               <p>walkSwitchType generates an AST that implements sw, where sw is a
type switch.</p>
               
               <pre><code class="language-go">func walkSwitchType(sw *ir.SwitchStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkUnsafeData" data-name="walkUnsafeData">
               <h3>
                  walkUnsafeData 
                  <span class="badge">function</span>
                  
                  <a href="#walkUnsafeData" class="anchor" title="Link to walkUnsafeData">#</a>
               </h3>
               
               <p>walkUnsafeData walks an OUNSAFESLICEDATA or OUNSAFESTRINGDATA expression.</p>
               
               <pre><code class="language-go">func walkUnsafeData(n *ir.UnaryExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkUnsafeSlice" data-name="walkUnsafeSlice">
               <h3>
                  walkUnsafeSlice 
                  <span class="badge">function</span>
                  
                  <a href="#walkUnsafeSlice" class="anchor" title="Link to walkUnsafeSlice">#</a>
               </h3>
               
               <pre><code class="language-go">func walkUnsafeSlice(n *ir.BinaryExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkUnsafeString" data-name="walkUnsafeString">
               <h3>
                  walkUnsafeString 
                  <span class="badge">function</span>
                  
                  <a href="#walkUnsafeString" class="anchor" title="Link to walkUnsafeString">#</a>
               </h3>
               
               <pre><code class="language-go">func walkUnsafeString(n *ir.BinaryExpr, init *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writebarrierfn" data-name="writebarrierfn">
               <h3>
                  writebarrierfn 
                  <span class="badge">function</span>
                  
                  <a href="#writebarrierfn" class="anchor" title="Link to writebarrierfn">#</a>
               </h3>
               
               <pre><code class="language-go">func writebarrierfn(name string, l *types.Type, r *types.Type) ir.Node</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>