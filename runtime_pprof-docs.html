<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - pprof</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>pprof</code>
         </h1>
         <hr />
         
         <article class="global" data-name="sink">
            <h2>sink</h2>
            <hr />
            
            <pre><code>sink []byte</code></pre>
         </article>
         
         <article class="global" data-name="errBadELF">
            <h2>errBadELF</h2>
            <hr />
            
            <pre><code>errBadELF</code></pre>
         </article>
         
         <article class="global" data-name="errNoBuildID">
            <h2>errNoBuildID</h2>
            <hr />
            
            <pre><code>errNoBuildID</code></pre>
         </article>
         
         <article class="global" data-name="_VM_PROT_READ">
            <h2>_VM_PROT_READ</h2>
            <hr />
            
            <pre><code>_VM_PROT_READ</code></pre>
         </article>
         
         <article class="global" data-name="_VM_PROT_WRITE">
            <h2>_VM_PROT_WRITE</h2>
            <hr />
            
            <pre><code>_VM_PROT_WRITE</code></pre>
         </article>
         
         <article class="global" data-name="_VM_PROT_EXECUTE">
            <h2>_VM_PROT_EXECUTE</h2>
            <hr />
            
            <pre><code>_VM_PROT_EXECUTE</code></pre>
         </article>
         
         <article class="global" data-name="_MACH_SEND_INVALID_DEST">
            <h2>_MACH_SEND_INVALID_DEST</h2>
            <hr />
            
            <pre><code>_MACH_SEND_INVALID_DEST</code></pre>
         </article>
         
         <article class="global" data-name="_MAXPATHLEN">
            <h2>_MAXPATHLEN</h2>
            <hr />
            
            <pre><code>_MAXPATHLEN</code></pre>
         </article>
         
         <article class="global" data-name="_VM_PROT_READ">
            <h2>_VM_PROT_READ</h2>
            <hr />
            
            <pre><code>_VM_PROT_READ</code></pre>
         </article>
         
         <article class="global" data-name="_VM_PROT_WRITE">
            <h2>_VM_PROT_WRITE</h2>
            <hr />
            
            <pre><code>_VM_PROT_WRITE</code></pre>
         </article>
         
         <article class="global" data-name="_VM_PROT_EXECUTE">
            <h2>_VM_PROT_EXECUTE</h2>
            <hr />
            
            <pre><code>_VM_PROT_EXECUTE</code></pre>
         </article>
         
         <article class="global" data-name="_MACH_SEND_INVALID_DEST">
            <h2>_MACH_SEND_INVALID_DEST</h2>
            <hr />
            
            <pre><code>_MACH_SEND_INVALID_DEST</code></pre>
         </article>
         
         <article class="global" data-name="_MAXPATHLEN">
            <h2>_MAXPATHLEN</h2>
            <hr />
            
            <pre><code>_MAXPATHLEN</code></pre>
         </article>
         
         <article class="global" data-name="lookupTried">
            <h2>lookupTried</h2>
            <hr />
            
            <pre><code>lookupTried symbolizeFlag</code></pre>
         </article>
         
         <article class="global" data-name="lookupFailed">
            <h2>lookupFailed</h2>
            <hr />
            
            <pre><code>lookupFailed symbolizeFlag</code></pre>
         </article>
         
         <article class="global" data-name="tagProfile_SampleType">
            <h2>tagProfile_SampleType</h2>
            <hr />
            
            <p>message Profile</p>
            
            <pre><code>tagProfile_SampleType</code></pre>
         </article>
         
         <article class="global" data-name="tagProfile_Sample">
            <h2>tagProfile_Sample</h2>
            <hr />
            
            <pre><code>tagProfile_Sample</code></pre>
         </article>
         
         <article class="global" data-name="tagProfile_Mapping">
            <h2>tagProfile_Mapping</h2>
            <hr />
            
            <pre><code>tagProfile_Mapping</code></pre>
         </article>
         
         <article class="global" data-name="tagProfile_Location">
            <h2>tagProfile_Location</h2>
            <hr />
            
            <pre><code>tagProfile_Location</code></pre>
         </article>
         
         <article class="global" data-name="tagProfile_Function">
            <h2>tagProfile_Function</h2>
            <hr />
            
            <pre><code>tagProfile_Function</code></pre>
         </article>
         
         <article class="global" data-name="tagProfile_StringTable">
            <h2>tagProfile_StringTable</h2>
            <hr />
            
            <pre><code>tagProfile_StringTable</code></pre>
         </article>
         
         <article class="global" data-name="tagProfile_DropFrames">
            <h2>tagProfile_DropFrames</h2>
            <hr />
            
            <pre><code>tagProfile_DropFrames</code></pre>
         </article>
         
         <article class="global" data-name="tagProfile_KeepFrames">
            <h2>tagProfile_KeepFrames</h2>
            <hr />
            
            <pre><code>tagProfile_KeepFrames</code></pre>
         </article>
         
         <article class="global" data-name="tagProfile_TimeNanos">
            <h2>tagProfile_TimeNanos</h2>
            <hr />
            
            <pre><code>tagProfile_TimeNanos</code></pre>
         </article>
         
         <article class="global" data-name="tagProfile_DurationNanos">
            <h2>tagProfile_DurationNanos</h2>
            <hr />
            
            <pre><code>tagProfile_DurationNanos</code></pre>
         </article>
         
         <article class="global" data-name="tagProfile_PeriodType">
            <h2>tagProfile_PeriodType</h2>
            <hr />
            
            <pre><code>tagProfile_PeriodType</code></pre>
         </article>
         
         <article class="global" data-name="tagProfile_Period">
            <h2>tagProfile_Period</h2>
            <hr />
            
            <pre><code>tagProfile_Period</code></pre>
         </article>
         
         <article class="global" data-name="tagProfile_Comment">
            <h2>tagProfile_Comment</h2>
            <hr />
            
            <pre><code>tagProfile_Comment</code></pre>
         </article>
         
         <article class="global" data-name="tagProfile_DefaultSampleType">
            <h2>tagProfile_DefaultSampleType</h2>
            <hr />
            
            <pre><code>tagProfile_DefaultSampleType</code></pre>
         </article>
         
         <article class="global" data-name="tagValueType_Type">
            <h2>tagValueType_Type</h2>
            <hr />
            
            <p>message ValueType</p>
            
            <pre><code>tagValueType_Type</code></pre>
         </article>
         
         <article class="global" data-name="tagValueType_Unit">
            <h2>tagValueType_Unit</h2>
            <hr />
            
            <pre><code>tagValueType_Unit</code></pre>
         </article>
         
         <article class="global" data-name="tagSample_Location">
            <h2>tagSample_Location</h2>
            <hr />
            
            <p>message Sample</p>
            
            <pre><code>tagSample_Location</code></pre>
         </article>
         
         <article class="global" data-name="tagSample_Value">
            <h2>tagSample_Value</h2>
            <hr />
            
            <pre><code>tagSample_Value</code></pre>
         </article>
         
         <article class="global" data-name="tagSample_Label">
            <h2>tagSample_Label</h2>
            <hr />
            
            <pre><code>tagSample_Label</code></pre>
         </article>
         
         <article class="global" data-name="tagLabel_Key">
            <h2>tagLabel_Key</h2>
            <hr />
            
            <p>message Label</p>
            
            <pre><code>tagLabel_Key</code></pre>
         </article>
         
         <article class="global" data-name="tagLabel_Str">
            <h2>tagLabel_Str</h2>
            <hr />
            
            <pre><code>tagLabel_Str</code></pre>
         </article>
         
         <article class="global" data-name="tagLabel_Num">
            <h2>tagLabel_Num</h2>
            <hr />
            
            <pre><code>tagLabel_Num</code></pre>
         </article>
         
         <article class="global" data-name="tagMapping_ID">
            <h2>tagMapping_ID</h2>
            <hr />
            
            <p>message Mapping</p>
            
            <pre><code>tagMapping_ID</code></pre>
         </article>
         
         <article class="global" data-name="tagMapping_Start">
            <h2>tagMapping_Start</h2>
            <hr />
            
            <pre><code>tagMapping_Start</code></pre>
         </article>
         
         <article class="global" data-name="tagMapping_Limit">
            <h2>tagMapping_Limit</h2>
            <hr />
            
            <pre><code>tagMapping_Limit</code></pre>
         </article>
         
         <article class="global" data-name="tagMapping_Offset">
            <h2>tagMapping_Offset</h2>
            <hr />
            
            <pre><code>tagMapping_Offset</code></pre>
         </article>
         
         <article class="global" data-name="tagMapping_Filename">
            <h2>tagMapping_Filename</h2>
            <hr />
            
            <pre><code>tagMapping_Filename</code></pre>
         </article>
         
         <article class="global" data-name="tagMapping_BuildID">
            <h2>tagMapping_BuildID</h2>
            <hr />
            
            <pre><code>tagMapping_BuildID</code></pre>
         </article>
         
         <article class="global" data-name="tagMapping_HasFunctions">
            <h2>tagMapping_HasFunctions</h2>
            <hr />
            
            <pre><code>tagMapping_HasFunctions</code></pre>
         </article>
         
         <article class="global" data-name="tagMapping_HasFilenames">
            <h2>tagMapping_HasFilenames</h2>
            <hr />
            
            <pre><code>tagMapping_HasFilenames</code></pre>
         </article>
         
         <article class="global" data-name="tagMapping_HasLineNumbers">
            <h2>tagMapping_HasLineNumbers</h2>
            <hr />
            
            <pre><code>tagMapping_HasLineNumbers</code></pre>
         </article>
         
         <article class="global" data-name="tagMapping_HasInlineFrames">
            <h2>tagMapping_HasInlineFrames</h2>
            <hr />
            
            <pre><code>tagMapping_HasInlineFrames</code></pre>
         </article>
         
         <article class="global" data-name="tagLocation_ID">
            <h2>tagLocation_ID</h2>
            <hr />
            
            <p>message Location</p>
            
            <pre><code>tagLocation_ID</code></pre>
         </article>
         
         <article class="global" data-name="tagLocation_MappingID">
            <h2>tagLocation_MappingID</h2>
            <hr />
            
            <pre><code>tagLocation_MappingID</code></pre>
         </article>
         
         <article class="global" data-name="tagLocation_Address">
            <h2>tagLocation_Address</h2>
            <hr />
            
            <pre><code>tagLocation_Address</code></pre>
         </article>
         
         <article class="global" data-name="tagLocation_Line">
            <h2>tagLocation_Line</h2>
            <hr />
            
            <pre><code>tagLocation_Line</code></pre>
         </article>
         
         <article class="global" data-name="tagLine_FunctionID">
            <h2>tagLine_FunctionID</h2>
            <hr />
            
            <p>message Line</p>
            
            <pre><code>tagLine_FunctionID</code></pre>
         </article>
         
         <article class="global" data-name="tagLine_Line">
            <h2>tagLine_Line</h2>
            <hr />
            
            <pre><code>tagLine_Line</code></pre>
         </article>
         
         <article class="global" data-name="tagFunction_ID">
            <h2>tagFunction_ID</h2>
            <hr />
            
            <p>message Function</p>
            
            <pre><code>tagFunction_ID</code></pre>
         </article>
         
         <article class="global" data-name="tagFunction_Name">
            <h2>tagFunction_Name</h2>
            <hr />
            
            <pre><code>tagFunction_Name</code></pre>
         </article>
         
         <article class="global" data-name="tagFunction_SystemName">
            <h2>tagFunction_SystemName</h2>
            <hr />
            
            <pre><code>tagFunction_SystemName</code></pre>
         </article>
         
         <article class="global" data-name="tagFunction_Filename">
            <h2>tagFunction_Filename</h2>
            <hr />
            
            <pre><code>tagFunction_Filename</code></pre>
         </article>
         
         <article class="global" data-name="tagFunction_StartLine">
            <h2>tagFunction_StartLine</h2>
            <hr />
            
            <pre><code>tagFunction_StartLine</code></pre>
         </article>
         
         <article class="global" data-name="space">
            <h2>space</h2>
            <hr />
            
            <pre><code>space</code></pre>
         </article>
         
         <article class="global" data-name="newline">
            <h2>newline</h2>
            <hr />
            
            <pre><code>newline</code></pre>
         </article>
         
         <article class="global" data-name="_VM_PROT_READ">
            <h2>_VM_PROT_READ</h2>
            <hr />
            
            <pre><code>_VM_PROT_READ</code></pre>
         </article>
         
         <article class="global" data-name="_VM_PROT_WRITE">
            <h2>_VM_PROT_WRITE</h2>
            <hr />
            
            <pre><code>_VM_PROT_WRITE</code></pre>
         </article>
         
         <article class="global" data-name="_VM_PROT_EXECUTE">
            <h2>_VM_PROT_EXECUTE</h2>
            <hr />
            
            <pre><code>_VM_PROT_EXECUTE</code></pre>
         </article>
         
         <article class="global" data-name="_MACH_SEND_INVALID_DEST">
            <h2>_MACH_SEND_INVALID_DEST</h2>
            <hr />
            
            <pre><code>_MACH_SEND_INVALID_DEST</code></pre>
         </article>
         
         <article class="global" data-name="_MAXPATHLEN">
            <h2>_MAXPATHLEN</h2>
            <hr />
            
            <pre><code>_MAXPATHLEN</code></pre>
         </article>
         
         <article class="global" data-name="memSink">
            <h2>memSink</h2>
            <hr />
            
            <pre><code>memSink any</code></pre>
         </article>
         
         <article class="global" data-name="persistentMemSink">
            <h2>persistentMemSink</h2>
            <hr />
            
            <pre><code>persistentMemSink *Obj32</code></pre>
         </article>
         
         <article class="global" data-name="memoryProfilerRun">
            <h2>memoryProfilerRun</h2>
            <hr />
            
            <pre><code>memoryProfilerRun</code></pre>
         </article>
         
         <article class="global" data-name="salt1">
            <h2>salt1</h2>
            <hr />
            
            <pre><code>salt1</code></pre>
         </article>
         
         <article class="global" data-name="salt2">
            <h2>salt2</h2>
            <hr />
            
            <pre><code>salt2</code></pre>
         </article>
         
         <article class="global" data-name="diffCPUTimeImpl">
            <h2>diffCPUTimeImpl</h2>
            <hr />
            
            <pre><code>diffCPUTimeImpl func</code></pre>
         </article>
         
         <article class="global" data-name="emptyCallStackTestRun">
            <h2>emptyCallStackTestRun</h2>
            <hr />
            
            <pre><code>emptyCallStackTestRun int64</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <p>ensure that stack records are valid map keys (comparable)</p>
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="profSelfMapsTests">
            <h2>profSelfMapsTests</h2>
            <hr />
            
            <pre><code>profSelfMapsTests</code></pre>
         </article>
         
         <article class="global" data-name="profSelfMapsTestsWithDeleted">
            <h2>profSelfMapsTestsWithDeleted</h2>
            <hr />
            
            <pre><code>profSelfMapsTestsWithDeleted</code></pre>
         </article>
         
         <article class="global" data-name="profiles">
            <h2>profiles</h2>
            <hr />
            
            <p>profiles records all registered profiles.</p>
            
            <pre><code>profiles *ast.StructType</code></pre>
         </article>
         
         <article class="global" data-name="goroutineProfile">
            <h2>goroutineProfile</h2>
            <hr />
            
            <pre><code>goroutineProfile</code></pre>
         </article>
         
         <article class="global" data-name="threadcreateProfile">
            <h2>threadcreateProfile</h2>
            <hr />
            
            <pre><code>threadcreateProfile</code></pre>
         </article>
         
         <article class="global" data-name="heapProfile">
            <h2>heapProfile</h2>
            <hr />
            
            <pre><code>heapProfile</code></pre>
         </article>
         
         <article class="global" data-name="allocsProfile">
            <h2>allocsProfile</h2>
            <hr />
            
            <pre><code>allocsProfile</code></pre>
         </article>
         
         <article class="global" data-name="blockProfile">
            <h2>blockProfile</h2>
            <hr />
            
            <pre><code>blockProfile</code></pre>
         </article>
         
         <article class="global" data-name="mutexProfile">
            <h2>mutexProfile</h2>
            <hr />
            
            <pre><code>mutexProfile</code></pre>
         </article>
         
         <article class="global" data-name="cpu">
            <h2>cpu</h2>
            <hr />
            
            <pre><code>cpu *ast.StructType</code></pre>
         </article>
          
         <article class="struct" data-name="opAlloc">
            <h2>type opAlloc struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">buf []byte</code></pre>
         </article>
         
         <article class="struct" data-name="opCall">
            <h2>type opCall struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="mapping">
            <h2>type mapping struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">hi uint64
lo uint64
err error</code></pre>
         </article>
         
         <article class="struct" data-name="machVMRegionBasicInfoData">
            <h2>type machVMRegionBasicInfoData struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Protection int32
Max_protection int32
Inheritance uint32
Shared int32
Reserved int32
Offset []byte
Behavior int32
User_wired_count uint16
Pad_cgo_1 []byte</code></pre>
         </article>
         
         <article class="struct" data-name="label">
            <h2>type label struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">key string
value string</code></pre>
         </article>
         
         <article class="struct" data-name="LabelSet">
            <h2>type LabelSet struct</h2>
            <hr />
            
            <p>LabelSet is a set of labels.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">list []label</code></pre>
         </article>
         
         <article class="struct" data-name="labelContextKey">
            <h2>type labelContextKey struct</h2>
            <hr />
            
            <p>labelContextKey is the type of contextKeys used for profiler labels.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="labelMap">
            <h2>type labelMap struct</h2>
            <hr />
            
            <p>labelMap is the representation of the label set held in the context type.
This is an initial implementation, but it will be replaced with something
that admits incremental immutable modification more efficiently.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">LabelSet</code></pre>
         </article>
         
         <article class="struct" data-name="profMap">
            <h2>type profMap struct</h2>
            <hr />
            
            <p>A profMap is a map from (stack, tag) to mapEntry.
It grows without bound, but that's assumed to be OK.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">hash *ast.MapType
all *profMapEntry
last *profMapEntry
free []profMapEntry
freeStk []uintptr</code></pre>
         </article>
         
         <article class="struct" data-name="profMapEntry">
            <h2>type profMapEntry struct</h2>
            <hr />
            
            <p>A profMapEntry is a single entry in the profMap.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">nextHash *profMapEntry
nextAll *profMapEntry
stk []uintptr
tag unsafe.Pointer
count int64</code></pre>
         </article>
         
         <article class="struct" data-name="profileBuilder">
            <h2>type profileBuilder struct</h2>
            <hr />
            
            <p>A profileBuilder writes a profile incrementally from a
stream of profile samples delivered by the runtime.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">start time.Time
end time.Time
havePeriod bool
period int64
m profMap
w io.Writer
zw *gzip.Writer
pb protobuf
strings []string
stringMap *ast.MapType
locs *ast.MapType
funcs *ast.MapType
mem []memMap
deck pcDeck</code></pre>
         </article>
         
         <article class="struct" data-name="memMap">
            <h2>type memMap struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">start uintptr
end uintptr
offset uint64
file string
buildID string
funcs symbolizeFlag
fake bool</code></pre>
         </article>
         
         <article class="struct" data-name="locInfo">
            <h2>type locInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">id uint64
pcs []uintptr
firstPCFrames []runtime.Frame
firstPCSymbolizeResult symbolizeFlag</code></pre>
         </article>
         
         <article class="struct" data-name="pcDeck">
            <h2>type pcDeck struct</h2>
            <hr />
            
            <p>pcDeck is a helper to detect a sequence of inlined functions from
a stack trace returned by the runtime.

The stack traces returned by runtime's trackback functions are fully
expanded (at least for Go functions) and include the fake pcs representing
inlined functions. The profile proto expects the inlined functions to be
encoded in one Location message.
https://github.com/google/pprof/blob/5e965273ee43930341d897407202dd5e10e952cb/proto/profile.proto#L177-L184

Runtime does not directly expose whether a frame is for an inlined function
and looking up debug info is not ideal, so we use a heuristic to filter
the fake pcs and restore the inlined and entry functions. Inlined functions
have the following properties:

	Frame's Func is nil (note: also true for non-Go functions), and
	Frame's Entry matches its entry function frame's Entry (note: could also be true for recursive calls and non-Go functions), and
	Frame's Name does not match its entry function frame's name (note: inlined functions cannot be directly recursive).

As reading and processing the pcs in a stack trace one by one (from leaf to the root),
we use pcDeck to temporarily hold the observed pcs and their expanded frames
until we observe the entry function frame.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pcs []uintptr
frames []runtime.Frame
symbolizeResult symbolizeFlag
firstPCFrames int
firstPCSymbolizeResult symbolizeFlag</code></pre>
         </article>
         
         <article class="struct" data-name="machVMRegionBasicInfoData">
            <h2>type machVMRegionBasicInfoData struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Protection int32
Max_protection int32
Inheritance uint32
Shared uint32
Reserved uint32
Offset []byte
Behavior int32
User_wired_count uint16
Pad_cgo_1 []byte</code></pre>
         </article>
         
         <article class="struct" data-name="Obj32">
            <h2>type Obj32 struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">link *Obj32
pad []byte</code></pre>
         </article>
         
         <article class="struct" data-name="inlineWrapper">
            <h2>type inlineWrapper struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="Profile">
            <h2>type Profile struct</h2>
            <hr />
            
            <p>A Profile is a collection of stack traces showing the call sequences
that led to instances of a particular event, such as allocation.
Packages can create and maintain their own profiles; the most common
use is for tracking resources that must be explicitly closed, such as files
or network connections.

A Profile's methods can be called from multiple goroutines simultaneously.

Each Profile has a unique name. A few profiles are predefined:

	goroutine    - stack traces of all current goroutines
	heap         - a sampling of memory allocations of live objects
	allocs       - a sampling of all past memory allocations
	threadcreate - stack traces that led to the creation of new OS threads
	block        - stack traces that led to blocking on synchronization primitives
	mutex        - stack traces of holders of contended mutexes

These predefined profiles maintain themselves and panic on an explicit
[Profile.Add] or [Profile.Remove] method call.

The CPU profile is not available as a Profile. It has a special API,
the [StartCPUProfile] and [StopCPUProfile] functions, because it streams
output to a writer during profiling.

# Heap profile

The heap profile reports statistics as of the most recently completed
garbage collection; it elides more recent allocation to avoid skewing
the profile away from live data and toward garbage.
If there has been no garbage collection at all, the heap profile reports
all known allocations. This exception helps mainly in programs running
without garbage collection enabled, usually for debugging purposes.

The heap profile tracks both the allocation sites for all live objects in
the application memory and for all objects allocated since the program start.
Pprof's -inuse_space, -inuse_objects, -alloc_space, and -alloc_objects
flags select which to display, defaulting to -inuse_space (live objects,
scaled by size).

# Allocs profile

The allocs profile is the same as the heap profile but changes the default
pprof display to -alloc_space, the total number of bytes allocated since
the program began (including garbage-collected bytes).

# Block profile

The block profile tracks time spent blocked on synchronization primitives,
such as [sync.Mutex], [sync.RWMutex], [sync.WaitGroup], [sync.Cond], and
channel send/receive/select.

Stack traces correspond to the location that blocked (for example,
[sync.Mutex.Lock]).

Sample values correspond to cumulative time spent blocked at that stack
trace, subject to time-based sampling specified by
[runtime.SetBlockProfileRate].

# Mutex profile

The mutex profile tracks contention on mutexes, such as [sync.Mutex],
[sync.RWMutex], and runtime-internal locks.

Stack traces correspond to the end of the critical section causing
contention. For example, a lock held for a long time while other goroutines
are waiting to acquire the lock will report contention when the lock is
finally unlocked (that is, at [sync.Mutex.Unlock]).

Sample values correspond to the approximate cumulative time other goroutines
spent blocked waiting for the lock, subject to event-based sampling
specified by [runtime.SetMutexProfileFraction]. For example, if a caller
holds a lock for 1s while 5 other goroutines are waiting for the entire
second to acquire the lock, its unlock call stack will report 5s of
contention.

Runtime-internal locks are always reported at the location
"runtime._LostContendedRuntimeLock". More detailed stack traces for
runtime-internal locks can be obtained by setting
`GODEBUG=runtimecontentionstacks=1` (see package [runtime] docs for
caveats).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
mu sync.Mutex
m *ast.MapType
count func
write func</code></pre>
         </article>
         
         <article class="struct" data-name="keysByCount">
            <h2>type keysByCount struct</h2>
            <hr />
            
            <p>keysByCount sorts keys with higher counts first, breaking ties by key string order.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">keys []string
count *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="runtimeProfile">
            <h2>type runtimeProfile struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">stk []profilerecord.StackRecord
labels []unsafe.Pointer</code></pre>
         </article>
         
         <article class="struct" data-name="protobuf">
            <h2>type protobuf struct</h2>
            <hr />
            
            <p>A protobuf is a simple protocol buffer encoder.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">data []byte
tmp []byte
nest int</code></pre>
         </article>
          
         <article class="function" data-name="TestConvertMemProfile">
            <h2>TestConvertMemProfile</h2>
            <hr />
            
            <pre><code>func TestConvertMemProfile(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="genericAllocFunc">
            <h2>genericAllocFunc</h2>
            <hr />
            
            <pre><code>func genericAllocFunc(n int) []T</code></pre>
         </article>
         
         <article class="function" data-name="profileToStrings">
            <h2>profileToStrings</h2>
            <hr />
            
            <pre><code>func profileToStrings(p *profile.Profile) []string</code></pre>
         </article>
         
         <article class="function" data-name="sampleToString">
            <h2>sampleToString</h2>
            <hr />
            
            <pre><code>func sampleToString(s *profile.Sample) string</code></pre>
         </article>
         
         <article class="function" data-name="locationToStrings">
            <h2>locationToStrings</h2>
            <hr />
            
            <pre><code>func locationToStrings(loc *profile.Location, funcs []string) []string</code></pre>
         </article>
         
         <article class="function" data-name="TestGenericsHashKeyInPprofBuilder">
            <h2>TestGenericsHashKeyInPprofBuilder</h2>
            <hr />
            
            <p>This is a regression test for https://go.dev/issue/64528.</p>
            
            <pre><code>func TestGenericsHashKeyInPprofBuilder(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="storeAlloc">
            <h2>storeAlloc</h2>
            <hr />
            
            <pre><code>func storeAlloc()</code></pre>
         </article>
         
         <article class="function" data-name="nonRecursiveGenericAllocFunction">
            <h2>nonRecursiveGenericAllocFunction</h2>
            <hr />
            
            <pre><code>func nonRecursiveGenericAllocFunction(alloc bool)</code></pre>
         </article>
         
         <article class="function" data-name="TestGenericsInlineLocations">
            <h2>TestGenericsInlineLocations</h2>
            <hr />
            
            <pre><code>func TestGenericsInlineLocations(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="growMap">
            <h2>growMap</h2>
            <hr />
            
            <pre><code>func growMap()</code></pre>
         </article>
         
         <article class="function" data-name="TestHeapRuntimeFrames">
            <h2>TestHeapRuntimeFrames</h2>
            <hr />
            
            <p>Runtime frames are hidden in heap profiles.
This is a regression test for https://go.dev/issue/71174.</p>
            
            <pre><code>func TestHeapRuntimeFrames(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSetGoroutineLabels">
            <h2>TestSetGoroutineLabels</h2>
            <hr />
            
            <pre><code>func TestSetGoroutineLabels(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDo">
            <h2>TestDo</h2>
            <hr />
            
            <pre><code>func TestDo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="getProfLabel">
            <h2>getProfLabel</h2>
            <hr />
            
            <pre><code>func getProfLabel() *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="diffCPUTimeRUsage">
            <h2>diffCPUTimeRUsage</h2>
            <hr />
            
            <pre><code>func diffCPUTimeRUsage(f func) (user time.Duration, system time.Duration)</code></pre>
         </article>
         
         <article class="function" data-name="isExecutable">
            <h2>isExecutable</h2>
            <hr />
            
            <pre><code>func isExecutable(protection int32) bool</code></pre>
         </article>
         
         <article class="function" data-name="machVMInfo">
            <h2>machVMInfo</h2>
            <hr />
            
            <p>machVMInfo uses the mach_vm_region region system call to add mapping entries
for the text region of the running process.</p>
            
            <pre><code>func machVMInfo(addMapping func) bool</code></pre>
         </article>
         
         <article class="function" data-name="read64">
            <h2>read64</h2>
            <hr />
            
            <pre><code>func read64(p *[]byte) uint64</code></pre>
         </article>
         
         <article class="function" data-name="regionFilename">
            <h2>regionFilename</h2>
            <hr />
            
            <pre><code>func regionFilename(address uint64) string</code></pre>
         </article>
         
         <article class="function" data-name="mach_vm_region">
            <h2>mach_vm_region</h2>
            <hr />
            
            <p>mach_vm_region and proc_regionfilename are implemented by
the runtime package (runtime/sys_darwin.go).</p>
            
            <pre><code>func mach_vm_region(address *uint64, region_size *uint64, info unsafe.Pointer) int32</code></pre>
         </article>
         
         <article class="function" data-name="proc_regionfilename">
            <h2>proc_regionfilename</h2>
            <hr />
            
            <pre><code>func proc_regionfilename(pid int, address uint64, buf *byte, buflen int64) int32</code></pre>
         </article>
         
         <article class="function" data-name="elfBuildID">
            <h2>elfBuildID</h2>
            <hr />
            
            <p>elfBuildID returns the GNU build ID of the named ELF binary,
without introducing a dependency on debug/elf and its dependencies.</p>
            
            <pre><code>func elfBuildID(file string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="addMaxRSS">
            <h2>addMaxRSS</h2>
            <hr />
            
            <p>Adds MaxRSS to platforms that are supported.</p>
            
            <pre><code>func addMaxRSS(w io.Writer)</code></pre>
         </article>
         
         <article class="function" data-name="readMapping">
            <h2>readMapping</h2>
            <hr />
            
            <p>readMapping reads /proc/self/maps and writes mappings to b.pb.
It saves the address ranges of the mappings in b.mem for use
when emitting locations.</p>
            
            <pre><code>func readMapping()</code></pre>
         </article>
         
         <article class="function" data-name="readMainModuleMapping">
            <h2>readMainModuleMapping</h2>
            <hr />
            
            <pre><code>func readMainModuleMapping() (start uint64, end uint64, exe string, buildID string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TestVMInfo">
            <h2>TestVMInfo</h2>
            <hr />
            
            <pre><code>func TestVMInfo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="useVMMapWithRetry">
            <h2>useVMMapWithRetry</h2>
            <hr />
            
            <pre><code>func useVMMapWithRetry(t *testing.T) (hi uint64, lo uint64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="useVMMap">
            <h2>useVMMap</h2>
            <hr />
            
            <pre><code>func useVMMap(t *testing.T) (hi uint64, lo uint64, retryable bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="parseVmmap">
            <h2>parseVmmap</h2>
            <hr />
            
            <p>parseVmmap parses the output of vmmap and calls addMapping for the first r-x TEXT segment in the output.</p>
            
            <pre><code>func parseVmmap(data []byte) (hi uint64, lo uint64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="labelValue">
            <h2>labelValue</h2>
            <hr />
            
            <pre><code>func labelValue(ctx context.Context) labelMap</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String satisfies Stringer and returns key, value pairs in a consistent
order.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="WithLabels">
            <h2>WithLabels</h2>
            <hr />
            
            <p>WithLabels returns a new [context.Context] with the given labels added.
A label overwrites a prior label with the same key.</p>
            
            <pre><code>func WithLabels(ctx context.Context, labels LabelSet) context.Context</code></pre>
         </article>
         
         <article class="function" data-name="mergeLabelSets">
            <h2>mergeLabelSets</h2>
            <hr />
            
            <pre><code>func mergeLabelSets(left LabelSet, right LabelSet) LabelSet</code></pre>
         </article>
         
         <article class="function" data-name="Labels">
            <h2>Labels</h2>
            <hr />
            
            <p>Labels takes an even number of strings representing key-value pairs
and makes a [LabelSet] containing them.
A label overwrites a prior label with the same key.
Currently only the CPU and goroutine profiles utilize any labels
information.
See https://golang.org/issue/23458 for details.</p>
            
            <pre><code>func Labels(args ...string) LabelSet</code></pre>
         </article>
         
         <article class="function" data-name="Label">
            <h2>Label</h2>
            <hr />
            
            <p>Label returns the value of the label with the given key on ctx, and a boolean indicating
whether that label exists.</p>
            
            <pre><code>func Label(ctx context.Context, key string) (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="ForLabels">
            <h2>ForLabels</h2>
            <hr />
            
            <p>ForLabels invokes f with each label set on the context.
The function f should return true to continue iteration or false to stop iteration early.</p>
            
            <pre><code>func ForLabels(ctx context.Context, f func)</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <pre><code>func lookup(stk []uint64, tag unsafe.Pointer) *profMapEntry</code></pre>
         </article>
         
         <article class="function" data-name="peBuildID">
            <h2>peBuildID</h2>
            <hr />
            
            <p>peBuildID returns a best effort unique ID for the named executable.

It would be wasteful to calculate the hash of the whole file,
instead use the binary name and the last modified time for the buildid.</p>
            
            <pre><code>func peBuildID(file string) string</code></pre>
         </article>
         
         <article class="function" data-name="addMaxRSS">
            <h2>addMaxRSS</h2>
            <hr />
            
            <p>Stub call for platforms that don't support rusage.</p>
            
            <pre><code>func addMaxRSS(w io.Writer)</code></pre>
         </article>
         
         <article class="function" data-name="lostProfileEvent">
            <h2>lostProfileEvent</h2>
            <hr />
            
            <p>lostProfileEvent is the function to which lost profiling
events are attributed.
(The name shows up in the pprof graphs.)</p>
            
            <pre><code>func lostProfileEvent()</code></pre>
         </article>
         
         <article class="function" data-name="stringIndex">
            <h2>stringIndex</h2>
            <hr />
            
            <p>stringIndex adds s to the string table if not already present
and returns the index of s in the string table.</p>
            
            <pre><code>func stringIndex(s string) int64</code></pre>
         </article>
         
         <article class="function" data-name="flush">
            <h2>flush</h2>
            <hr />
            
            <pre><code>func flush()</code></pre>
         </article>
         
         <article class="function" data-name="pbValueType">
            <h2>pbValueType</h2>
            <hr />
            
            <p>pbValueType encodes a ValueType message to b.pb.</p>
            
            <pre><code>func pbValueType(tag int, typ string, unit string)</code></pre>
         </article>
         
         <article class="function" data-name="pbSample">
            <h2>pbSample</h2>
            <hr />
            
            <p>pbSample encodes a Sample message to b.pb.</p>
            
            <pre><code>func pbSample(values []int64, locs []uint64, labels func)</code></pre>
         </article>
         
         <article class="function" data-name="pbLabel">
            <h2>pbLabel</h2>
            <hr />
            
            <p>pbLabel encodes a Label message to b.pb.</p>
            
            <pre><code>func pbLabel(tag int, key string, str string, num int64)</code></pre>
         </article>
         
         <article class="function" data-name="pbLine">
            <h2>pbLine</h2>
            <hr />
            
            <p>pbLine encodes a Line message to b.pb.</p>
            
            <pre><code>func pbLine(tag int, funcID uint64, line int64)</code></pre>
         </article>
         
         <article class="function" data-name="pbMapping">
            <h2>pbMapping</h2>
            <hr />
            
            <p>pbMapping encodes a Mapping message to b.pb.</p>
            
            <pre><code>func pbMapping(tag int, id uint64, base uint64, limit uint64, offset uint64, file string, buildID string, hasFuncs bool)</code></pre>
         </article>
         
         <article class="function" data-name="allFrames">
            <h2>allFrames</h2>
            <hr />
            
            <pre><code>func allFrames(addr uintptr) ([]runtime.Frame, symbolizeFlag)</code></pre>
         </article>
         
         <article class="function" data-name="newProfileBuilder">
            <h2>newProfileBuilder</h2>
            <hr />
            
            <p>newProfileBuilder returns a new profileBuilder.
CPU profiling data obtained from the runtime can be added
by calling b.addCPUData, and then the eventual profile
can be obtained by calling b.finish.</p>
            
            <pre><code>func newProfileBuilder(w io.Writer) *profileBuilder</code></pre>
         </article>
         
         <article class="function" data-name="addCPUData">
            <h2>addCPUData</h2>
            <hr />
            
            <p>addCPUData adds the CPU profiling data to the profile.

The data must be a whole number of records, as delivered by the runtime.
len(tags) must be equal to the number of records in data.</p>
            
            <pre><code>func addCPUData(data []uint64, tags []unsafe.Pointer) error</code></pre>
         </article>
         
         <article class="function" data-name="build">
            <h2>build</h2>
            <hr />
            
            <p>build completes and returns the constructed profile.</p>
            
            <pre><code>func build()</code></pre>
         </article>
         
         <article class="function" data-name="appendLocsForStack">
            <h2>appendLocsForStack</h2>
            <hr />
            
            <p>appendLocsForStack appends the location IDs for the given stack trace to the given
location ID slice, locs. The addresses in the stack are return PCs or 1 + the PC of
an inline marker as the runtime traceback function returns.

It may return an empty slice even if locs is non-empty, for example if locs consists
solely of runtime.goexit. We still count these empty stacks in profiles in order to
get the right cumulative sample count.

It may emit to b.pb, so there must be no message encoding in progress.</p>
            
            <pre><code>func appendLocsForStack(locs []uint64, stk []uintptr) newLocs []uint64</code></pre>
         </article>
         
         <article class="function" data-name="reset">
            <h2>reset</h2>
            <hr />
            
            <pre><code>func reset()</code></pre>
         </article>
         
         <article class="function" data-name="tryAdd">
            <h2>tryAdd</h2>
            <hr />
            
            <p>tryAdd tries to add the pc and Frames expanded from it (most likely one,
since the stack trace is already fully expanded) and the symbolizeResult
to the deck. If it fails the caller needs to flush the deck and retry.</p>
            
            <pre><code>func tryAdd(pc uintptr, frames []runtime.Frame, symbolizeResult symbolizeFlag) success bool</code></pre>
         </article>
         
         <article class="function" data-name="emitLocation">
            <h2>emitLocation</h2>
            <hr />
            
            <p>emitLocation emits the new location and function information recorded in the deck
and returns the location ID encoded in the profile protobuf.
It emits to b.pb, so there must be no message encoding in progress.
It resets the deck.</p>
            
            <pre><code>func emitLocation() uint64</code></pre>
         </article>
         
         <article class="function" data-name="parseProcSelfMaps">
            <h2>parseProcSelfMaps</h2>
            <hr />
            
            <pre><code>func parseProcSelfMaps(data []byte, addMapping func)</code></pre>
         </article>
         
         <article class="function" data-name="addMapping">
            <h2>addMapping</h2>
            <hr />
            
            <pre><code>func addMapping(lo uint64, hi uint64, offset uint64, file string, buildID string)</code></pre>
         </article>
         
         <article class="function" data-name="addMappingEntry">
            <h2>addMappingEntry</h2>
            <hr />
            
            <pre><code>func addMappingEntry(lo uint64, hi uint64, offset uint64, file string, buildID string, fake bool)</code></pre>
         </article>
         
         <article class="function" data-name="readMapping">
            <h2>readMapping</h2>
            <hr />
            
            <p>readMapping adds a mapping entry for the text region of the running process.
It uses the mach_vm_region region system call to add mapping entries for the
text region of the running process. Note that currently no attempt is
made to obtain the buildID information.</p>
            
            <pre><code>func readMapping()</code></pre>
         </article>
         
         <article class="function" data-name="readMainModuleMapping">
            <h2>readMainModuleMapping</h2>
            <hr />
            
            <pre><code>func readMainModuleMapping() (start uint64, end uint64, exe string, buildID string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="labelsSorted">
            <h2>labelsSorted</h2>
            <hr />
            
            <pre><code>func labelsSorted(ctx context.Context) []label</code></pre>
         </article>
         
         <article class="function" data-name="TestContextLabels">
            <h2>TestContextLabels</h2>
            <hr />
            
            <pre><code>func TestContextLabels(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLabelMapStringer">
            <h2>TestLabelMapStringer</h2>
            <hr />
            
            <pre><code>func TestLabelMapStringer(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkLabels">
            <h2>BenchmarkLabels</h2>
            <hr />
            
            <pre><code>func BenchmarkLabels(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="allocateTransient1M">
            <h2>allocateTransient1M</h2>
            <hr />
            
            <pre><code>func allocateTransient1M()</code></pre>
         </article>
         
         <article class="function" data-name="allocateTransient2M">
            <h2>allocateTransient2M</h2>
            <hr />
            
            <pre><code>func allocateTransient2M()</code></pre>
         </article>
         
         <article class="function" data-name="allocateTransient2MInline">
            <h2>allocateTransient2MInline</h2>
            <hr />
            
            <pre><code>func allocateTransient2MInline()</code></pre>
         </article>
         
         <article class="function" data-name="allocatePersistent1K">
            <h2>allocatePersistent1K</h2>
            <hr />
            
            <pre><code>func allocatePersistent1K()</code></pre>
         </article>
         
         <article class="function" data-name="allocateReflectTransient">
            <h2>allocateReflectTransient</h2>
            <hr />
            
            <pre><code>func allocateReflectTransient()</code></pre>
         </article>
         
         <article class="function" data-name="allocateReflect">
            <h2>allocateReflect</h2>
            <hr />
            
            <pre><code>func allocateReflect()</code></pre>
         </article>
         
         <article class="function" data-name="TestMemoryProfiler">
            <h2>TestMemoryProfiler</h2>
            <hr />
            
            <pre><code>func TestMemoryProfiler(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="cpuHogger">
            <h2>cpuHogger</h2>
            <hr />
            
            <pre><code>func cpuHogger(f func, y *int, dur time.Duration)</code></pre>
         </article>
         
         <article class="function" data-name="cpuHog1">
            <h2>cpuHog1</h2>
            <hr />
            
            <p>The actual CPU hogging function.
Must not call other functions nor access heap/globals in the loop,
otherwise under race detector the samples will be in the race runtime.</p>
            
            <pre><code>func cpuHog1(x int) int</code></pre>
         </article>
         
         <article class="function" data-name="cpuHog0">
            <h2>cpuHog0</h2>
            <hr />
            
            <pre><code>func cpuHog0(x int, n int) int</code></pre>
         </article>
         
         <article class="function" data-name="cpuHog2">
            <h2>cpuHog2</h2>
            <hr />
            
            <pre><code>func cpuHog2(x int) int</code></pre>
         </article>
         
         <article class="function" data-name="avoidFunctions">
            <h2>avoidFunctions</h2>
            <hr />
            
            <p>Return a list of functions that we don't want to ever appear in CPU
profiles. For gccgo, that list includes the sigprof handler itself.</p>
            
            <pre><code>func avoidFunctions() []string</code></pre>
         </article>
         
         <article class="function" data-name="TestCPUProfile">
            <h2>TestCPUProfile</h2>
            <hr />
            
            <pre><code>func TestCPUProfile(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCPUProfileMultithreaded">
            <h2>TestCPUProfileMultithreaded</h2>
            <hr />
            
            <pre><code>func TestCPUProfileMultithreaded(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCPUProfileMultithreadMagnitude">
            <h2>TestCPUProfileMultithreadMagnitude</h2>
            <hr />
            
            <pre><code>func TestCPUProfileMultithreadMagnitude(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="containsInlinedCall">
            <h2>containsInlinedCall</h2>
            <hr />
            
            <p>containsInlinedCall reports whether the function body for the function f is
known to contain an inlined function call within the first maxBytes bytes.</p>
            
            <pre><code>func containsInlinedCall(f any, maxBytes int) bool</code></pre>
         </article>
         
         <article class="function" data-name="findInlinedCall">
            <h2>findInlinedCall</h2>
            <hr />
            
            <p>findInlinedCall returns the PC of an inlined function call within
the function body for the function f if any.</p>
            
            <pre><code>func findInlinedCall(f any, maxBytes int) (pc uint64, found bool)</code></pre>
         </article>
         
         <article class="function" data-name="TestCPUProfileInlining">
            <h2>TestCPUProfileInlining</h2>
            <hr />
            
            <pre><code>func TestCPUProfileInlining(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="inlinedCaller">
            <h2>inlinedCaller</h2>
            <hr />
            
            <pre><code>func inlinedCaller(x int) int</code></pre>
         </article>
         
         <article class="function" data-name="inlinedCallee">
            <h2>inlinedCallee</h2>
            <hr />
            
            <pre><code>func inlinedCallee(x int, n int) int</code></pre>
         </article>
         
         <article class="function" data-name="dumpCallers">
            <h2>dumpCallers</h2>
            <hr />
            
            <pre><code>func dumpCallers(pcs []uintptr)</code></pre>
         </article>
         
         <article class="function" data-name="inlinedCallerDump">
            <h2>inlinedCallerDump</h2>
            <hr />
            
            <pre><code>func inlinedCallerDump(pcs []uintptr)</code></pre>
         </article>
         
         <article class="function" data-name="inlinedCalleeDump">
            <h2>inlinedCalleeDump</h2>
            <hr />
            
            <pre><code>func inlinedCalleeDump(pcs []uintptr)</code></pre>
         </article>
         
         <article class="function" data-name="dump">
            <h2>dump</h2>
            <hr />
            
            <pre><code>func dump(pcs []uintptr)</code></pre>
         </article>
         
         <article class="function" data-name="inlinedWrapperCallerDump">
            <h2>inlinedWrapperCallerDump</h2>
            <hr />
            
            <pre><code>func inlinedWrapperCallerDump(pcs []uintptr)</code></pre>
         </article>
         
         <article class="function" data-name="TestCPUProfileRecursion">
            <h2>TestCPUProfileRecursion</h2>
            <hr />
            
            <pre><code>func TestCPUProfileRecursion(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="recursionCaller">
            <h2>recursionCaller</h2>
            <hr />
            
            <pre><code>func recursionCaller(x int) int</code></pre>
         </article>
         
         <article class="function" data-name="recursionCallee">
            <h2>recursionCallee</h2>
            <hr />
            
            <pre><code>func recursionCallee(n int, x int) int</code></pre>
         </article>
         
         <article class="function" data-name="recursionChainTop">
            <h2>recursionChainTop</h2>
            <hr />
            
            <pre><code>func recursionChainTop(x int, pcs []uintptr)</code></pre>
         </article>
         
         <article class="function" data-name="recursionChainMiddle">
            <h2>recursionChainMiddle</h2>
            <hr />
            
            <pre><code>func recursionChainMiddle(x int, pcs []uintptr)</code></pre>
         </article>
         
         <article class="function" data-name="recursionChainBottom">
            <h2>recursionChainBottom</h2>
            <hr />
            
            <pre><code>func recursionChainBottom(x int, pcs []uintptr)</code></pre>
         </article>
         
         <article class="function" data-name="parseProfile">
            <h2>parseProfile</h2>
            <hr />
            
            <pre><code>func parseProfile(t *testing.T, valBytes []byte, f func) *profile.Profile</code></pre>
         </article>
         
         <article class="function" data-name="testCPUProfile">
            <h2>testCPUProfile</h2>
            <hr />
            
            <p>testCPUProfile runs f under the CPU profiler, checking for some conditions specified by need,
as interpreted by matches, and returns the parsed profile.</p>
            
            <pre><code>func testCPUProfile(t *testing.T, matches profileMatchFunc, f func) *profile.Profile</code></pre>
         </article>
         
         <article class="function" data-name="diffCPUTime">
            <h2>diffCPUTime</h2>
            <hr />
            
            <pre><code>func diffCPUTime(t *testing.T, f func) (user time.Duration, system time.Duration)</code></pre>
         </article>
         
         <article class="function" data-name="stackContains">
            <h2>stackContains</h2>
            <hr />
            
            <p>stackContains matches if a function named spec appears anywhere in the stack trace.</p>
            
            <pre><code>func stackContains(spec string, count uintptr, stk []*profile.Location, labels *ast.MapType) bool</code></pre>
         </article>
         
         <article class="function" data-name="profileOk">
            <h2>profileOk</h2>
            <hr />
            
            <pre><code>func profileOk(t *testing.T, matches profileMatchFunc, prof bytes.Buffer, duration time.Duration) (_ *profile.Profile, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="matchAndAvoidStacks">
            <h2>matchAndAvoidStacks</h2>
            <hr />
            
            <pre><code>func matchAndAvoidStacks(matches sampleMatchFunc, need []string, avoid []string) profileMatchFunc</code></pre>
         </article>
         
         <article class="function" data-name="TestCPUProfileWithFork">
            <h2>TestCPUProfileWithFork</h2>
            <hr />
            
            <p>Fork can hang if preempted with signals frequently enough (see issue 5517).
Ensure that we do not do this.</p>
            
            <pre><code>func TestCPUProfileWithFork(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestGoroutineSwitch">
            <h2>TestGoroutineSwitch</h2>
            <hr />
            
            <p>Test that profiler does not observe runtime.gogo as "user" goroutine execution.
If it did, it would see inconsistent state and would either record an incorrect stack
or crash because the stack was malformed.</p>
            
            <pre><code>func TestGoroutineSwitch(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="fprintStack">
            <h2>fprintStack</h2>
            <hr />
            
            <pre><code>func fprintStack(w io.Writer, stk []*profile.Location)</code></pre>
         </article>
         
         <article class="function" data-name="TestMathBigDivide">
            <h2>TestMathBigDivide</h2>
            <hr />
            
            <p>Test that profiling of division operations is okay, especially on ARM. See issue 6681.</p>
            
            <pre><code>func TestMathBigDivide(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="stackContainsAll">
            <h2>stackContainsAll</h2>
            <hr />
            
            <p>stackContainsAll matches if all functions in spec (comma-separated) appear somewhere in the stack trace.</p>
            
            <pre><code>func stackContainsAll(spec string, count uintptr, stk []*profile.Location, labels *ast.MapType) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestMorestack">
            <h2>TestMorestack</h2>
            <hr />
            
            <pre><code>func TestMorestack(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="growstack1">
            <h2>growstack1</h2>
            <hr />
            
            <pre><code>func growstack1()</code></pre>
         </article>
         
         <article class="function" data-name="growstack">
            <h2>growstack</h2>
            <hr />
            
            <pre><code>func growstack(n int)</code></pre>
         </article>
         
         <article class="function" data-name="use">
            <h2>use</h2>
            <hr />
            
            <pre><code>func use(x []byte)</code></pre>
         </article>
         
         <article class="function" data-name="TestBlockProfile">
            <h2>TestBlockProfile</h2>
            <hr />
            
            <pre><code>func TestBlockProfile(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="profileStacks">
            <h2>profileStacks</h2>
            <hr />
            
            <pre><code>func profileStacks(p *profile.Profile) res [][]string</code></pre>
         </article>
         
         <article class="function" data-name="blockRecordStacks">
            <h2>blockRecordStacks</h2>
            <hr />
            
            <pre><code>func blockRecordStacks(records []runtime.BlockProfileRecord) res [][]string</code></pre>
         </article>
         
         <article class="function" data-name="containsStack">
            <h2>containsStack</h2>
            <hr />
            
            <pre><code>func containsStack(got [][]string, want []string) bool</code></pre>
         </article>
         
         <article class="function" data-name="awaitBlockedGoroutine">
            <h2>awaitBlockedGoroutine</h2>
            <hr />
            
            <p>awaitBlockedGoroutine spins on runtime.Gosched until a runtime stack dump
shows a goroutine in the given state with a stack frame in
runtime/pprof.<fName>.</p>
            
            <pre><code>func awaitBlockedGoroutine(t *testing.T, state string, fName string, count int)</code></pre>
         </article>
         
         <article class="function" data-name="blockChanRecv">
            <h2>blockChanRecv</h2>
            <hr />
            
            <pre><code>func blockChanRecv(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="blockChanSend">
            <h2>blockChanSend</h2>
            <hr />
            
            <pre><code>func blockChanSend(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="blockChanClose">
            <h2>blockChanClose</h2>
            <hr />
            
            <pre><code>func blockChanClose(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="blockSelectRecvAsync">
            <h2>blockSelectRecvAsync</h2>
            <hr />
            
            <pre><code>func blockSelectRecvAsync(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="blockSelectSendSync">
            <h2>blockSelectSendSync</h2>
            <hr />
            
            <pre><code>func blockSelectSendSync(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="blockMutex">
            <h2>blockMutex</h2>
            <hr />
            
            <pre><code>func blockMutex(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="blockMutexN">
            <h2>blockMutexN</h2>
            <hr />
            
            <pre><code>func blockMutexN(t *testing.T, n int, d time.Duration)</code></pre>
         </article>
         
         <article class="function" data-name="blockCond">
            <h2>blockCond</h2>
            <hr />
            
            <pre><code>func blockCond(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBlockProfileBias">
            <h2>TestBlockProfileBias</h2>
            <hr />
            
            <p>See http://golang.org/cl/299991.</p>
            
            <pre><code>func TestBlockProfileBias(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="blockFrequentShort">
            <h2>blockFrequentShort</h2>
            <hr />
            
            <p>blockFrequentShort produces 100000 block events with an average duration of
rate / 10.</p>
            
            <pre><code>func blockFrequentShort(rate int)</code></pre>
         </article>
         
         <article class="function" data-name="blockInfrequentLong">
            <h2>blockInfrequentLong</h2>
            <hr />
            
            <p>blockInfrequentLong produces 10000 block events with an average duration of
rate.</p>
            
            <pre><code>func blockInfrequentLong(rate int)</code></pre>
         </article>
         
         <article class="function" data-name="blockevent">
            <h2>blockevent</h2>
            <hr />
            
            <p>Used by TestBlockProfileBias.</p>
            
            <pre><code>func blockevent(cycles int64, skip int)</code></pre>
         </article>
         
         <article class="function" data-name="TestMutexProfile">
            <h2>TestMutexProfile</h2>
            <hr />
            
            <pre><code>func TestMutexProfile(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMutexProfileRateAdjust">
            <h2>TestMutexProfileRateAdjust</h2>
            <hr />
            
            <pre><code>func TestMutexProfileRateAdjust(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="func1">
            <h2>func1</h2>
            <hr />
            
            <pre><code>func func1(c *ast.ChanType)</code></pre>
         </article>
         
         <article class="function" data-name="func2">
            <h2>func2</h2>
            <hr />
            
            <pre><code>func func2(c *ast.ChanType)</code></pre>
         </article>
         
         <article class="function" data-name="func3">
            <h2>func3</h2>
            <hr />
            
            <pre><code>func func3(c *ast.ChanType)</code></pre>
         </article>
         
         <article class="function" data-name="func4">
            <h2>func4</h2>
            <hr />
            
            <pre><code>func func4(c *ast.ChanType)</code></pre>
         </article>
         
         <article class="function" data-name="TestGoroutineCounts">
            <h2>TestGoroutineCounts</h2>
            <hr />
            
            <pre><code>func TestGoroutineCounts(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="containsInOrder">
            <h2>containsInOrder</h2>
            <hr />
            
            <pre><code>func containsInOrder(s string, all ...string) bool</code></pre>
         </article>
         
         <article class="function" data-name="containsCountsLabels">
            <h2>containsCountsLabels</h2>
            <hr />
            
            <pre><code>func containsCountsLabels(prof *profile.Profile, countLabels *ast.MapType) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestGoroutineProfileConcurrency">
            <h2>TestGoroutineProfileConcurrency</h2>
            <hr />
            
            <pre><code>func TestGoroutineProfileConcurrency(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestGoroutineProfileCoro">
            <h2>TestGoroutineProfileCoro</h2>
            <hr />
            
            <p>Regression test for #69998.</p>
            
            <pre><code>func TestGoroutineProfileCoro(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestGoroutineProfileIssue74090">
            <h2>TestGoroutineProfileIssue74090</h2>
            <hr />
            
            <p>This test tries to provoke a situation wherein the finalizer goroutine is
erroneously inspected by the goroutine profiler in such a way that could
cause a crash. See go.dev/issue/74090.</p>
            
            <pre><code>func TestGoroutineProfileIssue74090(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkGoroutine">
            <h2>BenchmarkGoroutine</h2>
            <hr />
            
            <pre><code>func BenchmarkGoroutine(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="TestEmptyCallStack">
            <h2>TestEmptyCallStack</h2>
            <hr />
            
            <p>Issue 18836.</p>
            
            <pre><code>func TestEmptyCallStack(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="stackContainsLabeled">
            <h2>stackContainsLabeled</h2>
            <hr />
            
            <p>stackContainsLabeled takes a spec like funcname;key=value and matches if the stack has that key
and value and has funcname somewhere in the stack.</p>
            
            <pre><code>func stackContainsLabeled(spec string, count uintptr, stk []*profile.Location, labels *ast.MapType) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestCPUProfileLabel">
            <h2>TestCPUProfileLabel</h2>
            <hr />
            
            <pre><code>func TestCPUProfileLabel(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLabelRace">
            <h2>TestLabelRace</h2>
            <hr />
            
            <pre><code>func TestLabelRace(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestGoroutineProfileLabelRace">
            <h2>TestGoroutineProfileLabelRace</h2>
            <hr />
            
            <pre><code>func TestGoroutineProfileLabelRace(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLabelSystemstack">
            <h2>TestLabelSystemstack</h2>
            <hr />
            
            <p>TestLabelSystemstack makes sure CPU profiler samples of goroutines running
on systemstack include the correct pprof labels. See issue #48577</p>
            
            <pre><code>func TestLabelSystemstack(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="labelHog">
            <h2>labelHog</h2>
            <hr />
            
            <p>labelHog is designed to burn CPU time in a way that a high number of CPU
samples end up running on systemstack.</p>
            
            <pre><code>func labelHog(stop *ast.ChanType, gogc int)</code></pre>
         </article>
         
         <article class="function" data-name="parallelLabelHog">
            <h2>parallelLabelHog</h2>
            <hr />
            
            <p>parallelLabelHog runs GOMAXPROCS goroutines running labelHog.</p>
            
            <pre><code>func parallelLabelHog(ctx context.Context, dur time.Duration, gogc int)</code></pre>
         </article>
         
         <article class="function" data-name="TestAtomicLoadStore64">
            <h2>TestAtomicLoadStore64</h2>
            <hr />
            
            <p>Check that there is no deadlock when the program receives SIGPROF while in
64bit atomics' critical section. Used to happen on mips{,le}. See #20146.</p>
            
            <pre><code>func TestAtomicLoadStore64(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestTracebackAll">
            <h2>TestTracebackAll</h2>
            <hr />
            
            <pre><code>func TestTracebackAll(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestTryAdd">
            <h2>TestTryAdd</h2>
            <hr />
            
            <p>TestTryAdd tests the cases that are hard to test with real program execution.

For example, the current go compilers may not always inline functions
involved in recursion but that may not be true in the future compilers. This
tests such cases by using fake call sequences and forcing the profile build
utilizing translateCPUProfile defined in proto_test.go</p>
            
            <pre><code>func TestTryAdd(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestTimeVDSO">
            <h2>TestTimeVDSO</h2>
            <hr />
            
            <pre><code>func TestTimeVDSO(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestProfilerStackDepth">
            <h2>TestProfilerStackDepth</h2>
            <hr />
            
            <pre><code>func TestProfilerStackDepth(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="hasPrefix">
            <h2>hasPrefix</h2>
            <hr />
            
            <pre><code>func hasPrefix(stk []string, prefix []string) bool</code></pre>
         </article>
         
         <article class="function" data-name="allocDeep">
            <h2>allocDeep</h2>
            <hr />
            
            <p>allocDeep calls itself n times before calling fn.</p>
            
            <pre><code>func allocDeep(n int)</code></pre>
         </article>
         
         <article class="function" data-name="blockChanDeep">
            <h2>blockChanDeep</h2>
            <hr />
            
            <p>blockChanDeep produces a block profile event at stack depth n, including the
caller.</p>
            
            <pre><code>func blockChanDeep(t *testing.T, n int)</code></pre>
         </article>
         
         <article class="function" data-name="blockMutexDeep">
            <h2>blockMutexDeep</h2>
            <hr />
            
            <p>blockMutexDeep produces a block profile event at stack depth n, including the
caller.</p>
            
            <pre><code>func blockMutexDeep(t *testing.T, n int)</code></pre>
         </article>
         
         <article class="function" data-name="goroutineDeep">
            <h2>goroutineDeep</h2>
            <hr />
            
            <p>goroutineDeep blocks at stack depth n, including the caller until the test is
finished.</p>
            
            <pre><code>func goroutineDeep(t *testing.T, n int)</code></pre>
         </article>
         
         <article class="function" data-name="produceProfileEvents">
            <h2>produceProfileEvents</h2>
            <hr />
            
            <p>produceProfileEvents produces pprof events at the given stack depth and then
blocks in goroutineDeep until the test completes. The stack traces are
guaranteed to have exactly the desired depth with produceProfileEvents as
their root frame which is expected by TestProfilerStackDepth.</p>
            
            <pre><code>func produceProfileEvents(t *testing.T, depth int)</code></pre>
         </article>
         
         <article class="function" data-name="getProfileStacks">
            <h2>getProfileStacks</h2>
            <hr />
            
            <pre><code>func getProfileStacks(collect func, fileLine bool) []string</code></pre>
         </article>
         
         <article class="function" data-name="TestMutexBlockFullAggregation">
            <h2>TestMutexBlockFullAggregation</h2>
            <hr />
            
            <pre><code>func TestMutexBlockFullAggregation(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="inlineA">
            <h2>inlineA</h2>
            <hr />
            
            <pre><code>func inlineA(mu *sync.Mutex, wg *sync.WaitGroup)</code></pre>
         </article>
         
         <article class="function" data-name="inlineB">
            <h2>inlineB</h2>
            <hr />
            
            <pre><code>func inlineB(mu *sync.Mutex, wg *sync.WaitGroup)</code></pre>
         </article>
         
         <article class="function" data-name="inlineC">
            <h2>inlineC</h2>
            <hr />
            
            <pre><code>func inlineC(mu *sync.Mutex, wg *sync.WaitGroup)</code></pre>
         </article>
         
         <article class="function" data-name="inlineD">
            <h2>inlineD</h2>
            <hr />
            
            <pre><code>func inlineD(mu *sync.Mutex, wg *sync.WaitGroup)</code></pre>
         </article>
         
         <article class="function" data-name="inlineE">
            <h2>inlineE</h2>
            <hr />
            
            <pre><code>func inlineE(mu *sync.Mutex, wg *sync.WaitGroup)</code></pre>
         </article>
         
         <article class="function" data-name="inlineF">
            <h2>inlineF</h2>
            <hr />
            
            <pre><code>func inlineF(mu *sync.Mutex, wg *sync.WaitGroup)</code></pre>
         </article>
         
         <article class="function" data-name="TestBlockMutexProfileInlineExpansion">
            <h2>TestBlockMutexProfileInlineExpansion</h2>
            <hr />
            
            <pre><code>func TestBlockMutexProfileInlineExpansion(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestProfileRecordNullPadding">
            <h2>TestProfileRecordNullPadding</h2>
            <hr />
            
            <pre><code>func TestProfileRecordNullPadding(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testProfileRecordNullPadding">
            <h2>testProfileRecordNullPadding</h2>
            <hr />
            
            <pre><code>func testProfileRecordNullPadding(t *testing.T, name string, fn func)</code></pre>
         </article>
         
         <article class="function" data-name="disableSampling">
            <h2>disableSampling</h2>
            <hr />
            
            <p>disableSampling configures the profilers to capture all events, otherwise
it's difficult to assert anything.</p>
            
            <pre><code>func disableSampling() func</code></pre>
         </article>
         
         <article class="function" data-name="addMaxRSS">
            <h2>addMaxRSS</h2>
            <hr />
            
            <pre><code>func addMaxRSS(w io.Writer)</code></pre>
         </article>
         
         <article class="function" data-name="translateCPUProfile">
            <h2>translateCPUProfile</h2>
            <hr />
            
            <p>translateCPUProfile parses binary CPU profiling stack trace data
generated by runtime.CPUProfile() into a profile struct.
This is only used for testing. Real conversions stream the
data into the profileBuilder as it becomes available.

count is the number of records in data.</p>
            
            <pre><code>func translateCPUProfile(data []uint64, count int) (*profile.Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="fmtJSON">
            <h2>fmtJSON</h2>
            <hr />
            
            <p>fmtJSON returns a pretty-printed JSON form for x.
It works reasonably well for printing protocol-buffer
data structures like profile.Profile.</p>
            
            <pre><code>func fmtJSON(x any) string</code></pre>
         </article>
         
         <article class="function" data-name="TestConvertCPUProfileNoSamples">
            <h2>TestConvertCPUProfileNoSamples</h2>
            <hr />
            
            <pre><code>func TestConvertCPUProfileNoSamples(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="f1">
            <h2>f1</h2>
            <hr />
            
            <pre><code>func f1()</code></pre>
         </article>
         
         <article class="function" data-name="f2">
            <h2>f2</h2>
            <hr />
            
            <pre><code>func f2()</code></pre>
         </article>
         
         <article class="function" data-name="testPCs">
            <h2>testPCs</h2>
            <hr />
            
            <p>testPCs returns two PCs and two corresponding memory mappings
to use in test profiles.</p>
            
            <pre><code>func testPCs(t *testing.T) (addr1 uint64, addr2 uint64, map1 *profile.Mapping, map2 *profile.Mapping)</code></pre>
         </article>
         
         <article class="function" data-name="TestConvertCPUProfile">
            <h2>TestConvertCPUProfile</h2>
            <hr />
            
            <pre><code>func TestConvertCPUProfile(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="checkProfile">
            <h2>checkProfile</h2>
            <hr />
            
            <pre><code>func checkProfile(t *testing.T, p *profile.Profile, period int64, periodType *profile.ValueType, sampleType []*profile.ValueType, samples []*profile.Sample, defaultSampleType string)</code></pre>
         </article>
         
         <article class="function" data-name="TestProcSelfMaps">
            <h2>TestProcSelfMaps</h2>
            <hr />
            
            <pre><code>func TestProcSelfMaps(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMapping">
            <h2>TestMapping</h2>
            <hr />
            
            <p>TestMapping checks the mapping section of CPU profiles
has the HasFunctions field set correctly. If all PCs included
in the samples are successfully symbolized, the corresponding
mapping entry (in this test case, only one entry) should have
its HasFunctions field set true.
The test generates a CPU profile that includes PCs from C side
that the runtime can't symbolize. See ./testdata/mappingtest.</p>
            
            <pre><code>func TestMapping(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="symbolized">
            <h2>symbolized</h2>
            <hr />
            
            <pre><code>func symbolized(loc *profile.Location) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestFakeMapping">
            <h2>TestFakeMapping</h2>
            <hr />
            
            <p>TestFakeMapping tests if at least one mapping exists
(including a fake mapping), and their HasFunctions bits
are set correctly.</p>
            
            <pre><code>func TestFakeMapping(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEmptyStack">
            <h2>TestEmptyStack</h2>
            <hr />
            
            <p>Make sure the profiler can handle an empty stack trace.
See issue 37967.</p>
            
            <pre><code>func TestEmptyStack(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="writeHeapProto">
            <h2>writeHeapProto</h2>
            <hr />
            
            <p>writeHeapProto writes the current heap profile in protobuf format to w.</p>
            
            <pre><code>func writeHeapProto(w io.Writer, p []profilerecord.MemProfileRecord, rate int64, defaultSampleType string) error</code></pre>
         </article>
         
         <article class="function" data-name="scaleHeapSample">
            <h2>scaleHeapSample</h2>
            <hr />
            
            <p>scaleHeapSample adjusts the data from a heap Sample to
account for its probability of appearing in the collected
data. heap profiles are a sampling of the memory allocations
requests in a program. We estimate the unsampled value by dividing
each collected sample by its probability of appearing in the
profile. heap profiles rely on a poisson process to determine
which samples to collect, based on the desired average collection
rate R. The probability of a sample of size S to appear in that
profile is 1-exp(-S/R).</p>
            
            <pre><code>func scaleHeapSample(count int64, size int64, rate int64) (int64, int64)</code></pre>
         </article>
         
         <article class="function" data-name="runtime_FrameStartLine">
            <h2>runtime_FrameStartLine</h2>
            <hr />
            
            <p>runtime_FrameStartLine is defined in runtime/symtab.go.</p>
            
            <pre><code>func runtime_FrameStartLine(f *runtime.Frame) int</code></pre>
         </article>
         
         <article class="function" data-name="runtime_FrameSymbolName">
            <h2>runtime_FrameSymbolName</h2>
            <hr />
            
            <p>runtime_FrameSymbolName is defined in runtime/symtab.go.</p>
            
            <pre><code>func runtime_FrameSymbolName(f *runtime.Frame) string</code></pre>
         </article>
         
         <article class="function" data-name="runtime_expandFinalInlineFrame">
            <h2>runtime_expandFinalInlineFrame</h2>
            <hr />
            
            <p>runtime_expandFinalInlineFrame is defined in runtime/symtab.go.</p>
            
            <pre><code>func runtime_expandFinalInlineFrame(stk []uintptr) []uintptr</code></pre>
         </article>
         
         <article class="function" data-name="runtime_setProfLabel">
            <h2>runtime_setProfLabel</h2>
            <hr />
            
            <p>runtime_setProfLabel is defined in runtime/proflabel.go.</p>
            
            <pre><code>func runtime_setProfLabel(labels unsafe.Pointer)</code></pre>
         </article>
         
         <article class="function" data-name="runtime_getProfLabel">
            <h2>runtime_getProfLabel</h2>
            <hr />
            
            <p>runtime_getProfLabel is defined in runtime/proflabel.go.</p>
            
            <pre><code>func runtime_getProfLabel() unsafe.Pointer</code></pre>
         </article>
         
         <article class="function" data-name="SetGoroutineLabels">
            <h2>SetGoroutineLabels</h2>
            <hr />
            
            <p>SetGoroutineLabels sets the current goroutine's labels to match ctx.
A new goroutine inherits the labels of the goroutine that created it.
This is a lower-level API than [Do], which should be used instead when possible.</p>
            
            <pre><code>func SetGoroutineLabels(ctx context.Context)</code></pre>
         </article>
         
         <article class="function" data-name="Do">
            <h2>Do</h2>
            <hr />
            
            <p>Do calls f with a copy of the parent context with the
given labels added to the parent's label map.
Goroutines spawned while executing f will inherit the augmented label-set.
Each key/value pair in labels is inserted into the label map in the
order provided, overriding any previous value for the same key.
The augmented label map will be set for the duration of the call to f
and restored once f returns.</p>
            
            <pre><code>func Do(ctx context.Context, labels LabelSet, f func)</code></pre>
         </article>
         
         <article class="function" data-name="lockProfiles">
            <h2>lockProfiles</h2>
            <hr />
            
            <pre><code>func lockProfiles()</code></pre>
         </article>
         
         <article class="function" data-name="unlockProfiles">
            <h2>unlockProfiles</h2>
            <hr />
            
            <pre><code>func unlockProfiles()</code></pre>
         </article>
         
         <article class="function" data-name="NewProfile">
            <h2>NewProfile</h2>
            <hr />
            
            <p>NewProfile creates a new profile with the given name.
If a profile with that name already exists, NewProfile panics.
The convention is to use a 'import/path.' prefix to create
separate name spaces for each package.
For compatibility with various tools that read pprof data,
profile names should not contain spaces.</p>
            
            <pre><code>func NewProfile(name string) *Profile</code></pre>
         </article>
         
         <article class="function" data-name="Lookup">
            <h2>Lookup</h2>
            <hr />
            
            <p>Lookup returns the profile with the given name, or nil if no such profile exists.</p>
            
            <pre><code>func Lookup(name string) *Profile</code></pre>
         </article>
         
         <article class="function" data-name="Profiles">
            <h2>Profiles</h2>
            <hr />
            
            <p>Profiles returns a slice of all the known profiles, sorted by name.</p>
            
            <pre><code>func Profiles() []*Profile</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <p>Name returns this profile's name, which can be passed to [Lookup] to reobtain the profile.</p>
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="Count">
            <h2>Count</h2>
            <hr />
            
            <p>Count returns the number of execution stacks currently in the profile.</p>
            
            <pre><code>func Count() int</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add adds the current execution stack to the profile, associated with value.
Add stores value in an internal map, so value must be suitable for use as
a map key and will not be garbage collected until the corresponding
call to [Profile.Remove]. Add panics if the profile already contains a stack for value.

The skip parameter has the same meaning as [runtime.Caller]'s skip
and controls where the stack trace begins. Passing skip=0 begins the
trace in the function calling Add. For example, given this
execution stack:

	Add
	called from rpc.NewClient
	called from mypkg.Run
	called from main.main

Passing skip=0 begins the stack trace at the call to Add inside rpc.NewClient.
Passing skip=1 begins the stack trace at the call to NewClient inside mypkg.Run.</p>
            
            <pre><code>func Add(value any, skip int)</code></pre>
         </article>
         
         <article class="function" data-name="Remove">
            <h2>Remove</h2>
            <hr />
            
            <p>Remove removes the execution stack associated with value from the profile.
It is a no-op if the value is not in the profile.</p>
            
            <pre><code>func Remove(value any)</code></pre>
         </article>
         
         <article class="function" data-name="WriteTo">
            <h2>WriteTo</h2>
            <hr />
            
            <p>WriteTo writes a pprof-formatted snapshot of the profile to w.
If a write to w returns an error, WriteTo returns that error.
Otherwise, WriteTo returns nil.

The debug parameter enables additional output.
Passing debug=0 writes the gzip-compressed protocol buffer described
in https://github.com/google/pprof/tree/main/proto#overview.
Passing debug=1 writes the legacy text format with comments
translating addresses to function names and line numbers, so that a
programmer can read the profile without tools.

The predefined profiles may assign meaning to other debug values;
for example, when printing the "goroutine" profile, debug=2 means to
print the goroutine stacks in the same form that a Go program uses
when dying due to an unrecovered panic.</p>
            
            <pre><code>func WriteTo(w io.Writer, debug int) error</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Stack">
            <h2>Stack</h2>
            <hr />
            
            <pre><code>func Stack(i int) []uintptr</code></pre>
         </article>
         
         <article class="function" data-name="Label">
            <h2>Label</h2>
            <hr />
            
            <pre><code>func Label(i int) *labelMap</code></pre>
         </article>
         
         <article class="function" data-name="expandInlinedFrames">
            <h2>expandInlinedFrames</h2>
            <hr />
            
            <p>expandInlinedFrames copies the call stack from pcs into dst, expanding any
PCs corresponding to inlined calls into the corresponding PCs for the inlined
functions. Returns the number of frames copied to dst.</p>
            
            <pre><code>func expandInlinedFrames(dst []uintptr, pcs []uintptr) int</code></pre>
         </article>
         
         <article class="function" data-name="printCountCycleProfile">
            <h2>printCountCycleProfile</h2>
            <hr />
            
            <p>printCountCycleProfile outputs block profile records (for block or mutex profiles)
as the pprof-proto format output. Translations from cycle count to time duration
are done because The proto expects count and time (nanoseconds) instead of count
and the number of cycles for block, contention profiles.</p>
            
            <pre><code>func printCountCycleProfile(w io.Writer, countName string, cycleName string, records []profilerecord.BlockProfileRecord) error</code></pre>
         </article>
         
         <article class="function" data-name="printCountProfile">
            <h2>printCountProfile</h2>
            <hr />
            
            <p>printCountProfile prints a countProfile at the specified debug level.
The profile will be in compressed proto format unless debug is nonzero.</p>
            
            <pre><code>func printCountProfile(w io.Writer, debug int, name string, p countProfile) error</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="printStackRecord">
            <h2>printStackRecord</h2>
            <hr />
            
            <p>printStackRecord prints the function + source line information
for a single stack trace.</p>
            
            <pre><code>func printStackRecord(w io.Writer, stk []uintptr, allFrames bool)</code></pre>
         </article>
         
         <article class="function" data-name="WriteHeapProfile">
            <h2>WriteHeapProfile</h2>
            <hr />
            
            <p>WriteHeapProfile is shorthand for [Lookup]("heap").WriteTo(w, 0).
It is preserved for backwards compatibility.</p>
            
            <pre><code>func WriteHeapProfile(w io.Writer) error</code></pre>
         </article>
         
         <article class="function" data-name="countHeap">
            <h2>countHeap</h2>
            <hr />
            
            <p>countHeap returns the number of records in the heap profile.</p>
            
            <pre><code>func countHeap() int</code></pre>
         </article>
         
         <article class="function" data-name="writeHeap">
            <h2>writeHeap</h2>
            <hr />
            
            <p>writeHeap writes the current runtime heap profile to w.</p>
            
            <pre><code>func writeHeap(w io.Writer, debug int) error</code></pre>
         </article>
         
         <article class="function" data-name="writeAlloc">
            <h2>writeAlloc</h2>
            <hr />
            
            <p>writeAlloc writes the current runtime heap profile to w
with the total allocation space as the default sample type.</p>
            
            <pre><code>func writeAlloc(w io.Writer, debug int) error</code></pre>
         </article>
         
         <article class="function" data-name="writeHeapInternal">
            <h2>writeHeapInternal</h2>
            <hr />
            
            <pre><code>func writeHeapInternal(w io.Writer, debug int, defaultSampleType string) error</code></pre>
         </article>
         
         <article class="function" data-name="countThreadCreate">
            <h2>countThreadCreate</h2>
            <hr />
            
            <p>countThreadCreate returns the size of the current ThreadCreateProfile.</p>
            
            <pre><code>func countThreadCreate() int</code></pre>
         </article>
         
         <article class="function" data-name="writeThreadCreate">
            <h2>writeThreadCreate</h2>
            <hr />
            
            <p>writeThreadCreate writes the current runtime ThreadCreateProfile to w.</p>
            
            <pre><code>func writeThreadCreate(w io.Writer, debug int) error</code></pre>
         </article>
         
         <article class="function" data-name="countGoroutine">
            <h2>countGoroutine</h2>
            <hr />
            
            <p>countGoroutine returns the number of goroutines.</p>
            
            <pre><code>func countGoroutine() int</code></pre>
         </article>
         
         <article class="function" data-name="writeGoroutine">
            <h2>writeGoroutine</h2>
            <hr />
            
            <p>writeGoroutine writes the current runtime GoroutineProfile to w.</p>
            
            <pre><code>func writeGoroutine(w io.Writer, debug int) error</code></pre>
         </article>
         
         <article class="function" data-name="writeGoroutineStacks">
            <h2>writeGoroutineStacks</h2>
            <hr />
            
            <pre><code>func writeGoroutineStacks(w io.Writer) error</code></pre>
         </article>
         
         <article class="function" data-name="writeRuntimeProfile">
            <h2>writeRuntimeProfile</h2>
            <hr />
            
            <pre><code>func writeRuntimeProfile(w io.Writer, debug int, name string, fetch func) error</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Stack">
            <h2>Stack</h2>
            <hr />
            
            <pre><code>func Stack(i int) []uintptr</code></pre>
         </article>
         
         <article class="function" data-name="Label">
            <h2>Label</h2>
            <hr />
            
            <pre><code>func Label(i int) *labelMap</code></pre>
         </article>
         
         <article class="function" data-name="StartCPUProfile">
            <h2>StartCPUProfile</h2>
            <hr />
            
            <p>StartCPUProfile enables CPU profiling for the current process.
While profiling, the profile will be buffered and written to w.
StartCPUProfile returns an error if profiling is already enabled.

On Unix-like systems, StartCPUProfile does not work by default for
Go code built with -buildmode=c-archive or -buildmode=c-shared.
StartCPUProfile relies on the SIGPROF signal, but that signal will
be delivered to the main program's SIGPROF signal handler (if any)
not to the one used by Go. To make it work, call [os/signal.Notify]
for [syscall.SIGPROF], but note that doing so may break any profiling
being done by the main program.</p>
            
            <pre><code>func StartCPUProfile(w io.Writer) error</code></pre>
         </article>
         
         <article class="function" data-name="readProfile">
            <h2>readProfile</h2>
            <hr />
            
            <p>readProfile, provided by the runtime, returns the next chunk of
binary CPU profiling stack trace data, blocking until data is available.
If profiling is turned off and all the profile data accumulated while it was
on has been returned, readProfile returns eof=true.
The caller must save the returned data and tags before calling readProfile again.</p>
            
            <pre><code>func readProfile() (data []uint64, tags []unsafe.Pointer, eof bool)</code></pre>
         </article>
         
         <article class="function" data-name="profileWriter">
            <h2>profileWriter</h2>
            <hr />
            
            <pre><code>func profileWriter(w io.Writer)</code></pre>
         </article>
         
         <article class="function" data-name="StopCPUProfile">
            <h2>StopCPUProfile</h2>
            <hr />
            
            <p>StopCPUProfile stops the current CPU profile, if any.
StopCPUProfile only returns after all the writes for the
profile have completed.</p>
            
            <pre><code>func StopCPUProfile()</code></pre>
         </article>
         
         <article class="function" data-name="countBlock">
            <h2>countBlock</h2>
            <hr />
            
            <p>countBlock returns the number of records in the blocking profile.</p>
            
            <pre><code>func countBlock() int</code></pre>
         </article>
         
         <article class="function" data-name="countMutex">
            <h2>countMutex</h2>
            <hr />
            
            <p>countMutex returns the number of records in the mutex profile.</p>
            
            <pre><code>func countMutex() int</code></pre>
         </article>
         
         <article class="function" data-name="writeBlock">
            <h2>writeBlock</h2>
            <hr />
            
            <p>writeBlock writes the current blocking profile to w.</p>
            
            <pre><code>func writeBlock(w io.Writer, debug int) error</code></pre>
         </article>
         
         <article class="function" data-name="writeMutex">
            <h2>writeMutex</h2>
            <hr />
            
            <p>writeMutex writes the current mutex profile to w.</p>
            
            <pre><code>func writeMutex(w io.Writer, debug int) error</code></pre>
         </article>
         
         <article class="function" data-name="writeProfileInternal">
            <h2>writeProfileInternal</h2>
            <hr />
            
            <p>writeProfileInternal writes the current blocking or mutex profile depending on the passed parameters.</p>
            
            <pre><code>func writeProfileInternal(w io.Writer, debug int, name string, runtimeProfile func) error</code></pre>
         </article>
         
         <article class="function" data-name="pprof_goroutineProfileWithLabels">
            <h2>pprof_goroutineProfileWithLabels</h2>
            <hr />
            
            <pre><code>func pprof_goroutineProfileWithLabels(p []profilerecord.StackRecord, labels []unsafe.Pointer) (n int, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="pprof_cyclesPerSecond">
            <h2>pprof_cyclesPerSecond</h2>
            <hr />
            
            <pre><code>func pprof_cyclesPerSecond() int64</code></pre>
         </article>
         
         <article class="function" data-name="pprof_memProfileInternal">
            <h2>pprof_memProfileInternal</h2>
            <hr />
            
            <pre><code>func pprof_memProfileInternal(p []profilerecord.MemProfileRecord, inuseZero bool) (n int, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="pprof_blockProfileInternal">
            <h2>pprof_blockProfileInternal</h2>
            <hr />
            
            <pre><code>func pprof_blockProfileInternal(p []profilerecord.BlockProfileRecord) (n int, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="pprof_mutexProfileInternal">
            <h2>pprof_mutexProfileInternal</h2>
            <hr />
            
            <pre><code>func pprof_mutexProfileInternal(p []profilerecord.BlockProfileRecord) (n int, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="pprof_threadCreateInternal">
            <h2>pprof_threadCreateInternal</h2>
            <hr />
            
            <pre><code>func pprof_threadCreateInternal(p []profilerecord.StackRecord) (n int, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="pprof_fpunwindExpand">
            <h2>pprof_fpunwindExpand</h2>
            <hr />
            
            <pre><code>func pprof_fpunwindExpand(dst []uintptr, src []uintptr) int</code></pre>
         </article>
         
         <article class="function" data-name="pprof_makeProfStack">
            <h2>pprof_makeProfStack</h2>
            <hr />
            
            <pre><code>func pprof_makeProfStack() []uintptr</code></pre>
         </article>
         
         <article class="function" data-name="readMapping">
            <h2>readMapping</h2>
            <hr />
            
            <p>readMapping adds memory mapping information to the profile.</p>
            
            <pre><code>func readMapping()</code></pre>
         </article>
         
         <article class="function" data-name="readMainModuleMapping">
            <h2>readMainModuleMapping</h2>
            <hr />
            
            <pre><code>func readMainModuleMapping() (start uint64, end uint64, exe string, buildID string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="createModuleSnapshot">
            <h2>createModuleSnapshot</h2>
            <hr />
            
            <pre><code>func createModuleSnapshot() (syscall.Handle, error)</code></pre>
         </article>
         
         <article class="function" data-name="varint">
            <h2>varint</h2>
            <hr />
            
            <pre><code>func varint(x uint64)</code></pre>
         </article>
         
         <article class="function" data-name="length">
            <h2>length</h2>
            <hr />
            
            <pre><code>func length(tag int, len int)</code></pre>
         </article>
         
         <article class="function" data-name="uint64">
            <h2>uint64</h2>
            <hr />
            
            <pre><code>func uint64(tag int, x uint64)</code></pre>
         </article>
         
         <article class="function" data-name="uint64s">
            <h2>uint64s</h2>
            <hr />
            
            <pre><code>func uint64s(tag int, x []uint64)</code></pre>
         </article>
         
         <article class="function" data-name="uint64Opt">
            <h2>uint64Opt</h2>
            <hr />
            
            <pre><code>func uint64Opt(tag int, x uint64)</code></pre>
         </article>
         
         <article class="function" data-name="int64">
            <h2>int64</h2>
            <hr />
            
            <pre><code>func int64(tag int, x int64)</code></pre>
         </article>
         
         <article class="function" data-name="int64Opt">
            <h2>int64Opt</h2>
            <hr />
            
            <pre><code>func int64Opt(tag int, x int64)</code></pre>
         </article>
         
         <article class="function" data-name="int64s">
            <h2>int64s</h2>
            <hr />
            
            <pre><code>func int64s(tag int, x []int64)</code></pre>
         </article>
         
         <article class="function" data-name="string">
            <h2>string</h2>
            <hr />
            
            <pre><code>func string(tag int, x string)</code></pre>
         </article>
         
         <article class="function" data-name="strings">
            <h2>strings</h2>
            <hr />
            
            <pre><code>func strings(tag int, x []string)</code></pre>
         </article>
         
         <article class="function" data-name="stringOpt">
            <h2>stringOpt</h2>
            <hr />
            
            <pre><code>func stringOpt(tag int, x string)</code></pre>
         </article>
         
         <article class="function" data-name="bool">
            <h2>bool</h2>
            <hr />
            
            <pre><code>func bool(tag int, x bool)</code></pre>
         </article>
         
         <article class="function" data-name="boolOpt">
            <h2>boolOpt</h2>
            <hr />
            
            <pre><code>func boolOpt(tag int, x bool)</code></pre>
         </article>
         
         <article class="function" data-name="startMessage">
            <h2>startMessage</h2>
            <hr />
            
            <pre><code>func startMessage() msgOffset</code></pre>
         </article>
         
         <article class="function" data-name="endMessage">
            <h2>endMessage</h2>
            <hr />
            
            <pre><code>func endMessage(tag int, start msgOffset)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
