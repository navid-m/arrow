<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - hpack</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>hpack</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"io"
"bytes"
"errors"
"fmt"
"bytes"
"errors"
"io"
"sync"
"fmt"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ErrInvalidHuffman" data-name="ErrInvalidHuffman">
               <h3>
                  ErrInvalidHuffman 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrInvalidHuffman" class="anchor" title="Link to ErrInvalidHuffman">#</a>
               </h3>
               
               <p>ErrInvalidHuffman is returned for errors found decoding
Huffman-encoded strings.</p>
               
               <pre><code class="language-go">var ErrInvalidHuffman = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrStringLength" data-name="ErrStringLength">
               <h3>
                  ErrStringLength 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrStringLength" class="anchor" title="Link to ErrStringLength">#</a>
               </h3>
               
               <p>ErrStringLength is returned by Decoder.Write when the max string length
(as configured by Decoder.SetMaxStringLength) would be violated.</p>
               
               <pre><code class="language-go">var ErrStringLength = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bufPool" data-name="bufPool">
               <h3>
                  bufPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bufPool" class="anchor" title="Link to bufPool">#</a>
               </h3>
               
               <pre><code class="language-go">var bufPool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="buildRootOnce" data-name="buildRootOnce">
               <h3>
                  buildRootOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#buildRootOnce" class="anchor" title="Link to buildRootOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var buildRootOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNeedMore" data-name="errNeedMore">
               <h3>
                  errNeedMore 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNeedMore" class="anchor" title="Link to errNeedMore">#</a>
               </h3>
               
               <p>errNeedMore is an internal sentinel error value that means the
buffer is truncated and we need to read more data before we can
continue parsing.</p>
               
               <pre><code class="language-go">var errNeedMore = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errVarintOverflow" data-name="errVarintOverflow">
               <h3>
                  errVarintOverflow 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errVarintOverflow" class="anchor" title="Link to errVarintOverflow">#</a>
               </h3>
               
               <pre><code class="language-go">var errVarintOverflow = DecodingError{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="huffmanCodeLen" data-name="huffmanCodeLen">
               <h3>
                  huffmanCodeLen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#huffmanCodeLen" class="anchor" title="Link to huffmanCodeLen">#</a>
               </h3>
               
               <pre><code class="language-go">var huffmanCodeLen = [256]uint8{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="huffmanCodes" data-name="huffmanCodes">
               <h3>
                  huffmanCodes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#huffmanCodes" class="anchor" title="Link to huffmanCodes">#</a>
               </h3>
               
               <pre><code class="language-go">var huffmanCodes = [256]uint32{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="indexedFalse" data-name="indexedFalse">
               <h3>
                  indexedFalse 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#indexedFalse" class="anchor" title="Link to indexedFalse">#</a>
               </h3>
               
               <pre><code class="language-go">const indexedFalse</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="indexedNever" data-name="indexedNever">
               <h3>
                  indexedNever 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#indexedNever" class="anchor" title="Link to indexedNever">#</a>
               </h3>
               
               <pre><code class="language-go">const indexedNever</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="indexedTrue" data-name="indexedTrue">
               <h3>
                  indexedTrue 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#indexedTrue" class="anchor" title="Link to indexedTrue">#</a>
               </h3>
               
               <pre><code class="language-go">const indexedTrue indexType = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initialHeaderTableSize" data-name="initialHeaderTableSize">
               <h3>
                  initialHeaderTableSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#initialHeaderTableSize" class="anchor" title="Link to initialHeaderTableSize">#</a>
               </h3>
               
               <pre><code class="language-go">const initialHeaderTableSize = 4096</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="lazyRootHuffmanNode" data-name="lazyRootHuffmanNode">
               <h3>
                  lazyRootHuffmanNode 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#lazyRootHuffmanNode" class="anchor" title="Link to lazyRootHuffmanNode">#</a>
               </h3>
               
               <pre><code class="language-go">var lazyRootHuffmanNode *node</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="staticTable" data-name="staticTable">
               <h3>
                  staticTable 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#staticTable" class="anchor" title="Link to staticTable">#</a>
               </h3>
               
               <pre><code class="language-go">var staticTable = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="uint32Max" data-name="uint32Max">
               <h3>
                  uint32Max 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#uint32Max" class="anchor" title="Link to uint32Max">#</a>
               </h3>
               
               <pre><code class="language-go">const uint32Max = *ast.UnaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="InvalidIndexError" data-name="InvalidIndexError">
               <h3>
                  InvalidIndexError
                  <span class="badge type-badge">type</span>
                  <a href="#InvalidIndexError" class="anchor" title="Link to InvalidIndexError">#</a>
               </h3>
               
               <p>An InvalidIndexError is returned when an encoder references a table
entry before the static table or after the end of the dynamic table.</p>
               
               <pre><code class="language-go">type InvalidIndexError int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="incomparable" data-name="incomparable">
               <h3>
                  incomparable
                  <span class="badge type-badge">type</span>
                  <a href="#incomparable" class="anchor" title="Link to incomparable">#</a>
               </h3>
               
               <p>incomparable is a zero-width, non-comparable type. Adding it to a struct
makes that struct also non-comparable, and generally doesn't add
any size (as long as it's first).</p>
               
               <pre><code class="language-go">type incomparable [0]func()</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="indexType" data-name="indexType">
               <h3>
                  indexType
                  <span class="badge type-badge">type</span>
                  <a href="#indexType" class="anchor" title="Link to indexType">#</a>
               </h3>
               
               <pre><code class="language-go">type indexType int</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Decoder" data-name="Decoder">
               <h3>
                  Decoder
                  <span class="badge">struct</span>
                  <a href="#Decoder" class="anchor" title="Link to Decoder">#</a>
               </h3>
               
               <p>A Decoder is the decoding context for incremental processing of
header blocks.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Decoder struct {
dynTab dynamicTable
emit func(f HeaderField)
emitEnabled bool
maxStrLen int
buf []byte
saveBuf bytes.Buffer
firstField bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="DecodingError" data-name="DecodingError">
               <h3>
                  DecodingError
                  <span class="badge">struct</span>
                  <a href="#DecodingError" class="anchor" title="Link to DecodingError">#</a>
               </h3>
               
               <p>A DecodingError is something the spec defines as a decoding error.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type DecodingError struct {
Err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Encoder" data-name="Encoder">
               <h3>
                  Encoder
                  <span class="badge">struct</span>
                  <a href="#Encoder" class="anchor" title="Link to Encoder">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Encoder struct {
dynTab dynamicTable
minSize uint32
maxSizeLimit uint32
tableSizeUpdate bool
w io.Writer
buf []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="HeaderField" data-name="HeaderField">
               <h3>
                  HeaderField
                  <span class="badge">struct</span>
                  <a href="#HeaderField" class="anchor" title="Link to HeaderField">#</a>
               </h3>
               
               <p>A HeaderField is a name-value pair. Both the name and value are
treated as opaque sequences of octets.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type HeaderField struct {
Name string
Value string
Sensitive bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dynamicTable" data-name="dynamicTable">
               <h3>
                  dynamicTable
                  <span class="badge">struct</span>
                  <a href="#dynamicTable" class="anchor" title="Link to dynamicTable">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type dynamicTable struct {
table headerFieldTable
size uint32
maxSize uint32
allowedMaxSize uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="headerFieldTable" data-name="headerFieldTable">
               <h3>
                  headerFieldTable
                  <span class="badge">struct</span>
                  <a href="#headerFieldTable" class="anchor" title="Link to headerFieldTable">#</a>
               </h3>
               
               <p>headerFieldTable implements a list of HeaderFields.
This is used to implement the static and dynamic tables.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type headerFieldTable struct {
ents []HeaderField
evictCount uint64
byName map[string]uint64
byNameValue map[pairNameValue]uint64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="node" data-name="node">
               <h3>
                  node
                  <span class="badge">struct</span>
                  <a href="#node" class="anchor" title="Link to node">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type node struct {
_ incomparable
children *[256]*node
codeLen uint8
sym byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pairNameValue" data-name="pairNameValue">
               <h3>
                  pairNameValue
                  <span class="badge">struct</span>
                  <a href="#pairNameValue" class="anchor" title="Link to pairNameValue">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type pairNameValue struct {
name string
value string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="undecodedString" data-name="undecodedString">
               <h3>
                  undecodedString
                  <span class="badge">struct</span>
                  <a href="#undecodedString" class="anchor" title="Link to undecodedString">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type undecodedString struct {
isHuff bool
b []byte
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AppendHuffmanString" data-name="AppendHuffmanString">
               <h3>
                  AppendHuffmanString 
                  <span class="badge">function</span>
                  
                  <a href="#AppendHuffmanString" class="anchor" title="Link to AppendHuffmanString">#</a>
               </h3>
               
               <p>AppendHuffmanString appends s, as encoded in Huffman codes, to dst
and returns the extended buffer.</p>
               
               <pre><code class="language-go">func AppendHuffmanString(dst []byte, s string) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close declares that the decoding is complete and resets the Decoder
to be reused again for a new header block. If there is any remaining
data in the decoder's buffer, Close returns an error.</p>
               
               <pre><code class="language-go">func (d *Decoder) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DecodeFull" data-name="DecodeFull">
               <h3>
                  DecodeFull 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DecodeFull" class="anchor" title="Link to DecodeFull">#</a>
               </h3>
               
               <p>DecodeFull decodes an entire block.
TODO: remove this method and make it incremental later? This is
easier for debugging now.</p>
               
               <pre><code class="language-go">func (d *Decoder) DecodeFull(p []byte) ([]HeaderField, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EmitEnabled" data-name="EmitEnabled">
               <h3>
                  EmitEnabled 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EmitEnabled" class="anchor" title="Link to EmitEnabled">#</a>
               </h3>
               
               <p>EmitEnabled reports whether calls to the emitFunc provided to NewDecoder
are currently enabled. The default is true.</p>
               
               <pre><code class="language-go">func (d *Decoder) EmitEnabled() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e InvalidIndexError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (de DecodingError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HuffmanDecode" data-name="HuffmanDecode">
               <h3>
                  HuffmanDecode 
                  <span class="badge">function</span>
                  
                  <a href="#HuffmanDecode" class="anchor" title="Link to HuffmanDecode">#</a>
               </h3>
               
               <p>HuffmanDecode decodes the string in v and writes the expanded
result to w, returning the number of bytes written to w and the
Write call's return value. At most one Write call is made.</p>
               
               <pre><code class="language-go">func HuffmanDecode(w io.Writer, v []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HuffmanDecodeToString" data-name="HuffmanDecodeToString">
               <h3>
                  HuffmanDecodeToString 
                  <span class="badge">function</span>
                  
                  <a href="#HuffmanDecodeToString" class="anchor" title="Link to HuffmanDecodeToString">#</a>
               </h3>
               
               <p>HuffmanDecodeToString decodes the string in v.</p>
               
               <pre><code class="language-go">func HuffmanDecodeToString(v []byte) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HuffmanEncodeLength" data-name="HuffmanEncodeLength">
               <h3>
                  HuffmanEncodeLength 
                  <span class="badge">function</span>
                  
                  <a href="#HuffmanEncodeLength" class="anchor" title="Link to HuffmanEncodeLength">#</a>
               </h3>
               
               <p>HuffmanEncodeLength returns the number of bytes required to encode
s in Huffman codes. The result is round up to byte boundary.</p>
               
               <pre><code class="language-go">func HuffmanEncodeLength(s string) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsPseudo" data-name="IsPseudo">
               <h3>
                  IsPseudo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsPseudo" class="anchor" title="Link to IsPseudo">#</a>
               </h3>
               
               <p>IsPseudo reports whether the header field is an http2 pseudo header.
That is, it reports whether it starts with a colon.
It is not otherwise guaranteed to be a valid pseudo header field,
though.</p>
               
               <pre><code class="language-go">func (hf HeaderField) IsPseudo() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MaxDynamicTableSize" data-name="MaxDynamicTableSize">
               <h3>
                  MaxDynamicTableSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MaxDynamicTableSize" class="anchor" title="Link to MaxDynamicTableSize">#</a>
               </h3>
               
               <p>MaxDynamicTableSize returns the current dynamic header table size.</p>
               
               <pre><code class="language-go">func (e *Encoder) MaxDynamicTableSize() (v uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewDecoder" data-name="NewDecoder">
               <h3>
                  NewDecoder 
                  <span class="badge">function</span>
                  
                  <a href="#NewDecoder" class="anchor" title="Link to NewDecoder">#</a>
               </h3>
               
               <p>NewDecoder returns a new decoder with the provided maximum dynamic
table size. The emitFunc will be called for each valid field
parsed, in the same goroutine as calls to Write, before Write returns.</p>
               
               <pre><code class="language-go">func NewDecoder(maxDynamicTableSize uint32, emitFunc func(f HeaderField)) *Decoder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewEncoder" data-name="NewEncoder">
               <h3>
                  NewEncoder 
                  <span class="badge">function</span>
                  
                  <a href="#NewEncoder" class="anchor" title="Link to NewEncoder">#</a>
               </h3>
               
               <p>NewEncoder returns a new Encoder which performs HPACK encoding. An
encoded data is written to w.</p>
               
               <pre><code class="language-go">func NewEncoder(w io.Writer) *Encoder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetAllowedMaxDynamicTableSize" data-name="SetAllowedMaxDynamicTableSize">
               <h3>
                  SetAllowedMaxDynamicTableSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetAllowedMaxDynamicTableSize" class="anchor" title="Link to SetAllowedMaxDynamicTableSize">#</a>
               </h3>
               
               <p>SetAllowedMaxDynamicTableSize sets the upper bound that the encoded
stream (via dynamic table size updates) may set the maximum size
to.</p>
               
               <pre><code class="language-go">func (d *Decoder) SetAllowedMaxDynamicTableSize(v uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetEmitEnabled" data-name="SetEmitEnabled">
               <h3>
                  SetEmitEnabled 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetEmitEnabled" class="anchor" title="Link to SetEmitEnabled">#</a>
               </h3>
               
               <p>SetEmitEnabled controls whether the emitFunc provided to NewDecoder
should be called. The default is true.
This facility exists to let servers enforce MAX_HEADER_LIST_SIZE
while still decoding and keeping in-sync with decoder state, but
without doing unnecessary decompression or generating unnecessary
garbage for header fields past the limit.</p>
               
               <pre><code class="language-go">func (d *Decoder) SetEmitEnabled(v bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetEmitFunc" data-name="SetEmitFunc">
               <h3>
                  SetEmitFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetEmitFunc" class="anchor" title="Link to SetEmitFunc">#</a>
               </h3>
               
               <p>SetEmitFunc changes the callback used when new header fields
are decoded.
It must be non-nil. It does not affect EmitEnabled.</p>
               
               <pre><code class="language-go">func (d *Decoder) SetEmitFunc(emitFunc func(f HeaderField))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetMaxDynamicTableSize" data-name="SetMaxDynamicTableSize">
               <h3>
                  SetMaxDynamicTableSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetMaxDynamicTableSize" class="anchor" title="Link to SetMaxDynamicTableSize">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *Decoder) SetMaxDynamicTableSize(v uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetMaxDynamicTableSize" data-name="SetMaxDynamicTableSize">
               <h3>
                  SetMaxDynamicTableSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetMaxDynamicTableSize" class="anchor" title="Link to SetMaxDynamicTableSize">#</a>
               </h3>
               
               <p>SetMaxDynamicTableSize changes the dynamic header table size to v.
The actual size is bounded by the value passed to
SetMaxDynamicTableSizeLimit.</p>
               
               <pre><code class="language-go">func (e *Encoder) SetMaxDynamicTableSize(v uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetMaxDynamicTableSizeLimit" data-name="SetMaxDynamicTableSizeLimit">
               <h3>
                  SetMaxDynamicTableSizeLimit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetMaxDynamicTableSizeLimit" class="anchor" title="Link to SetMaxDynamicTableSizeLimit">#</a>
               </h3>
               
               <p>SetMaxDynamicTableSizeLimit changes the maximum value that can be
specified in SetMaxDynamicTableSize to v. By default, it is set to
4096, which is the same size of the default dynamic header table
size described in HPACK specification. If the current maximum
dynamic header table size is strictly greater than v, "Header Table
Size Update" will be done in the next WriteField call and the
maximum dynamic header table size is truncated to v.</p>
               
               <pre><code class="language-go">func (e *Encoder) SetMaxDynamicTableSizeLimit(v uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetMaxStringLength" data-name="SetMaxStringLength">
               <h3>
                  SetMaxStringLength 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetMaxStringLength" class="anchor" title="Link to SetMaxStringLength">#</a>
               </h3>
               
               <p>SetMaxStringLength sets the maximum size of a HeaderField name or
value string. If a string exceeds this length (even after any
decompression), Write will return ErrStringLength.
A value of 0 means unlimited and is the default from NewDecoder.</p>
               
               <pre><code class="language-go">func (d *Decoder) SetMaxStringLength(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <p>Size returns the size of an entry per RFC 7541 section 4.1.</p>
               
               <pre><code class="language-go">func (hf HeaderField) Size() uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (hf HeaderField) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *Decoder) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteField" data-name="WriteField">
               <h3>
                  WriteField 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteField" class="anchor" title="Link to WriteField">#</a>
               </h3>
               
               <p>WriteField encodes f into a single Write to e's underlying Writer.
This function may also produce bytes for "Header Table Size Update"
if necessary. If produced, it is done before encoding f.</p>
               
               <pre><code class="language-go">func (e *Encoder) WriteField(f HeaderField) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <pre><code class="language-go">func (dt *dynamicTable) add(f HeaderField)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addEntry" data-name="addEntry">
               <h3>
                  addEntry 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addEntry" class="anchor" title="Link to addEntry">#</a>
               </h3>
               
               <p>addEntry adds a new entry.</p>
               
               <pre><code class="language-go">func (t *headerFieldTable) addEntry(f HeaderField)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendHpackString" data-name="appendHpackString">
               <h3>
                  appendHpackString 
                  <span class="badge">function</span>
                  
                  <a href="#appendHpackString" class="anchor" title="Link to appendHpackString">#</a>
               </h3>
               
               <p>appendHpackString appends s, as encoded in "String Literal"
representation, to dst and returns the extended buffer.
s will be encoded in Huffman codes only when it produces strictly
shorter byte string.</p>
               
               <pre><code class="language-go">func appendHpackString(dst []byte, s string) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendIndexed" data-name="appendIndexed">
               <h3>
                  appendIndexed 
                  <span class="badge">function</span>
                  
                  <a href="#appendIndexed" class="anchor" title="Link to appendIndexed">#</a>
               </h3>
               
               <p>appendIndexed appends index i, as encoded in "Indexed Header Field"
representation, to dst and returns the extended buffer.</p>
               
               <pre><code class="language-go">func appendIndexed(dst []byte, i uint64) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendIndexedName" data-name="appendIndexedName">
               <h3>
                  appendIndexedName 
                  <span class="badge">function</span>
                  
                  <a href="#appendIndexedName" class="anchor" title="Link to appendIndexedName">#</a>
               </h3>
               
               <p>appendIndexedName appends f and index i referring indexed name
entry, as encoded in one of "Literal Header field - Indexed Name"
representation variants, to dst and returns the extended buffer.
If f.Sensitive is true, "Never Indexed" representation is used. If
f.Sensitive is false and indexing is true, "Incremental Indexing"
representation is used.</p>
               
               <pre><code class="language-go">func appendIndexedName(dst []byte, f HeaderField, i uint64, indexing bool) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendNewName" data-name="appendNewName">
               <h3>
                  appendNewName 
                  <span class="badge">function</span>
                  
                  <a href="#appendNewName" class="anchor" title="Link to appendNewName">#</a>
               </h3>
               
               <p>appendNewName appends f, as encoded in one of "Literal Header field
- New Name" representation variants, to dst and returns the
extended buffer.
If f.Sensitive is true, "Never Indexed" representation is used. If
f.Sensitive is false and indexing is true, "Incremental Indexing"
representation is used.</p>
               
               <pre><code class="language-go">func appendNewName(dst []byte, f HeaderField, indexing bool) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendTableSize" data-name="appendTableSize">
               <h3>
                  appendTableSize 
                  <span class="badge">function</span>
                  
                  <a href="#appendTableSize" class="anchor" title="Link to appendTableSize">#</a>
               </h3>
               
               <p>appendTableSize appends v, as encoded in "Header Table Size Update"
representation, to dst and returns the extended buffer.</p>
               
               <pre><code class="language-go">func appendTableSize(dst []byte, v uint32) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendVarInt" data-name="appendVarInt">
               <h3>
                  appendVarInt 
                  <span class="badge">function</span>
                  
                  <a href="#appendVarInt" class="anchor" title="Link to appendVarInt">#</a>
               </h3>
               
               <p>appendVarInt appends i, as encoded in variable integer form using n
bit prefix, to dst and returns the extended buffer.
See
https://httpwg.org/specs/rfc7541.html#integer.representation</p>
               
               <pre><code class="language-go">func appendVarInt(dst []byte, n byte, i uint64) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="at" data-name="at">
               <h3>
                  at 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#at" class="anchor" title="Link to at">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *Decoder) at(i uint64) (hf HeaderField, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="buildRootHuffmanNode" data-name="buildRootHuffmanNode">
               <h3>
                  buildRootHuffmanNode 
                  <span class="badge">function</span>
                  
                  <a href="#buildRootHuffmanNode" class="anchor" title="Link to buildRootHuffmanNode">#</a>
               </h3>
               
               <pre><code class="language-go">func buildRootHuffmanNode()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="callEmit" data-name="callEmit">
               <h3>
                  callEmit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#callEmit" class="anchor" title="Link to callEmit">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *Decoder) callEmit(hf HeaderField) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="decodeString" data-name="decodeString">
               <h3>
                  decodeString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#decodeString" class="anchor" title="Link to decodeString">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *Decoder) decodeString(u undecodedString) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="encodeTypeByte" data-name="encodeTypeByte">
               <h3>
                  encodeTypeByte 
                  <span class="badge">function</span>
                  
                  <a href="#encodeTypeByte" class="anchor" title="Link to encodeTypeByte">#</a>
               </h3>
               
               <p>encodeTypeByte returns type byte. If sensitive is true, type byte
for "Never Indexed" representation is returned. If sensitive is
false and indexing is true, type byte for "Incremental Indexing"
representation is returned. Otherwise, type byte for "Without
Indexing" is returned.</p>
               
               <pre><code class="language-go">func encodeTypeByte(indexing bool, sensitive bool) byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evict" data-name="evict">
               <h3>
                  evict 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evict" class="anchor" title="Link to evict">#</a>
               </h3>
               
               <p>If we're too big, evict old stuff.</p>
               
               <pre><code class="language-go">func (dt *dynamicTable) evict()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evictOldest" data-name="evictOldest">
               <h3>
                  evictOldest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#evictOldest" class="anchor" title="Link to evictOldest">#</a>
               </h3>
               
               <p>evictOldest evicts the n oldest entries in the table.</p>
               
               <pre><code class="language-go">func (t *headerFieldTable) evictOldest(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getRootHuffmanNode" data-name="getRootHuffmanNode">
               <h3>
                  getRootHuffmanNode 
                  <span class="badge">function</span>
                  
                  <a href="#getRootHuffmanNode" class="anchor" title="Link to getRootHuffmanNode">#</a>
               </h3>
               
               <pre><code class="language-go">func getRootHuffmanNode() *node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="huffmanDecode" data-name="huffmanDecode">
               <h3>
                  huffmanDecode 
                  <span class="badge">function</span>
                  
                  <a href="#huffmanDecode" class="anchor" title="Link to huffmanDecode">#</a>
               </h3>
               
               <p>huffmanDecode decodes v to buf.
If maxLen is greater than 0, attempts to write more to buf than
maxLen bytes will return ErrStringLength.</p>
               
               <pre><code class="language-go">func huffmanDecode(buf *bytes.Buffer, maxLen int, v []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="idToIndex" data-name="idToIndex">
               <h3>
                  idToIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#idToIndex" class="anchor" title="Link to idToIndex">#</a>
               </h3>
               
               <p>idToIndex converts a unique id to an HPACK index.
See Section 2.3.3.</p>
               
               <pre><code class="language-go">func (t *headerFieldTable) idToIndex(id uint64) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indexed" data-name="indexed">
               <h3>
                  indexed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#indexed" class="anchor" title="Link to indexed">#</a>
               </h3>
               
               <pre><code class="language-go">func (v indexType) indexed() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *headerFieldTable) init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="len" data-name="len">
               <h3>
                  len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#len" class="anchor" title="Link to len">#</a>
               </h3>
               
               <p>len reports the number of entries in the table.</p>
               
               <pre><code class="language-go">func (t *headerFieldTable) len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maxTableIndex" data-name="maxTableIndex">
               <h3>
                  maxTableIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maxTableIndex" class="anchor" title="Link to maxTableIndex">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *Decoder) maxTableIndex() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newInternalNode" data-name="newInternalNode">
               <h3>
                  newInternalNode 
                  <span class="badge">function</span>
                  
                  <a href="#newInternalNode" class="anchor" title="Link to newInternalNode">#</a>
               </h3>
               
               <pre><code class="language-go">func newInternalNode() *node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseDynamicTableSizeUpdate" data-name="parseDynamicTableSizeUpdate">
               <h3>
                  parseDynamicTableSizeUpdate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseDynamicTableSizeUpdate" class="anchor" title="Link to parseDynamicTableSizeUpdate">#</a>
               </h3>
               
               <p>(same invariants and behavior as parseHeaderFieldRepr)</p>
               
               <pre><code class="language-go">func (d *Decoder) parseDynamicTableSizeUpdate() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseFieldIndexed" data-name="parseFieldIndexed">
               <h3>
                  parseFieldIndexed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseFieldIndexed" class="anchor" title="Link to parseFieldIndexed">#</a>
               </h3>
               
               <p>(same invariants and behavior as parseHeaderFieldRepr)</p>
               
               <pre><code class="language-go">func (d *Decoder) parseFieldIndexed() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseFieldLiteral" data-name="parseFieldLiteral">
               <h3>
                  parseFieldLiteral 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseFieldLiteral" class="anchor" title="Link to parseFieldLiteral">#</a>
               </h3>
               
               <p>(same invariants and behavior as parseHeaderFieldRepr)</p>
               
               <pre><code class="language-go">func (d *Decoder) parseFieldLiteral(n uint8, it indexType) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseHeaderFieldRepr" data-name="parseHeaderFieldRepr">
               <h3>
                  parseHeaderFieldRepr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseHeaderFieldRepr" class="anchor" title="Link to parseHeaderFieldRepr">#</a>
               </h3>
               
               <p>returns errNeedMore if there isn't enough data available.
any other error is fatal.
consumes d.buf iff it returns nil.
precondition: must be called with len(d.buf) > 0</p>
               
               <pre><code class="language-go">func (d *Decoder) parseHeaderFieldRepr() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readString" data-name="readString">
               <h3>
                  readString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readString" class="anchor" title="Link to readString">#</a>
               </h3>
               
               <p>readString reads an hpack string from p.
It returns a reference to the encoded string data to permit deferring decode costs
until after the caller verifies all data is present.</p>
               
               <pre><code class="language-go">func (d *Decoder) readString(p []byte) (u undecodedString, remain []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readVarInt" data-name="readVarInt">
               <h3>
                  readVarInt 
                  <span class="badge">function</span>
                  
                  <a href="#readVarInt" class="anchor" title="Link to readVarInt">#</a>
               </h3>
               
               <p>readVarInt reads an unsigned variable length integer off the
beginning of p. n is the parameter as described in
https://httpwg.org/specs/rfc7541.html#rfc.section.5.1.
n must always be between 1 and 8.
The returned remain buffer is either a smaller suffix of p, or err != nil.
The error is errNeedMore if p doesn't contain a complete integer.</p>
               
               <pre><code class="language-go">func readVarInt(n byte, p []byte) (i uint64, remain []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="search" data-name="search">
               <h3>
                  search 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#search" class="anchor" title="Link to search">#</a>
               </h3>
               
               <p>search finds f in the table. If there is no match, i is 0.
If both name and value match, i is the matched index and nameValueMatch
becomes true. If only name matches, i points to that index and
nameValueMatch becomes false.
The returned index is a 1-based HPACK index. For dynamic tables, HPACK says
that index 1 should be the newest entry, but t.ents[0] is the oldest entry,
meaning t.ents is reversed for dynamic tables. Hence, when t is a dynamic
table, the return value i actually refers to the entry t.ents[t.len()-i].
All tables are assumed to be a dynamic tables except for the global staticTable.
See Section 2.3.3.</p>
               
               <pre><code class="language-go">func (t *headerFieldTable) search(f HeaderField) (i uint64, nameValueMatch bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="searchTable" data-name="searchTable">
               <h3>
                  searchTable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#searchTable" class="anchor" title="Link to searchTable">#</a>
               </h3>
               
               <p>searchTable searches f in both stable and dynamic header tables.
The static header table is searched first. Only when there is no
exact match for both name and value, the dynamic header table is
then searched. If there is no match, i is 0. If both name and value
match, i is the matched index and nameValueMatch becomes true. If
only name matches, i points to that index and nameValueMatch
becomes false.</p>
               
               <pre><code class="language-go">func (e *Encoder) searchTable(f HeaderField) (i uint64, nameValueMatch bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sensitive" data-name="sensitive">
               <h3>
                  sensitive 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sensitive" class="anchor" title="Link to sensitive">#</a>
               </h3>
               
               <pre><code class="language-go">func (v indexType) sensitive() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setMaxSize" data-name="setMaxSize">
               <h3>
                  setMaxSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setMaxSize" class="anchor" title="Link to setMaxSize">#</a>
               </h3>
               
               <pre><code class="language-go">func (dt *dynamicTable) setMaxSize(v uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldIndex" data-name="shouldIndex">
               <h3>
                  shouldIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shouldIndex" class="anchor" title="Link to shouldIndex">#</a>
               </h3>
               
               <p>shouldIndex reports whether f should be indexed.</p>
               
               <pre><code class="language-go">func (e *Encoder) shouldIndex(f HeaderField) bool</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();

               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);

               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;

               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               // Apply Prism highlighting again
               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>