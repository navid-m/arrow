<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - hpack</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>hpack</code>
         </h1>
         <hr />
         
         <article class="global" data-name="ErrStringLength">
            <h2>ErrStringLength</h2>
            <hr />
            
            <p>ErrStringLength is returned by Decoder.Write when the max string length
(as configured by Decoder.SetMaxStringLength) would be violated.</p>
            
            <pre><code>ErrStringLength</code></pre>
         </article>
         
         <article class="global" data-name="errNeedMore">
            <h2>errNeedMore</h2>
            <hr />
            
            <p>errNeedMore is an internal sentinel error value that means the
buffer is truncated and we need to read more data before we can
continue parsing.</p>
            
            <pre><code>errNeedMore</code></pre>
         </article>
         
         <article class="global" data-name="indexedTrue">
            <h2>indexedTrue</h2>
            <hr />
            
            <pre><code>indexedTrue indexType</code></pre>
         </article>
         
         <article class="global" data-name="indexedFalse">
            <h2>indexedFalse</h2>
            <hr />
            
            <pre><code>indexedFalse</code></pre>
         </article>
         
         <article class="global" data-name="indexedNever">
            <h2>indexedNever</h2>
            <hr />
            
            <pre><code>indexedNever</code></pre>
         </article>
         
         <article class="global" data-name="errVarintOverflow">
            <h2>errVarintOverflow</h2>
            <hr />
            
            <pre><code>errVarintOverflow</code></pre>
         </article>
         
         <article class="global" data-name="bufPool">
            <h2>bufPool</h2>
            <hr />
            
            <pre><code>bufPool</code></pre>
         </article>
         
         <article class="global" data-name="ErrInvalidHuffman">
            <h2>ErrInvalidHuffman</h2>
            <hr />
            
            <p>ErrInvalidHuffman is returned for errors found decoding
Huffman-encoded strings.</p>
            
            <pre><code>ErrInvalidHuffman</code></pre>
         </article>
         
         <article class="global" data-name="buildRootOnce">
            <h2>buildRootOnce</h2>
            <hr />
            
            <pre><code>buildRootOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="lazyRootHuffmanNode">
            <h2>lazyRootHuffmanNode</h2>
            <hr />
            
            <pre><code>lazyRootHuffmanNode *node</code></pre>
         </article>
         
         <article class="global" data-name="staticTable">
            <h2>staticTable</h2>
            <hr />
            
            <pre><code>staticTable</code></pre>
         </article>
         
         <article class="global" data-name="huffmanCodes">
            <h2>huffmanCodes</h2>
            <hr />
            
            <pre><code>huffmanCodes</code></pre>
         </article>
         
         <article class="global" data-name="huffmanCodeLen">
            <h2>huffmanCodeLen</h2>
            <hr />
            
            <pre><code>huffmanCodeLen</code></pre>
         </article>
         
         <article class="global" data-name="uint32Max">
            <h2>uint32Max</h2>
            <hr />
            
            <pre><code>uint32Max</code></pre>
         </article>
         
         <article class="global" data-name="initialHeaderTableSize">
            <h2>initialHeaderTableSize</h2>
            <hr />
            
            <pre><code>initialHeaderTableSize</code></pre>
         </article>
          
         <article class="struct" data-name="DecodingError">
            <h2>type DecodingError struct</h2>
            <hr />
            
            <p>A DecodingError is something the spec defines as a decoding error.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Err error</code></pre>
         </article>
         
         <article class="struct" data-name="HeaderField">
            <h2>type HeaderField struct</h2>
            <hr />
            
            <p>A HeaderField is a name-value pair. Both the name and value are
treated as opaque sequences of octets.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name string
Value string
Sensitive bool</code></pre>
         </article>
         
         <article class="struct" data-name="Decoder">
            <h2>type Decoder struct</h2>
            <hr />
            
            <p>A Decoder is the decoding context for incremental processing of
header blocks.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">dynTab dynamicTable
emit func
emitEnabled bool
maxStrLen int
buf []byte
saveBuf bytes.Buffer
firstField bool</code></pre>
         </article>
         
         <article class="struct" data-name="dynamicTable">
            <h2>type dynamicTable struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">table headerFieldTable
size uint32
maxSize uint32
allowedMaxSize uint32</code></pre>
         </article>
         
         <article class="struct" data-name="undecodedString">
            <h2>type undecodedString struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">isHuff bool
b []byte</code></pre>
         </article>
         
         <article class="struct" data-name="node">
            <h2>type node struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">_ incomparable
children *[]*node
codeLen uint8
sym byte</code></pre>
         </article>
         
         <article class="struct" data-name="headerFieldTable">
            <h2>type headerFieldTable struct</h2>
            <hr />
            
            <p>headerFieldTable implements a list of HeaderFields.
This is used to implement the static and dynamic tables.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ents []HeaderField
evictCount uint64
byName *ast.MapType
byNameValue *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="pairNameValue">
            <h2>type pairNameValue struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
value string</code></pre>
         </article>
         
         <article class="struct" data-name="Encoder">
            <h2>type Encoder struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">dynTab dynamicTable
minSize uint32
maxSizeLimit uint32
tableSizeUpdate bool
w io.Writer
buf []byte</code></pre>
         </article>
          
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="IsPseudo">
            <h2>IsPseudo</h2>
            <hr />
            
            <p>IsPseudo reports whether the header field is an http2 pseudo header.
That is, it reports whether it starts with a colon.
It is not otherwise guaranteed to be a valid pseudo header field,
though.</p>
            
            <pre><code>func IsPseudo() bool</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Size">
            <h2>Size</h2>
            <hr />
            
            <p>Size returns the size of an entry per RFC 7541 section 4.1.</p>
            
            <pre><code>func Size() uint32</code></pre>
         </article>
         
         <article class="function" data-name="NewDecoder">
            <h2>NewDecoder</h2>
            <hr />
            
            <p>NewDecoder returns a new decoder with the provided maximum dynamic
table size. The emitFunc will be called for each valid field
parsed, in the same goroutine as calls to Write, before Write returns.</p>
            
            <pre><code>func NewDecoder(maxDynamicTableSize uint32, emitFunc func) *Decoder</code></pre>
         </article>
         
         <article class="function" data-name="SetMaxStringLength">
            <h2>SetMaxStringLength</h2>
            <hr />
            
            <p>SetMaxStringLength sets the maximum size of a HeaderField name or
value string. If a string exceeds this length (even after any
decompression), Write will return ErrStringLength.
A value of 0 means unlimited and is the default from NewDecoder.</p>
            
            <pre><code>func SetMaxStringLength(n int)</code></pre>
         </article>
         
         <article class="function" data-name="SetEmitFunc">
            <h2>SetEmitFunc</h2>
            <hr />
            
            <p>SetEmitFunc changes the callback used when new header fields
are decoded.
It must be non-nil. It does not affect EmitEnabled.</p>
            
            <pre><code>func SetEmitFunc(emitFunc func)</code></pre>
         </article>
         
         <article class="function" data-name="SetEmitEnabled">
            <h2>SetEmitEnabled</h2>
            <hr />
            
            <p>SetEmitEnabled controls whether the emitFunc provided to NewDecoder
should be called. The default is true.

This facility exists to let servers enforce MAX_HEADER_LIST_SIZE
while still decoding and keeping in-sync with decoder state, but
without doing unnecessary decompression or generating unnecessary
garbage for header fields past the limit.</p>
            
            <pre><code>func SetEmitEnabled(v bool)</code></pre>
         </article>
         
         <article class="function" data-name="EmitEnabled">
            <h2>EmitEnabled</h2>
            <hr />
            
            <p>EmitEnabled reports whether calls to the emitFunc provided to NewDecoder
are currently enabled. The default is true.</p>
            
            <pre><code>func EmitEnabled() bool</code></pre>
         </article>
         
         <article class="function" data-name="SetMaxDynamicTableSize">
            <h2>SetMaxDynamicTableSize</h2>
            <hr />
            
            <pre><code>func SetMaxDynamicTableSize(v uint32)</code></pre>
         </article>
         
         <article class="function" data-name="SetAllowedMaxDynamicTableSize">
            <h2>SetAllowedMaxDynamicTableSize</h2>
            <hr />
            
            <p>SetAllowedMaxDynamicTableSize sets the upper bound that the encoded
stream (via dynamic table size updates) may set the maximum size
to.</p>
            
            <pre><code>func SetAllowedMaxDynamicTableSize(v uint32)</code></pre>
         </article>
         
         <article class="function" data-name="setMaxSize">
            <h2>setMaxSize</h2>
            <hr />
            
            <pre><code>func setMaxSize(v uint32)</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <pre><code>func add(f HeaderField)</code></pre>
         </article>
         
         <article class="function" data-name="evict">
            <h2>evict</h2>
            <hr />
            
            <p>If we're too big, evict old stuff.</p>
            
            <pre><code>func evict()</code></pre>
         </article>
         
         <article class="function" data-name="maxTableIndex">
            <h2>maxTableIndex</h2>
            <hr />
            
            <pre><code>func maxTableIndex() int</code></pre>
         </article>
         
         <article class="function" data-name="at">
            <h2>at</h2>
            <hr />
            
            <pre><code>func at(i uint64) (hf HeaderField, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="DecodeFull">
            <h2>DecodeFull</h2>
            <hr />
            
            <p>DecodeFull decodes an entire block.

TODO: remove this method and make it incremental later? This is
easier for debugging now.</p>
            
            <pre><code>func DecodeFull(p []byte) ([]HeaderField, error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close declares that the decoding is complete and resets the Decoder
to be reused again for a new header block. If there is any remaining
data in the decoder's buffer, Close returns an error.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="indexed">
            <h2>indexed</h2>
            <hr />
            
            <pre><code>func indexed() bool</code></pre>
         </article>
         
         <article class="function" data-name="sensitive">
            <h2>sensitive</h2>
            <hr />
            
            <pre><code>func sensitive() bool</code></pre>
         </article>
         
         <article class="function" data-name="parseHeaderFieldRepr">
            <h2>parseHeaderFieldRepr</h2>
            <hr />
            
            <p>returns errNeedMore if there isn't enough data available.
any other error is fatal.
consumes d.buf iff it returns nil.
precondition: must be called with len(d.buf) > 0</p>
            
            <pre><code>func parseHeaderFieldRepr() error</code></pre>
         </article>
         
         <article class="function" data-name="parseFieldIndexed">
            <h2>parseFieldIndexed</h2>
            <hr />
            
            <p>(same invariants and behavior as parseHeaderFieldRepr)</p>
            
            <pre><code>func parseFieldIndexed() error</code></pre>
         </article>
         
         <article class="function" data-name="parseFieldLiteral">
            <h2>parseFieldLiteral</h2>
            <hr />
            
            <p>(same invariants and behavior as parseHeaderFieldRepr)</p>
            
            <pre><code>func parseFieldLiteral(n uint8, it indexType) error</code></pre>
         </article>
         
         <article class="function" data-name="callEmit">
            <h2>callEmit</h2>
            <hr />
            
            <pre><code>func callEmit(hf HeaderField) error</code></pre>
         </article>
         
         <article class="function" data-name="parseDynamicTableSizeUpdate">
            <h2>parseDynamicTableSizeUpdate</h2>
            <hr />
            
            <p>(same invariants and behavior as parseHeaderFieldRepr)</p>
            
            <pre><code>func parseDynamicTableSizeUpdate() error</code></pre>
         </article>
         
         <article class="function" data-name="readVarInt">
            <h2>readVarInt</h2>
            <hr />
            
            <p>readVarInt reads an unsigned variable length integer off the
beginning of p. n is the parameter as described in
https://httpwg.org/specs/rfc7541.html#rfc.section.5.1.

n must always be between 1 and 8.

The returned remain buffer is either a smaller suffix of p, or err != nil.
The error is errNeedMore if p doesn't contain a complete integer.</p>
            
            <pre><code>func readVarInt(n byte, p []byte) (i uint64, remain []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readString">
            <h2>readString</h2>
            <hr />
            
            <p>readString reads an hpack string from p.

It returns a reference to the encoded string data to permit deferring decode costs
until after the caller verifies all data is present.</p>
            
            <pre><code>func readString(p []byte) (u undecodedString, remain []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="decodeString">
            <h2>decodeString</h2>
            <hr />
            
            <pre><code>func decodeString(u undecodedString) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="HuffmanDecode">
            <h2>HuffmanDecode</h2>
            <hr />
            
            <p>HuffmanDecode decodes the string in v and writes the expanded
result to w, returning the number of bytes written to w and the
Write call's return value. At most one Write call is made.</p>
            
            <pre><code>func HuffmanDecode(w io.Writer, v []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="HuffmanDecodeToString">
            <h2>HuffmanDecodeToString</h2>
            <hr />
            
            <p>HuffmanDecodeToString decodes the string in v.</p>
            
            <pre><code>func HuffmanDecodeToString(v []byte) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="huffmanDecode">
            <h2>huffmanDecode</h2>
            <hr />
            
            <p>huffmanDecode decodes v to buf.
If maxLen is greater than 0, attempts to write more to buf than
maxLen bytes will return ErrStringLength.</p>
            
            <pre><code>func huffmanDecode(buf *bytes.Buffer, maxLen int, v []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="newInternalNode">
            <h2>newInternalNode</h2>
            <hr />
            
            <pre><code>func newInternalNode() *node</code></pre>
         </article>
         
         <article class="function" data-name="getRootHuffmanNode">
            <h2>getRootHuffmanNode</h2>
            <hr />
            
            <pre><code>func getRootHuffmanNode() *node</code></pre>
         </article>
         
         <article class="function" data-name="buildRootHuffmanNode">
            <h2>buildRootHuffmanNode</h2>
            <hr />
            
            <pre><code>func buildRootHuffmanNode()</code></pre>
         </article>
         
         <article class="function" data-name="AppendHuffmanString">
            <h2>AppendHuffmanString</h2>
            <hr />
            
            <p>AppendHuffmanString appends s, as encoded in Huffman codes, to dst
and returns the extended buffer.</p>
            
            <pre><code>func AppendHuffmanString(dst []byte, s string) []byte</code></pre>
         </article>
         
         <article class="function" data-name="HuffmanEncodeLength">
            <h2>HuffmanEncodeLength</h2>
            <hr />
            
            <p>HuffmanEncodeLength returns the number of bytes required to encode
s in Huffman codes. The result is round up to byte boundary.</p>
            
            <pre><code>func HuffmanEncodeLength(s string) uint64</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="len">
            <h2>len</h2>
            <hr />
            
            <p>len reports the number of entries in the table.</p>
            
            <pre><code>func len() int</code></pre>
         </article>
         
         <article class="function" data-name="addEntry">
            <h2>addEntry</h2>
            <hr />
            
            <p>addEntry adds a new entry.</p>
            
            <pre><code>func addEntry(f HeaderField)</code></pre>
         </article>
         
         <article class="function" data-name="evictOldest">
            <h2>evictOldest</h2>
            <hr />
            
            <p>evictOldest evicts the n oldest entries in the table.</p>
            
            <pre><code>func evictOldest(n int)</code></pre>
         </article>
         
         <article class="function" data-name="search">
            <h2>search</h2>
            <hr />
            
            <p>search finds f in the table. If there is no match, i is 0.
If both name and value match, i is the matched index and nameValueMatch
becomes true. If only name matches, i points to that index and
nameValueMatch becomes false.

The returned index is a 1-based HPACK index. For dynamic tables, HPACK says
that index 1 should be the newest entry, but t.ents[0] is the oldest entry,
meaning t.ents is reversed for dynamic tables. Hence, when t is a dynamic
table, the return value i actually refers to the entry t.ents[t.len()-i].

All tables are assumed to be a dynamic tables except for the global staticTable.

See Section 2.3.3.</p>
            
            <pre><code>func search(f HeaderField) (i uint64, nameValueMatch bool)</code></pre>
         </article>
         
         <article class="function" data-name="idToIndex">
            <h2>idToIndex</h2>
            <hr />
            
            <p>idToIndex converts a unique id to an HPACK index.
See Section 2.3.3.</p>
            
            <pre><code>func idToIndex(id uint64) uint64</code></pre>
         </article>
         
         <article class="function" data-name="NewEncoder">
            <h2>NewEncoder</h2>
            <hr />
            
            <p>NewEncoder returns a new Encoder which performs HPACK encoding. An
encoded data is written to w.</p>
            
            <pre><code>func NewEncoder(w io.Writer) *Encoder</code></pre>
         </article>
         
         <article class="function" data-name="WriteField">
            <h2>WriteField</h2>
            <hr />
            
            <p>WriteField encodes f into a single Write to e's underlying Writer.
This function may also produce bytes for "Header Table Size Update"
if necessary. If produced, it is done before encoding f.</p>
            
            <pre><code>func WriteField(f HeaderField) error</code></pre>
         </article>
         
         <article class="function" data-name="searchTable">
            <h2>searchTable</h2>
            <hr />
            
            <p>searchTable searches f in both stable and dynamic header tables.
The static header table is searched first. Only when there is no
exact match for both name and value, the dynamic header table is
then searched. If there is no match, i is 0. If both name and value
match, i is the matched index and nameValueMatch becomes true. If
only name matches, i points to that index and nameValueMatch
becomes false.</p>
            
            <pre><code>func searchTable(f HeaderField) (i uint64, nameValueMatch bool)</code></pre>
         </article>
         
         <article class="function" data-name="SetMaxDynamicTableSize">
            <h2>SetMaxDynamicTableSize</h2>
            <hr />
            
            <p>SetMaxDynamicTableSize changes the dynamic header table size to v.
The actual size is bounded by the value passed to
SetMaxDynamicTableSizeLimit.</p>
            
            <pre><code>func SetMaxDynamicTableSize(v uint32)</code></pre>
         </article>
         
         <article class="function" data-name="MaxDynamicTableSize">
            <h2>MaxDynamicTableSize</h2>
            <hr />
            
            <p>MaxDynamicTableSize returns the current dynamic header table size.</p>
            
            <pre><code>func MaxDynamicTableSize() v uint32</code></pre>
         </article>
         
         <article class="function" data-name="SetMaxDynamicTableSizeLimit">
            <h2>SetMaxDynamicTableSizeLimit</h2>
            <hr />
            
            <p>SetMaxDynamicTableSizeLimit changes the maximum value that can be
specified in SetMaxDynamicTableSize to v. By default, it is set to
4096, which is the same size of the default dynamic header table
size described in HPACK specification. If the current maximum
dynamic header table size is strictly greater than v, "Header Table
Size Update" will be done in the next WriteField call and the
maximum dynamic header table size is truncated to v.</p>
            
            <pre><code>func SetMaxDynamicTableSizeLimit(v uint32)</code></pre>
         </article>
         
         <article class="function" data-name="shouldIndex">
            <h2>shouldIndex</h2>
            <hr />
            
            <p>shouldIndex reports whether f should be indexed.</p>
            
            <pre><code>func shouldIndex(f HeaderField) bool</code></pre>
         </article>
         
         <article class="function" data-name="appendIndexed">
            <h2>appendIndexed</h2>
            <hr />
            
            <p>appendIndexed appends index i, as encoded in "Indexed Header Field"
representation, to dst and returns the extended buffer.</p>
            
            <pre><code>func appendIndexed(dst []byte, i uint64) []byte</code></pre>
         </article>
         
         <article class="function" data-name="appendNewName">
            <h2>appendNewName</h2>
            <hr />
            
            <p>appendNewName appends f, as encoded in one of "Literal Header field
- New Name" representation variants, to dst and returns the
extended buffer.

If f.Sensitive is true, "Never Indexed" representation is used. If
f.Sensitive is false and indexing is true, "Incremental Indexing"
representation is used.</p>
            
            <pre><code>func appendNewName(dst []byte, f HeaderField, indexing bool) []byte</code></pre>
         </article>
         
         <article class="function" data-name="appendIndexedName">
            <h2>appendIndexedName</h2>
            <hr />
            
            <p>appendIndexedName appends f and index i referring indexed name
entry, as encoded in one of "Literal Header field - Indexed Name"
representation variants, to dst and returns the extended buffer.

If f.Sensitive is true, "Never Indexed" representation is used. If
f.Sensitive is false and indexing is true, "Incremental Indexing"
representation is used.</p>
            
            <pre><code>func appendIndexedName(dst []byte, f HeaderField, i uint64, indexing bool) []byte</code></pre>
         </article>
         
         <article class="function" data-name="appendTableSize">
            <h2>appendTableSize</h2>
            <hr />
            
            <p>appendTableSize appends v, as encoded in "Header Table Size Update"
representation, to dst and returns the extended buffer.</p>
            
            <pre><code>func appendTableSize(dst []byte, v uint32) []byte</code></pre>
         </article>
         
         <article class="function" data-name="appendVarInt">
            <h2>appendVarInt</h2>
            <hr />
            
            <p>appendVarInt appends i, as encoded in variable integer form using n
bit prefix, to dst and returns the extended buffer.

See
https://httpwg.org/specs/rfc7541.html#integer.representation</p>
            
            <pre><code>func appendVarInt(dst []byte, n byte, i uint64) []byte</code></pre>
         </article>
         
         <article class="function" data-name="appendHpackString">
            <h2>appendHpackString</h2>
            <hr />
            
            <p>appendHpackString appends s, as encoded in "String Literal"
representation, to dst and returns the extended buffer.

s will be encoded in Huffman codes only when it produces strictly
shorter byte string.</p>
            
            <pre><code>func appendHpackString(dst []byte, s string) []byte</code></pre>
         </article>
         
         <article class="function" data-name="encodeTypeByte">
            <h2>encodeTypeByte</h2>
            <hr />
            
            <p>encodeTypeByte returns type byte. If sensitive is true, type byte
for "Never Indexed" representation is returned. If sensitive is
false and indexing is true, type byte for "Incremental Indexing"
representation is returned. Otherwise, type byte for "Without
Indexing" is returned.</p>
            
            <pre><code>func encodeTypeByte(indexing bool, sensitive bool) byte</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
