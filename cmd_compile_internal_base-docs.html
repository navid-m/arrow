<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - base</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>base</code>
         </h1>
         <hr />
         
         <article class="global" data-name="Pos">
            <h2>Pos</h2>
            <hr />
            
            <p>Pos is the current source position being processed,
printed by Errorf, ErrorfLang, Fatalf, and Warnf.</p>
            
            <pre><code>Pos src.XPos</code></pre>
         </article>
         
         <article class="global" data-name="errorMsgs">
            <h2>errorMsgs</h2>
            <hr />
            
            <pre><code>errorMsgs []errorMsg</code></pre>
         </article>
         
         <article class="global" data-name="numErrors">
            <h2>numErrors</h2>
            <hr />
            
            <pre><code>numErrors int</code></pre>
         </article>
         
         <article class="global" data-name="numSyntaxErrors">
            <h2>numSyntaxErrors</h2>
            <hr />
            
            <pre><code>numSyntaxErrors int</code></pre>
         </article>
         
         <article class="global" data-name="lasterror">
            <h2>lasterror</h2>
            <hr />
            
            <p>lasterror keeps track of the most recently issued error,
to avoid printing multiple error messages on the same line.</p>
            
            <pre><code>lasterror *ast.StructType</code></pre>
         </article>
         
         <article class="global" data-name="bugStack">
            <h2>bugStack</h2>
            <hr />
            
            <pre><code>bugStack</code></pre>
         </article>
         
         <article class="global" data-name="AutogeneratedPos">
            <h2>AutogeneratedPos</h2>
            <hr />
            
            <pre><code>AutogeneratedPos src.XPos</code></pre>
         </article>
         
         <article class="global" data-name="Timer">
            <h2>Timer</h2>
            <hr />
            
            <pre><code>Timer Timings</code></pre>
         </article>
         
         <article class="global" data-name="CompilerBootstrap">
            <h2>CompilerBootstrap</h2>
            <hr />
            
            <p>CompilerBootstrap reports whether the current compiler binary was
built with -tags=compiler_bootstrap.</p>
            
            <pre><code>CompilerBootstrap</code></pre>
         </article>
         
         <article class="global" data-name="Debug">
            <h2>Debug</h2>
            <hr />
            
            <p>Debug holds the parsed debugging configuration values.</p>
            
            <pre><code>Debug DebugFlags</code></pre>
         </article>
         
         <article class="global" data-name="DebugSSA">
            <h2>DebugSSA</h2>
            <hr />
            
            <p>DebugSSA is called to set a -d ssa/... option.
If nil, those options are reported as invalid options.
If DebugSSA returns a non-empty string, that text is reported as a compiler error.</p>
            
            <pre><code>DebugSSA func</code></pre>
         </article>
         
         <article class="global" data-name="hashDebug">
            <h2>hashDebug</h2>
            <hr />
            
            <p>The default compiler-debugging HashDebug, for "-d=gossahash=..."</p>
            
            <pre><code>hashDebug *HashDebug</code></pre>
         </article>
         
         <article class="global" data-name="FmaHash">
            <h2>FmaHash</h2>
            <hr />
            
            <pre><code>FmaHash *HashDebug</code></pre>
         </article>
         
         <article class="global" data-name="LoopVarHash">
            <h2>LoopVarHash</h2>
            <hr />
            
            <pre><code>LoopVarHash *HashDebug</code></pre>
         </article>
         
         <article class="global" data-name="PGOHash">
            <h2>PGOHash</h2>
            <hr />
            
            <pre><code>PGOHash *HashDebug</code></pre>
         </article>
         
         <article class="global" data-name="MergeLocalsHash">
            <h2>MergeLocalsHash</h2>
            <hr />
            
            <pre><code>MergeLocalsHash *HashDebug</code></pre>
         </article>
         
         <article class="global" data-name="ReservedImports">
            <h2>ReservedImports</h2>
            <hr />
            
            <p>ReservedImports are import paths used internally for generated
symbols by the compiler.

The linker uses the magic symbol prefixes "go:" and "type:".
Avoid potential confusion between import paths and symbols
by rejecting these reserved imports for now. Also, people
"can do weird things in GOPATH and we'd prefer they didn't
do _that_ weird thing" (per rsc). See also #4257.</p>
            
            <pre><code>ReservedImports</code></pre>
         </article>
         
         <article class="global" data-name="Ctxt">
            <h2>Ctxt</h2>
            <hr />
            
            <pre><code>Ctxt *obj.Link</code></pre>
         </article>
         
         <article class="global" data-name="atExitFuncs">
            <h2>atExitFuncs</h2>
            <hr />
            
            <pre><code>atExitFuncs []func</code></pre>
         </article>
         
         <article class="global" data-name="EnableTrace">
            <h2>EnableTrace</h2>
            <hr />
            
            <p>To enable tracing support (-t flag), set EnableTrace to true.</p>
            
            <pre><code>EnableTrace</code></pre>
         </article>
         
         <article class="global" data-name="CompilerBootstrap">
            <h2>CompilerBootstrap</h2>
            <hr />
            
            <p>CompilerBootstrap reports whether the current compiler binary was
built with -tags=compiler_bootstrap.</p>
            
            <pre><code>CompilerBootstrap</code></pre>
         </article>
         
         <article class="global" data-name="Flag">
            <h2>Flag</h2>
            <hr />
            
            <p>Flag holds the parsed command-line flags.
See ParseFlag for non-zero defaults.</p>
            
            <pre><code>Flag CmdFlags</code></pre>
         </article>
          
         <article class="struct" data-name="errorMsg">
            <h2>type errorMsg struct</h2>
            <hr />
            
            <p>An errorMsg is a queued error message, waiting to be printed.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pos src.XPos
msg string
code errors.Code</code></pre>
         </article>
         
         <article class="struct" data-name="Timings">
            <h2>type Timings struct</h2>
            <hr />
            
            <p>Timings collects the execution times of labeled phases
which are added through a sequence of Start/Stop calls.
Events may be associated with each phase via AddEvent.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">list []timestamp
events *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="timestamp">
            <h2>type timestamp struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">time time.Time
label string
start bool</code></pre>
         </article>
         
         <article class="struct" data-name="event">
            <h2>type event struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">size int64
unit string</code></pre>
         </article>
         
         <article class="struct" data-name="DebugFlags">
            <h2>type DebugFlags struct</h2>
            <hr />
            
            <p>DebugFlags defines the debugging configuration values (see var Debug).
Each struct field is a different value, named for the lower-case of the field name.
Each field must be an int or string and must have a `help` struct tag.

The -d option takes a comma-separated list of settings.
Each setting is name=value; for ints, name is short for name=1.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">AlignHot int
Append int
Checkptr int
Closure int
Defer int
DisableNil int
DumpInlFuncProps string
DumpInlCallSiteScores int
InlScoreAdj string
InlBudgetSlack int
DumpPtrs int
DwarfInl int
EscapeMutationsCalls int
Export int
FIPSHash string
Fmahash string
GCAdjust int
GCCheck int
GCProg int
Gossahash string
InlFuncsWithClosures int
InlStaticInit int
Libfuzzer int
LoopVar int
LoopVarHash string
LocationLists int
MaxShapeLen int
MergeLocals int
MergeLocalsDumpFunc string
MergeLocalsHash string
MergeLocalsTrace int
MergeLocalsHTrace int
Nil int
NoDeadLocals int
NoOpenDefer int
NoRefName int
PCTab string
Panic int
Reshape int
Shapify int
Slice int
SoftFloat int
StaticCopy int
SyncFrames int
TailCall int
TypeAssert int
WB int
ABIWrap int
MayMoreStack string
PGODebug int
PGOHash string
PGOInline int
PGOInlineCDFThreshold string
PGOInlineBudget int
PGODevirtualize int
RangeFuncCheck int
WrapGlobalMapDbg int
WrapGlobalMapCtl int
ZeroCopy int
ConcurrentOk bool</code></pre>
         </article>
         
         <article class="struct" data-name="hashAndMask">
            <h2>type hashAndMask struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">hash uint64
mask uint64
name string</code></pre>
         </article>
         
         <article class="struct" data-name="HashDebug">
            <h2>type HashDebug struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">mu sync.Mutex
name string
logfile io.Writer
posTmp []src.Pos
bytesTmp bytes.Buffer
matches []hashAndMask
excludes []hashAndMask
bisect *bisect.Matcher
fileSuffixOnly bool
inlineSuffixOnly bool</code></pre>
         </article>
         
         <article class="struct" data-name="CmdFlags">
            <h2>type CmdFlags struct</h2>
            <hr />
            
            <p>CmdFlags defines the command-line flags (see var Flag).
Each struct field is a different flag, by default named for the lower-case of the field name.
If the flag name is a single letter, the default flag name is left upper-case.
If the flag name is "Lower" followed by a single letter, the default flag name is the lower-case of the last letter.

If this default flag name can't be made right, the `flag` struct tag can be used to replace it,
but this should be done only in exceptional circumstances: it helps everyone if the flag name
is obvious from the field name when the flag is used elsewhere in the compiler sources.
The `flag:"-"` struct tag makes a field invisible to the flag logic and should also be used sparingly.

Each field must have a `help` struct tag giving the flag help message.

The allowed field types are bool, int, string, pointers to those (for values stored elsewhere),
CountFlag (for a counting flag), and func(string) (for a flag that uses special code for parsing).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">B CountFlag
C CountFlag
D string
E CountFlag
I func
K CountFlag
L CountFlag
N CountFlag
S CountFlag
W CountFlag
LowerC int
LowerD flag.Value
LowerE CountFlag
LowerH CountFlag
LowerJ CountFlag
LowerL CountFlag
LowerM CountFlag
LowerO string
LowerP *string
LowerR CountFlag
LowerT bool
LowerW CountFlag
LowerV *bool
Percent CountFlag
CompilingRuntime bool
AsmHdr string
ASan bool
Bench string
BlockProfile string
BuildID string
CPUProfile string
Complete bool
ClobberDead bool
ClobberDeadReg bool
Dwarf bool
DwarfBASEntries *bool
DwarfLocationLists *bool
Dynlink *bool
EmbedCfg func
Env func
GenDwarfInl int
GoVersion string
ImportCfg func
InstallSuffix string
JSON string
Lang string
LinkObj string
LinkShared *bool
Live CountFlag
MSan bool
MemProfile string
MemProfileRate int
MutexProfile string
NoLocalImports bool
CoverageCfg func
Pack bool
Race bool
Shared *bool
SmallFrames bool
Spectre string
Std bool
SymABIs string
TraceProfile string
TrimPath string
WB bool
PgoProfile string
ErrorURL bool
Cfg *ast.StructType</code></pre>
         </article>
          
         <article class="function" data-name="MapFile">
            <h2>MapFile</h2>
            <hr />
            
            <p>MapFile returns length bytes from the file starting at the
specified offset as a string.</p>
            
            <pre><code>func MapFile(f *os.File, offset int64, length int64) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="Errors">
            <h2>Errors</h2>
            <hr />
            
            <p>Errors returns the number of errors reported.</p>
            
            <pre><code>func Errors() int</code></pre>
         </article>
         
         <article class="function" data-name="SyntaxErrors">
            <h2>SyntaxErrors</h2>
            <hr />
            
            <p>SyntaxErrors returns the number of syntax errors reported.</p>
            
            <pre><code>func SyntaxErrors() int</code></pre>
         </article>
         
         <article class="function" data-name="addErrorMsg">
            <h2>addErrorMsg</h2>
            <hr />
            
            <p>addErrorMsg adds a new errorMsg (which may be a warning) to errorMsgs.</p>
            
            <pre><code>func addErrorMsg(pos src.XPos, code errors.Code, format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="FmtPos">
            <h2>FmtPos</h2>
            <hr />
            
            <p>FmtPos formats pos as a file:line string.</p>
            
            <pre><code>func FmtPos(pos src.XPos) string</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="FlushErrors">
            <h2>FlushErrors</h2>
            <hr />
            
            <p>FlushErrors sorts errors seen so far by line number, prints them to stdout,
and empties the errors array.</p>
            
            <pre><code>func FlushErrors()</code></pre>
         </article>
         
         <article class="function" data-name="sameline">
            <h2>sameline</h2>
            <hr />
            
            <p>sameline reports whether two positions a, b are on the same line.</p>
            
            <pre><code>func sameline(a src.XPos, b src.XPos) bool</code></pre>
         </article>
         
         <article class="function" data-name="Errorf">
            <h2>Errorf</h2>
            <hr />
            
            <p>Errorf reports a formatted error at the current line.</p>
            
            <pre><code>func Errorf(format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="ErrorfAt">
            <h2>ErrorfAt</h2>
            <hr />
            
            <p>ErrorfAt reports a formatted error message at pos.</p>
            
            <pre><code>func ErrorfAt(pos src.XPos, code errors.Code, format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="UpdateErrorDot">
            <h2>UpdateErrorDot</h2>
            <hr />
            
            <p>UpdateErrorDot is a clumsy hack that rewrites the last error,
if it was "LINE: undefined: NAME", to be "LINE: undefined: NAME in EXPR".
It is used to give better error messages for dot (selector) expressions.</p>
            
            <pre><code>func UpdateErrorDot(line string, name string, expr string)</code></pre>
         </article>
         
         <article class="function" data-name="Warn">
            <h2>Warn</h2>
            <hr />
            
            <p>Warn reports a formatted warning at the current line.
In general the Go compiler does NOT generate warnings,
so this should be used only when the user has opted in
to additional output by setting a particular flag.</p>
            
            <pre><code>func Warn(format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="WarnfAt">
            <h2>WarnfAt</h2>
            <hr />
            
            <p>WarnfAt reports a formatted warning at pos.
In general the Go compiler does NOT generate warnings,
so this should be used only when the user has opted in
to additional output by setting a particular flag.</p>
            
            <pre><code>func WarnfAt(pos src.XPos, format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Fatalf">
            <h2>Fatalf</h2>
            <hr />
            
            <p>Fatalf reports a fatal error - an internal problem - at the current line and exits.
If other errors have already been printed, then Fatalf just quietly exits.
(The internal problem may have been caused by incomplete information
after the already-reported errors, so best to let users fix those and
try again without being bothered about a spurious internal error.)

But if no errors have been printed, or if -d panic has been specified,
Fatalf prints the error as an "internal compiler error". In a released build,
it prints an error asking to file a bug report. In development builds, it
prints a stack trace.

If -h has been specified, Fatalf panics to force the usual runtime info dump.</p>
            
            <pre><code>func Fatalf(format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="FatalfAt">
            <h2>FatalfAt</h2>
            <hr />
            
            <p>FatalfAt reports a fatal error - an internal problem - at pos and exits.
If other errors have already been printed, then FatalfAt just quietly exits.
(The internal problem may have been caused by incomplete information
after the already-reported errors, so best to let users fix those and
try again without being bothered about a spurious internal error.)

But if no errors have been printed, or if -d panic has been specified,
FatalfAt prints the error as an "internal compiler error". In a released build,
it prints an error asking to file a bug report. In development builds, it
prints a stack trace.

If -h has been specified, FatalfAt panics to force the usual runtime info dump.</p>
            
            <pre><code>func FatalfAt(pos src.XPos, format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Assert">
            <h2>Assert</h2>
            <hr />
            
            <p>Assert reports "assertion failed" with Fatalf, unless b is true.</p>
            
            <pre><code>func Assert(b bool)</code></pre>
         </article>
         
         <article class="function" data-name="Assertf">
            <h2>Assertf</h2>
            <hr />
            
            <p>Assertf reports a fatal error with Fatalf, unless b is true.</p>
            
            <pre><code>func Assertf(b bool, format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="AssertfAt">
            <h2>AssertfAt</h2>
            <hr />
            
            <p>AssertfAt reports a fatal error with FatalfAt, unless b is true.</p>
            
            <pre><code>func AssertfAt(b bool, pos src.XPos, format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="hcrash">
            <h2>hcrash</h2>
            <hr />
            
            <p>hcrash crashes the compiler when -h is set, to find out where a message is generated.</p>
            
            <pre><code>func hcrash()</code></pre>
         </article>
         
         <article class="function" data-name="ErrorExit">
            <h2>ErrorExit</h2>
            <hr />
            
            <p>ErrorExit handles an error-status exit.
It flushes any pending errors, removes the output file, and exits.</p>
            
            <pre><code>func ErrorExit()</code></pre>
         </article>
         
         <article class="function" data-name="ExitIfErrors">
            <h2>ExitIfErrors</h2>
            <hr />
            
            <p>ExitIfErrors calls ErrorExit if any errors have been reported.</p>
            
            <pre><code>func ExitIfErrors()</code></pre>
         </article>
         
         <article class="function" data-name="append">
            <h2>append</h2>
            <hr />
            
            <pre><code>func append(labels []string, start bool)</code></pre>
         </article>
         
         <article class="function" data-name="Start">
            <h2>Start</h2>
            <hr />
            
            <p>Start marks the beginning of a new phase and implicitly stops the previous phase.
The phase name is the colon-separated concatenation of the labels.</p>
            
            <pre><code>func Start(labels ...string)</code></pre>
         </article>
         
         <article class="function" data-name="Stop">
            <h2>Stop</h2>
            <hr />
            
            <p>Stop marks the end of a phase and implicitly starts a new phase.
The labels are added to the labels of the ended phase.</p>
            
            <pre><code>func Stop(labels ...string)</code></pre>
         </article>
         
         <article class="function" data-name="AddEvent">
            <h2>AddEvent</h2>
            <hr />
            
            <p>AddEvent associates an event, i.e., a count, or an amount of data,
with the most recently started or stopped phase; or the very first
phase if Start or Stop hasn't been called yet. The unit specifies
the unit of measurement (e.g., MB, lines, no. of funcs, etc.).</p>
            
            <pre><code>func AddEvent(size int64, unit string)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write prints the phase times to w.
The prefix is printed at the start of each line.</p>
            
            <pre><code>func Write(w io.Writer, prefix string)</code></pre>
         </article>
         
         <article class="function" data-name="commonPrefix">
            <h2>commonPrefix</h2>
            <hr />
            
            <pre><code>func commonPrefix(a string, b string) string</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <pre><code>func add(label string, n int, dt time.Duration, tot time.Duration, events []*event)</code></pre>
         </article>
         
         <article class="function" data-name="write">
            <h2>write</h2>
            <hr />
            
            <pre><code>func write(w io.Writer)</code></pre>
         </article>
         
         <article class="function" data-name="isnumber">
            <h2>isnumber</h2>
            <hr />
            
            <pre><code>func isnumber(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetInlineSuffixOnly">
            <h2>SetInlineSuffixOnly</h2>
            <hr />
            
            <p>SetInlineSuffixOnly controls whether hashing and reporting use the entire
inline position, or just the most-inline suffix.  Compiler debugging tends
to want the whole inlining, debugging user problems (loopvarhash, e.g.)
typically does not need to see the entire inline tree, there is just one
copy of the source code.</p>
            
            <pre><code>func SetInlineSuffixOnly(b bool) *HashDebug</code></pre>
         </article>
         
         <article class="function" data-name="DebugHashMatchPkgFunc">
            <h2>DebugHashMatchPkgFunc</h2>
            <hr />
            
            <p>DebugHashMatchPkgFunc reports whether debug variable Gossahash

 1. is empty (returns true; this is a special more-quickly implemented case of 4 below)

 2. is "y" or "Y" (returns true)

 3. is "n" or "N" (returns false)

 4. does not explicitly exclude the sha1 hash of pkgAndName (see step 6)

 5. is a suffix of the sha1 hash of pkgAndName (returns true)

 6. OR
    if the (non-empty) value is in the regular language
    "(-[01]+/)+?([01]+(/[01]+)+?"
    (exclude..)(....include...)
    test the [01]+ exclude substrings, if any suffix-match, return false (4 above)
    test the [01]+ include substrings, if any suffix-match, return true
    The include substrings AFTER the first slash are numbered 0,1, etc and
    are named fmt.Sprintf("%s%d", varname, number)
    As an extra-special case for multiple failure search,
    an excludes-only string ending in a slash (terminated, not separated)
    implicitly specifies the include string "0/1", that is, match everything.
    (Exclude strings are used for automated search for multiple failures.)
    Clause 6 is not really intended for human use and only
    matters for failures that require multiple triggers.

Otherwise it returns false.

Unless Flags.Gossahash is empty, when DebugHashMatchPkgFunc returns true the message

	"%s triggered %s\n", varname, pkgAndName

is printed on the file named in environment variable GSHS_LOGFILE,
or standard out if that is empty.  "Varname" is either the name of
the variable or the name of the substring, depending on which matched.

Typical use:

 1. you make a change to the compiler, say, adding a new phase

 2. it is broken in some mystifying way, for example, make.bash builds a broken
    compiler that almost works, but crashes compiling a test in run.bash.

 3. add this guard to the code, which by default leaves it broken, but does not
    run the broken new code if Flags.Gossahash is non-empty and non-matching:

    if !base.DebugHashMatch(ir.PkgFuncName(fn)) {
    return nil // early exit, do nothing
    }

 4. rebuild w/o the bad code,
    GOCOMPILEDEBUG=gossahash=n ./all.bash
    to verify that you put the guard in the right place with the right sense of the test.

 5. use github.com/dr2chase/gossahash to search for the error:

    go install github.com/dr2chase/gossahash@latest

    gossahash -- <the thing that fails>

    for example: GOMAXPROCS=1 gossahash -- ./all.bash

 6. gossahash should return a single function whose miscompilation
    causes the problem, and you can focus on that.</p>
            
            <pre><code>func DebugHashMatchPkgFunc(pkg string, fn string) bool</code></pre>
         </article>
         
         <article class="function" data-name="DebugHashMatchPos">
            <h2>DebugHashMatchPos</h2>
            <hr />
            
            <pre><code>func DebugHashMatchPos(pos src.XPos) bool</code></pre>
         </article>
         
         <article class="function" data-name="HasDebugHash">
            <h2>HasDebugHash</h2>
            <hr />
            
            <p>HasDebugHash returns true if Flags.Gossahash is non-empty, which
results in hashDebug being not-nil.  I.e., if !HasDebugHash(),
there is no need to create the string for hashing and testing.</p>
            
            <pre><code>func HasDebugHash() bool</code></pre>
         </article>
         
         <article class="function" data-name="toHashAndMask">
            <h2>toHashAndMask</h2>
            <hr />
            
            <p>TODO: Delete when we switch to bisect-only.</p>
            
            <pre><code>func toHashAndMask(s string, varname string) hashAndMask</code></pre>
         </article>
         
         <article class="function" data-name="NewHashDebug">
            <h2>NewHashDebug</h2>
            <hr />
            
            <p>NewHashDebug returns a new hash-debug tester for the
environment variable ev.  If ev is not set, it returns
nil, allowing a lightweight check for normal-case behavior.</p>
            
            <pre><code>func NewHashDebug(ev string, s string, file io.Writer) *HashDebug</code></pre>
         </article>
         
         <article class="function" data-name="excluded">
            <h2>excluded</h2>
            <hr />
            
            <p>TODO: Delete when we switch to bisect-only.</p>
            
            <pre><code>func excluded(hash uint64) bool</code></pre>
         </article>
         
         <article class="function" data-name="hashString">
            <h2>hashString</h2>
            <hr />
            
            <p>TODO: Delete when we switch to bisect-only.</p>
            
            <pre><code>func hashString(hash uint64) string</code></pre>
         </article>
         
         <article class="function" data-name="match">
            <h2>match</h2>
            <hr />
            
            <p>TODO: Delete when we switch to bisect-only.</p>
            
            <pre><code>func match(hash uint64) *hashAndMask</code></pre>
         </article>
         
         <article class="function" data-name="MatchPkgFunc">
            <h2>MatchPkgFunc</h2>
            <hr />
            
            <p>MatchPkgFunc returns true if either the variable used to create d is
unset, or if its value is y, or if it is a suffix of the base-two
representation of the hash of pkg and fn.  If the variable is not nil,
then a true result is accompanied by stylized output to d.logfile, which
is used for automated bug search.</p>
            
            <pre><code>func MatchPkgFunc(pkg string, fn string, note func) bool</code></pre>
         </article>
         
         <article class="function" data-name="matchPkgFunc">
            <h2>matchPkgFunc</h2>
            <hr />
            
            <pre><code>func matchPkgFunc(pkg string, fn string, note func) bool</code></pre>
         </article>
         
         <article class="function" data-name="MatchPos">
            <h2>MatchPos</h2>
            <hr />
            
            <p>MatchPos is similar to MatchPkgFunc, but for hash computation
it uses the source position including all inlining information instead of
package name and path.
Note that the default answer for no environment variable (d == nil)
is "yes", do the thing.</p>
            
            <pre><code>func MatchPos(pos src.XPos, desc func) bool</code></pre>
         </article>
         
         <article class="function" data-name="matchPos">
            <h2>matchPos</h2>
            <hr />
            
            <pre><code>func matchPos(ctxt *obj.Link, pos src.XPos, note func) bool</code></pre>
         </article>
         
         <article class="function" data-name="matchPosWithInfo">
            <h2>matchPosWithInfo</h2>
            <hr />
            
            <pre><code>func matchPosWithInfo(ctxt *obj.Link, pos src.XPos, info any, note func) bool</code></pre>
         </article>
         
         <article class="function" data-name="MatchPosWithInfo">
            <h2>MatchPosWithInfo</h2>
            <hr />
            
            <p>MatchPosWithInfo is similar to MatchPos, but with additional information
that is included for hash computation, so it can distinguish multiple
matches on the same source location.
Note that the default answer for no environment variable (d == nil)
is "yes", do the thing.</p>
            
            <pre><code>func MatchPosWithInfo(pos src.XPos, info any, desc func) bool</code></pre>
         </article>
         
         <article class="function" data-name="matchAndLog">
            <h2>matchAndLog</h2>
            <hr />
            
            <p>matchAndLog is the core matcher. It reports whether the hash matches the pattern.
If a report needs to be printed, match prints that report to the log file.
The text func must be non-nil and should return a user-readable
representation of what was hashed. The note func may be nil; if non-nil,
it should return additional information to display to the user when this
change is selected.</p>
            
            <pre><code>func matchAndLog(hash uint64, text func, note func) bool</code></pre>
         </article>
         
         <article class="function" data-name="short">
            <h2>short</h2>
            <hr />
            
            <p>short returns the form of file name to use for d.
The default is the full path, but fileSuffixOnly selects
just the final path element.</p>
            
            <pre><code>func short(name string) string</code></pre>
         </article>
         
         <article class="function" data-name="hashPos">
            <h2>hashPos</h2>
            <hr />
            
            <p>hashPos returns a hash of the position pos, including its entire inline stack.
If d.inlineSuffixOnly is true, hashPos only considers the innermost (leaf) position on the inline stack.</p>
            
            <pre><code>func hashPos(ctxt *obj.Link, pos src.XPos) uint64</code></pre>
         </article>
         
         <article class="function" data-name="fmtPos">
            <h2>fmtPos</h2>
            <hr />
            
            <p>fmtPos returns a textual formatting of the position pos, including its entire inline stack.
If d.inlineSuffixOnly is true, fmtPos only considers the innermost (leaf) position on the inline stack.</p>
            
            <pre><code>func fmtPos(ctxt *obj.Link, pos src.XPos) string</code></pre>
         </article>
         
         <article class="function" data-name="log">
            <h2>log</h2>
            <hr />
            
            <p>log prints a match with the given hash and textual formatting.
TODO: Delete varname parameter when we switch to bisect-only.</p>
            
            <pre><code>func log(varname string, hash uint64, text string)</code></pre>
         </article>
         
         <article class="function" data-name="TestHashDebugGossahashY">
            <h2>TestHashDebugGossahashY</h2>
            <hr />
            
            <pre><code>func TestHashDebugGossahashY(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestHashDebugGossahashN">
            <h2>TestHashDebugGossahashN</h2>
            <hr />
            
            <pre><code>func TestHashDebugGossahashN(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestHashDebugGossahashEmpty">
            <h2>TestHashDebugGossahashEmpty</h2>
            <hr />
            
            <pre><code>func TestHashDebugGossahashEmpty(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestHashDebugMagic">
            <h2>TestHashDebugMagic</h2>
            <hr />
            
            <pre><code>func TestHashDebugMagic(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestHash">
            <h2>TestHash</h2>
            <hr />
            
            <pre><code>func TestHash(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestHashMatch">
            <h2>TestHashMatch</h2>
            <hr />
            
            <pre><code>func TestHashMatch(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestYMatch">
            <h2>TestYMatch</h2>
            <hr />
            
            <pre><code>func TestYMatch(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNMatch">
            <h2>TestNMatch</h2>
            <hr />
            
            <pre><code>func TestNMatch(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestHashNoMatch">
            <h2>TestHashNoMatch</h2>
            <hr />
            
            <pre><code>func TestHashNoMatch(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestHashSecondMatch">
            <h2>TestHashSecondMatch</h2>
            <hr />
            
            <pre><code>func TestHashSecondMatch(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="wantPrefix">
            <h2>wantPrefix</h2>
            <hr />
            
            <pre><code>func wantPrefix(t *testing.T, got string, want string)</code></pre>
         </article>
         
         <article class="function" data-name="wantContains">
            <h2>wantContains</h2>
            <hr />
            
            <pre><code>func wantContains(t *testing.T, got string, want string)</code></pre>
         </article>
         
         <article class="function" data-name="PkgLinksym">
            <h2>PkgLinksym</h2>
            <hr />
            
            <p>PkgLinksym returns the linker symbol for name within the given
package prefix. For user packages, prefix should be the package
path encoded with objabi.PathToPrefix.</p>
            
            <pre><code>func PkgLinksym(prefix string, name string, abi obj.ABI) *obj.LSym</code></pre>
         </article>
         
         <article class="function" data-name="Linkname">
            <h2>Linkname</h2>
            <hr />
            
            <p>Linkname returns the linker symbol for the given name as it might
appear within a //go:linkname directive.</p>
            
            <pre><code>func Linkname(name string, abi obj.ABI) *obj.LSym</code></pre>
         </article>
         
         <article class="function" data-name="linksym">
            <h2>linksym</h2>
            <hr />
            
            <p>linksym is an internal helper function for implementing the above
exported APIs.</p>
            
            <pre><code>func linksym(pkg string, name string, abi obj.ABI) *obj.LSym</code></pre>
         </article>
         
         <article class="function" data-name="MapFile">
            <h2>MapFile</h2>
            <hr />
            
            <pre><code>func MapFile(f *os.File, offset int64, length int64) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="AtExit">
            <h2>AtExit</h2>
            <hr />
            
            <pre><code>func AtExit(f func)</code></pre>
         </article>
         
         <article class="function" data-name="Exit">
            <h2>Exit</h2>
            <hr />
            
            <pre><code>func Exit(code int)</code></pre>
         </article>
         
         <article class="function" data-name="forEachGC">
            <h2>forEachGC</h2>
            <hr />
            
            <p>forEachGC calls fn each GC cycle until it returns false.</p>
            
            <pre><code>func forEachGC(fn func)</code></pre>
         </article>
         
         <article class="function" data-name="AdjustStartingHeap">
            <h2>AdjustStartingHeap</h2>
            <hr />
            
            <p>AdjustStartingHeap modifies GOGC so that GC should not occur until the heap
grows to the requested size.  This is intended but not promised, though it
is true-mostly, depending on when the adjustment occurs and on the
compiler's input and behavior.  Once this size is approximately reached
GOGC is reset to 100; subsequent GCs may reduce the heap below the requested
size, but this function does not affect that.

-d=gcadjust=1 enables logging of GOGC adjustment events.

NOTE: If you think this code would help startup time in your own
application and you decide to use it, please benchmark first to see if it
actually works for you (it may not: the Go compiler is not typical), and
whatever the outcome, please leave a comment on bug #56546.  This code
uses supported interfaces, but depends more than we like on
current+observed behavior of the garbage collector, so if many people need
this feature, we should consider/propose a better way to accomplish it.</p>
            
            <pre><code>func AdjustStartingHeap(requestedHeapGoal uint64)</code></pre>
         </article>
         
         <article class="function" data-name="usage">
            <h2>usage</h2>
            <hr />
            
            <pre><code>func usage()</code></pre>
         </article>
         
         <article class="function" data-name="addEnv">
            <h2>addEnv</h2>
            <hr />
            
            <pre><code>func addEnv(s string)</code></pre>
         </article>
         
         <article class="function" data-name="ParseFlags">
            <h2>ParseFlags</h2>
            <hr />
            
            <p>ParseFlags parses the command-line flags into Flag.</p>
            
            <pre><code>func ParseFlags()</code></pre>
         </article>
         
         <article class="function" data-name="registerFlags">
            <h2>registerFlags</h2>
            <hr />
            
            <p>registerFlags adds flag registrations for all the fields in Flag.
See the comment on type CmdFlags for the rules.</p>
            
            <pre><code>func registerFlags()</code></pre>
         </article>
         
         <article class="function" data-name="concurrentFlagOk">
            <h2>concurrentFlagOk</h2>
            <hr />
            
            <p>concurrentFlagOk reports whether the current compiler flags
are compatible with concurrent compilation.</p>
            
            <pre><code>func concurrentFlagOk() bool</code></pre>
         </article>
         
         <article class="function" data-name="concurrentBackendAllowed">
            <h2>concurrentBackendAllowed</h2>
            <hr />
            
            <pre><code>func concurrentBackendAllowed() bool</code></pre>
         </article>
         
         <article class="function" data-name="addImportDir">
            <h2>addImportDir</h2>
            <hr />
            
            <pre><code>func addImportDir(dir string)</code></pre>
         </article>
         
         <article class="function" data-name="readImportCfg">
            <h2>readImportCfg</h2>
            <hr />
            
            <pre><code>func readImportCfg(file string)</code></pre>
         </article>
         
         <article class="function" data-name="readCoverageCfg">
            <h2>readCoverageCfg</h2>
            <hr />
            
            <pre><code>func readCoverageCfg(file string)</code></pre>
         </article>
         
         <article class="function" data-name="readEmbedCfg">
            <h2>readEmbedCfg</h2>
            <hr />
            
            <pre><code>func readEmbedCfg(file string)</code></pre>
         </article>
         
         <article class="function" data-name="parseSpectre">
            <h2>parseSpectre</h2>
            <hr />
            
            <p>parseSpectre parses the spectre configuration from the string s.</p>
            
            <pre><code>func parseSpectre(s string)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
