<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - base</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>base</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"cmd/internal/cov/covcmd"
"cmd/internal/telemetry/counter"
"encoding/json"
"flag"
"fmt"
"internal/buildcfg"
"internal/platform"
"log"
"os"
"reflect"
"runtime"
"strings"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/sys"
"bytes"
"cmd/internal/obj"
"cmd/internal/src"
"fmt"
"internal/bisect"
"io"
"os"
"path/filepath"
"strconv"
"strings"
"sync"
"cmd/internal/obj"
"io"
"os"
"fmt"
"io"
"strings"
"time"
"fmt"
"os"
"runtime"
"runtime/debug"
"runtime/metrics"
"internal/unsafeheader"
"os"
"runtime"
"syscall"
"unsafe"
"fmt"
"internal/buildcfg"
"internal/types/errors"
"os"
"runtime/debug"
"sort"
"strings"
"cmd/internal/src"
"cmd/internal/telemetry/counter"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="AutogeneratedPos" data-name="AutogeneratedPos">
               <h3>
                  AutogeneratedPos 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#AutogeneratedPos" class="anchor" title="Link to AutogeneratedPos">#</a>
               </h3>
               
               <pre><code>var AutogeneratedPos src.XPos</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="CompilerBootstrap" data-name="CompilerBootstrap">
               <h3>
                  CompilerBootstrap 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#CompilerBootstrap" class="anchor" title="Link to CompilerBootstrap">#</a>
               </h3>
               
               <p>CompilerBootstrap reports whether the current compiler binary was
built with -tags=compiler_bootstrap.</p>
               
               <pre><code>const CompilerBootstrap = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="CompilerBootstrap" data-name="CompilerBootstrap">
               <h3>
                  CompilerBootstrap 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#CompilerBootstrap" class="anchor" title="Link to CompilerBootstrap">#</a>
               </h3>
               
               <p>CompilerBootstrap reports whether the current compiler binary was
built with -tags=compiler_bootstrap.</p>
               
               <pre><code>const CompilerBootstrap = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Ctxt" data-name="Ctxt">
               <h3>
                  Ctxt 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Ctxt" class="anchor" title="Link to Ctxt">#</a>
               </h3>
               
               <pre><code>var Ctxt *obj.Link</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Debug" data-name="Debug">
               <h3>
                  Debug 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Debug" class="anchor" title="Link to Debug">#</a>
               </h3>
               
               <p>Debug holds the parsed debugging configuration values.</p>
               
               <pre><code>var Debug DebugFlags</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DebugSSA" data-name="DebugSSA">
               <h3>
                  DebugSSA 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#DebugSSA" class="anchor" title="Link to DebugSSA">#</a>
               </h3>
               
               <p>DebugSSA is called to set a -d ssa/... option.
If nil, those options are reported as invalid options.
If DebugSSA returns a non-empty string, that text is reported as a compiler error.</p>
               
               <pre><code>var DebugSSA func(phase string, flag string, val int, valString string) string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="EnableTrace" data-name="EnableTrace">
               <h3>
                  EnableTrace 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#EnableTrace" class="anchor" title="Link to EnableTrace">#</a>
               </h3>
               
               <p>To enable tracing support (-t flag), set EnableTrace to true.</p>
               
               <pre><code>const EnableTrace = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Flag" data-name="Flag">
               <h3>
                  Flag 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Flag" class="anchor" title="Link to Flag">#</a>
               </h3>
               
               <p>Flag holds the parsed command-line flags.
See ParseFlag for non-zero defaults.</p>
               
               <pre><code>var Flag CmdFlags</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FmaHash" data-name="FmaHash">
               <h3>
                  FmaHash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#FmaHash" class="anchor" title="Link to FmaHash">#</a>
               </h3>
               
               <pre><code>var FmaHash *HashDebug</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="LoopVarHash" data-name="LoopVarHash">
               <h3>
                  LoopVarHash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#LoopVarHash" class="anchor" title="Link to LoopVarHash">#</a>
               </h3>
               
               <pre><code>var LoopVarHash *HashDebug</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MergeLocalsHash" data-name="MergeLocalsHash">
               <h3>
                  MergeLocalsHash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#MergeLocalsHash" class="anchor" title="Link to MergeLocalsHash">#</a>
               </h3>
               
               <pre><code>var MergeLocalsHash *HashDebug</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PGOHash" data-name="PGOHash">
               <h3>
                  PGOHash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#PGOHash" class="anchor" title="Link to PGOHash">#</a>
               </h3>
               
               <pre><code>var PGOHash *HashDebug</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Pos" data-name="Pos">
               <h3>
                  Pos 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Pos" class="anchor" title="Link to Pos">#</a>
               </h3>
               
               <p>Pos is the current source position being processed,
printed by Errorf, ErrorfLang, Fatalf, and Warnf.</p>
               
               <pre><code>var Pos src.XPos</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ReservedImports" data-name="ReservedImports">
               <h3>
                  ReservedImports 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ReservedImports" class="anchor" title="Link to ReservedImports">#</a>
               </h3>
               
               <p>ReservedImports are import paths used internally for generated
symbols by the compiler.
The linker uses the magic symbol prefixes "go:" and "type:".
Avoid potential confusion between import paths and symbols
by rejecting these reserved imports for now. Also, people
"can do weird things in GOPATH and we'd prefer they didn't
do _that_ weird thing" (per rsc). See also #4257.</p>
               
               <pre><code>var ReservedImports = map[string]bool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Timer" data-name="Timer">
               <h3>
                  Timer 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Timer" class="anchor" title="Link to Timer">#</a>
               </h3>
               
               <pre><code>var Timer Timings</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="atExitFuncs" data-name="atExitFuncs">
               <h3>
                  atExitFuncs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#atExitFuncs" class="anchor" title="Link to atExitFuncs">#</a>
               </h3>
               
               <pre><code>var atExitFuncs []func()</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bugStack" data-name="bugStack">
               <h3>
                  bugStack 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bugStack" class="anchor" title="Link to bugStack">#</a>
               </h3>
               
               <pre><code>var bugStack = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errorMsgs" data-name="errorMsgs">
               <h3>
                  errorMsgs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errorMsgs" class="anchor" title="Link to errorMsgs">#</a>
               </h3>
               
               <pre><code>var errorMsgs []errorMsg</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hashDebug" data-name="hashDebug">
               <h3>
                  hashDebug 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#hashDebug" class="anchor" title="Link to hashDebug">#</a>
               </h3>
               
               <p>The default compiler-debugging HashDebug, for "-d=gossahash=..."</p>
               
               <pre><code>var hashDebug *HashDebug</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="lasterror" data-name="lasterror">
               <h3>
                  lasterror 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#lasterror" class="anchor" title="Link to lasterror">#</a>
               </h3>
               
               <p>lasterror keeps track of the most recently issued error,
to avoid printing multiple error messages on the same line.</p>
               
               <pre><code>var lasterror struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="numErrors" data-name="numErrors">
               <h3>
                  numErrors 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#numErrors" class="anchor" title="Link to numErrors">#</a>
               </h3>
               
               <pre><code>var numErrors int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="numSyntaxErrors" data-name="numSyntaxErrors">
               <h3>
                  numSyntaxErrors 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#numSyntaxErrors" class="anchor" title="Link to numSyntaxErrors">#</a>
               </h3>
               
               <pre><code>var numSyntaxErrors int</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="CountFlag" data-name="CountFlag">
               <h3>
                  CountFlag
                  <span class="badge type-badge">type</span>
                  <a href="#CountFlag" class="anchor" title="Link to CountFlag">#</a>
               </h3>
               
               <p>A CountFlag is a counting integer flag.
It accepts -name=value to set the value directly,
but it also accepts -name with no =value to increment the count.</p>
               
               <pre><code>type CountFlag int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="byPos" data-name="byPos">
               <h3>
                  byPos
                  <span class="badge type-badge">type</span>
                  <a href="#byPos" class="anchor" title="Link to byPos">#</a>
               </h3>
               
               <p>byPos sorts errors by source position.</p>
               
               <pre><code>type byPos []errorMsg</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="lines" data-name="lines">
               <h3>
                  lines
                  <span class="badge type-badge">type</span>
                  <a href="#lines" class="anchor" title="Link to lines">#</a>
               </h3>
               
               <pre><code>type lines [][]string</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="CmdFlags" data-name="CmdFlags">
               <h3>
                  CmdFlags
                  <span class="badge">struct</span>
                  <a href="#CmdFlags" class="anchor" title="Link to CmdFlags">#</a>
               </h3>
               
               <p>CmdFlags defines the command-line flags (see var Flag).
Each struct field is a different flag, by default named for the lower-case of the field name.
If the flag name is a single letter, the default flag name is left upper-case.
If the flag name is "Lower" followed by a single letter, the default flag name is the lower-case of the last letter.
If this default flag name can't be made right, the `flag` struct tag can be used to replace it,
but this should be done only in exceptional circumstances: it helps everyone if the flag name
is obvious from the field name when the flag is used elsewhere in the compiler sources.
The `flag:"-"` struct tag makes a field invisible to the flag logic and should also be used sparingly.
Each field must have a `help` struct tag giving the flag help message.
The allowed field types are bool, int, string, pointers to those (for values stored elsewhere),
CountFlag (for a counting flag), and func(string) (for a flag that uses special code for parsing).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CmdFlags struct {
B CountFlag "help:\"disable bounds checking\""
C CountFlag "help:\"disable printing of columns in error messages\""
D string "help:\"set relative `path` for local imports\""
E CountFlag "help:\"debug symbol export\""
I func(string) "help:\"add `directory` to import search path\""
K CountFlag "help:\"debug missing line numbers\""
L CountFlag "help:\"also show actual source file names in error messages for positions affected by //line directives\""
N CountFlag "help:\"disable optimizations\""
S CountFlag "help:\"print assembly listing\""
W CountFlag "help:\"debug parse tree after type checking\""
LowerC int "help:\"concurrency during compilation (1 means no concurrency)\""
LowerD flag.Value "help:\"enable debugging settings; try -d help\""
LowerE CountFlag "help:\"no limit on number of errors reported\""
LowerH CountFlag "help:\"halt on error\""
LowerJ CountFlag "help:\"debug runtime-initialized variables\""
LowerL CountFlag "help:\"disable inlining\""
LowerM CountFlag "help:\"print optimization decisions\""
LowerO string "help:\"write output to `file`\""
LowerP *string "help:\"set expected package import `path`\""
LowerR CountFlag "help:\"debug generated wrappers\""
LowerT bool "help:\"enable tracing for debugging the compiler\""
LowerW CountFlag "help:\"debug type checking\""
LowerV *bool "help:\"increase debug verbosity\""
Percent CountFlag "flag:\"%\" help:\"debug non-static initializers\""
CompilingRuntime bool "flag:\"+\" help:\"compiling runtime\""
AsmHdr string "help:\"write assembly header to `file`\""
ASan bool "help:\"build code compatible with C/C++ address sanitizer\""
Bench string "help:\"append benchmark times to `file`\""
BlockProfile string "help:\"write block profile to `file`\""
BuildID string "help:\"record `id` as the build id in the export metadata\""
CPUProfile string "help:\"write cpu profile to `file`\""
Complete bool "help:\"compiling complete package (no C or assembly)\""
ClobberDead bool "help:\"clobber dead stack slots (for debugging)\""
ClobberDeadReg bool "help:\"clobber dead registers (for debugging)\""
Dwarf bool "help:\"generate DWARF symbols\""
DwarfBASEntries *bool "help:\"use base address selection entries in DWARF\""
DwarfLocationLists *bool "help:\"add location lists to DWARF in optimized mode\""
Dynlink *bool "help:\"support references to Go symbols defined in other shared libraries\""
EmbedCfg func(string) "help:\"read go:embed configuration from `file`\""
Env func(string) "help:\"add `definition` of the form key=value to environment\""
GenDwarfInl int "help:\"generate DWARF inline info records\""
GoVersion string "help:\"required version of the runtime\""
ImportCfg func(string) "help:\"read import configuration from `file`\""
InstallSuffix string "help:\"set pkg directory `suffix`\""
JSON string "help:\"version,file for JSON compiler/optimizer detail output\""
Lang string "help:\"Go language version source code expects\""
LinkObj string "help:\"write linker-specific object to `file`\""
LinkShared *bool "help:\"generate code that will be linked against Go shared libraries\""
Live CountFlag "help:\"debug liveness analysis\""
MSan bool "help:\"build code compatible with C/C++ memory sanitizer\""
MemProfile string "help:\"write memory profile to `file`\""
MemProfileRate int "help:\"set runtime.MemProfileRate to `rate`\""
MutexProfile string "help:\"write mutex profile to `file`\""
NoLocalImports bool "help:\"reject local (relative) imports\""
CoverageCfg func(string) "help:\"read coverage configuration from `file`\""
Pack bool "help:\"write to file.a instead of file.o\""
Race bool "help:\"enable race detector\""
Shared *bool "help:\"generate code that can be linked into a shared library\""
SmallFrames bool "help:\"reduce the size limit for stack allocated objects\""
Spectre string "help:\"enable spectre mitigations in `list` (all, index, ret)\""
Std bool "help:\"compiling standard library\""
SymABIs string "help:\"read symbol ABIs from `file`\""
TraceProfile string "help:\"write an execution trace to `file`\""
TrimPath string "help:\"remove `prefix` from recorded source file paths\""
WB bool "help:\"enable write barrier\""
PgoProfile string "help:\"read profile or pre-process profile from `file`\""
ErrorURL bool "help:\"print explanatory URL with error message if applicable\""
Cfg struct{...}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="DebugFlags" data-name="DebugFlags">
               <h3>
                  DebugFlags
                  <span class="badge">struct</span>
                  <a href="#DebugFlags" class="anchor" title="Link to DebugFlags">#</a>
               </h3>
               
               <p>DebugFlags defines the debugging configuration values (see var Debug).
Each struct field is a different value, named for the lower-case of the field name.
Each field must be an int or string and must have a `help` struct tag.
The -d option takes a comma-separated list of settings.
Each setting is name=value; for ints, name is short for name=1.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type DebugFlags struct {
AlignHot int `help:"enable hot block alignment (currently requires -pgo)" concurrent:"ok"`
Append int `help:"print information about append compilation"`
Checkptr int `help:"instrument unsafe pointer conversions\n0: instrumentation disabled\n1: conversions involving unsafe.Pointer are instrumented\n2: conversions to unsafe.Pointer force heap allocation" concurrent:"ok"`
Closure int `help:"print information about closure compilation"`
Defer int `help:"print information about defer compilation"`
DisableNil int `help:"disable nil checks" concurrent:"ok"`
DumpInlFuncProps string `help:"dump function properties from inl heuristics to specified file"`
DumpInlCallSiteScores int `help:"dump scored callsites during inlining"`
InlScoreAdj string `help:"set inliner score adjustments (ex: -d=inlscoreadj=panicPathAdj:10/passConstToNestedIfAdj:-90)"`
InlBudgetSlack int `help:"amount to expand the initial inline budget when new inliner enabled. Defaults to 80 if option not set." concurrent:"ok"`
DumpPtrs int `help:"show Node pointers values in dump output"`
DwarfInl int `help:"print information about DWARF inlined function creation"`
EscapeMutationsCalls int `help:"print extra escape analysis diagnostics about mutations and calls" concurrent:"ok"`
Export int `help:"print export data"`
FIPSHash string `help:"hash value for FIPS debugging" concurrent:"ok"`
Fmahash string `help:"hash value for use in debugging platform-dependent multiply-add use" concurrent:"ok"`
GCAdjust int `help:"log adjustments to GOGC" concurrent:"ok"`
GCCheck int `help:"check heap/gc use by compiler" concurrent:"ok"`
GCProg int `help:"print dump of GC programs"`
Gossahash string `help:"hash value for use in debugging the compiler"`
InlFuncsWithClosures int `help:"allow functions with closures to be inlined" concurrent:"ok"`
InlStaticInit int `help:"allow static initialization of inlined calls" concurrent:"ok"`
Libfuzzer int `help:"enable coverage instrumentation for libfuzzer"`
LoopVar int `help:"shared (0, default), 1 (private loop variables), 2, private + log"`
LoopVarHash string `help:"for debugging changes in loop behavior. Overrides experiment and loopvar flag."`
LocationLists int `help:"print information about DWARF location list creation"`
MaxShapeLen int `help:"hash shape names longer than this threshold (default 500)" concurrent:"ok"`
MergeLocals int `help:"merge together non-interfering local stack slots" concurrent:"ok"`
MergeLocalsDumpFunc string `help:"dump specified func in merge locals"`
MergeLocalsHash string `help:"hash value for debugging stack slot merging of local variables" concurrent:"ok"`
MergeLocalsTrace int `help:"trace debug output for locals merging"`
MergeLocalsHTrace int `help:"hash-selected trace debug output for locals merging"`
Nil int `help:"print information about nil checks"`
NoDeadLocals int `help:"disable deadlocals pass" concurrent:"ok"`
NoOpenDefer int `help:"disable open-coded defers" concurrent:"ok"`
NoRefName int `help:"do not include referenced symbol names in object file" concurrent:"ok"`
PCTab string `help:"print named pc-value table\nOne of: pctospadj, pctofile, pctoline, pctoinline, pctopcdata"`
Panic int `help:"show all compiler panics"`
Reshape int `help:"print information about expression reshaping"`
Shapify int `help:"print information about shaping recursive types"`
Slice int `help:"print information about slice compilation"`
SoftFloat int `help:"force compiler to emit soft-float code" concurrent:"ok"`
StaticCopy int `help:"print information about missed static copies" concurrent:"ok"`
SyncFrames int `help:"how many writer stack frames to include at sync points in unified export data"`
TailCall int `help:"print information about tail calls"`
TypeAssert int `help:"print information about type assertion inlining"`
WB int `help:"print information about write barriers"`
ABIWrap int `help:"print information about ABI wrapper generation"`
MayMoreStack string `help:"call named function before all stack growth checks" concurrent:"ok"`
PGODebug int `help:"debug profile-guided optimizations"`
PGOHash string `help:"hash value for debugging profile-guided optimizations" concurrent:"ok"`
PGOInline int `help:"enable profile-guided inlining" concurrent:"ok"`
PGOInlineCDFThreshold string `help:"cumulative threshold percentage for determining call sites as hot candidates for inlining" concurrent:"ok"`
PGOInlineBudget int `help:"inline budget for hot functions" concurrent:"ok"`
PGODevirtualize int `help:"enable profile-guided devirtualization; 0 to disable, 1 to enable interface devirtualization, 2 to enable function devirtualization" concurrent:"ok"`
RangeFuncCheck int `help:"insert code to check behavior of range iterator functions" concurrent:"ok"`
WrapGlobalMapDbg int `help:"debug trace output for global map init wrapping"`
WrapGlobalMapCtl int `help:"global map init wrap control (0 => default, 1 => off, 2 => stress mode, no size cutoff)"`
ZeroCopy int `help:"enable zero-copy string->[]byte conversions" concurrent:"ok"`
ConcurrentOk bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="HashDebug" data-name="HashDebug">
               <h3>
                  HashDebug
                  <span class="badge">struct</span>
                  <a href="#HashDebug" class="anchor" title="Link to HashDebug">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type HashDebug struct {
mu sync.Mutex
name string
logfile io.Writer
posTmp []src.Pos
bytesTmp bytes.Buffer
matches []hashAndMask
excludes []hashAndMask
bisect *bisect.Matcher
fileSuffixOnly bool
inlineSuffixOnly bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Timings" data-name="Timings">
               <h3>
                  Timings
                  <span class="badge">struct</span>
                  <a href="#Timings" class="anchor" title="Link to Timings">#</a>
               </h3>
               
               <p>Timings collects the execution times of labeled phases
which are added through a sequence of Start/Stop calls.
Events may be associated with each phase via AddEvent.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Timings struct {
list []timestamp
events map[int][]*event
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="errorMsg" data-name="errorMsg">
               <h3>
                  errorMsg
                  <span class="badge">struct</span>
                  <a href="#errorMsg" class="anchor" title="Link to errorMsg">#</a>
               </h3>
               
               <p>An errorMsg is a queued error message, waiting to be printed.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type errorMsg struct {
pos src.XPos
msg string
code errors.Code
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="event" data-name="event">
               <h3>
                  event
                  <span class="badge">struct</span>
                  <a href="#event" class="anchor" title="Link to event">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type event struct {
size int64
unit string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="hashAndMask" data-name="hashAndMask">
               <h3>
                  hashAndMask
                  <span class="badge">struct</span>
                  <a href="#hashAndMask" class="anchor" title="Link to hashAndMask">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type hashAndMask struct {
hash uint64
mask uint64
name string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="timestamp" data-name="timestamp">
               <h3>
                  timestamp
                  <span class="badge">struct</span>
                  <a href="#timestamp" class="anchor" title="Link to timestamp">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type timestamp struct {
time time.Time
label string
start bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AddEvent" data-name="AddEvent">
               <h3>
                  AddEvent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddEvent" class="anchor" title="Link to AddEvent">#</a>
               </h3>
               
               <p>AddEvent associates an event, i.e., a count, or an amount of data,
with the most recently started or stopped phase; or the very first
phase if Start or Stop hasn't been called yet. The unit specifies
the unit of measurement (e.g., MB, lines, no. of funcs, etc.).</p>
               
               <pre><code>func (t *Timings) AddEvent(size int64, unit string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AdjustStartingHeap" data-name="AdjustStartingHeap">
               <h3>
                  AdjustStartingHeap 
                  <span class="badge">function</span>
                  
                  <a href="#AdjustStartingHeap" class="anchor" title="Link to AdjustStartingHeap">#</a>
               </h3>
               
               <p>AdjustStartingHeap modifies GOGC so that GC should not occur until the heap
grows to the requested size.  This is intended but not promised, though it
is true-mostly, depending on when the adjustment occurs and on the
compiler's input and behavior.  Once this size is approximately reached
GOGC is reset to 100; subsequent GCs may reduce the heap below the requested
size, but this function does not affect that.
-d=gcadjust=1 enables logging of GOGC adjustment events.
NOTE: If you think this code would help startup time in your own
application and you decide to use it, please benchmark first to see if it
actually works for you (it may not: the Go compiler is not typical), and
whatever the outcome, please leave a comment on bug #56546.  This code
uses supported interfaces, but depends more than we like on
current+observed behavior of the garbage collector, so if many people need
this feature, we should consider/propose a better way to accomplish it.</p>
               
               <pre><code>func AdjustStartingHeap(requestedHeapGoal uint64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Assert" data-name="Assert">
               <h3>
                  Assert 
                  <span class="badge">function</span>
                  
                  <a href="#Assert" class="anchor" title="Link to Assert">#</a>
               </h3>
               
               <p>Assert reports "assertion failed" with Fatalf, unless b is true.</p>
               
               <pre><code>func Assert(b bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Assertf" data-name="Assertf">
               <h3>
                  Assertf 
                  <span class="badge">function</span>
                  
                  <a href="#Assertf" class="anchor" title="Link to Assertf">#</a>
               </h3>
               
               <p>Assertf reports a fatal error with Fatalf, unless b is true.</p>
               
               <pre><code>func Assertf(b bool, format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AssertfAt" data-name="AssertfAt">
               <h3>
                  AssertfAt 
                  <span class="badge">function</span>
                  
                  <a href="#AssertfAt" class="anchor" title="Link to AssertfAt">#</a>
               </h3>
               
               <p>AssertfAt reports a fatal error with FatalfAt, unless b is true.</p>
               
               <pre><code>func AssertfAt(b bool, pos src.XPos, format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AtExit" data-name="AtExit">
               <h3>
                  AtExit 
                  <span class="badge">function</span>
                  
                  <a href="#AtExit" class="anchor" title="Link to AtExit">#</a>
               </h3>
               
               <pre><code>func AtExit(f func())</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DebugHashMatchPkgFunc" data-name="DebugHashMatchPkgFunc">
               <h3>
                  DebugHashMatchPkgFunc 
                  <span class="badge">function</span>
                  
                  <a href="#DebugHashMatchPkgFunc" class="anchor" title="Link to DebugHashMatchPkgFunc">#</a>
               </h3>
               
               <p>DebugHashMatchPkgFunc reports whether debug variable Gossahash
1. is empty (returns true; this is a special more-quickly implemented case of 4 below)
2. is "y" or "Y" (returns true)
3. is "n" or "N" (returns false)
4. does not explicitly exclude the sha1 hash of pkgAndName (see step 6)
5. is a suffix of the sha1 hash of pkgAndName (returns true)
6. OR
if the (non-empty) value is in the regular language
"(-[01]+/)+?([01]+(/[01]+)+?"
(exclude..)(....include...)
test the [01]+ exclude substrings, if any suffix-match, return false (4 above)
test the [01]+ include substrings, if any suffix-match, return true
The include substrings AFTER the first slash are numbered 0,1, etc and
are named fmt.Sprintf("%s%d", varname, number)
As an extra-special case for multiple failure search,
an excludes-only string ending in a slash (terminated, not separated)
implicitly specifies the include string "0/1", that is, match everything.
(Exclude strings are used for automated search for multiple failures.)
Clause 6 is not really intended for human use and only
matters for failures that require multiple triggers.
Otherwise it returns false.
Unless Flags.Gossahash is empty, when DebugHashMatchPkgFunc returns true the message
"%s triggered %s\n", varname, pkgAndName
is printed on the file named in environment variable GSHS_LOGFILE,
or standard out if that is empty.  "Varname" is either the name of
the variable or the name of the substring, depending on which matched.
Typical use:
1. you make a change to the compiler, say, adding a new phase
2. it is broken in some mystifying way, for example, make.bash builds a broken
compiler that almost works, but crashes compiling a test in run.bash.
3. add this guard to the code, which by default leaves it broken, but does not
run the broken new code if Flags.Gossahash is non-empty and non-matching:
if !base.DebugHashMatch(ir.PkgFuncName(fn)) {
return nil // early exit, do nothing
}
4. rebuild w/o the bad code,
GOCOMPILEDEBUG=gossahash=n ./all.bash
to verify that you put the guard in the right place with the right sense of the test.
5. use github.com/dr2chase/gossahash to search for the error:
go install github.com/dr2chase/gossahash@latest
gossahash -- <the thing that fails>
for example: GOMAXPROCS=1 gossahash -- ./all.bash
6. gossahash should return a single function whose miscompilation
causes the problem, and you can focus on that.</p>
               
               <pre><code>func DebugHashMatchPkgFunc(pkg string, fn string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DebugHashMatchPos" data-name="DebugHashMatchPos">
               <h3>
                  DebugHashMatchPos 
                  <span class="badge">function</span>
                  
                  <a href="#DebugHashMatchPos" class="anchor" title="Link to DebugHashMatchPos">#</a>
               </h3>
               
               <pre><code>func DebugHashMatchPos(pos src.XPos) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ErrorExit" data-name="ErrorExit">
               <h3>
                  ErrorExit 
                  <span class="badge">function</span>
                  
                  <a href="#ErrorExit" class="anchor" title="Link to ErrorExit">#</a>
               </h3>
               
               <p>ErrorExit handles an error-status exit.
It flushes any pending errors, removes the output file, and exits.</p>
               
               <pre><code>func ErrorExit()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Errorf" data-name="Errorf">
               <h3>
                  Errorf 
                  <span class="badge">function</span>
                  
                  <a href="#Errorf" class="anchor" title="Link to Errorf">#</a>
               </h3>
               
               <p>Errorf reports a formatted error at the current line.</p>
               
               <pre><code>func Errorf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ErrorfAt" data-name="ErrorfAt">
               <h3>
                  ErrorfAt 
                  <span class="badge">function</span>
                  
                  <a href="#ErrorfAt" class="anchor" title="Link to ErrorfAt">#</a>
               </h3>
               
               <p>ErrorfAt reports a formatted error message at pos.</p>
               
               <pre><code>func ErrorfAt(pos src.XPos, code errors.Code, format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Errors" data-name="Errors">
               <h3>
                  Errors 
                  <span class="badge">function</span>
                  
                  <a href="#Errors" class="anchor" title="Link to Errors">#</a>
               </h3>
               
               <p>Errors returns the number of errors reported.</p>
               
               <pre><code>func Errors() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Exit" data-name="Exit">
               <h3>
                  Exit 
                  <span class="badge">function</span>
                  
                  <a href="#Exit" class="anchor" title="Link to Exit">#</a>
               </h3>
               
               <pre><code>func Exit(code int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ExitIfErrors" data-name="ExitIfErrors">
               <h3>
                  ExitIfErrors 
                  <span class="badge">function</span>
                  
                  <a href="#ExitIfErrors" class="anchor" title="Link to ExitIfErrors">#</a>
               </h3>
               
               <p>ExitIfErrors calls ErrorExit if any errors have been reported.</p>
               
               <pre><code>func ExitIfErrors()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fatalf" data-name="Fatalf">
               <h3>
                  Fatalf 
                  <span class="badge">function</span>
                  
                  <a href="#Fatalf" class="anchor" title="Link to Fatalf">#</a>
               </h3>
               
               <p>Fatalf reports a fatal error - an internal problem - at the current line and exits.
If other errors have already been printed, then Fatalf just quietly exits.
(The internal problem may have been caused by incomplete information
after the already-reported errors, so best to let users fix those and
try again without being bothered about a spurious internal error.)
But if no errors have been printed, or if -d panic has been specified,
Fatalf prints the error as an "internal compiler error". In a released build,
it prints an error asking to file a bug report. In development builds, it
prints a stack trace.
If -h has been specified, Fatalf panics to force the usual runtime info dump.</p>
               
               <pre><code>func Fatalf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FatalfAt" data-name="FatalfAt">
               <h3>
                  FatalfAt 
                  <span class="badge">function</span>
                  
                  <a href="#FatalfAt" class="anchor" title="Link to FatalfAt">#</a>
               </h3>
               
               <p>FatalfAt reports a fatal error - an internal problem - at pos and exits.
If other errors have already been printed, then FatalfAt just quietly exits.
(The internal problem may have been caused by incomplete information
after the already-reported errors, so best to let users fix those and
try again without being bothered about a spurious internal error.)
But if no errors have been printed, or if -d panic has been specified,
FatalfAt prints the error as an "internal compiler error". In a released build,
it prints an error asking to file a bug report. In development builds, it
prints a stack trace.
If -h has been specified, FatalfAt panics to force the usual runtime info dump.</p>
               
               <pre><code>func FatalfAt(pos src.XPos, format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FlushErrors" data-name="FlushErrors">
               <h3>
                  FlushErrors 
                  <span class="badge">function</span>
                  
                  <a href="#FlushErrors" class="anchor" title="Link to FlushErrors">#</a>
               </h3>
               
               <p>FlushErrors sorts errors seen so far by line number, prints them to stdout,
and empties the errors array.</p>
               
               <pre><code>func FlushErrors()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FmtPos" data-name="FmtPos">
               <h3>
                  FmtPos 
                  <span class="badge">function</span>
                  
                  <a href="#FmtPos" class="anchor" title="Link to FmtPos">#</a>
               </h3>
               
               <p>FmtPos formats pos as a file:line string.</p>
               
               <pre><code>func FmtPos(pos src.XPos) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HasDebugHash" data-name="HasDebugHash">
               <h3>
                  HasDebugHash 
                  <span class="badge">function</span>
                  
                  <a href="#HasDebugHash" class="anchor" title="Link to HasDebugHash">#</a>
               </h3>
               
               <p>HasDebugHash returns true if Flags.Gossahash is non-empty, which
results in hashDebug being not-nil.  I.e., if !HasDebugHash(),
there is no need to create the string for hashing and testing.</p>
               
               <pre><code>func HasDebugHash() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code>func (x byPos) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Less" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Less" class="anchor" title="Link to Less">#</a>
               </h3>
               
               <pre><code>func (x byPos) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Linkname" data-name="Linkname">
               <h3>
                  Linkname 
                  <span class="badge">function</span>
                  
                  <a href="#Linkname" class="anchor" title="Link to Linkname">#</a>
               </h3>
               
               <p>Linkname returns the linker symbol for the given name as it might
appear within a //go:linkname directive.</p>
               
               <pre><code>func Linkname(name string, abi obj.ABI) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MapFile" data-name="MapFile">
               <h3>
                  MapFile 
                  <span class="badge">function</span>
                  
                  <a href="#MapFile" class="anchor" title="Link to MapFile">#</a>
               </h3>
               
               <p>MapFile returns length bytes from the file starting at the
specified offset as a string.</p>
               
               <pre><code>func MapFile(f *os.File, offset int64, length int64) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MapFile" data-name="MapFile">
               <h3>
                  MapFile 
                  <span class="badge">function</span>
                  
                  <a href="#MapFile" class="anchor" title="Link to MapFile">#</a>
               </h3>
               
               <pre><code>func MapFile(f *os.File, offset int64, length int64) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MatchPkgFunc" data-name="MatchPkgFunc">
               <h3>
                  MatchPkgFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MatchPkgFunc" class="anchor" title="Link to MatchPkgFunc">#</a>
               </h3>
               
               <p>MatchPkgFunc returns true if either the variable used to create d is
unset, or if its value is y, or if it is a suffix of the base-two
representation of the hash of pkg and fn.  If the variable is not nil,
then a true result is accompanied by stylized output to d.logfile, which
is used for automated bug search.</p>
               
               <pre><code>func (d *HashDebug) MatchPkgFunc(pkg string, fn string, note func() string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MatchPos" data-name="MatchPos">
               <h3>
                  MatchPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MatchPos" class="anchor" title="Link to MatchPos">#</a>
               </h3>
               
               <p>MatchPos is similar to MatchPkgFunc, but for hash computation
it uses the source position including all inlining information instead of
package name and path.
Note that the default answer for no environment variable (d == nil)
is "yes", do the thing.</p>
               
               <pre><code>func (d *HashDebug) MatchPos(pos src.XPos, desc func() string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MatchPosWithInfo" data-name="MatchPosWithInfo">
               <h3>
                  MatchPosWithInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MatchPosWithInfo" class="anchor" title="Link to MatchPosWithInfo">#</a>
               </h3>
               
               <p>MatchPosWithInfo is similar to MatchPos, but with additional information
that is included for hash computation, so it can distinguish multiple
matches on the same source location.
Note that the default answer for no environment variable (d == nil)
is "yes", do the thing.</p>
               
               <pre><code>func (d *HashDebug) MatchPosWithInfo(pos src.XPos, info any, desc func() string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewHashDebug" data-name="NewHashDebug">
               <h3>
                  NewHashDebug 
                  <span class="badge">function</span>
                  
                  <a href="#NewHashDebug" class="anchor" title="Link to NewHashDebug">#</a>
               </h3>
               
               <p>NewHashDebug returns a new hash-debug tester for the
environment variable ev.  If ev is not set, it returns
nil, allowing a lightweight check for normal-case behavior.</p>
               
               <pre><code>func NewHashDebug(ev string, s string, file io.Writer) *HashDebug</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseFlags" data-name="ParseFlags">
               <h3>
                  ParseFlags 
                  <span class="badge">function</span>
                  
                  <a href="#ParseFlags" class="anchor" title="Link to ParseFlags">#</a>
               </h3>
               
               <p>ParseFlags parses the command-line flags into Flag.</p>
               
               <pre><code>func ParseFlags()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PkgLinksym" data-name="PkgLinksym">
               <h3>
                  PkgLinksym 
                  <span class="badge">function</span>
                  
                  <a href="#PkgLinksym" class="anchor" title="Link to PkgLinksym">#</a>
               </h3>
               
               <p>PkgLinksym returns the linker symbol for name within the given
package prefix. For user packages, prefix should be the package
path encoded with objabi.PathToPrefix.</p>
               
               <pre><code>func PkgLinksym(prefix string, name string, abi obj.ABI) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetInlineSuffixOnly" data-name="SetInlineSuffixOnly">
               <h3>
                  SetInlineSuffixOnly 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetInlineSuffixOnly" class="anchor" title="Link to SetInlineSuffixOnly">#</a>
               </h3>
               
               <p>SetInlineSuffixOnly controls whether hashing and reporting use the entire
inline position, or just the most-inline suffix.  Compiler debugging tends
to want the whole inlining, debugging user problems (loopvarhash, e.g.)
typically does not need to see the entire inline tree, there is just one
copy of the source code.</p>
               
               <pre><code>func (d *HashDebug) SetInlineSuffixOnly(b bool) *HashDebug</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Start" data-name="Start">
               <h3>
                  Start 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Start" class="anchor" title="Link to Start">#</a>
               </h3>
               
               <p>Start marks the beginning of a new phase and implicitly stops the previous phase.
The phase name is the colon-separated concatenation of the labels.</p>
               
               <pre><code>func (t *Timings) Start(labels ...string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stop" data-name="Stop">
               <h3>
                  Stop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stop" class="anchor" title="Link to Stop">#</a>
               </h3>
               
               <p>Stop marks the end of a phase and implicitly starts a new phase.
The labels are added to the labels of the ended phase.</p>
               
               <pre><code>func (t *Timings) Stop(labels ...string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <pre><code>func (x byPos) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SyntaxErrors" data-name="SyntaxErrors">
               <h3>
                  SyntaxErrors 
                  <span class="badge">function</span>
                  
                  <a href="#SyntaxErrors" class="anchor" title="Link to SyntaxErrors">#</a>
               </h3>
               
               <p>SyntaxErrors returns the number of syntax errors reported.</p>
               
               <pre><code>func SyntaxErrors() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UpdateErrorDot" data-name="UpdateErrorDot">
               <h3>
                  UpdateErrorDot 
                  <span class="badge">function</span>
                  
                  <a href="#UpdateErrorDot" class="anchor" title="Link to UpdateErrorDot">#</a>
               </h3>
               
               <p>UpdateErrorDot is a clumsy hack that rewrites the last error,
if it was "LINE: undefined: NAME", to be "LINE: undefined: NAME in EXPR".
It is used to give better error messages for dot (selector) expressions.</p>
               
               <pre><code>func UpdateErrorDot(line string, name string, expr string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Warn" data-name="Warn">
               <h3>
                  Warn 
                  <span class="badge">function</span>
                  
                  <a href="#Warn" class="anchor" title="Link to Warn">#</a>
               </h3>
               
               <p>Warn reports a formatted warning at the current line.
In general the Go compiler does NOT generate warnings,
so this should be used only when the user has opted in
to additional output by setting a particular flag.</p>
               
               <pre><code>func Warn(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WarnfAt" data-name="WarnfAt">
               <h3>
                  WarnfAt 
                  <span class="badge">function</span>
                  
                  <a href="#WarnfAt" class="anchor" title="Link to WarnfAt">#</a>
               </h3>
               
               <p>WarnfAt reports a formatted warning at pos.
In general the Go compiler does NOT generate warnings,
so this should be used only when the user has opted in
to additional output by setting a particular flag.</p>
               
               <pre><code>func WarnfAt(pos src.XPos, format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write prints the phase times to w.
The prefix is printed at the start of each line.</p>
               
               <pre><code>func (t *Timings) Write(w io.Writer, prefix string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <pre><code>func (lines *lines) add(label string, n int, dt time.Duration, tot time.Duration, events []*event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addEnv" data-name="addEnv">
               <h3>
                  addEnv 
                  <span class="badge">function</span>
                  
                  <a href="#addEnv" class="anchor" title="Link to addEnv">#</a>
               </h3>
               
               <pre><code>func addEnv(s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addErrorMsg" data-name="addErrorMsg">
               <h3>
                  addErrorMsg 
                  <span class="badge">function</span>
                  
                  <a href="#addErrorMsg" class="anchor" title="Link to addErrorMsg">#</a>
               </h3>
               
               <p>addErrorMsg adds a new errorMsg (which may be a warning) to errorMsgs.</p>
               
               <pre><code>func addErrorMsg(pos src.XPos, code errors.Code, format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addImportDir" data-name="addImportDir">
               <h3>
                  addImportDir 
                  <span class="badge">function</span>
                  
                  <a href="#addImportDir" class="anchor" title="Link to addImportDir">#</a>
               </h3>
               
               <pre><code>func addImportDir(dir string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="append" data-name="append">
               <h3>
                  append 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#append" class="anchor" title="Link to append">#</a>
               </h3>
               
               <pre><code>func (t *Timings) append(labels []string, start bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="commonPrefix" data-name="commonPrefix">
               <h3>
                  commonPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#commonPrefix" class="anchor" title="Link to commonPrefix">#</a>
               </h3>
               
               <pre><code>func commonPrefix(a string, b string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="concurrentBackendAllowed" data-name="concurrentBackendAllowed">
               <h3>
                  concurrentBackendAllowed 
                  <span class="badge">function</span>
                  
                  <a href="#concurrentBackendAllowed" class="anchor" title="Link to concurrentBackendAllowed">#</a>
               </h3>
               
               <pre><code>func concurrentBackendAllowed() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="concurrentFlagOk" data-name="concurrentFlagOk">
               <h3>
                  concurrentFlagOk 
                  <span class="badge">function</span>
                  
                  <a href="#concurrentFlagOk" class="anchor" title="Link to concurrentFlagOk">#</a>
               </h3>
               
               <p>concurrentFlagOk reports whether the current compiler flags
are compatible with concurrent compilation.</p>
               
               <pre><code>func concurrentFlagOk() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="excluded" data-name="excluded">
               <h3>
                  excluded 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#excluded" class="anchor" title="Link to excluded">#</a>
               </h3>
               
               <p>TODO: Delete when we switch to bisect-only.</p>
               
               <pre><code>func (d *HashDebug) excluded(hash uint64) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtPos" data-name="fmtPos">
               <h3>
                  fmtPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtPos" class="anchor" title="Link to fmtPos">#</a>
               </h3>
               
               <p>fmtPos returns a textual formatting of the position pos, including its entire inline stack.
If d.inlineSuffixOnly is true, fmtPos only considers the innermost (leaf) position on the inline stack.</p>
               
               <pre><code>func (d *HashDebug) fmtPos(ctxt *obj.Link, pos src.XPos) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="forEachGC" data-name="forEachGC">
               <h3>
                  forEachGC 
                  <span class="badge">function</span>
                  
                  <a href="#forEachGC" class="anchor" title="Link to forEachGC">#</a>
               </h3>
               
               <p>forEachGC calls fn each GC cycle until it returns false.</p>
               
               <pre><code>func forEachGC(fn func() bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashPos" data-name="hashPos">
               <h3>
                  hashPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hashPos" class="anchor" title="Link to hashPos">#</a>
               </h3>
               
               <p>hashPos returns a hash of the position pos, including its entire inline stack.
If d.inlineSuffixOnly is true, hashPos only considers the innermost (leaf) position on the inline stack.</p>
               
               <pre><code>func (d *HashDebug) hashPos(ctxt *obj.Link, pos src.XPos) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashString" data-name="hashString">
               <h3>
                  hashString 
                  <span class="badge">function</span>
                  
                  <a href="#hashString" class="anchor" title="Link to hashString">#</a>
               </h3>
               
               <p>TODO: Delete when we switch to bisect-only.</p>
               
               <pre><code>func hashString(hash uint64) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hcrash" data-name="hcrash">
               <h3>
                  hcrash 
                  <span class="badge">function</span>
                  
                  <a href="#hcrash" class="anchor" title="Link to hcrash">#</a>
               </h3>
               
               <p>hcrash crashes the compiler when -h is set, to find out where a message is generated.</p>
               
               <pre><code>func hcrash()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isnumber" data-name="isnumber">
               <h3>
                  isnumber 
                  <span class="badge">function</span>
                  
                  <a href="#isnumber" class="anchor" title="Link to isnumber">#</a>
               </h3>
               
               <pre><code>func isnumber(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linksym" data-name="linksym">
               <h3>
                  linksym 
                  <span class="badge">function</span>
                  
                  <a href="#linksym" class="anchor" title="Link to linksym">#</a>
               </h3>
               
               <p>linksym is an internal helper function for implementing the above
exported APIs.</p>
               
               <pre><code>func linksym(pkg string, name string, abi obj.ABI) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="log" data-name="log">
               <h3>
                  log 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#log" class="anchor" title="Link to log">#</a>
               </h3>
               
               <p>log prints a match with the given hash and textual formatting.
TODO: Delete varname parameter when we switch to bisect-only.</p>
               
               <pre><code>func (d *HashDebug) log(varname string, hash uint64, text string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <p>TODO: Delete when we switch to bisect-only.</p>
               
               <pre><code>func (d *HashDebug) match(hash uint64) *hashAndMask</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchAndLog" data-name="matchAndLog">
               <h3>
                  matchAndLog 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchAndLog" class="anchor" title="Link to matchAndLog">#</a>
               </h3>
               
               <p>matchAndLog is the core matcher. It reports whether the hash matches the pattern.
If a report needs to be printed, match prints that report to the log file.
The text func must be non-nil and should return a user-readable
representation of what was hashed. The note func may be nil; if non-nil,
it should return additional information to display to the user when this
change is selected.</p>
               
               <pre><code>func (d *HashDebug) matchAndLog(hash uint64, text func() string, note func() string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchPkgFunc" data-name="matchPkgFunc">
               <h3>
                  matchPkgFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchPkgFunc" class="anchor" title="Link to matchPkgFunc">#</a>
               </h3>
               
               <pre><code>func (d *HashDebug) matchPkgFunc(pkg string, fn string, note func() string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchPos" data-name="matchPos">
               <h3>
                  matchPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchPos" class="anchor" title="Link to matchPos">#</a>
               </h3>
               
               <pre><code>func (d *HashDebug) matchPos(ctxt *obj.Link, pos src.XPos, note func() string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchPosWithInfo" data-name="matchPosWithInfo">
               <h3>
                  matchPosWithInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchPosWithInfo" class="anchor" title="Link to matchPosWithInfo">#</a>
               </h3>
               
               <pre><code>func (d *HashDebug) matchPosWithInfo(ctxt *obj.Link, pos src.XPos, info any, note func() string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseSpectre" data-name="parseSpectre">
               <h3>
                  parseSpectre 
                  <span class="badge">function</span>
                  
                  <a href="#parseSpectre" class="anchor" title="Link to parseSpectre">#</a>
               </h3>
               
               <p>parseSpectre parses the spectre configuration from the string s.</p>
               
               <pre><code>func parseSpectre(s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readCoverageCfg" data-name="readCoverageCfg">
               <h3>
                  readCoverageCfg 
                  <span class="badge">function</span>
                  
                  <a href="#readCoverageCfg" class="anchor" title="Link to readCoverageCfg">#</a>
               </h3>
               
               <pre><code>func readCoverageCfg(file string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readEmbedCfg" data-name="readEmbedCfg">
               <h3>
                  readEmbedCfg 
                  <span class="badge">function</span>
                  
                  <a href="#readEmbedCfg" class="anchor" title="Link to readEmbedCfg">#</a>
               </h3>
               
               <pre><code>func readEmbedCfg(file string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readImportCfg" data-name="readImportCfg">
               <h3>
                  readImportCfg 
                  <span class="badge">function</span>
                  
                  <a href="#readImportCfg" class="anchor" title="Link to readImportCfg">#</a>
               </h3>
               
               <pre><code>func readImportCfg(file string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="registerFlags" data-name="registerFlags">
               <h3>
                  registerFlags 
                  <span class="badge">function</span>
                  
                  <a href="#registerFlags" class="anchor" title="Link to registerFlags">#</a>
               </h3>
               
               <p>registerFlags adds flag registrations for all the fields in Flag.
See the comment on type CmdFlags for the rules.</p>
               
               <pre><code>func registerFlags()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sameline" data-name="sameline">
               <h3>
                  sameline 
                  <span class="badge">function</span>
                  
                  <a href="#sameline" class="anchor" title="Link to sameline">#</a>
               </h3>
               
               <p>sameline reports whether two positions a, b are on the same line.</p>
               
               <pre><code>func sameline(a src.XPos, b src.XPos) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="short" data-name="short">
               <h3>
                  short 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#short" class="anchor" title="Link to short">#</a>
               </h3>
               
               <p>short returns the form of file name to use for d.
The default is the full path, but fileSuffixOnly selects
just the final path element.</p>
               
               <pre><code>func (d *HashDebug) short(name string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toHashAndMask" data-name="toHashAndMask">
               <h3>
                  toHashAndMask 
                  <span class="badge">function</span>
                  
                  <a href="#toHashAndMask" class="anchor" title="Link to toHashAndMask">#</a>
               </h3>
               
               <p>TODO: Delete when we switch to bisect-only.</p>
               
               <pre><code>func toHashAndMask(s string, varname string) hashAndMask</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="usage" data-name="usage">
               <h3>
                  usage 
                  <span class="badge">function</span>
                  
                  <a href="#usage" class="anchor" title="Link to usage">#</a>
               </h3>
               
               <pre><code>func usage()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="write" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#write" class="anchor" title="Link to write">#</a>
               </h3>
               
               <pre><code>func (lines lines) write(w io.Writer)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>