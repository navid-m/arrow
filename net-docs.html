<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - net</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="net_http-docs.html">http</a></li>
               
               <li><a href="net_mail-docs.html">mail</a></li>
               
               <li><a href="net_netip-docs.html">netip</a></li>
               
               <li><a href="net_rpc-docs.html">rpc</a></li>
               
               <li><a href="net_smtp-docs.html">smtp</a></li>
               
               <li><a href="net_textproto-docs.html">textproto</a></li>
               
               <li><a href="net_url-docs.html">url</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>net</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"internal/itoa"
"syscall"
"time"
"syscall"
"context"
"io"
"os"
"internal/syscall/unix"
"runtime"
"syscall"
"unsafe"
"syscall"
"golang.org/x/net/route"
"internal/poll"
"internal/syscall/unix"
"os"
"syscall"
"io"
"syscall"
"syscall"
"golang.org/x/net/route"
"errors"
"internal/itoa"
"internal/stringslite"
"os"
"context"
"errors"
"internal/nettrace"
"internal/singleflight"
"net/netip"
"sync"
"golang.org/x/net/dns/dnsmessage"
"os"
"syscall"
"syscall"
"time"
"C"
"C"
"errors"
"internal/bytealg"
"io/fs"
"net/netip"
"sync"
"time"
"syscall"
"golang.org/x/net/route"
"context"
"errors"
"internal/bytealg"
"internal/itoa"
"internal/stringslite"
"io"
"os"
"syscall"
"os"
"syscall"
"runtime"
"syscall"
"time"
"syscall"
"golang.org/x/net/route"
"C"
"syscall"
"unsafe"
"syscall"
"golang.org/x/net/lif"
"context"
"internal/bytealg"
"internal/itoa"
"io/fs"
"os"
"syscall"
"internal/syscall/unix"
"syscall"
"C"
"unsafe"
"context"
"internal/syscall/windows"
"os"
"runtime"
"syscall"
"time"
"unsafe"
"internal/poll"
"io"
"os"
"syscall"
"time"
"internal/syscall/windows"
"os"
"syscall"
"unsafe"
"os"
"syscall"
"context"
"internal/itoa"
"io"
"net/netip"
"os"
"syscall"
"time"
"os"
"syscall"
"runtime"
"syscall"
"C"
"syscall"
"unsafe"
"internal/syscall/unix"
"syscall"
"internal/syscall/unix"
"runtime"
"syscall"
"time"
"os"
"syscall"
"C"
"unsafe"
"errors"
"internal/bytealg"
"internal/godebug"
"internal/stringslite"
"io/fs"
"os"
"runtime"
"sync"
"internal/syscall/windows"
"syscall"
"time"
"internal/bytealg"
"io"
"os"
"time"
"internal/poll"
"io"
"os"
"syscall"
"internal/poll"
"io"
"internal/poll"
"os"
"syscall"
"context"
"os"
"sync"
"syscall"
"time"
"internal/bytealg"
"internal/stringslite"
"net/netip"
"time"
"internal/poll"
"internal/syscall/unix"
"syscall"
"unsafe"
"context"
"C"
"unsafe"
"context"
"internal/bytealg"
"sync"
"syscall"
"internal/syscall/windows"
"os"
"syscall"
"os"
"runtime"
"syscall"
"internal/bytealg"
"internal/itoa"
"internal/stringslite"
"net/netip"
"context"
"internal/syscall/windows"
"os"
"runtime"
"syscall"
"time"
"unsafe"
"os"
"runtime"
"syscall"
"context"
"net/netip"
"syscall"
"context"
"errors"
"internal/bytealg"
"internal/godebug"
"internal/itoa"
"internal/stringslite"
"io"
"os"
"runtime"
"sync"
"sync/atomic"
"time"
"golang.org/x/net/dns/dnsmessage"
"context"
"syscall"
"context"
"errors"
"io"
"os"
"sync"
"sync/atomic"
"syscall"
"time"
"internal/poll"
"runtime"
"syscall"
"internal/syscall/unix"
"context"
"internal/bytealg"
"internal/godebug"
"internal/nettrace"
"syscall"
"time"
"cmp"
"internal/bytealg"
"internal/itoa"
"slices"
_ "unsafe"
"golang.org/x/net/dns/dnsmessage"
"context"
"internal/bytealg"
"runtime"
"sync"
_ "unsafe"
"errors"
"internal/bytealg"
"os"
"sync"
"time"
"os"
"syscall"
"syscall"
"syscall"
"syscall"
"runtime"
"syscall"
"context"
"errors"
"os"
"syscall"
"context"
"errors"
"internal/itoa"
"sync"
"time"
_ "unsafe"
"runtime"
"syscall"
"syscall"
"runtime"
"syscall"
"context"
"internal/itoa"
"net/netip"
"syscall"
"os"
"sync/atomic"
"time"
_ "unsafe"
"internal/poll"
"os"
"syscall"
"io"
"syscall"
"context"
"internal/poll"
"os"
"runtime"
"syscall"
"os"
"syscall"
"syscall"
"time"
"syscall"
"C"
"internal/syscall/windows"
"syscall"
"runtime"
"syscall"
"time"
"runtime"
"syscall"
"C"
"errors"
"io"
"os"
"syscall"
"internal/poll"
"io"
"os"
"syscall"
"runtime"
"syscall"
"context"
"io"
"os"
"syscall"
"os"
"syscall"
"internal/syscall/windows"
"syscall"
"context"
"syscall"
"internal/poll"
"io"
"syscall"
"context"
"internal/poll"
"os"
"syscall"
"context"
"errors"
"internal/bytealg"
"net/netip"
"runtime"
"syscall"
"unsafe"
"golang.org/x/net/dns/dnsmessage"
"context"
"errors"
"internal/poll"
"io"
"os"
"sync"
"syscall"
"time"
_ "unsafe"
"context"
"os"
"syscall"
"context"
"internal/poll"
"internal/syscall/windows"
"os"
"runtime"
"syscall"
"unsafe"
"os"
"syscall"
"unsafe"
"context"
"internal/poll"
"net/netip"
"runtime"
"syscall"
_ "unsafe"
"internal/bytealg"
"runtime"
"syscall"
"os"
"syscall"
"C"
"os"
"io"
"os"
"sync"
"time"
"context"
"errors"
"net/netip"
"os"
"syscall"
"syscall"
"net/netip"
"slices"
"C"
"C"
"C"
"os"
"syscall"
_ "unsafe"
"context"
"errors"
"internal/poll"
"internal/syscall/unix"
"sync"
"syscall"
"C"
"unsafe"
"context"
"syscall"
"internal/bytealg"
"sync"
"internal/poll"
"runtime"
"time"
"internal/poll"
"runtime"
"syscall"
"time"
"syscall"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="DefaultResolver">
               <h3>
                  DefaultResolver 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>DefaultResolver is the resolver used by the package-level Lookup
functions and by Dialers without a specified Resolver.</p>
               
               <pre><code>var DefaultResolver = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrClosed">
               <h3>
                  ErrClosed 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrClosed is the error returned by an I/O call on a network
connection that has already been closed, or that is closed by
another goroutine before the I/O is completed. This may be wrapped
in another error, and should normally be tested using
errors.Is(err, net.ErrClosed).</p>
               
               <pre><code>var ErrClosed error = errClosed</code></pre>
            </article>
            
            <article class="global" data-name="ErrWriteToConnected">
               <h3>
                  ErrWriteToConnected 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Various errors contained in OpError.</p>
               
               <pre><code>var ErrWriteToConnected = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="FlagBroadcast">
               <h3>
                  FlagBroadcast 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FlagBroadcast</code></pre>
            </article>
            
            <article class="global" data-name="FlagLoopback">
               <h3>
                  FlagLoopback 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FlagLoopback</code></pre>
            </article>
            
            <article class="global" data-name="FlagMulticast">
               <h3>
                  FlagMulticast 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FlagMulticast</code></pre>
            </article>
            
            <article class="global" data-name="FlagPointToPoint">
               <h3>
                  FlagPointToPoint 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FlagPointToPoint</code></pre>
            </article>
            
            <article class="global" data-name="FlagRunning">
               <h3>
                  FlagRunning 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FlagRunning</code></pre>
            </article>
            
            <article class="global" data-name="FlagUp">
               <h3>
                  FlagUp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FlagUp Flags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="IPv4allrouter">
               <h3>
                  IPv4allrouter 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Well-known IPv4 addresses</p>
               
               <pre><code>var IPv4allrouter = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="IPv4allsys">
               <h3>
                  IPv4allsys 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Well-known IPv4 addresses</p>
               
               <pre><code>var IPv4allsys = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="IPv4bcast">
               <h3>
                  IPv4bcast 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Well-known IPv4 addresses</p>
               
               <pre><code>var IPv4bcast = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="IPv4len">
               <h3>
                  IPv4len 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>IP address lengths (bytes).</p>
               
               <pre><code>const IPv4len = 4</code></pre>
            </article>
            
            <article class="global" data-name="IPv4zero">
               <h3>
                  IPv4zero 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Well-known IPv4 addresses</p>
               
               <pre><code>var IPv4zero = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="IPv6interfacelocalallnodes">
               <h3>
                  IPv6interfacelocalallnodes 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Well-known IPv6 addresses</p>
               
               <pre><code>var IPv6interfacelocalallnodes = IP{...}</code></pre>
            </article>
            
            <article class="global" data-name="IPv6len">
               <h3>
                  IPv6len 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>IP address lengths (bytes).</p>
               
               <pre><code>const IPv6len = 16</code></pre>
            </article>
            
            <article class="global" data-name="IPv6linklocalallnodes">
               <h3>
                  IPv6linklocalallnodes 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Well-known IPv6 addresses</p>
               
               <pre><code>var IPv6linklocalallnodes = IP{...}</code></pre>
            </article>
            
            <article class="global" data-name="IPv6linklocalallrouters">
               <h3>
                  IPv6linklocalallrouters 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Well-known IPv6 addresses</p>
               
               <pre><code>var IPv6linklocalallrouters = IP{...}</code></pre>
            </article>
            
            <article class="global" data-name="IPv6loopback">
               <h3>
                  IPv6loopback 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Well-known IPv6 addresses</p>
               
               <pre><code>var IPv6loopback = IP{...}</code></pre>
            </article>
            
            <article class="global" data-name="IPv6unspecified">
               <h3>
                  IPv6unspecified 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Well-known IPv6 addresses</p>
               
               <pre><code>var IPv6unspecified = IP{...}</code></pre>
            </article>
            
            <article class="global" data-name="IPv6zero">
               <h3>
                  IPv6zero 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Well-known IPv6 addresses</p>
               
               <pre><code>var IPv6zero = IP{...}</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ context.Context = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ io.WriterTo = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ io.Reader = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_C_AF_INET">
               <h3>
                  _C_AF_INET 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_AF_INET = C.AF_INET</code></pre>
            </article>
            
            <article class="global" data-name="_C_AF_INET">
               <h3>
                  _C_AF_INET 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_AF_INET = syscall.AF_INET</code></pre>
            </article>
            
            <article class="global" data-name="_C_AF_INET6">
               <h3>
                  _C_AF_INET6 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_AF_INET6 = C.AF_INET6</code></pre>
            </article>
            
            <article class="global" data-name="_C_AF_INET6">
               <h3>
                  _C_AF_INET6 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_AF_INET6 = syscall.AF_INET6</code></pre>
            </article>
            
            <article class="global" data-name="_C_AF_UNSPEC">
               <h3>
                  _C_AF_UNSPEC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_AF_UNSPEC = syscall.AF_UNSPEC</code></pre>
            </article>
            
            <article class="global" data-name="_C_AF_UNSPEC">
               <h3>
                  _C_AF_UNSPEC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_AF_UNSPEC = C.AF_UNSPEC</code></pre>
            </article>
            
            <article class="global" data-name="_C_EAI_ADDRFAMILY">
               <h3>
                  _C_EAI_ADDRFAMILY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_EAI_ADDRFAMILY = unix.EAI_ADDRFAMILY</code></pre>
            </article>
            
            <article class="global" data-name="_C_EAI_ADDRFAMILY">
               <h3>
                  _C_EAI_ADDRFAMILY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_EAI_ADDRFAMILY = C.EAI_ADDRFAMILY</code></pre>
            </article>
            
            <article class="global" data-name="_C_EAI_AGAIN">
               <h3>
                  _C_EAI_AGAIN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_EAI_AGAIN = C.EAI_AGAIN</code></pre>
            </article>
            
            <article class="global" data-name="_C_EAI_AGAIN">
               <h3>
                  _C_EAI_AGAIN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_EAI_AGAIN = unix.EAI_AGAIN</code></pre>
            </article>
            
            <article class="global" data-name="_C_EAI_NODATA">
               <h3>
                  _C_EAI_NODATA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_EAI_NODATA = unix.EAI_NODATA</code></pre>
            </article>
            
            <article class="global" data-name="_C_EAI_NODATA">
               <h3>
                  _C_EAI_NODATA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_EAI_NODATA = C.EAI_NODATA</code></pre>
            </article>
            
            <article class="global" data-name="_C_EAI_NONAME">
               <h3>
                  _C_EAI_NONAME 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_EAI_NONAME = unix.EAI_NONAME</code></pre>
            </article>
            
            <article class="global" data-name="_C_EAI_NONAME">
               <h3>
                  _C_EAI_NONAME 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_EAI_NONAME = C.EAI_NONAME</code></pre>
            </article>
            
            <article class="global" data-name="_C_EAI_OVERFLOW">
               <h3>
                  _C_EAI_OVERFLOW 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_EAI_OVERFLOW = unix.EAI_OVERFLOW</code></pre>
            </article>
            
            <article class="global" data-name="_C_EAI_OVERFLOW">
               <h3>
                  _C_EAI_OVERFLOW 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_EAI_OVERFLOW = C.EAI_OVERFLOW</code></pre>
            </article>
            
            <article class="global" data-name="_C_EAI_SERVICE">
               <h3>
                  _C_EAI_SERVICE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_EAI_SERVICE = unix.EAI_SERVICE</code></pre>
            </article>
            
            <article class="global" data-name="_C_EAI_SERVICE">
               <h3>
                  _C_EAI_SERVICE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_EAI_SERVICE = C.EAI_SERVICE</code></pre>
            </article>
            
            <article class="global" data-name="_C_EAI_SYSTEM">
               <h3>
                  _C_EAI_SYSTEM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_EAI_SYSTEM = unix.EAI_SYSTEM</code></pre>
            </article>
            
            <article class="global" data-name="_C_EAI_SYSTEM">
               <h3>
                  _C_EAI_SYSTEM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_EAI_SYSTEM = C.EAI_SYSTEM</code></pre>
            </article>
            
            <article class="global" data-name="_C_IPPROTO_TCP">
               <h3>
                  _C_IPPROTO_TCP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_IPPROTO_TCP = syscall.IPPROTO_TCP</code></pre>
            </article>
            
            <article class="global" data-name="_C_IPPROTO_TCP">
               <h3>
                  _C_IPPROTO_TCP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_IPPROTO_TCP = C.IPPROTO_TCP</code></pre>
            </article>
            
            <article class="global" data-name="_C_IPPROTO_UDP">
               <h3>
                  _C_IPPROTO_UDP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_IPPROTO_UDP = syscall.IPPROTO_UDP</code></pre>
            </article>
            
            <article class="global" data-name="_C_IPPROTO_UDP">
               <h3>
                  _C_IPPROTO_UDP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_IPPROTO_UDP = C.IPPROTO_UDP</code></pre>
            </article>
            
            <article class="global" data-name="_C_SOCK_DGRAM">
               <h3>
                  _C_SOCK_DGRAM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_SOCK_DGRAM = C.SOCK_DGRAM</code></pre>
            </article>
            
            <article class="global" data-name="_C_SOCK_DGRAM">
               <h3>
                  _C_SOCK_DGRAM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_SOCK_DGRAM = syscall.SOCK_DGRAM</code></pre>
            </article>
            
            <article class="global" data-name="_C_SOCK_STREAM">
               <h3>
                  _C_SOCK_STREAM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_SOCK_STREAM = syscall.SOCK_STREAM</code></pre>
            </article>
            
            <article class="global" data-name="_C_SOCK_STREAM">
               <h3>
                  _C_SOCK_STREAM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _C_SOCK_STREAM = C.SOCK_STREAM</code></pre>
            </article>
            
            <article class="global" data-name="_DNS_ERROR_RCODE_NAME_ERROR">
               <h3>
                  _DNS_ERROR_RCODE_NAME_ERROR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _DNS_ERROR_RCODE_NAME_ERROR = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_DNS_INFO_NO_RECORDS">
               <h3>
                  _DNS_INFO_NO_RECORDS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _DNS_INFO_NO_RECORDS = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_IPPROTO_MPTCP">
               <h3>
                  _IPPROTO_MPTCP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants aren't in the syscall package, which is frozen</p>
               
               <pre><code>const _IPPROTO_MPTCP = 0x106</code></pre>
            </article>
            
            <article class="global" data-name="_KINFO_RT_IFLIST">
               <h3>
                  _KINFO_RT_IFLIST 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _KINFO_RT_IFLIST = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="_MPTCP_INFO">
               <h3>
                  _MPTCP_INFO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants aren't in the syscall package, which is frozen</p>
               
               <pre><code>const _MPTCP_INFO = 0x1</code></pre>
            </article>
            
            <article class="global" data-name="_RTAX_IFA">
               <h3>
                  _RTAX_IFA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _RTAX_IFA = 5</code></pre>
            </article>
            
            <article class="global" data-name="_RTAX_MAX">
               <h3>
                  _RTAX_MAX 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _RTAX_MAX = 8</code></pre>
            </article>
            
            <article class="global" data-name="_RTAX_NETMASK">
               <h3>
                  _RTAX_NETMASK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _RTAX_NETMASK = 2</code></pre>
            </article>
            
            <article class="global" data-name="_SOL_MPTCP">
               <h3>
                  _SOL_MPTCP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants aren't in the syscall package, which is frozen</p>
               
               <pre><code>const _SOL_MPTCP = 0x11c</code></pre>
            </article>
            
            <article class="global" data-name="_WSAHOST_NOT_FOUND">
               <h3>
                  _WSAHOST_NOT_FOUND 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _WSAHOST_NOT_FOUND = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_WSATRY_AGAIN">
               <h3>
                  _WSATRY_AGAIN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _WSATRY_AGAIN = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_WSATYPE_NOT_FOUND">
               <h3>
                  _WSATYPE_NOT_FOUND 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _WSATYPE_NOT_FOUND = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="aLongTimeAgo">
               <h3>
                  aLongTimeAgo 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>aLongTimeAgo is a non-zero time, far in the past, used for
immediate cancellation of dials.</p>
               
               <pre><code>var aLongTimeAgo = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="big">
               <h3>
                  big 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Bigger than we need, not too big to worry about overflow</p>
               
               <pre><code>const big = 0xFFFFFF</code></pre>
            </article>
            
            <article class="global" data-name="cacheMaxAge">
               <h3>
                  cacheMaxAge 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const cacheMaxAge = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="cgoAddrInfoFlags">
               <h3>
                  cgoAddrInfoFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>NOTE(rsc): In theory there are approximately balanced
arguments for and against including AI_ADDRCONFIG
in the flags (it includes IPv4 results only on IPv4 systems,
and similarly for IPv6), but in practice setting it causes
getaddrinfo to return the wrong canonical name on Linux.
So definitely leave it out.</p>
               
               <pre><code>const cgoAddrInfoFlags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="cgoAddrInfoFlags">
               <h3>
                  cgoAddrInfoFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const cgoAddrInfoFlags = C.AI_CANONNAME</code></pre>
            </article>
            
            <article class="global" data-name="cgoAddrInfoFlags">
               <h3>
                  cgoAddrInfoFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const cgoAddrInfoFlags = C.AI_CANONNAME</code></pre>
            </article>
            
            <article class="global" data-name="cgoAddrInfoFlags">
               <h3>
                  cgoAddrInfoFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const cgoAddrInfoFlags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="cgoAddrInfoFlags">
               <h3>
                  cgoAddrInfoFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const cgoAddrInfoFlags = C.AI_CANONNAME</code></pre>
            </article>
            
            <article class="global" data-name="cgoAddrInfoFlags">
               <h3>
                  cgoAddrInfoFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const cgoAddrInfoFlags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="cgoAddrInfoFlags">
               <h3>
                  cgoAddrInfoFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const cgoAddrInfoFlags = C.AI_CANONNAME</code></pre>
            </article>
            
            <article class="global" data-name="cgoAddrInfoFlags">
               <h3>
                  cgoAddrInfoFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const cgoAddrInfoFlags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="cgoAvailable">
               <h3>
                  cgoAvailable 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>cgoAvailable set to true to indicate that the cgo resolver
is available on Windows. Note that on Windows the cgo resolver
does not actually use cgo.</p>
               
               <pre><code>const cgoAvailable = true</code></pre>
            </article>
            
            <article class="global" data-name="cgoAvailable">
               <h3>
                  cgoAvailable 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>cgoAvailable set to true to indicate that the cgo resolver
is available on Plan 9. Note that on Plan 9 the cgo resolver
does not actually use cgo.</p>
               
               <pre><code>const cgoAvailable = true</code></pre>
            </article>
            
            <article class="global" data-name="cgoAvailable">
               <h3>
                  cgoAvailable 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>cgoAvailable set to false to indicate that the cgo resolver
is not available on this system.</p>
               
               <pre><code>const cgoAvailable = false</code></pre>
            </article>
            
            <article class="global" data-name="cgoAvailable">
               <h3>
                  cgoAvailable 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>cgoAvailable set to true to indicate that the cgo resolver
is available on this system.</p>
               
               <pre><code>const cgoAvailable = true</code></pre>
            </article>
            
            <article class="global" data-name="classAMask">
               <h3>
                  classAMask 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Default route masks for IPv4.</p>
               
               <pre><code>var classAMask = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="classBMask">
               <h3>
                  classBMask 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Default route masks for IPv4.</p>
               
               <pre><code>var classBMask = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="classCMask">
               <h3>
                  classCMask 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Default route masks for IPv4.</p>
               
               <pre><code>var classCMask = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="confOnce">
               <h3>
                  confOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var confOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="confVal">
               <h3>
                  confVal 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var confVal = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="connectFunc">
               <h3>
                  connectFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var connectFunc func(syscall.Handle, syscall.Sockaddr) error = syscall.Connect</code></pre>
            </article>
            
            <article class="global" data-name="connectFunc">
               <h3>
                  connectFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var connectFunc func(int, syscall.Sockaddr) error = syscall.Connect</code></pre>
            </article>
            
            <article class="global" data-name="defaultBuffer">
               <h3>
                  defaultBuffer 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const defaultBuffer = 65535</code></pre>
            </article>
            
            <article class="global" data-name="defaultKeepAliveIdle">
               <h3>
                  defaultKeepAliveIdle 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Default values of KeepAliveTime and KeepAliveInterval on Windows,
check out https://learn.microsoft.com/en-us/windows/win32/winsock/sio-keepalive-vals#remarks for details.</p>
               
               <pre><code>const defaultKeepAliveIdle = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="defaultKeepAliveInterval">
               <h3>
                  defaultKeepAliveInterval 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Default values of KeepAliveTime and KeepAliveInterval on Windows,
check out https://learn.microsoft.com/en-us/windows/win32/winsock/sio-keepalive-vals#remarks for details.</p>
               
               <pre><code>const defaultKeepAliveInterval = time.Second</code></pre>
            </article>
            
            <article class="global" data-name="defaultMPTCPEnabledDial">
               <h3>
                  defaultMPTCPEnabledDial 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const defaultMPTCPEnabledDial = false</code></pre>
            </article>
            
            <article class="global" data-name="defaultMPTCPEnabledListen">
               <h3>
                  defaultMPTCPEnabledListen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For the moment, MultiPath TCP is used by default with listeners, if
available, but not with dialers.
See go.dev/issue/56539</p>
               
               <pre><code>const defaultMPTCPEnabledListen = true</code></pre>
            </article>
            
            <article class="global" data-name="defaultNS">
               <h3>
                  defaultNS 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>defaultNS is the default name servers to use in the absence of DNS configuration.
defaultNS should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/pojntfx/hydrapp/hydrapp
- github.com/mtibben/androiddnsfix
- github.com/metacubex/mihomo
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname defaultNS</p>
               
               <pre><code>var defaultNS = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="defaultTCPKeepAliveCount">
               <h3>
                  defaultTCPKeepAliveCount 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>defaultTCPKeepAliveCount is a default constant value for TCP_KEEPCNT.</p>
               
               <pre><code>const defaultTCPKeepAliveCount = 9</code></pre>
            </article>
            
            <article class="global" data-name="defaultTCPKeepAliveIdle">
               <h3>
                  defaultTCPKeepAliveIdle 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>defaultTCPKeepAliveIdle is a default constant value for TCP_KEEPIDLE.
See go.dev/issue/31510 for details.</p>
               
               <pre><code>const defaultTCPKeepAliveIdle = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="defaultTCPKeepAliveInterval">
               <h3>
                  defaultTCPKeepAliveInterval 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>defaultTCPKeepAliveInterval is a default constant value for TCP_KEEPINTVL.
It is the same as defaultTCPKeepAliveIdle, see go.dev/issue/31510 for details.</p>
               
               <pre><code>const defaultTCPKeepAliveInterval = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="dnsSectionMask">
               <h3>
                  dnsSectionMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const dnsSectionMask = 0x0003</code></pre>
            </article>
            
            <article class="global" data-name="dnsWaitGroup">
               <h3>
                  dnsWaitGroup 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>dnsWaitGroup can be used by tests to wait for all DNS goroutines to
complete. This avoids races on the test hooks.</p>
               
               <pre><code>var dnsWaitGroup sync.WaitGroup</code></pre>
            </article>
            
            <article class="global" data-name="errCanceled">
               <h3>
                  errCanceled 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>For both read and write operations.</p>
               
               <pre><code>var errCanceled = canceledError{...}</code></pre>
            </article>
            
            <article class="global" data-name="errCannotMarshalDNSMessage">
               <h3>
                  errCannotMarshalDNSMessage 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errCannotMarshalDNSMessage = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errCannotUnmarshalDNSMessage">
               <h3>
                  errCannotUnmarshalDNSMessage 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errCannotUnmarshalDNSMessage = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errClosed">
               <h3>
                  errClosed 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>errClosed exists just so that the docs for ErrClosed don't mention
the internal package poll.</p>
               
               <pre><code>var errClosed = poll.ErrNetClosing</code></pre>
            </article>
            
            <article class="global" data-name="errInvalidDNSResponse">
               <h3>
                  errInvalidDNSResponse 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errInvalidDNSResponse = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errInvalidInterface">
               <h3>
                  errInvalidInterface 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errInvalidInterface = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errInvalidInterfaceIndex">
               <h3>
                  errInvalidInterfaceIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errInvalidInterfaceIndex = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errInvalidInterfaceName">
               <h3>
                  errInvalidInterfaceName 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errInvalidInterfaceName = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errLameReferral">
               <h3>
                  errLameReferral 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errLameReferral = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errMalformedDNSRecordsDetail">
               <h3>
                  errMalformedDNSRecordsDetail 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>errMalformedDNSRecordsDetail is the DNSError detail which is returned when a Resolver.Lookup...
method receives DNS records which contain invalid DNS names. This may be returned alongside
results which have had the malformed records filtered out.</p>
               
               <pre><code>var errMalformedDNSRecordsDetail = "DNS response contained records which contain invalid names"</code></pre>
            </article>
            
            <article class="global" data-name="errMissingAddress">
               <h3>
                  errMissingAddress 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>For connection setup and write operations.</p>
               
               <pre><code>var errMissingAddress = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errNoAnswerFromDNSServer">
               <h3>
                  errNoAnswerFromDNSServer 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errNoAnswerFromDNSServer = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errNoSuchHost">
               <h3>
                  errNoSuchHost 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Various errors contained in DNSError.</p>
               
               <pre><code>var errNoSuchHost = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="errNoSuchInterface">
               <h3>
                  errNoSuchInterface 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errNoSuchInterface = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errNoSuchMulticastInterface">
               <h3>
                  errNoSuchMulticastInterface 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errNoSuchMulticastInterface = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errNoSuitableAddress">
               <h3>
                  errNoSuitableAddress 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>For connection setup operations.</p>
               
               <pre><code>var errNoSuitableAddress = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errServerMisbehaving">
               <h3>
                  errServerMisbehaving 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errServerMisbehaving = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errServerTemporarilyMisbehaving">
               <h3>
                  errServerTemporarilyMisbehaving 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>errServerTemporarilyMisbehaving is like errServerMisbehaving, except
that when it gets translated to a DNSError, the IsTemporary field
gets set to true.</p>
               
               <pre><code>var errServerTemporarilyMisbehaving = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="errTimeout">
               <h3>
                  errTimeout 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>errTimeout exists to return the historical "i/o timeout" string
for context.DeadlineExceeded. See mapErr.
It is also used when Dialer.Deadline is exceeded.
error.Is(errTimeout, context.DeadlineExceeded) returns true.
TODO(iant): We could consider changing this to os.ErrDeadlineExceeded
in the future, if we make
errors.Is(os.ErrDeadlineExceeded, context.DeadlineExceeded)
return true.</p>
               
               <pre><code>var errTimeout error = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="errUnknownPort">
               <h3>
                  errUnknownPort 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Various errors contained in DNSError.</p>
               
               <pre><code>var errUnknownPort = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="fakePorts">
               <h3>
                  fakePorts 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var fakePorts sync.Map</code></pre>
            </article>
            
            <article class="global" data-name="flagNames">
               <h3>
                  flagNames 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var flagNames = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="getHostname">
               <h3>
                  getHostname 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var getHostname = os.Hostname</code></pre>
            </article>
            
            <article class="global" data-name="getsockoptIntFunc">
               <h3>
                  getsockoptIntFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var getsockoptIntFunc func(int, int, int) (int, error) = syscall.GetsockoptInt</code></pre>
            </article>
            
            <article class="global" data-name="hasSOLMPTCP">
               <h3>
                  hasSOLMPTCP 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var hasSOLMPTCP bool</code></pre>
            </article>
            
            <article class="global" data-name="hexDigit">
               <h3>
                  hexDigit 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hexDigit = "0123456789abcdef"</code></pre>
            </article>
            
            <article class="global" data-name="hostLookupCgo">
               <h3>
                  hostLookupCgo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>hostLookupCgo means defer to cgo.</p>
               
               <pre><code>const hostLookupCgo hostLookupOrder = iota</code></pre>
            </article>
            
            <article class="global" data-name="hostLookupDNS">
               <h3>
                  hostLookupDNS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hostLookupDNS</code></pre>
            </article>
            
            <article class="global" data-name="hostLookupDNSFiles">
               <h3>
                  hostLookupDNSFiles 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hostLookupDNSFiles</code></pre>
            </article>
            
            <article class="global" data-name="hostLookupFiles">
               <h3>
                  hostLookupFiles 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hostLookupFiles</code></pre>
            </article>
            
            <article class="global" data-name="hostLookupFilesDNS">
               <h3>
                  hostLookupFilesDNS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hostLookupFilesDNS</code></pre>
            </article>
            
            <article class="global" data-name="hosts">
               <h3>
                  hosts 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>hosts contains known host entries.</p>
               
               <pre><code>var hosts struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="hostsFilePath">
               <h3>
                  hostsFilePath 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var hostsFilePath = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="hostsFilePath">
               <h3>
                  hostsFilePath 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var hostsFilePath = "/etc/hosts"</code></pre>
            </article>
            
            <article class="global" data-name="hostsFilePath">
               <h3>
                  hostsFilePath 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var hostsFilePath = "/etc/hosts"</code></pre>
            </article>
            
            <article class="global" data-name="ipStackCaps">
               <h3>
                  ipStackCaps 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ipStackCaps ipStackCapabilities</code></pre>
            </article>
            
            <article class="global" data-name="listenFunc">
               <h3>
                  listenFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var listenFunc func(syscall.Handle, int) error = syscall.Listen</code></pre>
            </article>
            
            <article class="global" data-name="listenFunc">
               <h3>
                  listenFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var listenFunc func(int, int) error = syscall.Listen</code></pre>
            </article>
            
            <article class="global" data-name="listenerBacklogCache">
               <h3>
                  listenerBacklogCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var listenerBacklogCache struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="lookupOrderName">
               <h3>
                  lookupOrderName 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var lookupOrderName = map[hostLookupOrder]string{...}</code></pre>
            </article>
            
            <article class="global" data-name="maxDNSPacketSize">
               <h3>
                  maxDNSPacketSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Maximum DNS packet size.
Value taken from https://dnsflagday.net/2020/.</p>
               
               <pre><code>const maxDNSPacketSize = 1232</code></pre>
            </article>
            
            <article class="global" data-name="maxNameinfoLen">
               <h3>
                  maxNameinfoLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are roughly enough for the following:
Source		Encoding			Maximum length of single name entry
Unicast DNS		ASCII or			<=253 + a NUL terminator
Unicode in RFC 5892		252 * total number of labels + delimiters + a NUL terminator
Multicast DNS	UTF-8 in RFC 5198 or		<=253 + a NUL terminator
the same as unicast DNS ASCII	<=253 + a NUL terminator
Local database	various				depends on implementation</p>
               
               <pre><code>const maxNameinfoLen = 4096</code></pre>
            </article>
            
            <article class="global" data-name="maxPacketSize">
               <h3>
                  maxPacketSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxPacketSize = 65535</code></pre>
            </article>
            
            <article class="global" data-name="maxPortBufSize">
               <h3>
                  maxPortBufSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>maxPortBufSize is the longest reasonable name of a service
(non-numeric port).
Currently the longest known IANA-unregistered name is
"mobility-header", so we use that length, plus some slop in case
something longer is added in the future.</p>
               
               <pre><code>const maxPortBufSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxProtoLength">
               <h3>
                  maxProtoLength 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxProtoLength = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="mdnsAssumeDoesNotExist">
               <h3>
                  mdnsAssumeDoesNotExist 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const mdnsAssumeDoesNotExist</code></pre>
            </article>
            
            <article class="global" data-name="mdnsAssumeExists">
               <h3>
                  mdnsAssumeExists 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const mdnsAssumeExists</code></pre>
            </article>
            
            <article class="global" data-name="mdnsFromSystem">
               <h3>
                  mdnsFromSystem 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const mdnsFromSystem mdnsTest = iota</code></pre>
            </article>
            
            <article class="global" data-name="mptcpAvailable">
               <h3>
                  mptcpAvailable 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var mptcpAvailable bool</code></pre>
            </article>
            
            <article class="global" data-name="mptcpDisabledDial">
               <h3>
                  mptcpDisabledDial 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const mptcpDisabledDial</code></pre>
            </article>
            
            <article class="global" data-name="mptcpDisabledListen">
               <h3>
                  mptcpDisabledListen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const mptcpDisabledListen</code></pre>
            </article>
            
            <article class="global" data-name="mptcpEnabledDial">
               <h3>
                  mptcpEnabledDial 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const mptcpEnabledDial</code></pre>
            </article>
            
            <article class="global" data-name="mptcpEnabledListen">
               <h3>
                  mptcpEnabledListen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const mptcpEnabledListen</code></pre>
            </article>
            
            <article class="global" data-name="mptcpOnce">
               <h3>
                  mptcpOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var mptcpOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="mptcpUseDefaultDial">
               <h3>
                  mptcpUseDefaultDial 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The value 0 is the system default, linked to defaultMPTCPEnabledDial</p>
               
               <pre><code>const mptcpUseDefaultDial mptcpStatusDial = iota</code></pre>
            </article>
            
            <article class="global" data-name="mptcpUseDefaultListen">
               <h3>
                  mptcpUseDefaultListen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The value 0 is the system default, linked to defaultMPTCPEnabledListen</p>
               
               <pre><code>const mptcpUseDefaultListen mptcpStatusListen = iota</code></pre>
            </article>
            
            <article class="global" data-name="multipathtcp">
               <h3>
                  multipathtcp 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>The type of service offered
0 == MPTCP disabled
1 == MPTCP enabled
2 == MPTCP enabled on listeners only
3 == MPTCP enabled on dialers only</p>
               
               <pre><code>var multipathtcp = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="nameinfoLen">
               <h3>
                  nameinfoLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are roughly enough for the following:
Source		Encoding			Maximum length of single name entry
Unicast DNS		ASCII or			<=253 + a NUL terminator
Unicode in RFC 5892		252 * total number of labels + delimiters + a NUL terminator
Multicast DNS	UTF-8 in RFC 5198 or		<=253 + a NUL terminator
the same as unicast DNS ASCII	<=253 + a NUL terminator
Local database	various				depends on implementation</p>
               
               <pre><code>const nameinfoLen = 64</code></pre>
            </article>
            
            <article class="global" data-name="netCgoBuildTag">
               <h3>
                  netCgoBuildTag 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const netCgoBuildTag = false</code></pre>
            </article>
            
            <article class="global" data-name="netCgoBuildTag">
               <h3>
                  netCgoBuildTag 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const netCgoBuildTag = true</code></pre>
            </article>
            
            <article class="global" data-name="netGoBuildTag">
               <h3>
                  netGoBuildTag 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const netGoBuildTag = true</code></pre>
            </article>
            
            <article class="global" data-name="netGoBuildTag">
               <h3>
                  netGoBuildTag 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const netGoBuildTag = false</code></pre>
            </article>
            
            <article class="global" data-name="netdir">
               <h3>
                  netdir 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var netdir = "/net"</code></pre>
            </article>
            
            <article class="global" data-name="netdns">
               <h3>
                  netdns 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var netdns = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="netedns0">
               <h3>
                  netedns0 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>netedns0 controls whether we send an EDNS0 additional header.</p>
               
               <pre><code>var netedns0 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="nextPortCounter">
               <h3>
                  nextPortCounter 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nextPortCounter atomic.Int32</code></pre>
            </article>
            
            <article class="global" data-name="noCancel">
               <h3>
                  noCancel 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var noCancel = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="noDeadline">
               <h3>
                  noDeadline 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>noDeadline and noCancel are just zero values for
readability with functions taking too many parameters.</p>
               
               <pre><code>var noDeadline = time.Time{...}</code></pre>
            </article>
            
            <article class="global" data-name="nssConfig">
               <h3>
                  nssConfig 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nssConfig nsswitchConfig</code></pre>
            </article>
            
            <article class="global" data-name="nssConfigPath">
               <h3>
                  nssConfigPath 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nssConfigPath = "/etc/nsswitch.conf"</code></pre>
            </article>
            
            <article class="global" data-name="onceReadProtocols">
               <h3>
                  onceReadProtocols 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var onceReadProtocols sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="onceReadServices">
               <h3>
                  onceReadServices 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var onceReadServices sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="packetPool">
               <h3>
                  packetPool 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var packetPool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global" data-name="pollSplice">
               <h3>
                  pollSplice 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var pollSplice = poll.Splice</code></pre>
            </article>
            
            <article class="global" data-name="protocols">
               <h3>
                  protocols 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>protocols contains minimal mappings between internet protocol
names and numbers for platforms that don't have a complete list of
protocol numbers.
See https://www.iana.org/assignments/protocol-numbers
On Unix, this map is augmented by readProtocols via lookupProtocol.</p>
               
               <pre><code>var protocols = map[string]int{...}</code></pre>
            </article>
            
            <article class="global" data-name="readFromSyscallName">
               <h3>
                  readFromSyscallName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const readFromSyscallName = "recvfrom"</code></pre>
            </article>
            
            <article class="global" data-name="readFromSyscallName">
               <h3>
                  readFromSyscallName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const readFromSyscallName = "wsarecvfrom"</code></pre>
            </article>
            
            <article class="global" data-name="readMsgFlags">
               <h3>
                  readMsgFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const readMsgFlags = 0</code></pre>
            </article>
            
            <article class="global" data-name="readMsgFlags">
               <h3>
                  readMsgFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const readMsgFlags = syscall.MSG_CMSG_CLOEXEC</code></pre>
            </article>
            
            <article class="global" data-name="readMsgFlags">
               <h3>
                  readMsgFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const readMsgFlags = 0</code></pre>
            </article>
            
            <article class="global" data-name="readMsgSyscallName">
               <h3>
                  readMsgSyscallName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const readMsgSyscallName = "recvmsg"</code></pre>
            </article>
            
            <article class="global" data-name="readMsgSyscallName">
               <h3>
                  readMsgSyscallName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const readMsgSyscallName = "wsarecvmsg"</code></pre>
            </article>
            
            <article class="global" data-name="readSyscallName">
               <h3>
                  readSyscallName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const readSyscallName = "fd_read"</code></pre>
            </article>
            
            <article class="global" data-name="readSyscallName">
               <h3>
                  readSyscallName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const readSyscallName = "read"</code></pre>
            </article>
            
            <article class="global" data-name="readSyscallName">
               <h3>
                  readSyscallName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const readSyscallName = "wsarecv"</code></pre>
            </article>
            
            <article class="global" data-name="resolvConf">
               <h3>
                  resolvConf 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var resolvConf resolverConfig</code></pre>
            </article>
            
            <article class="global" data-name="rfc6724policyTable">
               <h3>
                  rfc6724policyTable 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>RFC 6724 section 2.1.
Items are sorted by the size of their Prefix.Mask.Size,</p>
               
               <pre><code>var rfc6724policyTable = policyTable{...}</code></pre>
            </article>
            
            <article class="global" data-name="scopeAdminLocal">
               <h3>
                  scopeAdminLocal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const scopeAdminLocal scope = 0x4</code></pre>
            </article>
            
            <article class="global" data-name="scopeGlobal">
               <h3>
                  scopeGlobal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const scopeGlobal scope = 0xe</code></pre>
            </article>
            
            <article class="global" data-name="scopeInterfaceLocal">
               <h3>
                  scopeInterfaceLocal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const scopeInterfaceLocal scope = 0x1</code></pre>
            </article>
            
            <article class="global" data-name="scopeLinkLocal">
               <h3>
                  scopeLinkLocal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const scopeLinkLocal scope = 0x2</code></pre>
            </article>
            
            <article class="global" data-name="scopeOrgLocal">
               <h3>
                  scopeOrgLocal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const scopeOrgLocal scope = 0x8</code></pre>
            </article>
            
            <article class="global" data-name="scopeSiteLocal">
               <h3>
                  scopeSiteLocal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const scopeSiteLocal scope = 0x5</code></pre>
            </article>
            
            <article class="global" data-name="services">
               <h3>
                  services 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>services contains minimal mappings between services names and port
numbers for platforms that don't have a complete list of port numbers.
See https://www.iana.org/assignments/service-names-port-numbers
On Unix, this map is augmented by readServices via goLookupPort.</p>
               
               <pre><code>var services = map[string]map[string]int{...}</code></pre>
            </article>
            
            <article class="global" data-name="socketFunc">
               <h3>
                  socketFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Placeholders for socket system calls.</p>
               
               <pre><code>var socketFunc func(int, int, int) (int, error) = syscall.Socket</code></pre>
            </article>
            
            <article class="global" data-name="sockets">
               <h3>
                  sockets 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var sockets sync.Map</code></pre>
            </article>
            
            <article class="global" data-name="supportsSendfile">
               <h3>
                  supportsSendfile 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const supportsSendfile = true</code></pre>
            </article>
            
            <article class="global" data-name="supportsSendfile">
               <h3>
                  supportsSendfile 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const supportsSendfile = false</code></pre>
            </article>
            
            <article class="global" data-name="supportsSendfile">
               <h3>
                  supportsSendfile 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const supportsSendfile = true</code></pre>
            </article>
            
            <article class="global" data-name="supportsSendfile">
               <h3>
                  supportsSendfile 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const supportsSendfile = true</code></pre>
            </article>
            
            <article class="global" data-name="sysARPHardwareGREIPv4">
               <h3>
                  sysARPHardwareGREIPv4 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sysARPHardwareGREIPv4 = 778</code></pre>
            </article>
            
            <article class="global" data-name="sysARPHardwareGREIPv6">
               <h3>
                  sysARPHardwareGREIPv6 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sysARPHardwareGREIPv6 = 823</code></pre>
            </article>
            
            <article class="global" data-name="sysARPHardwareIPv4IPv4">
               <h3>
                  sysARPHardwareIPv4IPv4 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>See linux/if_arp.h.
Note that Linux doesn't support IPv4 over IPv6 tunneling.</p>
               
               <pre><code>const sysARPHardwareIPv4IPv4 = 768</code></pre>
            </article>
            
            <article class="global" data-name="sysARPHardwareIPv6IPv4">
               <h3>
                  sysARPHardwareIPv6IPv4 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sysARPHardwareIPv6IPv4 = 776</code></pre>
            </article>
            
            <article class="global" data-name="sysARPHardwareIPv6IPv6">
               <h3>
                  sysARPHardwareIPv6IPv6 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sysARPHardwareIPv6IPv6 = 769</code></pre>
            </article>
            
            <article class="global" data-name="sysTCP_KEEPCNT">
               <h3>
                  sysTCP_KEEPCNT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Some macros of TCP Keep-Alive options on Solaris 11.4 may
differ from those on OpenSolaris-based derivatives.</p>
               
               <pre><code>const sysTCP_KEEPCNT = 0x1F</code></pre>
            </article>
            
            <article class="global" data-name="sysTCP_KEEPCNT">
               <h3>
                  sysTCP_KEEPCNT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>syscall.TCP_KEEPINTVL and syscall.TCP_KEEPCNT might be missing on some darwin architectures.</p>
               
               <pre><code>const sysTCP_KEEPCNT = 0x102</code></pre>
            </article>
            
            <article class="global" data-name="sysTCP_KEEPIDLE">
               <h3>
                  sysTCP_KEEPIDLE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Some macros of TCP Keep-Alive options on Solaris 11.4 may
differ from those on OpenSolaris-based derivatives.</p>
               
               <pre><code>const sysTCP_KEEPIDLE = 0x1D</code></pre>
            </article>
            
            <article class="global" data-name="sysTCP_KEEPINTVL">
               <h3>
                  sysTCP_KEEPINTVL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>syscall.TCP_KEEPINTVL and syscall.TCP_KEEPCNT might be missing on some darwin architectures.</p>
               
               <pre><code>const sysTCP_KEEPINTVL = 0x101</code></pre>
            </article>
            
            <article class="global" data-name="sysTCP_KEEPINTVL">
               <h3>
                  sysTCP_KEEPINTVL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Some macros of TCP Keep-Alive options on Solaris 11.4 may
differ from those on OpenSolaris-based derivatives.</p>
               
               <pre><code>const sysTCP_KEEPINTVL = 0x1E</code></pre>
            </article>
            
            <article class="global" data-name="testHookCanceledDial">
               <h3>
                  testHookCanceledDial 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var testHookCanceledDial = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global" data-name="testHookDialTCP">
               <h3>
                  testHookDialTCP 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>if non-nil, overrides dialTCP.</p>
               
               <pre><code>var testHookDialTCP func(ctx context.Context, net string, laddr *TCPAddr, raddr *TCPAddr) (*TCPConn, error)</code></pre>
            </article>
            
            <article class="global" data-name="testHookLookupIP">
               <h3>
                  testHookLookupIP 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var testHookLookupIP = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global" data-name="testHookSetKeepAlive">
               <h3>
                  testHookSetKeepAlive 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var testHookSetKeepAlive = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global" data-name="testHookStepTime">
               <h3>
                  testHookStepTime 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>testHookStepTime sleeps until time has moved forward by a nonzero amount.
This helps to avoid flakes in timeout tests by ensuring that an implausibly
short deadline (such as 1ns in the future) is always expired by the time
a relevant system call occurs.</p>
               
               <pre><code>var testHookStepTime = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global" data-name="testPreHookSetKeepAlive">
               <h3>
                  testPreHookSetKeepAlive 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var testPreHookSetKeepAlive = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global" data-name="threadLimit">
               <h3>
                  threadLimit 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var threadLimit chan struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="threadOnce">
               <h3>
                  threadOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var threadOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="udpHeaderSize">
               <h3>
                  udpHeaderSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const udpHeaderSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="useTCPOnly">
               <h3>
                  useTCPOnly 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>to be used as a useTCP parameter to exchange</p>
               
               <pre><code>const useTCPOnly = true</code></pre>
            </article>
            
            <article class="global" data-name="useUDPOrTCP">
               <h3>
                  useUDPOrTCP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const useUDPOrTCP = false</code></pre>
            </article>
            
            <article class="global" data-name="v4InV6Prefix">
               <h3>
                  v4InV6Prefix 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var v4InV6Prefix = []byte{...}</code></pre>
            </article>
            
            <article class="global" data-name="writeMsgSyscallName">
               <h3>
                  writeMsgSyscallName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const writeMsgSyscallName = "wsasendmsg"</code></pre>
            </article>
            
            <article class="global" data-name="writeMsgSyscallName">
               <h3>
                  writeMsgSyscallName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const writeMsgSyscallName = "sendmsg"</code></pre>
            </article>
            
            <article class="global" data-name="writeSyscallName">
               <h3>
                  writeSyscallName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const writeSyscallName = "wsasend"</code></pre>
            </article>
            
            <article class="global" data-name="writeSyscallName">
               <h3>
                  writeSyscallName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const writeSyscallName = "write"</code></pre>
            </article>
            
            <article class="global" data-name="writeSyscallName">
               <h3>
                  writeSyscallName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const writeSyscallName = "fd_write"</code></pre>
            </article>
            
            <article class="global" data-name="writeToSyscallName">
               <h3>
                  writeToSyscallName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const writeToSyscallName = "sendto"</code></pre>
            </article>
            
            <article class="global" data-name="writeToSyscallName">
               <h3>
                  writeToSyscallName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const writeToSyscallName = "wsasendto"</code></pre>
            </article>
            
            <article class="global" data-name="wsaSocketFunc">
               <h3>
                  wsaSocketFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Placeholders for socket system calls.</p>
               
               <pre><code>var wsaSocketFunc func(int32, int32, int32, *syscall.WSAProtocolInfo, uint32, uint32) (syscall.Handle, error) = windows.WSASocket</code></pre>
            </article>
            
            <article class="global" data-name="zoneCache">
               <h3>
                  zoneCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var zoneCache = ipv6ZoneCache{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="Buffers">
               <h3>
                  Buffers
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Buffers contains zero or more runs of bytes to write.
On certain machines, for certain types of connections, this is
optimized into an OS-specific batch write operation (such as
"writev").</p>
               
               <pre><code>type Buffers [][]byte</code></pre>
            </article>
            
            <article class="type" data-name="Flags">
               <h3>
                  Flags
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type Flags uint</code></pre>
            </article>
            
            <article class="type" data-name="HardwareAddr">
               <h3>
                  HardwareAddr
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A HardwareAddr represents a physical hardware address.</p>
               
               <pre><code>type HardwareAddr []byte</code></pre>
            </article>
            
            <article class="type" data-name="IP">
               <h3>
                  IP
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An IP is a single IP address, a slice of bytes.
Functions in this package accept either 4-byte (IPv4)
or 16-byte (IPv6) slices as input.
Note that in this documentation, referring to an
IP address as an IPv4 address or an IPv6 address
is a semantic property of the address, not just the
length of the byte slice: a 16-byte slice can still
be an IPv4 address.</p>
               
               <pre><code>type IP []byte</code></pre>
            </article>
            
            <article class="type" data-name="IPMask">
               <h3>
                  IPMask
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An IPMask is a bitmask that can be used to manipulate
IP addresses for IP addressing and routing.
See type [IPNet] and func [ParseCIDR] for details.</p>
               
               <pre><code>type IPMask []byte</code></pre>
            </article>
            
            <article class="type" data-name="InvalidAddrError">
               <h3>
                  InvalidAddrError
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type InvalidAddrError string</code></pre>
            </article>
            
            <article class="type" data-name="UnknownNetworkError">
               <h3>
                  UnknownNetworkError
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type UnknownNetworkError string</code></pre>
            </article>
            
            <article class="type" data-name="_C_char">
               <h3>
                  _C_char
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_char C.char</code></pre>
            </article>
            
            <article class="type" data-name="_C_char">
               <h3>
                  _C_char
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_char byte</code></pre>
            </article>
            
            <article class="type" data-name="_C_int">
               <h3>
                  _C_int
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_int C.int</code></pre>
            </article>
            
            <article class="type" data-name="_C_int">
               <h3>
                  _C_int
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_int int32</code></pre>
            </article>
            
            <article class="type" data-name="_C_socklen_t">
               <h3>
                  _C_socklen_t
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_socklen_t int</code></pre>
            </article>
            
            <article class="type" data-name="_C_socklen_t">
               <h3>
                  _C_socklen_t
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_socklen_t C.socklen_t</code></pre>
            </article>
            
            <article class="type" data-name="_C_struct___res_state">
               <h3>
                  _C_struct___res_state
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_struct___res_state unix.ResState</code></pre>
            </article>
            
            <article class="type" data-name="_C_struct___res_state">
               <h3>
                  _C_struct___res_state
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_struct___res_state C.struct___res_state</code></pre>
            </article>
            
            <article class="type" data-name="_C_struct_addrinfo">
               <h3>
                  _C_struct_addrinfo
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_struct_addrinfo unix.Addrinfo</code></pre>
            </article>
            
            <article class="type" data-name="_C_struct_addrinfo">
               <h3>
                  _C_struct_addrinfo
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_struct_addrinfo C.struct_addrinfo</code></pre>
            </article>
            
            <article class="type" data-name="_C_struct_sockaddr">
               <h3>
                  _C_struct_sockaddr
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_struct_sockaddr C.struct_sockaddr</code></pre>
            </article>
            
            <article class="type" data-name="_C_struct_sockaddr">
               <h3>
                  _C_struct_sockaddr
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_struct_sockaddr syscall.RawSockaddr</code></pre>
            </article>
            
            <article class="type" data-name="_C_uchar">
               <h3>
                  _C_uchar
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_uchar C.uchar</code></pre>
            </article>
            
            <article class="type" data-name="_C_uchar">
               <h3>
                  _C_uchar
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_uchar byte</code></pre>
            </article>
            
            <article class="type" data-name="_C_uint">
               <h3>
                  _C_uint
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_uint C.uint</code></pre>
            </article>
            
            <article class="type" data-name="_C_uint">
               <h3>
                  _C_uint
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type _C_uint uint32</code></pre>
            </article>
            
            <article class="type" data-name="addrList">
               <h3>
                  addrList
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An addrList represents a list of network endpoint addresses.</p>
               
               <pre><code>type addrList []Addr</code></pre>
            </article>
            
            <article class="type" data-name="addrinfoErrno">
               <h3>
                  addrinfoErrno
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An addrinfoErrno represents a getaddrinfo, getnameinfo-specific
error number. It's a signed number and a zero value is a non-error
by convention.</p>
               
               <pre><code>type addrinfoErrno int</code></pre>
            </article>
            
            <article class="type" data-name="byPref">
               <h3>
                  byPref
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>byPref sorts MX records by preference</p>
               
               <pre><code>type byPref []*MX</code></pre>
            </article>
            
            <article class="type" data-name="byPriorityWeight">
               <h3>
                  byPriorityWeight
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>byPriorityWeight sorts SRV records by ascending priority and weight.</p>
               
               <pre><code>type byPriorityWeight []*SRV</code></pre>
            </article>
            
            <article class="type" data-name="fileAddr">
               <h3>
                  fileAddr
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type fileAddr string</code></pre>
            </article>
            
            <article class="type" data-name="hostLookupOrder">
               <h3>
                  hostLookupOrder
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>hostLookupOrder specifies the order of LookupHost lookup strategies.
It is basically a simplified representation of nsswitch.conf.
"files" means /etc/hosts.</p>
               
               <pre><code>type hostLookupOrder int</code></pre>
            </article>
            
            <article class="type" data-name="mdnsTest">
               <h3>
                  mdnsTest
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>mdnsTest is for testing only.</p>
               
               <pre><code>type mdnsTest int</code></pre>
            </article>
            
            <article class="type" data-name="mptcpStatusDial">
               <h3>
                  mptcpStatusDial
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>mptcpStatusDial is a tristate for Multipath TCP on clients,
see go.dev/issue/56539</p>
               
               <pre><code>type mptcpStatusDial uint8</code></pre>
            </article>
            
            <article class="type" data-name="mptcpStatusListen">
               <h3>
                  mptcpStatusListen
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>mptcpStatusListen is a tristate for Multipath TCP on servers,
see go.dev/issue/56539</p>
               
               <pre><code>type mptcpStatusListen uint8</code></pre>
            </article>
            
            <article class="type" data-name="policyTable">
               <h3>
                  policyTable
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type policyTable []policyTableEntry</code></pre>
            </article>
            
            <article class="type" data-name="scope">
               <h3>
                  scope
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>RFC 6724 section 3.1.</p>
               
               <pre><code>type scope uint8</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Addr">
               <h3>
                  Addr
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Addr represents a network end point address.
The two methods [Addr.Network] and [Addr.String] conventionally return strings
that can be passed as the arguments to [Dial], but the exact form
and meaning of the strings is up to the implementation.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Addr interface {
Network() string
String() string
}</code></pre>
            </article>
            
            <article class="interface" data-name="Conn">
               <h3>
                  Conn
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Conn is a generic stream-oriented network connection.
Multiple goroutines may invoke methods on a Conn simultaneously.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Conn interface {
Read(b []byte) (n int, err error)
Write(b []byte) (n int, err error)
Close() error
LocalAddr() Addr
RemoteAddr() Addr
SetDeadline(t time.Time) error
SetReadDeadline(t time.Time) error
SetWriteDeadline(t time.Time) error
}</code></pre>
            </article>
            
            <article class="interface" data-name="Error">
               <h3>
                  Error
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>An Error represents a network error.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Error interface {
error
Timeout() bool
Temporary() bool
}</code></pre>
            </article>
            
            <article class="interface" data-name="Listener">
               <h3>
                  Listener
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A Listener is a generic network listener for stream-oriented protocols.
Multiple goroutines may invoke methods on a Listener simultaneously.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Listener interface {
Accept() (Conn, error)
Close() error
Addr() Addr
}</code></pre>
            </article>
            
            <article class="interface" data-name="PacketConn">
               <h3>
                  PacketConn
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>PacketConn is a generic packet-oriented network connection.
Multiple goroutines may invoke methods on a PacketConn simultaneously.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type PacketConn interface {
ReadFrom(p []byte) (n int, addr Addr, err error)
WriteTo(p []byte, addr Addr) (n int, err error)
Close() error
LocalAddr() Addr
SetDeadline(t time.Time) error
SetReadDeadline(t time.Time) error
SetWriteDeadline(t time.Time) error
}</code></pre>
            </article>
            
            <article class="interface" data-name="buffersWriter">
               <h3>
                  buffersWriter
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>buffersWriter is the interface implemented by Conns that support a
"writev"-like batch write optimization.
writeBuffers should fully consume and write all chunks from the
provided Buffers, else it should report a non-nil error.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type buffersWriter interface {
writeBuffers(*Buffers) (int64, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="sockaddr">
               <h3>
                  sockaddr
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A sockaddr represents a TCP, UDP, IP or Unix network endpoint
address that can be converted into a syscall.Sockaddr.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type sockaddr interface {
Addr
family() int
isWildcard() bool
sockaddr(family int) (syscall.Sockaddr, error)
toLocal(net string) sockaddr
}</code></pre>
            </article>
            
            <article class="interface" data-name="temporary">
               <h3>
                  temporary
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type temporary interface {
Temporary() bool
}</code></pre>
            </article>
            
            <article class="interface" data-name="timeout">
               <h3>
                  timeout
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type timeout interface {
Timeout() bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="AddrError">
               <h3>
                  AddrError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type AddrError struct {
Err string
Addr string
}</code></pre>
            </article>
            
            <article class="struct" data-name="DNSConfigError">
               <h3>
                  DNSConfigError
                  <span class="badge">struct</span>
               </h3>
               
               <p>DNSConfigError represents an error reading the machine's DNS configuration.
(No longer used; kept for compatibility.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type DNSConfigError struct {
Err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="DNSError">
               <h3>
                  DNSError
                  <span class="badge">struct</span>
               </h3>
               
               <p>DNSError represents a DNS lookup error.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type DNSError struct {
UnwrapErr error
Err string
Name string
Server string
IsTimeout bool
IsTemporary bool
IsNotFound bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="Dialer">
               <h3>
                  Dialer
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Dialer contains options for connecting to an address.
The zero value for each field is equivalent to dialing
without that option. Dialing with the zero value of Dialer
is therefore equivalent to just calling the [Dial] function.
It is safe to call Dialer's methods concurrently.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Dialer struct {
Timeout time.Duration
Deadline time.Time
LocalAddr Addr
DualStack bool
FallbackDelay time.Duration
KeepAlive time.Duration
KeepAliveConfig KeepAliveConfig
Resolver *Resolver
Cancel <-chan struct{...}
Control func(network string, address string, c syscall.RawConn) error
ControlContext func(ctx context.Context, network string, address string, c syscall.RawConn) error
mptcpStatus mptcpStatusDial
}</code></pre>
            </article>
            
            <article class="struct" data-name="IPAddr">
               <h3>
                  IPAddr
                  <span class="badge">struct</span>
               </h3>
               
               <p>IPAddr represents the address of an IP end point.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type IPAddr struct {
IP IP
Zone string
}</code></pre>
            </article>
            
            <article class="struct" data-name="IPConn">
               <h3>
                  IPConn
                  <span class="badge">struct</span>
               </h3>
               
               <p>IPConn is the implementation of the [Conn] and [PacketConn] interfaces
for IP network connections.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type IPConn struct {
conn
}</code></pre>
            </article>
            
            <article class="struct" data-name="IPNet">
               <h3>
                  IPNet
                  <span class="badge">struct</span>
               </h3>
               
               <p>An IPNet represents an IP network.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type IPNet struct {
IP IP
Mask IPMask
}</code></pre>
            </article>
            
            <article class="struct" data-name="Interface">
               <h3>
                  Interface
                  <span class="badge">struct</span>
               </h3>
               
               <p>Interface represents a mapping between network interface name
and index. It also represents network interface facility
information.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Interface struct {
Index int
MTU int
Name string
HardwareAddr HardwareAddr
Flags Flags
}</code></pre>
            </article>
            
            <article class="struct" data-name="KeepAliveConfig">
               <h3>
                  KeepAliveConfig
                  <span class="badge">struct</span>
               </h3>
               
               <p>KeepAliveConfig contains TCP keep-alive options.
If the Idle, Interval, or Count fields are zero, a default value is chosen.
If a field is negative, the corresponding socket-level option will be left unchanged.
Note that prior to Windows 10 version 1709, neither setting Idle and Interval
separately nor changing Count (which is usually 10) is supported.
Therefore, it's recommended to set both Idle and Interval to non-negative values
in conjunction with a -1 for Count on those old Windows if you intend to customize
the TCP keep-alive settings.
By contrast, if only one of Idle and Interval is set to a non-negative value,
the other will be set to the system default value, and ultimately,
set both Idle and Interval to negative values if you want to leave them unchanged.
Note that Solaris and its derivatives do not support setting Interval to a non-negative value
and Count to a negative value, or vice-versa.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type KeepAliveConfig struct {
Enable bool
Idle time.Duration
Interval time.Duration
Count int
}</code></pre>
            </article>
            
            <article class="struct" data-name="ListenConfig">
               <h3>
                  ListenConfig
                  <span class="badge">struct</span>
               </h3>
               
               <p>ListenConfig contains options for listening to an address.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ListenConfig struct {
Control func(network string, address string, c syscall.RawConn) error
KeepAlive time.Duration
KeepAliveConfig KeepAliveConfig
mptcpStatus mptcpStatusListen
}</code></pre>
            </article>
            
            <article class="struct" data-name="MX">
               <h3>
                  MX
                  <span class="badge">struct</span>
               </h3>
               
               <p>An MX represents a single DNS MX record.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MX struct {
Host string
Pref uint16
}</code></pre>
            </article>
            
            <article class="struct" data-name="NS">
               <h3>
                  NS
                  <span class="badge">struct</span>
               </h3>
               
               <p>An NS represents a single DNS NS record.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NS struct {
Host string
}</code></pre>
            </article>
            
            <article class="struct" data-name="OpError">
               <h3>
                  OpError
                  <span class="badge">struct</span>
               </h3>
               
               <p>OpError is the error type usually returned by functions in the net
package. It describes the operation, network type, and address of
an error.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type OpError struct {
Op string
Net string
Source Addr
Addr Addr
Err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="ParseError">
               <h3>
                  ParseError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ParseError is the error type of literal network address parsers.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ParseError struct {
Type string
Text string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Resolver">
               <h3>
                  Resolver
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Resolver looks up names and numbers.
A nil *Resolver is equivalent to a zero Resolver.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Resolver struct {
PreferGo bool
StrictErrors bool
Dial func(ctx context.Context, network string, address string) (Conn, error)
lookupGroup singleflight.Group
}</code></pre>
            </article>
            
            <article class="struct" data-name="SRV">
               <h3>
                  SRV
                  <span class="badge">struct</span>
               </h3>
               
               <p>An SRV represents a single DNS SRV record.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SRV struct {
Target string
Port uint16
Priority uint16
Weight uint16
}</code></pre>
            </article>
            
            <article class="struct" data-name="TCPAddr">
               <h3>
                  TCPAddr
                  <span class="badge">struct</span>
               </h3>
               
               <p>TCPAddr represents the address of a TCP end point.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TCPAddr struct {
IP IP
Port int
Zone string
}</code></pre>
            </article>
            
            <article class="struct" data-name="TCPConn">
               <h3>
                  TCPConn
                  <span class="badge">struct</span>
               </h3>
               
               <p>TCPConn is an implementation of the [Conn] interface for TCP network
connections.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TCPConn struct {
conn
}</code></pre>
            </article>
            
            <article class="struct" data-name="TCPListener">
               <h3>
                  TCPListener
                  <span class="badge">struct</span>
               </h3>
               
               <p>TCPListener is a TCP network listener. Clients should typically
use variables of type [Listener] instead of assuming TCP.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TCPListener struct {
fd *netFD
lc ListenConfig
}</code></pre>
            </article>
            
            <article class="struct" data-name="UDPAddr">
               <h3>
                  UDPAddr
                  <span class="badge">struct</span>
               </h3>
               
               <p>UDPAddr represents the address of a UDP end point.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UDPAddr struct {
IP IP
Port int
Zone string
}</code></pre>
            </article>
            
            <article class="struct" data-name="UDPConn">
               <h3>
                  UDPConn
                  <span class="badge">struct</span>
               </h3>
               
               <p>UDPConn is the implementation of the [Conn] and [PacketConn] interfaces
for UDP network connections.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UDPConn struct {
conn
}</code></pre>
            </article>
            
            <article class="struct" data-name="UnixAddr">
               <h3>
                  UnixAddr
                  <span class="badge">struct</span>
               </h3>
               
               <p>UnixAddr represents the address of a Unix domain socket end point.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UnixAddr struct {
Name string
Net string
}</code></pre>
            </article>
            
            <article class="struct" data-name="UnixConn">
               <h3>
                  UnixConn
                  <span class="badge">struct</span>
               </h3>
               
               <p>UnixConn is an implementation of the [Conn] interface for connections
to Unix domain sockets.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UnixConn struct {
conn
}</code></pre>
            </article>
            
            <article class="struct" data-name="UnixListener">
               <h3>
                  UnixListener
                  <span class="badge">struct</span>
               </h3>
               
               <p>UnixListener is a Unix domain socket listener. Clients should
typically use variables of type [Listener] instead of assuming Unix
domain sockets.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UnixListener struct {
fd *netFD
path string
unlink bool
unlinkOnce sync.Once
}</code></pre>
            </article>
            
            <article class="struct" data-name="_C_struct___res_state">
               <h3>
                  _C_struct___res_state
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type _C_struct___res_state struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="addrPortUDPAddr">
               <h3>
                  addrPortUDPAddr
                  <span class="badge">struct</span>
               </h3>
               
               <p>An addrPortUDPAddr is a netip.AddrPort-based UDP address that satisfies the Addr interface.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type addrPortUDPAddr struct {
netip.AddrPort
}</code></pre>
            </article>
            
            <article class="struct" data-name="byName">
               <h3>
                  byName
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type byName struct {
addrs []string
canonicalName string
}</code></pre>
            </article>
            
            <article class="struct" data-name="byRFC6724Info">
               <h3>
                  byRFC6724Info
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type byRFC6724Info struct {
addr IPAddr
addrAttr ipAttr
src netip.Addr
srcAttr ipAttr
}</code></pre>
            </article>
            
            <article class="struct" data-name="canceledError">
               <h3>
                  canceledError
                  <span class="badge">struct</span>
               </h3>
               
               <p>canceledError lets us return the same error string we have always
returned, while still being Is context.Canceled.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type canceledError struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="conf">
               <h3>
                  conf
                  <span class="badge">struct</span>
               </h3>
               
               <p>conf is used to determine name resolution configuration.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type conf struct {
netGo bool
netCgo bool
dnsDebugLevel int
preferCgo bool
goos string
mdnsTest mdnsTest
}</code></pre>
            </article>
            
            <article class="struct" data-name="conn">
               <h3>
                  conn
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type conn struct {
fd *netFD
}</code></pre>
            </article>
            
            <article class="struct" data-name="deadlineTimer">
               <h3>
                  deadlineTimer
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type deadlineTimer struct {
timer chan *time.Timer
expired chan struct{...}
}</code></pre>
            </article>
            
            <article class="struct" data-name="dnsConfig">
               <h3>
                  dnsConfig
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dnsConfig struct {
servers []string
search []string
ndots int
timeout time.Duration
attempts int
rotate bool
unknownOpt bool
lookup []string
err error
mtime time.Time
soffset uint32
singleRequest bool
useTCP bool
trustAD bool
noReload bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="fakeNetFD">
               <h3>
                  fakeNetFD
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fakeNetFD struct {
fd *netFD
assignedPort int
queue *packetQueue
peer *netFD
readDeadline *ast.IndexExpr
writeDeadline *ast.IndexExpr
fakeAddr fakeSockAddr
incoming chan []*netFD
incomingFull chan []*netFD
incomingEmpty chan bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="fakeSockAddr">
               <h3>
                  fakeSockAddr
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fakeSockAddr struct {
family int
address string
}</code></pre>
            </article>
            
            <article class="struct" data-name="file">
               <h3>
                  file
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type file struct {
file *os.File
data []byte
atEOF bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="ifreq">
               <h3>
                  ifreq
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ifreq struct {
Name [16]uint8
Ifru [16]byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="ipAttr">
               <h3>
                  ipAttr
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ipAttr struct {
Scope scope
Precedence uint8
Label uint8
}</code></pre>
            </article>
            
            <article class="struct" data-name="ipStackCapabilities">
               <h3>
                  ipStackCapabilities
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ipStackCapabilities struct {
sync.Once
ipv4Enabled bool
ipv6Enabled bool
ipv4MappedIPv6Enabled bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="ipv6ZoneCache">
               <h3>
                  ipv6ZoneCache
                  <span class="badge">struct</span>
               </h3>
               
               <p>An ipv6ZoneCache represents a cache holding partial network
interface information. It is used for reducing the cost of IPv6
addressing scope zone resolution.
Multiple names sharing the index are managed by first-come
first-served basis for consistency.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ipv6ZoneCache struct {
sync.RWMutex
lastFetched time.Time
toIndex map[string]int
toName map[int]string
}</code></pre>
            </article>
            
            <article class="struct" data-name="netFD">
               <h3>
                  netFD
                  <span class="badge">struct</span>
               </h3>
               
               <p>Network file descriptor.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type netFD struct {
pfd poll.FD
net string
n string
dir string
listen *os.File
ctl *os.File
data *os.File
laddr Addr
raddr Addr
isStream bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="netFD">
               <h3>
                  netFD
                  <span class="badge">struct</span>
               </h3>
               
               <p>Network file descriptor.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type netFD struct {
pfd poll.FD
family int
sotype int
isConnected bool
net string
laddr Addr
raddr Addr
}</code></pre>
            </article>
            
            <article class="struct" data-name="netFD">
               <h3>
                  netFD
                  <span class="badge">struct</span>
               </h3>
               
               <p>Network file descriptor.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type netFD struct {
pfd poll.FD
family int
sotype int
isConnected bool
net string
laddr Addr
raddr Addr
*fakeNetFD
}</code></pre>
            </article>
            
            <article class="struct" data-name="noReadFrom">
               <h3>
                  noReadFrom
                  <span class="badge">struct</span>
               </h3>
               
               <p>noReadFrom can be embedded alongside another type to
hide the ReadFrom method of that other type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type noReadFrom struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="noWriteTo">
               <h3>
                  noWriteTo
                  <span class="badge">struct</span>
               </h3>
               
               <p>noWriteTo can be embedded alongside another type to
hide the WriteTo method of that other type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type noWriteTo struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="notFoundError">
               <h3>
                  notFoundError
                  <span class="badge">struct</span>
               </h3>
               
               <p>notFoundError is a special error understood by the newDNSError function,
which causes a creation of a DNSError with IsNotFound field set to true.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type notFoundError struct {
s string
}</code></pre>
            </article>
            
            <article class="struct" data-name="nssConf">
               <h3>
                  nssConf
                  <span class="badge">struct</span>
               </h3>
               
               <p>nssConf represents the state of the machine's /etc/nsswitch.conf file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nssConf struct {
mtime time.Time
err error
sources map[string][]nssSource
}</code></pre>
            </article>
            
            <article class="struct" data-name="nssCriterion">
               <h3>
                  nssCriterion
                  <span class="badge">struct</span>
               </h3>
               
               <p>nssCriterion is the parsed structure of one of the criteria in brackets
after an NSS source name.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nssCriterion struct {
negate bool
status string
action string
}</code></pre>
            </article>
            
            <article class="struct" data-name="nssSource">
               <h3>
                  nssSource
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nssSource struct {
source string
criteria []nssCriterion
}</code></pre>
            </article>
            
            <article class="struct" data-name="nsswitchConfig">
               <h3>
                  nsswitchConfig
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nsswitchConfig struct {
initOnce sync.Once
ch chan struct{...}
lastChecked time.Time
mu sync.Mutex
nssConf *nssConf
}</code></pre>
            </article>
            
            <article class="struct" data-name="onlyValuesCtx">
               <h3>
                  onlyValuesCtx
                  <span class="badge">struct</span>
               </h3>
               
               <p>onlyValuesCtx is a context that uses an underlying context
for value lookup if the underlying context hasn't yet expired.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type onlyValuesCtx struct {
context.Context
lookupValues context.Context
}</code></pre>
            </article>
            
            <article class="struct" data-name="packet">
               <h3>
                  packet
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type packet struct {
buf []byte
bufOffset int
next *packet
from sockaddr
}</code></pre>
            </article>
            
            <article class="struct" data-name="packetQueue">
               <h3>
                  packetQueue
                  <span class="badge">struct</span>
               </h3>
               
               <p>A packetQueue is a set of 1-buffered channels implementing a FIFO queue
of packets.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type packetQueue struct {
empty chan packetQueueState
ready chan packetQueueState
full chan packetQueueState
}</code></pre>
            </article>
            
            <article class="struct" data-name="packetQueueState">
               <h3>
                  packetQueueState
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type packetQueueState struct {
head *packet
tail *packet
nBytes int
readBufferBytes int
readClosed bool
writeClosed bool
noLinger bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="pipe">
               <h3>
                  pipe
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pipe struct {
wrMu sync.Mutex
rdRx <-chan []byte
rdTx chan<- int
wrTx chan<- []byte
wrRx <-chan int
once sync.Once
localDone chan struct{...}
remoteDone <-chan struct{...}
readDeadline pipeDeadline
writeDeadline pipeDeadline
}</code></pre>
            </article>
            
            <article class="struct" data-name="pipeAddr">
               <h3>
                  pipeAddr
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pipeAddr struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="pipeDeadline">
               <h3>
                  pipeDeadline
                  <span class="badge">struct</span>
               </h3>
               
               <p>pipeDeadline is an abstraction for handling timeouts.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pipeDeadline struct {
mu sync.Mutex
timer *time.Timer
cancel chan struct{...}
}</code></pre>
            </article>
            
            <article class="struct" data-name="policyTableEntry">
               <h3>
                  policyTableEntry
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type policyTableEntry struct {
Prefix netip.Prefix
Precedence uint8
Label uint8
}</code></pre>
            </article>
            
            <article class="struct" data-name="rawConn">
               <h3>
                  rawConn
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type rawConn struct {
fd *netFD
}</code></pre>
            </article>
            
            <article class="struct" data-name="rawListener">
               <h3>
                  rawListener
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type rawListener struct {
rawConn
}</code></pre>
            </article>
            
            <article class="struct" data-name="rawSockaddrDatalink">
               <h3>
                  rawSockaddrDatalink
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type rawSockaddrDatalink struct {
Len uint8
Family uint8
Index uint16
Type uint8
Nlen uint8
Alen uint8
Slen uint8
Data [120]byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="resolverConfig">
               <h3>
                  resolverConfig
                  <span class="badge">struct</span>
               </h3>
               
               <p>A resolverConfig represents a DNS stub resolver configuration.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type resolverConfig struct {
initOnce sync.Once
ch chan struct{...}
lastChecked time.Time
dnsConfig *ast.IndexExpr
}</code></pre>
            </article>
            
            <article class="struct" data-name="sysDialer">
               <h3>
                  sysDialer
                  <span class="badge">struct</span>
               </h3>
               
               <p>sysDialer contains a Dial's parameters and configuration.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sysDialer struct {
Dialer
network string
address string
testHookDialTCP func(ctx context.Context, net string, laddr *TCPAddr, raddr *TCPAddr) (*TCPConn, error)
}</code></pre>
            </article>
            
            <article class="struct" data-name="sysListener">
               <h3>
                  sysListener
                  <span class="badge">struct</span>
               </h3>
               
               <p>sysListener contains a Listen's parameters and configuration.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sysListener struct {
ListenConfig
network string
address string
}</code></pre>
            </article>
            
            <article class="struct" data-name="tcpConnWithoutReadFrom">
               <h3>
                  tcpConnWithoutReadFrom
                  <span class="badge">struct</span>
               </h3>
               
               <p>tcpConnWithoutReadFrom implements all the methods of *TCPConn other
than ReadFrom. This is used to permit ReadFrom to call io.Copy
without leading to a recursive call to ReadFrom.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type tcpConnWithoutReadFrom struct {
noReadFrom
*TCPConn
}</code></pre>
            </article>
            
            <article class="struct" data-name="tcpConnWithoutWriteTo">
               <h3>
                  tcpConnWithoutWriteTo
                  <span class="badge">struct</span>
               </h3>
               
               <p>tcpConnWithoutWriteTo implements all the methods of *TCPConn other
than WriteTo. This is used to permit WriteTo to call io.Copy
without leading to a recursive call to WriteTo.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type tcpConnWithoutWriteTo struct {
noWriteTo
*TCPConn
}</code></pre>
            </article>
            
            <article class="struct" data-name="temporaryError">
               <h3>
                  temporaryError
                  <span class="badge">struct</span>
               </h3>
               
               <p>temporaryError is an error type that implements the [Error] interface.
It returns true from the Temporary method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type temporaryError struct {
s string
}</code></pre>
            </article>
            
            <article class="struct" data-name="timeoutError">
               <h3>
                  timeoutError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type timeoutError struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="udpHeader">
               <h3>
                  udpHeader
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type udpHeader struct {
raddr IP
laddr IP
ifcaddr IP
rport uint16
lport uint16
}</code></pre>
            </article>
            
            <article class="struct" data-name="unknownAddr">
               <h3>
                  unknownAddr
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type unknownAddr struct {

}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Accept">
               <h3>
                  Accept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Accept implements the Accept method in the [Listener] interface; it
waits for the next call and returns a generic [Conn].</p>
               
               <pre><code>func (l *TCPListener) Accept() (Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="Accept">
               <h3>
                  Accept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Accept implements the Accept method in the [Listener] interface.
Returned connections will be of type [*UnixConn].</p>
               
               <pre><code>func (l *UnixListener) Accept() (Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="AcceptTCP">
               <h3>
                  AcceptTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AcceptTCP accepts the next incoming call and returns the new
connection.</p>
               
               <pre><code>func (l *TCPListener) AcceptTCP() (*TCPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="AcceptUnix">
               <h3>
                  AcceptUnix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AcceptUnix accepts the next incoming call and returns the new
connection.</p>
               
               <pre><code>func (l *UnixListener) AcceptUnix() (*UnixConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="Addr">
               <h3>
                  Addr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Addr returns the listener's network address, a [*TCPAddr].
The Addr returned is shared by all invocations of Addr, so
do not modify it.</p>
               
               <pre><code>func (l *TCPListener) Addr() Addr</code></pre>
            </article>
            
            <article class="function" data-name="Addr">
               <h3>
                  Addr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Addr returns the listener's network address.
The Addr returned is shared by all invocations of Addr, so
do not modify it.</p>
               
               <pre><code>func (l *UnixListener) Addr() Addr</code></pre>
            </article>
            
            <article class="function" data-name="AddrPort">
               <h3>
                  AddrPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddrPort returns the [TCPAddr] a as a [netip.AddrPort].
If a.Port does not fit in a uint16, it's silently truncated.
If a is nil, a zero value is returned.</p>
               
               <pre><code>func (a *TCPAddr) AddrPort() netip.AddrPort</code></pre>
            </article>
            
            <article class="function" data-name="AddrPort">
               <h3>
                  AddrPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddrPort returns the [UDPAddr] a as a [netip.AddrPort].
If a.Port does not fit in a uint16, it's silently truncated.
If a is nil, a zero value is returned.</p>
               
               <pre><code>func (a *UDPAddr) AddrPort() netip.AddrPort</code></pre>
            </article>
            
            <article class="function" data-name="Addrs">
               <h3>
                  Addrs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Addrs returns a list of unicast interface addresses for a specific
interface.</p>
               
               <pre><code>func (ifi *Interface) Addrs() ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="AppendText">
               <h3>
                  AppendText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendText implements the [encoding.TextAppender] interface.
The encoding is the same as returned by [IP.String], with one exception:
When len(ip) is zero, it appends nothing.</p>
               
               <pre><code>func (ip IP) AppendText(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *udpHeader) Bytes() []byte</code></pre>
            </article>
            
            <article class="function" data-name="CIDRMask">
               <h3>
                  CIDRMask 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CIDRMask returns an [IPMask] consisting of 'ones' 1 bits
followed by 0s up to a total length of 'bits' bits.
For a mask of this form, CIDRMask is the inverse of [IPMask.Size].</p>
               
               <pre><code>func CIDRMask(ones int, bits int) IPMask</code></pre>
            </article>
            
            <article class="function" data-name="Classify">
               <h3>
                  Classify 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Classify returns the policyTableEntry of the entry with the longest
matching prefix that contains ip.
The table t must be sorted from largest mask size to smallest.</p>
               
               <pre><code>func (t policyTable) Classify(ip netip.Addr) policyTableEntry</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pipe) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close closes the connection.</p>
               
               <pre><code>func (c *conn) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close stops listening on the Unix address. Already accepted
connections are not closed.</p>
               
               <pre><code>func (l *UnixListener) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close stops listening on the TCP address.
Already Accepted connections are not closed.</p>
               
               <pre><code>func (l *TCPListener) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) Close() (err error)</code></pre>
            </article>
            
            <article class="function" data-name="CloseRead">
               <h3>
                  CloseRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CloseRead shuts down the reading side of the Unix domain connection.
Most callers should just use Close.</p>
               
               <pre><code>func (c *UnixConn) CloseRead() error</code></pre>
            </article>
            
            <article class="function" data-name="CloseRead">
               <h3>
                  CloseRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CloseRead shuts down the reading side of the TCP connection.
Most callers should just use Close.</p>
               
               <pre><code>func (c *TCPConn) CloseRead() error</code></pre>
            </article>
            
            <article class="function" data-name="CloseWrite">
               <h3>
                  CloseWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CloseWrite shuts down the writing side of the Unix domain connection.
Most callers should just use Close.</p>
               
               <pre><code>func (c *UnixConn) CloseWrite() error</code></pre>
            </article>
            
            <article class="function" data-name="CloseWrite">
               <h3>
                  CloseWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CloseWrite shuts down the writing side of the TCP connection.
Most callers should just use Close.</p>
               
               <pre><code>func (c *TCPConn) CloseWrite() error</code></pre>
            </article>
            
            <article class="function" data-name="Contains">
               <h3>
                  Contains 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Contains reports whether the network includes ip.</p>
               
               <pre><code>func (n *IPNet) Contains(ip IP) bool</code></pre>
            </article>
            
            <article class="function" data-name="Control">
               <h3>
                  Control 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *rawConn) Control(f func(uintptr)) error</code></pre>
            </article>
            
            <article class="function" data-name="DefaultMask">
               <h3>
                  DefaultMask 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DefaultMask returns the default IP mask for the IP address ip.
Only IPv4 addresses have default masks; DefaultMask returns
nil if ip is not a valid IPv4 address.</p>
               
               <pre><code>func (ip IP) DefaultMask() IPMask</code></pre>
            </article>
            
            <article class="function" data-name="Dial">
               <h3>
                  Dial 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Dial connects to the address on the named network.
See func Dial for a description of the network and address
parameters.
Dial uses [context.Background] internally; to specify the context, use
[Dialer.DialContext].</p>
               
               <pre><code>func (d *Dialer) Dial(network string, address string) (Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="Dial">
               <h3>
                  Dial 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Dial connects to the address on the named network.
Known networks are "tcp", "tcp4" (IPv4-only), "tcp6" (IPv6-only),
"udp", "udp4" (IPv4-only), "udp6" (IPv6-only), "ip", "ip4"
(IPv4-only), "ip6" (IPv6-only), "unix", "unixgram" and
"unixpacket".
For TCP and UDP networks, the address has the form "host:port".
The host must be a literal IP address, or a host name that can be
resolved to IP addresses.
The port must be a literal port number or a service name.
If the host is a literal IPv6 address it must be enclosed in square
brackets, as in "[2001:db8::1]:80" or "[fe80::1%zone]:80".
The zone specifies the scope of the literal IPv6 address as defined
in RFC 4007.
The functions [JoinHostPort] and [SplitHostPort] manipulate a pair of
host and port in this form.
When using TCP, and the host resolves to multiple IP addresses,
Dial will try each IP address in order until one succeeds.
Examples:
Dial("tcp", "golang.org:http")
Dial("tcp", "192.0.2.1:http")
Dial("tcp", "198.51.100.1:80")
Dial("udp", "[2001:db8::1]:domain")
Dial("udp", "[fe80::1%lo0]:53")
Dial("tcp", ":80")
For IP networks, the network must be "ip", "ip4" or "ip6" followed
by a colon and a literal protocol number or a protocol name, and
the address has the form "host". The host must be a literal IP
address or a literal IPv6 address with zone.
It depends on each operating system how the operating system
behaves with a non-well known protocol number such as "0" or "255".
Examples:
Dial("ip4:1", "192.0.2.1")
Dial("ip6:ipv6-icmp", "2001:db8::1")
Dial("ip6:58", "fe80::1%lo0")
For TCP, UDP and IP networks, if the host is empty or a literal
unspecified IP address, as in ":80", "0.0.0.0:80" or "[::]:80" for
TCP and UDP, "", "0.0.0.0" or "::" for IP, the local system is
assumed.
For Unix networks, the address must be a file system path.</p>
               
               <pre><code>func Dial(network string, address string) (Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="DialContext">
               <h3>
                  DialContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DialContext connects to the address on the named network using
the provided context.
The provided Context must be non-nil. If the context expires before
the connection is complete, an error is returned. Once successfully
connected, any expiration of the context will not affect the
connection.
When using TCP, and the host in the address parameter resolves to multiple
network addresses, any dial timeout (from d.Timeout or ctx) is spread
over each consecutive dial, such that each is given an appropriate
fraction of the time to connect.
For example, if a host has 4 IP addresses and the timeout is 1 minute,
the connect to each single address will be given 15 seconds to complete
before trying the next one.
See func [Dial] for a description of the network and address
parameters.</p>
               
               <pre><code>func (d *Dialer) DialContext(ctx context.Context, network string, address string) (Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="DialIP">
               <h3>
                  DialIP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DialIP acts like [Dial] for IP networks.
The network must be an IP network name; see func Dial for details.
If laddr is nil, a local address is automatically chosen.
If the IP field of raddr is nil or an unspecified IP address, the
local system is assumed.</p>
               
               <pre><code>func DialIP(network string, laddr *IPAddr, raddr *IPAddr) (*IPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="DialTCP">
               <h3>
                  DialTCP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DialTCP acts like [Dial] for TCP networks.
The network must be a TCP network name; see func Dial for details.
If laddr is nil, a local address is automatically chosen.
If the IP field of raddr is nil or an unspecified IP address, the
local system is assumed.</p>
               
               <pre><code>func DialTCP(network string, laddr *TCPAddr, raddr *TCPAddr) (*TCPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="DialTimeout">
               <h3>
                  DialTimeout 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DialTimeout acts like [Dial] but takes a timeout.
The timeout includes name resolution, if required.
When using TCP, and the host in the address parameter resolves to
multiple IP addresses, the timeout is spread over each consecutive
dial, such that each is given an appropriate fraction of the time
to connect.
See func Dial for a description of the network and address
parameters.</p>
               
               <pre><code>func DialTimeout(network string, address string, timeout time.Duration) (Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="DialUDP">
               <h3>
                  DialUDP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DialUDP acts like [Dial] for UDP networks.
The network must be a UDP network name; see func [Dial] for details.
If laddr is nil, a local address is automatically chosen.
If the IP field of raddr is nil or an unspecified IP address, the
local system is assumed.</p>
               
               <pre><code>func DialUDP(network string, laddr *UDPAddr, raddr *UDPAddr) (*UDPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="DialUnix">
               <h3>
                  DialUnix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DialUnix acts like [Dial] for Unix networks.
The network must be a Unix network name; see func Dial for details.
If laddr is non-nil, it is used as the local address for the
connection.</p>
               
               <pre><code>func DialUnix(network string, laddr *UnixAddr, raddr *UnixAddr) (*UnixConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Equal reports whether ip and x are the same IP address.
An IPv4 address and that same address in IPv6 form are
considered to be equal.</p>
               
               <pre><code>func (ip IP) Equal(x IP) bool</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *DNSConfigError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *timeoutError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e InvalidAddrError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *DNSError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e UnknownNetworkError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *temporaryError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *notFoundError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *AddrError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (eai addrinfoErrno) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ParseError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *OpError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (canceledError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="File">
               <h3>
                  File 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>File returns a copy of the underlying [os.File].
It is the caller's responsibility to close f when finished.
Closing l does not affect f, and closing f does not affect l.
The returned os.File's file descriptor is different from the
connection's. Attempting to change properties of the original
using this duplicate may or may not have the desired effect.</p>
               
               <pre><code>func (l *TCPListener) File() (f *os.File, err error)</code></pre>
            </article>
            
            <article class="function" data-name="File">
               <h3>
                  File 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>File returns a copy of the underlying [os.File].
It is the caller's responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
The returned os.File's file descriptor is different from the connection's.
Attempting to change properties of the original using this duplicate
may or may not have the desired effect.</p>
               
               <pre><code>func (c *conn) File() (f *os.File, err error)</code></pre>
            </article>
            
            <article class="function" data-name="File">
               <h3>
                  File 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>File returns a copy of the underlying [os.File].
It is the caller's responsibility to close f when finished.
Closing l does not affect f, and closing f does not affect l.
The returned os.File's file descriptor is different from the
connection's. Attempting to change properties of the original
using this duplicate may or may not have the desired effect.</p>
               
               <pre><code>func (l *UnixListener) File() (f *os.File, err error)</code></pre>
            </article>
            
            <article class="function" data-name="FileConn">
               <h3>
                  FileConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FileConn returns a copy of the network connection corresponding to
the open file f.
It is the caller's responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.</p>
               
               <pre><code>func FileConn(f *os.File) (c Conn, err error)</code></pre>
            </article>
            
            <article class="function" data-name="FileListener">
               <h3>
                  FileListener 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FileListener returns a copy of the network listener corresponding
to the open file f.
It is the caller's responsibility to close ln when finished.
Closing ln does not affect f, and closing f does not affect ln.</p>
               
               <pre><code>func FileListener(f *os.File) (ln Listener, err error)</code></pre>
            </article>
            
            <article class="function" data-name="FilePacketConn">
               <h3>
                  FilePacketConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FilePacketConn returns a copy of the packet network connection
corresponding to the open file f.
It is the caller's responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.</p>
               
               <pre><code>func FilePacketConn(f *os.File) (c PacketConn, err error)</code></pre>
            </article>
            
            <article class="function" data-name="IPv4">
               <h3>
                  IPv4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IPv4 returns the IP address (in 16-byte form) of the
IPv4 address a.b.c.d.</p>
               
               <pre><code>func IPv4(a byte, b byte, c byte, d byte) IP</code></pre>
            </article>
            
            <article class="function" data-name="IPv4Mask">
               <h3>
                  IPv4Mask 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IPv4Mask returns the IP mask (in 4-byte form) of the
IPv4 mask a.b.c.d.</p>
               
               <pre><code>func IPv4Mask(a byte, b byte, c byte, d byte) IPMask</code></pre>
            </article>
            
            <article class="function" data-name="InterfaceAddrs">
               <h3>
                  InterfaceAddrs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>InterfaceAddrs returns a list of the system's unicast interface
addresses.
The returned list does not identify the associated interface; use
Interfaces and [Interface.Addrs] for more detail.</p>
               
               <pre><code>func InterfaceAddrs() ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="InterfaceByIndex">
               <h3>
                  InterfaceByIndex 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>InterfaceByIndex returns the interface specified by index.
On Solaris, it returns one of the logical network interfaces
sharing the logical data link; for more precision use
[InterfaceByName].</p>
               
               <pre><code>func InterfaceByIndex(index int) (*Interface, error)</code></pre>
            </article>
            
            <article class="function" data-name="InterfaceByName">
               <h3>
                  InterfaceByName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>InterfaceByName returns the interface specified by name.</p>
               
               <pre><code>func InterfaceByName(name string) (*Interface, error)</code></pre>
            </article>
            
            <article class="function" data-name="Interfaces">
               <h3>
                  Interfaces 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Interfaces returns a list of the system's network interfaces.</p>
               
               <pre><code>func Interfaces() ([]Interface, error)</code></pre>
            </article>
            
            <article class="function" data-name="Is">
               <h3>
                  Is 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *timeoutError) Is(err error) bool</code></pre>
            </article>
            
            <article class="function" data-name="Is">
               <h3>
                  Is 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (canceledError) Is(err error) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsGlobalUnicast">
               <h3>
                  IsGlobalUnicast 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsGlobalUnicast reports whether ip is a global unicast
address.
The identification of global unicast addresses uses address type
identification as defined in RFC 1122, RFC 4632 and RFC 4291 with
the exception of IPv4 directed broadcast addresses.
It returns true even if ip is in IPv4 private address space or
local IPv6 unicast address space.</p>
               
               <pre><code>func (ip IP) IsGlobalUnicast() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsInterfaceLocalMulticast">
               <h3>
                  IsInterfaceLocalMulticast 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsInterfaceLocalMulticast reports whether ip is
an interface-local multicast address.</p>
               
               <pre><code>func (ip IP) IsInterfaceLocalMulticast() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsLinkLocalMulticast">
               <h3>
                  IsLinkLocalMulticast 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsLinkLocalMulticast reports whether ip is a link-local
multicast address.</p>
               
               <pre><code>func (ip IP) IsLinkLocalMulticast() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsLinkLocalUnicast">
               <h3>
                  IsLinkLocalUnicast 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsLinkLocalUnicast reports whether ip is a link-local
unicast address.</p>
               
               <pre><code>func (ip IP) IsLinkLocalUnicast() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsLoopback">
               <h3>
                  IsLoopback 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsLoopback reports whether ip is a loopback address.</p>
               
               <pre><code>func (ip IP) IsLoopback() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsMulticast">
               <h3>
                  IsMulticast 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsMulticast reports whether ip is a multicast address.</p>
               
               <pre><code>func (ip IP) IsMulticast() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPrivate">
               <h3>
                  IsPrivate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsPrivate reports whether ip is a private address, according to
RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses).</p>
               
               <pre><code>func (ip IP) IsPrivate() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsUnspecified">
               <h3>
                  IsUnspecified 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsUnspecified reports whether ip is an unspecified address, either
the IPv4 address "0.0.0.0" or the IPv6 address "::".</p>
               
               <pre><code>func (ip IP) IsUnspecified() bool</code></pre>
            </article>
            
            <article class="function" data-name="JoinHostPort">
               <h3>
                  JoinHostPort 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>JoinHostPort combines host and port into a network address of the
form "host:port". If host contains a colon, as found in literal
IPv6 addresses, then JoinHostPort returns "[host]:port".
See func Dial for a description of the host and port parameters.</p>
               
               <pre><code>func JoinHostPort(host string, port string) string</code></pre>
            </article>
            
            <article class="function" data-name="Listen">
               <h3>
                  Listen 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Listen announces on the local network address.
See func Listen for a description of the network and address
parameters.
The ctx argument is used while resolving the address on which to listen;
it does not affect the returned Listener.</p>
               
               <pre><code>func (lc *ListenConfig) Listen(ctx context.Context, network string, address string) (Listener, error)</code></pre>
            </article>
            
            <article class="function" data-name="Listen">
               <h3>
                  Listen 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Listen announces on the local network address.
The network must be "tcp", "tcp4", "tcp6", "unix" or "unixpacket".
For TCP networks, if the host in the address parameter is empty or
a literal unspecified IP address, Listen listens on all available
unicast and anycast IP addresses of the local system.
To only use IPv4, use network "tcp4".
The address can use a host name, but this is not recommended,
because it will create a listener for at most one of the host's IP
addresses.
If the port in the address parameter is empty or "0", as in
"127.0.0.1:" or "[::1]:0", a port number is automatically chosen.
The [Addr] method of [Listener] can be used to discover the chosen
port.
See func [Dial] for a description of the network and address
parameters.
Listen uses context.Background internally; to specify the context, use
[ListenConfig.Listen].</p>
               
               <pre><code>func Listen(network string, address string) (Listener, error)</code></pre>
            </article>
            
            <article class="function" data-name="ListenIP">
               <h3>
                  ListenIP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ListenIP acts like [ListenPacket] for IP networks.
The network must be an IP network name; see func Dial for details.
If the IP field of laddr is nil or an unspecified IP address,
ListenIP listens on all available IP addresses of the local system
except multicast IP addresses.</p>
               
               <pre><code>func ListenIP(network string, laddr *IPAddr) (*IPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="ListenMulticastUDP">
               <h3>
                  ListenMulticastUDP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ListenMulticastUDP acts like [ListenPacket] for UDP networks but
takes a group address on a specific network interface.
The network must be a UDP network name; see func [Dial] for details.
ListenMulticastUDP listens on all available IP addresses of the
local system including the group, multicast IP address.
If ifi is nil, ListenMulticastUDP uses the system-assigned
multicast interface, although this is not recommended because the
assignment depends on platforms and sometimes it might require
routing configuration.
If the Port field of gaddr is 0, a port number is automatically
chosen.
ListenMulticastUDP is just for convenience of simple, small
applications. There are [golang.org/x/net/ipv4] and
[golang.org/x/net/ipv6] packages for general purpose uses.
Note that ListenMulticastUDP will set the IP_MULTICAST_LOOP socket option
to 0 under IPPROTO_IP, to disable loopback of multicast packets.</p>
               
               <pre><code>func ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="ListenPacket">
               <h3>
                  ListenPacket 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ListenPacket announces on the local network address.
See func ListenPacket for a description of the network and address
parameters.
The ctx argument is used while resolving the address on which to listen;
it does not affect the returned Listener.</p>
               
               <pre><code>func (lc *ListenConfig) ListenPacket(ctx context.Context, network string, address string) (PacketConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="ListenPacket">
               <h3>
                  ListenPacket 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ListenPacket announces on the local network address.
The network must be "udp", "udp4", "udp6", "unixgram", or an IP
transport. The IP transports are "ip", "ip4", or "ip6" followed by
a colon and a literal protocol number or a protocol name, as in
"ip:1" or "ip:icmp".
For UDP and IP networks, if the host in the address parameter is
empty or a literal unspecified IP address, ListenPacket listens on
all available IP addresses of the local system except multicast IP
addresses.
To only use IPv4, use network "udp4" or "ip4:proto".
The address can use a host name, but this is not recommended,
because it will create a listener for at most one of the host's IP
addresses.
If the port in the address parameter is empty or "0", as in
"127.0.0.1:" or "[::1]:0", a port number is automatically chosen.
The LocalAddr method of [PacketConn] can be used to discover the
chosen port.
See func [Dial] for a description of the network and address
parameters.
ListenPacket uses context.Background internally; to specify the context, use
[ListenConfig.ListenPacket].</p>
               
               <pre><code>func ListenPacket(network string, address string) (PacketConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="ListenTCP">
               <h3>
                  ListenTCP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ListenTCP acts like [Listen] for TCP networks.
The network must be a TCP network name; see func Dial for details.
If the IP field of laddr is nil or an unspecified IP address,
ListenTCP listens on all available unicast and anycast IP addresses
of the local system.
If the Port field of laddr is 0, a port number is automatically
chosen.</p>
               
               <pre><code>func ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error)</code></pre>
            </article>
            
            <article class="function" data-name="ListenUDP">
               <h3>
                  ListenUDP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ListenUDP acts like [ListenPacket] for UDP networks.
The network must be a UDP network name; see func [Dial] for details.
If the IP field of laddr is nil or an unspecified IP address,
ListenUDP listens on all available IP addresses of the local system
except multicast IP addresses.
If the Port field of laddr is 0, a port number is automatically
chosen.</p>
               
               <pre><code>func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="ListenUnix">
               <h3>
                  ListenUnix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ListenUnix acts like [Listen] for Unix networks.
The network must be "unix" or "unixpacket".</p>
               
               <pre><code>func ListenUnix(network string, laddr *UnixAddr) (*UnixListener, error)</code></pre>
            </article>
            
            <article class="function" data-name="ListenUnixgram">
               <h3>
                  ListenUnixgram 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ListenUnixgram acts like [ListenPacket] for Unix networks.
The network must be "unixgram".</p>
               
               <pre><code>func ListenUnixgram(network string, laddr *UnixAddr) (*UnixConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="LocalAddr">
               <h3>
                  LocalAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*pipe) LocalAddr() Addr</code></pre>
            </article>
            
            <article class="function" data-name="LocalAddr">
               <h3>
                  LocalAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LocalAddr returns the local network address.
The Addr returned is shared by all invocations of LocalAddr, so
do not modify it.</p>
               
               <pre><code>func (c *conn) LocalAddr() Addr</code></pre>
            </article>
            
            <article class="function" data-name="LookupAddr">
               <h3>
                  LookupAddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LookupAddr performs a reverse lookup for the given address, returning a list
of names mapping to that address.
The returned names are validated to be properly formatted presentation-format
domain names. If the response contains invalid names, those records are filtered
out and an error will be returned alongside the remaining results, if any.
When using the host C library resolver, at most one result will be
returned. To bypass the host resolver, use a custom [Resolver].
LookupAddr uses [context.Background] internally; to specify the context, use
[Resolver.LookupAddr].</p>
               
               <pre><code>func LookupAddr(addr string) (names []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupAddr">
               <h3>
                  LookupAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupAddr performs a reverse lookup for the given address, returning a list
of names mapping to that address.
The returned names are validated to be properly formatted presentation-format
domain names. If the response contains invalid names, those records are filtered
out and an error will be returned alongside the remaining results, if any.</p>
               
               <pre><code>func (r *Resolver) LookupAddr(ctx context.Context, addr string) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupCNAME">
               <h3>
                  LookupCNAME 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupCNAME returns the canonical name for the given host.
Callers that do not care about the canonical name can call
[LookupHost] or [LookupIP] directly; both take care of resolving
the canonical name as part of the lookup.
A canonical name is the final name after following zero
or more CNAME records.
LookupCNAME does not return an error if host does not
contain DNS "CNAME" records, as long as host resolves to
address records.
The returned canonical name is validated to be a properly
formatted presentation-format domain name.</p>
               
               <pre><code>func (r *Resolver) LookupCNAME(ctx context.Context, host string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupCNAME">
               <h3>
                  LookupCNAME 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LookupCNAME returns the canonical name for the given host.
Callers that do not care about the canonical name can call
[LookupHost] or [LookupIP] directly; both take care of resolving
the canonical name as part of the lookup.
A canonical name is the final name after following zero
or more CNAME records.
LookupCNAME does not return an error if host does not
contain DNS "CNAME" records, as long as host resolves to
address records.
The returned canonical name is validated to be a properly
formatted presentation-format domain name.
LookupCNAME uses [context.Background] internally; to specify the context, use
[Resolver.LookupCNAME].</p>
               
               <pre><code>func LookupCNAME(host string) (cname string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupHost">
               <h3>
                  LookupHost 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupHost looks up the given host using the local resolver.
It returns a slice of that host's addresses.</p>
               
               <pre><code>func (r *Resolver) LookupHost(ctx context.Context, host string) (addrs []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupHost">
               <h3>
                  LookupHost 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LookupHost looks up the given host using the local resolver.
It returns a slice of that host's addresses.
LookupHost uses [context.Background] internally; to specify the context, use
[Resolver.LookupHost].</p>
               
               <pre><code>func LookupHost(host string) (addrs []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupIP">
               <h3>
                  LookupIP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupIP looks up host for the given network using the local resolver.
It returns a slice of that host's IP addresses of the type specified by
network.
network must be one of "ip", "ip4" or "ip6".</p>
               
               <pre><code>func (r *Resolver) LookupIP(ctx context.Context, network string, host string) ([]IP, error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupIP">
               <h3>
                  LookupIP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LookupIP looks up host using the local resolver.
It returns a slice of that host's IPv4 and IPv6 addresses.</p>
               
               <pre><code>func LookupIP(host string) ([]IP, error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupIPAddr">
               <h3>
                  LookupIPAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupIPAddr looks up host using the local resolver.
It returns a slice of that host's IPv4 and IPv6 addresses.</p>
               
               <pre><code>func (r *Resolver) LookupIPAddr(ctx context.Context, host string) ([]IPAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupMX">
               <h3>
                  LookupMX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupMX returns the DNS MX records for the given domain name sorted by preference.
The returned mail server names are validated to be properly
formatted presentation-format domain names. If the response contains
invalid names, those records are filtered out and an error
will be returned alongside the remaining results, if any.</p>
               
               <pre><code>func (r *Resolver) LookupMX(ctx context.Context, name string) ([]*MX, error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupMX">
               <h3>
                  LookupMX 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LookupMX returns the DNS MX records for the given domain name sorted by preference.
The returned mail server names are validated to be properly
formatted presentation-format domain names. If the response contains
invalid names, those records are filtered out and an error
will be returned alongside the remaining results, if any.
LookupMX uses [context.Background] internally; to specify the context, use
[Resolver.LookupMX].</p>
               
               <pre><code>func LookupMX(name string) ([]*MX, error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupNS">
               <h3>
                  LookupNS 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupNS returns the DNS NS records for the given domain name.
The returned name server names are validated to be properly
formatted presentation-format domain names. If the response contains
invalid names, those records are filtered out and an error
will be returned alongside the remaining results, if any.</p>
               
               <pre><code>func (r *Resolver) LookupNS(ctx context.Context, name string) ([]*NS, error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupNS">
               <h3>
                  LookupNS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LookupNS returns the DNS NS records for the given domain name.
The returned name server names are validated to be properly
formatted presentation-format domain names. If the response contains
invalid names, those records are filtered out and an error
will be returned alongside the remaining results, if any.
LookupNS uses [context.Background] internally; to specify the context, use
[Resolver.LookupNS].</p>
               
               <pre><code>func LookupNS(name string) ([]*NS, error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupNetIP">
               <h3>
                  LookupNetIP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupNetIP looks up host using the local resolver.
It returns a slice of that host's IP addresses of the type specified by
network.
The network must be one of "ip", "ip4" or "ip6".</p>
               
               <pre><code>func (r *Resolver) LookupNetIP(ctx context.Context, network string, host string) ([]netip.Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupPort">
               <h3>
                  LookupPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupPort looks up the port for the given network and service.
The network must be one of "tcp", "tcp4", "tcp6", "udp", "udp4", "udp6" or "ip".</p>
               
               <pre><code>func (r *Resolver) LookupPort(ctx context.Context, network string, service string) (port int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupPort">
               <h3>
                  LookupPort 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LookupPort looks up the port for the given network and service.
LookupPort uses [context.Background] internally; to specify the context, use
[Resolver.LookupPort].</p>
               
               <pre><code>func LookupPort(network string, service string) (port int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupSRV">
               <h3>
                  LookupSRV 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LookupSRV tries to resolve an [SRV] query of the given service,
protocol, and domain name. The proto is "tcp" or "udp".
The returned records are sorted by priority and randomized
by weight within a priority.
LookupSRV constructs the DNS name to look up following RFC 2782.
That is, it looks up _service._proto.name. To accommodate services
publishing SRV records under non-standard names, if both service
and proto are empty strings, LookupSRV looks up name directly.
The returned service names are validated to be properly
formatted presentation-format domain names. If the response contains
invalid names, those records are filtered out and an error
will be returned alongside the remaining results, if any.</p>
               
               <pre><code>func LookupSRV(service string, proto string, name string) (cname string, addrs []*SRV, err error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupSRV">
               <h3>
                  LookupSRV 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupSRV tries to resolve an [SRV] query of the given service,
protocol, and domain name. The proto is "tcp" or "udp".
The returned records are sorted by priority and randomized
by weight within a priority.
LookupSRV constructs the DNS name to look up following RFC 2782.
That is, it looks up _service._proto.name. To accommodate services
publishing SRV records under non-standard names, if both service
and proto are empty strings, LookupSRV looks up name directly.
The returned service names are validated to be properly
formatted presentation-format domain names. If the response contains
invalid names, those records are filtered out and an error
will be returned alongside the remaining results, if any.</p>
               
               <pre><code>func (r *Resolver) LookupSRV(ctx context.Context, service string, proto string, name string) (string, []*SRV, error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupTXT">
               <h3>
                  LookupTXT 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LookupTXT returns the DNS TXT records for the given domain name.
If a DNS TXT record holds multiple strings, they are concatenated as a
single string.
LookupTXT uses [context.Background] internally; to specify the context, use
[Resolver.LookupTXT].</p>
               
               <pre><code>func LookupTXT(name string) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="LookupTXT">
               <h3>
                  LookupTXT 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupTXT returns the DNS TXT records for the given domain name.
If a DNS TXT record holds multiple strings, they are concatenated as a
single string.</p>
               
               <pre><code>func (r *Resolver) LookupTXT(ctx context.Context, name string) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarshalText implements the [encoding.TextMarshaler] interface.
The encoding is the same as returned by [IP.String], with one exception:
When len(ip) is zero, it returns an empty slice.</p>
               
               <pre><code>func (ip IP) MarshalText() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Mask">
               <h3>
                  Mask 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Mask returns the result of masking the IP address ip with mask.</p>
               
               <pre><code>func (ip IP) Mask(mask IPMask) IP</code></pre>
            </article>
            
            <article class="function" data-name="MulticastAddrs">
               <h3>
                  MulticastAddrs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MulticastAddrs returns a list of multicast, joined group addresses
for a specific interface.</p>
               
               <pre><code>func (ifi *Interface) MulticastAddrs() ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="MultipathTCP">
               <h3>
                  MultipathTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MultipathTCP reports whether MPTCP will be used.
This method doesn't check if MPTCP is supported by the operating
system or not.</p>
               
               <pre><code>func (d *Dialer) MultipathTCP() bool</code></pre>
            </article>
            
            <article class="function" data-name="MultipathTCP">
               <h3>
                  MultipathTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MultipathTCP reports whether the ongoing connection is using MPTCP.
If Multipath TCP is not supported by the host, by the other peer or
intentionally / accidentally filtered out by a device in between, a
fallback to TCP will be done. This method does its best to check if
MPTCP is still being used or not.
On Linux, more conditions are verified on kernels >= v5.16, improving
the results.</p>
               
               <pre><code>func (c *TCPConn) MultipathTCP() (bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="MultipathTCP">
               <h3>
                  MultipathTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MultipathTCP reports whether MPTCP will be used.
This method doesn't check if MPTCP is supported by the operating
system or not.</p>
               
               <pre><code>func (lc *ListenConfig) MultipathTCP() bool</code></pre>
            </article>
            
            <article class="function" data-name="Network">
               <h3>
                  Network 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Network returns the address's network name, "ip".</p>
               
               <pre><code>func (a *IPAddr) Network() string</code></pre>
            </article>
            
            <article class="function" data-name="Network">
               <h3>
                  Network 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pipeAddr) Network() string</code></pre>
            </article>
            
            <article class="function" data-name="Network">
               <h3>
                  Network 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Network returns the address's network name, "udp".</p>
               
               <pre><code>func (a *UDPAddr) Network() string</code></pre>
            </article>
            
            <article class="function" data-name="Network">
               <h3>
                  Network 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (unknownAddr) Network() string</code></pre>
            </article>
            
            <article class="function" data-name="Network">
               <h3>
                  Network 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Network returns the address's network name, "tcp".</p>
               
               <pre><code>func (a *TCPAddr) Network() string</code></pre>
            </article>
            
            <article class="function" data-name="Network">
               <h3>
                  Network 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Network returns the address's network name, "unix", "unixgram" or
"unixpacket".</p>
               
               <pre><code>func (a *UnixAddr) Network() string</code></pre>
            </article>
            
            <article class="function" data-name="Network">
               <h3>
                  Network 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Network returns the address's network name, "ip+net".</p>
               
               <pre><code>func (n *IPNet) Network() string</code></pre>
            </article>
            
            <article class="function" data-name="Network">
               <h3>
                  Network 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (addrPortUDPAddr) Network() string</code></pre>
            </article>
            
            <article class="function" data-name="Network">
               <h3>
                  Network 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fileAddr) Network() string</code></pre>
            </article>
            
            <article class="function" data-name="Network">
               <h3>
                  Network 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Network returns the network type of the underlying connection.
Other packages in std that import internal/poll and are unable to
import net (such as os) can use a type assertion to access this
extension method so that they can distinguish different socket types.
Network is not intended for use outside the standard library.</p>
               
               <pre><code>func (c *rawConn) Network() poll.String</code></pre>
            </article>
            
            <article class="function" data-name="ParseCIDR">
               <h3>
                  ParseCIDR 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseCIDR parses s as a CIDR notation IP address and prefix length,
like "192.0.2.0/24" or "2001:db8::/32", as defined in
RFC 4632 and RFC 4291.
It returns the IP address and the network implied by the IP and
prefix length.
For example, ParseCIDR("192.0.2.1/24") returns the IP address
192.0.2.1 and the network 192.0.2.0/24.</p>
               
               <pre><code>func ParseCIDR(s string) (IP, *IPNet, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseIP">
               <h3>
                  ParseIP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseIP parses s as an IP address, returning the result.
The string s can be in IPv4 dotted decimal ("192.0.2.1"), IPv6
("2001:db8::68"), or IPv4-mapped IPv6 ("::ffff:192.0.2.1") form.
If s is not a valid textual representation of an IP address,
ParseIP returns nil. The returned address is always 16 bytes,
IPv4 addresses are returned in IPv4-mapped IPv6 form.</p>
               
               <pre><code>func ParseIP(s string) IP</code></pre>
            </article>
            
            <article class="function" data-name="ParseMAC">
               <h3>
                  ParseMAC 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet
IP over InfiniBand link-layer address using one of the following formats:
00:00:5e:00:53:01
02:00:5e:10:00:00:00:01
00:00:00:00:fe:80:00:00:00:00:00:00:02:00:5e:10:00:00:00:01
00-00-5e-00-53-01
02-00-5e-10-00-00-00-01
00-00-00-00-fe-80-00-00-00-00-00-00-02-00-5e-10-00-00-00-01
0000.5e00.5301
0200.5e10.0000.0001
0000.0000.fe80.0000.0000.0000.0200.5e10.0000.0001</p>
               
               <pre><code>func ParseMAC(s string) (hw HardwareAddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Pipe">
               <h3>
                  Pipe 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Pipe creates a synchronous, in-memory, full duplex
network connection; both ends implement the [Conn] interface.
Reads on one end are matched with writes on the other,
copying data directly between the two; there is no internal
buffering.</p>
               
               <pre><code>func Pipe() (Conn, Conn)</code></pre>
            </article>
            
            <article class="function" data-name="PollFD">
               <h3>
                  PollFD 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PollFD returns the poll.FD of the underlying connection.
Other packages in std that also import [internal/poll] (such as os)
can use a type assertion to access this extension method so that
they can pass the *poll.FD to functions like poll.Splice.
PollFD is not intended for use outside the standard library.</p>
               
               <pre><code>func (c *rawConn) PollFD() *poll.FD</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pipe) Read(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *rawConn) Read(f func(uintptr) bool) error</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) Read(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Read from the buffers.
Read implements [io.Reader] for [Buffers].
Read modifies the slice v as well as v[i] for 0 <= i < len(v),
but does not modify v[i][j] for any i, j.</p>
               
               <pre><code>func (v *Buffers) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *rawListener) Read(func(uintptr) bool) error</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Read implements the Conn Read method.</p>
               
               <pre><code>func (c *conn) Read(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadFrom implements the [PacketConn] ReadFrom method.</p>
               
               <pre><code>func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadFrom implements the [PacketConn] ReadFrom method.</p>
               
               <pre><code>func (c *UnixConn) ReadFrom(b []byte) (int, Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadFrom implements the [io.ReaderFrom] ReadFrom method.</p>
               
               <pre><code>func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadFrom implements the [PacketConn] ReadFrom method.</p>
               
               <pre><code>func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadFrom hides another ReadFrom method.
It should never be called.</p>
               
               <pre><code>func (noReadFrom) ReadFrom(io.Reader) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFromIP">
               <h3>
                  ReadFromIP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadFromIP acts like ReadFrom but returns an IPAddr.</p>
               
               <pre><code>func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFromUDP">
               <h3>
                  ReadFromUDP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadFromUDP acts like [UDPConn.ReadFrom] but returns a UDPAddr.</p>
               
               <pre><code>func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFromUDPAddrPort">
               <h3>
                  ReadFromUDPAddrPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadFromUDPAddrPort acts like ReadFrom but returns a [netip.AddrPort].
If c is bound to an unspecified address, the returned
netip.AddrPort's address might be an IPv4-mapped IPv6 address.
Use [netip.Addr.Unmap] to get the address without the IPv6 prefix.</p>
               
               <pre><code>func (c *UDPConn) ReadFromUDPAddrPort(b []byte) (n int, addr netip.AddrPort, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFromUnix">
               <h3>
                  ReadFromUnix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadFromUnix acts like [UnixConn.ReadFrom] but returns a [UnixAddr].</p>
               
               <pre><code>func (c *UnixConn) ReadFromUnix(b []byte) (int, *UnixAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadMsgIP">
               <h3>
                  ReadMsgIP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadMsgIP reads a message from c, copying the payload into b and
the associated out-of-band data into oob. It returns the number of
bytes copied into b, the number of bytes copied into oob, the flags
that were set on the message and the source address of the message.
The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be
used to manipulate IP-level socket options in oob.</p>
               
               <pre><code>func (c *IPConn) ReadMsgIP(b []byte, oob []byte) (n int, oobn int, flags int, addr *IPAddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadMsgUDP">
               <h3>
                  ReadMsgUDP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadMsgUDP reads a message from c, copying the payload into b and
the associated out-of-band data into oob. It returns the number of
bytes copied into b, the number of bytes copied into oob, the flags
that were set on the message and the source address of the message.
The packages [golang.org/x/net/ipv4] and [golang.org/x/net/ipv6] can be
used to manipulate IP-level socket options in oob.</p>
               
               <pre><code>func (c *UDPConn) ReadMsgUDP(b []byte, oob []byte) (n int, oobn int, flags int, addr *UDPAddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadMsgUDPAddrPort">
               <h3>
                  ReadMsgUDPAddrPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadMsgUDPAddrPort is like [UDPConn.ReadMsgUDP] but returns an [netip.AddrPort] instead of a [UDPAddr].</p>
               
               <pre><code>func (c *UDPConn) ReadMsgUDPAddrPort(b []byte, oob []byte) (n int, oobn int, flags int, addr netip.AddrPort, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadMsgUnix">
               <h3>
                  ReadMsgUnix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadMsgUnix reads a message from c, copying the payload into b and
the associated out-of-band data into oob. It returns the number of
bytes copied into b, the number of bytes copied into oob, the flags
that were set on the message and the source address of the message.
Note that if len(b) == 0 and len(oob) > 0, this function will still
read (and discard) 1 byte from the connection.</p>
               
               <pre><code>func (c *UnixConn) ReadMsgUnix(b []byte, oob []byte) (n int, oobn int, flags int, addr *UnixAddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="RemoteAddr">
               <h3>
                  RemoteAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RemoteAddr returns the remote network address.
The Addr returned is shared by all invocations of RemoteAddr, so
do not modify it.</p>
               
               <pre><code>func (c *conn) RemoteAddr() Addr</code></pre>
            </article>
            
            <article class="function" data-name="RemoteAddr">
               <h3>
                  RemoteAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*pipe) RemoteAddr() Addr</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reset attempts to reset the timer.
If the timer has already expired, Reset returns false.</p>
               
               <pre><code>func (dt *deadlineTimer) Reset(deadline time.Time) bool</code></pre>
            </article>
            
            <article class="function" data-name="ResolveIPAddr">
               <h3>
                  ResolveIPAddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ResolveIPAddr returns an address of IP end point.
The network must be an IP network name.
If the host in the address parameter is not a literal IP address,
ResolveIPAddr resolves the address to an address of IP end point.
Otherwise, it parses the address as a literal IP address.
The address parameter can use a host name, but this is not
recommended, because it will return at most one of the host name's
IP addresses.
See func [Dial] for a description of the network and address
parameters.</p>
               
               <pre><code>func ResolveIPAddr(network string, address string) (*IPAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="ResolveTCPAddr">
               <h3>
                  ResolveTCPAddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ResolveTCPAddr returns an address of TCP end point.
The network must be a TCP network name.
If the host in the address parameter is not a literal IP address or
the port is not a literal port number, ResolveTCPAddr resolves the
address to an address of TCP end point.
Otherwise, it parses the address as a pair of literal IP address
and port number.
The address parameter can use a host name, but this is not
recommended, because it will return at most one of the host name's
IP addresses.
See func [Dial] for a description of the network and address
parameters.</p>
               
               <pre><code>func ResolveTCPAddr(network string, address string) (*TCPAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="ResolveUDPAddr">
               <h3>
                  ResolveUDPAddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ResolveUDPAddr returns an address of UDP end point.
The network must be a UDP network name.
If the host in the address parameter is not a literal IP address or
the port is not a literal port number, ResolveUDPAddr resolves the
address to an address of UDP end point.
Otherwise, it parses the address as a pair of literal IP address
and port number.
The address parameter can use a host name, but this is not
recommended, because it will return at most one of the host name's
IP addresses.
See func [Dial] for a description of the network and address
parameters.</p>
               
               <pre><code>func ResolveUDPAddr(network string, address string) (*UDPAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="ResolveUnixAddr">
               <h3>
                  ResolveUnixAddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ResolveUnixAddr returns an address of Unix domain socket end point.
The network must be a Unix network name.
See func [Dial] for a description of the network and address
parameters.</p>
               
               <pre><code>func ResolveUnixAddr(network string, address string) (*UnixAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="SetDeadline">
               <h3>
                  SetDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) SetDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetDeadline">
               <h3>
                  SetDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetDeadline sets the deadline associated with the listener.
A zero time value disables the deadline.</p>
               
               <pre><code>func (l *TCPListener) SetDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetDeadline">
               <h3>
                  SetDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) SetDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetDeadline">
               <h3>
                  SetDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetDeadline implements the Conn SetDeadline method.</p>
               
               <pre><code>func (c *conn) SetDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetDeadline">
               <h3>
                  SetDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) SetDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetDeadline">
               <h3>
                  SetDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) SetDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetDeadline">
               <h3>
                  SetDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetDeadline sets the deadline associated with the listener.
A zero time value disables the deadline.</p>
               
               <pre><code>func (l *UnixListener) SetDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetDeadline">
               <h3>
                  SetDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pipe) SetDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetKeepAlive">
               <h3>
                  SetKeepAlive 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetKeepAlive sets whether the operating system should send
keep-alive messages on the connection.</p>
               
               <pre><code>func (c *TCPConn) SetKeepAlive(keepalive bool) error</code></pre>
            </article>
            
            <article class="function" data-name="SetKeepAliveConfig">
               <h3>
                  SetKeepAliveConfig 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetKeepAliveConfig configures keep-alive messages sent by the operating system.</p>
               
               <pre><code>func (c *TCPConn) SetKeepAliveConfig(config KeepAliveConfig) error</code></pre>
            </article>
            
            <article class="function" data-name="SetKeepAliveConfig">
               <h3>
                  SetKeepAliveConfig 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetKeepAliveConfig configures keep-alive messages sent by the operating system.</p>
               
               <pre><code>func (c *TCPConn) SetKeepAliveConfig(config KeepAliveConfig) error</code></pre>
            </article>
            
            <article class="function" data-name="SetKeepAliveConfig">
               <h3>
                  SetKeepAliveConfig 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetKeepAliveConfig configures keep-alive messages sent by the operating system.</p>
               
               <pre><code>func (c *TCPConn) SetKeepAliveConfig(config KeepAliveConfig) error</code></pre>
            </article>
            
            <article class="function" data-name="SetKeepAlivePeriod">
               <h3>
                  SetKeepAlivePeriod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetKeepAlivePeriod sets the duration the connection needs to
remain idle before TCP starts sending keepalive probes.
Note that calling this method on Windows prior to Windows 10 version 1709
will reset the KeepAliveInterval to the default system value, which is normally 1 second.</p>
               
               <pre><code>func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="SetLinger">
               <h3>
                  SetLinger 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetLinger sets the behavior of Close on a connection which still
has data waiting to be sent or to be acknowledged.
If sec < 0 (the default), the operating system finishes sending the
data in the background.
If sec == 0, the operating system discards any unsent or
unacknowledged data.
If sec > 0, the data is sent in the background as with sec < 0.
On some operating systems including Linux, this may cause Close to block
until all data has been sent or discarded.
On some operating systems after sec seconds have elapsed any remaining
unsent data may be discarded.</p>
               
               <pre><code>func (c *TCPConn) SetLinger(sec int) error</code></pre>
            </article>
            
            <article class="function" data-name="SetMultipathTCP">
               <h3>
                  SetMultipathTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetMultipathTCP directs the [Listen] method to use, or not use, MPTCP,
if supported by the operating system. This method overrides the
system default and the GODEBUG=multipathtcp=... setting if any.
If MPTCP is not available on the host or not supported by the client,
the Listen method will fall back to TCP.</p>
               
               <pre><code>func (lc *ListenConfig) SetMultipathTCP(use bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetMultipathTCP">
               <h3>
                  SetMultipathTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetMultipathTCP directs the [Dial] methods to use, or not use, MPTCP,
if supported by the operating system. This method overrides the
system default and the GODEBUG=multipathtcp=... setting if any.
If MPTCP is not available on the host or not supported by the server,
the Dial methods will fall back to TCP.</p>
               
               <pre><code>func (d *Dialer) SetMultipathTCP(use bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetNoDelay">
               <h3>
                  SetNoDelay 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetNoDelay controls whether the operating system should delay
packet transmission in hopes of sending fewer packets (Nagle's
algorithm).  The default is true (no delay), meaning that data is
sent as soon as possible after a Write.</p>
               
               <pre><code>func (c *TCPConn) SetNoDelay(noDelay bool) error</code></pre>
            </article>
            
            <article class="function" data-name="SetReadBuffer">
               <h3>
                  SetReadBuffer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetReadBuffer sets the size of the operating system's
receive buffer associated with the connection.</p>
               
               <pre><code>func (c *conn) SetReadBuffer(bytes int) error</code></pre>
            </article>
            
            <article class="function" data-name="SetReadDeadline">
               <h3>
                  SetReadDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) SetReadDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetReadDeadline">
               <h3>
                  SetReadDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetReadDeadline implements the Conn SetReadDeadline method.</p>
               
               <pre><code>func (c *conn) SetReadDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetReadDeadline">
               <h3>
                  SetReadDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pipe) SetReadDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetReadDeadline">
               <h3>
                  SetReadDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) SetReadDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetReadDeadline">
               <h3>
                  SetReadDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) SetReadDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetReadDeadline">
               <h3>
                  SetReadDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) SetReadDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetUnlinkOnClose">
               <h3>
                  SetUnlinkOnClose 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetUnlinkOnClose sets whether the underlying socket file should be removed
from the file system when the listener is closed.
The default behavior is to unlink the socket file only when package net created it.
That is, when the listener and the underlying socket file were created by a call to
Listen or ListenUnix, then by default closing the listener will remove the socket file.
but if the listener was created by a call to FileListener to use an already existing
socket file, then by default closing the listener will not remove the socket file.</p>
               
               <pre><code>func (l *UnixListener) SetUnlinkOnClose(unlink bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetWriteBuffer">
               <h3>
                  SetWriteBuffer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetWriteBuffer sets the size of the operating system's
transmit buffer associated with the connection.</p>
               
               <pre><code>func (c *conn) SetWriteBuffer(bytes int) error</code></pre>
            </article>
            
            <article class="function" data-name="SetWriteDeadline">
               <h3>
                  SetWriteDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetWriteDeadline implements the Conn SetWriteDeadline method.</p>
               
               <pre><code>func (c *conn) SetWriteDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetWriteDeadline">
               <h3>
                  SetWriteDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pipe) SetWriteDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetWriteDeadline">
               <h3>
                  SetWriteDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) SetWriteDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetWriteDeadline">
               <h3>
                  SetWriteDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) SetWriteDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetWriteDeadline">
               <h3>
                  SetWriteDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) SetWriteDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetWriteDeadline">
               <h3>
                  SetWriteDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) SetWriteDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Size returns the number of leading ones and total bits in the mask.
If the mask is not in the canonical form--ones followed by zeros--then
Size returns 0, 0.</p>
               
               <pre><code>func (m IPMask) Size() (ones int, bits int)</code></pre>
            </article>
            
            <article class="function" data-name="SplitHostPort">
               <h3>
                  SplitHostPort 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SplitHostPort splits a network address of the form "host:port",
"host%zone:port", "[host]:port" or "[host%zone]:port" into host or
host%zone and port.
A literal IPv6 address in hostport must be enclosed in square
brackets, as in "[::1]:80", "[::1%lo0]:80".
See func Dial for a description of the hostport parameter, and host
and port results.</p>
               
               <pre><code>func SplitHostPort(hostport string) (host string, port string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *IPAddr) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f Flags) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *TCPAddr) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a HardwareAddr) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *UDPAddr) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o hostLookupOrder) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (unknownAddr) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the CIDR notation of n like "192.0.2.0/24"
or "2001:db8::/48" as defined in RFC 4632 and RFC 4291.
If the mask is not in the canonical form, it returns the
string which consists of an IP address, followed by a slash
character and a mask expressed as hexadecimal form with no
punctuation like "198.51.100.0/c000ff00".</p>
               
               <pre><code>func (n *IPNet) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *UnixAddr) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the string form of the IP address ip.
It returns one of 4 forms:
- "<nil>", if ip has length 0
- dotted decimal ("192.0.2.1"), if ip is an IPv4 or IP4-mapped IPv6 address
- IPv6 conforming to RFC 5952 ("2001:db8::1"), if ip is a valid IPv6 address
- the hexadecimal form of ip, without punctuation, if no other cases apply</p>
               
               <pre><code>func (ip IP) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f fileAddr) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pipeAddr) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the hexadecimal form of m, with no punctuation.</p>
               
               <pre><code>func (m IPMask) String() string</code></pre>
            </article>
            
            <article class="function" data-name="SyscallConn">
               <h3>
                  SyscallConn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SyscallConn returns a raw network connection.
This implements the [syscall.Conn] interface.
The returned RawConn only supports calling Control. Read and
Write return an error.</p>
               
               <pre><code>func (l *UnixListener) SyscallConn() (syscall.RawConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="SyscallConn">
               <h3>
                  SyscallConn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SyscallConn returns a raw network connection.
This implements the [syscall.Conn] interface.</p>
               
               <pre><code>func (c *IPConn) SyscallConn() (syscall.RawConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="SyscallConn">
               <h3>
                  SyscallConn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SyscallConn returns a raw network connection.
This implements the [syscall.Conn] interface.</p>
               
               <pre><code>func (c *UnixConn) SyscallConn() (syscall.RawConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="SyscallConn">
               <h3>
                  SyscallConn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SyscallConn returns a raw network connection.
This implements the [syscall.Conn] interface.</p>
               
               <pre><code>func (c *TCPConn) SyscallConn() (syscall.RawConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="SyscallConn">
               <h3>
                  SyscallConn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SyscallConn returns a raw network connection.
This implements the [syscall.Conn] interface.
The returned RawConn only supports calling Control. Read and
Write return an error.</p>
               
               <pre><code>func (l *TCPListener) SyscallConn() (syscall.RawConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="SyscallConn">
               <h3>
                  SyscallConn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SyscallConn returns a raw network connection.
This implements the [syscall.Conn] interface.</p>
               
               <pre><code>func (c *UDPConn) SyscallConn() (syscall.RawConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="TCPAddrFromAddrPort">
               <h3>
                  TCPAddrFromAddrPort 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TCPAddrFromAddrPort returns addr as a [TCPAddr]. If addr.IsValid() is false,
then the returned TCPAddr will contain a nil IP field, indicating an
address family-agnostic unspecified address.</p>
               
               <pre><code>func TCPAddrFromAddrPort(addr netip.AddrPort) *TCPAddr</code></pre>
            </article>
            
            <article class="function" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e UnknownNetworkError) Temporary() bool</code></pre>
            </article>
            
            <article class="function" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e InvalidAddrError) Temporary() bool</code></pre>
            </article>
            
            <article class="function" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ParseError) Temporary() bool</code></pre>
            </article>
            
            <article class="function" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *AddrError) Temporary() bool</code></pre>
            </article>
            
            <article class="function" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (eai addrinfoErrno) Temporary() bool</code></pre>
            </article>
            
            <article class="function" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Temporary reports whether the DNS error is known to be temporary.
This is not always known; a DNS lookup may fail due to a temporary
error and return a [DNSError] for which Temporary returns false.</p>
               
               <pre><code>func (e *DNSError) Temporary() bool</code></pre>
            </article>
            
            <article class="function" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *DNSConfigError) Temporary() bool</code></pre>
            </article>
            
            <article class="function" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *OpError) Temporary() bool</code></pre>
            </article>
            
            <article class="function" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *timeoutError) Temporary() bool</code></pre>
            </article>
            
            <article class="function" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *temporaryError) Temporary() bool</code></pre>
            </article>
            
            <article class="function" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ParseError) Timeout() bool</code></pre>
            </article>
            
            <article class="function" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e InvalidAddrError) Timeout() bool</code></pre>
            </article>
            
            <article class="function" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *temporaryError) Timeout() bool</code></pre>
            </article>
            
            <article class="function" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *OpError) Timeout() bool</code></pre>
            </article>
            
            <article class="function" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (eai addrinfoErrno) Timeout() bool</code></pre>
            </article>
            
            <article class="function" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Timeout reports whether the DNS lookup is known to have timed out.
This is not always known; a DNS lookup may fail due to a timeout
and return a [DNSError] for which Timeout returns false.</p>
               
               <pre><code>func (e *DNSError) Timeout() bool</code></pre>
            </article>
            
            <article class="function" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e UnknownNetworkError) Timeout() bool</code></pre>
            </article>
            
            <article class="function" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *DNSConfigError) Timeout() bool</code></pre>
            </article>
            
            <article class="function" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *timeoutError) Timeout() bool</code></pre>
            </article>
            
            <article class="function" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *AddrError) Timeout() bool</code></pre>
            </article>
            
            <article class="function" data-name="To16">
               <h3>
                  To16 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>To16 converts the IP address ip to a 16-byte representation.
If ip is not an IP address (it is the wrong length), To16 returns nil.</p>
               
               <pre><code>func (ip IP) To16() IP</code></pre>
            </article>
            
            <article class="function" data-name="To4">
               <h3>
                  To4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>To4 converts the IPv4 address ip to a 4-byte representation.
If ip is not an IPv4 address, To4 returns nil.</p>
               
               <pre><code>func (ip IP) To4() IP</code></pre>
            </article>
            
            <article class="function" data-name="UDPAddrFromAddrPort">
               <h3>
                  UDPAddrFromAddrPort 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>UDPAddrFromAddrPort returns addr as a [UDPAddr]. If addr.IsValid() is false,
then the returned UDPAddr will contain a nil IP field, indicating an
address family-agnostic unspecified address.</p>
               
               <pre><code>func UDPAddrFromAddrPort(addr netip.AddrPort) *UDPAddr</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalText">
               <h3>
                  UnmarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnmarshalText implements the [encoding.TextUnmarshaler] interface.
The IP address is expected in a form accepted by [ParseIP].</p>
               
               <pre><code>func (ip *IP) UnmarshalText(text []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Unwrap returns e.UnwrapErr.</p>
               
               <pre><code>func (e *DNSError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *DNSConfigError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *OpError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Value performs a lookup if the original context hasn't expired.</p>
               
               <pre><code>func (ovc *onlyValuesCtx) Value(key any) any</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write implements the Conn Write method.</p>
               
               <pre><code>func (c *conn) Write(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pipe) Write(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) Write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) Write(p []byte) (nn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) Write(p []byte) (nn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) Write(p []byte) (nn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *rawConn) Write(f func(uintptr) bool) error</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *rawListener) Write(func(uintptr) bool) error</code></pre>
            </article>
            
            <article class="function" data-name="WriteMsgIP">
               <h3>
                  WriteMsgIP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteMsgIP writes a message to addr via c, copying the payload from
b and the associated out-of-band data from oob. It returns the
number of payload and out-of-band bytes written.
The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be
used to manipulate IP-level socket options in oob.</p>
               
               <pre><code>func (c *IPConn) WriteMsgIP(b []byte, oob []byte, addr *IPAddr) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteMsgUDP">
               <h3>
                  WriteMsgUDP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteMsgUDP writes a message to addr via c if c isn't connected, or
to c's remote address if c is connected (in which case addr must be
nil). The payload is copied from b and the associated out-of-band
data is copied from oob. It returns the number of payload and
out-of-band bytes written.
The packages [golang.org/x/net/ipv4] and [golang.org/x/net/ipv6] can be
used to manipulate IP-level socket options in oob.</p>
               
               <pre><code>func (c *UDPConn) WriteMsgUDP(b []byte, oob []byte, addr *UDPAddr) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteMsgUDPAddrPort">
               <h3>
                  WriteMsgUDPAddrPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteMsgUDPAddrPort is like [UDPConn.WriteMsgUDP] but takes a [netip.AddrPort] instead of a [UDPAddr].</p>
               
               <pre><code>func (c *UDPConn) WriteMsgUDPAddrPort(b []byte, oob []byte, addr netip.AddrPort) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteMsgUnix">
               <h3>
                  WriteMsgUnix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteMsgUnix writes a message to addr via c, copying the payload
from b and the associated out-of-band data from oob. It returns the
number of payload and out-of-band bytes written.
Note that if len(b) == 0 and len(oob) > 0, this function will still
write 1 byte to the connection.</p>
               
               <pre><code>func (c *UnixConn) WriteMsgUnix(b []byte, oob []byte, addr *UnixAddr) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteTo implements the [PacketConn] WriteTo method.</p>
               
               <pre><code>func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteTo implements the [PacketConn] WriteTo method.</p>
               
               <pre><code>func (c *UnixConn) WriteTo(b []byte, addr Addr) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteTo implements the [PacketConn] WriteTo method.</p>
               
               <pre><code>func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteTo writes contents of the buffers to w.
WriteTo implements [io.WriterTo] for [Buffers].
WriteTo modifies the slice v as well as v[i] for 0 <= i < len(v),
but does not modify v[i][j] for any i, j.</p>
               
               <pre><code>func (v *Buffers) WriteTo(w io.Writer) (n int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteTo hides another WriteTo method.
It should never be called.</p>
               
               <pre><code>func (noWriteTo) WriteTo(io.Writer) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteTo implements the io.WriterTo WriteTo method.</p>
               
               <pre><code>func (c *TCPConn) WriteTo(w io.Writer) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteToIP">
               <h3>
                  WriteToIP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteToIP acts like [IPConn.WriteTo] but takes an [IPAddr].</p>
               
               <pre><code>func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteToUDP">
               <h3>
                  WriteToUDP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteToUDP acts like [UDPConn.WriteTo] but takes a [UDPAddr].</p>
               
               <pre><code>func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteToUDPAddrPort">
               <h3>
                  WriteToUDPAddrPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteToUDPAddrPort acts like [UDPConn.WriteTo] but takes a [netip.AddrPort].</p>
               
               <pre><code>func (c *UDPConn) WriteToUDPAddrPort(b []byte, addr netip.AddrPort) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteToUnix">
               <h3>
                  WriteToUnix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteToUnix acts like [UnixConn.WriteTo] but takes a [UnixAddr].</p>
               
               <pre><code>func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="_C_ai_addr">
               <h3>
                  _C_ai_addr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_ai_addr(ai *_C_struct_addrinfo) **_C_struct_sockaddr</code></pre>
            </article>
            
            <article class="function" data-name="_C_ai_addr">
               <h3>
                  _C_ai_addr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_ai_addr(ai *_C_struct_addrinfo) **_C_struct_sockaddr</code></pre>
            </article>
            
            <article class="function" data-name="_C_ai_family">
               <h3>
                  _C_ai_family 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_ai_family(ai *_C_struct_addrinfo) *_C_int</code></pre>
            </article>
            
            <article class="function" data-name="_C_ai_family">
               <h3>
                  _C_ai_family 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_ai_family(ai *_C_struct_addrinfo) *_C_int</code></pre>
            </article>
            
            <article class="function" data-name="_C_ai_flags">
               <h3>
                  _C_ai_flags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_ai_flags(ai *_C_struct_addrinfo) *_C_int</code></pre>
            </article>
            
            <article class="function" data-name="_C_ai_flags">
               <h3>
                  _C_ai_flags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_ai_flags(ai *_C_struct_addrinfo) *_C_int</code></pre>
            </article>
            
            <article class="function" data-name="_C_ai_next">
               <h3>
                  _C_ai_next 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_ai_next(ai *_C_struct_addrinfo) **_C_struct_addrinfo</code></pre>
            </article>
            
            <article class="function" data-name="_C_ai_next">
               <h3>
                  _C_ai_next 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_ai_next(ai *_C_struct_addrinfo) **_C_struct_addrinfo</code></pre>
            </article>
            
            <article class="function" data-name="_C_ai_protocol">
               <h3>
                  _C_ai_protocol 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_ai_protocol(ai *_C_struct_addrinfo) *_C_int</code></pre>
            </article>
            
            <article class="function" data-name="_C_ai_protocol">
               <h3>
                  _C_ai_protocol 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_ai_protocol(ai *_C_struct_addrinfo) *_C_int</code></pre>
            </article>
            
            <article class="function" data-name="_C_ai_socktype">
               <h3>
                  _C_ai_socktype 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_ai_socktype(ai *_C_struct_addrinfo) *_C_int</code></pre>
            </article>
            
            <article class="function" data-name="_C_ai_socktype">
               <h3>
                  _C_ai_socktype 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_ai_socktype(ai *_C_struct_addrinfo) *_C_int</code></pre>
            </article>
            
            <article class="function" data-name="_C_free">
               <h3>
                  _C_free 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_free(p unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="_C_free">
               <h3>
                  _C_free 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_free(p unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="_C_freeaddrinfo">
               <h3>
                  _C_freeaddrinfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_freeaddrinfo(ai *_C_struct_addrinfo)</code></pre>
            </article>
            
            <article class="function" data-name="_C_freeaddrinfo">
               <h3>
                  _C_freeaddrinfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_freeaddrinfo(ai *_C_struct_addrinfo)</code></pre>
            </article>
            
            <article class="function" data-name="_C_gai_strerror">
               <h3>
                  _C_gai_strerror 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_gai_strerror(eai _C_int) string</code></pre>
            </article>
            
            <article class="function" data-name="_C_gai_strerror">
               <h3>
                  _C_gai_strerror 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_gai_strerror(eai _C_int) string</code></pre>
            </article>
            
            <article class="function" data-name="_C_getaddrinfo">
               <h3>
                  _C_getaddrinfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_getaddrinfo(hostname *_C_char, servname *_C_char, hints *_C_struct_addrinfo, res **_C_struct_addrinfo) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="_C_getaddrinfo">
               <h3>
                  _C_getaddrinfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_getaddrinfo(hostname *byte, servname *byte, hints *_C_struct_addrinfo, res **_C_struct_addrinfo) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="_C_malloc">
               <h3>
                  _C_malloc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_malloc(n uintptr) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="_C_malloc">
               <h3>
                  _C_malloc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_malloc(n uintptr) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="_C_res_nclose">
               <h3>
                  _C_res_nclose 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_res_nclose(state *_C_struct___res_state)</code></pre>
            </article>
            
            <article class="function" data-name="_C_res_nclose">
               <h3>
                  _C_res_nclose 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_res_nclose(state *_C_struct___res_state)</code></pre>
            </article>
            
            <article class="function" data-name="_C_res_nclose">
               <h3>
                  _C_res_nclose 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_res_nclose(state *_C_struct___res_state)</code></pre>
            </article>
            
            <article class="function" data-name="_C_res_ninit">
               <h3>
                  _C_res_ninit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_res_ninit(state *_C_struct___res_state) error</code></pre>
            </article>
            
            <article class="function" data-name="_C_res_ninit">
               <h3>
                  _C_res_ninit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_res_ninit(state *_C_struct___res_state) error</code></pre>
            </article>
            
            <article class="function" data-name="_C_res_ninit">
               <h3>
                  _C_res_ninit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_res_ninit(state *_C_struct___res_state) error</code></pre>
            </article>
            
            <article class="function" data-name="_C_res_nsearch">
               <h3>
                  _C_res_nsearch 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_res_nsearch(state *_C_struct___res_state, dname *_C_char, class int, typ int, ans *_C_uchar, anslen int) int</code></pre>
            </article>
            
            <article class="function" data-name="_C_res_nsearch">
               <h3>
                  _C_res_nsearch 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_res_nsearch(state *_C_struct___res_state, dname *_C_char, class int, typ int, ans *_C_char, anslen int) int</code></pre>
            </article>
            
            <article class="function" data-name="_C_res_nsearch">
               <h3>
                  _C_res_nsearch 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _C_res_nsearch(state *_C_struct___res_state, dname *_C_char, class int, typ int, ans *_C_uchar, anslen int) int</code></pre>
            </article>
            
            <article class="function" data-name="absDomainName">
               <h3>
                  absDomainName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>absDomainName returns an absolute domain name which ends with a
trailing dot to match pure Go reverse resolver and all other lookup
routines.
See golang.org/issue/12189.
But we don't want to add dots for local names from /etc/hosts.
It's hard to tell so we settle on the heuristic that names without dots
(like "localhost" or "myhost") do not get trailing dots, but any other
names do.</p>
               
               <pre><code>func absDomainName(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="accept">
               <h3>
                  accept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) accept() (netfd *netFD, err error)</code></pre>
            </article>
            
            <article class="function" data-name="accept">
               <h3>
                  accept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) accept() (*netFD, error)</code></pre>
            </article>
            
            <article class="function" data-name="accept">
               <h3>
                  accept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ln *UnixListener) accept() (*UnixConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="accept">
               <h3>
                  accept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ln *UnixListener) accept() (*UnixConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="accept">
               <h3>
                  accept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) accept() (netfd *netFD, err error)</code></pre>
            </article>
            
            <article class="function" data-name="accept">
               <h3>
                  accept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ln *TCPListener) accept() (*TCPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="accept">
               <h3>
                  accept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) accept(laddr Addr) (*netFD, error)</code></pre>
            </article>
            
            <article class="function" data-name="accept">
               <h3>
                  accept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ln *TCPListener) accept() (*TCPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="acceptPlan9">
               <h3>
                  acceptPlan9 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) acceptPlan9() (nfd *netFD, err error)</code></pre>
            </article>
            
            <article class="function" data-name="acquireSema">
               <h3>
                  acquireSema 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (conf *nsswitchConfig) acquireSema()</code></pre>
            </article>
            
            <article class="function" data-name="acquireThread">
               <h3>
                  acquireThread 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func acquireThread(ctx context.Context) error</code></pre>
            </article>
            
            <article class="function" data-name="adapterAddresses">
               <h3>
                  adapterAddresses 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>adapterAddresses returns a list of IP adapter and address
structures. The structure contains an IP adapter and flattened
multiple IP addresses including unicast, anycast and multicast
addresses.</p>
               
               <pre><code>func adapterAddresses() ([]*windows.IpAdapterAddresses, error)</code></pre>
            </article>
            
            <article class="function" data-name="addrFunc">
               <h3>
                  addrFunc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) addrFunc() (func(syscall.Sockaddr) Addr)</code></pre>
            </article>
            
            <article class="function" data-name="addrLookupOrder">
               <h3>
                  addrLookupOrder 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addrLookupOrder determines which strategy to use to resolve addresses.
The provided Resolver is optional. nil means to not consider its options.
It also returns dnsConfig when it was used to determine the lookup order.</p>
               
               <pre><code>func (c *conf) addrLookupOrder(r *Resolver, addr string) (ret hostLookupOrder, dnsConf *dnsConfig)</code></pre>
            </article>
            
            <article class="function" data-name="addrPortToSockaddrInet4">
               <h3>
                  addrPortToSockaddrInet4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addrPortToSockaddrInet4(ap netip.AddrPort) (syscall.SockaddrInet4, error)</code></pre>
            </article>
            
            <article class="function" data-name="addrPortToSockaddrInet6">
               <h3>
                  addrPortToSockaddrInet6 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addrPortToSockaddrInet6(ap netip.AddrPort) (syscall.SockaddrInet6, error)</code></pre>
            </article>
            
            <article class="function" data-name="addrTable">
               <h3>
                  addrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addrTable(ifi *Interface, msgs []syscall.NetlinkMessage) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="allFF">
               <h3>
                  allFF 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func allFF(b []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="appendTo">
               <h3>
                  appendTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>appendTo appends the string representation of ip to b and returns the expanded b
If len(ip) != IPv4len or IPv6len, it appends nothing.</p>
               
               <pre><code>func (ip IP) appendTo(b []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="assignFakeAddr">
               <h3>
                  assignFakeAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) assignFakeAddr(addr sockaddr) error</code></pre>
            </article>
            
            <article class="function" data-name="avoidDNS">
               <h3>
                  avoidDNS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>avoidDNS reports whether this is a hostname for which we should not
use DNS. Currently this includes only .onion, per RFC 7686. See
golang.org/issue/13705. Does not cover .local names (RFC 6762),
see golang.org/issue/16739.</p>
               
               <pre><code>func avoidDNS(name string) bool</code></pre>
            </article>
            
            <article class="function" data-name="boolint">
               <h3>
                  boolint 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Boolean to int.</p>
               
               <pre><code>func boolint(b bool) int</code></pre>
            </article>
            
            <article class="function" data-name="canUseConnectEx">
               <h3>
                  canUseConnectEx 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>canUseConnectEx reports whether we can use the ConnectEx Windows API call
for the given network type.</p>
               
               <pre><code>func canUseConnectEx(net string) bool</code></pre>
            </article>
            
            <article class="function" data-name="cgoLookupAddrPTR">
               <h3>
                  cgoLookupAddrPTR 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoLookupAddrPTR(addr string, sa *_C_struct_sockaddr, salen _C_socklen_t) (names []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoLookupCNAME">
               <h3>
                  cgoLookupCNAME 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoLookupCNAME(ctx context.Context, name string) (cname string, err error, completed bool)</code></pre>
            </article>
            
            <article class="function" data-name="cgoLookupCNAME">
               <h3>
                  cgoLookupCNAME 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoLookupCNAME(ctx context.Context, name string) (cname string, err error, completed bool)</code></pre>
            </article>
            
            <article class="function" data-name="cgoLookupHost">
               <h3>
                  cgoLookupHost 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoLookupHost(ctx context.Context, name string) (addrs []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoLookupHost">
               <h3>
                  cgoLookupHost 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoLookupHost(ctx context.Context, name string) (hosts []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoLookupHostIP">
               <h3>
                  cgoLookupHostIP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoLookupHostIP(network string, name string) (addrs []IPAddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoLookupIP">
               <h3>
                  cgoLookupIP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoLookupIP(ctx context.Context, network string, name string) (addrs []IPAddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoLookupIP">
               <h3>
                  cgoLookupIP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoLookupIP(ctx context.Context, network string, name string) (addrs []IPAddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoLookupPTR">
               <h3>
                  cgoLookupPTR 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoLookupPTR(ctx context.Context, addr string) (names []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoLookupPTR">
               <h3>
                  cgoLookupPTR 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoLookupPTR(ctx context.Context, addr string) (ptrs []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoLookupPort">
               <h3>
                  cgoLookupPort 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoLookupPort(ctx context.Context, network string, service string) (port int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoLookupPort">
               <h3>
                  cgoLookupPort 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoLookupPort(ctx context.Context, network string, service string) (port int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoLookupServicePort">
               <h3>
                  cgoLookupServicePort 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoLookupServicePort(hints *_C_struct_addrinfo, network string, service string) (port int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoNameinfoPTR">
               <h3>
                  cgoNameinfoPTR 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoNameinfoPTR(b []byte, sa *C.struct_sockaddr, salen C.socklen_t) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoNameinfoPTR">
               <h3>
                  cgoNameinfoPTR 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoNameinfoPTR(b []byte, sa *C.struct_sockaddr, salen C.socklen_t) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoNameinfoPTR">
               <h3>
                  cgoNameinfoPTR 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoNameinfoPTR(b []byte, sa *C.struct_sockaddr, salen C.socklen_t) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoNameinfoPTR">
               <h3>
                  cgoNameinfoPTR 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoNameinfoPTR(b []byte, sa *syscall.RawSockaddr, salen int) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoResSearch">
               <h3>
                  cgoResSearch 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoResSearch(hostname string, rtype int, class int) ([]dnsmessage.Resource, error)</code></pre>
            </article>
            
            <article class="function" data-name="cgoSockaddr">
               <h3>
                  cgoSockaddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoSockaddr(ip IP, zone string) (*_C_struct_sockaddr, _C_socklen_t)</code></pre>
            </article>
            
            <article class="function" data-name="cgoSockaddrInet4">
               <h3>
                  cgoSockaddrInet4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoSockaddrInet4(ip IP) *C.struct_sockaddr</code></pre>
            </article>
            
            <article class="function" data-name="cgoSockaddrInet4">
               <h3>
                  cgoSockaddrInet4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoSockaddrInet4(ip IP) *syscall.RawSockaddr</code></pre>
            </article>
            
            <article class="function" data-name="cgoSockaddrInet4">
               <h3>
                  cgoSockaddrInet4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoSockaddrInet4(ip IP) *C.struct_sockaddr</code></pre>
            </article>
            
            <article class="function" data-name="cgoSockaddrInet6">
               <h3>
                  cgoSockaddrInet6 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoSockaddrInet6(ip IP, zone int) *C.struct_sockaddr</code></pre>
            </article>
            
            <article class="function" data-name="cgoSockaddrInet6">
               <h3>
                  cgoSockaddrInet6 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoSockaddrInet6(ip IP, zone int) *syscall.RawSockaddr</code></pre>
            </article>
            
            <article class="function" data-name="cgoSockaddrInet6">
               <h3>
                  cgoSockaddrInet6 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cgoSockaddrInet6(ip IP, zone int) *C.struct_sockaddr</code></pre>
            </article>
            
            <article class="function" data-name="checkHeader">
               <h3>
                  checkHeader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkHeader performs basic sanity checks on the header.</p>
               
               <pre><code>func checkHeader(p *dnsmessage.Parser, h dnsmessage.Header) error</code></pre>
            </article>
            
            <article class="function" data-name="checkResponse">
               <h3>
                  checkResponse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func checkResponse(reqID uint16, reqQues dnsmessage.Question, respHdr dnsmessage.Header, respQues dnsmessage.Question) bool</code></pre>
            </article>
            
            <article class="function" data-name="classifyScope">
               <h3>
                  classifyScope 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func classifyScope(ip netip.Addr) scope</code></pre>
            </article>
            
            <article class="function" data-name="clear">
               <h3>
                  clear 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *packet) clear()</code></pre>
            </article>
            
            <article class="function" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ln *TCPListener) close() error</code></pre>
            </article>
            
            <article class="function" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ln *UnixListener) close() error</code></pre>
            </article>
            
            <article class="function" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *file) close()</code></pre>
            </article>
            
            <article class="function" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ln *UnixListener) close() error</code></pre>
            </article>
            
            <article class="function" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ln *TCPListener) close() error</code></pre>
            </article>
            
            <article class="function" data-name="closeRead">
               <h3>
                  closeRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) closeRead() error</code></pre>
            </article>
            
            <article class="function" data-name="closeRead">
               <h3>
                  closeRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) closeRead() error</code></pre>
            </article>
            
            <article class="function" data-name="closeRead">
               <h3>
                  closeRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) closeRead() error</code></pre>
            </article>
            
            <article class="function" data-name="closeRead">
               <h3>
                  closeRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) closeRead() error</code></pre>
            </article>
            
            <article class="function" data-name="closeRead">
               <h3>
                  closeRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) closeRead() error</code></pre>
            </article>
            
            <article class="function" data-name="closeRead">
               <h3>
                  closeRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pq *packetQueue) closeRead() error</code></pre>
            </article>
            
            <article class="function" data-name="closeWrite">
               <h3>
                  closeWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) closeWrite() error</code></pre>
            </article>
            
            <article class="function" data-name="closeWrite">
               <h3>
                  closeWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) closeWrite() error</code></pre>
            </article>
            
            <article class="function" data-name="closeWrite">
               <h3>
                  closeWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) closeWrite() error</code></pre>
            </article>
            
            <article class="function" data-name="closeWrite">
               <h3>
                  closeWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) closeWrite() error</code></pre>
            </article>
            
            <article class="function" data-name="closeWrite">
               <h3>
                  closeWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pq *packetQueue) closeWrite() error</code></pre>
            </article>
            
            <article class="function" data-name="closeWrite">
               <h3>
                  closeWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) closeWrite() error</code></pre>
            </article>
            
            <article class="function" data-name="commonPrefixLen">
               <h3>
                  commonPrefixLen 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>commonPrefixLen reports the length of the longest prefix (looking
at the most significant, or leftmost, bits) that the
two addresses have in common, up to the length of a's prefix (i.e.,
the portion of the address not including the interface ID).
If a or b is an IPv4 address as an IPv6 address, the IPv4 addresses
are compared (with max common prefix length of 32).
If a and b are different IP versions, 0 is returned.
See https://tools.ietf.org/html/rfc6724#section-2.2</p>
               
               <pre><code>func commonPrefixLen(a netip.Addr, b IP) (cpl int)</code></pre>
            </article>
            
            <article class="function" data-name="compareByRFC6724">
               <h3>
                  compareByRFC6724 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>compareByRFC6724 compares two byRFC6724Info records and returns an integer
indicating the order. It follows the algorithm and variable names from
RFC 6724 section 6. Returns -1 if a is preferred, 1 if b is preferred,
and 0 if they are equal.</p>
               
               <pre><code>func compareByRFC6724(a byRFC6724Info, b byRFC6724Info) int</code></pre>
            </article>
            
            <article class="function" data-name="concurrentThreadsLimit">
               <h3>
                  concurrentThreadsLimit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>concurrentThreadsLimit returns the number of threads we permit to
run concurrently doing DNS lookups via cgo. A DNS lookup may use a
file descriptor so we limit this to less than the number of
permitted open files. On some systems, notably Darwin, if
getaddrinfo is unable to open a file descriptor it simply returns
EAI_NONAME rather than a useful error. Limiting the number of
concurrent getaddrinfo calls to less than the permitted number of
file descriptors makes that error less likely. We don't bother to
apply the same limit to DNS lookups run directly from Go, because
there we will return a meaningful "too many open files" error.</p>
               
               <pre><code>func concurrentThreadsLimit() int</code></pre>
            </article>
            
            <article class="function" data-name="concurrentThreadsLimit">
               <h3>
                  concurrentThreadsLimit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>concurrentThreadsLimit returns the number of threads we permit to
run concurrently doing DNS lookups.</p>
               
               <pre><code>func concurrentThreadsLimit() int</code></pre>
            </article>
            
            <article class="function" data-name="concurrentThreadsLimit">
               <h3>
                  concurrentThreadsLimit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>concurrentThreadsLimit returns the number of threads we permit to
run concurrently doing DNS lookups.</p>
               
               <pre><code>func concurrentThreadsLimit() int</code></pre>
            </article>
            
            <article class="function" data-name="concurrentThreadsLimit">
               <h3>
                  concurrentThreadsLimit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>concurrentThreadsLimit returns the number of threads we permit to
run concurrently doing DNS lookups.</p>
               
               <pre><code>func concurrentThreadsLimit() int</code></pre>
            </article>
            
            <article class="function" data-name="connect">
               <h3>
                  connect 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) connect(ctx context.Context, la syscall.Sockaddr, ra syscall.Sockaddr) (rsa syscall.Sockaddr, ret error)</code></pre>
            </article>
            
            <article class="function" data-name="connect">
               <h3>
                  connect 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Always returns nil for connected peer address result.</p>
               
               <pre><code>func (fd *netFD) connect(ctx context.Context, la syscall.Sockaddr, ra syscall.Sockaddr) (syscall.Sockaddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="consume">
               <h3>
                  consume 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *Buffers) consume(n int64)</code></pre>
            </article>
            
            <article class="function" data-name="copyIP">
               <h3>
                  copyIP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func copyIP(x IP) IP</code></pre>
            </article>
            
            <article class="function" data-name="countAnyByte">
               <h3>
                  countAnyByte 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Count occurrences in s of any bytes in t.</p>
               
               <pre><code>func countAnyByte(s string, t string) int</code></pre>
            </article>
            
            <article class="function" data-name="ctrlNetwork">
               <h3>
                  ctrlNetwork 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) ctrlNetwork() string</code></pre>
            </article>
            
            <article class="function" data-name="deadline">
               <h3>
                  deadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>deadline returns the earliest of:
- now+Timeout
- d.Deadline
- the context's deadline
Or zero, if none of Timeout, Deadline, or context's deadline is set.</p>
               
               <pre><code>func (d *Dialer) deadline(ctx context.Context, now time.Time) (earliest time.Time)</code></pre>
            </article>
            
            <article class="function" data-name="destroy">
               <h3>
                  destroy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) destroy()</code></pre>
            </article>
            
            <article class="function" data-name="dial">
               <h3>
                  dial 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>dial makes a new connection to the provided server (which must be
an IP address) with the provided network type, using either r.Dial
(if both r and r.Dial are non-nil) or else Dialer.DialContext.</p>
               
               <pre><code>func (r *Resolver) dial(ctx context.Context, network string, server string) (Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="dial">
               <h3>
                  dial 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) dial(ctx context.Context, laddr sockaddr, raddr sockaddr, ctrlCtxFn func(context.Context, string, string, syscall.RawConn) error) error</code></pre>
            </article>
            
            <article class="function" data-name="dialIP">
               <h3>
                  dialIP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sd *sysDialer) dialIP(ctx context.Context, laddr *IPAddr, raddr *IPAddr) (*IPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="dialIP">
               <h3>
                  dialIP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sd *sysDialer) dialIP(ctx context.Context, laddr *IPAddr, raddr *IPAddr) (*IPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="dialMPTCP">
               <h3>
                  dialMPTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sd *sysDialer) dialMPTCP(ctx context.Context, laddr *TCPAddr, raddr *TCPAddr) (*TCPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="dialMPTCP">
               <h3>
                  dialMPTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sd *sysDialer) dialMPTCP(ctx context.Context, laddr *TCPAddr, raddr *TCPAddr) (*TCPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="dialParallel">
               <h3>
                  dialParallel 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>dialParallel races two copies of dialSerial, giving the first a
head start. It returns the first established connection and
closes the others. Otherwise it returns an error from the first
primary address.</p>
               
               <pre><code>func (sd *sysDialer) dialParallel(ctx context.Context, primaries addrList, fallbacks addrList) (Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="dialPlan9">
               <h3>
                  dialPlan9 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dialPlan9(ctx context.Context, net string, laddr Addr, raddr Addr) (fd *netFD, err error)</code></pre>
            </article>
            
            <article class="function" data-name="dialPlan9Blocking">
               <h3>
                  dialPlan9Blocking 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dialPlan9Blocking(ctx context.Context, net string, laddr Addr, raddr Addr) (fd *netFD, err error)</code></pre>
            </article>
            
            <article class="function" data-name="dialSerial">
               <h3>
                  dialSerial 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>dialSerial connects to a list of addresses in sequence, returning
either the first successful connection, or the first error.</p>
               
               <pre><code>func (sd *sysDialer) dialSerial(ctx context.Context, ras addrList) (Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="dialSingle">
               <h3>
                  dialSingle 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>dialSingle attempts to establish and returns a single connection to
the destination address.</p>
               
               <pre><code>func (sd *sysDialer) dialSingle(ctx context.Context, ra Addr) (c Conn, err error)</code></pre>
            </article>
            
            <article class="function" data-name="dialTCP">
               <h3>
                  dialTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sd *sysDialer) dialTCP(ctx context.Context, laddr *TCPAddr, raddr *TCPAddr) (*TCPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="dialTCP">
               <h3>
                  dialTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sd *sysDialer) dialTCP(ctx context.Context, laddr *TCPAddr, raddr *TCPAddr) (*TCPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="dialUDP">
               <h3>
                  dialUDP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sd *sysDialer) dialUDP(ctx context.Context, laddr *UDPAddr, raddr *UDPAddr) (*UDPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="dialUDP">
               <h3>
                  dialUDP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sd *sysDialer) dialUDP(ctx context.Context, laddr *UDPAddr, raddr *UDPAddr) (*UDPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="dialUnix">
               <h3>
                  dialUnix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sd *sysDialer) dialUnix(ctx context.Context, laddr *UnixAddr, raddr *UnixAddr) (*UnixConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="dialUnix">
               <h3>
                  dialUnix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sd *sysDialer) dialUnix(ctx context.Context, laddr *UnixAddr, raddr *UnixAddr) (*UnixConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="dnsDefaultSearch">
               <h3>
                  dnsDefaultSearch 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dnsDefaultSearch() []string</code></pre>
            </article>
            
            <article class="function" data-name="dnsPacketRoundTrip">
               <h3>
                  dnsPacketRoundTrip 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dnsPacketRoundTrip(c Conn, id uint16, query dnsmessage.Question, b []byte) (dnsmessage.Parser, dnsmessage.Header, error)</code></pre>
            </article>
            
            <article class="function" data-name="dnsReadConfig">
               <h3>
                  dnsReadConfig 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>See resolv.conf(5) on a Linux machine.</p>
               
               <pre><code>func dnsReadConfig(filename string) *dnsConfig</code></pre>
            </article>
            
            <article class="function" data-name="dnsReadConfig">
               <h3>
                  dnsReadConfig 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dnsReadConfig(ignoredFilename string) (conf *dnsConfig)</code></pre>
            </article>
            
            <article class="function" data-name="dnsStreamRoundTrip">
               <h3>
                  dnsStreamRoundTrip 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dnsStreamRoundTrip(c Conn, id uint16, query dnsmessage.Question, b []byte) (dnsmessage.Parser, dnsmessage.Header, error)</code></pre>
            </article>
            
            <article class="function" data-name="doBlockingWithCtx">
               <h3>
                  doBlockingWithCtx 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>doBlockingWithCtx executes a blocking function in a separate goroutine when the provided
context is cancellable. It is intended for use with calls that don't support context
cancellation (cgo, syscalls). blocking func may still be running after this function finishes.
For the duration of the execution of the blocking function, the thread is 'acquired' using [acquireThread],
blocking might not be executed when the context gets canceled early.</p>
               
               <pre><code>func doBlockingWithCtx(ctx context.Context, lookupName string, blocking func() (T, error)) (T, error)</code></pre>
            </article>
            
            <article class="function" data-name="doDialTCP">
               <h3>
                  doDialTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sd *sysDialer) doDialTCP(ctx context.Context, laddr *TCPAddr, raddr *TCPAddr) (*TCPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="doDialTCP">
               <h3>
                  doDialTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sd *sysDialer) doDialTCP(ctx context.Context, laddr *TCPAddr, raddr *TCPAddr) (*TCPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="doDialTCPProto">
               <h3>
                  doDialTCPProto 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sd *sysDialer) doDialTCPProto(ctx context.Context, laddr *TCPAddr, raddr *TCPAddr, proto int) (*TCPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="dtoi">
               <h3>
                  dtoi 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Decimal to integer.
Returns number, characters consumed, success.</p>
               
               <pre><code>func dtoi(s string) (n int, i int, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="dualStack">
               <h3>
                  dualStack 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *Dialer) dualStack() bool</code></pre>
            </article>
            
            <article class="function" data-name="dup">
               <h3>
                  dup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) dup() (f *os.File, err error)</code></pre>
            </article>
            
            <article class="function" data-name="dup">
               <h3>
                  dup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) dup() (*os.File, error)</code></pre>
            </article>
            
            <article class="function" data-name="dup">
               <h3>
                  dup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *TCPListener) dup() (*os.File, error)</code></pre>
            </article>
            
            <article class="function" data-name="dup">
               <h3>
                  dup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>This method is only called via Conn.</p>
               
               <pre><code>func (fd *netFD) dup() (*os.File, error)</code></pre>
            </article>
            
            <article class="function" data-name="dup">
               <h3>
                  dup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) dup() (f *os.File, err error)</code></pre>
            </article>
            
            <article class="function" data-name="dupSocket">
               <h3>
                  dupSocket 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dupSocket(f *os.File) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="ensureRooted">
               <h3>
                  ensureRooted 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ensureRooted(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="equalASCIIName">
               <h3>
                  equalASCIIName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func equalASCIIName(x dnsmessage.Name, y dnsmessage.Name) bool</code></pre>
            </article>
            
            <article class="function" data-name="exchange">
               <h3>
                  exchange 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>exchange sends a query on the connection and hopes for a response.</p>
               
               <pre><code>func (r *Resolver) exchange(ctx context.Context, server string, q dnsmessage.Question, timeout time.Duration, useTCP bool, ad bool) (dnsmessage.Parser, dnsmessage.Header, error)</code></pre>
            </article>
            
            <article class="function" data-name="extractExtendedRCode">
               <h3>
                  extractExtendedRCode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>extractExtendedRCode extracts the extended RCode from the OPT resource (EDNS(0))
If an OPT record is not found, the RCode from the hdr is returned.
Another return value indicates whether an additional resource was found.</p>
               
               <pre><code>func extractExtendedRCode(p dnsmessage.Parser, hdr dnsmessage.Header) (dnsmessage.RCode, bool)</code></pre>
            </article>
            
            <article class="function" data-name="fakeAddr">
               <h3>
                  fakeAddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fakeAddr(sa sockaddr) fakeSockAddr</code></pre>
            </article>
            
            <article class="function" data-name="fakeConnect">
               <h3>
                  fakeConnect 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fakeConnect(ctx context.Context, fd *netFD, laddr sockaddr, raddr sockaddr) error</code></pre>
            </article>
            
            <article class="function" data-name="fakeListen">
               <h3>
                  fakeListen 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fakeListen(fd *netFD, laddr sockaddr) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="fallbackDelay">
               <h3>
                  fallbackDelay 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *Dialer) fallbackDelay() time.Duration</code></pre>
            </article>
            
            <article class="function" data-name="family">
               <h3>
                  family 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *IPAddr) family() int</code></pre>
            </article>
            
            <article class="function" data-name="family">
               <h3>
                  family 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *UnixAddr) family() int</code></pre>
            </article>
            
            <article class="function" data-name="family">
               <h3>
                  family 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *UDPAddr) family() int</code></pre>
            </article>
            
            <article class="function" data-name="family">
               <h3>
                  family 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *TCPAddr) family() int</code></pre>
            </article>
            
            <article class="function" data-name="favoriteAddrFamily">
               <h3>
                  favoriteAddrFamily 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>favoriteAddrFamily returns the appropriate address family for the
given network, laddr, raddr and mode.
If mode indicates "listen" and laddr is a wildcard, we assume that
the user wants to make a passive-open connection with a wildcard
address family, both AF_INET and AF_INET6, and a wildcard address
like the following:
- A listen for a wildcard communication domain, "tcp" or
"udp", with a wildcard address: If the platform supports
both IPv6 and IPv4-mapped IPv6 communication capabilities,
or does not support IPv4, we use a dual stack, AF_INET6 and
IPV6_V6ONLY=0, wildcard address listen. The dual stack
wildcard address listen may fall back to an IPv6-only,
AF_INET6 and IPV6_V6ONLY=1, wildcard address listen.
Otherwise we prefer an IPv4-only, AF_INET, wildcard address
listen.
- A listen for a wildcard communication domain, "tcp" or
"udp", with an IPv4 wildcard address: same as above.
- A listen for a wildcard communication domain, "tcp" or
"udp", with an IPv6 wildcard address: same as above.
- A listen for an IPv4 communication domain, "tcp4" or "udp4",
with an IPv4 wildcard address: We use an IPv4-only, AF_INET,
wildcard address listen.
- A listen for an IPv6 communication domain, "tcp6" or "udp6",
with an IPv6 wildcard address: We use an IPv6-only, AF_INET6
and IPV6_V6ONLY=1, wildcard address listen.
Otherwise guess: If the addresses are IPv4 then returns AF_INET,
or else returns AF_INET6. It also returns a boolean value what
designates IPV6_V6ONLY option.
Note that the latest DragonFly BSD and OpenBSD kernels allow
neither "net.inet6.ip6.v6only=1" change nor IPPROTO_IPV6 level
IPV6_V6ONLY socket option setting.
favoriteAddrFamily should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/database64128/tfo-go/v2
- github.com/metacubex/tfo-go
- github.com/sagernet/tfo-go
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname favoriteAddrFamily</p>
               
               <pre><code>func favoriteAddrFamily(network string, laddr sockaddr, raddr sockaddr, mode string) (family int, ipv6only bool)</code></pre>
            </article>
            
            <article class="function" data-name="fd_fdstat_get_type">
               <h3>
                  fd_fdstat_get_type 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>This helper is implemented in the syscall package. It means we don't have
to redefine the fd_fdstat_get host import or the fdstat struct it
populates.
go:linkname fd_fdstat_get_type syscall.fd_fdstat_get_type</p>
               
               <pre><code>func fd_fdstat_get_type(fd int) (uint8, error)</code></pre>
            </article>
            
            <article class="function" data-name="file">
               <h3>
                  file 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ln *UnixListener) file() (*os.File, error)</code></pre>
            </article>
            
            <article class="function" data-name="file">
               <h3>
                  file 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ln *UnixListener) file() (*os.File, error)</code></pre>
            </article>
            
            <article class="function" data-name="file">
               <h3>
                  file 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ln *TCPListener) file() (*os.File, error)</code></pre>
            </article>
            
            <article class="function" data-name="file">
               <h3>
                  file 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ln *TCPListener) file() (*os.File, error)</code></pre>
            </article>
            
            <article class="function" data-name="file">
               <h3>
                  file 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) file(f *os.File, s string) (*os.File, error)</code></pre>
            </article>
            
            <article class="function" data-name="fileConn">
               <h3>
                  fileConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fileConn(f *os.File) (Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="fileConn">
               <h3>
                  fileConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fileConn(f *os.File) (Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="fileConn">
               <h3>
                  fileConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fileConn(f *os.File) (Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="fileConn">
               <h3>
                  fileConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fileConn(f *os.File) (Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="fileConn">
               <h3>
                  fileConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fileConn(f *os.File) (Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="fileConnNet">
               <h3>
                  fileConnNet 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fileConnNet(filetype syscall.Filetype) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="fileListenNet">
               <h3>
                  fileListenNet 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fileListenNet(filetype syscall.Filetype) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="fileListener">
               <h3>
                  fileListener 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fileListener(f *os.File) (Listener, error)</code></pre>
            </article>
            
            <article class="function" data-name="fileListener">
               <h3>
                  fileListener 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fileListener(f *os.File) (Listener, error)</code></pre>
            </article>
            
            <article class="function" data-name="fileListener">
               <h3>
                  fileListener 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fileListener(f *os.File) (Listener, error)</code></pre>
            </article>
            
            <article class="function" data-name="fileListener">
               <h3>
                  fileListener 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fileListener(f *os.File) (Listener, error)</code></pre>
            </article>
            
            <article class="function" data-name="fileListener">
               <h3>
                  fileListener 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fileListener(f *os.File) (Listener, error)</code></pre>
            </article>
            
            <article class="function" data-name="filePacketConn">
               <h3>
                  filePacketConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func filePacketConn(f *os.File) (PacketConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="filePacketConn">
               <h3>
                  filePacketConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func filePacketConn(f *os.File) (PacketConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="filePacketConn">
               <h3>
                  filePacketConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func filePacketConn(f *os.File) (PacketConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="filePacketConn">
               <h3>
                  filePacketConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func filePacketConn(f *os.File) (PacketConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="filePacketConn">
               <h3>
                  filePacketConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func filePacketConn(f *os.File) (PacketConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="filterAddrList">
               <h3>
                  filterAddrList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>filterAddrList applies a filter to a list of IP addresses,
yielding a list of Addr objects. Known filters are nil, ipv4only,
and ipv6only. It returns every address when the filter is nil.
The result contains at least one address when error is nil.</p>
               
               <pre><code>func filterAddrList(filter func(IPAddr) bool, ips []IPAddr, inetaddr func(IPAddr) Addr, originalAddr string) (addrList, error)</code></pre>
            </article>
            
            <article class="function" data-name="first">
               <h3>
                  first 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>first returns the first address which satisfies strategy, or if
none do, then the first address of any kind.</p>
               
               <pre><code>func (addrs addrList) first(strategy func(Addr) bool) Addr</code></pre>
            </article>
            
            <article class="function" data-name="fixErr">
               <h3>
                  fixErr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fixErr(err error)</code></pre>
            </article>
            
            <article class="function" data-name="forResolve">
               <h3>
                  forResolve 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>forResolve returns the most appropriate address in address for
a call to ResolveTCPAddr, ResolveUDPAddr, or ResolveIPAddr.
IPv4 is preferred, unless addr contains an IPv6 literal.</p>
               
               <pre><code>func (addrs addrList) forResolve(network string, addr string) Addr</code></pre>
            </article>
            
            <article class="function" data-name="foreachField">
               <h3>
                  foreachField 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>foreachField runs fn on each non-empty run of non-space bytes in x.
It returns the first non-nil error returned by fn.</p>
               
               <pre><code>func foreachField(x string, fn func(field string) error) error</code></pre>
            </article>
            
            <article class="function" data-name="genericReadFrom">
               <h3>
                  genericReadFrom 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Fallback implementation of io.ReaderFrom's ReadFrom, when sendfile isn't
applicable.</p>
               
               <pre><code>func genericReadFrom(c *TCPConn, r io.Reader) (n int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="genericWriteTo">
               <h3>
                  genericWriteTo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Fallback implementation of io.WriterTo's WriteTo, when zero-copy isn't applicable.</p>
               
               <pre><code>func genericWriteTo(c *TCPConn, w io.Writer) (n int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="get">
               <h3>
                  get 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pq *packetQueue) get() packetQueueState</code></pre>
            </article>
            
            <article class="function" data-name="get">
               <h3>
                  get 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m *mptcpStatusListen) get() bool</code></pre>
            </article>
            
            <article class="function" data-name="get">
               <h3>
                  get 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m *mptcpStatusDial) get() bool</code></pre>
            </article>
            
            <article class="function" data-name="getFields">
               <h3>
                  getFields 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func getFields(s string) []string</code></pre>
            </article>
            
            <article class="function" data-name="getIfList">
               <h3>
                  getIfList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func getIfList() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="getLineFromData">
               <h3>
                  getLineFromData 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *file) getLineFromData() (s string, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="getLookupGroup">
               <h3>
                  getLookupGroup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) getLookupGroup() *singleflight.Group</code></pre>
            </article>
            
            <article class="function" data-name="getSystemDNSConfig">
               <h3>
                  getSystemDNSConfig 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func getSystemDNSConfig() *dnsConfig</code></pre>
            </article>
            
            <article class="function" data-name="getSystemNSS">
               <h3>
                  getSystemNSS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func getSystemNSS() *nssConf</code></pre>
            </article>
            
            <article class="function" data-name="getprotobyname">
               <h3>
                  getprotobyname 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func getprotobyname(name string) (proto int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="goDebugNetDNS">
               <h3>
                  goDebugNetDNS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>goDebugNetDNS parses the value of the GODEBUG "netdns" value.
The netdns value can be of the form:
1       // debug level 1
2       // debug level 2
cgo     // use cgo for DNS lookups
go      // use go for DNS lookups
cgo+1   // use cgo for DNS lookups + debug level 1
1+cgo   // same
cgo+2   // same, but debug level 2
etc.</p>
               
               <pre><code>func goDebugNetDNS() (dnsMode string, debugLevel int)</code></pre>
            </article>
            
            <article class="function" data-name="goLookupCNAME">
               <h3>
                  goLookupCNAME 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>goLookupCNAME is the native Go (non-cgo) implementation of LookupCNAME.</p>
               
               <pre><code>func (r *Resolver) goLookupCNAME(ctx context.Context, host string, order hostLookupOrder, conf *dnsConfig) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="goLookupHostOrder">
               <h3>
                  goLookupHostOrder 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) goLookupHostOrder(ctx context.Context, name string, order hostLookupOrder, conf *dnsConfig) (addrs []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="goLookupIP">
               <h3>
                  goLookupIP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>goLookupIP is the native Go implementation of LookupIP.
The libc versions are in cgo_*.go.</p>
               
               <pre><code>func (r *Resolver) goLookupIP(ctx context.Context, network string, host string, order hostLookupOrder, conf *dnsConfig) (addrs []IPAddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="goLookupIPCNAMEOrder">
               <h3>
                  goLookupIPCNAMEOrder 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) goLookupIPCNAMEOrder(ctx context.Context, network string, name string, order hostLookupOrder, conf *dnsConfig) (addrs []IPAddr, cname dnsmessage.Name, err error)</code></pre>
            </article>
            
            <article class="function" data-name="goLookupIPFiles">
               <h3>
                  goLookupIPFiles 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lookup entries from /etc/hosts</p>
               
               <pre><code>func goLookupIPFiles(name string) (addrs []IPAddr, canonical string)</code></pre>
            </article>
            
            <article class="function" data-name="goLookupMX">
               <h3>
                  goLookupMX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>goLookupMX returns the MX records for name.</p>
               
               <pre><code>func (r *Resolver) goLookupMX(ctx context.Context, name string) ([]*MX, error)</code></pre>
            </article>
            
            <article class="function" data-name="goLookupNS">
               <h3>
                  goLookupNS 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>goLookupNS returns the NS records for name.</p>
               
               <pre><code>func (r *Resolver) goLookupNS(ctx context.Context, name string) ([]*NS, error)</code></pre>
            </article>
            
            <article class="function" data-name="goLookupPTR">
               <h3>
                  goLookupPTR 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>goLookupPTR is the native Go implementation of LookupAddr.</p>
               
               <pre><code>func (r *Resolver) goLookupPTR(ctx context.Context, addr string, order hostLookupOrder, conf *dnsConfig) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="goLookupPort">
               <h3>
                  goLookupPort 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>goLookupPort is the native Go implementation of LookupPort.</p>
               
               <pre><code>func goLookupPort(network string, service string) (port int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="goLookupSRV">
               <h3>
                  goLookupSRV 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>goLookupSRV returns the SRV records for a target name, built either
from its component service ("sip"), protocol ("tcp"), and name
("example.com."), or from name directly (if service and proto are
both empty).
In either case, the returned target name ("_sip._tcp.example.com.")
is also returned on success.
The records are sorted by weight.</p>
               
               <pre><code>func (r *Resolver) goLookupSRV(ctx context.Context, service string, proto string, name string) (target string, srvs []*SRV, err error)</code></pre>
            </article>
            
            <article class="function" data-name="goLookupTXT">
               <h3>
                  goLookupTXT 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>goLookupTXT returns the TXT records from name.</p>
               
               <pre><code>func (r *Resolver) goLookupTXT(ctx context.Context, name string) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="goosPrefersCgo">
               <h3>
                  goosPrefersCgo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>goosPrefersCgo reports whether the GOOS value passed in prefers
the cgo resolver.</p>
               
               <pre><code>func goosPrefersCgo() bool</code></pre>
            </article>
            
            <article class="function" data-name="handlePlan9DNSError">
               <h3>
                  handlePlan9DNSError 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func handlePlan9DNSError(err error, name string) error</code></pre>
            </article>
            
            <article class="function" data-name="hangupCtlWrite">
               <h3>
                  hangupCtlWrite 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func hangupCtlWrite(ctx context.Context, proto string, ctl *os.File, msg string) error</code></pre>
            </article>
            
            <article class="function" data-name="hasFallenBack">
               <h3>
                  hasFallenBack 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hasFallenBack reports whether the MPTCP connection has fallen back to "plain"
TCP.
A connection can fallback to TCP for different reasons, e.g. the other peer
doesn't support it, a middle box "accidentally" drops the option, etc.
If the MPTCP protocol has not been requested when creating the socket, this
method will return true: MPTCP is not being used.
Kernel >= 5.16 returns EOPNOTSUPP/ENOPROTOOPT in case of fallback.
Older kernels will always return them even if MPTCP is used: not usable.</p>
               
               <pre><code>func hasFallenBack(fd *netFD) bool</code></pre>
            </article>
            
            <article class="function" data-name="hasUpperCase">
               <h3>
                  hasUpperCase 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hasUpperCase tells whether the given string contains at least one upper-case.</p>
               
               <pre><code>func hasUpperCase(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="hexString">
               <h3>
                  hexString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func hexString(b []byte) string</code></pre>
            </article>
            
            <article class="function" data-name="hostLookupOrder">
               <h3>
                  hostLookupOrder 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>hostLookupOrder determines which strategy to use to resolve hostname.
The provided Resolver is optional. nil means to not consider its options.
It also returns dnsConfig when it was used to determine the lookup order.</p>
               
               <pre><code>func (c *conf) hostLookupOrder(r *Resolver, hostname string) (ret hostLookupOrder, dnsConf *dnsConfig)</code></pre>
            </article>
            
            <article class="function" data-name="index">
               <h3>
                  index 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (zc *ipv6ZoneCache) index(name string) int</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) init() error</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) init() error</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>init initializes conf and is only called via conf.initOnce.</p>
               
               <pre><code>func (conf *nsswitchConfig) init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) init() error</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>init initializes conf and is only called via conf.initOnce.</p>
               
               <pre><code>func (conf *resolverConfig) init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) init() error</code></pre>
            </article>
            
            <article class="function" data-name="initConfVal">
               <h3>
                  initConfVal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>initConfVal initializes confVal based on the environment
that will not change during program execution.</p>
               
               <pre><code>func initConfVal()</code></pre>
            </article>
            
            <article class="function" data-name="initMPTCPavailable">
               <h3>
                  initMPTCPavailable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Check that MPTCP is supported by attempting to create an MPTCP socket and by
looking at the returned error if any.</p>
               
               <pre><code>func initMPTCPavailable()</code></pre>
            </article>
            
            <article class="function" data-name="interfaceAddrTable">
               <h3>
                  interfaceAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If the ifi is nil, interfaceAddrTable returns addresses for all
network interfaces. Otherwise it returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceAddrTable">
               <h3>
                  interfaceAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If the ifi is nil, interfaceAddrTable returns addresses for all
network interfaces. Otherwise it returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceAddrTable">
               <h3>
                  interfaceAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If the ifi is nil, interfaceAddrTable returns addresses for all
network interfaces. Otherwise it returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceAddrTable">
               <h3>
                  interfaceAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If the ifi is nil, interfaceAddrTable returns addresses for all
network interfaces. Otherwise it returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceAddrTable">
               <h3>
                  interfaceAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If the ifi is nil, interfaceAddrTable returns addresses for all
network interfaces. Otherwise it returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceAddrTable">
               <h3>
                  interfaceAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If the ifi is nil, interfaceAddrTable returns addresses for all
network interfaces. Otherwise it returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceAddrTable">
               <h3>
                  interfaceAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If the ifi is nil, interfaceAddrTable returns addresses for all
network interfaces. Otherwise it returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceByIndex">
               <h3>
                  interfaceByIndex 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func interfaceByIndex(ift []Interface, index int) (*Interface, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceCount">
               <h3>
                  interfaceCount 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func interfaceCount() (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceMessages">
               <h3>
                  interfaceMessages 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func interfaceMessages(ifindex int) ([]route.Message, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceMessages">
               <h3>
                  interfaceMessages 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func interfaceMessages(ifindex int) ([]route.Message, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceMessages">
               <h3>
                  interfaceMessages 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func interfaceMessages(ifindex int) ([]route.Message, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceMulticastAddrTable">
               <h3>
                  interfaceMulticastAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>interfaceMulticastAddrTable returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceMulticastAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceMulticastAddrTable">
               <h3>
                  interfaceMulticastAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>interfaceMulticastAddrTable returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceMulticastAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceMulticastAddrTable">
               <h3>
                  interfaceMulticastAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>interfaceMulticastAddrTable returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceMulticastAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceMulticastAddrTable">
               <h3>
                  interfaceMulticastAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>interfaceMulticastAddrTable returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceMulticastAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceMulticastAddrTable">
               <h3>
                  interfaceMulticastAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>interfaceMulticastAddrTable returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceMulticastAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceMulticastAddrTable">
               <h3>
                  interfaceMulticastAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>interfaceMulticastAddrTable returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceMulticastAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceMulticastAddrTable">
               <h3>
                  interfaceMulticastAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>interfaceMulticastAddrTable returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceMulticastAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceMulticastAddrTable">
               <h3>
                  interfaceMulticastAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>interfaceMulticastAddrTable returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceMulticastAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceMulticastAddrTable">
               <h3>
                  interfaceMulticastAddrTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>interfaceMulticastAddrTable returns addresses for a specific
interface.</p>
               
               <pre><code>func interfaceMulticastAddrTable(ifi *Interface) ([]Addr, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceTable">
               <h3>
                  interfaceTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If the ifindex is zero, interfaceTable returns mappings of all
network interfaces. Otherwise it returns a mapping of a specific
interface.</p>
               
               <pre><code>func interfaceTable(ifindex int) ([]Interface, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceTable">
               <h3>
                  interfaceTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If the ifindex is zero, interfaceTable returns mappings of all
network interfaces. Otherwise it returns a mapping of a specific
interface.</p>
               
               <pre><code>func interfaceTable(ifindex int) ([]Interface, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceTable">
               <h3>
                  interfaceTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If the ifindex is zero, interfaceTable returns mappings of all
network interfaces. Otherwise it returns a mapping of a specific
interface.</p>
               
               <pre><code>func interfaceTable(ifindex int) ([]Interface, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceTable">
               <h3>
                  interfaceTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If the ifindex is zero, interfaceTable returns mappings of all
network interfaces. Otherwise it returns a mapping of a specific
interface.</p>
               
               <pre><code>func interfaceTable(ifindex int) ([]Interface, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceTable">
               <h3>
                  interfaceTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If the ifindex is zero, interfaceTable returns mappings of all
network interfaces. Otherwise it returns a mapping of a specific
interface.</p>
               
               <pre><code>func interfaceTable(ifindex int) ([]Interface, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceTable">
               <h3>
                  interfaceTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If the ifindex is zero, interfaceTable returns mappings of all
network interfaces. Otherwise it returns a mapping of a specific
interface.</p>
               
               <pre><code>func interfaceTable(ifindex int) ([]Interface, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceTable">
               <h3>
                  interfaceTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If the ifindex is zero, interfaceTable returns mappings of all
network interfaces. Otherwise it returns a mapping of a specific
interface.</p>
               
               <pre><code>func interfaceTable(ifindex int) ([]Interface, error)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceToIPv4Addr">
               <h3>
                  interfaceToIPv4Addr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func interfaceToIPv4Addr(ifi *Interface) (IP, error)</code></pre>
            </article>
            
            <article class="function" data-name="internetAddrList">
               <h3>
                  internetAddrList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>internetAddrList resolves addr, which may be a literal IP
address or a DNS name, and returns a list of internet protocol
family addresses. The result contains at least one address when
error is nil.</p>
               
               <pre><code>func (r *Resolver) internetAddrList(ctx context.Context, net string, addr string) (addrList, error)</code></pre>
            </article>
            
            <article class="function" data-name="internetSocket">
               <h3>
                  internetSocket 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func internetSocket(ctx context.Context, net string, laddr sockaddr, raddr sockaddr, sotype int, proto int, mode string, ctrlCtxFn func(context.Context, string, string, syscall.RawConn) error) (fd *netFD, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ipAddrsEface">
               <h3>
                  ipAddrsEface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ipAddrsEface returns an empty interface slice of addrs.</p>
               
               <pre><code>func ipAddrsEface(addrs []IPAddr) []any</code></pre>
            </article>
            
            <article class="function" data-name="ipAttrOf">
               <h3>
                  ipAttrOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ipAttrOf(ip netip.Addr) ipAttr</code></pre>
            </article>
            
            <article class="function" data-name="ipEmptyString">
               <h3>
                  ipEmptyString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ipEmptyString is like ip.String except that it returns
an empty string when ip is unset.</p>
               
               <pre><code>func ipEmptyString(ip IP) string</code></pre>
            </article>
            
            <article class="function" data-name="ipToSockaddr">
               <h3>
                  ipToSockaddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ipToSockaddr should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/database64128/tfo-go/v2
- github.com/metacubex/tfo-go
- github.com/sagernet/tfo-go
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname ipToSockaddr</p>
               
               <pre><code>func ipToSockaddr(family int, ip IP, port int, zone string) (syscall.Sockaddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="ipToSockaddrInet4">
               <h3>
                  ipToSockaddrInet4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ipToSockaddrInet4(ip IP, port int) (syscall.SockaddrInet4, error)</code></pre>
            </article>
            
            <article class="function" data-name="ipToSockaddrInet6">
               <h3>
                  ipToSockaddrInet6 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ipToSockaddrInet6(ip IP, port int, zone string) (syscall.SockaddrInet6, error)</code></pre>
            </article>
            
            <article class="function" data-name="ipVersion">
               <h3>
                  ipVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ipVersion returns the provided network's IP version: '4', '6' or 0
if network does not end in a '4' or '6' byte.</p>
               
               <pre><code>func ipVersion(network string) byte</code></pre>
            </article>
            
            <article class="function" data-name="ipv4only">
               <h3>
                  ipv4only 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ipv4only reports whether addr is an IPv4 address.</p>
               
               <pre><code>func ipv4only(addr IPAddr) bool</code></pre>
            </article>
            
            <article class="function" data-name="ipv6only">
               <h3>
                  ipv6only 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ipv6only reports whether addr is an IPv6 address except IPv4-mapped IPv6 address.</p>
               
               <pre><code>func ipv6only(addr IPAddr) bool</code></pre>
            </article>
            
            <article class="function" data-name="isAddrinfoErrno">
               <h3>
                  isAddrinfoErrno 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isAddrinfoErrno is just for testing purposes.</p>
               
               <pre><code>func (eai addrinfoErrno) isAddrinfoErrno()</code></pre>
            </article>
            
            <article class="function" data-name="isClosedChan">
               <h3>
                  isClosedChan 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isClosedChan(c <-chan struct{...}) bool</code></pre>
            </article>
            
            <article class="function" data-name="isConnError">
               <h3>
                  isConnError 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isConnError(err error) bool</code></pre>
            </article>
            
            <article class="function" data-name="isConnError">
               <h3>
                  isConnError 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isConnError(err error) bool</code></pre>
            </article>
            
            <article class="function" data-name="isConnError">
               <h3>
                  isConnError 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isConnError(err error) bool</code></pre>
            </article>
            
            <article class="function" data-name="isDomainName">
               <h3>
                  isDomainName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isDomainName checks if a string is a presentation-format domain name
(currently restricted to hostname-compatible "preferred name" LDH labels and
SRV-like "underscore labels"; see golang.org/issue/12421).
isDomainName should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/sagernet/sing
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname isDomainName</p>
               
               <pre><code>func isDomainName(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isGateway">
               <h3>
                  isGateway 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isGateway reports whether h should be considered a "gateway"
name for the myhostname NSS module.</p>
               
               <pre><code>func isGateway(h string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isIPv4">
               <h3>
                  isIPv4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isIPv4 reports whether addr contains an IPv4 address.</p>
               
               <pre><code>func isIPv4(addr Addr) bool</code></pre>
            </article>
            
            <article class="function" data-name="isLocalhost">
               <h3>
                  isLocalhost 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isLocalhost reports whether h should be considered a "localhost"
name for the myhostname NSS module.</p>
               
               <pre><code>func isLocalhost(h string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isNotIPv4">
               <h3>
                  isNotIPv4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isNotIPv4 reports whether addr does not contain an IPv4 address.</p>
               
               <pre><code>func isNotIPv4(addr Addr) bool</code></pre>
            </article>
            
            <article class="function" data-name="isOutbound">
               <h3>
                  isOutbound 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isOutbound reports whether h should be considered an "outbound"
name for the myhostname NSS module.</p>
               
               <pre><code>func isOutbound(h string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isSpace">
               <h3>
                  isSpace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isSpace reports whether b is an ASCII space character.</p>
               
               <pre><code>func isSpace(b byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="isUsingMPTCPProto">
               <h3>
                  isUsingMPTCPProto 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isUsingMPTCPProto reports whether the socket protocol is MPTCP.
Compared to hasFallenBack method, here only the socket protocol being used is
checked: it can be MPTCP but it doesn't mean MPTCP is used on the wire, maybe
a fallback to TCP has been done.</p>
               
               <pre><code>func isUsingMPTCPProto(fd *netFD) bool</code></pre>
            </article>
            
            <article class="function" data-name="isUsingMultipathTCP">
               <h3>
                  isUsingMultipathTCP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isUsingMultipathTCP reports whether MPTCP is still being used.
Please look at the description of hasFallenBack (kernel >=5.16) and
isUsingMPTCPProto methods for more details about what is being checked here.</p>
               
               <pre><code>func isUsingMultipathTCP(fd *netFD) bool</code></pre>
            </article>
            
            <article class="function" data-name="isUsingMultipathTCP">
               <h3>
                  isUsingMultipathTCP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isUsingMultipathTCP(fd *netFD) bool</code></pre>
            </article>
            
            <article class="function" data-name="isWildcard">
               <h3>
                  isWildcard 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *UnixAddr) isWildcard() bool</code></pre>
            </article>
            
            <article class="function" data-name="isWildcard">
               <h3>
                  isWildcard 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isWildcard(a Addr) bool</code></pre>
            </article>
            
            <article class="function" data-name="isWildcard">
               <h3>
                  isWildcard 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *UDPAddr) isWildcard() bool</code></pre>
            </article>
            
            <article class="function" data-name="isWildcard">
               <h3>
                  isWildcard 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *IPAddr) isWildcard() bool</code></pre>
            </article>
            
            <article class="function" data-name="isWildcard">
               <h3>
                  isWildcard 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *TCPAddr) isWildcard() bool</code></pre>
            </article>
            
            <article class="function" data-name="isZeros">
               <h3>
                  isZeros 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Is p all zeros?</p>
               
               <pre><code>func isZeros(p IP) bool</code></pre>
            </article>
            
            <article class="function" data-name="joinIPv4Group">
               <h3>
                  joinIPv4Group 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func joinIPv4Group(fd *netFD, ifi *Interface, ip IP) error</code></pre>
            </article>
            
            <article class="function" data-name="joinIPv4Group">
               <h3>
                  joinIPv4Group 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func joinIPv4Group(fd *netFD, ifi *Interface, ip IP) error</code></pre>
            </article>
            
            <article class="function" data-name="joinIPv6Group">
               <h3>
                  joinIPv6Group 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func joinIPv6Group(fd *netFD, ifi *Interface, ip IP) error</code></pre>
            </article>
            
            <article class="function" data-name="joinIPv6Group">
               <h3>
                  joinIPv6Group 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func joinIPv6Group(fd *netFD, ifi *Interface, ip IP) error</code></pre>
            </article>
            
            <article class="function" data-name="linkFlags">
               <h3>
                  linkFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func linkFlags(rawFlags int32) Flags</code></pre>
            </article>
            
            <article class="function" data-name="linkFlags">
               <h3>
                  linkFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func linkFlags(rawFlags int) Flags</code></pre>
            </article>
            
            <article class="function" data-name="linkFlags">
               <h3>
                  linkFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func linkFlags(rawFlags int) Flags</code></pre>
            </article>
            
            <article class="function" data-name="linkFlags">
               <h3>
                  linkFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func linkFlags(rawFlags uint32) Flags</code></pre>
            </article>
            
            <article class="function" data-name="listenDatagram">
               <h3>
                  listenDatagram 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) listenDatagram(ctx context.Context, laddr sockaddr, ctrlCtxFn func(context.Context, string, string, syscall.RawConn) error) error</code></pre>
            </article>
            
            <article class="function" data-name="listenIP">
               <h3>
                  listenIP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sl *sysListener) listenIP(ctx context.Context, laddr *IPAddr) (*IPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="listenIP">
               <h3>
                  listenIP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sl *sysListener) listenIP(ctx context.Context, laddr *IPAddr) (*IPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="listenIPv4MulticastUDP">
               <h3>
                  listenIPv4MulticastUDP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func listenIPv4MulticastUDP(c *UDPConn, ifi *Interface, ip IP) error</code></pre>
            </article>
            
            <article class="function" data-name="listenIPv6MulticastUDP">
               <h3>
                  listenIPv6MulticastUDP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func listenIPv6MulticastUDP(c *UDPConn, ifi *Interface, ip IP) error</code></pre>
            </article>
            
            <article class="function" data-name="listenMPTCP">
               <h3>
                  listenMPTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sl *sysListener) listenMPTCP(ctx context.Context, laddr *TCPAddr) (*TCPListener, error)</code></pre>
            </article>
            
            <article class="function" data-name="listenMPTCP">
               <h3>
                  listenMPTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sl *sysListener) listenMPTCP(ctx context.Context, laddr *TCPAddr) (*TCPListener, error)</code></pre>
            </article>
            
            <article class="function" data-name="listenMulticastUDP">
               <h3>
                  listenMulticastUDP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sl *sysListener) listenMulticastUDP(ctx context.Context, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="listenMulticastUDP">
               <h3>
                  listenMulticastUDP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sl *sysListener) listenMulticastUDP(ctx context.Context, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="listenPlan9">
               <h3>
                  listenPlan9 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func listenPlan9(ctx context.Context, net string, laddr Addr) (fd *netFD, err error)</code></pre>
            </article>
            
            <article class="function" data-name="listenStream">
               <h3>
                  listenStream 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) listenStream(ctx context.Context, laddr sockaddr, backlog int, ctrlCtxFn func(context.Context, string, string, syscall.RawConn) error) error</code></pre>
            </article>
            
            <article class="function" data-name="listenTCP">
               <h3>
                  listenTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sl *sysListener) listenTCP(ctx context.Context, laddr *TCPAddr) (*TCPListener, error)</code></pre>
            </article>
            
            <article class="function" data-name="listenTCP">
               <h3>
                  listenTCP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sl *sysListener) listenTCP(ctx context.Context, laddr *TCPAddr) (*TCPListener, error)</code></pre>
            </article>
            
            <article class="function" data-name="listenTCPProto">
               <h3>
                  listenTCPProto 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sl *sysListener) listenTCPProto(ctx context.Context, laddr *TCPAddr, proto int) (*TCPListener, error)</code></pre>
            </article>
            
            <article class="function" data-name="listenUDP">
               <h3>
                  listenUDP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sl *sysListener) listenUDP(ctx context.Context, laddr *UDPAddr) (*UDPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="listenUDP">
               <h3>
                  listenUDP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sl *sysListener) listenUDP(ctx context.Context, laddr *UDPAddr) (*UDPConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="listenUnix">
               <h3>
                  listenUnix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sl *sysListener) listenUnix(ctx context.Context, laddr *UnixAddr) (*UnixListener, error)</code></pre>
            </article>
            
            <article class="function" data-name="listenUnix">
               <h3>
                  listenUnix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sl *sysListener) listenUnix(ctx context.Context, laddr *UnixAddr) (*UnixListener, error)</code></pre>
            </article>
            
            <article class="function" data-name="listenUnixgram">
               <h3>
                  listenUnixgram 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sl *sysListener) listenUnixgram(ctx context.Context, laddr *UnixAddr) (*UnixConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="listenUnixgram">
               <h3>
                  listenUnixgram 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sl *sysListener) listenUnixgram(ctx context.Context, laddr *UnixAddr) (*UnixConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="listenerBacklog">
               <h3>
                  listenerBacklog 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>listenerBacklog is a caching wrapper around maxListenerBacklog.
listenerBacklog should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/database64128/tfo-go/v2
- github.com/metacubex/tfo-go
- github.com/sagernet/tfo-go
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname listenerBacklog</p>
               
               <pre><code>func listenerBacklog() int</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookup(ctx context.Context, name string, qtype dnsmessage.Type, conf *dnsConfig) (dnsmessage.Parser, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupAddr">
               <h3>
                  lookupAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupAddr(ctx context.Context, addr string) (name []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupAddr">
               <h3>
                  lookupAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupAddr(ctx context.Context, addr string) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupAddr">
               <h3>
                  lookupAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupAddr(ctx context.Context, addr string) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupCNAME">
               <h3>
                  lookupCNAME 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupCNAME(ctx context.Context, name string) (cname string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupCNAME">
               <h3>
                  lookupCNAME 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupCNAME(ctx context.Context, name string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupCNAME">
               <h3>
                  lookupCNAME 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupCNAME(ctx context.Context, name string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupHost">
               <h3>
                  lookupHost 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupHost(ctx context.Context, host string) (addrs []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupHost">
               <h3>
                  lookupHost 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*Resolver) lookupHost(ctx context.Context, host string) (addrs []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupHost">
               <h3>
                  lookupHost 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupHost(ctx context.Context, name string) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupIP">
               <h3>
                  lookupIP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupIP(ctx context.Context, network string, name string) ([]IPAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupIP">
               <h3>
                  lookupIP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupIP(ctx context.Context, network string, host string) (addrs []IPAddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupIP">
               <h3>
                  lookupIP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupIP(ctx context.Context, network string, host string) (addrs []IPAddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupIPAddr">
               <h3>
                  lookupIPAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupIPAddr looks up host using the local resolver and particular network.
It returns a slice of that host's IPv4 and IPv6 addresses.</p>
               
               <pre><code>func (r *Resolver) lookupIPAddr(ctx context.Context, network string, host string) ([]IPAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupIPReturn">
               <h3>
                  lookupIPReturn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lookupIPReturn turns the return values from singleflight.Do into
the return values from LookupIP.</p>
               
               <pre><code>func lookupIPReturn(addrsi any, err error, shared bool) ([]IPAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupMX">
               <h3>
                  lookupMX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupMX(ctx context.Context, name string) ([]*MX, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupMX">
               <h3>
                  lookupMX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupMX(ctx context.Context, name string) (mx []*MX, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupMX">
               <h3>
                  lookupMX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupMX(ctx context.Context, name string) ([]*MX, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupNS">
               <h3>
                  lookupNS 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupNS(ctx context.Context, name string) (ns []*NS, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupNS">
               <h3>
                  lookupNS 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupNS(ctx context.Context, name string) ([]*NS, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupNS">
               <h3>
                  lookupNS 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupNS(ctx context.Context, name string) ([]*NS, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupOrder">
               <h3>
                  lookupOrder 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *conf) lookupOrder(r *Resolver, hostname string) (ret hostLookupOrder, dnsConf *dnsConfig)</code></pre>
            </article>
            
            <article class="function" data-name="lookupPort">
               <h3>
                  lookupPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupPort(ctx context.Context, network string, service string) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupPort">
               <h3>
                  lookupPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupPort(ctx context.Context, network string, service string) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupPort">
               <h3>
                  lookupPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupPort(ctx context.Context, network string, service string) (port int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupPortMap">
               <h3>
                  lookupPortMap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func lookupPortMap(network string, service string) (port int, error error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupPortMapWithNetwork">
               <h3>
                  lookupPortMapWithNetwork 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func lookupPortMapWithNetwork(network string, errNetwork string, service string) (port int, error error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupPortWithNetwork">
               <h3>
                  lookupPortWithNetwork 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*Resolver) lookupPortWithNetwork(ctx context.Context, network string, errNetwork string, service string) (port int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupProtocol">
               <h3>
                  lookupProtocol 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lookupProtocol looks up IP protocol name in /etc/protocols and
returns correspondent protocol number.</p>
               
               <pre><code>func lookupProtocol(_ context.Context, name string) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupProtocol">
               <h3>
                  lookupProtocol 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lookupProtocol looks up IP protocol name and returns correspondent protocol number.</p>
               
               <pre><code>func lookupProtocol(ctx context.Context, name string) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupProtocol">
               <h3>
                  lookupProtocol 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lookupProtocol looks up IP protocol name and returns
the corresponding protocol number.</p>
               
               <pre><code>func lookupProtocol(ctx context.Context, name string) (proto int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupProtocolMap">
               <h3>
                  lookupProtocolMap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func lookupProtocolMap(name string) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupSRV">
               <h3>
                  lookupSRV 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupSRV(ctx context.Context, service string, proto string, name string) (string, []*SRV, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupSRV">
               <h3>
                  lookupSRV 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupSRV(ctx context.Context, service string, proto string, name string) (string, []*SRV, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupSRV">
               <h3>
                  lookupSRV 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupSRV(ctx context.Context, service string, proto string, name string) (cname string, addrs []*SRV, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupStaticAddr">
               <h3>
                  lookupStaticAddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lookupStaticAddr looks up the hosts for the given address from /etc/hosts.</p>
               
               <pre><code>func lookupStaticAddr(addr string) []string</code></pre>
            </article>
            
            <article class="function" data-name="lookupStaticHost">
               <h3>
                  lookupStaticHost 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lookupStaticHost looks up the addresses and the canonical name for the given host from /etc/hosts.</p>
               
               <pre><code>func lookupStaticHost(host string) ([]string, string)</code></pre>
            </article>
            
            <article class="function" data-name="lookupTXT">
               <h3>
                  lookupTXT 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupTXT(ctx context.Context, name string) (txt []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupTXT">
               <h3>
                  lookupTXT 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupTXT(ctx context.Context, name string) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupTXT">
               <h3>
                  lookupTXT 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) lookupTXT(ctx context.Context, name string) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="loopbackIP">
               <h3>
                  loopbackIP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>loopbackIP should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/database64128/tfo-go/v2
- github.com/metacubex/tfo-go
- github.com/sagernet/tfo-go
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname loopbackIP</p>
               
               <pre><code>func loopbackIP(net string) IP</code></pre>
            </article>
            
            <article class="function" data-name="lowerASCII">
               <h3>
                  lowerASCII 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lowerASCII returns the ASCII lowercase version of b.</p>
               
               <pre><code>func lowerASCII(b byte) byte</code></pre>
            </article>
            
            <article class="function" data-name="lowerASCIIBytes">
               <h3>
                  lowerASCIIBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lowerASCIIBytes makes x ASCII lowercase in-place.</p>
               
               <pre><code>func lowerASCIIBytes(x []byte)</code></pre>
            </article>
            
            <article class="function" data-name="makePipeDeadline">
               <h3>
                  makePipeDeadline 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makePipeDeadline() pipeDeadline</code></pre>
            </article>
            
            <article class="function" data-name="mapErr">
               <h3>
                  mapErr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>mapErr maps from the context errors to the historical internal net
error values.</p>
               
               <pre><code>func mapErr(err error) error</code></pre>
            </article>
            
            <article class="function" data-name="matchAddrFamily">
               <h3>
                  matchAddrFamily 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ip IP) matchAddrFamily(x IP) bool</code></pre>
            </article>
            
            <article class="function" data-name="matchIPFamily">
               <h3>
                  matchIPFamily 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func matchIPFamily(family int, addr sockaddr) sockaddr</code></pre>
            </article>
            
            <article class="function" data-name="maxAckBacklog">
               <h3>
                  maxAckBacklog 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Linux stores the backlog as:
- uint16 in kernel version < 4.1,
- uint32 in kernel version >= 4.1
Truncate number to avoid wrapping.
See issue 5030 and 41470.</p>
               
               <pre><code>func maxAckBacklog(n int) int</code></pre>
            </article>
            
            <article class="function" data-name="maxListenerBacklog">
               <h3>
                  maxListenerBacklog 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func maxListenerBacklog() int</code></pre>
            </article>
            
            <article class="function" data-name="maxListenerBacklog">
               <h3>
                  maxListenerBacklog 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func maxListenerBacklog() int</code></pre>
            </article>
            
            <article class="function" data-name="maxListenerBacklog">
               <h3>
                  maxListenerBacklog 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func maxListenerBacklog() int</code></pre>
            </article>
            
            <article class="function" data-name="maxListenerBacklog">
               <h3>
                  maxListenerBacklog 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func maxListenerBacklog() int</code></pre>
            </article>
            
            <article class="function" data-name="maxListenerBacklog">
               <h3>
                  maxListenerBacklog 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func maxListenerBacklog() int</code></pre>
            </article>
            
            <article class="function" data-name="minNonzeroTime">
               <h3>
                  minNonzeroTime 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func minNonzeroTime(a time.Time, b time.Time) time.Time</code></pre>
            </article>
            
            <article class="function" data-name="mustUseGoResolver">
               <h3>
                  mustUseGoResolver 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mustUseGoResolver reports whether a DNS lookup of any sort is
required to use the go resolver. The provided Resolver is optional.
This will report true if the cgo resolver is not available.</p>
               
               <pre><code>func (c *conf) mustUseGoResolver(r *Resolver) bool</code></pre>
            </article>
            
            <article class="function" data-name="name">
               <h3>
                  name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) name() string</code></pre>
            </article>
            
            <article class="function" data-name="name">
               <h3>
                  name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (zc *ipv6ZoneCache) name(index int) string</code></pre>
            </article>
            
            <article class="function" data-name="name">
               <h3>
                  name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) name() string</code></pre>
            </article>
            
            <article class="function" data-name="name">
               <h3>
                  name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) name() string</code></pre>
            </article>
            
            <article class="function" data-name="nameList">
               <h3>
                  nameList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>nameList returns a list of names for sequential DNS queries.</p>
               
               <pre><code>func (conf *dnsConfig) nameList(name string) []string</code></pre>
            </article>
            
            <article class="function" data-name="netFD">
               <h3>
                  netFD 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) netFD() (*netFD, error)</code></pre>
            </article>
            
            <article class="function" data-name="networkNumberAndMask">
               <h3>
                  networkNumberAndMask 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func networkNumberAndMask(n *IPNet) (ip IP, m IPMask)</code></pre>
            </article>
            
            <article class="function" data-name="newAddr">
               <h3>
                  newAddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newAddr(ifam *syscall.IfAddrmsg, attrs []syscall.NetlinkRouteAttr) Addr</code></pre>
            </article>
            
            <article class="function" data-name="newDNSError">
               <h3>
                  newDNSError 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newDNSError creates a new *DNSError.
Based on the err, it sets the UnwrapErr, IsTimeout, IsTemporary, IsNotFound fields.</p>
               
               <pre><code>func newDNSError(err error, name string, server string) *DNSError</code></pre>
            </article>
            
            <article class="function" data-name="newDeadlineTimer">
               <h3>
                  newDeadlineTimer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newDeadlineTimer(deadline time.Time) *deadlineTimer</code></pre>
            </article>
            
            <article class="function" data-name="newFD">
               <h3>
                  newFD 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newFD(sysfd int, family int, sotype int, net string) (*netFD, error)</code></pre>
            </article>
            
            <article class="function" data-name="newFD">
               <h3>
                  newFD 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newFD(sysfd syscall.Handle, family int, sotype int, net string) (*netFD, error)</code></pre>
            </article>
            
            <article class="function" data-name="newFD">
               <h3>
                  newFD 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newFD(net string, sysfd int) *netFD</code></pre>
            </article>
            
            <article class="function" data-name="newFD">
               <h3>
                  newFD 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newFD(net string, name string, listen *os.File, ctl *os.File, data *os.File, laddr Addr, raddr Addr) (*netFD, error)</code></pre>
            </article>
            
            <article class="function" data-name="newFakeNetFD">
               <h3>
                  newFakeNetFD 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newFakeNetFD(fd *netFD) *fakeNetFD</code></pre>
            </article>
            
            <article class="function" data-name="newFileConn">
               <h3>
                  newFileConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newFileConn(fd *netFD) Conn</code></pre>
            </article>
            
            <article class="function" data-name="newFileFD">
               <h3>
                  newFileFD 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newFileFD(f *os.File) (net *netFD, err error)</code></pre>
            </article>
            
            <article class="function" data-name="newFileFD">
               <h3>
                  newFileFD 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newFileFD(f *os.File) (*netFD, error)</code></pre>
            </article>
            
            <article class="function" data-name="newFileListener">
               <h3>
                  newFileListener 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newFileListener(fd *netFD) Listener</code></pre>
            </article>
            
            <article class="function" data-name="newIPConn">
               <h3>
                  newIPConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newIPConn(fd *netFD) *IPConn</code></pre>
            </article>
            
            <article class="function" data-name="newLink">
               <h3>
                  newLink 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newLink(ifim *syscall.IfInfomsg, attrs []syscall.NetlinkRouteAttr) *Interface</code></pre>
            </article>
            
            <article class="function" data-name="newPacketQueue">
               <h3>
                  newPacketQueue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newPacketQueue(readBufferBytes int) *packetQueue</code></pre>
            </article>
            
            <article class="function" data-name="newPollFD">
               <h3>
                  newPollFD 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newPollFD(net string, pfd poll.FD) *netFD</code></pre>
            </article>
            
            <article class="function" data-name="newRawConn">
               <h3>
                  newRawConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newRawConn(fd *netFD) *rawConn</code></pre>
            </article>
            
            <article class="function" data-name="newRawListener">
               <h3>
                  newRawListener 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newRawListener(fd *netFD) *rawListener</code></pre>
            </article>
            
            <article class="function" data-name="newRequest">
               <h3>
                  newRequest 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newRequest(q dnsmessage.Question, ad bool) (id uint16, udpReq []byte, tcpReq []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="newTCPConn">
               <h3>
                  newTCPConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newTCPConn(fd *netFD, keepAliveIdle time.Duration, keepAliveCfg KeepAliveConfig, preKeepAliveHook func(*netFD), keepAliveHook func(KeepAliveConfig)) *TCPConn</code></pre>
            </article>
            
            <article class="function" data-name="newUDPConn">
               <h3>
                  newUDPConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newUDPConn(fd *netFD) *UDPConn</code></pre>
            </article>
            
            <article class="function" data-name="newUnixConn">
               <h3>
                  newUnixConn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newUnixConn(fd *netFD) *UnixConn</code></pre>
            </article>
            
            <article class="function" data-name="newUnixFile">
               <h3>
                  newUnixFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Defined in os package.</p>
               
               <pre><code>func newUnixFile(fd int, name string) *os.File</code></pre>
            </article>
            
            <article class="function" data-name="ok">
               <h3>
                  ok 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ln *UnixListener) ok() bool</code></pre>
            </article>
            
            <article class="function" data-name="ok">
               <h3>
                  ok 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *conn) ok() bool</code></pre>
            </article>
            
            <article class="function" data-name="ok">
               <h3>
                  ok 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) ok() bool</code></pre>
            </article>
            
            <article class="function" data-name="ok">
               <h3>
                  ok 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ln *TCPListener) ok() bool</code></pre>
            </article>
            
            <article class="function" data-name="ok">
               <h3>
                  ok 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ln *TCPListener) ok() bool</code></pre>
            </article>
            
            <article class="function" data-name="ok">
               <h3>
                  ok 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *rawConn) ok() bool</code></pre>
            </article>
            
            <article class="function" data-name="opAddr">
               <h3>
                  opAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *UDPAddr) opAddr() Addr</code></pre>
            </article>
            
            <article class="function" data-name="opAddr">
               <h3>
                  opAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *TCPAddr) opAddr() Addr</code></pre>
            </article>
            
            <article class="function" data-name="opAddr">
               <h3>
                  opAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *UnixAddr) opAddr() Addr</code></pre>
            </article>
            
            <article class="function" data-name="opAddr">
               <h3>
                  opAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *IPAddr) opAddr() Addr</code></pre>
            </article>
            
            <article class="function" data-name="open">
               <h3>
                  open 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func open(name string) (*file, error)</code></pre>
            </article>
            
            <article class="function" data-name="parseCNAMEFromResources">
               <h3>
                  parseCNAMEFromResources 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseCNAMEFromResources(resources []dnsmessage.Resource) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="parseCriteria">
               <h3>
                  parseCriteria 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parses "foo=bar !foo=bar"</p>
               
               <pre><code>func parseCriteria(x string) (c []nssCriterion, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseIP">
               <h3>
                  parseIP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseIP(s string) ([16]byte, bool)</code></pre>
            </article>
            
            <article class="function" data-name="parseLiteralIP">
               <h3>
                  parseLiteralIP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseLiteralIP(addr string) string</code></pre>
            </article>
            
            <article class="function" data-name="parseNSSConf">
               <h3>
                  parseNSSConf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseNSSConf(f *file) *nssConf</code></pre>
            </article>
            
            <article class="function" data-name="parseNSSConfFile">
               <h3>
                  parseNSSConfFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseNSSConfFile(file string) *nssConf</code></pre>
            </article>
            
            <article class="function" data-name="parseNetwork">
               <h3>
                  parseNetwork 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseNetwork(ctx context.Context, network string, needsProto bool) (afnet string, proto int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parsePlan9Addr">
               <h3>
                  parsePlan9Addr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parsePlan9Addr parses address of the form [ip!]port (e.g. 127.0.0.1!80).</p>
               
               <pre><code>func parsePlan9Addr(s string) (ip IP, iport int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parsePort">
               <h3>
                  parsePort 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parsePort parses service as a decimal integer and returns the
corresponding value as port. It is the caller's responsibility to
parse service as a non-decimal integer when needsLookup is true.
Some system resolvers will return a valid port number when given a number
over 65536 (see https://golang.org/issues/11715). Alas, the parser
can't bail early on numbers > 65536. Therefore reasonably large/small
numbers are parsed in full and rejected if invalid.</p>
               
               <pre><code>func parsePort(service string) (port int, needsLookup bool)</code></pre>
            </article>
            
            <article class="function" data-name="parseProcNetIGMP">
               <h3>
                  parseProcNetIGMP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseProcNetIGMP(path string, ifi *Interface) []Addr</code></pre>
            </article>
            
            <article class="function" data-name="parseProcNetIGMP6">
               <h3>
                  parseProcNetIGMP6 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseProcNetIGMP6(path string, ifi *Interface) []Addr</code></pre>
            </article>
            
            <article class="function" data-name="partialDeadline">
               <h3>
                  partialDeadline 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>partialDeadline returns the deadline to use for a single address,
when multiple addresses are pending.</p>
               
               <pre><code>func partialDeadline(now time.Time, deadline time.Time, addrsRemaining int) (time.Time, error)</code></pre>
            </article>
            
            <article class="function" data-name="partition">
               <h3>
                  partition 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>partition divides an address list into two categories, using a
strategy function to assign a boolean label to each address.
The first address, and any with a matching label, are returned as
primaries, while addresses with the opposite label are returned
as fallbacks. For non-empty inputs, primaries is guaranteed to be
non-empty.</p>
               
               <pre><code>func (addrs addrList) partition(strategy func(Addr) bool) (primaries addrList, fallbacks addrList)</code></pre>
            </article>
            
            <article class="function" data-name="plan9LocalAddr">
               <h3>
                  plan9LocalAddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>plan9LocalAddr returns a Plan 9 local address string.
See setladdrport at https://9p.io/sources/plan9/sys/src/9/ip/devip.c.</p>
               
               <pre><code>func plan9LocalAddr(addr Addr) string</code></pre>
            </article>
            
            <article class="function" data-name="preferGo">
               <h3>
                  preferGo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) preferGo() bool</code></pre>
            </article>
            
            <article class="function" data-name="probe">
               <h3>
                  probe 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func probe(filename string, query string) bool</code></pre>
            </article>
            
            <article class="function" data-name="probe">
               <h3>
                  probe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>probe probes IPv4, IPv6 and IPv4-mapped IPv6 communication
capabilities which are controlled by the IPV6_V6ONLY socket option
and kernel configuration.
Should we try to use the IPv4 socket interface if we're only
dealing with IPv4 sockets? As long as the host system understands
IPv4-mapped IPv6, it's okay to pass IPv4-mapped IPv6 addresses to
the IPv6 interface. That simplifies our code and is most
general. Unfortunately, we need to run on kernels built without
IPv6 support too. So probe the kernel to figure it out.</p>
               
               <pre><code>func (p *ipStackCapabilities) probe()</code></pre>
            </article>
            
            <article class="function" data-name="probe">
               <h3>
                  probe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>probe probes IPv4, IPv6 and IPv4-mapped IPv6 communication
capabilities.
Plan 9 uses IPv6 natively, see ip(3).</p>
               
               <pre><code>func (p *ipStackCapabilities) probe()</code></pre>
            </article>
            
            <article class="function" data-name="put">
               <h3>
                  put 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pq *packetQueue) put(q packetQueueState)</code></pre>
            </article>
            
            <article class="function" data-name="query">
               <h3>
                  query 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func query(ctx context.Context, filename string, query string, bufSize int) (addrs []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="queryCS">
               <h3>
                  queryCS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func queryCS(ctx context.Context, net string, host string, service string) (res []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="queryCS1">
               <h3>
                  queryCS1 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func queryCS1(ctx context.Context, net string, ip IP, port int) (clone string, dest string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="queryDNS">
               <h3>
                  queryDNS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func queryDNS(ctx context.Context, addr string, typ string) (res []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="randInt">
               <h3>
                  randInt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func randInt() int</code></pre>
            </article>
            
            <article class="function" data-name="randIntn">
               <h3>
                  randIntn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func randIntn(n int) int</code></pre>
            </article>
            
            <article class="function" data-name="read">
               <h3>
                  read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pipe) read(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readFrom">
               <h3>
                  readFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UDPConn) readFrom(b []byte, addr *UDPAddr) (int, *UDPAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="readFrom">
               <h3>
                  readFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *IPConn) readFrom(b []byte) (int, *IPAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="readFrom">
               <h3>
                  readFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) readFrom(p []byte) (n int, sa syscall.Sockaddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readFrom">
               <h3>
                  readFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *TCPConn) readFrom(r io.Reader) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="readFrom">
               <h3>
                  readFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *IPConn) readFrom(b []byte) (int, *IPAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="readFrom">
               <h3>
                  readFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UnixConn) readFrom(b []byte) (int, *UnixAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="readFrom">
               <h3>
                  readFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UnixConn) readFrom(b []byte) (int, *UnixAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="readFrom">
               <h3>
                  readFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) readFrom(p []byte) (n int, sa syscall.Sockaddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readFrom">
               <h3>
                  readFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *TCPConn) readFrom(r io.Reader) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="readFrom">
               <h3>
                  readFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UDPConn) readFrom(b []byte, addr *UDPAddr) (int, *UDPAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="readFromAddrPort">
               <h3>
                  readFromAddrPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UDPConn) readFromAddrPort(b []byte) (int, netip.AddrPort, error)</code></pre>
            </article>
            
            <article class="function" data-name="readFromAddrPort">
               <h3>
                  readFromAddrPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UDPConn) readFromAddrPort(b []byte) (n int, addr netip.AddrPort, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readFromInet4">
               <h3>
                  readFromInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) readFromInet4(p []byte, sa *syscall.SockaddrInet4) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readFromInet4">
               <h3>
                  readFromInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) readFromInet4(p []byte, from *syscall.SockaddrInet4) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readFromInet6">
               <h3>
                  readFromInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) readFromInet6(p []byte, sa *syscall.SockaddrInet6) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readFromInet6">
               <h3>
                  readFromInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) readFromInet6(p []byte, from *syscall.SockaddrInet6) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readFromUDP">
               <h3>
                  readFromUDP 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>readFromUDP implements ReadFromUDP.</p>
               
               <pre><code>func (c *UDPConn) readFromUDP(b []byte, addr *UDPAddr) (int, *UDPAddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="readHosts">
               <h3>
                  readHosts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func readHosts()</code></pre>
            </article>
            
            <article class="function" data-name="readInterface">
               <h3>
                  readInterface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func readInterface(i int) (*Interface, error)</code></pre>
            </article>
            
            <article class="function" data-name="readLine">
               <h3>
                  readLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *file) readLine() (s string, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="readMsg">
               <h3>
                  readMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *IPConn) readMsg(b []byte, oob []byte) (n int, oobn int, flags int, addr *IPAddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readMsg">
               <h3>
                  readMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UDPConn) readMsg(b []byte, oob []byte) (n int, oobn int, flags int, addr netip.AddrPort, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readMsg">
               <h3>
                  readMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UnixConn) readMsg(b []byte, oob []byte) (n int, oobn int, flags int, addr *UnixAddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readMsg">
               <h3>
                  readMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *IPConn) readMsg(b []byte, oob []byte) (n int, oobn int, flags int, addr *IPAddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readMsg">
               <h3>
                  readMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) readMsg(p []byte, oob []byte, flags int) (n int, oobn int, retflags int, sa syscall.Sockaddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readMsg">
               <h3>
                  readMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) readMsg(p []byte, oob []byte, flags int) (n int, oobn int, retflags int, sa syscall.Sockaddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readMsg">
               <h3>
                  readMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UDPConn) readMsg(b []byte, oob []byte) (n int, oobn int, flags int, addr netip.AddrPort, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readMsg">
               <h3>
                  readMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UnixConn) readMsg(b []byte, oob []byte) (n int, oobn int, flags int, addr *UnixAddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readMsgInet4">
               <h3>
                  readMsgInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) readMsgInet4(p []byte, oob []byte, flags int, sa *syscall.SockaddrInet4) (n int, oobn int, retflags int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readMsgInet4">
               <h3>
                  readMsgInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) readMsgInet4(p []byte, oob []byte, flags int, sa *syscall.SockaddrInet4) (n int, oobn int, retflags int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readMsgInet6">
               <h3>
                  readMsgInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) readMsgInet6(p []byte, oob []byte, flags int, sa *syscall.SockaddrInet6) (n int, oobn int, retflags int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readMsgInet6">
               <h3>
                  readMsgInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) readMsgInet6(p []byte, oob []byte, flags int, sa *syscall.SockaddrInet6) (n int, oobn int, retflags int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readPlan9Addr">
               <h3>
                  readPlan9Addr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func readPlan9Addr(net string, filename string) (addr Addr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readProtocols">
               <h3>
                  readProtocols 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readProtocols loads contents of /etc/protocols into protocols map
for quick access.</p>
               
               <pre><code>func readProtocols()</code></pre>
            </article>
            
            <article class="function" data-name="readServices">
               <h3>
                  readServices 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func readServices()</code></pre>
            </article>
            
            <article class="function" data-name="recvfrom">
               <h3>
                  recvfrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pq *packetQueue) recvfrom(dt *deadlineTimer, b []byte, wholePacket bool, checkFrom func(sockaddr) error) (n int, from sockaddr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="releaseSema">
               <h3>
                  releaseSema 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (conf *nsswitchConfig) releaseSema()</code></pre>
            </article>
            
            <article class="function" data-name="releaseSema">
               <h3>
                  releaseSema 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (conf *resolverConfig) releaseSema()</code></pre>
            </article>
            
            <article class="function" data-name="releaseThread">
               <h3>
                  releaseThread 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func releaseThread()</code></pre>
            </article>
            
            <article class="function" data-name="removeComment">
               <h3>
                  removeComment 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>removeComment returns line, removing any '#' byte and any following
bytes.</p>
               
               <pre><code>func removeComment(line string) string</code></pre>
            </article>
            
            <article class="function" data-name="resSearch">
               <h3>
                  resSearch 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>resSearch will make a call to the 'res_nsearch' routine in the C library
and parse the output as a slice of DNS resources.</p>
               
               <pre><code>func resSearch(ctx context.Context, hostname string, rtype int, class int) ([]dnsmessage.Resource, error)</code></pre>
            </article>
            
            <article class="function" data-name="resolveAddrList">
               <h3>
                  resolveAddrList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>resolveAddrList resolves addr using hint and returns a list of
addresses. The result contains at least one address when error is
nil.</p>
               
               <pre><code>func (r *Resolver) resolveAddrList(ctx context.Context, op string, network string, addr string, hint Addr) (addrList, error)</code></pre>
            </article>
            
            <article class="function" data-name="resolveCNAME">
               <h3>
                  resolveCNAME 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>returns the last CNAME in chain.</p>
               
               <pre><code>func resolveCNAME(name *uint16, r *syscall.DNSRecord) *uint16</code></pre>
            </article>
            
            <article class="function" data-name="resolver">
               <h3>
                  resolver 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *Dialer) resolver() *Resolver</code></pre>
            </article>
            
            <article class="function" data-name="reverseaddr">
               <h3>
                  reverseaddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>reverseaddr returns the in-addr.arpa. or ip6.arpa. hostname of the IP
address addr suitable for rDNS (PTR) record lookup or an error if it fails
to parse the IP address.</p>
               
               <pre><code>func reverseaddr(addr string) (arpa string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="roundDurationUp">
               <h3>
                  roundDurationUp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>roundDurationUp rounds d to the next multiple of to.</p>
               
               <pre><code>func roundDurationUp(d time.Duration, to time.Duration) time.Duration</code></pre>
            </article>
            
            <article class="function" data-name="runtime_rand">
               <h3>
                  runtime_rand 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>provided by runtime
go:linkname runtime_rand runtime.rand</p>
               
               <pre><code>func runtime_rand() uint64</code></pre>
            </article>
            
            <article class="function" data-name="selfConnect">
               <h3>
                  selfConnect 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func selfConnect(fd *netFD, err error) bool</code></pre>
            </article>
            
            <article class="function" data-name="send">
               <h3>
                  send 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pq *packetQueue) send(dt *deadlineTimer, b []byte, from sockaddr, block bool) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="sendFile">
               <h3>
                  sendFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>sendFile copies the contents of r to c using the TransmitFile
system call to minimize copies.
if handled == true, sendFile returns the number of bytes copied and any
non-EOF error.
if handled == false, sendFile performed no work.</p>
               
               <pre><code>func sendFile(fd *netFD, r io.Reader) (written int64, err error, handled bool)</code></pre>
            </article>
            
            <article class="function" data-name="sendFile">
               <h3>
                  sendFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>sendFile copies the contents of r to c using the sendfile
system call to minimize copies.
if handled == true, sendFile returns the number (potentially zero) of bytes
copied and any non-EOF error.
if handled == false, sendFile performed no work.</p>
               
               <pre><code>func sendFile(c *netFD, r io.Reader) (written int64, err error, handled bool)</code></pre>
            </article>
            
            <article class="function" data-name="sendFile">
               <h3>
                  sendFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>sendFile copies the contents of r to c using the sendfile
system call to minimize copies.
if handled == true, sendFile returns the number (potentially zero) of bytes
copied and any non-EOF error.
if handled == false, sendFile performed no work.</p>
               
               <pre><code>func sendFile(c *netFD, r io.Reader) (written int64, err error, handled bool)</code></pre>
            </article>
            
            <article class="function" data-name="sendFile">
               <h3>
                  sendFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sendFile(c *netFD, r io.Reader) (n int64, err error, handled bool)</code></pre>
            </article>
            
            <article class="function" data-name="serverOffset">
               <h3>
                  serverOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>serverOffset returns an offset that can be used to determine
indices of servers in c.servers when making queries.
When the rotate option is enabled, this offset increases.
Otherwise it is always 0.</p>
               
               <pre><code>func (c *dnsConfig) serverOffset() uint32</code></pre>
            </article>
            
            <article class="function" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m *mptcpStatusListen) set(use bool)</code></pre>
            </article>
            
            <article class="function" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m *mptcpStatusDial) set(use bool)</code></pre>
            </article>
            
            <article class="function" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>set sets the point in time when the deadline will time out.
A timeout event is signaled by closing the channel returned by waiter.
Once a timeout has occurred, the deadline can be refreshed by specifying a
t value in the future.
A zero value for t prevents timeout.</p>
               
               <pre><code>func (d *pipeDeadline) set(t time.Time)</code></pre>
            </article>
            
            <article class="function" data-name="setAddr">
               <h3>
                  setAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) setAddr(laddr Addr, raddr Addr)</code></pre>
            </article>
            
            <article class="function" data-name="setAddr">
               <h3>
                  setAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) setAddr(laddr Addr, raddr Addr)</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultListenerSockopts">
               <h3>
                  setDefaultListenerSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultListenerSockopts(s int) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultListenerSockopts">
               <h3>
                  setDefaultListenerSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultListenerSockopts(s syscall.Handle) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultListenerSockopts">
               <h3>
                  setDefaultListenerSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultListenerSockopts(s int) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultListenerSockopts">
               <h3>
                  setDefaultListenerSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultListenerSockopts(s int) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultListenerSockopts">
               <h3>
                  setDefaultListenerSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultListenerSockopts(s int) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultListenerSockopts">
               <h3>
                  setDefaultListenerSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultListenerSockopts(s int) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultMulticastSockopts">
               <h3>
                  setDefaultMulticastSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultMulticastSockopts(s syscall.Handle) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultMulticastSockopts">
               <h3>
                  setDefaultMulticastSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultMulticastSockopts(s int) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultMulticastSockopts">
               <h3>
                  setDefaultMulticastSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultMulticastSockopts(s int) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultMulticastSockopts">
               <h3>
                  setDefaultMulticastSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultMulticastSockopts(s int) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultMulticastSockopts">
               <h3>
                  setDefaultMulticastSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultMulticastSockopts(s int) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultMulticastSockopts">
               <h3>
                  setDefaultMulticastSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultMulticastSockopts(s int) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultSockopts">
               <h3>
                  setDefaultSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultSockopts(s int, family int, sotype int, ipv6only bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultSockopts">
               <h3>
                  setDefaultSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultSockopts(s syscall.Handle, family int, sotype int, ipv6only bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultSockopts">
               <h3>
                  setDefaultSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultSockopts(s int, family int, sotype int, ipv6only bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultSockopts">
               <h3>
                  setDefaultSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultSockopts(s int, family int, sotype int, ipv6only bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultSockopts">
               <h3>
                  setDefaultSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultSockopts(s int, family int, sotype int, ipv6only bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultSockopts">
               <h3>
                  setDefaultSockopts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDefaultSockopts(s int, family int, sotype int, ipv6only bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setIPv4MreqToInterface">
               <h3>
                  setIPv4MreqToInterface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setIPv4MreqToInterface(mreq *syscall.IPMreq, ifi *Interface) error</code></pre>
            </article>
            
            <article class="function" data-name="setIPv4MulticastInterface">
               <h3>
                  setIPv4MulticastInterface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error</code></pre>
            </article>
            
            <article class="function" data-name="setIPv4MulticastInterface">
               <h3>
                  setIPv4MulticastInterface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error</code></pre>
            </article>
            
            <article class="function" data-name="setIPv4MulticastInterface">
               <h3>
                  setIPv4MulticastInterface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error</code></pre>
            </article>
            
            <article class="function" data-name="setIPv4MulticastInterface">
               <h3>
                  setIPv4MulticastInterface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error</code></pre>
            </article>
            
            <article class="function" data-name="setIPv4MulticastLoopback">
               <h3>
                  setIPv4MulticastLoopback 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setIPv4MulticastLoopback(fd *netFD, v bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setIPv4MulticastLoopback">
               <h3>
                  setIPv4MulticastLoopback 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setIPv4MulticastLoopback(fd *netFD, v bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setIPv4MulticastLoopback">
               <h3>
                  setIPv4MulticastLoopback 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setIPv4MulticastLoopback(fd *netFD, v bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setIPv4MulticastLoopback">
               <h3>
                  setIPv4MulticastLoopback 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setIPv4MulticastLoopback(fd *netFD, v bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setIPv6MulticastInterface">
               <h3>
                  setIPv6MulticastInterface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setIPv6MulticastInterface(fd *netFD, ifi *Interface) error</code></pre>
            </article>
            
            <article class="function" data-name="setIPv6MulticastInterface">
               <h3>
                  setIPv6MulticastInterface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setIPv6MulticastInterface(fd *netFD, ifi *Interface) error</code></pre>
            </article>
            
            <article class="function" data-name="setIPv6MulticastLoopback">
               <h3>
                  setIPv6MulticastLoopback 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setIPv6MulticastLoopback(fd *netFD, v bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setIPv6MulticastLoopback">
               <h3>
                  setIPv6MulticastLoopback 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setIPv6MulticastLoopback(fd *netFD, v bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAlive">
               <h3>
                  setKeepAlive 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAlive(fd *netFD, keepalive bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAlive">
               <h3>
                  setKeepAlive 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAlive(fd *netFD, keepalive bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAlive">
               <h3>
                  setKeepAlive 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAlive(fd *netFD, keepalive bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveCount">
               <h3>
                  setKeepAliveCount 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveCount(fd *netFD, n int) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveCount">
               <h3>
                  setKeepAliveCount 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveCount(_ *netFD, n int) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveCount">
               <h3>
                  setKeepAliveCount 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveCount(_ *netFD, n int) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveCount">
               <h3>
                  setKeepAliveCount 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveCount(fd *netFD, n int) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveCount">
               <h3>
                  setKeepAliveCount 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveCount(fd *netFD, n int) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveCount">
               <h3>
                  setKeepAliveCount 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveCount(fd *netFD, n int) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveCount">
               <h3>
                  setKeepAliveCount 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveCount(fd *netFD, n int) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveIdle">
               <h3>
                  setKeepAliveIdle 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveIdle(_ *netFD, d time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveIdle">
               <h3>
                  setKeepAliveIdle 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveIdle(fd *netFD, d time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveIdle">
               <h3>
                  setKeepAliveIdle 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveIdle(fd *netFD, d time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveIdle">
               <h3>
                  setKeepAliveIdle 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveIdle(fd *netFD, d time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveIdle">
               <h3>
                  setKeepAliveIdle 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveIdle(fd *netFD, d time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveIdle">
               <h3>
                  setKeepAliveIdle 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Set keep alive period.</p>
               
               <pre><code>func setKeepAliveIdle(fd *netFD, d time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveIdle">
               <h3>
                  setKeepAliveIdle 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveIdle(fd *netFD, d time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveIdleAndInterval">
               <h3>
                  setKeepAliveIdleAndInterval 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>setKeepAliveIdleAndInterval serves for kernels prior to Windows 10, version 1709.</p>
               
               <pre><code>func setKeepAliveIdleAndInterval(fd *netFD, idle time.Duration, interval time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveIdleAndIntervalAndCount">
               <h3>
                  setKeepAliveIdleAndIntervalAndCount 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>setKeepAliveIdleAndIntervalAndCount serves for Solaris prior to 11.4 by simulating
the TCP_KEEPIDLE, TCP_KEEPINTVL, and TCP_KEEPCNT with `TCP_KEEPALIVE_THRESHOLD` + `TCP_KEEPALIVE_ABORT_THRESHOLD`.</p>
               
               <pre><code>func setKeepAliveIdleAndIntervalAndCount(fd *netFD, idle time.Duration, interval time.Duration, count int) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveInterval">
               <h3>
                  setKeepAliveInterval 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveInterval(_ *netFD, d time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveInterval">
               <h3>
                  setKeepAliveInterval 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveInterval(fd *netFD, d time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveInterval">
               <h3>
                  setKeepAliveInterval 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveInterval(fd *netFD, d time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveInterval">
               <h3>
                  setKeepAliveInterval 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveInterval(fd *netFD, d time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveInterval">
               <h3>
                  setKeepAliveInterval 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveInterval(_ *netFD, d time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveInterval">
               <h3>
                  setKeepAliveInterval 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveInterval(fd *netFD, d time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="setKeepAliveInterval">
               <h3>
                  setKeepAliveInterval 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setKeepAliveInterval(fd *netFD, d time.Duration) error</code></pre>
            </article>
            
            <article class="function" data-name="setLinger">
               <h3>
                  setLinger 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setLinger(fd *netFD, sec int) error</code></pre>
            </article>
            
            <article class="function" data-name="setLinger">
               <h3>
                  setLinger 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pq *packetQueue) setLinger(linger bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setLinger">
               <h3>
                  setLinger 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) setLinger(sec int) error</code></pre>
            </article>
            
            <article class="function" data-name="setLinger">
               <h3>
                  setLinger 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setLinger(fd *netFD, sec int) error</code></pre>
            </article>
            
            <article class="function" data-name="setLinger">
               <h3>
                  setLinger 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setLinger(fd *netFD, sec int) error</code></pre>
            </article>
            
            <article class="function" data-name="setNoDelay">
               <h3>
                  setNoDelay 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setNoDelay(fd *netFD, noDelay bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setNoDelay">
               <h3>
                  setNoDelay 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setNoDelay(fd *netFD, noDelay bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setNoDelay">
               <h3>
                  setNoDelay 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setNoDelay(_ *netFD, _ bool) error</code></pre>
            </article>
            
            <article class="function" data-name="setReadBuffer">
               <h3>
                  setReadBuffer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) setReadBuffer(bytes int) error</code></pre>
            </article>
            
            <article class="function" data-name="setReadBuffer">
               <h3>
                  setReadBuffer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setReadBuffer sets a soft limit on the number of bytes available to read
from the pipe.</p>
               
               <pre><code>func (pq *packetQueue) setReadBuffer(bytes int) error</code></pre>
            </article>
            
            <article class="function" data-name="setReadBuffer">
               <h3>
                  setReadBuffer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setReadBuffer(fd *netFD, bytes int) error</code></pre>
            </article>
            
            <article class="function" data-name="setReadBuffer">
               <h3>
                  setReadBuffer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setReadBuffer(fd *netFD, bytes int) error</code></pre>
            </article>
            
            <article class="function" data-name="setReadBuffer">
               <h3>
                  setReadBuffer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setReadBuffer(fd *netFD, bytes int) error</code></pre>
            </article>
            
            <article class="function" data-name="setReadMsgCloseOnExec">
               <h3>
                  setReadMsgCloseOnExec 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setReadMsgCloseOnExec(oob []byte)</code></pre>
            </article>
            
            <article class="function" data-name="setReadMsgCloseOnExec">
               <h3>
                  setReadMsgCloseOnExec 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setReadMsgCloseOnExec(oob []byte)</code></pre>
            </article>
            
            <article class="function" data-name="setReadMsgCloseOnExec">
               <h3>
                  setReadMsgCloseOnExec 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setReadMsgCloseOnExec(oob []byte)</code></pre>
            </article>
            
            <article class="function" data-name="setWriteBuffer">
               <h3>
                  setWriteBuffer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setWriteBuffer(fd *netFD, bytes int) error</code></pre>
            </article>
            
            <article class="function" data-name="setWriteBuffer">
               <h3>
                  setWriteBuffer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) setWriteBuffer(bytes int) error</code></pre>
            </article>
            
            <article class="function" data-name="setWriteBuffer">
               <h3>
                  setWriteBuffer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setWriteBuffer(fd *netFD, bytes int) error</code></pre>
            </article>
            
            <article class="function" data-name="setWriteBuffer">
               <h3>
                  setWriteBuffer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setWriteBuffer(fd *netFD, bytes int) error</code></pre>
            </article>
            
            <article class="function" data-name="shuffleByWeight">
               <h3>
                  shuffleByWeight 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>shuffleByWeight shuffles SRV records by weight using the algorithm
described in RFC 2782.</p>
               
               <pre><code>func (addrs byPriorityWeight) shuffleByWeight()</code></pre>
            </article>
            
            <article class="function" data-name="shutdown">
               <h3>
                  shutdown 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) shutdown(how int) error</code></pre>
            </article>
            
            <article class="function" data-name="shutdown">
               <h3>
                  shutdown 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) shutdown(how int) error</code></pre>
            </article>
            
            <article class="function" data-name="simpleMaskLength">
               <h3>
                  simpleMaskLength 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If mask is a sequence of 1 bits followed by 0 bits,
return the number of 1 bits.</p>
               
               <pre><code>func simpleMaskLength(mask IPMask) int</code></pre>
            </article>
            
            <article class="function" data-name="skipToAnswer">
               <h3>
                  skipToAnswer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func skipToAnswer(p *dnsmessage.Parser, qtype dnsmessage.Type) error</code></pre>
            </article>
            
            <article class="function" data-name="sockaddr">
               <h3>
                  sockaddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *UnixAddr) sockaddr(family int) (syscall.Sockaddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="sockaddr">
               <h3>
                  sockaddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *TCPAddr) sockaddr(family int) (syscall.Sockaddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="sockaddr">
               <h3>
                  sockaddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *IPAddr) sockaddr(family int) (syscall.Sockaddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="sockaddr">
               <h3>
                  sockaddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *UDPAddr) sockaddr(family int) (syscall.Sockaddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="sockaddrToIP">
               <h3>
                  sockaddrToIP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sockaddrToIP(sa syscall.Sockaddr) Addr</code></pre>
            </article>
            
            <article class="function" data-name="sockaddrToTCP">
               <h3>
                  sockaddrToTCP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sockaddrToTCP(sa syscall.Sockaddr) Addr</code></pre>
            </article>
            
            <article class="function" data-name="sockaddrToUDP">
               <h3>
                  sockaddrToUDP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sockaddrToUDP(sa syscall.Sockaddr) Addr</code></pre>
            </article>
            
            <article class="function" data-name="sockaddrToUnix">
               <h3>
                  sockaddrToUnix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sockaddrToUnix(sa syscall.Sockaddr) Addr</code></pre>
            </article>
            
            <article class="function" data-name="sockaddrToUnixgram">
               <h3>
                  sockaddrToUnixgram 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sockaddrToUnixgram(sa syscall.Sockaddr) Addr</code></pre>
            </article>
            
            <article class="function" data-name="sockaddrToUnixpacket">
               <h3>
                  sockaddrToUnixpacket 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sockaddrToUnixpacket(sa syscall.Sockaddr) Addr</code></pre>
            </article>
            
            <article class="function" data-name="socket">
               <h3>
                  socket 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>socket returns a network file descriptor that is ready for
I/O using the fake network.</p>
               
               <pre><code>func socket(ctx context.Context, net string, family int, sotype int, proto int, ipv6only bool, laddr sockaddr, raddr sockaddr, ctrlCtxFn func(context.Context, string, string, syscall.RawConn) error) (*netFD, error)</code></pre>
            </article>
            
            <article class="function" data-name="socket">
               <h3>
                  socket 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>socket returns a network file descriptor that is ready for
asynchronous I/O using the network poller.</p>
               
               <pre><code>func socket(ctx context.Context, net string, family int, sotype int, proto int, ipv6only bool, laddr sockaddr, raddr sockaddr, ctrlCtxFn func(context.Context, string, string, syscall.RawConn) error) (fd *netFD, err error)</code></pre>
            </article>
            
            <article class="function" data-name="sort">
               <h3>
                  sort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>sort reorders MX records as specified in RFC 5321.</p>
               
               <pre><code>func (s byPref) sort()</code></pre>
            </article>
            
            <article class="function" data-name="sort">
               <h3>
                  sort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>sort reorders SRV records as specified in RFC 2782.</p>
               
               <pre><code>func (addrs byPriorityWeight) sort()</code></pre>
            </article>
            
            <article class="function" data-name="sortByRFC6724">
               <h3>
                  sortByRFC6724 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sortByRFC6724(addrs []IPAddr)</code></pre>
            </article>
            
            <article class="function" data-name="sortByRFC6724withSrcs">
               <h3>
                  sortByRFC6724withSrcs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sortByRFC6724withSrcs(addrs []IPAddr, srcs []netip.Addr)</code></pre>
            </article>
            
            <article class="function" data-name="sotypeToNet">
               <h3>
                  sotypeToNet 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sotypeToNet(sotype int) string</code></pre>
            </article>
            
            <article class="function" data-name="spliceFrom">
               <h3>
                  spliceFrom 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func spliceFrom(_ *netFD, _ io.Reader) (int64, error, bool)</code></pre>
            </article>
            
            <article class="function" data-name="spliceFrom">
               <h3>
                  spliceFrom 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>spliceFrom transfers data from r to c using the splice system call to minimize
copies from and to userspace. c must be a TCP connection.
Currently, spliceFrom is only enabled if r is a TCP or a stream-oriented Unix connection.
If spliceFrom returns handled == false, it has performed no work.</p>
               
               <pre><code>func spliceFrom(c *netFD, r io.Reader) (written int64, err error, handled bool)</code></pre>
            </article>
            
            <article class="function" data-name="spliceTo">
               <h3>
                  spliceTo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func spliceTo(_ io.Writer, _ *netFD) (int64, error, bool)</code></pre>
            </article>
            
            <article class="function" data-name="spliceTo">
               <h3>
                  spliceTo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>spliceTo transfers data from c to w using the splice system call to minimize
copies from and to userspace. c must be a TCP connection.
Currently, spliceTo is only enabled if w is a stream-oriented Unix connection.
If spliceTo returns handled == false, it has performed no work.</p>
               
               <pre><code>func spliceTo(w io.Writer, c *netFD) (written int64, err error, handled bool)</code></pre>
            </article>
            
            <article class="function" data-name="splitAtBytes">
               <h3>
                  splitAtBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Split s at any bytes in t.</p>
               
               <pre><code>func splitAtBytes(s string, t string) []string</code></pre>
            </article>
            
            <article class="function" data-name="splitHostZone">
               <h3>
                  splitHostZone 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func splitHostZone(s string) (host string, zone string)</code></pre>
            </article>
            
            <article class="function" data-name="spuriousENOTAVAIL">
               <h3>
                  spuriousENOTAVAIL 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func spuriousENOTAVAIL(err error) bool</code></pre>
            </article>
            
            <article class="function" data-name="srcAddrs">
               <h3>
                  srcAddrs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>srcAddrs tries to UDP-connect to each address to see if it has a
route. (This doesn't send any packets). The destination port
number is irrelevant.</p>
               
               <pre><code>func srcAddrs(addrs []IPAddr) []netip.Addr</code></pre>
            </article>
            
            <article class="function" data-name="standardCriteria">
               <h3>
                  standardCriteria 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>standardCriteria reports all specified criteria have the default
status actions.</p>
               
               <pre><code>func (s nssSource) standardCriteria() bool</code></pre>
            </article>
            
            <article class="function" data-name="standardStatusAction">
               <h3>
                  standardStatusAction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>standardStatusAction reports whether c is equivalent to not
specifying the criterion at all. last is whether this criteria is the
last in the list.</p>
               
               <pre><code>func (c nssCriterion) standardStatusAction(last bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="startPlan9">
               <h3>
                  startPlan9 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func startPlan9(ctx context.Context, net string, addr Addr) (ctl *os.File, dest string, proto string, name string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="stat">
               <h3>
                  stat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *file) stat() (mtime time.Time, size int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="stat">
               <h3>
                  stat 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func stat(name string) (mtime time.Time, size int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="status">
               <h3>
                  status 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) status(ln int) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="strictErrors">
               <h3>
                  strictErrors 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Resolver) strictErrors() bool</code></pre>
            </article>
            
            <article class="function" data-name="stringsEqualFold">
               <h3>
                  stringsEqualFold 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stringsEqualFold is strings.EqualFold, ASCII only. It reports whether s and t
are equal, ASCII-case-insensitively.</p>
               
               <pre><code>func stringsEqualFold(s string, t string) bool</code></pre>
            </article>
            
            <article class="function" data-name="stringsHasSuffixFold">
               <h3>
                  stringsHasSuffixFold 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stringsHasSuffixFold reports whether s ends in suffix,
ASCII-case-insensitively.</p>
               
               <pre><code>func stringsHasSuffixFold(s string, suffix string) bool</code></pre>
            </article>
            
            <article class="function" data-name="stripIPv4Header">
               <h3>
                  stripIPv4Header 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func stripIPv4Header(n int, b []byte) int</code></pre>
            </article>
            
            <article class="function" data-name="supportsIPv4">
               <h3>
                  supportsIPv4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>supportsIPv4 reports whether the platform supports IPv4 networking
functionality.</p>
               
               <pre><code>func supportsIPv4() bool</code></pre>
            </article>
            
            <article class="function" data-name="supportsIPv4map">
               <h3>
                  supportsIPv4map 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>supportsIPv4map reports whether the platform supports mapping an
IPv4 address inside an IPv6 address at transport layer
protocols. See RFC 4291, RFC 4038 and RFC 3493.</p>
               
               <pre><code>func supportsIPv4map() bool</code></pre>
            </article>
            
            <article class="function" data-name="supportsIPv6">
               <h3>
                  supportsIPv6 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>supportsIPv6 reports whether the platform supports IPv6 networking
functionality.</p>
               
               <pre><code>func supportsIPv6() bool</code></pre>
            </article>
            
            <article class="function" data-name="supportsMultipathTCP">
               <h3>
                  supportsMultipathTCP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func supportsMultipathTCP() bool</code></pre>
            </article>
            
            <article class="function" data-name="sysSocket">
               <h3>
                  sysSocket 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Wrapper around the socket system call that marks the returned file
descriptor as nonblocking and close-on-exec.</p>
               
               <pre><code>func sysSocket(family int, sotype int, proto int) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="sysSocket">
               <h3>
                  sysSocket 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Wrapper around the socket system call that marks the returned file
descriptor as nonblocking and close-on-exec.</p>
               
               <pre><code>func sysSocket(family int, sotype int, proto int) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="sysSocket">
               <h3>
                  sysSocket 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sysSocket(family int, sotype int, proto int) (syscall.Handle, error)</code></pre>
            </article>
            
            <article class="function" data-name="sysSocket">
               <h3>
                  sysSocket 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Wrapper around the socket system call that marks the returned file
descriptor as nonblocking and close-on-exec.</p>
               
               <pre><code>func sysSocket(family int, sotype int, proto int) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="sysSocket">
               <h3>
                  sysSocket 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sysSocket(family int, sotype int, proto int) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="systemConf">
               <h3>
                  systemConf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>systemConf returns the machine's network configuration.</p>
               
               <pre><code>func systemConf() *conf</code></pre>
            </article>
            
            <article class="function" data-name="toLocal">
               <h3>
                  toLocal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *UDPAddr) toLocal(net string) sockaddr</code></pre>
            </article>
            
            <article class="function" data-name="toLocal">
               <h3>
                  toLocal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *UnixAddr) toLocal(net string) sockaddr</code></pre>
            </article>
            
            <article class="function" data-name="toLocal">
               <h3>
                  toLocal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *TCPAddr) toLocal(net string) sockaddr</code></pre>
            </article>
            
            <article class="function" data-name="toLocal">
               <h3>
                  toLocal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func toLocal(a Addr, net string) Addr</code></pre>
            </article>
            
            <article class="function" data-name="toLocal">
               <h3>
                  toLocal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *IPAddr) toLocal(net string) sockaddr</code></pre>
            </article>
            
            <article class="function" data-name="toLower">
               <h3>
                  toLower 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>toLower returns a lower-case version of in. Restricting us to
ASCII is sufficient to handle the IP protocol names and allow
us to not depend on the strings and unicode packages.</p>
               
               <pre><code>func toLower(in string) string</code></pre>
            </article>
            
            <article class="function" data-name="trimSpace">
               <h3>
                  trimSpace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>trimSpace returns x without any leading or trailing ASCII whitespace.</p>
               
               <pre><code>func trimSpace(x string) string</code></pre>
            </article>
            
            <article class="function" data-name="tryAcquireSema">
               <h3>
                  tryAcquireSema 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (conf *resolverConfig) tryAcquireSema() bool</code></pre>
            </article>
            
            <article class="function" data-name="tryAcquireSema">
               <h3>
                  tryAcquireSema 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (conf *nsswitchConfig) tryAcquireSema() bool</code></pre>
            </article>
            
            <article class="function" data-name="tryOneName">
               <h3>
                  tryOneName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Do a lookup for a single name, which must be rooted
(otherwise answer will not find the answers).</p>
               
               <pre><code>func (r *Resolver) tryOneName(ctx context.Context, cfg *dnsConfig, name string, qtype dnsmessage.Type) (dnsmessage.Parser, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="tryUpdate">
               <h3>
                  tryUpdate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>tryUpdate tries to update conf.</p>
               
               <pre><code>func (conf *nsswitchConfig) tryUpdate()</code></pre>
            </article>
            
            <article class="function" data-name="tryUpdate">
               <h3>
                  tryUpdate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>tryUpdate tries to update conf with the named resolv.conf file.
The name variable only exists for testing. It is otherwise always
"/etc/resolv.conf".</p>
               
               <pre><code>func (conf *resolverConfig) tryUpdate(name string)</code></pre>
            </article>
            
            <article class="function" data-name="unixSocket">
               <h3>
                  unixSocket 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func unixSocket(ctx context.Context, net string, laddr sockaddr, raddr sockaddr, mode string, ctxCtrlFn func(context.Context, string, string, syscall.RawConn) error) (*netFD, error)</code></pre>
            </article>
            
            <article class="function" data-name="unmarshalUDPHeader">
               <h3>
                  unmarshalUDPHeader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func unmarshalUDPHeader(b []byte) (*udpHeader, []byte)</code></pre>
            </article>
            
            <article class="function" data-name="update">
               <h3>
                  update 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>update refreshes the network interface information if the cache was last
updated more than 1 minute ago, or if force is set. It reports whether the
cache was updated.</p>
               
               <pre><code>func (zc *ipv6ZoneCache) update(ift []Interface, force bool) (updated bool)</code></pre>
            </article>
            
            <article class="function" data-name="validRecs">
               <h3>
                  validRecs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>returns only results applicable to name and resolves CNAME entries.</p>
               
               <pre><code>func validRecs(r *syscall.DNSRecord, dnstype uint16, name string) []*syscall.DNSRecord</code></pre>
            </article>
            
            <article class="function" data-name="validateResolvedAddr">
               <h3>
                  validateResolvedAddr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func validateResolvedAddr(net string, family int, sa sockaddr) error</code></pre>
            </article>
            
            <article class="function" data-name="wait">
               <h3>
                  wait 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>wait returns a channel that is closed when the deadline is exceeded.</p>
               
               <pre><code>func (d *pipeDeadline) wait() (chan struct{...})</code></pre>
            </article>
            
            <article class="function" data-name="winError">
               <h3>
                  winError 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func winError(call string, err error) error</code></pre>
            </article>
            
            <article class="function" data-name="withUnexpiredValuesPreserved">
               <h3>
                  withUnexpiredValuesPreserved 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>withUnexpiredValuesPreserved returns a context.Context that only uses lookupCtx
for its values, otherwise it is never canceled and has no deadline.
If the lookup context expires, any looked up values will return nil.
See Issue 28600.</p>
               
               <pre><code>func withUnexpiredValuesPreserved(lookupCtx context.Context) context.Context</code></pre>
            </article>
            
            <article class="function" data-name="wrapSyscallError">
               <h3>
                  wrapSyscallError 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>wrapSyscallError takes an error and a syscall name. If the error is
a syscall.Errno, it wraps it in an os.SyscallError using the syscall name.</p>
               
               <pre><code>func wrapSyscallError(name string, err error) error</code></pre>
            </article>
            
            <article class="function" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pipe) write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pq *packetQueue) write(dt *deadlineTimer, b []byte, from sockaddr) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeBuffers">
               <h3>
                  writeBuffers 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *conn) writeBuffers(v *Buffers) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="writeBuffers">
               <h3>
                  writeBuffers 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) writeBuffers(buf *Buffers) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="writeBuffers">
               <h3>
                  writeBuffers 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) writeBuffers(v *Buffers) (n int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeBuffers">
               <h3>
                  writeBuffers 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *conn) writeBuffers(v *Buffers) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="writeMsg">
               <h3>
                  writeMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UDPConn) writeMsg(b []byte, oob []byte, addr *UDPAddr) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeMsg">
               <h3>
                  writeMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) writeMsg(p []byte, oob []byte, sa syscall.Sockaddr) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeMsg">
               <h3>
                  writeMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *IPConn) writeMsg(b []byte, oob []byte, addr *IPAddr) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeMsg">
               <h3>
                  writeMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *IPConn) writeMsg(b []byte, oob []byte, addr *IPAddr) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeMsg">
               <h3>
                  writeMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UnixConn) writeMsg(b []byte, oob []byte, addr *UnixAddr) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeMsg">
               <h3>
                  writeMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UDPConn) writeMsg(b []byte, oob []byte, addr *UDPAddr) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeMsg">
               <h3>
                  writeMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UnixConn) writeMsg(b []byte, oob []byte, addr *UnixAddr) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeMsg">
               <h3>
                  writeMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) writeMsg(p []byte, oob []byte, sa syscall.Sockaddr) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeMsgAddrPort">
               <h3>
                  writeMsgAddrPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UDPConn) writeMsgAddrPort(b []byte, oob []byte, addr netip.AddrPort) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeMsgAddrPort">
               <h3>
                  writeMsgAddrPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UDPConn) writeMsgAddrPort(b []byte, oob []byte, addr netip.AddrPort) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeMsgInet4">
               <h3>
                  writeMsgInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) writeMsgInet4(p []byte, oob []byte, sa *syscall.SockaddrInet4) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeMsgInet4">
               <h3>
                  writeMsgInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) writeMsgInet4(p []byte, oob []byte, sa *syscall.SockaddrInet4) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeMsgInet6">
               <h3>
                  writeMsgInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) writeMsgInet6(p []byte, oob []byte, sa *syscall.SockaddrInet6) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeMsgInet6">
               <h3>
                  writeMsgInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) writeMsgInet6(p []byte, oob []byte, sa *syscall.SockaddrInet6) (n int, oobn int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UDPConn) writeTo(b []byte, addr *UDPAddr) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UnixConn) writeTo(b []byte, addr *UnixAddr) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *IPConn) writeTo(b []byte, addr *IPAddr) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *TCPConn) writeTo(w io.Writer) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UDPConn) writeTo(b []byte, addr *UDPAddr) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) writeTo(p []byte, sa syscall.Sockaddr) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UnixConn) writeTo(b []byte, addr *UnixAddr) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *IPConn) writeTo(b []byte, addr *IPAddr) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *TCPConn) writeTo(w io.Writer) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) writeTo(p []byte, sa syscall.Sockaddr) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeToAddrPort">
               <h3>
                  writeToAddrPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UDPConn) writeToAddrPort(b []byte, addr netip.AddrPort) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="writeToAddrPort">
               <h3>
                  writeToAddrPort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *UDPConn) writeToAddrPort(b []byte, addr netip.AddrPort) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="writeToInet4">
               <h3>
                  writeToInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) writeToInet4(p []byte, sa *syscall.SockaddrInet4) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeToInet4">
               <h3>
                  writeToInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) writeToInet4(p []byte, sa *syscall.SockaddrInet4) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeToInet6">
               <h3>
                  writeToInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *netFD) writeToInet6(p []byte, sa *syscall.SockaddrInet6) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeToInet6">
               <h3>
                  writeToInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ffd *fakeNetFD) writeToInet6(p []byte, sa *syscall.SockaddrInet6) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="xtoi">
               <h3>
                  xtoi 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Hexadecimal to integer.
Returns number, characters consumed, success.</p>
               
               <pre><code>func xtoi(s string) (n int, i int, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="xtoi2">
               <h3>
                  xtoi2 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>xtoi2 converts the next two hex digits of s into a byte.
If s is longer than 2 bytes then the third byte must be e.
If the first two bytes of s are not hex digits or the third byte
does not match e, false is returned.</p>
               
               <pre><code>func xtoi2(s string, e byte) (byte, bool)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
