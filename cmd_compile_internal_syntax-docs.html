<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - syntax</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="cmd_compile_internal_syntax_testdata-docs.html">testdata</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>syntax</code>
         </h1>
         <hr />
         
         <article class="global" data-name="testdata">
            <h2>testdata</h2>
            <hr />
            
            <pre><code>testdata</code></pre>
         </article>
         
         <article class="global" data-name="print">
            <h2>print</h2>
            <hr />
            
            <pre><code>print</code></pre>
         </article>
         
         <article class="global" data-name="stringTests">
            <h2>stringTests</h2>
            <hr />
            
            <pre><code>stringTests</code></pre>
         </article>
         
         <article class="global" data-name="exprTests">
            <h2>exprTests</h2>
            <hr />
            
            <pre><code>exprTests</code></pre>
         </article>
         
         <article class="global" data-name="sampleTokens">
            <h2>sampleTokens</h2>
            <hr />
            
            <pre><code>sampleTokens</code></pre>
         </article>
         
         <article class="global" data-name="sentinel">
            <h2>sentinel</h2>
            <hr />
            
            <pre><code>sentinel</code></pre>
         </article>
         
         <article class="global" data-name="linebase">
            <h2>linebase</h2>
            <hr />
            
            <p>starting points for line and column numbers</p>
            
            <pre><code>linebase</code></pre>
         </article>
         
         <article class="global" data-name="colbase">
            <h2>colbase</h2>
            <hr />
            
            <pre><code>colbase</code></pre>
         </article>
         
         <article class="global" data-name="_token_name">
            <h2>_token_name</h2>
            <hr />
            
            <pre><code>_token_name</code></pre>
         </article>
         
         <article class="global" data-name="_token_index">
            <h2>_token_index</h2>
            <hr />
            
            <pre><code>_token_index</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ token</code></pre>
         </article>
         
         <article class="global" data-name="_EOF">
            <h2>_EOF</h2>
            <hr />
            
            <pre><code>_EOF</code></pre>
         </article>
         
         <article class="global" data-name="_Name">
            <h2>_Name</h2>
            <hr />
            
            <p>names and literals</p>
            
            <pre><code>_Name</code></pre>
         </article>
         
         <article class="global" data-name="_Literal">
            <h2>_Literal</h2>
            <hr />
            
            <pre><code>_Literal</code></pre>
         </article>
         
         <article class="global" data-name="_Operator">
            <h2>_Operator</h2>
            <hr />
            
            <p>operators and operations
_Operator is excluding '*' (_Star)</p>
            
            <pre><code>_Operator</code></pre>
         </article>
         
         <article class="global" data-name="_AssignOp">
            <h2>_AssignOp</h2>
            <hr />
            
            <pre><code>_AssignOp</code></pre>
         </article>
         
         <article class="global" data-name="_IncOp">
            <h2>_IncOp</h2>
            <hr />
            
            <pre><code>_IncOp</code></pre>
         </article>
         
         <article class="global" data-name="_Assign">
            <h2>_Assign</h2>
            <hr />
            
            <pre><code>_Assign</code></pre>
         </article>
         
         <article class="global" data-name="_Define">
            <h2>_Define</h2>
            <hr />
            
            <pre><code>_Define</code></pre>
         </article>
         
         <article class="global" data-name="_Arrow">
            <h2>_Arrow</h2>
            <hr />
            
            <pre><code>_Arrow</code></pre>
         </article>
         
         <article class="global" data-name="_Star">
            <h2>_Star</h2>
            <hr />
            
            <pre><code>_Star</code></pre>
         </article>
         
         <article class="global" data-name="_Lparen">
            <h2>_Lparen</h2>
            <hr />
            
            <p>delimiters</p>
            
            <pre><code>_Lparen</code></pre>
         </article>
         
         <article class="global" data-name="_Lbrack">
            <h2>_Lbrack</h2>
            <hr />
            
            <pre><code>_Lbrack</code></pre>
         </article>
         
         <article class="global" data-name="_Lbrace">
            <h2>_Lbrace</h2>
            <hr />
            
            <pre><code>_Lbrace</code></pre>
         </article>
         
         <article class="global" data-name="_Rparen">
            <h2>_Rparen</h2>
            <hr />
            
            <pre><code>_Rparen</code></pre>
         </article>
         
         <article class="global" data-name="_Rbrack">
            <h2>_Rbrack</h2>
            <hr />
            
            <pre><code>_Rbrack</code></pre>
         </article>
         
         <article class="global" data-name="_Rbrace">
            <h2>_Rbrace</h2>
            <hr />
            
            <pre><code>_Rbrace</code></pre>
         </article>
         
         <article class="global" data-name="_Comma">
            <h2>_Comma</h2>
            <hr />
            
            <pre><code>_Comma</code></pre>
         </article>
         
         <article class="global" data-name="_Semi">
            <h2>_Semi</h2>
            <hr />
            
            <pre><code>_Semi</code></pre>
         </article>
         
         <article class="global" data-name="_Colon">
            <h2>_Colon</h2>
            <hr />
            
            <pre><code>_Colon</code></pre>
         </article>
         
         <article class="global" data-name="_Dot">
            <h2>_Dot</h2>
            <hr />
            
            <pre><code>_Dot</code></pre>
         </article>
         
         <article class="global" data-name="_DotDotDot">
            <h2>_DotDotDot</h2>
            <hr />
            
            <pre><code>_DotDotDot</code></pre>
         </article>
         
         <article class="global" data-name="_Break">
            <h2>_Break</h2>
            <hr />
            
            <p>keywords</p>
            
            <pre><code>_Break</code></pre>
         </article>
         
         <article class="global" data-name="_Case">
            <h2>_Case</h2>
            <hr />
            
            <pre><code>_Case</code></pre>
         </article>
         
         <article class="global" data-name="_Chan">
            <h2>_Chan</h2>
            <hr />
            
            <pre><code>_Chan</code></pre>
         </article>
         
         <article class="global" data-name="_Const">
            <h2>_Const</h2>
            <hr />
            
            <pre><code>_Const</code></pre>
         </article>
         
         <article class="global" data-name="_Continue">
            <h2>_Continue</h2>
            <hr />
            
            <pre><code>_Continue</code></pre>
         </article>
         
         <article class="global" data-name="_Default">
            <h2>_Default</h2>
            <hr />
            
            <pre><code>_Default</code></pre>
         </article>
         
         <article class="global" data-name="_Defer">
            <h2>_Defer</h2>
            <hr />
            
            <pre><code>_Defer</code></pre>
         </article>
         
         <article class="global" data-name="_Else">
            <h2>_Else</h2>
            <hr />
            
            <pre><code>_Else</code></pre>
         </article>
         
         <article class="global" data-name="_Fallthrough">
            <h2>_Fallthrough</h2>
            <hr />
            
            <pre><code>_Fallthrough</code></pre>
         </article>
         
         <article class="global" data-name="_For">
            <h2>_For</h2>
            <hr />
            
            <pre><code>_For</code></pre>
         </article>
         
         <article class="global" data-name="_Func">
            <h2>_Func</h2>
            <hr />
            
            <pre><code>_Func</code></pre>
         </article>
         
         <article class="global" data-name="_Go">
            <h2>_Go</h2>
            <hr />
            
            <pre><code>_Go</code></pre>
         </article>
         
         <article class="global" data-name="_Goto">
            <h2>_Goto</h2>
            <hr />
            
            <pre><code>_Goto</code></pre>
         </article>
         
         <article class="global" data-name="_If">
            <h2>_If</h2>
            <hr />
            
            <pre><code>_If</code></pre>
         </article>
         
         <article class="global" data-name="_Import">
            <h2>_Import</h2>
            <hr />
            
            <pre><code>_Import</code></pre>
         </article>
         
         <article class="global" data-name="_Interface">
            <h2>_Interface</h2>
            <hr />
            
            <pre><code>_Interface</code></pre>
         </article>
         
         <article class="global" data-name="_Map">
            <h2>_Map</h2>
            <hr />
            
            <pre><code>_Map</code></pre>
         </article>
         
         <article class="global" data-name="_Package">
            <h2>_Package</h2>
            <hr />
            
            <pre><code>_Package</code></pre>
         </article>
         
         <article class="global" data-name="_Range">
            <h2>_Range</h2>
            <hr />
            
            <pre><code>_Range</code></pre>
         </article>
         
         <article class="global" data-name="_Return">
            <h2>_Return</h2>
            <hr />
            
            <pre><code>_Return</code></pre>
         </article>
         
         <article class="global" data-name="_Select">
            <h2>_Select</h2>
            <hr />
            
            <pre><code>_Select</code></pre>
         </article>
         
         <article class="global" data-name="_Struct">
            <h2>_Struct</h2>
            <hr />
            
            <pre><code>_Struct</code></pre>
         </article>
         
         <article class="global" data-name="_Switch">
            <h2>_Switch</h2>
            <hr />
            
            <pre><code>_Switch</code></pre>
         </article>
         
         <article class="global" data-name="_Type">
            <h2>_Type</h2>
            <hr />
            
            <pre><code>_Type</code></pre>
         </article>
         
         <article class="global" data-name="_Var">
            <h2>_Var</h2>
            <hr />
            
            <pre><code>_Var</code></pre>
         </article>
         
         <article class="global" data-name="tokenCount">
            <h2>tokenCount</h2>
            <hr />
            
            <p>empty line comment to exclude it from .String</p>
            
            <pre><code>tokenCount</code></pre>
         </article>
         
         <article class="global" data-name="Break">
            <h2>Break</h2>
            <hr />
            
            <p>for BranchStmt</p>
            
            <pre><code>Break</code></pre>
         </article>
         
         <article class="global" data-name="Continue">
            <h2>Continue</h2>
            <hr />
            
            <pre><code>Continue</code></pre>
         </article>
         
         <article class="global" data-name="Fallthrough">
            <h2>Fallthrough</h2>
            <hr />
            
            <pre><code>Fallthrough</code></pre>
         </article>
         
         <article class="global" data-name="Goto">
            <h2>Goto</h2>
            <hr />
            
            <pre><code>Goto</code></pre>
         </article>
         
         <article class="global" data-name="Go">
            <h2>Go</h2>
            <hr />
            
            <p>for CallStmt</p>
            
            <pre><code>Go</code></pre>
         </article>
         
         <article class="global" data-name="Defer">
            <h2>Defer</h2>
            <hr />
            
            <pre><code>Defer</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <p>Make sure we have at most 64 tokens so we can use them in a set.</p>
            
            <pre><code>_ uint64</code></pre>
         </article>
         
         <article class="global" data-name="IntLit">
            <h2>IntLit</h2>
            <hr />
            
            <p>TODO(gri) With the 'i' (imaginary) suffix now permitted on integer
and floating-point numbers, having a single ImagLit does
not represent the literal kind well anymore. Remove it?</p>
            
            <pre><code>IntLit LitKind</code></pre>
         </article>
         
         <article class="global" data-name="FloatLit">
            <h2>FloatLit</h2>
            <hr />
            
            <p>TODO(gri) With the 'i' (imaginary) suffix now permitted on integer
and floating-point numbers, having a single ImagLit does
not represent the literal kind well anymore. Remove it?</p>
            
            <pre><code>FloatLit</code></pre>
         </article>
         
         <article class="global" data-name="ImagLit">
            <h2>ImagLit</h2>
            <hr />
            
            <p>TODO(gri) With the 'i' (imaginary) suffix now permitted on integer
and floating-point numbers, having a single ImagLit does
not represent the literal kind well anymore. Remove it?</p>
            
            <pre><code>ImagLit</code></pre>
         </article>
         
         <article class="global" data-name="RuneLit">
            <h2>RuneLit</h2>
            <hr />
            
            <p>TODO(gri) With the 'i' (imaginary) suffix now permitted on integer
and floating-point numbers, having a single ImagLit does
not represent the literal kind well anymore. Remove it?</p>
            
            <pre><code>RuneLit</code></pre>
         </article>
         
         <article class="global" data-name="StringLit">
            <h2>StringLit</h2>
            <hr />
            
            <p>TODO(gri) With the 'i' (imaginary) suffix now permitted on integer
and floating-point numbers, having a single ImagLit does
not represent the literal kind well anymore. Remove it?</p>
            
            <pre><code>StringLit</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ Operator</code></pre>
         </article>
         
         <article class="global" data-name="Def">
            <h2>Def</h2>
            <hr />
            
            <p>Def is the : in :=</p>
            
            <pre><code>Def</code></pre>
         </article>
         
         <article class="global" data-name="Not">
            <h2>Not</h2>
            <hr />
            
            <pre><code>Not</code></pre>
         </article>
         
         <article class="global" data-name="Recv">
            <h2>Recv</h2>
            <hr />
            
            <pre><code>Recv</code></pre>
         </article>
         
         <article class="global" data-name="Tilde">
            <h2>Tilde</h2>
            <hr />
            
            <pre><code>Tilde</code></pre>
         </article>
         
         <article class="global" data-name="OrOr">
            <h2>OrOr</h2>
            <hr />
            
            <p>precOrOr</p>
            
            <pre><code>OrOr</code></pre>
         </article>
         
         <article class="global" data-name="AndAnd">
            <h2>AndAnd</h2>
            <hr />
            
            <p>precAndAnd</p>
            
            <pre><code>AndAnd</code></pre>
         </article>
         
         <article class="global" data-name="Eql">
            <h2>Eql</h2>
            <hr />
            
            <p>precCmp</p>
            
            <pre><code>Eql</code></pre>
         </article>
         
         <article class="global" data-name="Neq">
            <h2>Neq</h2>
            <hr />
            
            <pre><code>Neq</code></pre>
         </article>
         
         <article class="global" data-name="Lss">
            <h2>Lss</h2>
            <hr />
            
            <pre><code>Lss</code></pre>
         </article>
         
         <article class="global" data-name="Leq">
            <h2>Leq</h2>
            <hr />
            
            <pre><code>Leq</code></pre>
         </article>
         
         <article class="global" data-name="Gtr">
            <h2>Gtr</h2>
            <hr />
            
            <pre><code>Gtr</code></pre>
         </article>
         
         <article class="global" data-name="Geq">
            <h2>Geq</h2>
            <hr />
            
            <pre><code>Geq</code></pre>
         </article>
         
         <article class="global" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>precAdd</p>
            
            <pre><code>Add</code></pre>
         </article>
         
         <article class="global" data-name="Sub">
            <h2>Sub</h2>
            <hr />
            
            <pre><code>Sub</code></pre>
         </article>
         
         <article class="global" data-name="Or">
            <h2>Or</h2>
            <hr />
            
            <pre><code>Or</code></pre>
         </article>
         
         <article class="global" data-name="Xor">
            <h2>Xor</h2>
            <hr />
            
            <pre><code>Xor</code></pre>
         </article>
         
         <article class="global" data-name="Mul">
            <h2>Mul</h2>
            <hr />
            
            <p>precMul</p>
            
            <pre><code>Mul</code></pre>
         </article>
         
         <article class="global" data-name="Div">
            <h2>Div</h2>
            <hr />
            
            <pre><code>Div</code></pre>
         </article>
         
         <article class="global" data-name="Rem">
            <h2>Rem</h2>
            <hr />
            
            <pre><code>Rem</code></pre>
         </article>
         
         <article class="global" data-name="And">
            <h2>And</h2>
            <hr />
            
            <pre><code>And</code></pre>
         </article>
         
         <article class="global" data-name="AndNot">
            <h2>AndNot</h2>
            <hr />
            
            <pre><code>AndNot</code></pre>
         </article>
         
         <article class="global" data-name="Shl">
            <h2>Shl</h2>
            <hr />
            
            <pre><code>Shl</code></pre>
         </article>
         
         <article class="global" data-name="Shr">
            <h2>Shr</h2>
            <hr />
            
            <pre><code>Shr</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <p>Operator precedences</p>
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="precOrOr">
            <h2>precOrOr</h2>
            <hr />
            
            <p>Operator precedences</p>
            
            <pre><code>precOrOr</code></pre>
         </article>
         
         <article class="global" data-name="precAndAnd">
            <h2>precAndAnd</h2>
            <hr />
            
            <p>Operator precedences</p>
            
            <pre><code>precAndAnd</code></pre>
         </article>
         
         <article class="global" data-name="precCmp">
            <h2>precCmp</h2>
            <hr />
            
            <p>Operator precedences</p>
            
            <pre><code>precCmp</code></pre>
         </article>
         
         <article class="global" data-name="precAdd">
            <h2>precAdd</h2>
            <hr />
            
            <p>Operator precedences</p>
            
            <pre><code>precAdd</code></pre>
         </article>
         
         <article class="global" data-name="precMul">
            <h2>precMul</h2>
            <hr />
            
            <p>Operator precedences</p>
            
            <pre><code>precMul</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ ChanDir</code></pre>
         </article>
         
         <article class="global" data-name="SendOnly">
            <h2>SendOnly</h2>
            <hr />
            
            <pre><code>SendOnly</code></pre>
         </article>
         
         <article class="global" data-name="RecvOnly">
            <h2>RecvOnly</h2>
            <hr />
            
            <pre><code>RecvOnly</code></pre>
         </article>
         
         <article class="global" data-name="Above">
            <h2>Above</h2>
            <hr />
            
            <pre><code>Above CommentKind</code></pre>
         </article>
         
         <article class="global" data-name="Below">
            <h2>Below</h2>
            <hr />
            
            <pre><code>Below</code></pre>
         </article>
         
         <article class="global" data-name="Left">
            <h2>Left</h2>
            <hr />
            
            <pre><code>Left</code></pre>
         </article>
         
         <article class="global" data-name="Right">
            <h2>Right</h2>
            <hr />
            
            <pre><code>Right</code></pre>
         </article>
         
         <article class="global" data-name="decls">
            <h2>decls</h2>
            <hr />
            
            <pre><code>decls</code></pre>
         </article>
         
         <article class="global" data-name="exprs">
            <h2>exprs</h2>
            <hr />
            
            <pre><code>exprs</code></pre>
         </article>
         
         <article class="global" data-name="types">
            <h2>types</h2>
            <hr />
            
            <pre><code>types</code></pre>
         </article>
         
         <article class="global" data-name="fields">
            <h2>fields</h2>
            <hr />
            
            <pre><code>fields</code></pre>
         </article>
         
         <article class="global" data-name="stmts">
            <h2>stmts</h2>
            <hr />
            
            <pre><code>stmts</code></pre>
         </article>
         
         <article class="global" data-name="ranges">
            <h2>ranges</h2>
            <hr />
            
            <pre><code>ranges</code></pre>
         </article>
         
         <article class="global" data-name="guards">
            <h2>guards</h2>
            <hr />
            
            <pre><code>guards</code></pre>
         </article>
         
         <article class="global" data-name="cases">
            <h2>cases</h2>
            <hr />
            
            <pre><code>cases</code></pre>
         </article>
         
         <article class="global" data-name="comms">
            <h2>comms</h2>
            <hr />
            
            <pre><code>comms</code></pre>
         </article>
         
         <article class="global" data-name="fast">
            <h2>fast</h2>
            <hr />
            
            <pre><code>fast</code></pre>
         </article>
         
         <article class="global" data-name="verify">
            <h2>verify</h2>
            <hr />
            
            <pre><code>verify</code></pre>
         </article>
         
         <article class="global" data-name="src_">
            <h2>src_</h2>
            <hr />
            
            <pre><code>src_</code></pre>
         </article>
         
         <article class="global" data-name="skip">
            <h2>skip</h2>
            <hr />
            
            <pre><code>skip</code></pre>
         </article>
         
         <article class="global" data-name="tooLarge">
            <h2>tooLarge</h2>
            <hr />
            
            <p>Make sure (PosMax + 1) doesn't overflow when converted to default
type int (when passed as argument to fmt.Sprintf) on 32bit platforms
(see test cases below).</p>
            
            <pre><code>tooLarge int</code></pre>
         </article>
         
         <article class="global" data-name="PosMax">
            <h2>PosMax</h2>
            <hr />
            
            <p>PosMax is the largest line or column value that can be represented without loss.
Incoming values (arguments) larger than PosMax will be set to PosMax.

Keep this consistent with maxLineCol in go/scanner.</p>
            
            <pre><code>PosMax</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ Form</code></pre>
         </article>
         
         <article class="global" data-name="LineForm">
            <h2>LineForm</h2>
            <hr />
            
            <pre><code>LineForm</code></pre>
         </article>
         
         <article class="global" data-name="ShortForm">
            <h2>ShortForm</h2>
            <hr />
            
            <pre><code>ShortForm</code></pre>
         </article>
         
         <article class="global" data-name="none">
            <h2>none</h2>
            <hr />
            
            <pre><code>none ctrlSymbol</code></pre>
         </article>
         
         <article class="global" data-name="semi">
            <h2>semi</h2>
            <hr />
            
            <pre><code>semi</code></pre>
         </article>
         
         <article class="global" data-name="blank">
            <h2>blank</h2>
            <hr />
            
            <pre><code>blank</code></pre>
         </article>
         
         <article class="global" data-name="newline">
            <h2>newline</h2>
            <hr />
            
            <pre><code>newline</code></pre>
         </article>
         
         <article class="global" data-name="indent">
            <h2>indent</h2>
            <hr />
            
            <pre><code>indent</code></pre>
         </article>
         
         <article class="global" data-name="outdent">
            <h2>outdent</h2>
            <hr />
            
            <pre><code>outdent</code></pre>
         </article>
         
         <article class="global" data-name="tabBytes">
            <h2>tabBytes</h2>
            <hr />
            
            <pre><code>tabBytes</code></pre>
         </article>
         
         <article class="global" data-name="newlineByte">
            <h2>newlineByte</h2>
            <hr />
            
            <pre><code>newlineByte</code></pre>
         </article>
         
         <article class="global" data-name="blankByte">
            <h2>blankByte</h2>
            <hr />
            
            <pre><code>blankByte</code></pre>
         </article>
         
         <article class="global" data-name="CheckBranches">
            <h2>CheckBranches</h2>
            <hr />
            
            <p>Modes supported by the parser.</p>
            
            <pre><code>CheckBranches Mode</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ error</code></pre>
         </article>
         
         <article class="global" data-name="indentBytes">
            <h2>indentBytes</h2>
            <hr />
            
            <pre><code>indentBytes</code></pre>
         </article>
         
         <article class="global" data-name="_Operator_name">
            <h2>_Operator_name</h2>
            <hr />
            
            <pre><code>_Operator_name</code></pre>
         </article>
         
         <article class="global" data-name="_Operator_index">
            <h2>_Operator_index</h2>
            <hr />
            
            <pre><code>_Operator_index</code></pre>
         </article>
         
         <article class="global" data-name="debug">
            <h2>debug</h2>
            <hr />
            
            <pre><code>debug</code></pre>
         </article>
         
         <article class="global" data-name="trace">
            <h2>trace</h2>
            <hr />
            
            <pre><code>trace</code></pre>
         </article>
         
         <article class="global" data-name="stopset">
            <h2>stopset</h2>
            <hr />
            
            <p>The stopset contains keywords that start a statement.
They are good synchronization points in case of syntax
errors and (usually) shouldn't be skipped over.</p>
            
            <pre><code>stopset uint64</code></pre>
         </article>
         
         <article class="global" data-name="comments">
            <h2>comments</h2>
            <hr />
            
            <p>The mode flags below control which comments are reported
by calling the error handler. If no flag is set, comments
are ignored.</p>
            
            <pre><code>comments uint</code></pre>
         </article>
         
         <article class="global" data-name="directives">
            <h2>directives</h2>
            <hr />
            
            <p>The mode flags below control which comments are reported
by calling the error handler. If no flag is set, comments
are ignored.</p>
            
            <pre><code>directives</code></pre>
         </article>
         
         <article class="global" data-name="keywordMap">
            <h2>keywordMap</h2>
            <hr />
            
            <pre><code>keywordMap []token</code></pre>
         </article>
         
         <article class="global" data-name="invalid">
            <h2>invalid</h2>
            <hr />
            
            <pre><code>invalid</code></pre>
         </article>
          
         <article class="struct" data-name="position">
            <h2>type position struct</h2>
            <hr />
            
            <p>A position represents a source position in the current file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">line uint
col uint</code></pre>
         </article>
         
         <article class="struct" data-name="shortBuffer">
            <h2>type shortBuffer struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">buf []byte</code></pre>
         </article>
         
         <article class="struct" data-name="source">
            <h2>type source struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">in io.Reader
errh func
buf []byte
ioerr error
b int
r int
e int
line uint
col uint
ch rune
chw int</code></pre>
         </article>
         
         <article class="struct" data-name="TypeAndValue">
            <h2>type TypeAndValue struct</h2>
            <hr />
            
            <p>A TypeAndValue records the type information, constant
value if known, and various other flags associated with
an expression.
This type is similar to types2.TypeAndValue, but exposes
none of types2's internals.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Type Type
Value constant.Value
exprFlags</code></pre>
         </article>
         
         <article class="struct" data-name="typeAndValue">
            <h2>type typeAndValue struct</h2>
            <hr />
            
            <p>a typeAndValue contains the results of typechecking an expression.
It is embedded in expression nodes.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">tv TypeAndValue</code></pre>
         </article>
         
         <article class="struct" data-name="walker">
            <h2>type walker struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">v Visitor</code></pre>
         </article>
         
         <article class="struct" data-name="node">
            <h2>type node struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pos Pos</code></pre>
         </article>
         
         <article class="struct" data-name="File">
            <h2>type File struct</h2>
            <hr />
            
            <p>package PkgName; DeclList[0], DeclList[1], ...</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Pragma Pragma
PkgName *Name
DeclList []Decl
EOF Pos
GoVersion string
node</code></pre>
         </article>
         
         <article class="struct" data-name="ImportDecl">
            <h2>type ImportDecl struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Group *Group
Pragma Pragma
LocalPkgName *Name
Path *BasicLit
decl</code></pre>
         </article>
         
         <article class="struct" data-name="ConstDecl">
            <h2>type ConstDecl struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Group *Group
Pragma Pragma
NameList []*Name
Type Expr
Values Expr
decl</code></pre>
         </article>
         
         <article class="struct" data-name="TypeDecl">
            <h2>type TypeDecl struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Group *Group
Pragma Pragma
Name *Name
TParamList []*Field
Alias bool
Type Expr
decl</code></pre>
         </article>
         
         <article class="struct" data-name="VarDecl">
            <h2>type VarDecl struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Group *Group
Pragma Pragma
NameList []*Name
Type Expr
Values Expr
decl</code></pre>
         </article>
         
         <article class="struct" data-name="FuncDecl">
            <h2>type FuncDecl struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Pragma Pragma
Recv *Field
Name *Name
TParamList []*Field
Type *FuncType
Body *BlockStmt
decl</code></pre>
         </article>
         
         <article class="struct" data-name="decl">
            <h2>type decl struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">node</code></pre>
         </article>
         
         <article class="struct" data-name="Group">
            <h2>type Group struct</h2>
            <hr />
            
            <p>All declarations belonging to the same group point to the same Group node.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">_ int</code></pre>
         </article>
         
         <article class="struct" data-name="BadExpr">
            <h2>type BadExpr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">expr</code></pre>
         </article>
         
         <article class="struct" data-name="Name">
            <h2>type Name struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Value string
expr</code></pre>
         </article>
         
         <article class="struct" data-name="BasicLit">
            <h2>type BasicLit struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Value string
Kind LitKind
Bad bool
expr</code></pre>
         </article>
         
         <article class="struct" data-name="CompositeLit">
            <h2>type CompositeLit struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Type Expr
ElemList []Expr
NKeys int
Rbrace Pos
expr</code></pre>
         </article>
         
         <article class="struct" data-name="KeyValueExpr">
            <h2>type KeyValueExpr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Key Expr
Value Expr
expr</code></pre>
         </article>
         
         <article class="struct" data-name="FuncLit">
            <h2>type FuncLit struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Type *FuncType
Body *BlockStmt
expr</code></pre>
         </article>
         
         <article class="struct" data-name="ParenExpr">
            <h2>type ParenExpr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">X Expr
expr</code></pre>
         </article>
         
         <article class="struct" data-name="SelectorExpr">
            <h2>type SelectorExpr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">X Expr
Sel *Name
expr</code></pre>
         </article>
         
         <article class="struct" data-name="IndexExpr">
            <h2>type IndexExpr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">X Expr
Index Expr
expr</code></pre>
         </article>
         
         <article class="struct" data-name="SliceExpr">
            <h2>type SliceExpr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">X Expr
Index []Expr
Full bool
expr</code></pre>
         </article>
         
         <article class="struct" data-name="AssertExpr">
            <h2>type AssertExpr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">X Expr
Type Expr
expr</code></pre>
         </article>
         
         <article class="struct" data-name="TypeSwitchGuard">
            <h2>type TypeSwitchGuard struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Lhs *Name
X Expr
expr</code></pre>
         </article>
         
         <article class="struct" data-name="Operation">
            <h2>type Operation struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Op Operator
X Expr
Y Expr
expr</code></pre>
         </article>
         
         <article class="struct" data-name="CallExpr">
            <h2>type CallExpr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Fun Expr
ArgList []Expr
HasDots bool
expr</code></pre>
         </article>
         
         <article class="struct" data-name="ListExpr">
            <h2>type ListExpr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">ElemList []Expr
expr</code></pre>
         </article>
         
         <article class="struct" data-name="ArrayType">
            <h2>type ArrayType struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Len Expr
Elem Expr
expr</code></pre>
         </article>
         
         <article class="struct" data-name="SliceType">
            <h2>type SliceType struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Elem Expr
expr</code></pre>
         </article>
         
         <article class="struct" data-name="DotsType">
            <h2>type DotsType struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Elem Expr
expr</code></pre>
         </article>
         
         <article class="struct" data-name="StructType">
            <h2>type StructType struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">FieldList []*Field
TagList []*BasicLit
expr</code></pre>
         </article>
         
         <article class="struct" data-name="Field">
            <h2>type Field struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name *Name
Type Expr
node</code></pre>
         </article>
         
         <article class="struct" data-name="InterfaceType">
            <h2>type InterfaceType struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">MethodList []*Field
expr</code></pre>
         </article>
         
         <article class="struct" data-name="FuncType">
            <h2>type FuncType struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">ParamList []*Field
ResultList []*Field
expr</code></pre>
         </article>
         
         <article class="struct" data-name="MapType">
            <h2>type MapType struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Key Expr
Value Expr
expr</code></pre>
         </article>
         
         <article class="struct" data-name="ChanType">
            <h2>type ChanType struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Dir ChanDir
Elem Expr
expr</code></pre>
         </article>
         
         <article class="struct" data-name="expr">
            <h2>type expr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">node
typeAndValue</code></pre>
         </article>
         
         <article class="struct" data-name="EmptyStmt">
            <h2>type EmptyStmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">simpleStmt</code></pre>
         </article>
         
         <article class="struct" data-name="LabeledStmt">
            <h2>type LabeledStmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Label *Name
Stmt Stmt
stmt</code></pre>
         </article>
         
         <article class="struct" data-name="BlockStmt">
            <h2>type BlockStmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">List []Stmt
Rbrace Pos
stmt</code></pre>
         </article>
         
         <article class="struct" data-name="ExprStmt">
            <h2>type ExprStmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">X Expr
simpleStmt</code></pre>
         </article>
         
         <article class="struct" data-name="SendStmt">
            <h2>type SendStmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Chan Expr
Value Expr
simpleStmt</code></pre>
         </article>
         
         <article class="struct" data-name="DeclStmt">
            <h2>type DeclStmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">DeclList []Decl
stmt</code></pre>
         </article>
         
         <article class="struct" data-name="AssignStmt">
            <h2>type AssignStmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Op Operator
Lhs Expr
Rhs Expr
simpleStmt</code></pre>
         </article>
         
         <article class="struct" data-name="BranchStmt">
            <h2>type BranchStmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Tok token
Label *Name
Target Stmt
stmt</code></pre>
         </article>
         
         <article class="struct" data-name="CallStmt">
            <h2>type CallStmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Tok token
Call Expr
DeferAt Expr
stmt</code></pre>
         </article>
         
         <article class="struct" data-name="ReturnStmt">
            <h2>type ReturnStmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Results Expr
stmt</code></pre>
         </article>
         
         <article class="struct" data-name="IfStmt">
            <h2>type IfStmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Init SimpleStmt
Cond Expr
Then *BlockStmt
Else Stmt
stmt</code></pre>
         </article>
         
         <article class="struct" data-name="ForStmt">
            <h2>type ForStmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Init SimpleStmt
Cond Expr
Post SimpleStmt
Body *BlockStmt
stmt</code></pre>
         </article>
         
         <article class="struct" data-name="SwitchStmt">
            <h2>type SwitchStmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Init SimpleStmt
Tag Expr
Body []*CaseClause
Rbrace Pos
stmt</code></pre>
         </article>
         
         <article class="struct" data-name="SelectStmt">
            <h2>type SelectStmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Body []*CommClause
Rbrace Pos
stmt</code></pre>
         </article>
         
         <article class="struct" data-name="RangeClause">
            <h2>type RangeClause struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Lhs Expr
Def bool
X Expr
simpleStmt</code></pre>
         </article>
         
         <article class="struct" data-name="CaseClause">
            <h2>type CaseClause struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Cases Expr
Body []Stmt
Colon Pos
node</code></pre>
         </article>
         
         <article class="struct" data-name="CommClause">
            <h2>type CommClause struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Comm SimpleStmt
Body []Stmt
Colon Pos
node</code></pre>
         </article>
         
         <article class="struct" data-name="stmt">
            <h2>type stmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">node</code></pre>
         </article>
         
         <article class="struct" data-name="simpleStmt">
            <h2>type simpleStmt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">stmt</code></pre>
         </article>
         
         <article class="struct" data-name="Comment">
            <h2>type Comment struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Kind CommentKind
Text string
Next *Comment</code></pre>
         </article>
         
         <article class="struct" data-name="test">
            <h2>type test struct</h2>
            <hr />
            
            <p>A test is a source code snippet of a particular node type.
In the snippet, a '@' indicates the position recorded by
the parser when creating the respective node.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">nodetyp string
snippet string</code></pre>
         </article>
         
         <article class="struct" data-name="Pos">
            <h2>type Pos struct</h2>
            <hr />
            
            <p>A Pos represents an absolute (line, col) source position
with a reference to position base for computing relative
(to a file, or line directive) position information.
Pos values are intentionally light-weight so that they
can be created without too much concern about space use.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">base *PosBase
line uint32
col uint32</code></pre>
         </article>
         
         <article class="struct" data-name="position_">
            <h2>type position_ struct</h2>
            <hr />
            
            <p>TODO(gri) cleanup: find better name, avoid conflict with position in error_test.go</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">filename string
line uint
col uint</code></pre>
         </article>
         
         <article class="struct" data-name="PosBase">
            <h2>type PosBase struct</h2>
            <hr />
            
            <p>A PosBase represents the base for relative position information:
At position pos, the relative position is filename:line:col.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pos Pos
filename string
line uint32
col uint32
trimmed bool</code></pre>
         </article>
         
         <article class="struct" data-name="whitespace">
            <h2>type whitespace struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">last token
kind ctrlSymbol</code></pre>
         </article>
         
         <article class="struct" data-name="printer">
            <h2>type printer struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">output io.Writer
written int
form Form
linebreaks bool
indent int
nlcount int
pending []whitespace
lastTok token</code></pre>
         </article>
         
         <article class="struct" data-name="printGroup">
            <h2>type printGroup struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">node
Tok token
Decls []Decl</code></pre>
         </article>
         
         <article class="struct" data-name="Error">
            <h2>type Error struct</h2>
            <hr />
            
            <p>Error describes a syntax error. Error implements the error interface.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Pos Pos
Msg string</code></pre>
         </article>
         
         <article class="struct" data-name="dumper">
            <h2>type dumper struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">output io.Writer
ptrmap *ast.MapType
indent int
last byte
line int</code></pre>
         </article>
         
         <article class="struct" data-name="writeError">
            <h2>type writeError struct</h2>
            <hr />
            
            <p>writeError wraps locally caught write errors so we can distinguish
them from genuine panics which we don't want to return as errors.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">err error</code></pre>
         </article>
         
         <article class="struct" data-name="parser">
            <h2>type parser struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">file *PosBase
errh ErrorHandler
mode Mode
pragh PragmaHandler
scanner
base *PosBase
first error
errcnt int
pragma Pragma
goVersion string
top bool
fnest int
xnest int
indent []byte</code></pre>
         </article>
         
         <article class="struct" data-name="scanner">
            <h2>type scanner struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">source
mode uint
nlsemi bool
line uint
col uint
blank bool
tok token
lit string
bad bool
kind LitKind
op Operator
prec int</code></pre>
         </article>
         
         <article class="struct" data-name="labelScope">
            <h2>type labelScope struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">errh ErrorHandler
labels *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="label">
            <h2>type label struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">parent *block
lstmt *LabeledStmt
used bool</code></pre>
         </article>
         
         <article class="struct" data-name="block">
            <h2>type block struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">parent *block
start Pos
lstmt *LabeledStmt</code></pre>
         </article>
         
         <article class="struct" data-name="targets">
            <h2>type targets struct</h2>
            <hr />
            
            <p>targets describes the target statements within which break
or continue statements are valid.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">breaks Stmt
continues *ForStmt
caseIndex int</code></pre>
         </article>
          
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="sortedPositions">
            <h2>sortedPositions</h2>
            <hr />
            
            <pre><code>func sortedPositions(m *ast.MapType) []position</code></pre>
         </article>
         
         <article class="function" data-name="declaredErrors">
            <h2>declaredErrors</h2>
            <hr />
            
            <p>declaredErrors returns a map of source positions to error
patterns, extracted from error comments in the given file.
Error comments in the form of line comments use col = 0
in their position.</p>
            
            <pre><code>func declaredErrors(t *testing.T, filename string) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="testSyntaxErrors">
            <h2>testSyntaxErrors</h2>
            <hr />
            
            <pre><code>func testSyntaxErrors(t *testing.T, filename string)</code></pre>
         </article>
         
         <article class="function" data-name="TestSyntaxErrors">
            <h2>TestSyntaxErrors</h2>
            <hr />
            
            <pre><code>func TestSyntaxErrors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue67866">
            <h2>TestIssue67866</h2>
            <hr />
            
            <pre><code>func TestIssue67866(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPrint">
            <h2>TestPrint</h2>
            <hr />
            
            <pre><code>func TestPrint(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(data []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TestPrintError">
            <h2>TestPrintError</h2>
            <hr />
            
            <pre><code>func TestPrintError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPrintString">
            <h2>TestPrintString</h2>
            <hr />
            
            <pre><code>func TestPrintString(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testOut">
            <h2>testOut</h2>
            <hr />
            
            <pre><code>func testOut() io.Writer</code></pre>
         </article>
         
         <article class="function" data-name="dup">
            <h2>dup</h2>
            <hr />
            
            <pre><code>func dup(s string) []string</code></pre>
         </article>
         
         <article class="function" data-name="TestShortString">
            <h2>TestShortString</h2>
            <hr />
            
            <pre><code>func TestShortString(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="errh">
            <h2>errh</h2>
            <hr />
            
            <p>errh is a default error handler for basic tests.</p>
            
            <pre><code>func errh(line uint, col uint, msg string)</code></pre>
         </article>
         
         <article class="function" data-name="TestSmoke">
            <h2>TestSmoke</h2>
            <hr />
            
            <p>Don't bother with other tests if TestSmoke doesn't pass.</p>
            
            <pre><code>func TestSmoke(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestTokens">
            <h2>TestTokens</h2>
            <hr />
            
            <p>Once TestSmoke passes, run TestTokens next.</p>
            
            <pre><code>func TestTokens(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanner">
            <h2>TestScanner</h2>
            <hr />
            
            <pre><code>func TestScanner(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEmbeddedTokens">
            <h2>TestEmbeddedTokens</h2>
            <hr />
            
            <pre><code>func TestEmbeddedTokens(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestComments">
            <h2>TestComments</h2>
            <hr />
            
            <pre><code>func TestComments(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNumbers">
            <h2>TestNumbers</h2>
            <hr />
            
            <pre><code>func TestNumbers(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanErrors">
            <h2>TestScanErrors</h2>
            <hr />
            
            <pre><code>func TestScanErrors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDirectives">
            <h2>TestDirectives</h2>
            <hr />
            
            <pre><code>func TestDirectives(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue21938">
            <h2>TestIssue21938</h2>
            <hr />
            
            <pre><code>func TestIssue21938(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue33961">
            <h2>TestIssue33961</h2>
            <hr />
            
            <pre><code>func TestIssue33961(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init(in io.Reader, errh func)</code></pre>
         </article>
         
         <article class="function" data-name="pos">
            <h2>pos</h2>
            <hr />
            
            <p>pos returns the (line, col) source position of s.ch.</p>
            
            <pre><code>func pos() (line uint, col uint)</code></pre>
         </article>
         
         <article class="function" data-name="error">
            <h2>error</h2>
            <hr />
            
            <p>error reports the error msg at source position s.pos().</p>
            
            <pre><code>func error(msg string)</code></pre>
         </article>
         
         <article class="function" data-name="start">
            <h2>start</h2>
            <hr />
            
            <p>start starts a new active source segment (including s.ch).
As long as stop has not been called, the active segment's
bytes (excluding s.ch) may be retrieved by calling segment.</p>
            
            <pre><code>func start()</code></pre>
         </article>
         
         <article class="function" data-name="stop">
            <h2>stop</h2>
            <hr />
            
            <pre><code>func stop()</code></pre>
         </article>
         
         <article class="function" data-name="segment">
            <h2>segment</h2>
            <hr />
            
            <pre><code>func segment() []byte</code></pre>
         </article>
         
         <article class="function" data-name="rewind">
            <h2>rewind</h2>
            <hr />
            
            <p>rewind rewinds the scanner's read position and character s.ch
to the start of the currently active segment, which must not
contain any newlines (otherwise position information will be
incorrect). Currently, rewind is only needed for handling the
source sequence ".."; it must not be called outside an active
segment.</p>
            
            <pre><code>func rewind()</code></pre>
         </article>
         
         <article class="function" data-name="nextch">
            <h2>nextch</h2>
            <hr />
            
            <pre><code>func nextch()</code></pre>
         </article>
         
         <article class="function" data-name="fill">
            <h2>fill</h2>
            <hr />
            
            <p>fill reads more source bytes into s.buf.
It returns with at least one more byte in the buffer, or with s.ioerr != nil.</p>
            
            <pre><code>func fill()</code></pre>
         </article>
         
         <article class="function" data-name="nextSize">
            <h2>nextSize</h2>
            <hr />
            
            <p>nextSize returns the next bigger size for a buffer of a given size.</p>
            
            <pre><code>func nextSize(size int) int</code></pre>
         </article>
         
         <article class="function" data-name="TestCommentMap">
            <h2>TestCommentMap</h2>
            <hr />
            
            <pre><code>func TestCommentMap(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="CommentsDo">
            <h2>CommentsDo</h2>
            <hr />
            
            <p>CommentsDo parses the given source and calls the provided handler for each
comment or error. If the text provided to handler starts with a '/' it is
the comment text; otherwise it is the error message.</p>
            
            <pre><code>func CommentsDo(src io.Reader, handler func)</code></pre>
         </article>
         
         <article class="function" data-name="CommentMap">
            <h2>CommentMap</h2>
            <hr />
            
            <p>CommentMap collects all comments in the given src with comment text
that matches the supplied regular expression rx and returns them as
[]Error lists in a map indexed by line number. The comment text is
the comment with any comment markers ("//", "/*", or "*/") stripped.
The position for each Error is the position of the token immediately
preceding the comment and the Error message is the comment text,
with all comments that are on the same line collected in a slice, in
source order. If there is no preceding token (the matching comment
appears at the beginning of the file), then the recorded position
is unknown (line, col = 0, 0). If there are no matching comments,
the result is nil.</p>
            
            <pre><code>func CommentMap(src io.Reader, rx *regexp.Regexp) res *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>func _()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="contains">
            <h2>contains</h2>
            <hr />
            
            <p>contains reports whether tok is in tokset.</p>
            
            <pre><code>func contains(tokset uint64, tok token) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsVoid">
            <h2>IsVoid</h2>
            <hr />
            
            <pre><code>func IsVoid() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsType">
            <h2>IsType</h2>
            <hr />
            
            <pre><code>func IsType() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsBuiltin">
            <h2>IsBuiltin</h2>
            <hr />
            
            <pre><code>func IsBuiltin() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsValue">
            <h2>IsValue</h2>
            <hr />
            
            <pre><code>func IsValue() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsNil">
            <h2>IsNil</h2>
            <hr />
            
            <pre><code>func IsNil() bool</code></pre>
         </article>
         
         <article class="function" data-name="Addressable">
            <h2>Addressable</h2>
            <hr />
            
            <pre><code>func Addressable() bool</code></pre>
         </article>
         
         <article class="function" data-name="Assignable">
            <h2>Assignable</h2>
            <hr />
            
            <pre><code>func Assignable() bool</code></pre>
         </article>
         
         <article class="function" data-name="HasOk">
            <h2>HasOk</h2>
            <hr />
            
            <pre><code>func HasOk() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsRuntimeHelper">
            <h2>IsRuntimeHelper</h2>
            <hr />
            
            <pre><code>func IsRuntimeHelper() bool</code></pre>
         </article>
         
         <article class="function" data-name="SetIsVoid">
            <h2>SetIsVoid</h2>
            <hr />
            
            <pre><code>func SetIsVoid()</code></pre>
         </article>
         
         <article class="function" data-name="SetIsType">
            <h2>SetIsType</h2>
            <hr />
            
            <pre><code>func SetIsType()</code></pre>
         </article>
         
         <article class="function" data-name="SetIsBuiltin">
            <h2>SetIsBuiltin</h2>
            <hr />
            
            <pre><code>func SetIsBuiltin()</code></pre>
         </article>
         
         <article class="function" data-name="SetIsValue">
            <h2>SetIsValue</h2>
            <hr />
            
            <pre><code>func SetIsValue()</code></pre>
         </article>
         
         <article class="function" data-name="SetIsNil">
            <h2>SetIsNil</h2>
            <hr />
            
            <pre><code>func SetIsNil()</code></pre>
         </article>
         
         <article class="function" data-name="SetAddressable">
            <h2>SetAddressable</h2>
            <hr />
            
            <pre><code>func SetAddressable()</code></pre>
         </article>
         
         <article class="function" data-name="SetAssignable">
            <h2>SetAssignable</h2>
            <hr />
            
            <pre><code>func SetAssignable()</code></pre>
         </article>
         
         <article class="function" data-name="SetHasOk">
            <h2>SetHasOk</h2>
            <hr />
            
            <pre><code>func SetHasOk()</code></pre>
         </article>
         
         <article class="function" data-name="SetIsRuntimeHelper">
            <h2>SetIsRuntimeHelper</h2>
            <hr />
            
            <pre><code>func SetIsRuntimeHelper()</code></pre>
         </article>
         
         <article class="function" data-name="SetTypeInfo">
            <h2>SetTypeInfo</h2>
            <hr />
            
            <pre><code>func SetTypeInfo(tv TypeAndValue)</code></pre>
         </article>
         
         <article class="function" data-name="GetTypeInfo">
            <h2>GetTypeInfo</h2>
            <hr />
            
            <pre><code>func GetTypeInfo() TypeAndValue</code></pre>
         </article>
         
         <article class="function" data-name="Inspect">
            <h2>Inspect</h2>
            <hr />
            
            <p>Inspect traverses an AST in pre-order: it starts by calling f(root);
root must not be nil. If f returns true, Inspect invokes f recursively
for each of the non-nil children of root, followed by a call of f(nil).

See Walk for caveats about shared nodes.</p>
            
            <pre><code>func Inspect(root Node, f func)</code></pre>
         </article>
         
         <article class="function" data-name="Visit">
            <h2>Visit</h2>
            <hr />
            
            <pre><code>func Visit(node Node) Visitor</code></pre>
         </article>
         
         <article class="function" data-name="Walk">
            <h2>Walk</h2>
            <hr />
            
            <p>Walk traverses an AST in pre-order: It starts by calling
v.Visit(node); node must not be nil. If the visitor w returned by
v.Visit(node) is not nil, Walk is invoked recursively with visitor
w for each of the non-nil children of node, followed by a call of
w.Visit(nil).

Some nodes may be shared among multiple parent nodes (e.g., types in
field lists such as type T in "a, b, c T"). Such shared nodes are
walked multiple times.
TODO(gri) Revisit this design. It may make sense to walk those nodes
only once. A place where this matters is types2.TestResolveIdents.</p>
            
            <pre><code>func Walk(root Node, v Visitor)</code></pre>
         </article>
         
         <article class="function" data-name="node">
            <h2>node</h2>
            <hr />
            
            <pre><code>func node(n Node)</code></pre>
         </article>
         
         <article class="function" data-name="declList">
            <h2>declList</h2>
            <hr />
            
            <pre><code>func declList(list []Decl)</code></pre>
         </article>
         
         <article class="function" data-name="exprList">
            <h2>exprList</h2>
            <hr />
            
            <pre><code>func exprList(list []Expr)</code></pre>
         </article>
         
         <article class="function" data-name="stmtList">
            <h2>stmtList</h2>
            <hr />
            
            <pre><code>func stmtList(list []Stmt)</code></pre>
         </article>
         
         <article class="function" data-name="nameList">
            <h2>nameList</h2>
            <hr />
            
            <pre><code>func nameList(list []*Name)</code></pre>
         </article>
         
         <article class="function" data-name="fieldList">
            <h2>fieldList</h2>
            <hr />
            
            <pre><code>func fieldList(list []*Field)</code></pre>
         </article>
         
         <article class="function" data-name="Pos">
            <h2>Pos</h2>
            <hr />
            
            <pre><code>func Pos() Pos</code></pre>
         </article>
         
         <article class="function" data-name="SetPos">
            <h2>SetPos</h2>
            <hr />
            
            <pre><code>func SetPos(pos Pos)</code></pre>
         </article>
         
         <article class="function" data-name="aNode">
            <h2>aNode</h2>
            <hr />
            
            <pre><code>func aNode()</code></pre>
         </article>
         
         <article class="function" data-name="aDecl">
            <h2>aDecl</h2>
            <hr />
            
            <pre><code>func aDecl()</code></pre>
         </article>
         
         <article class="function" data-name="NewName">
            <h2>NewName</h2>
            <hr />
            
            <pre><code>func NewName(pos Pos, value string) *Name</code></pre>
         </article>
         
         <article class="function" data-name="aExpr">
            <h2>aExpr</h2>
            <hr />
            
            <pre><code>func aExpr()</code></pre>
         </article>
         
         <article class="function" data-name="aStmt">
            <h2>aStmt</h2>
            <hr />
            
            <pre><code>func aStmt()</code></pre>
         </article>
         
         <article class="function" data-name="aSimpleStmt">
            <h2>aSimpleStmt</h2>
            <hr />
            
            <pre><code>func aSimpleStmt()</code></pre>
         </article>
         
         <article class="function" data-name="TestPos">
            <h2>TestPos</h2>
            <hr />
            
            <pre><code>func TestPos(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testPos">
            <h2>testPos</h2>
            <hr />
            
            <pre><code>func testPos(t *testing.T, list []test, prefix string, suffix string, extract func)</code></pre>
         </article>
         
         <article class="function" data-name="stripAt">
            <h2>stripAt</h2>
            <hr />
            
            <pre><code>func stripAt(s string) (string, int)</code></pre>
         </article>
         
         <article class="function" data-name="typeOf">
            <h2>typeOf</h2>
            <hr />
            
            <pre><code>func typeOf(n Node) string</code></pre>
         </article>
         
         <article class="function" data-name="TestParse">
            <h2>TestParse</h2>
            <hr />
            
            <pre><code>func TestParse(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestVerify">
            <h2>TestVerify</h2>
            <hr />
            
            <pre><code>func TestVerify(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestStdLib">
            <h2>TestStdLib</h2>
            <hr />
            
            <pre><code>func TestStdLib(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="walkDirs">
            <h2>walkDirs</h2>
            <hr />
            
            <pre><code>func walkDirs(t *testing.T, dir string, action func)</code></pre>
         </article>
         
         <article class="function" data-name="verifyPrint">
            <h2>verifyPrint</h2>
            <hr />
            
            <pre><code>func verifyPrint(t *testing.T, filename string, ast1 *File)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue17697">
            <h2>TestIssue17697</h2>
            <hr />
            
            <pre><code>func TestIssue17697(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseFile">
            <h2>TestParseFile</h2>
            <hr />
            
            <pre><code>func TestParseFile(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLineDirectives">
            <h2>TestLineDirectives</h2>
            <hr />
            
            <pre><code>func TestLineDirectives(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnpackListExprAllocs">
            <h2>TestUnpackListExprAllocs</h2>
            <hr />
            
            <p>Test that typical uses of UnpackListExpr don't allocate.</p>
            
            <pre><code>func TestUnpackListExprAllocs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="MakePos">
            <h2>MakePos</h2>
            <hr />
            
            <p>MakePos returns a new Pos for the given PosBase, line and column.</p>
            
            <pre><code>func MakePos(base *PosBase, line uint, col uint) Pos</code></pre>
         </article>
         
         <article class="function" data-name="Pos">
            <h2>Pos</h2>
            <hr />
            
            <pre><code>func Pos() Pos</code></pre>
         </article>
         
         <article class="function" data-name="IsKnown">
            <h2>IsKnown</h2>
            <hr />
            
            <pre><code>func IsKnown() bool</code></pre>
         </article>
         
         <article class="function" data-name="Base">
            <h2>Base</h2>
            <hr />
            
            <pre><code>func Base() *PosBase</code></pre>
         </article>
         
         <article class="function" data-name="Line">
            <h2>Line</h2>
            <hr />
            
            <pre><code>func Line() uint</code></pre>
         </article>
         
         <article class="function" data-name="Col">
            <h2>Col</h2>
            <hr />
            
            <pre><code>func Col() uint</code></pre>
         </article>
         
         <article class="function" data-name="FileBase">
            <h2>FileBase</h2>
            <hr />
            
            <p>FileBase returns the PosBase of the file containing pos,
skipping over intermediate PosBases from //line directives.
The result is nil if pos doesn't have a file base.</p>
            
            <pre><code>func FileBase() *PosBase</code></pre>
         </article>
         
         <article class="function" data-name="RelFilename">
            <h2>RelFilename</h2>
            <hr />
            
            <pre><code>func RelFilename() string</code></pre>
         </article>
         
         <article class="function" data-name="RelLine">
            <h2>RelLine</h2>
            <hr />
            
            <pre><code>func RelLine() uint</code></pre>
         </article>
         
         <article class="function" data-name="RelCol">
            <h2>RelCol</h2>
            <hr />
            
            <pre><code>func RelCol() uint</code></pre>
         </article>
         
         <article class="function" data-name="Cmp">
            <h2>Cmp</h2>
            <hr />
            
            <p>Cmp compares the positions p and q and returns a result r as follows:

	r <  0: p is before q
	r == 0: p and q are the same position (but may not be identical)
	r >  0: p is after q

If p and q are in different files, p is before q if the filename
of p sorts lexicographically before the filename of q.</p>
            
            <pre><code>func Cmp(q Pos) int</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="NewFileBase">
            <h2>NewFileBase</h2>
            <hr />
            
            <p>NewFileBase returns a new PosBase for the given filename.
A file PosBase's position is relative to itself, with the
position being filename:1:1.</p>
            
            <pre><code>func NewFileBase(filename string) *PosBase</code></pre>
         </article>
         
         <article class="function" data-name="NewTrimmedFileBase">
            <h2>NewTrimmedFileBase</h2>
            <hr />
            
            <p>NewTrimmedFileBase is like NewFileBase, but allows specifying Trimmed.</p>
            
            <pre><code>func NewTrimmedFileBase(filename string, trimmed bool) *PosBase</code></pre>
         </article>
         
         <article class="function" data-name="NewLineBase">
            <h2>NewLineBase</h2>
            <hr />
            
            <p>NewLineBase returns a new PosBase for a line directive "line filename:line:col"
relative to pos, which is the position of the character immediately following
the comment containing the line directive. For a directive in a line comment,
that position is the beginning of the next line (i.e., the newline character
belongs to the line comment).</p>
            
            <pre><code>func NewLineBase(pos Pos, filename string, trimmed bool, line uint, col uint) *PosBase</code></pre>
         </article>
         
         <article class="function" data-name="IsFileBase">
            <h2>IsFileBase</h2>
            <hr />
            
            <pre><code>func IsFileBase() bool</code></pre>
         </article>
         
         <article class="function" data-name="Pos">
            <h2>Pos</h2>
            <hr />
            
            <pre><code>func Pos() _ Pos</code></pre>
         </article>
         
         <article class="function" data-name="Filename">
            <h2>Filename</h2>
            <hr />
            
            <pre><code>func Filename() string</code></pre>
         </article>
         
         <article class="function" data-name="Line">
            <h2>Line</h2>
            <hr />
            
            <pre><code>func Line() uint</code></pre>
         </article>
         
         <article class="function" data-name="Col">
            <h2>Col</h2>
            <hr />
            
            <pre><code>func Col() uint</code></pre>
         </article>
         
         <article class="function" data-name="Trimmed">
            <h2>Trimmed</h2>
            <hr />
            
            <pre><code>func Trimmed() bool</code></pre>
         </article>
         
         <article class="function" data-name="sat32">
            <h2>sat32</h2>
            <hr />
            
            <pre><code>func sat32(x uint) uint32</code></pre>
         </article>
         
         <article class="function" data-name="Fprint">
            <h2>Fprint</h2>
            <hr />
            
            <p>Fprint prints node x to w in the specified form.
It returns the number of bytes written, and whether there was an error.</p>
            
            <pre><code>func Fprint(w io.Writer, x Node, form Form) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String is a convenience function that prints n in ShortForm
and returns the printed string.</p>
            
            <pre><code>func String(n Node) string</code></pre>
         </article>
         
         <article class="function" data-name="write">
            <h2>write</h2>
            <hr />
            
            <p>write is a thin wrapper around p.output.Write
that takes care of accounting and error handling.</p>
            
            <pre><code>func write(data []byte)</code></pre>
         </article>
         
         <article class="function" data-name="writeBytes">
            <h2>writeBytes</h2>
            <hr />
            
            <pre><code>func writeBytes(data []byte)</code></pre>
         </article>
         
         <article class="function" data-name="writeString">
            <h2>writeString</h2>
            <hr />
            
            <pre><code>func writeString(s string)</code></pre>
         </article>
         
         <article class="function" data-name="impliesSemi">
            <h2>impliesSemi</h2>
            <hr />
            
            <p>If impliesSemi returns true for a non-blank line's final token tok,
a semicolon is automatically inserted. Vice versa, a semicolon may
be omitted in those cases.</p>
            
            <pre><code>func impliesSemi(tok token) bool</code></pre>
         </article>
         
         <article class="function" data-name="lineComment">
            <h2>lineComment</h2>
            <hr />
            
            <pre><code>func lineComment(text string) bool</code></pre>
         </article>
         
         <article class="function" data-name="addWhitespace">
            <h2>addWhitespace</h2>
            <hr />
            
            <pre><code>func addWhitespace(kind ctrlSymbol, text string)</code></pre>
         </article>
         
         <article class="function" data-name="flush">
            <h2>flush</h2>
            <hr />
            
            <pre><code>func flush(next token)</code></pre>
         </article>
         
         <article class="function" data-name="mayCombine">
            <h2>mayCombine</h2>
            <hr />
            
            <pre><code>func mayCombine(prev token, next byte) b bool</code></pre>
         </article>
         
         <article class="function" data-name="print">
            <h2>print</h2>
            <hr />
            
            <pre><code>func print(args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="printNode">
            <h2>printNode</h2>
            <hr />
            
            <pre><code>func printNode(n Node)</code></pre>
         </article>
         
         <article class="function" data-name="printRawNode">
            <h2>printRawNode</h2>
            <hr />
            
            <pre><code>func printRawNode(n Node)</code></pre>
         </article>
         
         <article class="function" data-name="printFields">
            <h2>printFields</h2>
            <hr />
            
            <pre><code>func printFields(fields []*Field, tags []*BasicLit, i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="printFieldList">
            <h2>printFieldList</h2>
            <hr />
            
            <pre><code>func printFieldList(fields []*Field, tags []*BasicLit, sep token)</code></pre>
         </article>
         
         <article class="function" data-name="printMethodList">
            <h2>printMethodList</h2>
            <hr />
            
            <pre><code>func printMethodList(methods []*Field)</code></pre>
         </article>
         
         <article class="function" data-name="printNameList">
            <h2>printNameList</h2>
            <hr />
            
            <pre><code>func printNameList(list []*Name)</code></pre>
         </article>
         
         <article class="function" data-name="printExprList">
            <h2>printExprList</h2>
            <hr />
            
            <pre><code>func printExprList(list []Expr)</code></pre>
         </article>
         
         <article class="function" data-name="printExprLines">
            <h2>printExprLines</h2>
            <hr />
            
            <pre><code>func printExprLines(list []Expr)</code></pre>
         </article>
         
         <article class="function" data-name="groupFor">
            <h2>groupFor</h2>
            <hr />
            
            <pre><code>func groupFor(d Decl) (token, *Group)</code></pre>
         </article>
         
         <article class="function" data-name="printDecl">
            <h2>printDecl</h2>
            <hr />
            
            <pre><code>func printDecl(list []Decl)</code></pre>
         </article>
         
         <article class="function" data-name="printDeclList">
            <h2>printDeclList</h2>
            <hr />
            
            <pre><code>func printDeclList(list []Decl)</code></pre>
         </article>
         
         <article class="function" data-name="printSignature">
            <h2>printSignature</h2>
            <hr />
            
            <pre><code>func printSignature(sig *FuncType)</code></pre>
         </article>
         
         <article class="function" data-name="printParameterList">
            <h2>printParameterList</h2>
            <hr />
            
            <p>If tok != 0 print a type parameter list: tok == _Type means
a type parameter list for a type, tok == _Func means a type
parameter list for a func.</p>
            
            <pre><code>func printParameterList(list []*Field, tok token)</code></pre>
         </article>
         
         <article class="function" data-name="combinesWithName">
            <h2>combinesWithName</h2>
            <hr />
            
            <p>combinesWithName reports whether a name followed by the expression x
syntactically combines to another valid (value) expression. For instance
using *T for x, "name *T" syntactically appears as the expression x*T.
On the other hand, using  P|Q or *P|~Q for x, "name P|Q" or "name *P|~Q"
cannot be combined into a valid (value) expression.</p>
            
            <pre><code>func combinesWithName(x Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="printStmtList">
            <h2>printStmtList</h2>
            <hr />
            
            <pre><code>func printStmtList(list []Stmt, braces bool)</code></pre>
         </article>
         
         <article class="function" data-name="printSwitchBody">
            <h2>printSwitchBody</h2>
            <hr />
            
            <pre><code>func printSwitchBody(list []*CaseClause)</code></pre>
         </article>
         
         <article class="function" data-name="printSelectBody">
            <h2>printSelectBody</h2>
            <hr />
            
            <pre><code>func printSelectBody(list []*CommClause)</code></pre>
         </article>
         
         <article class="function" data-name="printCaseClause">
            <h2>printCaseClause</h2>
            <hr />
            
            <pre><code>func printCaseClause(c *CaseClause, braces bool)</code></pre>
         </article>
         
         <article class="function" data-name="printCommClause">
            <h2>printCommClause</h2>
            <hr />
            
            <pre><code>func printCommClause(c *CommClause, braces bool)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Parse">
            <h2>Parse</h2>
            <hr />
            
            <p>Parse parses a single Go source file from src and returns the corresponding
syntax tree. If there are errors, Parse will return the first error found,
and a possibly partially constructed syntax tree, or nil.

If errh != nil, it is called with each error encountered, and Parse will
process as much source as possible. In this case, the returned syntax tree
is only nil if no correct package clause was found.
If errh is nil, Parse will terminate immediately upon encountering the first
error, and the returned syntax tree is nil.

If pragh != nil, it is called with each pragma encountered.</p>
            
            <pre><code>func Parse(base *PosBase, src io.Reader, errh ErrorHandler, pragh PragmaHandler, mode Mode) (_ *File, first error)</code></pre>
         </article>
         
         <article class="function" data-name="ParseFile">
            <h2>ParseFile</h2>
            <hr />
            
            <p>ParseFile behaves like Parse but it reads the source from the named file.</p>
            
            <pre><code>func ParseFile(filename string, errh ErrorHandler, pragh PragmaHandler, mode Mode) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="Fdump">
            <h2>Fdump</h2>
            <hr />
            
            <p>Fdump dumps the structure of the syntax tree rooted at n to w.
It is intended for debugging purposes; no specific output format
is guaranteed.</p>
            
            <pre><code>func Fdump(w io.Writer, n Node) err error</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(data []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="printf">
            <h2>printf</h2>
            <hr />
            
            <p>printf is a convenience wrapper that takes care of print errors.</p>
            
            <pre><code>func printf(format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="dump">
            <h2>dump</h2>
            <hr />
            
            <p>dump prints the contents of x.
If x is the reflect.Value of a struct s, where &s
implements Node, then &s should be passed for n -
this permits printing of the unexported span and
comments fields of the embedded isNode field by
calling the Span() and Comment() instead of using
reflection.</p>
            
            <pre><code>func dump(x reflect.Value, n Node)</code></pre>
         </article>
         
         <article class="function" data-name="isExported">
            <h2>isExported</h2>
            <hr />
            
            <pre><code>func isExported(name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestDump">
            <h2>TestDump</h2>
            <hr />
            
            <pre><code>func TestDump(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>func _()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init(file *PosBase, r io.Reader, errh ErrorHandler, pragh PragmaHandler, mode Mode)</code></pre>
         </article>
         
         <article class="function" data-name="takePragma">
            <h2>takePragma</h2>
            <hr />
            
            <p>takePragma returns the current parsed pragmas
and clears them from the parser state.</p>
            
            <pre><code>func takePragma() Pragma</code></pre>
         </article>
         
         <article class="function" data-name="clearPragma">
            <h2>clearPragma</h2>
            <hr />
            
            <p>clearPragma is called at the end of a statement or
other Go form that does NOT accept a pragma.
It sends the pragma back to the pragma handler
to be reported as unused.</p>
            
            <pre><code>func clearPragma()</code></pre>
         </article>
         
         <article class="function" data-name="updateBase">
            <h2>updateBase</h2>
            <hr />
            
            <p>updateBase sets the current position base to a new line base at pos.
The base's filename, line, and column values are extracted from text
which is positioned at (tline, tcol) (only needed for error messages).</p>
            
            <pre><code>func updateBase(pos Pos, tline uint, tcol uint, text string)</code></pre>
         </article>
         
         <article class="function" data-name="commentText">
            <h2>commentText</h2>
            <hr />
            
            <pre><code>func commentText(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="trailingDigits">
            <h2>trailingDigits</h2>
            <hr />
            
            <pre><code>func trailingDigits(text string) (uint, uint, bool)</code></pre>
         </article>
         
         <article class="function" data-name="got">
            <h2>got</h2>
            <hr />
            
            <pre><code>func got(tok token) bool</code></pre>
         </article>
         
         <article class="function" data-name="want">
            <h2>want</h2>
            <hr />
            
            <pre><code>func want(tok token)</code></pre>
         </article>
         
         <article class="function" data-name="gotAssign">
            <h2>gotAssign</h2>
            <hr />
            
            <p>gotAssign is like got(_Assign) but it also accepts ":="
(and reports an error) for better parser error recovery.</p>
            
            <pre><code>func gotAssign() bool</code></pre>
         </article>
         
         <article class="function" data-name="posAt">
            <h2>posAt</h2>
            <hr />
            
            <p>posAt returns the Pos value for (line, col) and the current position base.</p>
            
            <pre><code>func posAt(line uint, col uint) Pos</code></pre>
         </article>
         
         <article class="function" data-name="errorAt">
            <h2>errorAt</h2>
            <hr />
            
            <p>errorAt reports an error at the given position.</p>
            
            <pre><code>func errorAt(pos Pos, msg string)</code></pre>
         </article>
         
         <article class="function" data-name="syntaxErrorAt">
            <h2>syntaxErrorAt</h2>
            <hr />
            
            <p>syntaxErrorAt reports a syntax error at the given position.</p>
            
            <pre><code>func syntaxErrorAt(pos Pos, msg string)</code></pre>
         </article>
         
         <article class="function" data-name="tokstring">
            <h2>tokstring</h2>
            <hr />
            
            <p>tokstring returns the English word for selected punctuation tokens
for more readable error messages. Use tokstring (not tok.String())
for user-facing (error) messages; use tok.String() for debugging
output.</p>
            
            <pre><code>func tokstring(tok token) string</code></pre>
         </article>
         
         <article class="function" data-name="pos">
            <h2>pos</h2>
            <hr />
            
            <p>Convenience methods using the current token position.</p>
            
            <pre><code>func pos() Pos</code></pre>
         </article>
         
         <article class="function" data-name="error">
            <h2>error</h2>
            <hr />
            
            <pre><code>func error(msg string)</code></pre>
         </article>
         
         <article class="function" data-name="syntaxError">
            <h2>syntaxError</h2>
            <hr />
            
            <pre><code>func syntaxError(msg string)</code></pre>
         </article>
         
         <article class="function" data-name="advance">
            <h2>advance</h2>
            <hr />
            
            <p>advance consumes tokens until it finds a token of the stopset or followlist.
The stopset is only considered if we are inside a function (p.fnest > 0).
The followlist is the list of valid tokens that can follow a production;
if it is empty, exactly one (non-EOF) token is consumed to ensure progress.</p>
            
            <pre><code>func advance(followlist ...token)</code></pre>
         </article>
         
         <article class="function" data-name="trace">
            <h2>trace</h2>
            <hr />
            
            <p>usage: defer p.trace(msg)()</p>
            
            <pre><code>func trace(msg string) func</code></pre>
         </article>
         
         <article class="function" data-name="print">
            <h2>print</h2>
            <hr />
            
            <pre><code>func print(msg string)</code></pre>
         </article>
         
         <article class="function" data-name="fileOrNil">
            <h2>fileOrNil</h2>
            <hr />
            
            <p>SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .</p>
            
            <pre><code>func fileOrNil() *File</code></pre>
         </article>
         
         <article class="function" data-name="isEmptyFuncDecl">
            <h2>isEmptyFuncDecl</h2>
            <hr />
            
            <pre><code>func isEmptyFuncDecl(dcl Decl) bool</code></pre>
         </article>
         
         <article class="function" data-name="list">
            <h2>list</h2>
            <hr />
            
            <p>list parses a possibly empty, sep-separated list of elements, optionally
followed by sep, and closed by close (or EOF). sep must be one of _Comma
or _Semi, and close must be one of _Rparen, _Rbrace, or _Rbrack.

For each list element, f is called. Specifically, unless we're at close
(or EOF), f is called at least once. After f returns true, no more list
elements are accepted. list returns the position of the closing token.

list = [ f { sep f } [sep] ] close .</p>
            
            <pre><code>func list(context string, sep token, close token, f func) Pos</code></pre>
         </article>
         
         <article class="function" data-name="appendGroup">
            <h2>appendGroup</h2>
            <hr />
            
            <p>appendGroup(f) = f | "(" { f ";" } ")" . // ";" is optional before ")"</p>
            
            <pre><code>func appendGroup(list []Decl, f func) []Decl</code></pre>
         </article>
         
         <article class="function" data-name="importDecl">
            <h2>importDecl</h2>
            <hr />
            
            <p>ImportSpec = [ "." | PackageName ] ImportPath .
ImportPath = string_lit .</p>
            
            <pre><code>func importDecl(group *Group) Decl</code></pre>
         </article>
         
         <article class="function" data-name="constDecl">
            <h2>constDecl</h2>
            <hr />
            
            <p>ConstSpec = IdentifierList [ [ Type ] "=" ExpressionList ] .</p>
            
            <pre><code>func constDecl(group *Group) Decl</code></pre>
         </article>
         
         <article class="function" data-name="typeDecl">
            <h2>typeDecl</h2>
            <hr />
            
            <p>TypeSpec = identifier [ TypeParams ] [ "=" ] Type .</p>
            
            <pre><code>func typeDecl(group *Group) Decl</code></pre>
         </article>
         
         <article class="function" data-name="extractName">
            <h2>extractName</h2>
            <hr />
            
            <p>extractName splits the expression x into (name, expr) if syntactically
x can be written as name expr. The split only happens if expr is a type
element (per the isTypeElem predicate) or if force is set.
If x is just a name, the result is (name, nil). If the split succeeds,
the result is (name, expr). Otherwise the result is (nil, x).
Examples:

	x           force    name    expr
	------------------------------------
	P*[]int     T/F      P       *[]int
	P*E         T        P       *E
	P*E         F        nil     P*E
	P([]int)    T/F      P       []int
	P(E)        T        P       E
	P(E)        F        nil     P(E)
	P*E|F|~G    T/F      P       *E|F|~G
	P*E|F|G     T        P       *E|F|G
	P*E|F|G     F        nil     P*E|F|G</p>
            
            <pre><code>func extractName(x Expr, force bool) (*Name, Expr)</code></pre>
         </article>
         
         <article class="function" data-name="isTypeElem">
            <h2>isTypeElem</h2>
            <hr />
            
            <p>isTypeElem reports whether x is a (possibly parenthesized) type element expression.
The result is false if x could be a type element OR an ordinary (value) expression.</p>
            
            <pre><code>func isTypeElem(x Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="varDecl">
            <h2>varDecl</h2>
            <hr />
            
            <p>VarSpec = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .</p>
            
            <pre><code>func varDecl(group *Group) Decl</code></pre>
         </article>
         
         <article class="function" data-name="funcDeclOrNil">
            <h2>funcDeclOrNil</h2>
            <hr />
            
            <p>FunctionDecl = "func" FunctionName [ TypeParams ] ( Function | Signature ) .
FunctionName = identifier .
Function     = Signature FunctionBody .
MethodDecl   = "func" Receiver MethodName ( Function | Signature ) .
Receiver     = Parameters .</p>
            
            <pre><code>func funcDeclOrNil() *FuncDecl</code></pre>
         </article>
         
         <article class="function" data-name="funcBody">
            <h2>funcBody</h2>
            <hr />
            
            <pre><code>func funcBody() *BlockStmt</code></pre>
         </article>
         
         <article class="function" data-name="expr">
            <h2>expr</h2>
            <hr />
            
            <pre><code>func expr() Expr</code></pre>
         </article>
         
         <article class="function" data-name="binaryExpr">
            <h2>binaryExpr</h2>
            <hr />
            
            <p>Expression = UnaryExpr | Expression binary_op Expression .</p>
            
            <pre><code>func binaryExpr(x Expr, prec int) Expr</code></pre>
         </article>
         
         <article class="function" data-name="unaryExpr">
            <h2>unaryExpr</h2>
            <hr />
            
            <p>UnaryExpr = PrimaryExpr | unary_op UnaryExpr .</p>
            
            <pre><code>func unaryExpr() Expr</code></pre>
         </article>
         
         <article class="function" data-name="callStmt">
            <h2>callStmt</h2>
            <hr />
            
            <p>callStmt parses call-like statements that can be preceded by 'defer' and 'go'.</p>
            
            <pre><code>func callStmt() *CallStmt</code></pre>
         </article>
         
         <article class="function" data-name="operand">
            <h2>operand</h2>
            <hr />
            
            <p>Operand     = Literal | OperandName | MethodExpr | "(" Expression ")" .
Literal     = BasicLit | CompositeLit | FunctionLit .
BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
OperandName = identifier | QualifiedIdent.</p>
            
            <pre><code>func operand(keep_parens bool) Expr</code></pre>
         </article>
         
         <article class="function" data-name="pexpr">
            <h2>pexpr</h2>
            <hr />
            
            <p>pexpr parses a PrimaryExpr.

	PrimaryExpr =
		Operand |
		Conversion |
		PrimaryExpr Selector |
		PrimaryExpr Index |
		PrimaryExpr Slice |
		PrimaryExpr TypeAssertion |
		PrimaryExpr Arguments .

	Selector       = "." identifier .
	Index          = "[" Expression "]" .
	Slice          = "[" ( [ Expression ] ":" [ Expression ] ) |
	                     ( [ Expression ] ":" Expression ":" Expression )
	                 "]" .
	TypeAssertion  = "." "(" Type ")" .
	Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .</p>
            
            <pre><code>func pexpr(x Expr, keep_parens bool) Expr</code></pre>
         </article>
         
         <article class="function" data-name="isValue">
            <h2>isValue</h2>
            <hr />
            
            <p>isValue reports whether x syntactically must be a value (and not a type) expression.</p>
            
            <pre><code>func isValue(x Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="bare_complitexpr">
            <h2>bare_complitexpr</h2>
            <hr />
            
            <p>Element = Expression | LiteralValue .</p>
            
            <pre><code>func bare_complitexpr() Expr</code></pre>
         </article>
         
         <article class="function" data-name="complitexpr">
            <h2>complitexpr</h2>
            <hr />
            
            <p>LiteralValue = "{" [ ElementList [ "," ] ] "}" .</p>
            
            <pre><code>func complitexpr() *CompositeLit</code></pre>
         </article>
         
         <article class="function" data-name="type_">
            <h2>type_</h2>
            <hr />
            
            <pre><code>func type_() Expr</code></pre>
         </article>
         
         <article class="function" data-name="newIndirect">
            <h2>newIndirect</h2>
            <hr />
            
            <pre><code>func newIndirect(pos Pos, typ Expr) Expr</code></pre>
         </article>
         
         <article class="function" data-name="typeOrNil">
            <h2>typeOrNil</h2>
            <hr />
            
            <p>typeOrNil is like type_ but it returns nil if there was no type
instead of reporting an error.

	Type     = TypeName | TypeLit | "(" Type ")" .
	TypeName = identifier | QualifiedIdent .
	TypeLit  = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
		      SliceType | MapType | Channel_Type .</p>
            
            <pre><code>func typeOrNil() Expr</code></pre>
         </article>
         
         <article class="function" data-name="typeInstance">
            <h2>typeInstance</h2>
            <hr />
            
            <pre><code>func typeInstance(typ Expr) Expr</code></pre>
         </article>
         
         <article class="function" data-name="funcType">
            <h2>funcType</h2>
            <hr />
            
            <p>If context != "", type parameters are not permitted.</p>
            
            <pre><code>func funcType(context string) ([]*Field, *FuncType)</code></pre>
         </article>
         
         <article class="function" data-name="arrayType">
            <h2>arrayType</h2>
            <hr />
            
            <p>"[" has already been consumed, and pos is its position.
If len != nil it is the already consumed array length.</p>
            
            <pre><code>func arrayType(pos Pos, len Expr) Expr</code></pre>
         </article>
         
         <article class="function" data-name="sliceType">
            <h2>sliceType</h2>
            <hr />
            
            <p>"[" and "]" have already been consumed, and pos is the position of "[".</p>
            
            <pre><code>func sliceType(pos Pos) Expr</code></pre>
         </article>
         
         <article class="function" data-name="chanElem">
            <h2>chanElem</h2>
            <hr />
            
            <pre><code>func chanElem() Expr</code></pre>
         </article>
         
         <article class="function" data-name="structType">
            <h2>structType</h2>
            <hr />
            
            <p>StructType = "struct" "{" { FieldDecl ";" } "}" .</p>
            
            <pre><code>func structType() *StructType</code></pre>
         </article>
         
         <article class="function" data-name="interfaceType">
            <h2>interfaceType</h2>
            <hr />
            
            <p>InterfaceType = "interface" "{" { ( MethodDecl | EmbeddedElem ) ";" } "}" .</p>
            
            <pre><code>func interfaceType() *InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="funcResult">
            <h2>funcResult</h2>
            <hr />
            
            <p>Result = Parameters | Type .</p>
            
            <pre><code>func funcResult() []*Field</code></pre>
         </article>
         
         <article class="function" data-name="addField">
            <h2>addField</h2>
            <hr />
            
            <pre><code>func addField(styp *StructType, pos Pos, name *Name, typ Expr, tag *BasicLit)</code></pre>
         </article>
         
         <article class="function" data-name="fieldDecl">
            <h2>fieldDecl</h2>
            <hr />
            
            <p>FieldDecl      = (IdentifierList Type | AnonymousField) [ Tag ] .
AnonymousField = [ "*" ] TypeName .
Tag            = string_lit .</p>
            
            <pre><code>func fieldDecl(styp *StructType)</code></pre>
         </article>
         
         <article class="function" data-name="arrayOrTArgs">
            <h2>arrayOrTArgs</h2>
            <hr />
            
            <pre><code>func arrayOrTArgs() Expr</code></pre>
         </article>
         
         <article class="function" data-name="oliteral">
            <h2>oliteral</h2>
            <hr />
            
            <pre><code>func oliteral() *BasicLit</code></pre>
         </article>
         
         <article class="function" data-name="methodDecl">
            <h2>methodDecl</h2>
            <hr />
            
            <p>MethodSpec        = MethodName Signature | InterfaceTypeName .
MethodName        = identifier .
InterfaceTypeName = TypeName .</p>
            
            <pre><code>func methodDecl() *Field</code></pre>
         </article>
         
         <article class="function" data-name="embeddedElem">
            <h2>embeddedElem</h2>
            <hr />
            
            <p>EmbeddedElem = MethodSpec | EmbeddedTerm { "|" EmbeddedTerm } .</p>
            
            <pre><code>func embeddedElem(f *Field) *Field</code></pre>
         </article>
         
         <article class="function" data-name="embeddedTerm">
            <h2>embeddedTerm</h2>
            <hr />
            
            <p>EmbeddedTerm = [ "~" ] Type .</p>
            
            <pre><code>func embeddedTerm() Expr</code></pre>
         </article>
         
         <article class="function" data-name="paramDeclOrNil">
            <h2>paramDeclOrNil</h2>
            <hr />
            
            <p>ParameterDecl = [ IdentifierList ] [ "..." ] Type .</p>
            
            <pre><code>func paramDeclOrNil(name *Name, follow token) *Field</code></pre>
         </article>
         
         <article class="function" data-name="paramList">
            <h2>paramList</h2>
            <hr />
            
            <p>Parameters    = "(" [ ParameterList [ "," ] ] ")" .
ParameterList = ParameterDecl { "," ParameterDecl } .
"(" or "[" has already been consumed.
If name != nil, it is the first name after "(" or "[".
If typ != nil, name must be != nil, and (name, typ) is the first field in the list.
In the result list, either all fields have a name, or no field has a name.</p>
            
            <pre><code>func paramList(name *Name, typ Expr, close token, requireNames bool) list []*Field</code></pre>
         </article>
         
         <article class="function" data-name="badExpr">
            <h2>badExpr</h2>
            <hr />
            
            <pre><code>func badExpr() *BadExpr</code></pre>
         </article>
         
         <article class="function" data-name="simpleStmt">
            <h2>simpleStmt</h2>
            <hr />
            
            <p>SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .</p>
            
            <pre><code>func simpleStmt(lhs Expr, keyword token) SimpleStmt</code></pre>
         </article>
         
         <article class="function" data-name="newRangeClause">
            <h2>newRangeClause</h2>
            <hr />
            
            <pre><code>func newRangeClause(lhs Expr, def bool) *RangeClause</code></pre>
         </article>
         
         <article class="function" data-name="newAssignStmt">
            <h2>newAssignStmt</h2>
            <hr />
            
            <pre><code>func newAssignStmt(pos Pos, op Operator, lhs Expr, rhs Expr) *AssignStmt</code></pre>
         </article>
         
         <article class="function" data-name="labeledStmtOrNil">
            <h2>labeledStmtOrNil</h2>
            <hr />
            
            <pre><code>func labeledStmtOrNil(label *Name) Stmt</code></pre>
         </article>
         
         <article class="function" data-name="blockStmt">
            <h2>blockStmt</h2>
            <hr />
            
            <p>context must be a non-empty string unless we know that p.tok == _Lbrace.</p>
            
            <pre><code>func blockStmt(context string) *BlockStmt</code></pre>
         </article>
         
         <article class="function" data-name="declStmt">
            <h2>declStmt</h2>
            <hr />
            
            <pre><code>func declStmt(f func) *DeclStmt</code></pre>
         </article>
         
         <article class="function" data-name="forStmt">
            <h2>forStmt</h2>
            <hr />
            
            <pre><code>func forStmt() Stmt</code></pre>
         </article>
         
         <article class="function" data-name="header">
            <h2>header</h2>
            <hr />
            
            <pre><code>func header(keyword token) (init SimpleStmt, cond Expr, post SimpleStmt)</code></pre>
         </article>
         
         <article class="function" data-name="emphasize">
            <h2>emphasize</h2>
            <hr />
            
            <p>emphasize returns a string representation of x, with (top-level)
binary expressions emphasized by enclosing them in parentheses.</p>
            
            <pre><code>func emphasize(x Expr) string</code></pre>
         </article>
         
         <article class="function" data-name="ifStmt">
            <h2>ifStmt</h2>
            <hr />
            
            <pre><code>func ifStmt() *IfStmt</code></pre>
         </article>
         
         <article class="function" data-name="switchStmt">
            <h2>switchStmt</h2>
            <hr />
            
            <pre><code>func switchStmt() *SwitchStmt</code></pre>
         </article>
         
         <article class="function" data-name="selectStmt">
            <h2>selectStmt</h2>
            <hr />
            
            <pre><code>func selectStmt() *SelectStmt</code></pre>
         </article>
         
         <article class="function" data-name="caseClause">
            <h2>caseClause</h2>
            <hr />
            
            <pre><code>func caseClause() *CaseClause</code></pre>
         </article>
         
         <article class="function" data-name="commClause">
            <h2>commClause</h2>
            <hr />
            
            <pre><code>func commClause() *CommClause</code></pre>
         </article>
         
         <article class="function" data-name="stmtOrNil">
            <h2>stmtOrNil</h2>
            <hr />
            
            <p>stmtOrNil parses a statement if one is present, or else returns nil.

	Statement =
		Declaration | LabeledStmt | SimpleStmt |
		GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
		FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
		DeferStmt .</p>
            
            <pre><code>func stmtOrNil() Stmt</code></pre>
         </article>
         
         <article class="function" data-name="stmtList">
            <h2>stmtList</h2>
            <hr />
            
            <p>StatementList = { Statement ";" } .</p>
            
            <pre><code>func stmtList() l []Stmt</code></pre>
         </article>
         
         <article class="function" data-name="argList">
            <h2>argList</h2>
            <hr />
            
            <p>argList parses a possibly empty, comma-separated list of arguments,
optionally followed by a comma (if not empty), and closed by ")".
The last argument may be followed by "...".

argList = [ arg { "," arg } [ "..." ] [ "," ] ] ")" .</p>
            
            <pre><code>func argList() (list []Expr, hasDots bool)</code></pre>
         </article>
         
         <article class="function" data-name="name">
            <h2>name</h2>
            <hr />
            
            <pre><code>func name() *Name</code></pre>
         </article>
         
         <article class="function" data-name="nameList">
            <h2>nameList</h2>
            <hr />
            
            <p>IdentifierList = identifier { "," identifier } .
The first name must be provided.</p>
            
            <pre><code>func nameList(first *Name) []*Name</code></pre>
         </article>
         
         <article class="function" data-name="qualifiedName">
            <h2>qualifiedName</h2>
            <hr />
            
            <p>The first name may be provided, or nil.</p>
            
            <pre><code>func qualifiedName(name *Name) Expr</code></pre>
         </article>
         
         <article class="function" data-name="exprList">
            <h2>exprList</h2>
            <hr />
            
            <p>ExpressionList = Expression { "," Expression } .</p>
            
            <pre><code>func exprList() Expr</code></pre>
         </article>
         
         <article class="function" data-name="typeList">
            <h2>typeList</h2>
            <hr />
            
            <p>typeList parses a non-empty, comma-separated list of types,
optionally followed by a comma. If strict is set to false,
the first element may also be a (non-type) expression.
If there is more than one argument, the result is a *ListExpr.
The comma result indicates whether there was a (separating or
trailing) comma.

typeList = arg { "," arg } [ "," ] .</p>
            
            <pre><code>func typeList(strict bool) (x Expr, comma bool)</code></pre>
         </article>
         
         <article class="function" data-name="Unparen">
            <h2>Unparen</h2>
            <hr />
            
            <p>Unparen returns e with any enclosing parentheses stripped.</p>
            
            <pre><code>func Unparen(x Expr) Expr</code></pre>
         </article>
         
         <article class="function" data-name="UnpackListExpr">
            <h2>UnpackListExpr</h2>
            <hr />
            
            <p>UnpackListExpr unpacks a *ListExpr into a []Expr.</p>
            
            <pre><code>func UnpackListExpr(x Expr) []Expr</code></pre>
         </article>
         
         <article class="function" data-name="StartPos">
            <h2>StartPos</h2>
            <hr />
            
            <p>StartPos returns the start position of n.</p>
            
            <pre><code>func StartPos(n Node) Pos</code></pre>
         </article>
         
         <article class="function" data-name="EndPos">
            <h2>EndPos</h2>
            <hr />
            
            <p>EndPos returns the approximate end position of n in the source.
For some nodes (*Name, *BasicLit) it returns the position immediately
following the node; for others (*BlockStmt, *SwitchStmt, etc.) it
returns the position of the closing '}'; and for some (*ParenExpr)
the returned position is the end position of the last enclosed
expression.
Thus, EndPos should not be used for exact demarcation of the
end of a node in the source; it is mostly useful to determine
scope ranges where there is some leeway.</p>
            
            <pre><code>func EndPos(n Node) Pos</code></pre>
         </article>
         
         <article class="function" data-name="lastDecl">
            <h2>lastDecl</h2>
            <hr />
            
            <pre><code>func lastDecl(list []Decl) Decl</code></pre>
         </article>
         
         <article class="function" data-name="lastExpr">
            <h2>lastExpr</h2>
            <hr />
            
            <pre><code>func lastExpr(list []Expr) Expr</code></pre>
         </article>
         
         <article class="function" data-name="lastStmt">
            <h2>lastStmt</h2>
            <hr />
            
            <pre><code>func lastStmt(list []Stmt) Stmt</code></pre>
         </article>
         
         <article class="function" data-name="lastField">
            <h2>lastField</h2>
            <hr />
            
            <pre><code>func lastField(list []*Field) *Field</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init(src io.Reader, errh func, mode uint)</code></pre>
         </article>
         
         <article class="function" data-name="errorf">
            <h2>errorf</h2>
            <hr />
            
            <p>errorf reports an error at the most recently read character position.</p>
            
            <pre><code>func errorf(format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="errorAtf">
            <h2>errorAtf</h2>
            <hr />
            
            <p>errorAtf reports an error at a byte column offset relative to the current token start.</p>
            
            <pre><code>func errorAtf(offset int, format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="setLit">
            <h2>setLit</h2>
            <hr />
            
            <p>setLit sets the scanner state for a recognized _Literal token.</p>
            
            <pre><code>func setLit(kind LitKind, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="next">
            <h2>next</h2>
            <hr />
            
            <p>next advances the scanner by reading the next token.

If a read, source encoding, or lexical error occurs, next calls
the installed error handler with the respective error position
and message. The error message is guaranteed to be non-empty and
never starts with a '/'. The error handler must exist.

If the scanner mode includes the comments flag and a comment
(including comments containing directives) is encountered, the
error handler is also called with each comment position and text
(including opening /* or // and closing */, but without a newline
at the end of line comments). Comment text always starts with a /
which can be used to distinguish these handler calls from errors.

If the scanner mode includes the directives (but not the comments)
flag, only comments containing a //line, /*line, or //go: directive
are reported, in the same way as regular comments.</p>
            
            <pre><code>func next()</code></pre>
         </article>
         
         <article class="function" data-name="ident">
            <h2>ident</h2>
            <hr />
            
            <pre><code>func ident()</code></pre>
         </article>
         
         <article class="function" data-name="tokStrFast">
            <h2>tokStrFast</h2>
            <hr />
            
            <p>tokStrFast is a faster version of token.String, which assumes that tok
is one of the valid tokens - and can thus skip bounds checks.</p>
            
            <pre><code>func tokStrFast(tok token) string</code></pre>
         </article>
         
         <article class="function" data-name="atIdentChar">
            <h2>atIdentChar</h2>
            <hr />
            
            <pre><code>func atIdentChar(first bool) bool</code></pre>
         </article>
         
         <article class="function" data-name="hash">
            <h2>hash</h2>
            <hr />
            
            <p>hash is a perfect hash function for keywords.
It assumes that s has at least length 2.</p>
            
            <pre><code>func hash(s []byte) uint</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="lower">
            <h2>lower</h2>
            <hr />
            
            <pre><code>func lower(ch rune) rune</code></pre>
         </article>
         
         <article class="function" data-name="isLetter">
            <h2>isLetter</h2>
            <hr />
            
            <pre><code>func isLetter(ch rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="isDecimal">
            <h2>isDecimal</h2>
            <hr />
            
            <pre><code>func isDecimal(ch rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="isHex">
            <h2>isHex</h2>
            <hr />
            
            <pre><code>func isHex(ch rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="digits">
            <h2>digits</h2>
            <hr />
            
            <p>digits accepts the sequence { digit | '_' }.
If base <= 10, digits accepts any decimal digit but records
the index (relative to the literal start) of a digit >= base
in *invalid, if *invalid < 0.
digits returns a bitset describing whether the sequence contained
digits (bit 0 is set), or separators '_' (bit 1 is set).</p>
            
            <pre><code>func digits(base int, invalid *int) digsep int</code></pre>
         </article>
         
         <article class="function" data-name="number">
            <h2>number</h2>
            <hr />
            
            <pre><code>func number(seenPoint bool)</code></pre>
         </article>
         
         <article class="function" data-name="baseName">
            <h2>baseName</h2>
            <hr />
            
            <pre><code>func baseName(base int) string</code></pre>
         </article>
         
         <article class="function" data-name="invalidSep">
            <h2>invalidSep</h2>
            <hr />
            
            <p>invalidSep returns the index of the first invalid separator in x, or -1.</p>
            
            <pre><code>func invalidSep(x string) int</code></pre>
         </article>
         
         <article class="function" data-name="rune">
            <h2>rune</h2>
            <hr />
            
            <pre><code>func rune()</code></pre>
         </article>
         
         <article class="function" data-name="stdString">
            <h2>stdString</h2>
            <hr />
            
            <pre><code>func stdString()</code></pre>
         </article>
         
         <article class="function" data-name="rawString">
            <h2>rawString</h2>
            <hr />
            
            <pre><code>func rawString()</code></pre>
         </article>
         
         <article class="function" data-name="comment">
            <h2>comment</h2>
            <hr />
            
            <pre><code>func comment(text string)</code></pre>
         </article>
         
         <article class="function" data-name="skipLine">
            <h2>skipLine</h2>
            <hr />
            
            <pre><code>func skipLine()</code></pre>
         </article>
         
         <article class="function" data-name="lineComment">
            <h2>lineComment</h2>
            <hr />
            
            <pre><code>func lineComment()</code></pre>
         </article>
         
         <article class="function" data-name="skipComment">
            <h2>skipComment</h2>
            <hr />
            
            <pre><code>func skipComment() bool</code></pre>
         </article>
         
         <article class="function" data-name="fullComment">
            <h2>fullComment</h2>
            <hr />
            
            <pre><code>func fullComment()</code></pre>
         </article>
         
         <article class="function" data-name="escape">
            <h2>escape</h2>
            <hr />
            
            <pre><code>func escape(quote rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="checkBranches">
            <h2>checkBranches</h2>
            <hr />
            
            <p>checkBranches checks correct use of labels and branch
statements (break, continue, fallthrough, goto) in a function body.
It catches:
  - misplaced breaks, continues, and fallthroughs
  - bad labeled breaks and continues
  - invalid, unused, duplicate, and missing labels
  - gotos jumping over variable declarations and into blocks</p>
            
            <pre><code>func checkBranches(body *BlockStmt, errh ErrorHandler)</code></pre>
         </article>
         
         <article class="function" data-name="errf">
            <h2>errf</h2>
            <hr />
            
            <pre><code>func errf(pos Pos, format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="declare">
            <h2>declare</h2>
            <hr />
            
            <p>declare declares the label introduced by s in block b and returns
the new label. If the label was already declared, declare reports
and error and the existing label is returned instead.</p>
            
            <pre><code>func declare(b *block, s *LabeledStmt) *label</code></pre>
         </article>
         
         <article class="function" data-name="gotoTarget">
            <h2>gotoTarget</h2>
            <hr />
            
            <p>gotoTarget returns the labeled statement matching the given name and
declared in block b or any of its enclosing blocks. The result is nil
if the label is not defined, or doesn't match a valid labeled statement.</p>
            
            <pre><code>func gotoTarget(b *block, name string) *LabeledStmt</code></pre>
         </article>
         
         <article class="function" data-name="enclosingTarget">
            <h2>enclosingTarget</h2>
            <hr />
            
            <p>enclosingTarget returns the innermost enclosing labeled statement matching
the given name. The result is nil if the label is not defined, and invalid
if the label is defined but doesn't label a valid labeled statement.</p>
            
            <pre><code>func enclosingTarget(b *block, name string) *LabeledStmt</code></pre>
         </article>
         
         <article class="function" data-name="blockBranches">
            <h2>blockBranches</h2>
            <hr />
            
            <p>blockBranches processes a block's body starting at start and returns the
list of unresolved (forward) gotos. parent is the immediately enclosing
block (or nil), ctxt provides information about the enclosing statements,
and lstmt is the labeled statement associated with this block, or nil.</p>
            
            <pre><code>func blockBranches(parent *block, ctxt targets, lstmt *LabeledStmt, start Pos, body []Stmt) []*BranchStmt</code></pre>
         </article>
         
         <article class="function" data-name="trimTrailingEmptyStmts">
            <h2>trimTrailingEmptyStmts</h2>
            <hr />
            
            <pre><code>func trimTrailingEmptyStmts(list []Stmt) []Stmt</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
