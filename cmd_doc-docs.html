<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - main</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="cmd_doc_testdata-docs.html">testdata</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>main</code>
         </h1>
         <hr />
         
         <article class="global" data-name="dirs">
            <h2>dirs</h2>
            <hr />
            
            <pre><code>dirs Dirs</code></pre>
         </article>
         
         <article class="global" data-name="testGOPATH">
            <h2>testGOPATH</h2>
            <hr />
            
            <pre><code>testGOPATH</code></pre>
         </article>
         
         <article class="global" data-name="codeRootsCache">
            <h2>codeRootsCache</h2>
            <hr />
            
            <pre><code>codeRootsCache *ast.StructType</code></pre>
         </article>
         
         <article class="global" data-name="usingModules">
            <h2>usingModules</h2>
            <hr />
            
            <pre><code>usingModules bool</code></pre>
         </article>
         
         <article class="global" data-name="modFlagRegexp">
            <h2>modFlagRegexp</h2>
            <hr />
            
            <pre><code>modFlagRegexp</code></pre>
         </article>
         
         <article class="global" data-name="isDotSlashTests">
            <h2>isDotSlashTests</h2>
            <hr />
            
            <pre><code>isDotSlashTests</code></pre>
         </article>
         
         <article class="global" data-name="p">
            <h2>p</h2>
            <hr />
            
            <pre><code>p</code></pre>
         </article>
         
         <article class="global" data-name="tests">
            <h2>tests</h2>
            <hr />
            
            <pre><code>tests</code></pre>
         </article>
         
         <article class="global" data-name="trimTests">
            <h2>trimTests</h2>
            <hr />
            
            <pre><code>trimTests</code></pre>
         </article>
         
         <article class="global" data-name="unexported">
            <h2>unexported</h2>
            <hr />
            
            <pre><code>unexported bool</code></pre>
         </article>
         
         <article class="global" data-name="matchCase">
            <h2>matchCase</h2>
            <hr />
            
            <pre><code>matchCase bool</code></pre>
         </article>
         
         <article class="global" data-name="chdir">
            <h2>chdir</h2>
            <hr />
            
            <pre><code>chdir string</code></pre>
         </article>
         
         <article class="global" data-name="showAll">
            <h2>showAll</h2>
            <hr />
            
            <pre><code>showAll bool</code></pre>
         </article>
         
         <article class="global" data-name="showCmd">
            <h2>showCmd</h2>
            <hr />
            
            <pre><code>showCmd bool</code></pre>
         </article>
         
         <article class="global" data-name="showSrc">
            <h2>showSrc</h2>
            <hr />
            
            <pre><code>showSrc bool</code></pre>
         </article>
         
         <article class="global" data-name="short">
            <h2>short</h2>
            <hr />
            
            <pre><code>short bool</code></pre>
         </article>
         
         <article class="global" data-name="dotPaths">
            <h2>dotPaths</h2>
            <hr />
            
            <p>dotPaths lists all the dotted paths legal on Unix-like and
Windows-like file systems. We check them all, as the chance
of error is minute and even on Windows people will use ./
sometimes.</p>
            
            <pre><code>dotPaths</code></pre>
         </article>
         
         <article class="global" data-name="buildCtx">
            <h2>buildCtx</h2>
            <hr />
            
            <pre><code>buildCtx</code></pre>
         </article>
         
         <article class="global" data-name="punchedCardWidth">
            <h2>punchedCardWidth</h2>
            <hr />
            
            <pre><code>punchedCardWidth</code></pre>
         </article>
         
         <article class="global" data-name="indent">
            <h2>indent</h2>
            <hr />
            
            <pre><code>indent</code></pre>
         </article>
         
         <article class="global" data-name="newlineBytes">
            <h2>newlineBytes</h2>
            <hr />
            
            <pre><code>newlineBytes</code></pre>
         </article>
          
         <article class="struct" data-name="Dir">
            <h2>type Dir struct</h2>
            <hr />
            
            <p>A Dir describes a directory holding code by specifying
the expected import path and the file system directory.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">importPath string
dir string
inModule bool</code></pre>
         </article>
         
         <article class="struct" data-name="Dirs">
            <h2>type Dirs struct</h2>
            <hr />
            
            <p>Dirs is a structure for scanning the directory tree.
Its Next method returns the next Go source directory it finds.
Although it can be used to scan the tree multiple times, it
only walks the tree once, caching the data it finds.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">scan *ast.ChanType
hist []Dir
offset int</code></pre>
         </article>
         
         <article class="struct" data-name="moduleJSON">
            <h2>type moduleJSON struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Path string
Dir string
GoVersion string</code></pre>
         </article>
         
         <article class="struct" data-name="isDotSlashTest">
            <h2>type isDotSlashTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">str string
result bool</code></pre>
         </article>
         
         <article class="struct" data-name="test">
            <h2>type test struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
args []string
yes []string
no []string</code></pre>
         </article>
         
         <article class="struct" data-name="trimTest">
            <h2>type trimTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string
prefix string
result string
ok bool</code></pre>
         </article>
         
         <article class="struct" data-name="Package">
            <h2>type Package struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">writer io.Writer
name string
userPath string
pkg *ast.Package
file *ast.File
doc *doc.Package
build *build.Package
typedValue *ast.MapType
constructor *ast.MapType
fs *token.FileSet
buf pkgBuffer</code></pre>
         </article>
         
         <article class="struct" data-name="pkgBuffer">
            <h2>type pkgBuffer struct</h2>
            <hr />
            
            <p>pkgBuffer is a wrapper for bytes.Buffer that prints a package clause the
first time Write is called.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pkg *Package
printed bool
bytes.Buffer</code></pre>
         </article>
          
         <article class="function" data-name="dirsInit">
            <h2>dirsInit</h2>
            <hr />
            
            <p>dirsInit starts the scanning of package directories in GOROOT and GOPATH. Any
extra paths passed to it are included in the channel.</p>
            
            <pre><code>func dirsInit(extra ...Dir)</code></pre>
         </article>
         
         <article class="function" data-name="goCmd">
            <h2>goCmd</h2>
            <hr />
            
            <p>goCmd returns the "go" command path corresponding to buildCtx.GOROOT.</p>
            
            <pre><code>func goCmd() string</code></pre>
         </article>
         
         <article class="function" data-name="Reset">
            <h2>Reset</h2>
            <hr />
            
            <p>Reset puts the scan back at the beginning.</p>
            
            <pre><code>func Reset()</code></pre>
         </article>
         
         <article class="function" data-name="Next">
            <h2>Next</h2>
            <hr />
            
            <p>Next returns the next directory in the scan. The boolean
is false when the scan is done.</p>
            
            <pre><code>func Next() (Dir, bool)</code></pre>
         </article>
         
         <article class="function" data-name="walk">
            <h2>walk</h2>
            <hr />
            
            <p>walk walks the trees in GOROOT and GOPATH.</p>
            
            <pre><code>func walk(roots []Dir)</code></pre>
         </article>
         
         <article class="function" data-name="bfsWalkRoot">
            <h2>bfsWalkRoot</h2>
            <hr />
            
            <p>bfsWalkRoot walks a single directory hierarchy in breadth-first lexical order.
Each Go source directory it finds is delivered on d.scan.</p>
            
            <pre><code>func bfsWalkRoot(root Dir)</code></pre>
         </article>
         
         <article class="function" data-name="codeRoots">
            <h2>codeRoots</h2>
            <hr />
            
            <p>codeRoots returns the code roots to search for packages.
In GOPATH mode this is GOROOT/src and GOPATH/src, with empty import paths.
In module mode, this is each module root, with an import path set to its module path.</p>
            
            <pre><code>func codeRoots() []Dir</code></pre>
         </article>
         
         <article class="function" data-name="findCodeRoots">
            <h2>findCodeRoots</h2>
            <hr />
            
            <pre><code>func findCodeRoots() []Dir</code></pre>
         </article>
         
         <article class="function" data-name="vendorEnabled">
            <h2>vendorEnabled</h2>
            <hr />
            
            <p>vendorEnabled indicates if vendoring is enabled.
Inspired by setDefaultBuildMod in modload/init.go</p>
            
            <pre><code>func vendorEnabled() (*moduleJSON, bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="getMainModuleAnd114">
            <h2>getMainModuleAnd114</h2>
            <hr />
            
            <p>getMainModuleAnd114 gets the main module's information and whether the
go command in use is 1.14+. This is the information needed to figure out
if vendoring should be enabled.</p>
            
            <pre><code>func getMainModuleAnd114() (*moduleJSON, bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestMain">
            <h2>TestMain</h2>
            <hr />
            
            <pre><code>func TestMain(m *testing.M)</code></pre>
         </article>
         
         <article class="function" data-name="maybeSkip">
            <h2>maybeSkip</h2>
            <hr />
            
            <pre><code>func maybeSkip(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIsDotSlashPath">
            <h2>TestIsDotSlashPath</h2>
            <hr />
            
            <pre><code>func TestIsDotSlashPath(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDoc">
            <h2>TestDoc</h2>
            <hr />
            
            <pre><code>func TestDoc(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMultiplePackages">
            <h2>TestMultiplePackages</h2>
            <hr />
            
            <p>Test the code to try multiple packages. Our test case is

	go doc rand.Float64

This needs to find math/rand.Float64; however crypto/rand, which doesn't
have the symbol, usually appears first in the directory listing.</p>
            
            <pre><code>func TestMultiplePackages(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestTwoArgLookup">
            <h2>TestTwoArgLookup</h2>
            <hr />
            
            <p>Test the code to look up packages when given two args. First test case is

	go doc binary BigEndian

This needs to find encoding/binary.BigEndian, which means
finding the package encoding/binary given only "binary".
Second case is

	go doc rand Float64

which again needs to find math/rand and not give up after crypto/rand,
which has no such function.</p>
            
            <pre><code>func TestTwoArgLookup(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDotSlashLookup">
            <h2>TestDotSlashLookup</h2>
            <hr />
            
            <p>Test the code to look up packages when the first argument starts with "./".
Our test case is in effect "cd src/text; doc ./template". This should get
text/template but before Issue 23383 was fixed would give html/template.</p>
            
            <pre><code>func TestDotSlashLookup(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNoPackageClauseWhenNoMatch">
            <h2>TestNoPackageClauseWhenNoMatch</h2>
            <hr />
            
            <p>Test that we don't print spurious package clauses
when there should be no output at all. Issue 37969.</p>
            
            <pre><code>func TestNoPackageClauseWhenNoMatch(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestTrim">
            <h2>TestTrim</h2>
            <hr />
            
            <pre><code>func TestTrim(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="usage">
            <h2>usage</h2>
            <hr />
            
            <p>usage is a replacement usage function for the flags package.</p>
            
            <pre><code>func usage()</code></pre>
         </article>
         
         <article class="function" data-name="main">
            <h2>main</h2>
            <hr />
            
            <pre><code>func main()</code></pre>
         </article>
         
         <article class="function" data-name="do">
            <h2>do</h2>
            <hr />
            
            <p>do is the workhorse, broken out of main to make testing easier.</p>
            
            <pre><code>func do(writer io.Writer, flagSet *flag.FlagSet, args []string) err error</code></pre>
         </article>
         
         <article class="function" data-name="failMessage">
            <h2>failMessage</h2>
            <hr />
            
            <p>failMessage creates a nicely formatted error message when there is no result to show.</p>
            
            <pre><code>func failMessage(paths []string, symbol string, method string) error</code></pre>
         </article>
         
         <article class="function" data-name="parseArgs">
            <h2>parseArgs</h2>
            <hr />
            
            <p>parseArgs analyzes the arguments (if any) and returns the package
it represents, the part of the argument the user used to identify
the path (or "" if it's the current package) and the symbol
(possibly with a .method) within that package.
parseSymbol is used to analyze the symbol itself.
The boolean final argument reports whether it is possible that
there may be more directories worth looking at. It will only
be true if the package path is a partial match for some directory
and there may be more matches. For example, if the argument
is rand.Float64, we must scan both crypto/rand and math/rand
to find the symbol, and the first call will return crypto/rand, true.</p>
            
            <pre><code>func parseArgs(args []string) (pkg *build.Package, path string, symbol string, more bool)</code></pre>
         </article>
         
         <article class="function" data-name="isDotSlash">
            <h2>isDotSlash</h2>
            <hr />
            
            <p>isDotSlash reports whether the path begins with a reference
to the local . or .. directory.</p>
            
            <pre><code>func isDotSlash(arg string) bool</code></pre>
         </article>
         
         <article class="function" data-name="importDir">
            <h2>importDir</h2>
            <hr />
            
            <p>importDir is just an error-catching wrapper for build.ImportDir.</p>
            
            <pre><code>func importDir(dir string) *build.Package</code></pre>
         </article>
         
         <article class="function" data-name="parseSymbol">
            <h2>parseSymbol</h2>
            <hr />
            
            <p>parseSymbol breaks str apart into a symbol and method.
Both may be missing or the method may be missing.
If present, each must be a valid Go identifier.</p>
            
            <pre><code>func parseSymbol(str string) (symbol string, method string)</code></pre>
         </article>
         
         <article class="function" data-name="isExported">
            <h2>isExported</h2>
            <hr />
            
            <p>isExported reports whether the name is an exported identifier.
If the unexported flag (-u) is true, isExported returns true because
it means that we treat the name as if it is exported.</p>
            
            <pre><code>func isExported(name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="findNextPackage">
            <h2>findNextPackage</h2>
            <hr />
            
            <p>findNextPackage returns the next full file name path that matches the
(perhaps partial) package path pkg. The boolean reports if any match was found.</p>
            
            <pre><code>func findNextPackage(pkg string) (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="splitGopath">
            <h2>splitGopath</h2>
            <hr />
            
            <p>splitGopath splits $GOPATH into a list of roots.</p>
            
            <pre><code>func splitGopath() []string</code></pre>
         </article>
         
         <article class="function" data-name="ToText">
            <h2>ToText</h2>
            <hr />
            
            <pre><code>func ToText(w io.Writer, text string, prefix string, codePrefix string)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="packageClause">
            <h2>packageClause</h2>
            <hr />
            
            <pre><code>func packageClause()</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="prettyPath">
            <h2>prettyPath</h2>
            <hr />
            
            <p>prettyPath returns a version of the package path that is suitable for an
error message. It obeys the import comment if present. Also, since
pkg.build.ImportPath is sometimes the unhelpful "" or ".", it looks for a
directory name in GOROOT or GOPATH if that happens.</p>
            
            <pre><code>func prettyPath() string</code></pre>
         </article>
         
         <article class="function" data-name="trim">
            <h2>trim</h2>
            <hr />
            
            <p>trim trims the directory prefix from the path, paying attention
to the path separator. If they are the same string or the prefix
is not present the original is returned. The boolean reports whether
the prefix is present. That path and prefix have slashes for separators.</p>
            
            <pre><code>func trim(path string, prefix string) (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="Fatalf">
            <h2>Fatalf</h2>
            <hr />
            
            <p>pkg.Fatalf is like log.Fatalf, but panics so it can be recovered in the
main do function, so it doesn't cause an exit. Allows testing to work
without running a subprocess. The log prefix will be added when
logged in main; it is not added here.</p>
            
            <pre><code>func Fatalf(format string, args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="parsePackage">
            <h2>parsePackage</h2>
            <hr />
            
            <p>parsePackage turns the build package we found into a parsed package
we can then use to generate documentation.</p>
            
            <pre><code>func parsePackage(writer io.Writer, pkg *build.Package, userPath string) *Package</code></pre>
         </article>
         
         <article class="function" data-name="Printf">
            <h2>Printf</h2>
            <hr />
            
            <pre><code>func Printf(format string, args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="flush">
            <h2>flush</h2>
            <hr />
            
            <pre><code>func flush()</code></pre>
         </article>
         
         <article class="function" data-name="newlines">
            <h2>newlines</h2>
            <hr />
            
            <p>newlines guarantees there are n newlines at the end of the buffer.</p>
            
            <pre><code>func newlines(n int)</code></pre>
         </article>
         
         <article class="function" data-name="emit">
            <h2>emit</h2>
            <hr />
            
            <p>emit prints the node. If showSrc is true, it ignores the provided comment,
assuming the comment is in the node itself. Otherwise, the go/doc package
clears the stuff we don't want to print anyway. It's a bit of a magic trick.</p>
            
            <pre><code>func emit(comment string, node ast.Node)</code></pre>
         </article>
         
         <article class="function" data-name="oneLineNode">
            <h2>oneLineNode</h2>
            <hr />
            
            <p>oneLineNode returns a one-line summary of the given input node.</p>
            
            <pre><code>func oneLineNode(node ast.Node) string</code></pre>
         </article>
         
         <article class="function" data-name="oneLineNodeDepth">
            <h2>oneLineNodeDepth</h2>
            <hr />
            
            <p>oneLineNodeDepth returns a one-line summary of the given input node.
The depth specifies the maximum depth when traversing the AST.</p>
            
            <pre><code>func oneLineNodeDepth(node ast.Node, depth int) string</code></pre>
         </article>
         
         <article class="function" data-name="formatTypeParams">
            <h2>formatTypeParams</h2>
            <hr />
            
            <pre><code>func formatTypeParams(list *ast.FieldList, depth int) string</code></pre>
         </article>
         
         <article class="function" data-name="oneLineField">
            <h2>oneLineField</h2>
            <hr />
            
            <p>oneLineField returns a one-line summary of the field.</p>
            
            <pre><code>func oneLineField(field *ast.Field, depth int) string</code></pre>
         </article>
         
         <article class="function" data-name="joinStrings">
            <h2>joinStrings</h2>
            <hr />
            
            <p>joinStrings formats the input as a comma-separated list,
but truncates the list at some reasonable length if necessary.</p>
            
            <pre><code>func joinStrings(ss []string) string</code></pre>
         </article>
         
         <article class="function" data-name="printHeader">
            <h2>printHeader</h2>
            <hr />
            
            <p>printHeader prints a header for the section named s, adding a blank line on each side.</p>
            
            <pre><code>func printHeader(s string)</code></pre>
         </article>
         
         <article class="function" data-name="constsDoc">
            <h2>constsDoc</h2>
            <hr />
            
            <p>constsDoc prints all const documentation, if any, including a header.
The one argument is the valueDoc registry.</p>
            
            <pre><code>func constsDoc(printed *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="varsDoc">
            <h2>varsDoc</h2>
            <hr />
            
            <p>varsDoc prints all var documentation, if any, including a header.
Printed is the valueDoc registry.</p>
            
            <pre><code>func varsDoc(printed *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="funcsDoc">
            <h2>funcsDoc</h2>
            <hr />
            
            <p>funcsDoc prints all func documentation, if any, including a header.</p>
            
            <pre><code>func funcsDoc()</code></pre>
         </article>
         
         <article class="function" data-name="typesDoc">
            <h2>typesDoc</h2>
            <hr />
            
            <p>funcsDoc prints all type documentation, if any, including a header.</p>
            
            <pre><code>func typesDoc()</code></pre>
         </article>
         
         <article class="function" data-name="packageDoc">
            <h2>packageDoc</h2>
            <hr />
            
            <p>packageDoc prints the docs for the package.</p>
            
            <pre><code>func packageDoc()</code></pre>
         </article>
         
         <article class="function" data-name="packageClause">
            <h2>packageClause</h2>
            <hr />
            
            <p>packageClause prints the package clause.</p>
            
            <pre><code>func packageClause()</code></pre>
         </article>
         
         <article class="function" data-name="valueSummary">
            <h2>valueSummary</h2>
            <hr />
            
            <p>valueSummary prints a one-line summary for each set of values and constants.
If all the types in a constant or variable declaration belong to the same
type they can be printed by typeSummary, and so can be suppressed here.</p>
            
            <pre><code>func valueSummary(values []*doc.Value, showGrouped bool)</code></pre>
         </article>
         
         <article class="function" data-name="funcSummary">
            <h2>funcSummary</h2>
            <hr />
            
            <p>funcSummary prints a one-line summary for each function. Constructors
are printed by typeSummary, below, and so can be suppressed here.</p>
            
            <pre><code>func funcSummary(funcs []*doc.Func, showConstructors bool)</code></pre>
         </article>
         
         <article class="function" data-name="typeSummary">
            <h2>typeSummary</h2>
            <hr />
            
            <p>typeSummary prints a one-line summary for each type, followed by its constructors.</p>
            
            <pre><code>func typeSummary()</code></pre>
         </article>
         
         <article class="function" data-name="bugs">
            <h2>bugs</h2>
            <hr />
            
            <p>bugs prints the BUGS information for the package.
TODO: Provide access to TODOs and NOTEs as well (very noisy so off by default)?</p>
            
            <pre><code>func bugs()</code></pre>
         </article>
         
         <article class="function" data-name="findValues">
            <h2>findValues</h2>
            <hr />
            
            <p>findValues finds the doc.Values that describe the symbol.</p>
            
            <pre><code>func findValues(symbol string, docValues []*doc.Value) values []*doc.Value</code></pre>
         </article>
         
         <article class="function" data-name="findFuncs">
            <h2>findFuncs</h2>
            <hr />
            
            <p>findFuncs finds the doc.Funcs that describes the symbol.</p>
            
            <pre><code>func findFuncs(symbol string) funcs []*doc.Func</code></pre>
         </article>
         
         <article class="function" data-name="findTypes">
            <h2>findTypes</h2>
            <hr />
            
            <p>findTypes finds the doc.Types that describes the symbol.
If symbol is empty, it finds all exported types.</p>
            
            <pre><code>func findTypes(symbol string) types []*doc.Type</code></pre>
         </article>
         
         <article class="function" data-name="findTypeSpec">
            <h2>findTypeSpec</h2>
            <hr />
            
            <p>findTypeSpec returns the ast.TypeSpec within the declaration that defines the symbol.
The name must match exactly.</p>
            
            <pre><code>func findTypeSpec(decl *ast.GenDecl, symbol string) *ast.TypeSpec</code></pre>
         </article>
         
         <article class="function" data-name="symbolDoc">
            <h2>symbolDoc</h2>
            <hr />
            
            <p>symbolDoc prints the docs for symbol. There may be multiple matches.
If symbol matches a type, output includes its methods factories and associated constants.
If there is no top-level symbol, symbolDoc looks for methods that match.</p>
            
            <pre><code>func symbolDoc(symbol string) bool</code></pre>
         </article>
         
         <article class="function" data-name="valueDoc">
            <h2>valueDoc</h2>
            <hr />
            
            <p>valueDoc prints the docs for a constant or variable. The printed map records
which values have been printed already to avoid duplication. Otherwise, a
declaration like:

	const ( c = 1; C = 2 )

… could be printed twice if the -u flag is set, as it matches twice.</p>
            
            <pre><code>func valueDoc(value *doc.Value, printed *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="typeDoc">
            <h2>typeDoc</h2>
            <hr />
            
            <p>typeDoc prints the docs for a type, including constructors and other items
related to it.</p>
            
            <pre><code>func typeDoc(typ *doc.Type)</code></pre>
         </article>
         
         <article class="function" data-name="trimUnexportedElems">
            <h2>trimUnexportedElems</h2>
            <hr />
            
            <p>trimUnexportedElems modifies spec in place to elide unexported fields from
structs and methods from interfaces (unless the unexported flag is set or we
are asked to show the original source).</p>
            
            <pre><code>func trimUnexportedElems(spec *ast.TypeSpec)</code></pre>
         </article>
         
         <article class="function" data-name="trimUnexportedFields">
            <h2>trimUnexportedFields</h2>
            <hr />
            
            <p>trimUnexportedFields returns the field list trimmed of unexported fields.</p>
            
            <pre><code>func trimUnexportedFields(fields *ast.FieldList, isInterface bool) *ast.FieldList</code></pre>
         </article>
         
         <article class="function" data-name="printMethodDoc">
            <h2>printMethodDoc</h2>
            <hr />
            
            <p>printMethodDoc prints the docs for matches of symbol.method.
If symbol is empty, it prints all methods for any concrete type
that match the name. It reports whether it found any methods.</p>
            
            <pre><code>func printMethodDoc(symbol string, method string) bool</code></pre>
         </article>
         
         <article class="function" data-name="printFieldDoc">
            <h2>printFieldDoc</h2>
            <hr />
            
            <p>printFieldDoc prints the docs for matches of symbol.fieldName.
It reports whether it found any field.
Both symbol and fieldName must be non-empty or it returns false.</p>
            
            <pre><code>func printFieldDoc(symbol string, fieldName string) bool</code></pre>
         </article>
         
         <article class="function" data-name="match">
            <h2>match</h2>
            <hr />
            
            <p>match reports whether the user's symbol matches the program's.
A lower-case character in the user's string matches either case in the program's.
The program string must be exported.</p>
            
            <pre><code>func match(user string, program string) bool</code></pre>
         </article>
         
         <article class="function" data-name="simpleFold">
            <h2>simpleFold</h2>
            <hr />
            
            <p>simpleFold returns the minimum rune equivalent to r
under Unicode-defined simple case folding.</p>
            
            <pre><code>func simpleFold(r rune) rune</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
