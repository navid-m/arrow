<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - main</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>main</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"bytes"
"fmt"
"log"
"os"
"os/exec"
"path/filepath"
"regexp"
"strings"
"sync"
"golang.org/x/mod/semver"
"bytes"
"flag"
"fmt"
"go/build"
"go/token"
"io"
"log"
"os"
"path"
"path/filepath"
"strings"
"cmd/internal/telemetry/counter"
"bufio"
"bytes"
"fmt"
"go/ast"
"go/build"
"go/doc"
"go/format"
"go/parser"
"go/printer"
"go/token"
"io"
"io/fs"
"log"
"path/filepath"
"strings"
"unicode"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="buildCtx" data-name="buildCtx">
               <h3>
                  buildCtx 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#buildCtx" class="anchor" title="Link to buildCtx">#</a>
               </h3>
               
               <pre><code class="language-go">var buildCtx = build.Default</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="chdir" data-name="chdir">
               <h3>
                  chdir 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#chdir" class="anchor" title="Link to chdir">#</a>
               </h3>
               
               <pre><code class="language-go">var chdir string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="codeRootsCache" data-name="codeRootsCache">
               <h3>
                  codeRootsCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#codeRootsCache" class="anchor" title="Link to codeRootsCache">#</a>
               </h3>
               
               <pre><code class="language-go">var codeRootsCache struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dirs" data-name="dirs">
               <h3>
                  dirs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dirs" class="anchor" title="Link to dirs">#</a>
               </h3>
               
               <pre><code class="language-go">var dirs Dirs</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dotPaths" data-name="dotPaths">
               <h3>
                  dotPaths 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dotPaths" class="anchor" title="Link to dotPaths">#</a>
               </h3>
               
               <p>dotPaths lists all the dotted paths legal on Unix-like and
Windows-like file systems. We check them all, as the chance
of error is minute and even on Windows people will use ./
sometimes.</p>
               
               <pre><code class="language-go">var dotPaths = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="indent" data-name="indent">
               <h3>
                  indent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#indent" class="anchor" title="Link to indent">#</a>
               </h3>
               
               <pre><code class="language-go">const indent = "    "</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="matchCase" data-name="matchCase">
               <h3>
                  matchCase 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#matchCase" class="anchor" title="Link to matchCase">#</a>
               </h3>
               
               <pre><code class="language-go">var matchCase bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="modFlagRegexp" data-name="modFlagRegexp">
               <h3>
                  modFlagRegexp 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#modFlagRegexp" class="anchor" title="Link to modFlagRegexp">#</a>
               </h3>
               
               <pre><code class="language-go">var modFlagRegexp = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="newlineBytes" data-name="newlineBytes">
               <h3>
                  newlineBytes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#newlineBytes" class="anchor" title="Link to newlineBytes">#</a>
               </h3>
               
               <pre><code class="language-go">var newlineBytes = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="punchedCardWidth" data-name="punchedCardWidth">
               <h3>
                  punchedCardWidth 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#punchedCardWidth" class="anchor" title="Link to punchedCardWidth">#</a>
               </h3>
               
               <pre><code class="language-go">const punchedCardWidth = 80</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="short" data-name="short">
               <h3>
                  short 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#short" class="anchor" title="Link to short">#</a>
               </h3>
               
               <pre><code class="language-go">var short bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="showAll" data-name="showAll">
               <h3>
                  showAll 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#showAll" class="anchor" title="Link to showAll">#</a>
               </h3>
               
               <pre><code class="language-go">var showAll bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="showCmd" data-name="showCmd">
               <h3>
                  showCmd 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#showCmd" class="anchor" title="Link to showCmd">#</a>
               </h3>
               
               <pre><code class="language-go">var showCmd bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="showSrc" data-name="showSrc">
               <h3>
                  showSrc 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#showSrc" class="anchor" title="Link to showSrc">#</a>
               </h3>
               
               <pre><code class="language-go">var showSrc bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testGOPATH" data-name="testGOPATH">
               <h3>
                  testGOPATH 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testGOPATH" class="anchor" title="Link to testGOPATH">#</a>
               </h3>
               
               <pre><code class="language-go">var testGOPATH = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unexported" data-name="unexported">
               <h3>
                  unexported 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#unexported" class="anchor" title="Link to unexported">#</a>
               </h3>
               
               <pre><code class="language-go">var unexported bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="usingModules" data-name="usingModules">
               <h3>
                  usingModules 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#usingModules" class="anchor" title="Link to usingModules">#</a>
               </h3>
               
               <pre><code class="language-go">var usingModules bool</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="PackageError" data-name="PackageError">
               <h3>
                  PackageError
                  <span class="badge type-badge">type</span>
                  <a href="#PackageError" class="anchor" title="Link to PackageError">#</a>
               </h3>
               
               <pre><code class="language-go">type PackageError string</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Dir" data-name="Dir">
               <h3>
                  Dir
                  <span class="badge">struct</span>
                  <a href="#Dir" class="anchor" title="Link to Dir">#</a>
               </h3>
               
               <p>A Dir describes a directory holding code by specifying
the expected import path and the file system directory.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Dir struct {
importPath string
dir string
inModule bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Dirs" data-name="Dirs">
               <h3>
                  Dirs
                  <span class="badge">struct</span>
                  <a href="#Dirs" class="anchor" title="Link to Dirs">#</a>
               </h3>
               
               <p>Dirs is a structure for scanning the directory tree.
Its Next method returns the next Go source directory it finds.
Although it can be used to scan the tree multiple times, it
only walks the tree once, caching the data it finds.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Dirs struct {
scan chan Dir
hist []Dir
offset int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Package" data-name="Package">
               <h3>
                  Package
                  <span class="badge">struct</span>
                  <a href="#Package" class="anchor" title="Link to Package">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Package struct {
writer io.Writer
name string
userPath string
pkg *ast.Package
file *ast.File
doc *doc.Package
build *build.Package
typedValue map[*doc.Value]bool
constructor map[*doc.Func]bool
fs *token.FileSet
buf pkgBuffer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="moduleJSON" data-name="moduleJSON">
               <h3>
                  moduleJSON
                  <span class="badge">struct</span>
                  <a href="#moduleJSON" class="anchor" title="Link to moduleJSON">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type moduleJSON struct {
Path string
Dir string
GoVersion string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pkgBuffer" data-name="pkgBuffer">
               <h3>
                  pkgBuffer
                  <span class="badge">struct</span>
                  <a href="#pkgBuffer" class="anchor" title="Link to pkgBuffer">#</a>
               </h3>
               
               <p>pkgBuffer is a wrapper for bytes.Buffer that prints a package clause the
first time Write is called.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type pkgBuffer struct {
pkg *Package
printed bool
bytes.Buffer
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (p PackageError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fatalf" data-name="Fatalf">
               <h3>
                  Fatalf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Fatalf" class="anchor" title="Link to Fatalf">#</a>
               </h3>
               
               <p>pkg.Fatalf is like log.Fatalf, but panics so it can be recovered in the
main do function, so it doesn't cause an exit. Allows testing to work
without running a subprocess. The log prefix will be added when
logged in main; it is not added here.</p>
               
               <pre><code class="language-go">func (pkg *Package) Fatalf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Next" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Next" class="anchor" title="Link to Next">#</a>
               </h3>
               
               <p>Next returns the next directory in the scan. The boolean
is false when the scan is done.</p>
               
               <pre><code class="language-go">func (d *Dirs) Next() (Dir, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Printf" data-name="Printf">
               <h3>
                  Printf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Printf" class="anchor" title="Link to Printf">#</a>
               </h3>
               
               <pre><code class="language-go">func (pkg *Package) Printf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset puts the scan back at the beginning.</p>
               
               <pre><code class="language-go">func (d *Dirs) Reset()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ToText" data-name="ToText">
               <h3>
                  ToText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ToText" class="anchor" title="Link to ToText">#</a>
               </h3>
               
               <pre><code class="language-go">func (pkg *Package) ToText(w io.Writer, text string, prefix string, codePrefix string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code class="language-go">func (pb *pkgBuffer) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bfsWalkRoot" data-name="bfsWalkRoot">
               <h3>
                  bfsWalkRoot 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bfsWalkRoot" class="anchor" title="Link to bfsWalkRoot">#</a>
               </h3>
               
               <p>bfsWalkRoot walks a single directory hierarchy in breadth-first lexical order.
Each Go source directory it finds is delivered on d.scan.</p>
               
               <pre><code class="language-go">func (d *Dirs) bfsWalkRoot(root Dir)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bugs" data-name="bugs">
               <h3>
                  bugs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bugs" class="anchor" title="Link to bugs">#</a>
               </h3>
               
               <p>bugs prints the BUGS information for the package.
TODO: Provide access to TODOs and NOTEs as well (very noisy so off by default)?</p>
               
               <pre><code class="language-go">func (pkg *Package) bugs()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="codeRoots" data-name="codeRoots">
               <h3>
                  codeRoots 
                  <span class="badge">function</span>
                  
                  <a href="#codeRoots" class="anchor" title="Link to codeRoots">#</a>
               </h3>
               
               <p>codeRoots returns the code roots to search for packages.
In GOPATH mode this is GOROOT/src and GOPATH/src, with empty import paths.
In module mode, this is each module root, with an import path set to its module path.</p>
               
               <pre><code class="language-go">func codeRoots() []Dir</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="constsDoc" data-name="constsDoc">
               <h3>
                  constsDoc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#constsDoc" class="anchor" title="Link to constsDoc">#</a>
               </h3>
               
               <p>constsDoc prints all const documentation, if any, including a header.
The one argument is the valueDoc registry.</p>
               
               <pre><code class="language-go">func (pkg *Package) constsDoc(printed map[*ast.GenDecl]bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dirsInit" data-name="dirsInit">
               <h3>
                  dirsInit 
                  <span class="badge">function</span>
                  
                  <a href="#dirsInit" class="anchor" title="Link to dirsInit">#</a>
               </h3>
               
               <p>dirsInit starts the scanning of package directories in GOROOT and GOPATH. Any
extra paths passed to it are included in the channel.</p>
               
               <pre><code class="language-go">func dirsInit(extra ...Dir)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="do" data-name="do">
               <h3>
                  do 
                  <span class="badge">function</span>
                  
                  <a href="#do" class="anchor" title="Link to do">#</a>
               </h3>
               
               <p>do is the workhorse, broken out of main to make testing easier.</p>
               
               <pre><code class="language-go">func do(writer io.Writer, flagSet *flag.FlagSet, args []string) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emit" data-name="emit">
               <h3>
                  emit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#emit" class="anchor" title="Link to emit">#</a>
               </h3>
               
               <p>emit prints the node. If showSrc is true, it ignores the provided comment,
assuming the comment is in the node itself. Otherwise, the go/doc package
clears the stuff we don't want to print anyway. It's a bit of a magic trick.</p>
               
               <pre><code class="language-go">func (pkg *Package) emit(comment string, node ast.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="failMessage" data-name="failMessage">
               <h3>
                  failMessage 
                  <span class="badge">function</span>
                  
                  <a href="#failMessage" class="anchor" title="Link to failMessage">#</a>
               </h3>
               
               <p>failMessage creates a nicely formatted error message when there is no result to show.</p>
               
               <pre><code class="language-go">func failMessage(paths []string, symbol string, method string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findCodeRoots" data-name="findCodeRoots">
               <h3>
                  findCodeRoots 
                  <span class="badge">function</span>
                  
                  <a href="#findCodeRoots" class="anchor" title="Link to findCodeRoots">#</a>
               </h3>
               
               <pre><code class="language-go">func findCodeRoots() []Dir</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findFuncs" data-name="findFuncs">
               <h3>
                  findFuncs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findFuncs" class="anchor" title="Link to findFuncs">#</a>
               </h3>
               
               <p>findFuncs finds the doc.Funcs that describes the symbol.</p>
               
               <pre><code class="language-go">func (pkg *Package) findFuncs(symbol string) (funcs []*doc.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findNextPackage" data-name="findNextPackage">
               <h3>
                  findNextPackage 
                  <span class="badge">function</span>
                  
                  <a href="#findNextPackage" class="anchor" title="Link to findNextPackage">#</a>
               </h3>
               
               <p>findNextPackage returns the next full file name path that matches the
(perhaps partial) package path pkg. The boolean reports if any match was found.</p>
               
               <pre><code class="language-go">func findNextPackage(pkg string) (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findTypeSpec" data-name="findTypeSpec">
               <h3>
                  findTypeSpec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findTypeSpec" class="anchor" title="Link to findTypeSpec">#</a>
               </h3>
               
               <p>findTypeSpec returns the ast.TypeSpec within the declaration that defines the symbol.
The name must match exactly.</p>
               
               <pre><code class="language-go">func (pkg *Package) findTypeSpec(decl *ast.GenDecl, symbol string) *ast.TypeSpec</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findTypes" data-name="findTypes">
               <h3>
                  findTypes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findTypes" class="anchor" title="Link to findTypes">#</a>
               </h3>
               
               <p>findTypes finds the doc.Types that describes the symbol.
If symbol is empty, it finds all exported types.</p>
               
               <pre><code class="language-go">func (pkg *Package) findTypes(symbol string) (types []*doc.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findValues" data-name="findValues">
               <h3>
                  findValues 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findValues" class="anchor" title="Link to findValues">#</a>
               </h3>
               
               <p>findValues finds the doc.Values that describe the symbol.</p>
               
               <pre><code class="language-go">func (pkg *Package) findValues(symbol string, docValues []*doc.Value) (values []*doc.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flush" data-name="flush">
               <h3>
                  flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flush" class="anchor" title="Link to flush">#</a>
               </h3>
               
               <pre><code class="language-go">func (pkg *Package) flush()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formatTypeParams" data-name="formatTypeParams">
               <h3>
                  formatTypeParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#formatTypeParams" class="anchor" title="Link to formatTypeParams">#</a>
               </h3>
               
               <pre><code class="language-go">func (pkg *Package) formatTypeParams(list *ast.FieldList, depth int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcSummary" data-name="funcSummary">
               <h3>
                  funcSummary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcSummary" class="anchor" title="Link to funcSummary">#</a>
               </h3>
               
               <p>funcSummary prints a one-line summary for each function. Constructors
are printed by typeSummary, below, and so can be suppressed here.</p>
               
               <pre><code class="language-go">func (pkg *Package) funcSummary(funcs []*doc.Func, showConstructors bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcsDoc" data-name="funcsDoc">
               <h3>
                  funcsDoc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcsDoc" class="anchor" title="Link to funcsDoc">#</a>
               </h3>
               
               <p>funcsDoc prints all func documentation, if any, including a header.</p>
               
               <pre><code class="language-go">func (pkg *Package) funcsDoc()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getMainModuleAnd114" data-name="getMainModuleAnd114">
               <h3>
                  getMainModuleAnd114 
                  <span class="badge">function</span>
                  
                  <a href="#getMainModuleAnd114" class="anchor" title="Link to getMainModuleAnd114">#</a>
               </h3>
               
               <p>getMainModuleAnd114 gets the main module's information and whether the
go command in use is 1.14+. This is the information needed to figure out
if vendoring should be enabled.</p>
               
               <pre><code class="language-go">func getMainModuleAnd114() (*moduleJSON, bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goCmd" data-name="goCmd">
               <h3>
                  goCmd 
                  <span class="badge">function</span>
                  
                  <a href="#goCmd" class="anchor" title="Link to goCmd">#</a>
               </h3>
               
               <p>goCmd returns the "go" command path corresponding to buildCtx.GOROOT.</p>
               
               <pre><code class="language-go">func goCmd() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="importDir" data-name="importDir">
               <h3>
                  importDir 
                  <span class="badge">function</span>
                  
                  <a href="#importDir" class="anchor" title="Link to importDir">#</a>
               </h3>
               
               <p>importDir is just an error-catching wrapper for build.ImportDir.</p>
               
               <pre><code class="language-go">func importDir(dir string) *build.Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDotSlash" data-name="isDotSlash">
               <h3>
                  isDotSlash 
                  <span class="badge">function</span>
                  
                  <a href="#isDotSlash" class="anchor" title="Link to isDotSlash">#</a>
               </h3>
               
               <p>isDotSlash reports whether the path begins with a reference
to the local . or .. directory.</p>
               
               <pre><code class="language-go">func isDotSlash(arg string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isExported" data-name="isExported">
               <h3>
                  isExported 
                  <span class="badge">function</span>
                  
                  <a href="#isExported" class="anchor" title="Link to isExported">#</a>
               </h3>
               
               <p>isExported reports whether the name is an exported identifier.
If the unexported flag (-u) is true, isExported returns true because
it means that we treat the name as if it is exported.</p>
               
               <pre><code class="language-go">func isExported(name string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="joinStrings" data-name="joinStrings">
               <h3>
                  joinStrings 
                  <span class="badge">function</span>
                  
                  <a href="#joinStrings" class="anchor" title="Link to joinStrings">#</a>
               </h3>
               
               <p>joinStrings formats the input as a comma-separated list,
but truncates the list at some reasonable length if necessary.</p>
               
               <pre><code class="language-go">func joinStrings(ss []string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="main" data-name="main">
               <h3>
                  main 
                  <span class="badge">function</span>
                  
                  <a href="#main" class="anchor" title="Link to main">#</a>
               </h3>
               
               <pre><code class="language-go">func main()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge">function</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <p>match reports whether the user's symbol matches the program's.
A lower-case character in the user's string matches either case in the program's.
The program string must be exported.</p>
               
               <pre><code class="language-go">func match(user string, program string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newlines" data-name="newlines">
               <h3>
                  newlines 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newlines" class="anchor" title="Link to newlines">#</a>
               </h3>
               
               <p>newlines guarantees there are n newlines at the end of the buffer.</p>
               
               <pre><code class="language-go">func (pkg *Package) newlines(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="oneLineField" data-name="oneLineField">
               <h3>
                  oneLineField 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#oneLineField" class="anchor" title="Link to oneLineField">#</a>
               </h3>
               
               <p>oneLineField returns a one-line summary of the field.</p>
               
               <pre><code class="language-go">func (pkg *Package) oneLineField(field *ast.Field, depth int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="oneLineNode" data-name="oneLineNode">
               <h3>
                  oneLineNode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#oneLineNode" class="anchor" title="Link to oneLineNode">#</a>
               </h3>
               
               <p>oneLineNode returns a one-line summary of the given input node.</p>
               
               <pre><code class="language-go">func (pkg *Package) oneLineNode(node ast.Node) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="oneLineNodeDepth" data-name="oneLineNodeDepth">
               <h3>
                  oneLineNodeDepth 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#oneLineNodeDepth" class="anchor" title="Link to oneLineNodeDepth">#</a>
               </h3>
               
               <p>oneLineNodeDepth returns a one-line summary of the given input node.
The depth specifies the maximum depth when traversing the AST.</p>
               
               <pre><code class="language-go">func (pkg *Package) oneLineNodeDepth(node ast.Node, depth int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="packageClause" data-name="packageClause">
               <h3>
                  packageClause 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#packageClause" class="anchor" title="Link to packageClause">#</a>
               </h3>
               
               <p>packageClause prints the package clause.</p>
               
               <pre><code class="language-go">func (pkg *Package) packageClause()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="packageClause" data-name="packageClause">
               <h3>
                  packageClause 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#packageClause" class="anchor" title="Link to packageClause">#</a>
               </h3>
               
               <pre><code class="language-go">func (pb *pkgBuffer) packageClause()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="packageDoc" data-name="packageDoc">
               <h3>
                  packageDoc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#packageDoc" class="anchor" title="Link to packageDoc">#</a>
               </h3>
               
               <p>packageDoc prints the docs for the package.</p>
               
               <pre><code class="language-go">func (pkg *Package) packageDoc()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseArgs" data-name="parseArgs">
               <h3>
                  parseArgs 
                  <span class="badge">function</span>
                  
                  <a href="#parseArgs" class="anchor" title="Link to parseArgs">#</a>
               </h3>
               
               <p>parseArgs analyzes the arguments (if any) and returns the package
it represents, the part of the argument the user used to identify
the path (or "" if it's the current package) and the symbol
(possibly with a .method) within that package.
parseSymbol is used to analyze the symbol itself.
The boolean final argument reports whether it is possible that
there may be more directories worth looking at. It will only
be true if the package path is a partial match for some directory
and there may be more matches. For example, if the argument
is rand.Float64, we must scan both crypto/rand and math/rand
to find the symbol, and the first call will return crypto/rand, true.</p>
               
               <pre><code class="language-go">func parseArgs(args []string) (pkg *build.Package, path string, symbol string, more bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsePackage" data-name="parsePackage">
               <h3>
                  parsePackage 
                  <span class="badge">function</span>
                  
                  <a href="#parsePackage" class="anchor" title="Link to parsePackage">#</a>
               </h3>
               
               <p>parsePackage turns the build package we found into a parsed package
we can then use to generate documentation.</p>
               
               <pre><code class="language-go">func parsePackage(writer io.Writer, pkg *build.Package, userPath string) *Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseSymbol" data-name="parseSymbol">
               <h3>
                  parseSymbol 
                  <span class="badge">function</span>
                  
                  <a href="#parseSymbol" class="anchor" title="Link to parseSymbol">#</a>
               </h3>
               
               <p>parseSymbol breaks str apart into a symbol and method.
Both may be missing or the method may be missing.
If present, each must be a valid Go identifier.</p>
               
               <pre><code class="language-go">func parseSymbol(str string) (symbol string, method string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="prettyPath" data-name="prettyPath">
               <h3>
                  prettyPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#prettyPath" class="anchor" title="Link to prettyPath">#</a>
               </h3>
               
               <p>prettyPath returns a version of the package path that is suitable for an
error message. It obeys the import comment if present. Also, since
pkg.build.ImportPath is sometimes the unhelpful "" or ".", it looks for a
directory name in GOROOT or GOPATH if that happens.</p>
               
               <pre><code class="language-go">func (pkg *Package) prettyPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printFieldDoc" data-name="printFieldDoc">
               <h3>
                  printFieldDoc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#printFieldDoc" class="anchor" title="Link to printFieldDoc">#</a>
               </h3>
               
               <p>printFieldDoc prints the docs for matches of symbol.fieldName.
It reports whether it found any field.
Both symbol and fieldName must be non-empty or it returns false.</p>
               
               <pre><code class="language-go">func (pkg *Package) printFieldDoc(symbol string, fieldName string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printHeader" data-name="printHeader">
               <h3>
                  printHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#printHeader" class="anchor" title="Link to printHeader">#</a>
               </h3>
               
               <p>printHeader prints a header for the section named s, adding a blank line on each side.</p>
               
               <pre><code class="language-go">func (pkg *Package) printHeader(s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printMethodDoc" data-name="printMethodDoc">
               <h3>
                  printMethodDoc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#printMethodDoc" class="anchor" title="Link to printMethodDoc">#</a>
               </h3>
               
               <p>printMethodDoc prints the docs for matches of symbol.method.
If symbol is empty, it prints all methods for any concrete type
that match the name. It reports whether it found any methods.</p>
               
               <pre><code class="language-go">func (pkg *Package) printMethodDoc(symbol string, method string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="simpleFold" data-name="simpleFold">
               <h3>
                  simpleFold 
                  <span class="badge">function</span>
                  
                  <a href="#simpleFold" class="anchor" title="Link to simpleFold">#</a>
               </h3>
               
               <p>simpleFold returns the minimum rune equivalent to r
under Unicode-defined simple case folding.</p>
               
               <pre><code class="language-go">func simpleFold(r rune) rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitGopath" data-name="splitGopath">
               <h3>
                  splitGopath 
                  <span class="badge">function</span>
                  
                  <a href="#splitGopath" class="anchor" title="Link to splitGopath">#</a>
               </h3>
               
               <p>splitGopath splits $GOPATH into a list of roots.</p>
               
               <pre><code class="language-go">func splitGopath() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="symbolDoc" data-name="symbolDoc">
               <h3>
                  symbolDoc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#symbolDoc" class="anchor" title="Link to symbolDoc">#</a>
               </h3>
               
               <p>symbolDoc prints the docs for symbol. There may be multiple matches.
If symbol matches a type, output includes its methods factories and associated constants.
If there is no top-level symbol, symbolDoc looks for methods that match.</p>
               
               <pre><code class="language-go">func (pkg *Package) symbolDoc(symbol string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trim" data-name="trim">
               <h3>
                  trim 
                  <span class="badge">function</span>
                  
                  <a href="#trim" class="anchor" title="Link to trim">#</a>
               </h3>
               
               <p>trim trims the directory prefix from the path, paying attention
to the path separator. If they are the same string or the prefix
is not present the original is returned. The boolean reports whether
the prefix is present. That path and prefix have slashes for separators.</p>
               
               <pre><code class="language-go">func trim(path string, prefix string) (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimUnexportedElems" data-name="trimUnexportedElems">
               <h3>
                  trimUnexportedElems 
                  <span class="badge">function</span>
                  
                  <a href="#trimUnexportedElems" class="anchor" title="Link to trimUnexportedElems">#</a>
               </h3>
               
               <p>trimUnexportedElems modifies spec in place to elide unexported fields from
structs and methods from interfaces (unless the unexported flag is set or we
are asked to show the original source).</p>
               
               <pre><code class="language-go">func trimUnexportedElems(spec *ast.TypeSpec)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimUnexportedFields" data-name="trimUnexportedFields">
               <h3>
                  trimUnexportedFields 
                  <span class="badge">function</span>
                  
                  <a href="#trimUnexportedFields" class="anchor" title="Link to trimUnexportedFields">#</a>
               </h3>
               
               <p>trimUnexportedFields returns the field list trimmed of unexported fields.</p>
               
               <pre><code class="language-go">func trimUnexportedFields(fields *ast.FieldList, isInterface bool) *ast.FieldList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeDoc" data-name="typeDoc">
               <h3>
                  typeDoc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeDoc" class="anchor" title="Link to typeDoc">#</a>
               </h3>
               
               <p>typeDoc prints the docs for a type, including constructors and other items
related to it.</p>
               
               <pre><code class="language-go">func (pkg *Package) typeDoc(typ *doc.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeSummary" data-name="typeSummary">
               <h3>
                  typeSummary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeSummary" class="anchor" title="Link to typeSummary">#</a>
               </h3>
               
               <p>typeSummary prints a one-line summary for each type, followed by its constructors.</p>
               
               <pre><code class="language-go">func (pkg *Package) typeSummary()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typesDoc" data-name="typesDoc">
               <h3>
                  typesDoc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typesDoc" class="anchor" title="Link to typesDoc">#</a>
               </h3>
               
               <p>funcsDoc prints all type documentation, if any, including a header.</p>
               
               <pre><code class="language-go">func (pkg *Package) typesDoc()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="usage" data-name="usage">
               <h3>
                  usage 
                  <span class="badge">function</span>
                  
                  <a href="#usage" class="anchor" title="Link to usage">#</a>
               </h3>
               
               <p>usage is a replacement usage function for the flags package.</p>
               
               <pre><code class="language-go">func usage()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="valueDoc" data-name="valueDoc">
               <h3>
                  valueDoc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#valueDoc" class="anchor" title="Link to valueDoc">#</a>
               </h3>
               
               <p>valueDoc prints the docs for a constant or variable. The printed map records
which values have been printed already to avoid duplication. Otherwise, a
declaration like:
const ( c = 1; C = 2 )
… could be printed twice if the -u flag is set, as it matches twice.</p>
               
               <pre><code class="language-go">func (pkg *Package) valueDoc(value *doc.Value, printed map[*ast.GenDecl]bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="valueSummary" data-name="valueSummary">
               <h3>
                  valueSummary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#valueSummary" class="anchor" title="Link to valueSummary">#</a>
               </h3>
               
               <p>valueSummary prints a one-line summary for each set of values and constants.
If all the types in a constant or variable declaration belong to the same
type they can be printed by typeSummary, and so can be suppressed here.</p>
               
               <pre><code class="language-go">func (pkg *Package) valueSummary(values []*doc.Value, showGrouped bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="varsDoc" data-name="varsDoc">
               <h3>
                  varsDoc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#varsDoc" class="anchor" title="Link to varsDoc">#</a>
               </h3>
               
               <p>varsDoc prints all var documentation, if any, including a header.
Printed is the valueDoc registry.</p>
               
               <pre><code class="language-go">func (pkg *Package) varsDoc(printed map[*ast.GenDecl]bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="vendorEnabled" data-name="vendorEnabled">
               <h3>
                  vendorEnabled 
                  <span class="badge">function</span>
                  
                  <a href="#vendorEnabled" class="anchor" title="Link to vendorEnabled">#</a>
               </h3>
               
               <p>vendorEnabled indicates if vendoring is enabled.
Inspired by setDefaultBuildMod in modload/init.go</p>
               
               <pre><code class="language-go">func vendorEnabled() (*moduleJSON, bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walk" data-name="walk">
               <h3>
                  walk 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#walk" class="anchor" title="Link to walk">#</a>
               </h3>
               
               <p>walk walks the trees in GOROOT and GOPATH.</p>
               
               <pre><code class="language-go">func (d *Dirs) walk(roots []Dir)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();

               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);

               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;

               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               // Apply Prism highlighting again
               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>