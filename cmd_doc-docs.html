<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - main</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>main</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bytes"
"flag"
"fmt"
"go/build"
"go/token"
"io"
"log"
"os"
"path"
"path/filepath"
"strings"
"cmd/internal/telemetry/counter"
"bufio"
"bytes"
"fmt"
"go/ast"
"go/build"
"go/doc"
"go/format"
"go/parser"
"go/printer"
"go/token"
"io"
"io/fs"
"log"
"path/filepath"
"strings"
"unicode"
"unicode/utf8"
"bytes"
"fmt"
"log"
"os"
"os/exec"
"path/filepath"
"regexp"
"strings"
"sync"
"golang.org/x/mod/semver"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="buildCtx">
               <h3>
                  buildCtx 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var buildCtx = build.Default</code></pre>
            </article>
            
            <article class="global" data-name="chdir">
               <h3>
                  chdir 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var chdir string</code></pre>
            </article>
            
            <article class="global" data-name="codeRootsCache">
               <h3>
                  codeRootsCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var codeRootsCache struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="dirs">
               <h3>
                  dirs 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var dirs Dirs</code></pre>
            </article>
            
            <article class="global" data-name="dotPaths">
               <h3>
                  dotPaths 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>dotPaths lists all the dotted paths legal on Unix-like and
Windows-like file systems. We check them all, as the chance
of error is minute and even on Windows people will use ./
sometimes.</p>
               
               <pre><code>var dotPaths = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="indent">
               <h3>
                  indent 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const indent = "    "</code></pre>
            </article>
            
            <article class="global" data-name="matchCase">
               <h3>
                  matchCase 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var matchCase bool</code></pre>
            </article>
            
            <article class="global" data-name="modFlagRegexp">
               <h3>
                  modFlagRegexp 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var modFlagRegexp = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="newlineBytes">
               <h3>
                  newlineBytes 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var newlineBytes = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="punchedCardWidth">
               <h3>
                  punchedCardWidth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const punchedCardWidth = 80</code></pre>
            </article>
            
            <article class="global" data-name="short">
               <h3>
                  short 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var short bool</code></pre>
            </article>
            
            <article class="global" data-name="showAll">
               <h3>
                  showAll 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var showAll bool</code></pre>
            </article>
            
            <article class="global" data-name="showCmd">
               <h3>
                  showCmd 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var showCmd bool</code></pre>
            </article>
            
            <article class="global" data-name="showSrc">
               <h3>
                  showSrc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var showSrc bool</code></pre>
            </article>
            
            <article class="global" data-name="testGOPATH">
               <h3>
                  testGOPATH 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var testGOPATH = false</code></pre>
            </article>
            
            <article class="global" data-name="unexported">
               <h3>
                  unexported 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var unexported bool</code></pre>
            </article>
            
            <article class="global" data-name="usingModules">
               <h3>
                  usingModules 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var usingModules bool</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="PackageError">
               <h3>
                  PackageError
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type PackageError string</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Dir">
               <h3>
                  Dir
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Dir describes a directory holding code by specifying
the expected import path and the file system directory.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Dir struct {
importPath string
dir string
inModule bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="Dirs">
               <h3>
                  Dirs
                  <span class="badge">struct</span>
               </h3>
               
               <p>Dirs is a structure for scanning the directory tree.
Its Next method returns the next Go source directory it finds.
Although it can be used to scan the tree multiple times, it
only walks the tree once, caching the data it finds.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Dirs struct {
scan chan Dir
hist []Dir
offset int
}</code></pre>
            </article>
            
            <article class="struct" data-name="Package">
               <h3>
                  Package
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Package struct {
writer io.Writer
name string
userPath string
pkg *ast.Package
file *ast.File
doc *doc.Package
build *build.Package
typedValue map[*doc.Value]bool
constructor map[*doc.Func]bool
fs *token.FileSet
buf pkgBuffer
}</code></pre>
            </article>
            
            <article class="struct" data-name="moduleJSON">
               <h3>
                  moduleJSON
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type moduleJSON struct {
Path string
Dir string
GoVersion string
}</code></pre>
            </article>
            
            <article class="struct" data-name="pkgBuffer">
               <h3>
                  pkgBuffer
                  <span class="badge">struct</span>
               </h3>
               
               <p>pkgBuffer is a wrapper for bytes.Buffer that prints a package clause the
first time Write is called.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pkgBuffer struct {
pkg *Package
printed bool
bytes.Buffer
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p PackageError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Fatalf">
               <h3>
                  Fatalf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>pkg.Fatalf is like log.Fatalf, but panics so it can be recovered in the
main do function, so it doesn't cause an exit. Allows testing to work
without running a subprocess. The log prefix will be added when
logged in main; it is not added here.</p>
               
               <pre><code>func (pkg *Package) Fatalf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Next returns the next directory in the scan. The boolean
is false when the scan is done.</p>
               
               <pre><code>func (d *Dirs) Next() (Dir, bool)</code></pre>
            </article>
            
            <article class="function" data-name="Printf">
               <h3>
                  Printf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pkg *Package) Printf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reset puts the scan back at the beginning.</p>
               
               <pre><code>func (d *Dirs) Reset()</code></pre>
            </article>
            
            <article class="function" data-name="ToText">
               <h3>
                  ToText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pkg *Package) ToText(w io.Writer, text string, prefix string, codePrefix string)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pb *pkgBuffer) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="bfsWalkRoot">
               <h3>
                  bfsWalkRoot 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>bfsWalkRoot walks a single directory hierarchy in breadth-first lexical order.
Each Go source directory it finds is delivered on d.scan.</p>
               
               <pre><code>func (d *Dirs) bfsWalkRoot(root Dir)</code></pre>
            </article>
            
            <article class="function" data-name="bugs">
               <h3>
                  bugs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>bugs prints the BUGS information for the package.
TODO: Provide access to TODOs and NOTEs as well (very noisy so off by default)?</p>
               
               <pre><code>func (pkg *Package) bugs()</code></pre>
            </article>
            
            <article class="function" data-name="codeRoots">
               <h3>
                  codeRoots 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>codeRoots returns the code roots to search for packages.
In GOPATH mode this is GOROOT/src and GOPATH/src, with empty import paths.
In module mode, this is each module root, with an import path set to its module path.</p>
               
               <pre><code>func codeRoots() []Dir</code></pre>
            </article>
            
            <article class="function" data-name="constsDoc">
               <h3>
                  constsDoc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>constsDoc prints all const documentation, if any, including a header.
The one argument is the valueDoc registry.</p>
               
               <pre><code>func (pkg *Package) constsDoc(printed map[*ast.GenDecl]bool)</code></pre>
            </article>
            
            <article class="function" data-name="dirsInit">
               <h3>
                  dirsInit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dirsInit starts the scanning of package directories in GOROOT and GOPATH. Any
extra paths passed to it are included in the channel.</p>
               
               <pre><code>func dirsInit(extra ...Dir)</code></pre>
            </article>
            
            <article class="function" data-name="do">
               <h3>
                  do 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>do is the workhorse, broken out of main to make testing easier.</p>
               
               <pre><code>func do(writer io.Writer, flagSet *flag.FlagSet, args []string) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="emit">
               <h3>
                  emit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>emit prints the node. If showSrc is true, it ignores the provided comment,
assuming the comment is in the node itself. Otherwise, the go/doc package
clears the stuff we don't want to print anyway. It's a bit of a magic trick.</p>
               
               <pre><code>func (pkg *Package) emit(comment string, node ast.Node)</code></pre>
            </article>
            
            <article class="function" data-name="failMessage">
               <h3>
                  failMessage 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>failMessage creates a nicely formatted error message when there is no result to show.</p>
               
               <pre><code>func failMessage(paths []string, symbol string, method string) error</code></pre>
            </article>
            
            <article class="function" data-name="findCodeRoots">
               <h3>
                  findCodeRoots 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func findCodeRoots() []Dir</code></pre>
            </article>
            
            <article class="function" data-name="findFuncs">
               <h3>
                  findFuncs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>findFuncs finds the doc.Funcs that describes the symbol.</p>
               
               <pre><code>func (pkg *Package) findFuncs(symbol string) (funcs []*doc.Func)</code></pre>
            </article>
            
            <article class="function" data-name="findNextPackage">
               <h3>
                  findNextPackage 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>findNextPackage returns the next full file name path that matches the
(perhaps partial) package path pkg. The boolean reports if any match was found.</p>
               
               <pre><code>func findNextPackage(pkg string) (string, bool)</code></pre>
            </article>
            
            <article class="function" data-name="findTypeSpec">
               <h3>
                  findTypeSpec 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>findTypeSpec returns the ast.TypeSpec within the declaration that defines the symbol.
The name must match exactly.</p>
               
               <pre><code>func (pkg *Package) findTypeSpec(decl *ast.GenDecl, symbol string) *ast.TypeSpec</code></pre>
            </article>
            
            <article class="function" data-name="findTypes">
               <h3>
                  findTypes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>findTypes finds the doc.Types that describes the symbol.
If symbol is empty, it finds all exported types.</p>
               
               <pre><code>func (pkg *Package) findTypes(symbol string) (types []*doc.Type)</code></pre>
            </article>
            
            <article class="function" data-name="findValues">
               <h3>
                  findValues 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>findValues finds the doc.Values that describe the symbol.</p>
               
               <pre><code>func (pkg *Package) findValues(symbol string, docValues []*doc.Value) (values []*doc.Value)</code></pre>
            </article>
            
            <article class="function" data-name="flush">
               <h3>
                  flush 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pkg *Package) flush()</code></pre>
            </article>
            
            <article class="function" data-name="formatTypeParams">
               <h3>
                  formatTypeParams 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pkg *Package) formatTypeParams(list *ast.FieldList, depth int) string</code></pre>
            </article>
            
            <article class="function" data-name="funcSummary">
               <h3>
                  funcSummary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>funcSummary prints a one-line summary for each function. Constructors
are printed by typeSummary, below, and so can be suppressed here.</p>
               
               <pre><code>func (pkg *Package) funcSummary(funcs []*doc.Func, showConstructors bool)</code></pre>
            </article>
            
            <article class="function" data-name="funcsDoc">
               <h3>
                  funcsDoc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>funcsDoc prints all func documentation, if any, including a header.</p>
               
               <pre><code>func (pkg *Package) funcsDoc()</code></pre>
            </article>
            
            <article class="function" data-name="getMainModuleAnd114">
               <h3>
                  getMainModuleAnd114 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>getMainModuleAnd114 gets the main module's information and whether the
go command in use is 1.14+. This is the information needed to figure out
if vendoring should be enabled.</p>
               
               <pre><code>func getMainModuleAnd114() (*moduleJSON, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="goCmd">
               <h3>
                  goCmd 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>goCmd returns the "go" command path corresponding to buildCtx.GOROOT.</p>
               
               <pre><code>func goCmd() string</code></pre>
            </article>
            
            <article class="function" data-name="importDir">
               <h3>
                  importDir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>importDir is just an error-catching wrapper for build.ImportDir.</p>
               
               <pre><code>func importDir(dir string) *build.Package</code></pre>
            </article>
            
            <article class="function" data-name="isDotSlash">
               <h3>
                  isDotSlash 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isDotSlash reports whether the path begins with a reference
to the local . or .. directory.</p>
               
               <pre><code>func isDotSlash(arg string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isExported">
               <h3>
                  isExported 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isExported reports whether the name is an exported identifier.
If the unexported flag (-u) is true, isExported returns true because
it means that we treat the name as if it is exported.</p>
               
               <pre><code>func isExported(name string) bool</code></pre>
            </article>
            
            <article class="function" data-name="joinStrings">
               <h3>
                  joinStrings 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>joinStrings formats the input as a comma-separated list,
but truncates the list at some reasonable length if necessary.</p>
               
               <pre><code>func joinStrings(ss []string) string</code></pre>
            </article>
            
            <article class="function" data-name="main">
               <h3>
                  main 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func main()</code></pre>
            </article>
            
            <article class="function" data-name="match">
               <h3>
                  match 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>match reports whether the user's symbol matches the program's.
A lower-case character in the user's string matches either case in the program's.
The program string must be exported.</p>
               
               <pre><code>func match(user string, program string) bool</code></pre>
            </article>
            
            <article class="function" data-name="newlines">
               <h3>
                  newlines 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newlines guarantees there are n newlines at the end of the buffer.</p>
               
               <pre><code>func (pkg *Package) newlines(n int)</code></pre>
            </article>
            
            <article class="function" data-name="oneLineField">
               <h3>
                  oneLineField 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>oneLineField returns a one-line summary of the field.</p>
               
               <pre><code>func (pkg *Package) oneLineField(field *ast.Field, depth int) string</code></pre>
            </article>
            
            <article class="function" data-name="oneLineNode">
               <h3>
                  oneLineNode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>oneLineNode returns a one-line summary of the given input node.</p>
               
               <pre><code>func (pkg *Package) oneLineNode(node ast.Node) string</code></pre>
            </article>
            
            <article class="function" data-name="oneLineNodeDepth">
               <h3>
                  oneLineNodeDepth 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>oneLineNodeDepth returns a one-line summary of the given input node.
The depth specifies the maximum depth when traversing the AST.</p>
               
               <pre><code>func (pkg *Package) oneLineNodeDepth(node ast.Node, depth int) string</code></pre>
            </article>
            
            <article class="function" data-name="packageClause">
               <h3>
                  packageClause 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>packageClause prints the package clause.</p>
               
               <pre><code>func (pkg *Package) packageClause()</code></pre>
            </article>
            
            <article class="function" data-name="packageClause">
               <h3>
                  packageClause 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pb *pkgBuffer) packageClause()</code></pre>
            </article>
            
            <article class="function" data-name="packageDoc">
               <h3>
                  packageDoc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>packageDoc prints the docs for the package.</p>
               
               <pre><code>func (pkg *Package) packageDoc()</code></pre>
            </article>
            
            <article class="function" data-name="parseArgs">
               <h3>
                  parseArgs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseArgs analyzes the arguments (if any) and returns the package
it represents, the part of the argument the user used to identify
the path (or "" if it's the current package) and the symbol
(possibly with a .method) within that package.
parseSymbol is used to analyze the symbol itself.
The boolean final argument reports whether it is possible that
there may be more directories worth looking at. It will only
be true if the package path is a partial match for some directory
and there may be more matches. For example, if the argument
is rand.Float64, we must scan both crypto/rand and math/rand
to find the symbol, and the first call will return crypto/rand, true.</p>
               
               <pre><code>func parseArgs(args []string) (pkg *build.Package, path string, symbol string, more bool)</code></pre>
            </article>
            
            <article class="function" data-name="parsePackage">
               <h3>
                  parsePackage 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parsePackage turns the build package we found into a parsed package
we can then use to generate documentation.</p>
               
               <pre><code>func parsePackage(writer io.Writer, pkg *build.Package, userPath string) *Package</code></pre>
            </article>
            
            <article class="function" data-name="parseSymbol">
               <h3>
                  parseSymbol 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseSymbol breaks str apart into a symbol and method.
Both may be missing or the method may be missing.
If present, each must be a valid Go identifier.</p>
               
               <pre><code>func parseSymbol(str string) (symbol string, method string)</code></pre>
            </article>
            
            <article class="function" data-name="prettyPath">
               <h3>
                  prettyPath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>prettyPath returns a version of the package path that is suitable for an
error message. It obeys the import comment if present. Also, since
pkg.build.ImportPath is sometimes the unhelpful "" or ".", it looks for a
directory name in GOROOT or GOPATH if that happens.</p>
               
               <pre><code>func (pkg *Package) prettyPath() string</code></pre>
            </article>
            
            <article class="function" data-name="printFieldDoc">
               <h3>
                  printFieldDoc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>printFieldDoc prints the docs for matches of symbol.fieldName.
It reports whether it found any field.
Both symbol and fieldName must be non-empty or it returns false.</p>
               
               <pre><code>func (pkg *Package) printFieldDoc(symbol string, fieldName string) bool</code></pre>
            </article>
            
            <article class="function" data-name="printHeader">
               <h3>
                  printHeader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>printHeader prints a header for the section named s, adding a blank line on each side.</p>
               
               <pre><code>func (pkg *Package) printHeader(s string)</code></pre>
            </article>
            
            <article class="function" data-name="printMethodDoc">
               <h3>
                  printMethodDoc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>printMethodDoc prints the docs for matches of symbol.method.
If symbol is empty, it prints all methods for any concrete type
that match the name. It reports whether it found any methods.</p>
               
               <pre><code>func (pkg *Package) printMethodDoc(symbol string, method string) bool</code></pre>
            </article>
            
            <article class="function" data-name="simpleFold">
               <h3>
                  simpleFold 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>simpleFold returns the minimum rune equivalent to r
under Unicode-defined simple case folding.</p>
               
               <pre><code>func simpleFold(r rune) rune</code></pre>
            </article>
            
            <article class="function" data-name="splitGopath">
               <h3>
                  splitGopath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>splitGopath splits $GOPATH into a list of roots.</p>
               
               <pre><code>func splitGopath() []string</code></pre>
            </article>
            
            <article class="function" data-name="symbolDoc">
               <h3>
                  symbolDoc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>symbolDoc prints the docs for symbol. There may be multiple matches.
If symbol matches a type, output includes its methods factories and associated constants.
If there is no top-level symbol, symbolDoc looks for methods that match.</p>
               
               <pre><code>func (pkg *Package) symbolDoc(symbol string) bool</code></pre>
            </article>
            
            <article class="function" data-name="trim">
               <h3>
                  trim 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>trim trims the directory prefix from the path, paying attention
to the path separator. If they are the same string or the prefix
is not present the original is returned. The boolean reports whether
the prefix is present. That path and prefix have slashes for separators.</p>
               
               <pre><code>func trim(path string, prefix string) (string, bool)</code></pre>
            </article>
            
            <article class="function" data-name="trimUnexportedElems">
               <h3>
                  trimUnexportedElems 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>trimUnexportedElems modifies spec in place to elide unexported fields from
structs and methods from interfaces (unless the unexported flag is set or we
are asked to show the original source).</p>
               
               <pre><code>func trimUnexportedElems(spec *ast.TypeSpec)</code></pre>
            </article>
            
            <article class="function" data-name="trimUnexportedFields">
               <h3>
                  trimUnexportedFields 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>trimUnexportedFields returns the field list trimmed of unexported fields.</p>
               
               <pre><code>func trimUnexportedFields(fields *ast.FieldList, isInterface bool) *ast.FieldList</code></pre>
            </article>
            
            <article class="function" data-name="typeDoc">
               <h3>
                  typeDoc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>typeDoc prints the docs for a type, including constructors and other items
related to it.</p>
               
               <pre><code>func (pkg *Package) typeDoc(typ *doc.Type)</code></pre>
            </article>
            
            <article class="function" data-name="typeSummary">
               <h3>
                  typeSummary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>typeSummary prints a one-line summary for each type, followed by its constructors.</p>
               
               <pre><code>func (pkg *Package) typeSummary()</code></pre>
            </article>
            
            <article class="function" data-name="typesDoc">
               <h3>
                  typesDoc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>funcsDoc prints all type documentation, if any, including a header.</p>
               
               <pre><code>func (pkg *Package) typesDoc()</code></pre>
            </article>
            
            <article class="function" data-name="usage">
               <h3>
                  usage 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>usage is a replacement usage function for the flags package.</p>
               
               <pre><code>func usage()</code></pre>
            </article>
            
            <article class="function" data-name="valueDoc">
               <h3>
                  valueDoc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>valueDoc prints the docs for a constant or variable. The printed map records
which values have been printed already to avoid duplication. Otherwise, a
declaration like:
const ( c = 1; C = 2 )
… could be printed twice if the -u flag is set, as it matches twice.</p>
               
               <pre><code>func (pkg *Package) valueDoc(value *doc.Value, printed map[*ast.GenDecl]bool)</code></pre>
            </article>
            
            <article class="function" data-name="valueSummary">
               <h3>
                  valueSummary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>valueSummary prints a one-line summary for each set of values and constants.
If all the types in a constant or variable declaration belong to the same
type they can be printed by typeSummary, and so can be suppressed here.</p>
               
               <pre><code>func (pkg *Package) valueSummary(values []*doc.Value, showGrouped bool)</code></pre>
            </article>
            
            <article class="function" data-name="varsDoc">
               <h3>
                  varsDoc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>varsDoc prints all var documentation, if any, including a header.
Printed is the valueDoc registry.</p>
               
               <pre><code>func (pkg *Package) varsDoc(printed map[*ast.GenDecl]bool)</code></pre>
            </article>
            
            <article class="function" data-name="vendorEnabled">
               <h3>
                  vendorEnabled 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>vendorEnabled indicates if vendoring is enabled.
Inspired by setDefaultBuildMod in modload/init.go</p>
               
               <pre><code>func vendorEnabled() (*moduleJSON, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="walk">
               <h3>
                  walk 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>walk walks the trees in GOROOT and GOPATH.</p>
               
               <pre><code>func (d *Dirs) walk(roots []Dir)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
