<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - modget</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>modget</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"fmt"
"path/filepath"
"regexp"
"strings"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/gover"
"cmd/go/internal/modload"
"cmd/go/internal/search"
"cmd/go/internal/str"
"cmd/internal/pkgpattern"
"golang.org/x/mod/module"
"context"
"errors"
"fmt"
"os"
"path/filepath"
"runtime"
"sort"
"strconv"
"strings"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/gover"
"cmd/go/internal/imports"
"cmd/go/internal/modfetch"
"cmd/go/internal/modload"
"cmd/go/internal/search"
"cmd/go/internal/toolchain"
"cmd/go/internal/work"
"cmd/internal/par"
"golang.org/x/mod/modfile"
"golang.org/x/mod/module"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="CmdGet" data-name="CmdGet">
               <h3>
                  CmdGet 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#CmdGet" class="anchor" title="Link to CmdGet">#</a>
               </h3>
               
               <pre><code class="language-go">var CmdGet = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="HelpVCS" data-name="HelpVCS">
               <h3>
                  HelpVCS 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#HelpVCS" class="anchor" title="Link to HelpVCS">#</a>
               </h3>
               
               <pre><code class="language-go">var HelpVCS = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errVersionChange" data-name="errVersionChange">
               <h3>
                  errVersionChange 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errVersionChange" class="anchor" title="Link to errVersionChange">#</a>
               </h3>
               
               <p>errVersionChange is a sentinel error indicating that a module's version needs
to be updated before its dependencies can be loaded.</p>
               
               <pre><code class="language-go">var errVersionChange = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="getD" data-name="getD">
               <h3>
                  getD 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#getD" class="anchor" title="Link to getD">#</a>
               </h3>
               
               <pre><code class="language-go">var getD dFlag</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="getF" data-name="getF">
               <h3>
                  getF 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#getF" class="anchor" title="Link to getF">#</a>
               </h3>
               
               <pre><code class="language-go">var getF = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="getFix" data-name="getFix">
               <h3>
                  getFix 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#getFix" class="anchor" title="Link to getFix">#</a>
               </h3>
               
               <pre><code class="language-go">var getFix = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="getInsecure" data-name="getInsecure">
               <h3>
                  getInsecure 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#getInsecure" class="anchor" title="Link to getInsecure">#</a>
               </h3>
               
               <pre><code class="language-go">var getInsecure = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="getM" data-name="getM">
               <h3>
                  getM 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#getM" class="anchor" title="Link to getM">#</a>
               </h3>
               
               <pre><code class="language-go">var getM = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="getT" data-name="getT">
               <h3>
                  getT 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#getT" class="anchor" title="Link to getT">#</a>
               </h3>
               
               <pre><code class="language-go">var getT = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="getTool" data-name="getTool">
               <h3>
                  getTool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#getTool" class="anchor" title="Link to getTool">#</a>
               </h3>
               
               <pre><code class="language-go">var getTool = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="getU" data-name="getU">
               <h3>
                  getU 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#getU" class="anchor" title="Link to getU">#</a>
               </h3>
               
               <pre><code class="language-go">var getU upgradeFlag</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="conflictError" data-name="conflictError">
               <h3>
                  conflictError
                  <span class="badge">struct</span>
                  <a href="#conflictError" class="anchor" title="Link to conflictError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type conflictError struct {
mPath string
proposed versionReason
conflict versionReason
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dFlag" data-name="dFlag">
               <h3>
                  dFlag
                  <span class="badge">struct</span>
                  <a href="#dFlag" class="anchor" title="Link to dFlag">#</a>
               </h3>
               
               <p>dFlag is a custom flag.Value for the deprecated -d flag
which will be used to provide warnings or errors if -d
is provided.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type dFlag struct {
value bool
set bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="matchInModuleKey" data-name="matchInModuleKey">
               <h3>
                  matchInModuleKey
                  <span class="badge">struct</span>
                  <a href="#matchInModuleKey" class="anchor" title="Link to matchInModuleKey">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type matchInModuleKey struct {
pattern string
m module.Version
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pathSet" data-name="pathSet">
               <h3>
                  pathSet
                  <span class="badge">struct</span>
                  <a href="#pathSet" class="anchor" title="Link to pathSet">#</a>
               </h3>
               
               <p>A pathSet describes the possible options for resolving a specific path
to a package and/or module.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type pathSet struct {
path string
pkgMods []module.Version
mod module.Version
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="query" data-name="query">
               <h3>
                  query
                  <span class="badge">struct</span>
                  <a href="#query" class="anchor" title="Link to query">#</a>
               </h3>
               
               <p>A query describes a command-line argument and the modules and/or packages
to which that argument may resolve..</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type query struct {
raw string
rawVersion string
pattern string
patternIsLocal bool
version string
matchWildcard func(path string) bool
canMatchWildcardInModule func(mPath string) bool
conflict *query
candidates []pathSet
candidatesMu sync.Mutex
pathSeen sync.Map
resolved []module.Version
matchesPackages bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="resolver" data-name="resolver">
               <h3>
                  resolver
                  <span class="badge">struct</span>
                  <a href="#resolver" class="anchor" title="Link to resolver">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type resolver struct {
localQueries []*query
pathQueries []*query
wildcardQueries []*query
patternAllQueries []*query
toolQueries []*query
nonesByPath map[string]*query
wildcardNones []*query
resolvedVersion map[string]versionReason
buildList []module.Version
buildListVersion map[string]string
initialVersion map[string]string
missing []pathSet
work *par.Queue
matchInModuleCache *ast.IndexListExpr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="upgradeFlag" data-name="upgradeFlag">
               <h3>
                  upgradeFlag
                  <span class="badge">struct</span>
                  <a href="#upgradeFlag" class="anchor" title="Link to upgradeFlag">#</a>
               </h3>
               
               <p>upgradeFlag is a custom flag.Value for -u.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type upgradeFlag struct {
rawVersion string
version string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="versionReason" data-name="versionReason">
               <h3>
                  versionReason
                  <span class="badge">struct</span>
                  <a href="#versionReason" class="anchor" title="Link to versionReason">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type versionReason struct {
version string
reason *query
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *conflictError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsBoolFlag" data-name="IsBoolFlag">
               <h3>
                  IsBoolFlag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsBoolFlag" class="anchor" title="Link to IsBoolFlag">#</a>
               </h3>
               
               <pre><code class="language-go">func (*upgradeFlag) IsBoolFlag() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsBoolFlag" data-name="IsBoolFlag">
               <h3>
                  IsBoolFlag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsBoolFlag" class="anchor" title="Link to IsBoolFlag">#</a>
               </h3>
               
               <pre><code class="language-go">func (v *dFlag) IsBoolFlag() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ResolvedString" data-name="ResolvedString">
               <h3>
                  ResolvedString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ResolvedString" class="anchor" title="Link to ResolvedString">#</a>
               </h3>
               
               <p>ResolvedString returns a string describing m as a resolved match for q.</p>
               
               <pre><code class="language-go">func (q *query) ResolvedString(m module.Version) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <pre><code class="language-go">func (v *dFlag) Set(s string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <pre><code class="language-go">func (v *upgradeFlag) Set(s string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *dFlag) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns the original argument from which q was parsed.</p>
               
               <pre><code class="language-go">func (q *query) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (v *upgradeFlag) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="applyUpgrades" data-name="applyUpgrades">
               <h3>
                  applyUpgrades 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#applyUpgrades" class="anchor" title="Link to applyUpgrades">#</a>
               </h3>
               
               <p>applyUpgrades disambiguates candidate sets that are needed to upgrade (or
provide) transitive dependencies imported by previously-resolved packages.
applyUpgrades modifies the build list by adding one module version from each
pathSet in upgrades, then downgrading (or further upgrading) those modules as
needed to maintain any already-resolved versions of other modules.
applyUpgrades does not mark the new versions as resolved, so they can still
be further modified by other queries (such as wildcards).
If all pathSets are resolved without any changes to the build list,
applyUpgrades returns with changed=false.</p>
               
               <pre><code class="language-go">func (r *resolver) applyUpgrades(ctx context.Context, upgrades []pathSet) (changed bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canMatchInModule" data-name="canMatchInModule">
               <h3>
                  canMatchInModule 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#canMatchInModule" class="anchor" title="Link to canMatchInModule">#</a>
               </h3>
               
               <p>canMatchInModule reports whether the given module path can potentially
contain q.pattern.</p>
               
               <pre><code class="language-go">func (q *query) canMatchInModule(mPath string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkAllowedOr" data-name="checkAllowedOr">
               <h3>
                  checkAllowedOr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkAllowedOr" class="anchor" title="Link to checkAllowedOr">#</a>
               </h3>
               
               <p>checkAllowedOr is like modload.CheckAllowed, but it always allows the requested
and current versions (even if they are retracted or otherwise excluded).</p>
               
               <pre><code class="language-go">func (r *resolver) checkAllowedOr(requested string, selected func(string) string) modload.AllowedFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPackageProblems" data-name="checkPackageProblems">
               <h3>
                  checkPackageProblems 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkPackageProblems" class="anchor" title="Link to checkPackageProblems">#</a>
               </h3>
               
               <p>checkPackageProblems reloads packages for the given patterns and reports
missing and ambiguous package errors. It also reports retractions and
deprecations for resolved modules and modules needed to build named packages.
It also adds a sum for each updated module in the build list if we had one
before and didn't get one while loading packages.
We skip missing-package errors earlier in the process, since we want to
resolve pathSets ourselves, but at that point, we don't have enough context
to log the package-import chains leading to each error.</p>
               
               <pre><code class="language-go">func (r *resolver) checkPackageProblems(ctx context.Context, pkgPatterns []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkWildcardVersions" data-name="checkWildcardVersions">
               <h3>
                  checkWildcardVersions 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkWildcardVersions" class="anchor" title="Link to checkWildcardVersions">#</a>
               </h3>
               
               <p>checkWildcardVersions reports an error if any module in the build list has a
path (or contains a package) matching a query with a wildcard pattern, but
has a selected version that does *not* match the query.</p>
               
               <pre><code class="language-go">func (r *resolver) checkWildcardVersions(ctx context.Context)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chooseArbitrarily" data-name="chooseArbitrarily">
               <h3>
                  chooseArbitrarily 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#chooseArbitrarily" class="anchor" title="Link to chooseArbitrarily">#</a>
               </h3>
               
               <p>chooseArbitrarily returns an arbitrary (but deterministic) module version
from among those in the given set.
chooseArbitrarily prefers module paths that were already in the build list at
the start of 'go get', prefers modules that provide packages over those that
do not, and chooses the first module meeting those criteria (so biases toward
longer paths).</p>
               
               <pre><code class="language-go">func (r *resolver) chooseArbitrarily(cs pathSet) (isPackage bool, m module.Version)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="disambiguate" data-name="disambiguate">
               <h3>
                  disambiguate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#disambiguate" class="anchor" title="Link to disambiguate">#</a>
               </h3>
               
               <p>disambiguate eliminates candidates from cs that conflict with other module
versions that have already been resolved. If there is only one (unique)
remaining candidate, disambiguate returns that candidate, along with
an indication of whether that result interprets cs.path as a package
Note: we're only doing very simple disambiguation here. The goal is to
reproduce the user's intent, not to find a solution that a human couldn't.
In the vast majority of cases, we expect only one module per pathSet,
but we want to give some minimal additional tools so that users can add an
extra argument or two on the command line to resolve simple ambiguities.</p>
               
               <pre><code class="language-go">func (r *resolver) disambiguate(cs pathSet) (filtered pathSet, isPackage bool, m module.Version, unique bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errSet" data-name="errSet">
               <h3>
                  errSet 
                  <span class="badge">function</span>
                  
                  <a href="#errSet" class="anchor" title="Link to errSet">#</a>
               </h3>
               
               <p>errSet returns a pathSet containing the given error.</p>
               
               <pre><code class="language-go">func errSet(err error) pathSet</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findAndUpgradeImports" data-name="findAndUpgradeImports">
               <h3>
                  findAndUpgradeImports 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findAndUpgradeImports" class="anchor" title="Link to findAndUpgradeImports">#</a>
               </h3>
               
               <p>findAndUpgradeImports returns a pathSet for each package that is not yet
in the build list but is transitively imported by the packages matching the
given queries (which must already have been resolved).
If the getU flag ("-u") is set, findAndUpgradeImports also returns a
pathSet for each module that is not constrained by any other
command-line argument and has an available matching upgrade.</p>
               
               <pre><code class="language-go">func (r *resolver) findAndUpgradeImports(ctx context.Context, queries []*query) (upgrades []pathSet)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findMissingWildcards" data-name="findMissingWildcards">
               <h3>
                  findMissingWildcards 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findMissingWildcards" class="anchor" title="Link to findMissingWildcards">#</a>
               </h3>
               
               <p>findMissingWildcards adds a candidate set for each query in r.wildcardQueries
that has not yet resolved to any version containing packages.</p>
               
               <pre><code class="language-go">func (r *resolver) findMissingWildcards(ctx context.Context)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initialSelected" data-name="initialSelected">
               <h3>
                  initialSelected 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initialSelected" class="anchor" title="Link to initialSelected">#</a>
               </h3>
               
               <p>initialSelected returns the version of the module with the given path that
was selected at the start of this 'go get' invocation.</p>
               
               <pre><code class="language-go">func (r *resolver) initialSelected(mPath string) (version string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNoSuchModuleVersion" data-name="isNoSuchModuleVersion">
               <h3>
                  isNoSuchModuleVersion 
                  <span class="badge">function</span>
                  
                  <a href="#isNoSuchModuleVersion" class="anchor" title="Link to isNoSuchModuleVersion">#</a>
               </h3>
               
               <p>isNoSuchModuleVersion reports whether err indicates that the requested module
does not exist at the requested version, either because the module does not
exist at all or because it does not include that specific version.</p>
               
               <pre><code class="language-go">func isNoSuchModuleVersion(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNoSuchPackageVersion" data-name="isNoSuchPackageVersion">
               <h3>
                  isNoSuchPackageVersion 
                  <span class="badge">function</span>
                  
                  <a href="#isNoSuchPackageVersion" class="anchor" title="Link to isNoSuchPackageVersion">#</a>
               </h3>
               
               <p>isNoSuchPackageVersion reports whether err indicates that the requested
package does not exist at the requested version, either because no module
that could contain it exists at that version, or because every such module
that does exist does not actually contain the package.</p>
               
               <pre><code class="language-go">func isNoSuchPackageVersion(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isWildcard" data-name="isWildcard">
               <h3>
                  isWildcard 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isWildcard" class="anchor" title="Link to isWildcard">#</a>
               </h3>
               
               <p>isWildcard reports whether q is a pattern that can match multiple paths.</p>
               
               <pre><code class="language-go">func (q *query) isWildcard() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadPackages" data-name="loadPackages">
               <h3>
                  loadPackages 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#loadPackages" class="anchor" title="Link to loadPackages">#</a>
               </h3>
               
               <p>loadPackages loads the packages matching the given patterns, invoking the
findPackage function for each package that may require a change to the
build list.
loadPackages invokes the findPackage function for each package loaded from a
module outside the main module. If the module or version that supplies that
package needs to be changed due to a query, findPackage may return false
and the imports of that package will not be loaded.
loadPackages also invokes the findPackage function for each imported package
that is neither present in the standard library nor in any module in the
build list.</p>
               
               <pre><code class="language-go">func (r *resolver) loadPackages(ctx context.Context, patterns []string, findPackage func(ctx context.Context, path string, m module.Version) versionOk bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchInModule" data-name="matchInModule">
               <h3>
                  matchInModule 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchInModule" class="anchor" title="Link to matchInModule">#</a>
               </h3>
               
               <p>matchInModule is a caching wrapper around modload.MatchInModule.</p>
               
               <pre><code class="language-go">func (r *resolver) matchInModule(ctx context.Context, pattern string, m module.Version) (packages []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchesPath" data-name="matchesPath">
               <h3>
                  matchesPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchesPath" class="anchor" title="Link to matchesPath">#</a>
               </h3>
               
               <p>matchesPath reports whether the given path matches q.pattern.</p>
               
               <pre><code class="language-go">func (q *query) matchesPath(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newQuery" data-name="newQuery">
               <h3>
                  newQuery 
                  <span class="badge">function</span>
                  
                  <a href="#newQuery" class="anchor" title="Link to newQuery">#</a>
               </h3>
               
               <p>newQuery returns a new query parsed from the raw argument,
which must be either path or path@version.</p>
               
               <pre><code class="language-go">func newQuery(raw string) (*query, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newResolver" data-name="newResolver">
               <h3>
                  newResolver 
                  <span class="badge">function</span>
                  
                  <a href="#newResolver" class="anchor" title="Link to newResolver">#</a>
               </h3>
               
               <pre><code class="language-go">func newResolver(ctx context.Context, queries []*query) *resolver</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="noneForPath" data-name="noneForPath">
               <h3>
                  noneForPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#noneForPath" class="anchor" title="Link to noneForPath">#</a>
               </h3>
               
               <p>noneForPath returns a "none" query matching the given module path,
or found == false if no such query exists.</p>
               
               <pre><code class="language-go">func (r *resolver) noneForPath(mPath string) (nq *query, found bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseArgs" data-name="parseArgs">
               <h3>
                  parseArgs 
                  <span class="badge">function</span>
                  
                  <a href="#parseArgs" class="anchor" title="Link to parseArgs">#</a>
               </h3>
               
               <p>parseArgs parses command-line arguments and reports errors.
The command-line arguments are of the form path@version or simply path, with
implicit @upgrade. path@none is "downgrade away".</p>
               
               <pre><code class="language-go">func parseArgs(ctx context.Context, rawArgs []string) (dropToolchain bool, queries []*query)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathOnce" data-name="pathOnce">
               <h3>
                  pathOnce 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pathOnce" class="anchor" title="Link to pathOnce">#</a>
               </h3>
               
               <p>pathOnce invokes f to generate the pathSet for the given path,
if one is still needed.
Note that, unlike sync.Once, pathOnce does not guarantee that a concurrent
call to f for the given path has completed on return.
pathOnce is safe for concurrent use by multiple goroutines, but note that
multiple concurrent calls will result in the sets being added in
nondeterministic order.</p>
               
               <pre><code class="language-go">func (q *query) pathOnce(path string, f func() pathSet)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="performLocalQueries" data-name="performLocalQueries">
               <h3>
                  performLocalQueries 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#performLocalQueries" class="anchor" title="Link to performLocalQueries">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *resolver) performLocalQueries(ctx context.Context)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="performPathQueries" data-name="performPathQueries">
               <h3>
                  performPathQueries 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#performPathQueries" class="anchor" title="Link to performPathQueries">#</a>
               </h3>
               
               <p>performPathQueries populates the candidates for each query whose pattern is
a path literal.
The candidate packages and modules for path literals depend only on the
initial build list, not the current build list, so we only need to query path
literals once.</p>
               
               <pre><code class="language-go">func (r *resolver) performPathQueries(ctx context.Context)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="performPatternAllQueries" data-name="performPatternAllQueries">
               <h3>
                  performPatternAllQueries 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#performPatternAllQueries" class="anchor" title="Link to performPatternAllQueries">#</a>
               </h3>
               
               <p>performPatternAllQueries populates the candidates for each query whose
pattern is "all".
The candidate modules for a given package in "all" depend only on the initial
build list, but we cannot follow the dependencies of a given package until we
know which candidate is selected — and that selection may depend on the
results of other queries. We need to re-evaluate the "all" queries whenever
the module for one or more packages in "all" are resolved.</p>
               
               <pre><code class="language-go">func (r *resolver) performPatternAllQueries(ctx context.Context)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="performToolQueries" data-name="performToolQueries">
               <h3>
                  performToolQueries 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#performToolQueries" class="anchor" title="Link to performToolQueries">#</a>
               </h3>
               
               <p>performToolQueries populates the candidates for each query whose
pattern is "tool".</p>
               
               <pre><code class="language-go">func (r *resolver) performToolQueries(ctx context.Context)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="performWildcardQueries" data-name="performWildcardQueries">
               <h3>
                  performWildcardQueries 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#performWildcardQueries" class="anchor" title="Link to performWildcardQueries">#</a>
               </h3>
               
               <p>performWildcardQueries populates the candidates for each query whose pattern
is a wildcard.
The candidates for a given module path matching (or containing a package
matching) a wildcard query depend only on the initial build list, but the set
of modules may be expanded by other queries, so wildcard queries need to be
re-evaluated whenever a potentially-matching module path is added to the
build list.</p>
               
               <pre><code class="language-go">func (r *resolver) performWildcardQueries(ctx context.Context)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="queryModule" data-name="queryModule">
               <h3>
                  queryModule 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#queryModule" class="anchor" title="Link to queryModule">#</a>
               </h3>
               
               <p>queryModule wraps modload.Query, substituting r.checkAllowedOr to decide
allowed versions.</p>
               
               <pre><code class="language-go">func (r *resolver) queryModule(ctx context.Context, mPath string, query string, selected func(string) string) (module.Version, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="queryNone" data-name="queryNone">
               <h3>
                  queryNone 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#queryNone" class="anchor" title="Link to queryNone">#</a>
               </h3>
               
               <p>queryNone adds a candidate set to q for each module matching q.pattern.
Each candidate set has only one possible module version: the matched
module at version "none".
We interpret arguments to 'go get' as packages first, and fall back to
modules second. However, no module exists at version "none", and therefore no
package exists at that version either: we know that the argument cannot match
any packages, and thus it must match modules instead.</p>
               
               <pre><code class="language-go">func (r *resolver) queryNone(ctx context.Context, q *query)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="queryPackages" data-name="queryPackages">
               <h3>
                  queryPackages 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#queryPackages" class="anchor" title="Link to queryPackages">#</a>
               </h3>
               
               <p>queryPackages wraps modload.QueryPackage, substituting r.checkAllowedOr to
decide allowed versions.</p>
               
               <pre><code class="language-go">func (r *resolver) queryPackages(ctx context.Context, pattern string, query string, selected func(string) string) (pkgMods []module.Version, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="queryPath" data-name="queryPath">
               <h3>
                  queryPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#queryPath" class="anchor" title="Link to queryPath">#</a>
               </h3>
               
               <p>queryPath adds a candidate set to q for the package with path q.pattern.
The candidate set consists of all modules that could provide q.pattern
and have a version matching q, plus (if it exists) the module whose path
is itself q.pattern (at a matching version).</p>
               
               <pre><code class="language-go">func (r *resolver) queryPath(ctx context.Context, q *query)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="queryPattern" data-name="queryPattern">
               <h3>
                  queryPattern 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#queryPattern" class="anchor" title="Link to queryPattern">#</a>
               </h3>
               
               <p>queryPattern wraps modload.QueryPattern, substituting r.checkAllowedOr to
decide allowed versions.</p>
               
               <pre><code class="language-go">func (r *resolver) queryPattern(ctx context.Context, pattern string, query string, selected func(string) string) (pkgMods []module.Version, mod module.Version, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="queryWildcard" data-name="queryWildcard">
               <h3>
                  queryWildcard 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#queryWildcard" class="anchor" title="Link to queryWildcard">#</a>
               </h3>
               
               <p>queryWildcard adds a candidate set to q for each module for which:
- some version of the module is already in the build list, and
- that module exists at some version matching q.version, and
- either the module path itself matches q.pattern, or some package within
the module at q.version matches q.pattern.</p>
               
               <pre><code class="language-go">func (r *resolver) queryWildcard(ctx context.Context, q *query)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reportChanges" data-name="reportChanges">
               <h3>
                  reportChanges 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reportChanges" class="anchor" title="Link to reportChanges">#</a>
               </h3>
               
               <p>reportChanges logs version changes to os.Stderr.
reportChanges only logs changes to modules named on the command line and to
explicitly required modules in go.mod. Most changes to indirect requirements
are not relevant to the user and are not logged.
reportChanges should be called after WriteGoMod.</p>
               
               <pre><code class="language-go">func (r *resolver) reportChanges(oldReqs []module.Version, newReqs []module.Version)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reportConflict" data-name="reportConflict">
               <h3>
                  reportConflict 
                  <span class="badge">function</span>
                  
                  <a href="#reportConflict" class="anchor" title="Link to reportConflict">#</a>
               </h3>
               
               <pre><code class="language-go">func reportConflict(pq *query, m module.Version, conflict versionReason)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reportError" data-name="reportError">
               <h3>
                  reportError 
                  <span class="badge">function</span>
                  
                  <a href="#reportError" class="anchor" title="Link to reportError">#</a>
               </h3>
               
               <p>reportError logs err concisely using base.Errorf.</p>
               
               <pre><code class="language-go">func reportError(q *query, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reqsFromGoMod" data-name="reqsFromGoMod">
               <h3>
                  reqsFromGoMod 
                  <span class="badge">function</span>
                  
                  <a href="#reqsFromGoMod" class="anchor" title="Link to reqsFromGoMod">#</a>
               </h3>
               
               <pre><code class="language-go">func reqsFromGoMod(f *modfile.File) []module.Version</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolve" data-name="resolve">
               <h3>
                  resolve 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#resolve" class="anchor" title="Link to resolve">#</a>
               </h3>
               
               <p>resolve records that module m must be at its indicated version (which may be
"none") due to query q. If some other query forces module m to be at a
different version, resolve reports a conflict error.</p>
               
               <pre><code class="language-go">func (r *resolver) resolve(q *query, m module.Version)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveQueries" data-name="resolveQueries">
               <h3>
                  resolveQueries 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#resolveQueries" class="anchor" title="Link to resolveQueries">#</a>
               </h3>
               
               <p>resolveQueries resolves candidate sets that are attached to the given
queries and/or needed to provide the given missing-package dependencies.
resolveQueries starts by resolving one module version from each
unambiguous pathSet attached to the given queries.
If no unambiguous query results in a change to the build list,
resolveQueries revisits the ambiguous query candidates and resolves them
arbitrarily in order to guarantee forward progress.
If all pathSets are resolved without any changes to the build list,
resolveQueries returns with changed=false.</p>
               
               <pre><code class="language-go">func (r *resolver) resolveQueries(ctx context.Context, queries []*query) (changed bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runGet" data-name="runGet">
               <h3>
                  runGet 
                  <span class="badge">function</span>
                  
                  <a href="#runGet" class="anchor" title="Link to runGet">#</a>
               </h3>
               
               <pre><code class="language-go">func runGet(ctx context.Context, cmd *base.Command, args []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="selected" data-name="selected">
               <h3>
                  selected 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#selected" class="anchor" title="Link to selected">#</a>
               </h3>
               
               <p>selected returns the version of the module with the given path that is
selected in the resolver's current build list.</p>
               
               <pre><code class="language-go">func (r *resolver) selected(mPath string) (version string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tryWildcard" data-name="tryWildcard">
               <h3>
                  tryWildcard 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tryWildcard" class="anchor" title="Link to tryWildcard">#</a>
               </h3>
               
               <p>tryWildcard returns a pathSet for module m matching query q.
If m does not actually match q, tryWildcard returns an empty pathSet.</p>
               
               <pre><code class="language-go">func (r *resolver) tryWildcard(ctx context.Context, q *query, m module.Version) pathSet</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateBuildList" data-name="updateBuildList">
               <h3>
                  updateBuildList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#updateBuildList" class="anchor" title="Link to updateBuildList">#</a>
               </h3>
               
               <p>updateBuildList updates the module loader's global build list to be
consistent with r.resolvedVersion, and to include additional modules
provided that they do not conflict with the resolved versions.
If the additional modules conflict with the resolved versions, they will be
downgraded to a non-conflicting version (possibly "none").
If the resulting build list is the same as the one resulting from the last
call to updateBuildList, updateBuildList returns with changed=false.</p>
               
               <pre><code class="language-go">func (r *resolver) updateBuildList(ctx context.Context, additions []module.Version) (changed bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateTools" data-name="updateTools">
               <h3>
                  updateTools 
                  <span class="badge">function</span>
                  
                  <a href="#updateTools" class="anchor" title="Link to updateTools">#</a>
               </h3>
               
               <pre><code class="language-go">func updateTools(ctx context.Context, queries []*query, opts *modload.WriteOpts)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validate" data-name="validate">
               <h3>
                  validate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#validate" class="anchor" title="Link to validate">#</a>
               </h3>
               
               <p>validate reports a non-nil error if q is not sensible and well-formed.</p>
               
               <pre><code class="language-go">func (q *query) validate() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="versionOkForMainModule" data-name="versionOkForMainModule">
               <h3>
                  versionOkForMainModule 
                  <span class="badge">function</span>
                  
                  <a href="#versionOkForMainModule" class="anchor" title="Link to versionOkForMainModule">#</a>
               </h3>
               
               <pre><code class="language-go">func versionOkForMainModule(version string) bool</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();

               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);

               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;

               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               // Apply Prism highlighting again
               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>