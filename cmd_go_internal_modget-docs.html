<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - modget</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>modget</code>
         </h1>
         <hr />
         
         <article class="global" data-name="CmdGet">
            <h2>CmdGet</h2>
            <hr />
            
            <pre><code>CmdGet</code></pre>
         </article>
         
         <article class="global" data-name="HelpVCS">
            <h2>HelpVCS</h2>
            <hr />
            
            <pre><code>HelpVCS</code></pre>
         </article>
         
         <article class="global" data-name="getD">
            <h2>getD</h2>
            <hr />
            
            <pre><code>getD dFlag</code></pre>
         </article>
         
         <article class="global" data-name="getF">
            <h2>getF</h2>
            <hr />
            
            <pre><code>getF</code></pre>
         </article>
         
         <article class="global" data-name="getFix">
            <h2>getFix</h2>
            <hr />
            
            <pre><code>getFix</code></pre>
         </article>
         
         <article class="global" data-name="getM">
            <h2>getM</h2>
            <hr />
            
            <pre><code>getM</code></pre>
         </article>
         
         <article class="global" data-name="getT">
            <h2>getT</h2>
            <hr />
            
            <pre><code>getT</code></pre>
         </article>
         
         <article class="global" data-name="getU">
            <h2>getU</h2>
            <hr />
            
            <pre><code>getU upgradeFlag</code></pre>
         </article>
         
         <article class="global" data-name="getTool">
            <h2>getTool</h2>
            <hr />
            
            <pre><code>getTool</code></pre>
         </article>
         
         <article class="global" data-name="getInsecure">
            <h2>getInsecure</h2>
            <hr />
            
            <pre><code>getInsecure</code></pre>
         </article>
         
         <article class="global" data-name="errVersionChange">
            <h2>errVersionChange</h2>
            <hr />
            
            <p>errVersionChange is a sentinel error indicating that a module's version needs
to be updated before its dependencies can be loaded.</p>
            
            <pre><code>errVersionChange</code></pre>
         </article>
          
         <article class="struct" data-name="upgradeFlag">
            <h2>type upgradeFlag struct</h2>
            <hr />
            
            <p>upgradeFlag is a custom flag.Value for -u.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">rawVersion string
version string</code></pre>
         </article>
         
         <article class="struct" data-name="dFlag">
            <h2>type dFlag struct</h2>
            <hr />
            
            <p>dFlag is a custom flag.Value for the deprecated -d flag
which will be used to provide warnings or errors if -d
is provided.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">value bool
set bool</code></pre>
         </article>
         
         <article class="struct" data-name="resolver">
            <h2>type resolver struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">localQueries []*query
pathQueries []*query
wildcardQueries []*query
patternAllQueries []*query
toolQueries []*query
nonesByPath *ast.MapType
wildcardNones []*query
resolvedVersion *ast.MapType
buildList []module.Version
buildListVersion *ast.MapType
initialVersion *ast.MapType
missing []pathSet
work *par.Queue
matchInModuleCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="struct" data-name="versionReason">
            <h2>type versionReason struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">version string
reason *query</code></pre>
         </article>
         
         <article class="struct" data-name="matchInModuleKey">
            <h2>type matchInModuleKey struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pattern string
m module.Version</code></pre>
         </article>
         
         <article class="struct" data-name="query">
            <h2>type query struct</h2>
            <hr />
            
            <p>A query describes a command-line argument and the modules and/or packages
to which that argument may resolve..</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">raw string
rawVersion string
pattern string
patternIsLocal bool
version string
matchWildcard func
canMatchWildcardInModule func
conflict *query
candidates []pathSet
candidatesMu sync.Mutex
pathSeen sync.Map
resolved []module.Version
matchesPackages bool</code></pre>
         </article>
         
         <article class="struct" data-name="pathSet">
            <h2>type pathSet struct</h2>
            <hr />
            
            <p>A pathSet describes the possible options for resolving a specific path
to a package and/or module.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string
pkgMods []module.Version
mod module.Version
err error</code></pre>
         </article>
         
         <article class="struct" data-name="conflictError">
            <h2>type conflictError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">mPath string
proposed versionReason
conflict versionReason</code></pre>
         </article>
          
         <article class="function" data-name="IsBoolFlag">
            <h2>IsBoolFlag</h2>
            <hr />
            
            <pre><code>func IsBoolFlag() bool</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(s string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="IsBoolFlag">
            <h2>IsBoolFlag</h2>
            <hr />
            
            <pre><code>func IsBoolFlag() bool</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(s string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="runGet">
            <h2>runGet</h2>
            <hr />
            
            <pre><code>func runGet(ctx context.Context, cmd *base.Command, args []string)</code></pre>
         </article>
         
         <article class="function" data-name="updateTools">
            <h2>updateTools</h2>
            <hr />
            
            <pre><code>func updateTools(ctx context.Context, queries []*query, opts *modload.WriteOpts)</code></pre>
         </article>
         
         <article class="function" data-name="parseArgs">
            <h2>parseArgs</h2>
            <hr />
            
            <p>parseArgs parses command-line arguments and reports errors.

The command-line arguments are of the form path@version or simply path, with
implicit @upgrade. path@none is "downgrade away".</p>
            
            <pre><code>func parseArgs(ctx context.Context, rawArgs []string) (dropToolchain bool, queries []*query)</code></pre>
         </article>
         
         <article class="function" data-name="newResolver">
            <h2>newResolver</h2>
            <hr />
            
            <pre><code>func newResolver(ctx context.Context, queries []*query) *resolver</code></pre>
         </article>
         
         <article class="function" data-name="initialSelected">
            <h2>initialSelected</h2>
            <hr />
            
            <p>initialSelected returns the version of the module with the given path that
was selected at the start of this 'go get' invocation.</p>
            
            <pre><code>func initialSelected(mPath string) version string</code></pre>
         </article>
         
         <article class="function" data-name="selected">
            <h2>selected</h2>
            <hr />
            
            <p>selected returns the version of the module with the given path that is
selected in the resolver's current build list.</p>
            
            <pre><code>func selected(mPath string) version string</code></pre>
         </article>
         
         <article class="function" data-name="noneForPath">
            <h2>noneForPath</h2>
            <hr />
            
            <p>noneForPath returns a "none" query matching the given module path,
or found == false if no such query exists.</p>
            
            <pre><code>func noneForPath(mPath string) (nq *query, found bool)</code></pre>
         </article>
         
         <article class="function" data-name="queryModule">
            <h2>queryModule</h2>
            <hr />
            
            <p>queryModule wraps modload.Query, substituting r.checkAllowedOr to decide
allowed versions.</p>
            
            <pre><code>func queryModule(ctx context.Context, mPath string, query string, selected func) (module.Version, error)</code></pre>
         </article>
         
         <article class="function" data-name="queryPackages">
            <h2>queryPackages</h2>
            <hr />
            
            <p>queryPackages wraps modload.QueryPackage, substituting r.checkAllowedOr to
decide allowed versions.</p>
            
            <pre><code>func queryPackages(ctx context.Context, pattern string, query string, selected func) (pkgMods []module.Version, err error)</code></pre>
         </article>
         
         <article class="function" data-name="queryPattern">
            <h2>queryPattern</h2>
            <hr />
            
            <p>queryPattern wraps modload.QueryPattern, substituting r.checkAllowedOr to
decide allowed versions.</p>
            
            <pre><code>func queryPattern(ctx context.Context, pattern string, query string, selected func) (pkgMods []module.Version, mod module.Version, err error)</code></pre>
         </article>
         
         <article class="function" data-name="checkAllowedOr">
            <h2>checkAllowedOr</h2>
            <hr />
            
            <p>checkAllowedOr is like modload.CheckAllowed, but it always allows the requested
and current versions (even if they are retracted or otherwise excluded).</p>
            
            <pre><code>func checkAllowedOr(requested string, selected func) modload.AllowedFunc</code></pre>
         </article>
         
         <article class="function" data-name="matchInModule">
            <h2>matchInModule</h2>
            <hr />
            
            <p>matchInModule is a caching wrapper around modload.MatchInModule.</p>
            
            <pre><code>func matchInModule(ctx context.Context, pattern string, m module.Version) (packages []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="queryNone">
            <h2>queryNone</h2>
            <hr />
            
            <p>queryNone adds a candidate set to q for each module matching q.pattern.
Each candidate set has only one possible module version: the matched
module at version "none".

We interpret arguments to 'go get' as packages first, and fall back to
modules second. However, no module exists at version "none", and therefore no
package exists at that version either: we know that the argument cannot match
any packages, and thus it must match modules instead.</p>
            
            <pre><code>func queryNone(ctx context.Context, q *query)</code></pre>
         </article>
         
         <article class="function" data-name="performLocalQueries">
            <h2>performLocalQueries</h2>
            <hr />
            
            <pre><code>func performLocalQueries(ctx context.Context)</code></pre>
         </article>
         
         <article class="function" data-name="performWildcardQueries">
            <h2>performWildcardQueries</h2>
            <hr />
            
            <p>performWildcardQueries populates the candidates for each query whose pattern
is a wildcard.

The candidates for a given module path matching (or containing a package
matching) a wildcard query depend only on the initial build list, but the set
of modules may be expanded by other queries, so wildcard queries need to be
re-evaluated whenever a potentially-matching module path is added to the
build list.</p>
            
            <pre><code>func performWildcardQueries(ctx context.Context)</code></pre>
         </article>
         
         <article class="function" data-name="queryWildcard">
            <h2>queryWildcard</h2>
            <hr />
            
            <p>queryWildcard adds a candidate set to q for each module for which:
  - some version of the module is already in the build list, and
  - that module exists at some version matching q.version, and
  - either the module path itself matches q.pattern, or some package within
    the module at q.version matches q.pattern.</p>
            
            <pre><code>func queryWildcard(ctx context.Context, q *query)</code></pre>
         </article>
         
         <article class="function" data-name="tryWildcard">
            <h2>tryWildcard</h2>
            <hr />
            
            <p>tryWildcard returns a pathSet for module m matching query q.
If m does not actually match q, tryWildcard returns an empty pathSet.</p>
            
            <pre><code>func tryWildcard(ctx context.Context, q *query, m module.Version) pathSet</code></pre>
         </article>
         
         <article class="function" data-name="findMissingWildcards">
            <h2>findMissingWildcards</h2>
            <hr />
            
            <p>findMissingWildcards adds a candidate set for each query in r.wildcardQueries
that has not yet resolved to any version containing packages.</p>
            
            <pre><code>func findMissingWildcards(ctx context.Context)</code></pre>
         </article>
         
         <article class="function" data-name="checkWildcardVersions">
            <h2>checkWildcardVersions</h2>
            <hr />
            
            <p>checkWildcardVersions reports an error if any module in the build list has a
path (or contains a package) matching a query with a wildcard pattern, but
has a selected version that does *not* match the query.</p>
            
            <pre><code>func checkWildcardVersions(ctx context.Context)</code></pre>
         </article>
         
         <article class="function" data-name="performPathQueries">
            <h2>performPathQueries</h2>
            <hr />
            
            <p>performPathQueries populates the candidates for each query whose pattern is
a path literal.

The candidate packages and modules for path literals depend only on the
initial build list, not the current build list, so we only need to query path
literals once.</p>
            
            <pre><code>func performPathQueries(ctx context.Context)</code></pre>
         </article>
         
         <article class="function" data-name="queryPath">
            <h2>queryPath</h2>
            <hr />
            
            <p>queryPath adds a candidate set to q for the package with path q.pattern.
The candidate set consists of all modules that could provide q.pattern
and have a version matching q, plus (if it exists) the module whose path
is itself q.pattern (at a matching version).</p>
            
            <pre><code>func queryPath(ctx context.Context, q *query)</code></pre>
         </article>
         
         <article class="function" data-name="performToolQueries">
            <h2>performToolQueries</h2>
            <hr />
            
            <p>performToolQueries populates the candidates for each query whose
pattern is "tool".</p>
            
            <pre><code>func performToolQueries(ctx context.Context)</code></pre>
         </article>
         
         <article class="function" data-name="performPatternAllQueries">
            <h2>performPatternAllQueries</h2>
            <hr />
            
            <p>performPatternAllQueries populates the candidates for each query whose
pattern is "all".

The candidate modules for a given package in "all" depend only on the initial
build list, but we cannot follow the dependencies of a given package until we
know which candidate is selected — and that selection may depend on the
results of other queries. We need to re-evaluate the "all" queries whenever
the module for one or more packages in "all" are resolved.</p>
            
            <pre><code>func performPatternAllQueries(ctx context.Context)</code></pre>
         </article>
         
         <article class="function" data-name="findAndUpgradeImports">
            <h2>findAndUpgradeImports</h2>
            <hr />
            
            <p>findAndUpgradeImports returns a pathSet for each package that is not yet
in the build list but is transitively imported by the packages matching the
given queries (which must already have been resolved).

If the getU flag ("-u") is set, findAndUpgradeImports also returns a
pathSet for each module that is not constrained by any other
command-line argument and has an available matching upgrade.</p>
            
            <pre><code>func findAndUpgradeImports(ctx context.Context, queries []*query) upgrades []pathSet</code></pre>
         </article>
         
         <article class="function" data-name="loadPackages">
            <h2>loadPackages</h2>
            <hr />
            
            <p>loadPackages loads the packages matching the given patterns, invoking the
findPackage function for each package that may require a change to the
build list.

loadPackages invokes the findPackage function for each package loaded from a
module outside the main module. If the module or version that supplies that
package needs to be changed due to a query, findPackage may return false
and the imports of that package will not be loaded.

loadPackages also invokes the findPackage function for each imported package
that is neither present in the standard library nor in any module in the
build list.</p>
            
            <pre><code>func loadPackages(ctx context.Context, patterns []string, findPackage func)</code></pre>
         </article>
         
         <article class="function" data-name="resolveQueries">
            <h2>resolveQueries</h2>
            <hr />
            
            <p>resolveQueries resolves candidate sets that are attached to the given
queries and/or needed to provide the given missing-package dependencies.

resolveQueries starts by resolving one module version from each
unambiguous pathSet attached to the given queries.

If no unambiguous query results in a change to the build list,
resolveQueries revisits the ambiguous query candidates and resolves them
arbitrarily in order to guarantee forward progress.

If all pathSets are resolved without any changes to the build list,
resolveQueries returns with changed=false.</p>
            
            <pre><code>func resolveQueries(ctx context.Context, queries []*query) changed bool</code></pre>
         </article>
         
         <article class="function" data-name="applyUpgrades">
            <h2>applyUpgrades</h2>
            <hr />
            
            <p>applyUpgrades disambiguates candidate sets that are needed to upgrade (or
provide) transitive dependencies imported by previously-resolved packages.

applyUpgrades modifies the build list by adding one module version from each
pathSet in upgrades, then downgrading (or further upgrading) those modules as
needed to maintain any already-resolved versions of other modules.
applyUpgrades does not mark the new versions as resolved, so they can still
be further modified by other queries (such as wildcards).

If all pathSets are resolved without any changes to the build list,
applyUpgrades returns with changed=false.</p>
            
            <pre><code>func applyUpgrades(ctx context.Context, upgrades []pathSet) changed bool</code></pre>
         </article>
         
         <article class="function" data-name="disambiguate">
            <h2>disambiguate</h2>
            <hr />
            
            <p>disambiguate eliminates candidates from cs that conflict with other module
versions that have already been resolved. If there is only one (unique)
remaining candidate, disambiguate returns that candidate, along with
an indication of whether that result interprets cs.path as a package

Note: we're only doing very simple disambiguation here. The goal is to
reproduce the user's intent, not to find a solution that a human couldn't.
In the vast majority of cases, we expect only one module per pathSet,
but we want to give some minimal additional tools so that users can add an
extra argument or two on the command line to resolve simple ambiguities.</p>
            
            <pre><code>func disambiguate(cs pathSet) (filtered pathSet, isPackage bool, m module.Version, unique bool)</code></pre>
         </article>
         
         <article class="function" data-name="chooseArbitrarily">
            <h2>chooseArbitrarily</h2>
            <hr />
            
            <p>chooseArbitrarily returns an arbitrary (but deterministic) module version
from among those in the given set.

chooseArbitrarily prefers module paths that were already in the build list at
the start of 'go get', prefers modules that provide packages over those that
do not, and chooses the first module meeting those criteria (so biases toward
longer paths).</p>
            
            <pre><code>func chooseArbitrarily(cs pathSet) (isPackage bool, m module.Version)</code></pre>
         </article>
         
         <article class="function" data-name="checkPackageProblems">
            <h2>checkPackageProblems</h2>
            <hr />
            
            <p>checkPackageProblems reloads packages for the given patterns and reports
missing and ambiguous package errors. It also reports retractions and
deprecations for resolved modules and modules needed to build named packages.
It also adds a sum for each updated module in the build list if we had one
before and didn't get one while loading packages.

We skip missing-package errors earlier in the process, since we want to
resolve pathSets ourselves, but at that point, we don't have enough context
to log the package-import chains leading to each error.</p>
            
            <pre><code>func checkPackageProblems(ctx context.Context, pkgPatterns []string)</code></pre>
         </article>
         
         <article class="function" data-name="reportChanges">
            <h2>reportChanges</h2>
            <hr />
            
            <p>reportChanges logs version changes to os.Stderr.

reportChanges only logs changes to modules named on the command line and to
explicitly required modules in go.mod. Most changes to indirect requirements
are not relevant to the user and are not logged.

reportChanges should be called after WriteGoMod.</p>
            
            <pre><code>func reportChanges(oldReqs []module.Version, newReqs []module.Version)</code></pre>
         </article>
         
         <article class="function" data-name="resolve">
            <h2>resolve</h2>
            <hr />
            
            <p>resolve records that module m must be at its indicated version (which may be
"none") due to query q. If some other query forces module m to be at a
different version, resolve reports a conflict error.</p>
            
            <pre><code>func resolve(q *query, m module.Version)</code></pre>
         </article>
         
         <article class="function" data-name="updateBuildList">
            <h2>updateBuildList</h2>
            <hr />
            
            <p>updateBuildList updates the module loader's global build list to be
consistent with r.resolvedVersion, and to include additional modules
provided that they do not conflict with the resolved versions.

If the additional modules conflict with the resolved versions, they will be
downgraded to a non-conflicting version (possibly "none").

If the resulting build list is the same as the one resulting from the last
call to updateBuildList, updateBuildList returns with changed=false.</p>
            
            <pre><code>func updateBuildList(ctx context.Context, additions []module.Version) changed bool</code></pre>
         </article>
         
         <article class="function" data-name="reqsFromGoMod">
            <h2>reqsFromGoMod</h2>
            <hr />
            
            <pre><code>func reqsFromGoMod(f *modfile.File) []module.Version</code></pre>
         </article>
         
         <article class="function" data-name="isNoSuchModuleVersion">
            <h2>isNoSuchModuleVersion</h2>
            <hr />
            
            <p>isNoSuchModuleVersion reports whether err indicates that the requested module
does not exist at the requested version, either because the module does not
exist at all or because it does not include that specific version.</p>
            
            <pre><code>func isNoSuchModuleVersion(err error) bool</code></pre>
         </article>
         
         <article class="function" data-name="isNoSuchPackageVersion">
            <h2>isNoSuchPackageVersion</h2>
            <hr />
            
            <p>isNoSuchPackageVersion reports whether err indicates that the requested
package does not exist at the requested version, either because no module
that could contain it exists at that version, or because every such module
that does exist does not actually contain the package.</p>
            
            <pre><code>func isNoSuchPackageVersion(err error) bool</code></pre>
         </article>
         
         <article class="function" data-name="errSet">
            <h2>errSet</h2>
            <hr />
            
            <p>errSet returns a pathSet containing the given error.</p>
            
            <pre><code>func errSet(err error) pathSet</code></pre>
         </article>
         
         <article class="function" data-name="newQuery">
            <h2>newQuery</h2>
            <hr />
            
            <p>newQuery returns a new query parsed from the raw argument,
which must be either path or path@version.</p>
            
            <pre><code>func newQuery(raw string) (*query, error)</code></pre>
         </article>
         
         <article class="function" data-name="validate">
            <h2>validate</h2>
            <hr />
            
            <p>validate reports a non-nil error if q is not sensible and well-formed.</p>
            
            <pre><code>func validate() error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns the original argument from which q was parsed.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="ResolvedString">
            <h2>ResolvedString</h2>
            <hr />
            
            <p>ResolvedString returns a string describing m as a resolved match for q.</p>
            
            <pre><code>func ResolvedString(m module.Version) string</code></pre>
         </article>
         
         <article class="function" data-name="isWildcard">
            <h2>isWildcard</h2>
            <hr />
            
            <p>isWildcard reports whether q is a pattern that can match multiple paths.</p>
            
            <pre><code>func isWildcard() bool</code></pre>
         </article>
         
         <article class="function" data-name="matchesPath">
            <h2>matchesPath</h2>
            <hr />
            
            <p>matchesPath reports whether the given path matches q.pattern.</p>
            
            <pre><code>func matchesPath(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="canMatchInModule">
            <h2>canMatchInModule</h2>
            <hr />
            
            <p>canMatchInModule reports whether the given module path can potentially
contain q.pattern.</p>
            
            <pre><code>func canMatchInModule(mPath string) bool</code></pre>
         </article>
         
         <article class="function" data-name="pathOnce">
            <h2>pathOnce</h2>
            <hr />
            
            <p>pathOnce invokes f to generate the pathSet for the given path,
if one is still needed.

Note that, unlike sync.Once, pathOnce does not guarantee that a concurrent
call to f for the given path has completed on return.

pathOnce is safe for concurrent use by multiple goroutines, but note that
multiple concurrent calls will result in the sets being added in
nondeterministic order.</p>
            
            <pre><code>func pathOnce(path string, f func)</code></pre>
         </article>
         
         <article class="function" data-name="reportError">
            <h2>reportError</h2>
            <hr />
            
            <p>reportError logs err concisely using base.Errorf.</p>
            
            <pre><code>func reportError(q *query, err error)</code></pre>
         </article>
         
         <article class="function" data-name="reportConflict">
            <h2>reportConflict</h2>
            <hr />
            
            <pre><code>func reportConflict(pq *query, m module.Version, conflict versionReason)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="versionOkForMainModule">
            <h2>versionOkForMainModule</h2>
            <hr />
            
            <pre><code>func versionOkForMainModule(version string) bool</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
