<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>escape - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>escape</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"cmd/compile/internal/base"
"math"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"fmt"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/src"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/logopt"
"cmd/compile/internal/types"
"fmt"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/logopt"
"cmd/internal/src"
"fmt"
"strings"
"cmd/compile/internal/ir"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"fmt"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/logopt"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/src"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="attrCalls" data-name="attrCalls">
               <h3>
                  attrCalls 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#attrCalls" class="anchor" title="Link to attrCalls">#</a>
               </h3>
               
                  <p class="doc-comment">attrCalls indicates whether closures that are reachable from this
location may be called without tracking their results. This is
used to better optimize indirect closure calls.</p>
               
               <pre><code class="language-go">const attrCalls</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="attrEscapes" data-name="attrEscapes">
               <h3>
                  attrEscapes 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#attrEscapes" class="anchor" title="Link to attrEscapes">#</a>
               </h3>
               
                  <p class="doc-comment">attrEscapes indicates whether the represented variable's address
escapes; that is, whether the variable must be heap allocated.</p>
               
               <pre><code class="language-go">const attrEscapes locAttr = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="attrMutates" data-name="attrMutates">
               <h3>
                  attrMutates 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#attrMutates" class="anchor" title="Link to attrMutates">#</a>
               </h3>
               
                  <p class="doc-comment">attrMutates indicates whether pointers that are reachable from
this location may have their addressed memory mutated. This is
used to detect string->[]byte conversions that can be safely
optimized away.</p>
               
               <pre><code class="language-go">const attrMutates</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="attrPersists" data-name="attrPersists">
               <h3>
                  attrPersists 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#attrPersists" class="anchor" title="Link to attrPersists">#</a>
               </h3>
               
                  <p class="doc-comment">attrPersists indicates whether the represented expression's
address outlives the statement; that is, whether its storage
cannot be immediately reused.</p>
               
               <pre><code class="language-go">const attrPersists</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="escFuncPlanned" data-name="escFuncPlanned">
               <h3>
                  escFuncPlanned 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#escFuncPlanned" class="anchor" title="Link to escFuncPlanned">#</a>
               </h3>
               
               <pre><code class="language-go">const escFuncPlanned</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="escFuncStarted" data-name="escFuncStarted">
               <h3>
                  escFuncStarted 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#escFuncStarted" class="anchor" title="Link to escFuncStarted">#</a>
               </h3>
               
               <pre><code class="language-go">const escFuncStarted</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="escFuncTagged" data-name="escFuncTagged">
               <h3>
                  escFuncTagged 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#escFuncTagged" class="anchor" title="Link to escFuncTagged">#</a>
               </h3>
               
               <pre><code class="language-go">const escFuncTagged</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="escFuncUnknown" data-name="escFuncUnknown">
               <h3>
                  escFuncUnknown 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#escFuncUnknown" class="anchor" title="Link to escFuncUnknown">#</a>
               </h3>
               
               <pre><code class="language-go">const escFuncUnknown = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="leakCallee" data-name="leakCallee">
               <h3>
                  leakCallee 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#leakCallee" class="anchor" title="Link to leakCallee">#</a>
               </h3>
               
               <pre><code class="language-go">const leakCallee</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="leakHeap" data-name="leakHeap">
               <h3>
                  leakHeap 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#leakHeap" class="anchor" title="Link to leakHeap">#</a>
               </h3>
               
               <pre><code class="language-go">const leakHeap = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="leakMutator" data-name="leakMutator">
               <h3>
                  leakMutator 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#leakMutator" class="anchor" title="Link to leakMutator">#</a>
               </h3>
               
               <pre><code class="language-go">const leakMutator</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="leakResult0" data-name="leakResult0">
               <h3>
                  leakResult0 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#leakResult0" class="anchor" title="Link to leakResult0">#</a>
               </h3>
               
               <pre><code class="language-go">const leakResult0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="leakTagCache" data-name="leakTagCache">
               <h3>
                  leakTagCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#leakTagCache" class="anchor" title="Link to leakTagCache">#</a>
               </h3>
               
               <pre><code class="language-go">var leakTagCache = map[leaks]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="looping" data-name="looping">
               <h3>
                  looping 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#looping" class="anchor" title="Link to looping">#</a>
               </h3>
               
               <pre><code class="language-go">const looping labelState = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nonlooping" data-name="nonlooping">
               <h3>
                  nonlooping 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#nonlooping" class="anchor" title="Link to nonlooping">#</a>
               </h3>
               
               <pre><code class="language-go">const nonlooping</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="numEscResults" data-name="numEscResults">
               <h3>
                  numEscResults 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#numEscResults" class="anchor" title="Link to numEscResults">#</a>
               </h3>
               
               <pre><code class="language-go">const numEscResults = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="labelState" data-name="labelState">
               <h3>
                  labelState
                  <span class="badge type-badge">type</span>
                  <a href="#labelState" class="anchor" title="Link to labelState">#</a>
               </h3>
               
               <p>Mark labels that have no backjumps to them as not increasing e.loopdepth.</p>
               
               <pre><code class="language-go">type labelState int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="leaks" data-name="leaks">
               <h3>
                  leaks
                  <span class="badge type-badge">type</span>
                  <a href="#leaks" class="anchor" title="Link to leaks">#</a>
               </h3>
               
               <p>A leaks represents a set of assignment flows from a parameter to
the heap, mutator, callee, or to any of its function's (first
numEscResults) result parameters.</p>
               
               <pre><code class="language-go">type leaks [8]uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="locAttr" data-name="locAttr">
               <h3>
                  locAttr
                  <span class="badge type-badge">type</span>
                  <a href="#locAttr" class="anchor" title="Link to locAttr">#</a>
               </h3>
               
               <pre><code class="language-go">type locAttr uint8</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="batch" data-name="batch">
               <h3>
                  batch
                  <span class="badge">struct</span>
                  <a href="#batch" class="anchor" title="Link to batch">#</a>
               </h3>
               
               <p>A batch holds escape analysis state that's shared across an entire
batch of functions being analyzed at once.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type batch struct {
allLocs []*location
closures []closure
heapLoc location
mutatorLoc location
calleeLoc location
blankLoc location
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="closure" data-name="closure">
               <h3>
                  closure
                  <span class="badge">struct</span>
                  <a href="#closure" class="anchor" title="Link to closure">#</a>
               </h3>
               
               <p>A closure holds a closure expression and its spill hole (i.e.,
where the hole representing storing into its closure record).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type closure struct {
k hole
clo *ir.ClosureExpr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="edge" data-name="edge">
               <h3>
                  edge
                  <span class="badge">struct</span>
                  <a href="#edge" class="anchor" title="Link to edge">#</a>
               </h3>
               
               <p>An edge represents an assignment edge between two Go variables.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type edge struct {
src *location
derefs int
notes *note
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="escape" data-name="escape">
               <h3>
                  escape
                  <span class="badge">struct</span>
                  <a href="#escape" class="anchor" title="Link to escape">#</a>
               </h3>
               
               <p>An escape holds state specific to a single function being analyzed
within a batch.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type escape struct {
*batch
curfn *ir.Func
labels map[*types.Sym]labelState
loopDepth int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="hole" data-name="hole">
               <h3>
                  hole
                  <span class="badge">struct</span>
                  <a href="#hole" class="anchor" title="Link to hole">#</a>
               </h3>
               
               <p>A hole represents a context for evaluation of a Go
expression. E.g., when evaluating p in "x = **p", we'd have a hole
with dst==x and derefs==2.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type hole struct {
dst *location
derefs int
notes *note
addrtaken bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="location" data-name="location">
               <h3>
                  location
                  <span class="badge">struct</span>
                  <a href="#location" class="anchor" title="Link to location">#</a>
               </h3>
               
               <p>A location represents an abstract location that stores a Go
variable.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type location struct {
n ir.Node
curfn *ir.Func
edges []edge
loopDepth int
resultIndex int
derefs int
walkgen uint32
dst *location
dstEdgeIdx int
queued bool
attrs locAttr
paramEsc leaks
captured bool
reassigned bool
addrtaken bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="note" data-name="note">
               <h3>
                  note
                  <span class="badge">struct</span>
                  <a href="#note" class="anchor" title="Link to note">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type note struct {
next *note
where ir.Node
why string
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AddCallee" data-name="AddCallee">
               <h3>
                  AddCallee 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddCallee" class="anchor" title="Link to AddCallee">#</a>
               </h3>
               
               <p>AddCallee adds an assignment flow from l to the callee operand of a
call expression.</p>
               
               <pre><code class="language-go">func (l *leaks) AddCallee(derefs int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddHeap" data-name="AddHeap">
               <h3>
                  AddHeap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddHeap" class="anchor" title="Link to AddHeap">#</a>
               </h3>
               
               <p>AddHeap adds an assignment flow from l to the heap.</p>
               
               <pre><code class="language-go">func (l *leaks) AddHeap(derefs int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddMutator" data-name="AddMutator">
               <h3>
                  AddMutator 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddMutator" class="anchor" title="Link to AddMutator">#</a>
               </h3>
               
               <p>AddMutator adds a flow from l to the mutator (i.e., a pointer
operand of an indirect assignment statement).</p>
               
               <pre><code class="language-go">func (l *leaks) AddMutator(derefs int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddResult" data-name="AddResult">
               <h3>
                  AddResult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddResult" class="anchor" title="Link to AddResult">#</a>
               </h3>
               
               <p>AddResult adds an assignment flow from l to its function's i'th
result parameter.</p>
               
               <pre><code class="language-go">func (l *leaks) AddResult(i int, derefs int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Batch" data-name="Batch">
               <h3>
                  Batch 
                  <span class="badge">function</span>
                  
                  <a href="#Batch" class="anchor" title="Link to Batch">#</a>
               </h3>
               
               <p>Batch performs escape analysis on a minimal batch of
functions.</p>
               
               <pre><code class="language-go">func Batch(fns []*ir.Func, recursive bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Callee" data-name="Callee">
               <h3>
                  Callee 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Callee" class="anchor" title="Link to Callee">#</a>
               </h3>
               
               <p>Callee returns the minimum deref count of any assignment flow from
l to the callee operand of call expression. If no such flows exist,
Callee returns -1.</p>
               
               <pre><code class="language-go">func (l leaks) Callee() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Encode" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Encode" class="anchor" title="Link to Encode">#</a>
               </h3>
               
               <p>Encode converts l into a binary string for export data.</p>
               
               <pre><code class="language-go">func (l leaks) Encode() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fmt" data-name="Fmt">
               <h3>
                  Fmt 
                  <span class="badge">function</span>
                  
                  <a href="#Fmt" class="anchor" title="Link to Fmt">#</a>
               </h3>
               
               <p>Fmt is called from node printing to print information about escape analysis results.</p>
               
               <pre><code class="language-go">func Fmt(n ir.Node) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Funcs" data-name="Funcs">
               <h3>
                  Funcs 
                  <span class="badge">function</span>
                  
                  <a href="#Funcs" class="anchor" title="Link to Funcs">#</a>
               </h3>
               
               <pre><code class="language-go">func Funcs(all []*ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Heap" data-name="Heap">
               <h3>
                  Heap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Heap" class="anchor" title="Link to Heap">#</a>
               </h3>
               
               <p>Heap returns the minimum deref count of any assignment flow from l
to the heap. If no such flows exist, Heap returns -1.</p>
               
               <pre><code class="language-go">func (l leaks) Heap() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HeapAllocReason" data-name="HeapAllocReason">
               <h3>
                  HeapAllocReason 
                  <span class="badge">function</span>
                  
                  <a href="#HeapAllocReason" class="anchor" title="Link to HeapAllocReason">#</a>
               </h3>
               
               <p>HeapAllocReason returns the reason the given Node must be heap
allocated, or the empty string if it doesn't.</p>
               
               <pre><code class="language-go">func HeapAllocReason(n ir.Node) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mutator" data-name="Mutator">
               <h3>
                  Mutator 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mutator" class="anchor" title="Link to Mutator">#</a>
               </h3>
               
               <p>Mutator returns the minimum deref count of any assignment flow from
l to the pointer operand of an indirect assignment statement. If no
such flows exist, Mutator returns -1.</p>
               
               <pre><code class="language-go">func (l leaks) Mutator() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Optimize" data-name="Optimize">
               <h3>
                  Optimize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Optimize" class="anchor" title="Link to Optimize">#</a>
               </h3>
               
               <p>Optimize removes result flow paths that are equal in length or
longer than the shortest heap flow path.</p>
               
               <pre><code class="language-go">func (l *leaks) Optimize()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Result" data-name="Result">
               <h3>
                  Result 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Result" class="anchor" title="Link to Result">#</a>
               </h3>
               
               <p>Result returns the minimum deref count of any assignment flow from
l to its function's i'th result parameter. If no such flows exist,
Result returns -1.</p>
               
               <pre><code class="language-go">func (l leaks) Result(i int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <pre><code class="language-go">func (l *leaks) add(i int, derefs int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addr" data-name="addr">
               <h3>
                  addr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addr" class="anchor" title="Link to addr">#</a>
               </h3>
               
               <pre><code class="language-go">func (k hole) addr(where ir.Node, why string) hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addr" data-name="addr">
               <h3>
                  addr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addr" class="anchor" title="Link to addr">#</a>
               </h3>
               
               <p>addr evaluates an addressable expression n and returns a hole
that represents storing into the represented location.</p>
               
               <pre><code class="language-go">func (e *escape) addr(n ir.Node) hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addrs" data-name="addrs">
               <h3>
                  addrs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addrs" class="anchor" title="Link to addrs">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *escape) addrs(l ir.Nodes) []hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="asHole" data-name="asHole">
               <h3>
                  asHole 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#asHole" class="anchor" title="Link to asHole">#</a>
               </h3>
               
               <pre><code class="language-go">func (l *location) asHole() hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignHeap" data-name="assignHeap">
               <h3>
                  assignHeap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignHeap" class="anchor" title="Link to assignHeap">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *escape) assignHeap(src ir.Node, why string, where ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignList" data-name="assignList">
               <h3>
                  assignList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignList" class="anchor" title="Link to assignList">#</a>
               </h3>
               
               <p>assignList evaluates the assignment dsts... = srcs....</p>
               
               <pre><code class="language-go">func (e *escape) assignList(dsts []ir.Node, srcs []ir.Node, why string, where ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="block" data-name="block">
               <h3>
                  block 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#block" class="anchor" title="Link to block">#</a>
               </h3>
               
               <p>block is like stmts, but preserves loopDepth.</p>
               
               <pre><code class="language-go">func (e *escape) block(l ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="call" data-name="call">
               <h3>
                  call 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#call" class="anchor" title="Link to call">#</a>
               </h3>
               
               <p>call evaluates a call expressions, including builtin calls. ks
should contain the holes representing where the function callee's
results flows.</p>
               
               <pre><code class="language-go">func (e *escape) call(ks []hole, call ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="calleeHole" data-name="calleeHole">
               <h3>
                  calleeHole 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#calleeHole" class="anchor" title="Link to calleeHole">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *batch) calleeHole() hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="containsClosure" data-name="containsClosure">
               <h3>
                  containsClosure 
                  <span class="badge">function</span>
                  
                  <a href="#containsClosure" class="anchor" title="Link to containsClosure">#</a>
               </h3>
               
               <p>containsClosure reports whether c is a closure contained within f.</p>
               
               <pre><code class="language-go">func containsClosure(f *ir.Func, c *ir.Func) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyExpr" data-name="copyExpr">
               <h3>
                  copyExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#copyExpr" class="anchor" title="Link to copyExpr">#</a>
               </h3>
               
               <p>copyExpr creates and returns a new temporary variable within fn;
appends statements to init to declare and initialize it to expr;
and escape analyzes the data flow.</p>
               
               <pre><code class="language-go">func (e *escape) copyExpr(pos src.XPos, expr ir.Node, init *ir.Nodes) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dcl" data-name="dcl">
               <h3>
                  dcl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dcl" class="anchor" title="Link to dcl">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *escape) dcl(n *ir.Name) hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="deref" data-name="deref">
               <h3>
                  deref 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#deref" class="anchor" title="Link to deref">#</a>
               </h3>
               
               <pre><code class="language-go">func (k hole) deref(where ir.Node, why string) hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="discard" data-name="discard">
               <h3>
                  discard 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#discard" class="anchor" title="Link to discard">#</a>
               </h3>
               
               <p>discard evaluates an expression n for side-effects, but discards
its value.</p>
               
               <pre><code class="language-go">func (e *escape) discard(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="discardHole" data-name="discardHole">
               <h3>
                  discardHole 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#discardHole" class="anchor" title="Link to discardHole">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *batch) discardHole() hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="discards" data-name="discards">
               <h3>
                  discards 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#discards" class="anchor" title="Link to discards">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *escape) discards(l ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dotType" data-name="dotType">
               <h3>
                  dotType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dotType" class="anchor" title="Link to dotType">#</a>
               </h3>
               
               <pre><code class="language-go">func (k hole) dotType(t *types.Type, where ir.Node, why string) hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="explainFlow" data-name="explainFlow">
               <h3>
                  explainFlow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#explainFlow" class="anchor" title="Link to explainFlow">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *batch) explainFlow(pos string, dst *location, srcloc *location, derefs int, notes *note, explanation []*logopt.LoggedOpt) []*logopt.LoggedOpt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="explainLoc" data-name="explainLoc">
               <h3>
                  explainLoc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#explainLoc" class="anchor" title="Link to explainLoc">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *batch) explainLoc(l *location) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="explainPath" data-name="explainPath">
               <h3>
                  explainPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#explainPath" class="anchor" title="Link to explainPath">#</a>
               </h3>
               
               <p>explainPath prints an explanation of how src flows to the walk root.</p>
               
               <pre><code class="language-go">func (b *batch) explainPath(root *location, src *location) []*logopt.LoggedOpt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expr" data-name="expr">
               <h3>
                  expr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expr" class="anchor" title="Link to expr">#</a>
               </h3>
               
               <p>expr models evaluating an expression n and flowing the result into
hole k.</p>
               
               <pre><code class="language-go">func (e *escape) expr(k hole, n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprSkipInit" data-name="exprSkipInit">
               <h3>
                  exprSkipInit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprSkipInit" class="anchor" title="Link to exprSkipInit">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *escape) exprSkipInit(k hole, n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="finish" data-name="finish">
               <h3>
                  finish 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#finish" class="anchor" title="Link to finish">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *batch) finish(fns []*ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flow" data-name="flow">
               <h3>
                  flow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flow" class="anchor" title="Link to flow">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *batch) flow(k hole, src *location)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flowClosure" data-name="flowClosure">
               <h3>
                  flowClosure 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flowClosure" class="anchor" title="Link to flowClosure">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *batch) flowClosure(k hole, clo *ir.ClosureExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="get" data-name="get">
               <h3>
                  get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#get" class="anchor" title="Link to get">#</a>
               </h3>
               
               <pre><code class="language-go">func (l leaks) get(i int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goDeferStmt" data-name="goDeferStmt">
               <h3>
                  goDeferStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#goDeferStmt" class="anchor" title="Link to goDeferStmt">#</a>
               </h3>
               
               <p>goDeferStmt analyzes a "go" or "defer" statement.</p>
               
               <pre><code class="language-go">func (e *escape) goDeferStmt(n *ir.GoDeferStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasAttr" data-name="hasAttr">
               <h3>
                  hasAttr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasAttr" class="anchor" title="Link to hasAttr">#</a>
               </h3>
               
               <pre><code class="language-go">func (l *location) hasAttr(attr locAttr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasNonStringPointers" data-name="hasNonStringPointers">
               <h3>
                  hasNonStringPointers 
                  <span class="badge">function</span>
                  
                  <a href="#hasNonStringPointers" class="anchor" title="Link to hasNonStringPointers">#</a>
               </h3>
               
               <pre><code class="language-go">func hasNonStringPointers(t *types.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="heapHole" data-name="heapHole">
               <h3>
                  heapHole 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#heapHole" class="anchor" title="Link to heapHole">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *batch) heapHole() hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inMutualBatch" data-name="inMutualBatch">
               <h3>
                  inMutualBatch 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#inMutualBatch" class="anchor" title="Link to inMutualBatch">#</a>
               </h3>
               
               <p>inMutualBatch reports whether function fn is in the batch of
mutually recursive functions being analyzed. When this is true,
fn has not yet been analyzed, so its parameters and results
should be incorporated directly into the flow graph instead of
relying on its escape analysis tagging.</p>
               
               <pre><code class="language-go">func (b *batch) inMutualBatch(fn *ir.Name) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initFunc" data-name="initFunc">
               <h3>
                  initFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initFunc" class="anchor" title="Link to initFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *batch) initFunc(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isName" data-name="isName">
               <h3>
                  isName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isName" class="anchor" title="Link to isName">#</a>
               </h3>
               
               <pre><code class="language-go">func (l *location) isName(c ir.Class) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isSelfAssign" data-name="isSelfAssign">
               <h3>
                  isSelfAssign 
                  <span class="badge">function</span>
                  
                  <a href="#isSelfAssign" class="anchor" title="Link to isSelfAssign">#</a>
               </h3>
               
               <p>isSelfAssign reports whether assignment from src to dst can
be ignored by the escape analysis as it's effectively a self-assignment.</p>
               
               <pre><code class="language-go">func isSelfAssign(dst ir.Node, src ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isSliceSelfAssign" data-name="isSliceSelfAssign">
               <h3>
                  isSliceSelfAssign 
                  <span class="badge">function</span>
                  
                  <a href="#isSliceSelfAssign" class="anchor" title="Link to isSliceSelfAssign">#</a>
               </h3>
               
               <pre><code class="language-go">func isSliceSelfAssign(dst ir.Node, src ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="later" data-name="later">
               <h3>
                  later 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#later" class="anchor" title="Link to later">#</a>
               </h3>
               
               <p>later returns a new hole that flows into k, but some time later.
Its main effect is to prevent immediate reuse of temporary
variables introduced during Order.</p>
               
               <pre><code class="language-go">func (e *escape) later(k hole) hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="leakTo" data-name="leakTo">
               <h3>
                  leakTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#leakTo" class="anchor" title="Link to leakTo">#</a>
               </h3>
               
               <p>leak records that parameter l leaks to sink.</p>
               
               <pre><code class="language-go">func (l *location) leakTo(sink *location, derefs int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="leakTo" data-name="leakTo">
               <h3>
                  leakTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#leakTo" class="anchor" title="Link to leakTo">#</a>
               </h3>
               
               <p>leakTo records that parameter l leaks to sink.</p>
               
               <pre><code class="language-go">func (b *batch) leakTo(l *location, sink *location, derefs int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mayAffectMemory" data-name="mayAffectMemory">
               <h3>
                  mayAffectMemory 
                  <span class="badge">function</span>
                  
                  <a href="#mayAffectMemory" class="anchor" title="Link to mayAffectMemory">#</a>
               </h3>
               
               <p>mayAffectMemory reports whether evaluation of n may affect the program's
memory state. If the expression can't affect memory state, then it can be
safely ignored by the escape analysis.</p>
               
               <pre><code class="language-go">func mayAffectMemory(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mutate" data-name="mutate">
               <h3>
                  mutate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mutate" class="anchor" title="Link to mutate">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *escape) mutate(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mutatorHole" data-name="mutatorHole">
               <h3>
                  mutatorHole 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mutatorHole" class="anchor" title="Link to mutatorHole">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *batch) mutatorHole() hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newLoc" data-name="newLoc">
               <h3>
                  newLoc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newLoc" class="anchor" title="Link to newLoc">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *escape) newLoc(n ir.Node, persists bool) *location</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="note" data-name="note">
               <h3>
                  note 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#note" class="anchor" title="Link to note">#</a>
               </h3>
               
               <pre><code class="language-go">func (k hole) note(where ir.Node, why string) hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="oldLoc" data-name="oldLoc">
               <h3>
                  oldLoc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#oldLoc" class="anchor" title="Link to oldLoc">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *batch) oldLoc(n *ir.Name) *location</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="outlives" data-name="outlives">
               <h3>
                  outlives 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#outlives" class="anchor" title="Link to outlives">#</a>
               </h3>
               
               <p>outlives reports whether values stored in l may survive beyond
other's lifetime if stack allocated.</p>
               
               <pre><code class="language-go">func (b *batch) outlives(l *location, other *location) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="paramTag" data-name="paramTag">
               <h3>
                  paramTag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#paramTag" class="anchor" title="Link to paramTag">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *batch) paramTag(fn *ir.Func, narg int, f *types.Field) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseLeaks" data-name="parseLeaks">
               <h3>
                  parseLeaks 
                  <span class="badge">function</span>
                  
                  <a href="#parseLeaks" class="anchor" title="Link to parseLeaks">#</a>
               </h3>
               
               <p>parseLeaks parses a binary string representing a leaks.</p>
               
               <pre><code class="language-go">func parseLeaks(s string) leaks</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reassigned" data-name="reassigned">
               <h3>
                  reassigned 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reassigned" class="anchor" title="Link to reassigned">#</a>
               </h3>
               
               <p>reassigned marks the locations associated with the given holes as
reassigned, unless the location represents a variable declared and
assigned exactly once by where.</p>
               
               <pre><code class="language-go">func (e *escape) reassigned(ks []hole, where ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reportLeaks" data-name="reportLeaks">
               <h3>
                  reportLeaks 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reportLeaks" class="anchor" title="Link to reportLeaks">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *batch) reportLeaks(pos src.XPos, name string, esc leaks, sig *types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rewriteArgument" data-name="rewriteArgument">
               <h3>
                  rewriteArgument 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rewriteArgument" class="anchor" title="Link to rewriteArgument">#</a>
               </h3>
               
               <p>rewriteArgument rewrites the argument arg of the given call expression.
fn is the static callee function, if known.</p>
               
               <pre><code class="language-go">func (e *escape) rewriteArgument(arg ir.Node, call *ir.CallExpr, fn *ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="set" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#set" class="anchor" title="Link to set">#</a>
               </h3>
               
               <pre><code class="language-go">func (l *leaks) set(i int, derefs int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shift" data-name="shift">
               <h3>
                  shift 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shift" class="anchor" title="Link to shift">#</a>
               </h3>
               
               <pre><code class="language-go">func (k hole) shift(delta int) hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="spill" data-name="spill">
               <h3>
                  spill 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#spill" class="anchor" title="Link to spill">#</a>
               </h3>
               
               <p>spill allocates a new location associated with expression n, flows
its address to k, and returns a hole that flows values to it. It's
intended for use with most expressions that allocate storage.</p>
               
               <pre><code class="language-go">func (e *escape) spill(k hole, n ir.Node) hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmt" data-name="stmt">
               <h3>
                  stmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmt" class="anchor" title="Link to stmt">#</a>
               </h3>
               
               <p>stmt evaluates a single Go statement.</p>
               
               <pre><code class="language-go">func (e *escape) stmt(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmts" data-name="stmts">
               <h3>
                  stmts 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmts" class="anchor" title="Link to stmts">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *escape) stmts(l ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tagHole" data-name="tagHole">
               <h3>
                  tagHole 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tagHole" class="anchor" title="Link to tagHole">#</a>
               </h3>
               
               <p>tagHole returns a hole for evaluating an argument passed to param.
ks should contain the holes representing where the function
callee's results flows. fn is the statically-known callee function,
if any.</p>
               
               <pre><code class="language-go">func (e *escape) tagHole(ks []hole, fn *ir.Name, param *types.Field) hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="teeHole" data-name="teeHole">
               <h3>
                  teeHole 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#teeHole" class="anchor" title="Link to teeHole">#</a>
               </h3>
               
               <p>teeHole returns a new hole that flows into each hole of ks,
similar to the Unix tee(1) command.</p>
               
               <pre><code class="language-go">func (e *escape) teeHole(ks ...hole) hole</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unsafeValue" data-name="unsafeValue">
               <h3>
                  unsafeValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unsafeValue" class="anchor" title="Link to unsafeValue">#</a>
               </h3>
               
               <p>unsafeValue evaluates a uintptr-typed arithmetic expression looking
for conversions from an unsafe.Pointer.</p>
               
               <pre><code class="language-go">func (e *escape) unsafeValue(k hole, n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkAll" data-name="walkAll">
               <h3>
                  walkAll 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#walkAll" class="anchor" title="Link to walkAll">#</a>
               </h3>
               
               <p>walkAll computes the minimal dereferences between all pairs of
locations.</p>
               
               <pre><code class="language-go">func (b *batch) walkAll()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkFunc" data-name="walkFunc">
               <h3>
                  walkFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#walkFunc" class="anchor" title="Link to walkFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *batch) walkFunc(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkOne" data-name="walkOne">
               <h3>
                  walkOne 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#walkOne" class="anchor" title="Link to walkOne">#</a>
               </h3>
               
               <p>walkOne computes the minimal number of dereferences from root to
all other locations.</p>
               
               <pre><code class="language-go">func (b *batch) walkOne(root *location, walkgen uint32, enqueue func(*location))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="with" data-name="with">
               <h3>
                  with 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#with" class="anchor" title="Link to with">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *batch) with(fn *ir.Func) *escape</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>