<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - escape</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>escape</code>
         </h1>
         <hr />
         
         <article class="global" data-name="escFuncUnknown">
            <h2>escFuncUnknown</h2>
            <hr />
            
            <pre><code>escFuncUnknown</code></pre>
         </article>
         
         <article class="global" data-name="escFuncPlanned">
            <h2>escFuncPlanned</h2>
            <hr />
            
            <pre><code>escFuncPlanned</code></pre>
         </article>
         
         <article class="global" data-name="escFuncStarted">
            <h2>escFuncStarted</h2>
            <hr />
            
            <pre><code>escFuncStarted</code></pre>
         </article>
         
         <article class="global" data-name="escFuncTagged">
            <h2>escFuncTagged</h2>
            <hr />
            
            <pre><code>escFuncTagged</code></pre>
         </article>
         
         <article class="global" data-name="looping">
            <h2>looping</h2>
            <hr />
            
            <pre><code>looping labelState</code></pre>
         </article>
         
         <article class="global" data-name="nonlooping">
            <h2>nonlooping</h2>
            <hr />
            
            <pre><code>nonlooping</code></pre>
         </article>
         
         <article class="global" data-name="attrEscapes">
            <h2>attrEscapes</h2>
            <hr />
            
            <p>attrEscapes indicates whether the represented variable's address
escapes; that is, whether the variable must be heap allocated.</p>
            
            <pre><code>attrEscapes locAttr</code></pre>
         </article>
         
         <article class="global" data-name="attrPersists">
            <h2>attrPersists</h2>
            <hr />
            
            <p>attrPersists indicates whether the represented expression's
address outlives the statement; that is, whether its storage
cannot be immediately reused.</p>
            
            <pre><code>attrPersists</code></pre>
         </article>
         
         <article class="global" data-name="attrMutates">
            <h2>attrMutates</h2>
            <hr />
            
            <p>attrMutates indicates whether pointers that are reachable from
this location may have their addressed memory mutated. This is
used to detect string->[]byte conversions that can be safely
optimized away.</p>
            
            <pre><code>attrMutates</code></pre>
         </article>
         
         <article class="global" data-name="attrCalls">
            <h2>attrCalls</h2>
            <hr />
            
            <p>attrCalls indicates whether closures that are reachable from this
location may be called without tracking their results. This is
used to better optimize indirect closure calls.</p>
            
            <pre><code>attrCalls</code></pre>
         </article>
         
         <article class="global" data-name="leakHeap">
            <h2>leakHeap</h2>
            <hr />
            
            <pre><code>leakHeap</code></pre>
         </article>
         
         <article class="global" data-name="leakMutator">
            <h2>leakMutator</h2>
            <hr />
            
            <pre><code>leakMutator</code></pre>
         </article>
         
         <article class="global" data-name="leakCallee">
            <h2>leakCallee</h2>
            <hr />
            
            <pre><code>leakCallee</code></pre>
         </article>
         
         <article class="global" data-name="leakResult0">
            <h2>leakResult0</h2>
            <hr />
            
            <pre><code>leakResult0</code></pre>
         </article>
         
         <article class="global" data-name="numEscResults">
            <h2>numEscResults</h2>
            <hr />
            
            <pre><code>numEscResults</code></pre>
         </article>
         
         <article class="global" data-name="leakTagCache">
            <h2>leakTagCache</h2>
            <hr />
            
            <pre><code>leakTagCache</code></pre>
         </article>
          
         <article class="struct" data-name="batch">
            <h2>type batch struct</h2>
            <hr />
            
            <p>A batch holds escape analysis state that's shared across an entire
batch of functions being analyzed at once.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">allLocs []*location
closures []closure
heapLoc location
mutatorLoc location
calleeLoc location
blankLoc location</code></pre>
         </article>
         
         <article class="struct" data-name="closure">
            <h2>type closure struct</h2>
            <hr />
            
            <p>A closure holds a closure expression and its spill hole (i.e.,
where the hole representing storing into its closure record).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">k hole
clo *ir.ClosureExpr</code></pre>
         </article>
         
         <article class="struct" data-name="escape">
            <h2>type escape struct</h2>
            <hr />
            
            <p>An escape holds state specific to a single function being analyzed
within a batch.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">*batch
curfn *ir.Func
labels *ast.MapType
loopDepth int</code></pre>
         </article>
         
         <article class="struct" data-name="location">
            <h2>type location struct</h2>
            <hr />
            
            <p>A location represents an abstract location that stores a Go
variable.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">n ir.Node
curfn *ir.Func
edges []edge
loopDepth int
resultIndex int
derefs int
walkgen uint32
dst *location
dstEdgeIdx int
queued bool
attrs locAttr
paramEsc leaks
captured bool
reassigned bool
addrtaken bool</code></pre>
         </article>
         
         <article class="struct" data-name="edge">
            <h2>type edge struct</h2>
            <hr />
            
            <p>An edge represents an assignment edge between two Go variables.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">src *location
derefs int
notes *note</code></pre>
         </article>
         
         <article class="struct" data-name="hole">
            <h2>type hole struct</h2>
            <hr />
            
            <p>A hole represents a context for evaluation of a Go
expression. E.g., when evaluating p in "x = **p", we'd have a hole
with dst==x and derefs==2.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">dst *location
derefs int
notes *note
addrtaken bool</code></pre>
         </article>
         
         <article class="struct" data-name="note">
            <h2>type note struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">next *note
where ir.Node
why string</code></pre>
         </article>
          
         <article class="function" data-name="addr">
            <h2>addr</h2>
            <hr />
            
            <p>addr evaluates an addressable expression n and returns a hole
that represents storing into the represented location.</p>
            
            <pre><code>func addr(n ir.Node) hole</code></pre>
         </article>
         
         <article class="function" data-name="mutate">
            <h2>mutate</h2>
            <hr />
            
            <pre><code>func mutate(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="addrs">
            <h2>addrs</h2>
            <hr />
            
            <pre><code>func addrs(l ir.Nodes) []hole</code></pre>
         </article>
         
         <article class="function" data-name="assignHeap">
            <h2>assignHeap</h2>
            <hr />
            
            <pre><code>func assignHeap(src ir.Node, why string, where ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="assignList">
            <h2>assignList</h2>
            <hr />
            
            <p>assignList evaluates the assignment dsts... = srcs....</p>
            
            <pre><code>func assignList(dsts []ir.Node, srcs []ir.Node, why string, where ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="reassigned">
            <h2>reassigned</h2>
            <hr />
            
            <p>reassigned marks the locations associated with the given holes as
reassigned, unless the location represents a variable declared and
assigned exactly once by where.</p>
            
            <pre><code>func reassigned(ks []hole, where ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="Funcs">
            <h2>Funcs</h2>
            <hr />
            
            <pre><code>func Funcs(all []*ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="Batch">
            <h2>Batch</h2>
            <hr />
            
            <p>Batch performs escape analysis on a minimal batch of
functions.</p>
            
            <pre><code>func Batch(fns []*ir.Func, recursive bool)</code></pre>
         </article>
         
         <article class="function" data-name="with">
            <h2>with</h2>
            <hr />
            
            <pre><code>func with(fn *ir.Func) *escape</code></pre>
         </article>
         
         <article class="function" data-name="initFunc">
            <h2>initFunc</h2>
            <hr />
            
            <pre><code>func initFunc(fn *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="walkFunc">
            <h2>walkFunc</h2>
            <hr />
            
            <pre><code>func walkFunc(fn *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="flowClosure">
            <h2>flowClosure</h2>
            <hr />
            
            <pre><code>func flowClosure(k hole, clo *ir.ClosureExpr)</code></pre>
         </article>
         
         <article class="function" data-name="finish">
            <h2>finish</h2>
            <hr />
            
            <pre><code>func finish(fns []*ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="inMutualBatch">
            <h2>inMutualBatch</h2>
            <hr />
            
            <p>inMutualBatch reports whether function fn is in the batch of
mutually recursive functions being analyzed. When this is true,
fn has not yet been analyzed, so its parameters and results
should be incorporated directly into the flow graph instead of
relying on its escape analysis tagging.</p>
            
            <pre><code>func inMutualBatch(fn *ir.Name) bool</code></pre>
         </article>
         
         <article class="function" data-name="paramTag">
            <h2>paramTag</h2>
            <hr />
            
            <pre><code>func paramTag(fn *ir.Func, narg int, f *types.Field) string</code></pre>
         </article>
         
         <article class="function" data-name="reportLeaks">
            <h2>reportLeaks</h2>
            <hr />
            
            <pre><code>func reportLeaks(pos src.XPos, name string, esc leaks, sig *types.Type)</code></pre>
         </article>
         
         <article class="function" data-name="expr">
            <h2>expr</h2>
            <hr />
            
            <p>expr models evaluating an expression n and flowing the result into
hole k.</p>
            
            <pre><code>func expr(k hole, n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="exprSkipInit">
            <h2>exprSkipInit</h2>
            <hr />
            
            <pre><code>func exprSkipInit(k hole, n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="unsafeValue">
            <h2>unsafeValue</h2>
            <hr />
            
            <p>unsafeValue evaluates a uintptr-typed arithmetic expression looking
for conversions from an unsafe.Pointer.</p>
            
            <pre><code>func unsafeValue(k hole, n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="discard">
            <h2>discard</h2>
            <hr />
            
            <p>discard evaluates an expression n for side-effects, but discards
its value.</p>
            
            <pre><code>func discard(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="discards">
            <h2>discards</h2>
            <hr />
            
            <pre><code>func discards(l ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="spill">
            <h2>spill</h2>
            <hr />
            
            <p>spill allocates a new location associated with expression n, flows
its address to k, and returns a hole that flows values to it. It's
intended for use with most expressions that allocate storage.</p>
            
            <pre><code>func spill(k hole, n ir.Node) hole</code></pre>
         </article>
         
         <article class="function" data-name="hasAttr">
            <h2>hasAttr</h2>
            <hr />
            
            <pre><code>func hasAttr(attr locAttr) bool</code></pre>
         </article>
         
         <article class="function" data-name="asHole">
            <h2>asHole</h2>
            <hr />
            
            <pre><code>func asHole() hole</code></pre>
         </article>
         
         <article class="function" data-name="leakTo">
            <h2>leakTo</h2>
            <hr />
            
            <p>leak records that parameter l leaks to sink.</p>
            
            <pre><code>func leakTo(sink *location, derefs int)</code></pre>
         </article>
         
         <article class="function" data-name="leakTo">
            <h2>leakTo</h2>
            <hr />
            
            <p>leakTo records that parameter l leaks to sink.</p>
            
            <pre><code>func leakTo(l *location, sink *location, derefs int)</code></pre>
         </article>
         
         <article class="function" data-name="isName">
            <h2>isName</h2>
            <hr />
            
            <pre><code>func isName(c ir.Class) bool</code></pre>
         </article>
         
         <article class="function" data-name="note">
            <h2>note</h2>
            <hr />
            
            <pre><code>func note(where ir.Node, why string) hole</code></pre>
         </article>
         
         <article class="function" data-name="shift">
            <h2>shift</h2>
            <hr />
            
            <pre><code>func shift(delta int) hole</code></pre>
         </article>
         
         <article class="function" data-name="deref">
            <h2>deref</h2>
            <hr />
            
            <pre><code>func deref(where ir.Node, why string) hole</code></pre>
         </article>
         
         <article class="function" data-name="addr">
            <h2>addr</h2>
            <hr />
            
            <pre><code>func addr(where ir.Node, why string) hole</code></pre>
         </article>
         
         <article class="function" data-name="dotType">
            <h2>dotType</h2>
            <hr />
            
            <pre><code>func dotType(t *types.Type, where ir.Node, why string) hole</code></pre>
         </article>
         
         <article class="function" data-name="flow">
            <h2>flow</h2>
            <hr />
            
            <pre><code>func flow(k hole, src *location)</code></pre>
         </article>
         
         <article class="function" data-name="heapHole">
            <h2>heapHole</h2>
            <hr />
            
            <pre><code>func heapHole() hole</code></pre>
         </article>
         
         <article class="function" data-name="mutatorHole">
            <h2>mutatorHole</h2>
            <hr />
            
            <pre><code>func mutatorHole() hole</code></pre>
         </article>
         
         <article class="function" data-name="calleeHole">
            <h2>calleeHole</h2>
            <hr />
            
            <pre><code>func calleeHole() hole</code></pre>
         </article>
         
         <article class="function" data-name="discardHole">
            <h2>discardHole</h2>
            <hr />
            
            <pre><code>func discardHole() hole</code></pre>
         </article>
         
         <article class="function" data-name="oldLoc">
            <h2>oldLoc</h2>
            <hr />
            
            <pre><code>func oldLoc(n *ir.Name) *location</code></pre>
         </article>
         
         <article class="function" data-name="newLoc">
            <h2>newLoc</h2>
            <hr />
            
            <pre><code>func newLoc(n ir.Node, persists bool) *location</code></pre>
         </article>
         
         <article class="function" data-name="teeHole">
            <h2>teeHole</h2>
            <hr />
            
            <p>teeHole returns a new hole that flows into each hole of ks,
similar to the Unix tee(1) command.</p>
            
            <pre><code>func teeHole(ks ...hole) hole</code></pre>
         </article>
         
         <article class="function" data-name="later">
            <h2>later</h2>
            <hr />
            
            <p>later returns a new hole that flows into k, but some time later.
Its main effect is to prevent immediate reuse of temporary
variables introduced during Order.</p>
            
            <pre><code>func later(k hole) hole</code></pre>
         </article>
         
         <article class="function" data-name="Fmt">
            <h2>Fmt</h2>
            <hr />
            
            <p>Fmt is called from node printing to print information about escape analysis results.</p>
            
            <pre><code>func Fmt(n ir.Node) string</code></pre>
         </article>
         
         <article class="function" data-name="Heap">
            <h2>Heap</h2>
            <hr />
            
            <p>Heap returns the minimum deref count of any assignment flow from l
to the heap. If no such flows exist, Heap returns -1.</p>
            
            <pre><code>func Heap() int</code></pre>
         </article>
         
         <article class="function" data-name="Mutator">
            <h2>Mutator</h2>
            <hr />
            
            <p>Mutator returns the minimum deref count of any assignment flow from
l to the pointer operand of an indirect assignment statement. If no
such flows exist, Mutator returns -1.</p>
            
            <pre><code>func Mutator() int</code></pre>
         </article>
         
         <article class="function" data-name="Callee">
            <h2>Callee</h2>
            <hr />
            
            <p>Callee returns the minimum deref count of any assignment flow from
l to the callee operand of call expression. If no such flows exist,
Callee returns -1.</p>
            
            <pre><code>func Callee() int</code></pre>
         </article>
         
         <article class="function" data-name="Result">
            <h2>Result</h2>
            <hr />
            
            <p>Result returns the minimum deref count of any assignment flow from
l to its function's i'th result parameter. If no such flows exist,
Result returns -1.</p>
            
            <pre><code>func Result(i int) int</code></pre>
         </article>
         
         <article class="function" data-name="AddHeap">
            <h2>AddHeap</h2>
            <hr />
            
            <p>AddHeap adds an assignment flow from l to the heap.</p>
            
            <pre><code>func AddHeap(derefs int)</code></pre>
         </article>
         
         <article class="function" data-name="AddMutator">
            <h2>AddMutator</h2>
            <hr />
            
            <p>AddMutator adds a flow from l to the mutator (i.e., a pointer
operand of an indirect assignment statement).</p>
            
            <pre><code>func AddMutator(derefs int)</code></pre>
         </article>
         
         <article class="function" data-name="AddCallee">
            <h2>AddCallee</h2>
            <hr />
            
            <p>AddCallee adds an assignment flow from l to the callee operand of a
call expression.</p>
            
            <pre><code>func AddCallee(derefs int)</code></pre>
         </article>
         
         <article class="function" data-name="AddResult">
            <h2>AddResult</h2>
            <hr />
            
            <p>AddResult adds an assignment flow from l to its function's i'th
result parameter.</p>
            
            <pre><code>func AddResult(i int, derefs int)</code></pre>
         </article>
         
         <article class="function" data-name="get">
            <h2>get</h2>
            <hr />
            
            <pre><code>func get(i int) int</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <pre><code>func add(i int, derefs int)</code></pre>
         </article>
         
         <article class="function" data-name="set">
            <h2>set</h2>
            <hr />
            
            <pre><code>func set(i int, derefs int)</code></pre>
         </article>
         
         <article class="function" data-name="Optimize">
            <h2>Optimize</h2>
            <hr />
            
            <p>Optimize removes result flow paths that are equal in length or
longer than the shortest heap flow path.</p>
            
            <pre><code>func Optimize()</code></pre>
         </article>
         
         <article class="function" data-name="Encode">
            <h2>Encode</h2>
            <hr />
            
            <p>Encode converts l into a binary string for export data.</p>
            
            <pre><code>func Encode() string</code></pre>
         </article>
         
         <article class="function" data-name="parseLeaks">
            <h2>parseLeaks</h2>
            <hr />
            
            <p>parseLeaks parses a binary string representing a leaks.</p>
            
            <pre><code>func parseLeaks(s string) leaks</code></pre>
         </article>
         
         <article class="function" data-name="walkAll">
            <h2>walkAll</h2>
            <hr />
            
            <p>walkAll computes the minimal dereferences between all pairs of
locations.</p>
            
            <pre><code>func walkAll()</code></pre>
         </article>
         
         <article class="function" data-name="walkOne">
            <h2>walkOne</h2>
            <hr />
            
            <p>walkOne computes the minimal number of dereferences from root to
all other locations.</p>
            
            <pre><code>func walkOne(root *location, walkgen uint32, enqueue func)</code></pre>
         </article>
         
         <article class="function" data-name="explainPath">
            <h2>explainPath</h2>
            <hr />
            
            <p>explainPath prints an explanation of how src flows to the walk root.</p>
            
            <pre><code>func explainPath(root *location, src *location) []*logopt.LoggedOpt</code></pre>
         </article>
         
         <article class="function" data-name="explainFlow">
            <h2>explainFlow</h2>
            <hr />
            
            <pre><code>func explainFlow(pos string, dst *location, srcloc *location, derefs int, notes *note, explanation []*logopt.LoggedOpt) []*logopt.LoggedOpt</code></pre>
         </article>
         
         <article class="function" data-name="explainLoc">
            <h2>explainLoc</h2>
            <hr />
            
            <pre><code>func explainLoc(l *location) string</code></pre>
         </article>
         
         <article class="function" data-name="outlives">
            <h2>outlives</h2>
            <hr />
            
            <p>outlives reports whether values stored in l may survive beyond
other's lifetime if stack allocated.</p>
            
            <pre><code>func outlives(l *location, other *location) bool</code></pre>
         </article>
         
         <article class="function" data-name="containsClosure">
            <h2>containsClosure</h2>
            <hr />
            
            <p>containsClosure reports whether c is a closure contained within f.</p>
            
            <pre><code>func containsClosure(f *ir.Func, c *ir.Func) bool</code></pre>
         </article>
         
         <article class="function" data-name="stmt">
            <h2>stmt</h2>
            <hr />
            
            <p>stmt evaluates a single Go statement.</p>
            
            <pre><code>func stmt(n ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="stmts">
            <h2>stmts</h2>
            <hr />
            
            <pre><code>func stmts(l ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="block">
            <h2>block</h2>
            <hr />
            
            <p>block is like stmts, but preserves loopDepth.</p>
            
            <pre><code>func block(l ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="dcl">
            <h2>dcl</h2>
            <hr />
            
            <pre><code>func dcl(n *ir.Name) hole</code></pre>
         </article>
         
         <article class="function" data-name="call">
            <h2>call</h2>
            <hr />
            
            <p>call evaluates a call expressions, including builtin calls. ks
should contain the holes representing where the function callee's
results flows.</p>
            
            <pre><code>func call(ks []hole, call ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="goDeferStmt">
            <h2>goDeferStmt</h2>
            <hr />
            
            <p>goDeferStmt analyzes a "go" or "defer" statement.</p>
            
            <pre><code>func goDeferStmt(n *ir.GoDeferStmt)</code></pre>
         </article>
         
         <article class="function" data-name="rewriteArgument">
            <h2>rewriteArgument</h2>
            <hr />
            
            <p>rewriteArgument rewrites the argument arg of the given call expression.
fn is the static callee function, if known.</p>
            
            <pre><code>func rewriteArgument(arg ir.Node, call *ir.CallExpr, fn *ir.Name)</code></pre>
         </article>
         
         <article class="function" data-name="copyExpr">
            <h2>copyExpr</h2>
            <hr />
            
            <p>copyExpr creates and returns a new temporary variable within fn;
appends statements to init to declare and initialize it to expr;
and escape analyzes the data flow.</p>
            
            <pre><code>func copyExpr(pos src.XPos, expr ir.Node, init *ir.Nodes) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="tagHole">
            <h2>tagHole</h2>
            <hr />
            
            <p>tagHole returns a hole for evaluating an argument passed to param.
ks should contain the holes representing where the function
callee's results flows. fn is the statically-known callee function,
if any.</p>
            
            <pre><code>func tagHole(ks []hole, fn *ir.Name, param *types.Field) hole</code></pre>
         </article>
         
         <article class="function" data-name="hasNonStringPointers">
            <h2>hasNonStringPointers</h2>
            <hr />
            
            <pre><code>func hasNonStringPointers(t *types.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="isSliceSelfAssign">
            <h2>isSliceSelfAssign</h2>
            <hr />
            
            <pre><code>func isSliceSelfAssign(dst ir.Node, src ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="isSelfAssign">
            <h2>isSelfAssign</h2>
            <hr />
            
            <p>isSelfAssign reports whether assignment from src to dst can
be ignored by the escape analysis as it's effectively a self-assignment.</p>
            
            <pre><code>func isSelfAssign(dst ir.Node, src ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="mayAffectMemory">
            <h2>mayAffectMemory</h2>
            <hr />
            
            <p>mayAffectMemory reports whether evaluation of n may affect the program's
memory state. If the expression can't affect memory state, then it can be
safely ignored by the escape analysis.</p>
            
            <pre><code>func mayAffectMemory(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="HeapAllocReason">
            <h2>HeapAllocReason</h2>
            <hr />
            
            <p>HeapAllocReason returns the reason the given Node must be heap
allocated, or the empty string if it doesn't.</p>
            
            <pre><code>func HeapAllocReason(n ir.Node) string</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
