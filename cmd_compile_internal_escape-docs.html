<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - escape</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>escape</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/src"
"strings"
"fmt"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/logopt"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/src"
"cmd/compile/internal/base"
"math"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/logopt"
"cmd/internal/src"
"fmt"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"fmt"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/logopt"
"cmd/compile/internal/types"
"fmt"
"cmd/compile/internal/ir"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="attrCalls">
               <h3>
                  attrCalls 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>attrCalls indicates whether closures that are reachable from this
location may be called without tracking their results. This is
used to better optimize indirect closure calls.</p>
               
               <pre><code>const attrCalls</code></pre>
            </article>
            
            <article class="global" data-name="attrEscapes">
               <h3>
                  attrEscapes 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>attrEscapes indicates whether the represented variable's address
escapes; that is, whether the variable must be heap allocated.</p>
               
               <pre><code>const attrEscapes locAttr = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="attrMutates">
               <h3>
                  attrMutates 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>attrMutates indicates whether pointers that are reachable from
this location may have their addressed memory mutated. This is
used to detect string->[]byte conversions that can be safely
optimized away.</p>
               
               <pre><code>const attrMutates</code></pre>
            </article>
            
            <article class="global" data-name="attrPersists">
               <h3>
                  attrPersists 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>attrPersists indicates whether the represented expression's
address outlives the statement; that is, whether its storage
cannot be immediately reused.</p>
               
               <pre><code>const attrPersists</code></pre>
            </article>
            
            <article class="global" data-name="escFuncPlanned">
               <h3>
                  escFuncPlanned 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const escFuncPlanned</code></pre>
            </article>
            
            <article class="global" data-name="escFuncStarted">
               <h3>
                  escFuncStarted 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const escFuncStarted</code></pre>
            </article>
            
            <article class="global" data-name="escFuncTagged">
               <h3>
                  escFuncTagged 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const escFuncTagged</code></pre>
            </article>
            
            <article class="global" data-name="escFuncUnknown">
               <h3>
                  escFuncUnknown 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const escFuncUnknown = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="leakCallee">
               <h3>
                  leakCallee 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const leakCallee</code></pre>
            </article>
            
            <article class="global" data-name="leakHeap">
               <h3>
                  leakHeap 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const leakHeap = iota</code></pre>
            </article>
            
            <article class="global" data-name="leakMutator">
               <h3>
                  leakMutator 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const leakMutator</code></pre>
            </article>
            
            <article class="global" data-name="leakResult0">
               <h3>
                  leakResult0 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const leakResult0</code></pre>
            </article>
            
            <article class="global" data-name="leakTagCache">
               <h3>
                  leakTagCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var leakTagCache = map[leaks]string{...}</code></pre>
            </article>
            
            <article class="global" data-name="looping">
               <h3>
                  looping 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const looping labelState = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="nonlooping">
               <h3>
                  nonlooping 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nonlooping</code></pre>
            </article>
            
            <article class="global" data-name="numEscResults">
               <h3>
                  numEscResults 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const numEscResults = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="labelState">
               <h3>
                  labelState
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Mark labels that have no backjumps to them as not increasing e.loopdepth.</p>
               
               <pre><code>type labelState int</code></pre>
            </article>
            
            <article class="type" data-name="leaks">
               <h3>
                  leaks
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A leaks represents a set of assignment flows from a parameter to
the heap, mutator, callee, or to any of its function's (first
numEscResults) result parameters.</p>
               
               <pre><code>type leaks [8]uint8</code></pre>
            </article>
            
            <article class="type" data-name="locAttr">
               <h3>
                  locAttr
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type locAttr uint8</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="batch">
               <h3>
                  batch
                  <span class="badge">struct</span>
               </h3>
               
               <p>A batch holds escape analysis state that's shared across an entire
batch of functions being analyzed at once.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type batch struct {
allLocs []*location
closures []closure
heapLoc location
mutatorLoc location
calleeLoc location
blankLoc location
}</code></pre>
            </article>
            
            <article class="struct" data-name="closure">
               <h3>
                  closure
                  <span class="badge">struct</span>
               </h3>
               
               <p>A closure holds a closure expression and its spill hole (i.e.,
where the hole representing storing into its closure record).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type closure struct {
k hole
clo *ir.ClosureExpr
}</code></pre>
            </article>
            
            <article class="struct" data-name="edge">
               <h3>
                  edge
                  <span class="badge">struct</span>
               </h3>
               
               <p>An edge represents an assignment edge between two Go variables.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type edge struct {
src *location
derefs int
notes *note
}</code></pre>
            </article>
            
            <article class="struct" data-name="escape">
               <h3>
                  escape
                  <span class="badge">struct</span>
               </h3>
               
               <p>An escape holds state specific to a single function being analyzed
within a batch.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type escape struct {
*batch
curfn *ir.Func
labels map[*types.Sym]labelState
loopDepth int
}</code></pre>
            </article>
            
            <article class="struct" data-name="hole">
               <h3>
                  hole
                  <span class="badge">struct</span>
               </h3>
               
               <p>A hole represents a context for evaluation of a Go
expression. E.g., when evaluating p in "x = **p", we'd have a hole
with dst==x and derefs==2.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type hole struct {
dst *location
derefs int
notes *note
addrtaken bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="location">
               <h3>
                  location
                  <span class="badge">struct</span>
               </h3>
               
               <p>A location represents an abstract location that stores a Go
variable.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type location struct {
n ir.Node
curfn *ir.Func
edges []edge
loopDepth int
resultIndex int
derefs int
walkgen uint32
dst *location
dstEdgeIdx int
queued bool
attrs locAttr
paramEsc leaks
captured bool
reassigned bool
addrtaken bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="note">
               <h3>
                  note
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type note struct {
next *note
where ir.Node
why string
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="AddCallee">
               <h3>
                  AddCallee 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddCallee adds an assignment flow from l to the callee operand of a
call expression.</p>
               
               <pre><code>func (l *leaks) AddCallee(derefs int)</code></pre>
            </article>
            
            <article class="function" data-name="AddHeap">
               <h3>
                  AddHeap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddHeap adds an assignment flow from l to the heap.</p>
               
               <pre><code>func (l *leaks) AddHeap(derefs int)</code></pre>
            </article>
            
            <article class="function" data-name="AddMutator">
               <h3>
                  AddMutator 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddMutator adds a flow from l to the mutator (i.e., a pointer
operand of an indirect assignment statement).</p>
               
               <pre><code>func (l *leaks) AddMutator(derefs int)</code></pre>
            </article>
            
            <article class="function" data-name="AddResult">
               <h3>
                  AddResult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddResult adds an assignment flow from l to its function's i'th
result parameter.</p>
               
               <pre><code>func (l *leaks) AddResult(i int, derefs int)</code></pre>
            </article>
            
            <article class="function" data-name="Batch">
               <h3>
                  Batch 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Batch performs escape analysis on a minimal batch of
functions.</p>
               
               <pre><code>func Batch(fns []*ir.Func, recursive bool)</code></pre>
            </article>
            
            <article class="function" data-name="Callee">
               <h3>
                  Callee 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Callee returns the minimum deref count of any assignment flow from
l to the callee operand of call expression. If no such flows exist,
Callee returns -1.</p>
               
               <pre><code>func (l leaks) Callee() int</code></pre>
            </article>
            
            <article class="function" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Encode converts l into a binary string for export data.</p>
               
               <pre><code>func (l leaks) Encode() string</code></pre>
            </article>
            
            <article class="function" data-name="Fmt">
               <h3>
                  Fmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Fmt is called from node printing to print information about escape analysis results.</p>
               
               <pre><code>func Fmt(n ir.Node) string</code></pre>
            </article>
            
            <article class="function" data-name="Funcs">
               <h3>
                  Funcs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func Funcs(all []*ir.Func)</code></pre>
            </article>
            
            <article class="function" data-name="Heap">
               <h3>
                  Heap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Heap returns the minimum deref count of any assignment flow from l
to the heap. If no such flows exist, Heap returns -1.</p>
               
               <pre><code>func (l leaks) Heap() int</code></pre>
            </article>
            
            <article class="function" data-name="HeapAllocReason">
               <h3>
                  HeapAllocReason 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>HeapAllocReason returns the reason the given Node must be heap
allocated, or the empty string if it doesn't.</p>
               
               <pre><code>func HeapAllocReason(n ir.Node) string</code></pre>
            </article>
            
            <article class="function" data-name="Mutator">
               <h3>
                  Mutator 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Mutator returns the minimum deref count of any assignment flow from
l to the pointer operand of an indirect assignment statement. If no
such flows exist, Mutator returns -1.</p>
               
               <pre><code>func (l leaks) Mutator() int</code></pre>
            </article>
            
            <article class="function" data-name="Optimize">
               <h3>
                  Optimize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Optimize removes result flow paths that are equal in length or
longer than the shortest heap flow path.</p>
               
               <pre><code>func (l *leaks) Optimize()</code></pre>
            </article>
            
            <article class="function" data-name="Result">
               <h3>
                  Result 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Result returns the minimum deref count of any assignment flow from
l to its function's i'th result parameter. If no such flows exist,
Result returns -1.</p>
               
               <pre><code>func (l leaks) Result(i int) int</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *leaks) add(i int, derefs int)</code></pre>
            </article>
            
            <article class="function" data-name="addr">
               <h3>
                  addr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (k hole) addr(where ir.Node, why string) hole</code></pre>
            </article>
            
            <article class="function" data-name="addr">
               <h3>
                  addr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addr evaluates an addressable expression n and returns a hole
that represents storing into the represented location.</p>
               
               <pre><code>func (e *escape) addr(n ir.Node) hole</code></pre>
            </article>
            
            <article class="function" data-name="addrs">
               <h3>
                  addrs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *escape) addrs(l ir.Nodes) []hole</code></pre>
            </article>
            
            <article class="function" data-name="asHole">
               <h3>
                  asHole 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *location) asHole() hole</code></pre>
            </article>
            
            <article class="function" data-name="assignHeap">
               <h3>
                  assignHeap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *escape) assignHeap(src ir.Node, why string, where ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="assignList">
               <h3>
                  assignList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>assignList evaluates the assignment dsts... = srcs....</p>
               
               <pre><code>func (e *escape) assignList(dsts []ir.Node, srcs []ir.Node, why string, where ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="block">
               <h3>
                  block 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>block is like stmts, but preserves loopDepth.</p>
               
               <pre><code>func (e *escape) block(l ir.Nodes)</code></pre>
            </article>
            
            <article class="function" data-name="call">
               <h3>
                  call 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>call evaluates a call expressions, including builtin calls. ks
should contain the holes representing where the function callee's
results flows.</p>
               
               <pre><code>func (e *escape) call(ks []hole, call ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="calleeHole">
               <h3>
                  calleeHole 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) calleeHole() hole</code></pre>
            </article>
            
            <article class="function" data-name="containsClosure">
               <h3>
                  containsClosure 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>containsClosure reports whether c is a closure contained within f.</p>
               
               <pre><code>func containsClosure(f *ir.Func, c *ir.Func) bool</code></pre>
            </article>
            
            <article class="function" data-name="copyExpr">
               <h3>
                  copyExpr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>copyExpr creates and returns a new temporary variable within fn;
appends statements to init to declare and initialize it to expr;
and escape analyzes the data flow.</p>
               
               <pre><code>func (e *escape) copyExpr(pos src.XPos, expr ir.Node, init *ir.Nodes) *ir.Name</code></pre>
            </article>
            
            <article class="function" data-name="dcl">
               <h3>
                  dcl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *escape) dcl(n *ir.Name) hole</code></pre>
            </article>
            
            <article class="function" data-name="deref">
               <h3>
                  deref 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (k hole) deref(where ir.Node, why string) hole</code></pre>
            </article>
            
            <article class="function" data-name="discard">
               <h3>
                  discard 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>discard evaluates an expression n for side-effects, but discards
its value.</p>
               
               <pre><code>func (e *escape) discard(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="discardHole">
               <h3>
                  discardHole 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) discardHole() hole</code></pre>
            </article>
            
            <article class="function" data-name="discards">
               <h3>
                  discards 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *escape) discards(l ir.Nodes)</code></pre>
            </article>
            
            <article class="function" data-name="dotType">
               <h3>
                  dotType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (k hole) dotType(t *types.Type, where ir.Node, why string) hole</code></pre>
            </article>
            
            <article class="function" data-name="explainFlow">
               <h3>
                  explainFlow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) explainFlow(pos string, dst *location, srcloc *location, derefs int, notes *note, explanation []*logopt.LoggedOpt) []*logopt.LoggedOpt</code></pre>
            </article>
            
            <article class="function" data-name="explainLoc">
               <h3>
                  explainLoc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) explainLoc(l *location) string</code></pre>
            </article>
            
            <article class="function" data-name="explainPath">
               <h3>
                  explainPath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>explainPath prints an explanation of how src flows to the walk root.</p>
               
               <pre><code>func (b *batch) explainPath(root *location, src *location) []*logopt.LoggedOpt</code></pre>
            </article>
            
            <article class="function" data-name="expr">
               <h3>
                  expr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>expr models evaluating an expression n and flowing the result into
hole k.</p>
               
               <pre><code>func (e *escape) expr(k hole, n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="exprSkipInit">
               <h3>
                  exprSkipInit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *escape) exprSkipInit(k hole, n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="finish">
               <h3>
                  finish 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) finish(fns []*ir.Func)</code></pre>
            </article>
            
            <article class="function" data-name="flow">
               <h3>
                  flow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) flow(k hole, src *location)</code></pre>
            </article>
            
            <article class="function" data-name="flowClosure">
               <h3>
                  flowClosure 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) flowClosure(k hole, clo *ir.ClosureExpr)</code></pre>
            </article>
            
            <article class="function" data-name="get">
               <h3>
                  get 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l leaks) get(i int) int</code></pre>
            </article>
            
            <article class="function" data-name="goDeferStmt">
               <h3>
                  goDeferStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>goDeferStmt analyzes a "go" or "defer" statement.</p>
               
               <pre><code>func (e *escape) goDeferStmt(n *ir.GoDeferStmt)</code></pre>
            </article>
            
            <article class="function" data-name="hasAttr">
               <h3>
                  hasAttr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *location) hasAttr(attr locAttr) bool</code></pre>
            </article>
            
            <article class="function" data-name="hasNonStringPointers">
               <h3>
                  hasNonStringPointers 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func hasNonStringPointers(t *types.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="heapHole">
               <h3>
                  heapHole 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) heapHole() hole</code></pre>
            </article>
            
            <article class="function" data-name="inMutualBatch">
               <h3>
                  inMutualBatch 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>inMutualBatch reports whether function fn is in the batch of
mutually recursive functions being analyzed. When this is true,
fn has not yet been analyzed, so its parameters and results
should be incorporated directly into the flow graph instead of
relying on its escape analysis tagging.</p>
               
               <pre><code>func (b *batch) inMutualBatch(fn *ir.Name) bool</code></pre>
            </article>
            
            <article class="function" data-name="initFunc">
               <h3>
                  initFunc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) initFunc(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function" data-name="isName">
               <h3>
                  isName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *location) isName(c ir.Class) bool</code></pre>
            </article>
            
            <article class="function" data-name="isSelfAssign">
               <h3>
                  isSelfAssign 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isSelfAssign reports whether assignment from src to dst can
be ignored by the escape analysis as it's effectively a self-assignment.</p>
               
               <pre><code>func isSelfAssign(dst ir.Node, src ir.Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="isSliceSelfAssign">
               <h3>
                  isSliceSelfAssign 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isSliceSelfAssign(dst ir.Node, src ir.Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="later">
               <h3>
                  later 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>later returns a new hole that flows into k, but some time later.
Its main effect is to prevent immediate reuse of temporary
variables introduced during Order.</p>
               
               <pre><code>func (e *escape) later(k hole) hole</code></pre>
            </article>
            
            <article class="function" data-name="leakTo">
               <h3>
                  leakTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>leakTo records that parameter l leaks to sink.</p>
               
               <pre><code>func (b *batch) leakTo(l *location, sink *location, derefs int)</code></pre>
            </article>
            
            <article class="function" data-name="leakTo">
               <h3>
                  leakTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>leak records that parameter l leaks to sink.</p>
               
               <pre><code>func (l *location) leakTo(sink *location, derefs int)</code></pre>
            </article>
            
            <article class="function" data-name="mayAffectMemory">
               <h3>
                  mayAffectMemory 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>mayAffectMemory reports whether evaluation of n may affect the program's
memory state. If the expression can't affect memory state, then it can be
safely ignored by the escape analysis.</p>
               
               <pre><code>func mayAffectMemory(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="mutate">
               <h3>
                  mutate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *escape) mutate(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="mutatorHole">
               <h3>
                  mutatorHole 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) mutatorHole() hole</code></pre>
            </article>
            
            <article class="function" data-name="newLoc">
               <h3>
                  newLoc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *escape) newLoc(n ir.Node, persists bool) *location</code></pre>
            </article>
            
            <article class="function" data-name="note">
               <h3>
                  note 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (k hole) note(where ir.Node, why string) hole</code></pre>
            </article>
            
            <article class="function" data-name="oldLoc">
               <h3>
                  oldLoc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) oldLoc(n *ir.Name) *location</code></pre>
            </article>
            
            <article class="function" data-name="outlives">
               <h3>
                  outlives 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>outlives reports whether values stored in l may survive beyond
other's lifetime if stack allocated.</p>
               
               <pre><code>func (b *batch) outlives(l *location, other *location) bool</code></pre>
            </article>
            
            <article class="function" data-name="paramTag">
               <h3>
                  paramTag 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) paramTag(fn *ir.Func, narg int, f *types.Field) string</code></pre>
            </article>
            
            <article class="function" data-name="parseLeaks">
               <h3>
                  parseLeaks 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseLeaks parses a binary string representing a leaks.</p>
               
               <pre><code>func parseLeaks(s string) leaks</code></pre>
            </article>
            
            <article class="function" data-name="reassigned">
               <h3>
                  reassigned 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>reassigned marks the locations associated with the given holes as
reassigned, unless the location represents a variable declared and
assigned exactly once by where.</p>
               
               <pre><code>func (e *escape) reassigned(ks []hole, where ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="reportLeaks">
               <h3>
                  reportLeaks 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) reportLeaks(pos src.XPos, name string, esc leaks, sig *types.Type)</code></pre>
            </article>
            
            <article class="function" data-name="rewriteArgument">
               <h3>
                  rewriteArgument 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>rewriteArgument rewrites the argument arg of the given call expression.
fn is the static callee function, if known.</p>
               
               <pre><code>func (e *escape) rewriteArgument(arg ir.Node, call *ir.CallExpr, fn *ir.Name)</code></pre>
            </article>
            
            <article class="function" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *leaks) set(i int, derefs int)</code></pre>
            </article>
            
            <article class="function" data-name="shift">
               <h3>
                  shift 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (k hole) shift(delta int) hole</code></pre>
            </article>
            
            <article class="function" data-name="spill">
               <h3>
                  spill 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>spill allocates a new location associated with expression n, flows
its address to k, and returns a hole that flows values to it. It's
intended for use with most expressions that allocate storage.</p>
               
               <pre><code>func (e *escape) spill(k hole, n ir.Node) hole</code></pre>
            </article>
            
            <article class="function" data-name="stmt">
               <h3>
                  stmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>stmt evaluates a single Go statement.</p>
               
               <pre><code>func (e *escape) stmt(n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="stmts">
               <h3>
                  stmts 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *escape) stmts(l ir.Nodes)</code></pre>
            </article>
            
            <article class="function" data-name="tagHole">
               <h3>
                  tagHole 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>tagHole returns a hole for evaluating an argument passed to param.
ks should contain the holes representing where the function
callee's results flows. fn is the statically-known callee function,
if any.</p>
               
               <pre><code>func (e *escape) tagHole(ks []hole, fn *ir.Name, param *types.Field) hole</code></pre>
            </article>
            
            <article class="function" data-name="teeHole">
               <h3>
                  teeHole 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>teeHole returns a new hole that flows into each hole of ks,
similar to the Unix tee(1) command.</p>
               
               <pre><code>func (e *escape) teeHole(ks ...hole) hole</code></pre>
            </article>
            
            <article class="function" data-name="unsafeValue">
               <h3>
                  unsafeValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>unsafeValue evaluates a uintptr-typed arithmetic expression looking
for conversions from an unsafe.Pointer.</p>
               
               <pre><code>func (e *escape) unsafeValue(k hole, n ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="walkAll">
               <h3>
                  walkAll 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>walkAll computes the minimal dereferences between all pairs of
locations.</p>
               
               <pre><code>func (b *batch) walkAll()</code></pre>
            </article>
            
            <article class="function" data-name="walkFunc">
               <h3>
                  walkFunc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) walkFunc(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function" data-name="walkOne">
               <h3>
                  walkOne 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>walkOne computes the minimal number of dereferences from root to
all other locations.</p>
               
               <pre><code>func (b *batch) walkOne(root *location, walkgen uint32, enqueue func(*location))</code></pre>
            </article>
            
            <article class="function" data-name="with">
               <h3>
                  with 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) with(fn *ir.Func) *escape</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
