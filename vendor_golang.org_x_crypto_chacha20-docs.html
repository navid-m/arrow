<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>chacha20 - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>chacha20</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"crypto/cipher"
"encoding/binary"
"errors"
"math/bits"
"golang.org/x/crypto/internal/alias"
"golang.org/x/sys/cpu"
"runtime"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="KeySize" data-name="KeySize">
               <h3>
                  KeySize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KeySize" class="anchor" title="Link to KeySize">#</a>
               </h3>
               
                  <p class="doc-comment">KeySize is the size of the key used by this cipher, in bytes.</p>
               
               <pre><code class="language-go">const KeySize = 32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NonceSize" data-name="NonceSize">
               <h3>
                  NonceSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NonceSize" class="anchor" title="Link to NonceSize">#</a>
               </h3>
               
                  <p class="doc-comment">NonceSize is the size of the nonce used with the standard variant of this
cipher, in bytes.
Note that this is too short to be safely generated at random if the same
key is reused more than 2³² times.</p>
               
               <pre><code class="language-go">const NonceSize = 12</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NonceSizeX" data-name="NonceSizeX">
               <h3>
                  NonceSizeX 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NonceSizeX" class="anchor" title="Link to NonceSizeX">#</a>
               </h3>
               
                  <p class="doc-comment">NonceSizeX is the size of the nonce used with the XChaCha20 variant of
this cipher, in bytes.</p>
               
               <pre><code class="language-go">const NonceSizeX = 24</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ cipher.Stream = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="blockSize" data-name="blockSize">
               <h3>
                  blockSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#blockSize" class="anchor" title="Link to blockSize">#</a>
               </h3>
               
               <pre><code class="language-go">const blockSize = 64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bufSize" data-name="bufSize">
               <h3>
                  bufSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bufSize" class="anchor" title="Link to bufSize">#</a>
               </h3>
               
               <pre><code class="language-go">const bufSize = blockSize</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bufSize" data-name="bufSize">
               <h3>
                  bufSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bufSize" class="anchor" title="Link to bufSize">#</a>
               </h3>
               
               <pre><code class="language-go">const bufSize = 256</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bufSize" data-name="bufSize">
               <h3>
                  bufSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bufSize" class="anchor" title="Link to bufSize">#</a>
               </h3>
               
               <pre><code class="language-go">const bufSize = 256</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bufSize" data-name="bufSize">
               <h3>
                  bufSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bufSize" class="anchor" title="Link to bufSize">#</a>
               </h3>
               
               <pre><code class="language-go">const bufSize = 256</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="haveAsm" data-name="haveAsm">
               <h3>
                  haveAsm 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#haveAsm" class="anchor" title="Link to haveAsm">#</a>
               </h3>
               
               <pre><code class="language-go">var haveAsm = cpu.S390X.HasVX</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="j0" data-name="j0">
               <h3>
                  j0 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#j0" class="anchor" title="Link to j0">#</a>
               </h3>
               
                  <p class="doc-comment">The constant first 4 words of the ChaCha20 state.</p>
               
               <pre><code class="language-go">const j0 uint32 = 0x61707865</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="j1" data-name="j1">
               <h3>
                  j1 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#j1" class="anchor" title="Link to j1">#</a>
               </h3>
               
                  <p class="doc-comment">The constant first 4 words of the ChaCha20 state.</p>
               
               <pre><code class="language-go">const j1 uint32 = 0x3320646e</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="j2" data-name="j2">
               <h3>
                  j2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#j2" class="anchor" title="Link to j2">#</a>
               </h3>
               
                  <p class="doc-comment">The constant first 4 words of the ChaCha20 state.</p>
               
               <pre><code class="language-go">const j2 uint32 = 0x79622d32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="j3" data-name="j3">
               <h3>
                  j3 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#j3" class="anchor" title="Link to j3">#</a>
               </h3>
               
                  <p class="doc-comment">The constant first 4 words of the ChaCha20 state.</p>
               
               <pre><code class="language-go">const j3 uint32 = 0x6b206574</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unaligned" data-name="unaligned">
               <h3>
                  unaligned 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#unaligned" class="anchor" title="Link to unaligned">#</a>
               </h3>
               
                  <p class="doc-comment">Platforms that have fast unaligned 32-bit little endian accesses.</p>
               
               <pre><code class="language-go">const unaligned = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Cipher" data-name="Cipher">
               <h3>
                  Cipher
                  <span class="badge">struct</span>
                  <a href="#Cipher" class="anchor" title="Link to Cipher">#</a>
               </h3>
               
               <p>Cipher is a stateful instance of ChaCha20 or XChaCha20 using a particular key
and nonce. A *Cipher implements the cipher.Stream interface.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Cipher struct {
key [8]uint32
counter uint32
nonce [3]uint32
buf [bufSize]byte
len int
overflow bool
precompDone bool
p1 uint32
p5 uint32
p9 uint32
p13 uint32
p2 uint32
p6 uint32
p10 uint32
p14 uint32
p3 uint32
p7 uint32
p11 uint32
p15 uint32
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="HChaCha20" data-name="HChaCha20">
               <h3>
                  HChaCha20 
                  <span class="badge">function</span>
                  
                  <a href="#HChaCha20" class="anchor" title="Link to HChaCha20">#</a>
               </h3>
               
               <p>HChaCha20 uses the ChaCha20 core to generate a derived key from a 32 bytes
key and a 16 bytes nonce. It returns an error if key or nonce have any other
length. It is used as part of the XChaCha20 construction.</p>
               
               <pre><code class="language-go">func HChaCha20(key []byte, nonce []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewUnauthenticatedCipher" data-name="NewUnauthenticatedCipher">
               <h3>
                  NewUnauthenticatedCipher 
                  <span class="badge">function</span>
                  
                  <a href="#NewUnauthenticatedCipher" class="anchor" title="Link to NewUnauthenticatedCipher">#</a>
               </h3>
               
               <p>NewUnauthenticatedCipher creates a new ChaCha20 stream cipher with the given
32 bytes key and a 12 or 24 bytes nonce. If a nonce of 24 bytes is provided,
the XChaCha20 construction will be used. It returns an error if key or nonce
have any other length.
Note that ChaCha20, like all stream ciphers, is not authenticated and allows
attackers to silently tamper with the plaintext. For this reason, it is more
appropriate as a building block than as a standalone encryption mechanism.
Instead, consider using package golang.org/x/crypto/chacha20poly1305.</p>
               
               <pre><code class="language-go">func NewUnauthenticatedCipher(key []byte, nonce []byte) (*Cipher, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetCounter" data-name="SetCounter">
               <h3>
                  SetCounter 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetCounter" class="anchor" title="Link to SetCounter">#</a>
               </h3>
               
               <p>SetCounter sets the Cipher counter. The next invocation of XORKeyStream will
behave as if (64 * counter) bytes had been encrypted so far.
To prevent accidental counter reuse, SetCounter panics if counter is less
than the current value.
Note that the execution time of XORKeyStream is not independent of the
counter value.</p>
               
               <pre><code class="language-go">func (s *Cipher) SetCounter(counter uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="XORKeyStream" data-name="XORKeyStream">
               <h3>
                  XORKeyStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#XORKeyStream" class="anchor" title="Link to XORKeyStream">#</a>
               </h3>
               
               <p>XORKeyStream XORs each byte in the given slice with a byte from the
cipher's key stream. Dst and src must overlap entirely or not at all.
If len(dst) < len(src), XORKeyStream will panic. It is acceptable
to pass a dst bigger than src, and in that case, XORKeyStream will
only update dst[:len(src)] and will not touch the rest of dst.
Multiple calls to XORKeyStream behave as if the concatenation of
the src buffers was passed in a single run. That is, Cipher
maintains state and does not reset at each XORKeyStream call.</p>
               
               <pre><code class="language-go">func (s *Cipher) XORKeyStream(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addXor" data-name="addXor">
               <h3>
                  addXor 
                  <span class="badge">function</span>
                  
                  <a href="#addXor" class="anchor" title="Link to addXor">#</a>
               </h3>
               
               <p>addXor reads a little endian uint32 from src, XORs it with (a + b) and
places the result in little endian byte order in dst.</p>
               
               <pre><code class="language-go">func addXor(dst []byte, src []byte, a uint32, b uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chaCha20_ctr32_vsx" data-name="chaCha20_ctr32_vsx">
               <h3>
                  chaCha20_ctr32_vsx 
                  <span class="badge">function</span>
                  
                  <a href="#chaCha20_ctr32_vsx" class="anchor" title="Link to chaCha20_ctr32_vsx">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func chaCha20_ctr32_vsx(out *byte, inp *byte, len int, key *[8]uint32, counter *uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hChaCha20" data-name="hChaCha20">
               <h3>
                  hChaCha20 
                  <span class="badge">function</span>
                  
                  <a href="#hChaCha20" class="anchor" title="Link to hChaCha20">#</a>
               </h3>
               
               <pre><code class="language-go">func hChaCha20(out []byte, key []byte, nonce []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newUnauthenticatedCipher" data-name="newUnauthenticatedCipher">
               <h3>
                  newUnauthenticatedCipher 
                  <span class="badge">function</span>
                  
                  <a href="#newUnauthenticatedCipher" class="anchor" title="Link to newUnauthenticatedCipher">#</a>
               </h3>
               
               <pre><code class="language-go">func newUnauthenticatedCipher(c *Cipher, key []byte, nonce []byte) (*Cipher, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="quarterRound" data-name="quarterRound">
               <h3>
                  quarterRound 
                  <span class="badge">function</span>
                  
                  <a href="#quarterRound" class="anchor" title="Link to quarterRound">#</a>
               </h3>
               
               <p>quarterRound is the core of ChaCha20. It shuffles the bits of 4 state words.
It's executed 4 times for each of the 20 ChaCha20 rounds, operating on all 16
words each round, in columnar or diagonal groups of 4 at a time.</p>
               
               <pre><code class="language-go">func quarterRound(a uint32, b uint32, c uint32, d uint32) (uint32, uint32, uint32, uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="xorKeyStreamBlocks" data-name="xorKeyStreamBlocks">
               <h3>
                  xorKeyStreamBlocks 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#xorKeyStreamBlocks" class="anchor" title="Link to xorKeyStreamBlocks">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Cipher) xorKeyStreamBlocks(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="xorKeyStreamBlocks" data-name="xorKeyStreamBlocks">
               <h3>
                  xorKeyStreamBlocks 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#xorKeyStreamBlocks" class="anchor" title="Link to xorKeyStreamBlocks">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *Cipher) xorKeyStreamBlocks(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="xorKeyStreamBlocks" data-name="xorKeyStreamBlocks">
               <h3>
                  xorKeyStreamBlocks 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#xorKeyStreamBlocks" class="anchor" title="Link to xorKeyStreamBlocks">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *Cipher) xorKeyStreamBlocks(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="xorKeyStreamBlocks" data-name="xorKeyStreamBlocks">
               <h3>
                  xorKeyStreamBlocks 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#xorKeyStreamBlocks" class="anchor" title="Link to xorKeyStreamBlocks">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *Cipher) xorKeyStreamBlocks(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="xorKeyStreamBlocksGeneric" data-name="xorKeyStreamBlocksGeneric">
               <h3>
                  xorKeyStreamBlocksGeneric 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#xorKeyStreamBlocksGeneric" class="anchor" title="Link to xorKeyStreamBlocksGeneric">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Cipher) xorKeyStreamBlocksGeneric(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="xorKeyStreamVX" data-name="xorKeyStreamVX">
               <h3>
                  xorKeyStreamVX 
                  <span class="badge">function</span>
                  
                  <a href="#xorKeyStreamVX" class="anchor" title="Link to xorKeyStreamVX">#</a>
               </h3>
               
               <p>xorKeyStreamVX is an assembly implementation of XORKeyStream. It must only
be called when the vector facility is available. Implementation in asm_s390x.s.
go:noescape</p>
               
               <pre><code class="language-go">func xorKeyStreamVX(dst []byte, src []byte, key *[8]uint32, nonce *[3]uint32, counter *uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="xorKeyStreamVX" data-name="xorKeyStreamVX">
               <h3>
                  xorKeyStreamVX 
                  <span class="badge">function</span>
                  
                  <a href="#xorKeyStreamVX" class="anchor" title="Link to xorKeyStreamVX">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func xorKeyStreamVX(dst []byte, src []byte, key *[8]uint32, nonce *[3]uint32, counter *uint32)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>