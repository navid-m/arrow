<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - bigmod</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="crypto_internal_fips140_bigmod__asm-docs.html">_asm</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>bigmod</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>_ "crypto/internal/fips140/check"
"crypto/internal/fips140deps/byteorder"
"errors"
"math/bits"
"crypto/internal/fips140deps/cpu"
"crypto/internal/impl"
"unsafe"
"unsafe"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="_S">
               <h3>
                  _S 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>_S is the size in bytes of our limbs.</p>
               
               <pre><code>const _S = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="_W">
               <h3>
                  _W 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>_W is the size in bits of our limbs.</p>
               
               <pre><code>const _W = bits.UintSize</code></pre>
            </article>
            
            <article class="global" data-name="no">
               <h3>
                  no 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const no = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="preallocLimbs">
               <h3>
                  preallocLimbs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const preallocLimbs = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="preallocTarget">
               <h3>
                  preallocTarget 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>preallocTarget is the size in bits of the numbers used to implement the most
common and most performant RSA key size. It's also enough to cover some of
the operations of key sizes up to 4096.</p>
               
               <pre><code>const preallocTarget = 2048</code></pre>
            </article>
            
            <article class="global" data-name="supportADX">
               <h3>
                  supportADX 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var supportADX = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="yes">
               <h3>
                  yes 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const yes = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="choice">
               <h3>
                  choice
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>choice represents a constant-time boolean. The value of choice is always
either 1 or 0. We use an int instead of bool in order to make decisions in
constant time by turning it into a mask.</p>
               
               <pre><code>type choice uint</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Modulus">
               <h3>
                  Modulus
                  <span class="badge">struct</span>
               </h3>
               
               <p>Modulus is used for modular arithmetic, precomputing relevant constants.
A Modulus can leak the exact number of bits needed to store its value
and is stored without padding. Its actual value is still kept secret.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Modulus struct {
nat *Nat
odd bool
m0inv uint
rr *Nat
}</code></pre>
            </article>
            
            <article class="struct" data-name="Nat">
               <h3>
                  Nat
                  <span class="badge">struct</span>
               </h3>
               
               <p>Nat represents an arbitrary natural number
Each Nat has an announced length, which is the number of limbs it has stored.
Operations on this number are allowed to leak this length, but will not leak
any information about the values contained in those limbs.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Nat struct {
limbs []uint
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add computes x = x + y mod m.
The length of both operands must be the same as the modulus. Both operands
must already be reduced modulo m.
go:norace</p>
               
               <pre><code>func (x *Nat) Add(y *Nat, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="BitLen">
               <h3>
                  BitLen 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BitLen returns the size of m in bits.</p>
               
               <pre><code>func (m *Modulus) BitLen() int</code></pre>
            </article>
            
            <article class="function" data-name="BitLenVarTime">
               <h3>
                  BitLenVarTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BitLenVarTime returns the actual size of x in bits.
The actual size of x (but nothing more) leaks through timing side-channels.
Note that this is ordinarily secret, as opposed to the announced size of x.</p>
               
               <pre><code>func (x *Nat) BitLenVarTime() int</code></pre>
            </article>
            
            <article class="function" data-name="Bits">
               <h3>
                  Bits 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bits returns x as a little-endian slice of uint. The length of the slice
matches the announced length of x. The result and x share the same underlying
array.</p>
               
               <pre><code>func (x *Nat) Bits() []uint</code></pre>
            </article>
            
            <article class="function" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bytes returns x as a zero-extended big-endian byte slice. The size of the
slice will match the size of m.
x must have the same size as m and it must be less than or equal to m.</p>
               
               <pre><code>func (x *Nat) Bytes(m *Modulus) []byte</code></pre>
            </article>
            
            <article class="function" data-name="DivShortVarTime">
               <h3>
                  DivShortVarTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DivShortVarTime calculates x = x / y and returns the remainder.
It panics if y is zero.
go:norace</p>
               
               <pre><code>func (x *Nat) DivShortVarTime(y uint) uint</code></pre>
            </article>
            
            <article class="function" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Equal returns 1 if x == y, and 0 otherwise.
Both operands must have the same announced length.
go:norace</p>
               
               <pre><code>func (x *Nat) Equal(y *Nat) choice</code></pre>
            </article>
            
            <article class="function" data-name="Exp">
               <h3>
                  Exp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Exp calculates out = x^e mod m.
The exponent e is represented in big-endian order. The output will be resized
to the size of m and overwritten. x must already be reduced modulo m.
m must be odd, or Exp will panic.
go:norace</p>
               
               <pre><code>func (out *Nat) Exp(x *Nat, e []byte, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="ExpShortVarTime">
               <h3>
                  ExpShortVarTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ExpShortVarTime calculates out = x^e mod m.
The output will be resized to the size of m and overwritten. x must already
be reduced modulo m. This leaks the exponent through timing side-channels.
m must be odd, or ExpShortVarTime will panic.</p>
               
               <pre><code>func (out *Nat) ExpShortVarTime(x *Nat, e uint, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="ExpandFor">
               <h3>
                  ExpandFor 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ExpandFor ensures x has the right size to work with operations modulo m.
The announced size of x must be smaller than or equal to that of m.</p>
               
               <pre><code>func (x *Nat) ExpandFor(m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="GCDVarTime">
               <h3>
                  GCDVarTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GCDVarTime calculates x = GCD(a, b) where at least one of a or b is odd, and
both are non-zero. If GCDVarTime returns an error, x is not modified.
The output will be resized to the size of the larger of a and b.</p>
               
               <pre><code>func (x *Nat) GCDVarTime(a *Nat, b *Nat) (*Nat, error)</code></pre>
            </article>
            
            <article class="function" data-name="InverseVarTime">
               <h3>
                  InverseVarTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>InverseVarTime calculates x = a⁻¹ mod m and returns (x, true) if a is
invertible. Otherwise, InverseVarTime returns (x, false) and x is not
modified.
a must be reduced modulo m, but doesn't need to have the same size. The
output will be resized to the size of m and overwritten.
go:norace</p>
               
               <pre><code>func (x *Nat) InverseVarTime(a *Nat, m *Modulus) (*Nat, bool)</code></pre>
            </article>
            
            <article class="function" data-name="IsMinusOne">
               <h3>
                  IsMinusOne 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsMinusOne returns 1 if x == -1 mod m, and 0 otherwise.
The length of x must be the same as the modulus. x must already be reduced
modulo m.
go:norace</p>
               
               <pre><code>func (x *Nat) IsMinusOne(m *Modulus) choice</code></pre>
            </article>
            
            <article class="function" data-name="IsOdd">
               <h3>
                  IsOdd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsOdd returns 1 if x is odd, and 0 otherwise.</p>
               
               <pre><code>func (x *Nat) IsOdd() choice</code></pre>
            </article>
            
            <article class="function" data-name="IsOne">
               <h3>
                  IsOne 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsOne returns 1 if x == 1, and 0 otherwise.
go:norace</p>
               
               <pre><code>func (x *Nat) IsOne() choice</code></pre>
            </article>
            
            <article class="function" data-name="IsZero">
               <h3>
                  IsZero 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsZero returns 1 if x == 0, and 0 otherwise.
go:norace</p>
               
               <pre><code>func (x *Nat) IsZero() choice</code></pre>
            </article>
            
            <article class="function" data-name="Mod">
               <h3>
                  Mod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Mod calculates out = x mod m.
This works regardless how large the value of x is.
The output will be resized to the size of m and overwritten.
go:norace</p>
               
               <pre><code>func (out *Nat) Mod(x *Nat, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="Mul">
               <h3>
                  Mul 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Mul calculates x = x * y mod m.
The length of both operands must be the same as the modulus. Both operands
must already be reduced modulo m.
go:norace</p>
               
               <pre><code>func (x *Nat) Mul(y *Nat, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="Nat">
               <h3>
                  Nat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Nat returns m as a Nat.</p>
               
               <pre><code>func (m *Modulus) Nat() *Nat</code></pre>
            </article>
            
            <article class="function" data-name="NewModulus">
               <h3>
                  NewModulus 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewModulus creates a new Modulus from a slice of big-endian bytes. The
modulus must be greater than one.
The number of significant bits and whether the modulus is even is leaked
through timing side-channels.</p>
               
               <pre><code>func NewModulus(b []byte) (*Modulus, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewModulusProduct">
               <h3>
                  NewModulusProduct 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewModulusProduct creates a new Modulus from the product of two numbers
represented as big-endian byte slices. The result must be greater than one.
go:norace</p>
               
               <pre><code>func NewModulusProduct(a []byte, b []byte) (*Modulus, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewNat">
               <h3>
                  NewNat 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewNat returns a new nat with a size of zero, just like new(Nat), but with
the preallocated capacity to hold a number of up to preallocTarget bits.
NewNat inlines, so the allocation can live on the stack.</p>
               
               <pre><code>func NewNat() *Nat</code></pre>
            </article>
            
            <article class="function" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetBytes assigns x = b, where b is a slice of big-endian bytes.
SetBytes returns an error if b >= m.
The output will be resized to the size of m and overwritten.
go:norace</p>
               
               <pre><code>func (x *Nat) SetBytes(b []byte, m *Modulus) (*Nat, error)</code></pre>
            </article>
            
            <article class="function" data-name="SetOverflowingBytes">
               <h3>
                  SetOverflowingBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetOverflowingBytes assigns x = b, where b is a slice of big-endian bytes.
SetOverflowingBytes returns an error if b has a longer bit length than m, but
reduces overflowing values up to 2^⌈log2(m)⌉ - 1.
The output will be resized to the size of m and overwritten.</p>
               
               <pre><code>func (x *Nat) SetOverflowingBytes(b []byte, m *Modulus) (*Nat, error)</code></pre>
            </article>
            
            <article class="function" data-name="SetUint">
               <h3>
                  SetUint 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetUint assigns x = y.
The output will be resized to a single limb and overwritten.</p>
               
               <pre><code>func (x *Nat) SetUint(y uint) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="ShiftRightVarTime">
               <h3>
                  ShiftRightVarTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ShiftRightVarTime sets x = x >> n.
The announced length of x is unchanged.
go:norace</p>
               
               <pre><code>func (x *Nat) ShiftRightVarTime(n uint) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Size returns the size of m in bytes.</p>
               
               <pre><code>func (m *Modulus) Size() int</code></pre>
            </article>
            
            <article class="function" data-name="Sub">
               <h3>
                  Sub 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Sub computes x = x - y mod m.
The length of both operands must be the same as the modulus. Both operands
must already be reduced modulo m.
go:norace</p>
               
               <pre><code>func (x *Nat) Sub(y *Nat, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="SubOne">
               <h3>
                  SubOne 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SubOne computes x = x - 1 mod m.
The length of x must be the same as the modulus.</p>
               
               <pre><code>func (x *Nat) SubOne(m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="TrailingZeroBitsVarTime">
               <h3>
                  TrailingZeroBitsVarTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TrailingZeroBitsVarTime returns the number of trailing zero bits in x.</p>
               
               <pre><code>func (x *Nat) TrailingZeroBitsVarTime() uint</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>add computes x += y and returns the carry.
Both operands must have the same announced length.
go:norace</p>
               
               <pre><code>func (x *Nat) add(y *Nat) (c uint)</code></pre>
            </article>
            
            <article class="function" data-name="addMulVVW">
               <h3>
                  addMulVVW 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addMulVVW multiplies the multi-word value x by the single-word value y,
adding the result to the multi-word value z and returning the final carry.
It can be thought of as one row of a pen-and-paper column multiplication.
go:norace</p>
               
               <pre><code>func addMulVVW(z []uint, x []uint, y uint) (carry uint)</code></pre>
            </article>
            
            <article class="function" data-name="addMulVVW1024">
               <h3>
                  addMulVVW1024 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addMulVVW1024(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function" data-name="addMulVVW1024">
               <h3>
                  addMulVVW1024 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func addMulVVW1024(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function" data-name="addMulVVW1024">
               <h3>
                  addMulVVW1024 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addMulVVW1024(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function" data-name="addMulVVW1536">
               <h3>
                  addMulVVW1536 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func addMulVVW1536(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function" data-name="addMulVVW1536">
               <h3>
                  addMulVVW1536 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addMulVVW1536(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function" data-name="addMulVVW1536">
               <h3>
                  addMulVVW1536 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addMulVVW1536(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function" data-name="addMulVVW2048">
               <h3>
                  addMulVVW2048 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func addMulVVW2048(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function" data-name="addMulVVW2048">
               <h3>
                  addMulVVW2048 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addMulVVW2048(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function" data-name="addMulVVW2048">
               <h3>
                  addMulVVW2048 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addMulVVW2048(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function" data-name="addMulVVWWasm">
               <h3>
                  addMulVVWWasm 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addMulVVWWasm(z *uint, x *uint, y uint, n uintptr) (carry uint)</code></pre>
            </article>
            
            <article class="function" data-name="assign">
               <h3>
                  assign 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>assign sets x <- y if on == 1, and does nothing otherwise.
Both operands must have the same announced length.
go:norace</p>
               
               <pre><code>func (x *Nat) assign(on choice, y *Nat) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="bigEndianUint">
               <h3>
                  bigEndianUint 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>bigEndianUint returns the contents of buf interpreted as a
big-endian encoded uint value.</p>
               
               <pre><code>func bigEndianUint(buf []byte) uint</code></pre>
            </article>
            
            <article class="function" data-name="bitLen">
               <h3>
                  bitLen 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>bitLen is a version of bits.Len that only leaks the bit length of n, but not
its value. bits.Len and bits.LeadingZeros use a lookup table for the
low-order bits on some architectures.</p>
               
               <pre><code>func bitLen(n uint) int</code></pre>
            </article>
            
            <article class="function" data-name="cmpGeq">
               <h3>
                  cmpGeq 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>cmpGeq returns 1 if x >= y, and 0 otherwise.
Both operands must have the same announced length.
go:norace</p>
               
               <pre><code>func (x *Nat) cmpGeq(y *Nat) choice</code></pre>
            </article>
            
            <article class="function" data-name="ctEq">
               <h3>
                  ctEq 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ctEq returns 1 if x == y, and 0 otherwise. The execution time of this
function does not depend on its inputs.</p>
               
               <pre><code>func ctEq(x uint, y uint) choice</code></pre>
            </article>
            
            <article class="function" data-name="ctMask">
               <h3>
                  ctMask 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ctMask is all 1s if on is yes, and all 0s otherwise.</p>
               
               <pre><code>func ctMask(on choice) uint</code></pre>
            </article>
            
            <article class="function" data-name="expand">
               <h3>
                  expand 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>expand expands x to n limbs, leaving its value unchanged.</p>
               
               <pre><code>func (x *Nat) expand(n int) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="extendedGCD">
               <h3>
                  extendedGCD 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>extendedGCD computes u and A such that a = GCD(a, m) and u = A*a - B*m.
u will have the size of the larger of a and m, and A will have the size of m.
It is an error if either a or m is zero, or if they are both even.</p>
               
               <pre><code>func extendedGCD(a *Nat, m *Nat) (u *Nat, A *Nat, err error)</code></pre>
            </article>
            
            <article class="function" data-name="idx">
               <h3>
                  idx 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func idx(x *uint, i uintptr) *uint</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="maybeSubtractModulus">
               <h3>
                  maybeSubtractModulus 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>maybeSubtractModulus computes x -= m if and only if x >= m or if "always" is yes.
It can be used to reduce modulo m a value up to 2m - 1, which is a common
range for results computed by higher level operations.
always is usually a carry that indicates that the operation that produced x
overflowed its size, meaning abstractly x > 2^_W*n > m even if x < m.
x and m operands must have the same announced length.
go:norace</p>
               
               <pre><code>func (x *Nat) maybeSubtractModulus(always choice, m *Modulus)</code></pre>
            </article>
            
            <article class="function" data-name="minusInverseModW">
               <h3>
                  minusInverseModW 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>minusInverseModW computes -x⁻¹ mod _W with x odd.
This operation is used to precompute a constant involved in Montgomery
multiplication.</p>
               
               <pre><code>func minusInverseModW(x uint) uint</code></pre>
            </article>
            
            <article class="function" data-name="montgomeryMul">
               <h3>
                  montgomeryMul 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>montgomeryMul calculates x = a * b / R mod m, with R = 2^(_W * n) and
n = len(m.nat.limbs), also known as a Montgomery multiplication.
All inputs should be the same length and already reduced modulo m.
x will be resized to the size of m and overwritten.
go:norace</p>
               
               <pre><code>func (x *Nat) montgomeryMul(a *Nat, b *Nat, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="montgomeryReduction">
               <h3>
                  montgomeryReduction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>montgomeryReduction calculates x = x / R mod m, with R = 2^(_W * n) and
n = len(m.nat.limbs).
This assumes that x is already reduced mod m.</p>
               
               <pre><code>func (x *Nat) montgomeryReduction(m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="montgomeryRepresentation">
               <h3>
                  montgomeryRepresentation 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>montgomeryRepresentation calculates x = x * R mod m, with R = 2^(_W * n) and
n = len(m.nat.limbs).
Faster Montgomery multiplication replaces standard modular multiplication for
numbers in this representation.
This assumes that x is already reduced mod m.</p>
               
               <pre><code>func (x *Nat) montgomeryRepresentation(m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="newModulus">
               <h3>
                  newModulus 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newModulus(n *Nat) (*Modulus, error)</code></pre>
            </article>
            
            <article class="function" data-name="not">
               <h3>
                  not 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func not(c choice) choice</code></pre>
            </article>
            
            <article class="function" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>reset returns a zero nat of n limbs, reusing x's storage if n <= cap(x.limbs).</p>
               
               <pre><code>func (x *Nat) reset(n int) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="resetFor">
               <h3>
                  resetFor 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>resetFor ensures out has the right size to work with operations modulo m.
out is zeroed and may start at any size.</p>
               
               <pre><code>func (out *Nat) resetFor(m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="resetToBytes">
               <h3>
                  resetToBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>resetToBytes assigns x = b, where b is a slice of big-endian bytes, resizing
n to the appropriate size.
The announced length of x is set based on the actual bit size of the input,
ignoring leading zeroes.</p>
               
               <pre><code>func (x *Nat) resetToBytes(b []byte) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="rr">
               <h3>
                  rr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>rr returns R*R with R = 2^(_W * n) and n = len(m.nat.limbs).</p>
               
               <pre><code>func rr(m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="rshift1">
               <h3>
                  rshift1 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:norace</p>
               
               <pre><code>func rshift1(a *Nat, carry uint)</code></pre>
            </article>
            
            <article class="function" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>set assigns x = y, optionally resizing x to the appropriate size.</p>
               
               <pre><code>func (x *Nat) set(y *Nat) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="setBytes">
               <h3>
                  setBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *Nat) setBytes(b []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="shiftIn">
               <h3>
                  shiftIn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>shiftIn calculates x = x << _W + y mod m.
This assumes that x is already reduced mod m.
go:norace</p>
               
               <pre><code>func (x *Nat) shiftIn(y uint, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function" data-name="sub">
               <h3>
                  sub 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>sub computes x -= y. It returns the borrow of the subtraction.
Both operands must have the same announced length.
go:norace</p>
               
               <pre><code>func (x *Nat) sub(y *Nat) (c uint)</code></pre>
            </article>
            
            <article class="function" data-name="trim">
               <h3>
                  trim 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>trim reduces the size of x to match its value.</p>
               
               <pre><code>func (x *Nat) trim() *Nat</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
