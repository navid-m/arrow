<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - bigmod</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="crypto_internal_fips140_bigmod__asm-docs.html">_asm</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>bigmod</code>
         </h1>
         <hr />
         
         <article class="global" data-name="_W">
            <h2>_W</h2>
            <hr />
            
            <p>_W is the size in bits of our limbs.</p>
            
            <pre><code>_W</code></pre>
         </article>
         
         <article class="global" data-name="_S">
            <h2>_S</h2>
            <hr />
            
            <p>_S is the size in bytes of our limbs.</p>
            
            <pre><code>_S</code></pre>
         </article>
         
         <article class="global" data-name="yes">
            <h2>yes</h2>
            <hr />
            
            <pre><code>yes</code></pre>
         </article>
         
         <article class="global" data-name="no">
            <h2>no</h2>
            <hr />
            
            <pre><code>no</code></pre>
         </article>
         
         <article class="global" data-name="preallocTarget">
            <h2>preallocTarget</h2>
            <hr />
            
            <p>preallocTarget is the size in bits of the numbers used to implement the most
common and most performant RSA key size. It's also enough to cover some of
the operations of key sizes up to 4096.</p>
            
            <pre><code>preallocTarget</code></pre>
         </article>
         
         <article class="global" data-name="preallocLimbs">
            <h2>preallocLimbs</h2>
            <hr />
            
            <pre><code>preallocLimbs</code></pre>
         </article>
         
         <article class="global" data-name="supportADX">
            <h2>supportADX</h2>
            <hr />
            
            <pre><code>supportADX</code></pre>
         </article>
          
         <article class="struct" data-name="Nat">
            <h2>type Nat struct</h2>
            <hr />
            
            <p>Nat represents an arbitrary natural number

Each Nat has an announced length, which is the number of limbs it has stored.
Operations on this number are allowed to leak this length, but will not leak
any information about the values contained in those limbs.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">limbs []uint</code></pre>
         </article>
         
         <article class="struct" data-name="Modulus">
            <h2>type Modulus struct</h2>
            <hr />
            
            <p>Modulus is used for modular arithmetic, precomputing relevant constants.

A Modulus can leak the exact number of bits needed to store its value
and is stored without padding. Its actual value is still kept secret.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">nat *Nat
odd bool
m0inv uint
rr *Nat</code></pre>
         </article>
          
         <article class="function" data-name="addMulVVW1024">
            <h2>addMulVVW1024</h2>
            <hr />
            
            <pre><code>func addMulVVW1024(z *uint, x *uint, y uint) c uint</code></pre>
         </article>
         
         <article class="function" data-name="addMulVVW1536">
            <h2>addMulVVW1536</h2>
            <hr />
            
            <pre><code>func addMulVVW1536(z *uint, x *uint, y uint) c uint</code></pre>
         </article>
         
         <article class="function" data-name="addMulVVW2048">
            <h2>addMulVVW2048</h2>
            <hr />
            
            <pre><code>func addMulVVW2048(z *uint, x *uint, y uint) c uint</code></pre>
         </article>
         
         <article class="function" data-name="setBig">
            <h2>setBig</h2>
            <hr />
            
            <p>setBig assigns x = n, optionally resizing n to the appropriate size.

The announced length of x is set based on the actual bit size of the input,
ignoring leading zeroes.</p>
            
            <pre><code>func setBig(n *big.Int) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="asBig">
            <h2>asBig</h2>
            <hr />
            
            <pre><code>func asBig() *big.Int</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Generate">
            <h2>Generate</h2>
            <hr />
            
            <p>Generate generates an even nat. It's used by testing/quick to produce random
*nat values for quick.Check invocations.</p>
            
            <pre><code>func Generate(r *rand.Rand, size int) reflect.Value</code></pre>
         </article>
         
         <article class="function" data-name="testModAddCommutative">
            <h2>testModAddCommutative</h2>
            <hr />
            
            <pre><code>func testModAddCommutative(a *Nat, b *Nat) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestModAddCommutative">
            <h2>TestModAddCommutative</h2>
            <hr />
            
            <pre><code>func TestModAddCommutative(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testModSubThenAddIdentity">
            <h2>testModSubThenAddIdentity</h2>
            <hr />
            
            <pre><code>func testModSubThenAddIdentity(a *Nat, b *Nat) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestModSubThenAddIdentity">
            <h2>TestModSubThenAddIdentity</h2>
            <hr />
            
            <pre><code>func TestModSubThenAddIdentity(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMontgomeryRoundtrip">
            <h2>TestMontgomeryRoundtrip</h2>
            <hr />
            
            <pre><code>func TestMontgomeryRoundtrip(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestShiftIn">
            <h2>TestShiftIn</h2>
            <hr />
            
            <pre><code>func TestShiftIn(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestModulusAndNatSizes">
            <h2>TestModulusAndNatSizes</h2>
            <hr />
            
            <pre><code>func TestModulusAndNatSizes(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSetBytes">
            <h2>TestSetBytes</h2>
            <hr />
            
            <pre><code>func TestSetBytes(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestExpand">
            <h2>TestExpand</h2>
            <hr />
            
            <pre><code>func TestExpand(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMod">
            <h2>TestMod</h2>
            <hr />
            
            <pre><code>func TestMod(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestModSub">
            <h2>TestModSub</h2>
            <hr />
            
            <pre><code>func TestModSub(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestModAdd">
            <h2>TestModAdd</h2>
            <hr />
            
            <pre><code>func TestModAdd(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestExp">
            <h2>TestExp</h2>
            <hr />
            
            <pre><code>func TestExp(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestExpShort">
            <h2>TestExpShort</h2>
            <hr />
            
            <pre><code>func TestExpShort(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMulReductions">
            <h2>TestMulReductions</h2>
            <hr />
            
            <p>TestMulReductions tests that Mul reduces results equal or slightly greater
than the modulus. Some Montgomery algorithms don't and need extra care to
return correct results. See https://go.dev/issue/13907.</p>
            
            <pre><code>func TestMulReductions(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMul">
            <h2>TestMul</h2>
            <hr />
            
            <pre><code>func TestMul(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testMul">
            <h2>testMul</h2>
            <hr />
            
            <pre><code>func testMul(t *testing.T, n int)</code></pre>
         </article>
         
         <article class="function" data-name="TestIs">
            <h2>TestIs</h2>
            <hr />
            
            <pre><code>func TestIs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestTrailingZeroBits">
            <h2>TestTrailingZeroBits</h2>
            <hr />
            
            <pre><code>func TestTrailingZeroBits(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestRightShift">
            <h2>TestRightShift</h2>
            <hr />
            
            <pre><code>func TestRightShift(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="natBytes">
            <h2>natBytes</h2>
            <hr />
            
            <pre><code>func natBytes(n *Nat) []byte</code></pre>
         </article>
         
         <article class="function" data-name="natFromBytes">
            <h2>natFromBytes</h2>
            <hr />
            
            <pre><code>func natFromBytes(b []byte) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="modulusFromBytes">
            <h2>modulusFromBytes</h2>
            <hr />
            
            <pre><code>func modulusFromBytes(b []byte) *Modulus</code></pre>
         </article>
         
         <article class="function" data-name="maxModulus">
            <h2>maxModulus</h2>
            <hr />
            
            <p>maxModulus returns the biggest modulus that can fit in n limbs.</p>
            
            <pre><code>func maxModulus(n uint) *Modulus</code></pre>
         </article>
         
         <article class="function" data-name="makeBenchmarkModulus">
            <h2>makeBenchmarkModulus</h2>
            <hr />
            
            <pre><code>func makeBenchmarkModulus() *Modulus</code></pre>
         </article>
         
         <article class="function" data-name="makeBenchmarkValue">
            <h2>makeBenchmarkValue</h2>
            <hr />
            
            <pre><code>func makeBenchmarkValue() *Nat</code></pre>
         </article>
         
         <article class="function" data-name="makeBenchmarkExponent">
            <h2>makeBenchmarkExponent</h2>
            <hr />
            
            <pre><code>func makeBenchmarkExponent() []byte</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkModAdd">
            <h2>BenchmarkModAdd</h2>
            <hr />
            
            <pre><code>func BenchmarkModAdd(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkModSub">
            <h2>BenchmarkModSub</h2>
            <hr />
            
            <pre><code>func BenchmarkModSub(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkMontgomeryRepr">
            <h2>BenchmarkMontgomeryRepr</h2>
            <hr />
            
            <pre><code>func BenchmarkMontgomeryRepr(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkMontgomeryMul">
            <h2>BenchmarkMontgomeryMul</h2>
            <hr />
            
            <pre><code>func BenchmarkMontgomeryMul(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkModMul">
            <h2>BenchmarkModMul</h2>
            <hr />
            
            <pre><code>func BenchmarkModMul(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkExpBig">
            <h2>BenchmarkExpBig</h2>
            <hr />
            
            <pre><code>func BenchmarkExpBig(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkExp">
            <h2>BenchmarkExp</h2>
            <hr />
            
            <pre><code>func BenchmarkExp(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="TestNewModulus">
            <h2>TestNewModulus</h2>
            <hr />
            
            <pre><code>func TestNewModulus(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="makeTestValue">
            <h2>makeTestValue</h2>
            <hr />
            
            <pre><code>func makeTestValue(nbits int) []uint</code></pre>
         </article>
         
         <article class="function" data-name="TestAddMulVVWSized">
            <h2>TestAddMulVVWSized</h2>
            <hr />
            
            <pre><code>func TestAddMulVVWSized(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInverse">
            <h2>TestInverse</h2>
            <hr />
            
            <pre><code>func TestInverse(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="decodeHex">
            <h2>decodeHex</h2>
            <hr />
            
            <pre><code>func decodeHex(t *testing.T, s string) []byte</code></pre>
         </article>
         
         <article class="function" data-name="idx">
            <h2>idx</h2>
            <hr />
            
            <pre><code>func idx(x *uint, i uintptr) *uint</code></pre>
         </article>
         
         <article class="function" data-name="addMulVVWWasm">
            <h2>addMulVVWWasm</h2>
            <hr />
            
            <pre><code>func addMulVVWWasm(z *uint, x *uint, y uint, n uintptr) carry uint</code></pre>
         </article>
         
         <article class="function" data-name="addMulVVW1024">
            <h2>addMulVVW1024</h2>
            <hr />
            
            <pre><code>func addMulVVW1024(z *uint, x *uint, y uint) c uint</code></pre>
         </article>
         
         <article class="function" data-name="addMulVVW1536">
            <h2>addMulVVW1536</h2>
            <hr />
            
            <pre><code>func addMulVVW1536(z *uint, x *uint, y uint) c uint</code></pre>
         </article>
         
         <article class="function" data-name="addMulVVW2048">
            <h2>addMulVVW2048</h2>
            <hr />
            
            <pre><code>func addMulVVW2048(z *uint, x *uint, y uint) c uint</code></pre>
         </article>
         
         <article class="function" data-name="not">
            <h2>not</h2>
            <hr />
            
            <pre><code>func not(c choice) choice</code></pre>
         </article>
         
         <article class="function" data-name="ctMask">
            <h2>ctMask</h2>
            <hr />
            
            <p>ctMask is all 1s if on is yes, and all 0s otherwise.</p>
            
            <pre><code>func ctMask(on choice) uint</code></pre>
         </article>
         
         <article class="function" data-name="ctEq">
            <h2>ctEq</h2>
            <hr />
            
            <p>ctEq returns 1 if x == y, and 0 otherwise. The execution time of this
function does not depend on its inputs.</p>
            
            <pre><code>func ctEq(x uint, y uint) choice</code></pre>
         </article>
         
         <article class="function" data-name="NewNat">
            <h2>NewNat</h2>
            <hr />
            
            <p>NewNat returns a new nat with a size of zero, just like new(Nat), but with
the preallocated capacity to hold a number of up to preallocTarget bits.
NewNat inlines, so the allocation can live on the stack.</p>
            
            <pre><code>func NewNat() *Nat</code></pre>
         </article>
         
         <article class="function" data-name="expand">
            <h2>expand</h2>
            <hr />
            
            <p>expand expands x to n limbs, leaving its value unchanged.</p>
            
            <pre><code>func expand(n int) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="reset">
            <h2>reset</h2>
            <hr />
            
            <p>reset returns a zero nat of n limbs, reusing x's storage if n <= cap(x.limbs).</p>
            
            <pre><code>func reset(n int) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="resetToBytes">
            <h2>resetToBytes</h2>
            <hr />
            
            <p>resetToBytes assigns x = b, where b is a slice of big-endian bytes, resizing
n to the appropriate size.

The announced length of x is set based on the actual bit size of the input,
ignoring leading zeroes.</p>
            
            <pre><code>func resetToBytes(b []byte) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="trim">
            <h2>trim</h2>
            <hr />
            
            <p>trim reduces the size of x to match its value.</p>
            
            <pre><code>func trim() *Nat</code></pre>
         </article>
         
         <article class="function" data-name="set">
            <h2>set</h2>
            <hr />
            
            <p>set assigns x = y, optionally resizing x to the appropriate size.</p>
            
            <pre><code>func set(y *Nat) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="Bits">
            <h2>Bits</h2>
            <hr />
            
            <p>Bits returns x as a little-endian slice of uint. The length of the slice
matches the announced length of x. The result and x share the same underlying
array.</p>
            
            <pre><code>func Bits() []uint</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <p>Bytes returns x as a zero-extended big-endian byte slice. The size of the
slice will match the size of m.

x must have the same size as m and it must be less than or equal to m.</p>
            
            <pre><code>func Bytes(m *Modulus) []byte</code></pre>
         </article>
         
         <article class="function" data-name="SetBytes">
            <h2>SetBytes</h2>
            <hr />
            
            <p>SetBytes assigns x = b, where b is a slice of big-endian bytes.
SetBytes returns an error if b >= m.

The output will be resized to the size of m and overwritten.</p>
            
            <pre><code>func SetBytes(b []byte, m *Modulus) (*Nat, error)</code></pre>
         </article>
         
         <article class="function" data-name="SetOverflowingBytes">
            <h2>SetOverflowingBytes</h2>
            <hr />
            
            <p>SetOverflowingBytes assigns x = b, where b is a slice of big-endian bytes.
SetOverflowingBytes returns an error if b has a longer bit length than m, but
reduces overflowing values up to 2^⌈log2(m)⌉ - 1.

The output will be resized to the size of m and overwritten.</p>
            
            <pre><code>func SetOverflowingBytes(b []byte, m *Modulus) (*Nat, error)</code></pre>
         </article>
         
         <article class="function" data-name="bigEndianUint">
            <h2>bigEndianUint</h2>
            <hr />
            
            <p>bigEndianUint returns the contents of buf interpreted as a
big-endian encoded uint value.</p>
            
            <pre><code>func bigEndianUint(buf []byte) uint</code></pre>
         </article>
         
         <article class="function" data-name="setBytes">
            <h2>setBytes</h2>
            <hr />
            
            <pre><code>func setBytes(b []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="SetUint">
            <h2>SetUint</h2>
            <hr />
            
            <p>SetUint assigns x = y.

The output will be resized to a single limb and overwritten.</p>
            
            <pre><code>func SetUint(y uint) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="Equal">
            <h2>Equal</h2>
            <hr />
            
            <p>Equal returns 1 if x == y, and 0 otherwise.

Both operands must have the same announced length.</p>
            
            <pre><code>func Equal(y *Nat) choice</code></pre>
         </article>
         
         <article class="function" data-name="IsZero">
            <h2>IsZero</h2>
            <hr />
            
            <p>IsZero returns 1 if x == 0, and 0 otherwise.</p>
            
            <pre><code>func IsZero() choice</code></pre>
         </article>
         
         <article class="function" data-name="IsOne">
            <h2>IsOne</h2>
            <hr />
            
            <p>IsOne returns 1 if x == 1, and 0 otherwise.</p>
            
            <pre><code>func IsOne() choice</code></pre>
         </article>
         
         <article class="function" data-name="IsMinusOne">
            <h2>IsMinusOne</h2>
            <hr />
            
            <p>IsMinusOne returns 1 if x == -1 mod m, and 0 otherwise.

The length of x must be the same as the modulus. x must already be reduced
modulo m.</p>
            
            <pre><code>func IsMinusOne(m *Modulus) choice</code></pre>
         </article>
         
         <article class="function" data-name="IsOdd">
            <h2>IsOdd</h2>
            <hr />
            
            <p>IsOdd returns 1 if x is odd, and 0 otherwise.</p>
            
            <pre><code>func IsOdd() choice</code></pre>
         </article>
         
         <article class="function" data-name="TrailingZeroBitsVarTime">
            <h2>TrailingZeroBitsVarTime</h2>
            <hr />
            
            <p>TrailingZeroBitsVarTime returns the number of trailing zero bits in x.</p>
            
            <pre><code>func TrailingZeroBitsVarTime() uint</code></pre>
         </article>
         
         <article class="function" data-name="cmpGeq">
            <h2>cmpGeq</h2>
            <hr />
            
            <p>cmpGeq returns 1 if x >= y, and 0 otherwise.

Both operands must have the same announced length.</p>
            
            <pre><code>func cmpGeq(y *Nat) choice</code></pre>
         </article>
         
         <article class="function" data-name="assign">
            <h2>assign</h2>
            <hr />
            
            <p>assign sets x <- y if on == 1, and does nothing otherwise.

Both operands must have the same announced length.</p>
            
            <pre><code>func assign(on choice, y *Nat) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <p>add computes x += y and returns the carry.

Both operands must have the same announced length.</p>
            
            <pre><code>func add(y *Nat) c uint</code></pre>
         </article>
         
         <article class="function" data-name="sub">
            <h2>sub</h2>
            <hr />
            
            <p>sub computes x -= y. It returns the borrow of the subtraction.

Both operands must have the same announced length.</p>
            
            <pre><code>func sub(y *Nat) c uint</code></pre>
         </article>
         
         <article class="function" data-name="ShiftRightVarTime">
            <h2>ShiftRightVarTime</h2>
            <hr />
            
            <p>ShiftRightVarTime sets x = x >> n.

The announced length of x is unchanged.</p>
            
            <pre><code>func ShiftRightVarTime(n uint) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="BitLenVarTime">
            <h2>BitLenVarTime</h2>
            <hr />
            
            <p>BitLenVarTime returns the actual size of x in bits.

The actual size of x (but nothing more) leaks through timing side-channels.
Note that this is ordinarily secret, as opposed to the announced size of x.</p>
            
            <pre><code>func BitLenVarTime() int</code></pre>
         </article>
         
         <article class="function" data-name="bitLen">
            <h2>bitLen</h2>
            <hr />
            
            <p>bitLen is a version of bits.Len that only leaks the bit length of n, but not
its value. bits.Len and bits.LeadingZeros use a lookup table for the
low-order bits on some architectures.</p>
            
            <pre><code>func bitLen(n uint) int</code></pre>
         </article>
         
         <article class="function" data-name="rr">
            <h2>rr</h2>
            <hr />
            
            <p>rr returns R*R with R = 2^(_W * n) and n = len(m.nat.limbs).</p>
            
            <pre><code>func rr(m *Modulus) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="minusInverseModW">
            <h2>minusInverseModW</h2>
            <hr />
            
            <p>minusInverseModW computes -x⁻¹ mod _W with x odd.

This operation is used to precompute a constant involved in Montgomery
multiplication.</p>
            
            <pre><code>func minusInverseModW(x uint) uint</code></pre>
         </article>
         
         <article class="function" data-name="NewModulus">
            <h2>NewModulus</h2>
            <hr />
            
            <p>NewModulus creates a new Modulus from a slice of big-endian bytes. The
modulus must be greater than one.

The number of significant bits and whether the modulus is even is leaked
through timing side-channels.</p>
            
            <pre><code>func NewModulus(b []byte) (*Modulus, error)</code></pre>
         </article>
         
         <article class="function" data-name="NewModulusProduct">
            <h2>NewModulusProduct</h2>
            <hr />
            
            <p>NewModulusProduct creates a new Modulus from the product of two numbers
represented as big-endian byte slices. The result must be greater than one.</p>
            
            <pre><code>func NewModulusProduct(a []byte, b []byte) (*Modulus, error)</code></pre>
         </article>
         
         <article class="function" data-name="newModulus">
            <h2>newModulus</h2>
            <hr />
            
            <pre><code>func newModulus(n *Nat) (*Modulus, error)</code></pre>
         </article>
         
         <article class="function" data-name="Size">
            <h2>Size</h2>
            <hr />
            
            <p>Size returns the size of m in bytes.</p>
            
            <pre><code>func Size() int</code></pre>
         </article>
         
         <article class="function" data-name="BitLen">
            <h2>BitLen</h2>
            <hr />
            
            <p>BitLen returns the size of m in bits.</p>
            
            <pre><code>func BitLen() int</code></pre>
         </article>
         
         <article class="function" data-name="Nat">
            <h2>Nat</h2>
            <hr />
            
            <p>Nat returns m as a Nat.</p>
            
            <pre><code>func Nat() *Nat</code></pre>
         </article>
         
         <article class="function" data-name="shiftIn">
            <h2>shiftIn</h2>
            <hr />
            
            <p>shiftIn calculates x = x << _W + y mod m.

This assumes that x is already reduced mod m.</p>
            
            <pre><code>func shiftIn(y uint, m *Modulus) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="Mod">
            <h2>Mod</h2>
            <hr />
            
            <p>Mod calculates out = x mod m.

This works regardless how large the value of x is.

The output will be resized to the size of m and overwritten.</p>
            
            <pre><code>func Mod(x *Nat, m *Modulus) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="ExpandFor">
            <h2>ExpandFor</h2>
            <hr />
            
            <p>ExpandFor ensures x has the right size to work with operations modulo m.

The announced size of x must be smaller than or equal to that of m.</p>
            
            <pre><code>func ExpandFor(m *Modulus) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="resetFor">
            <h2>resetFor</h2>
            <hr />
            
            <p>resetFor ensures out has the right size to work with operations modulo m.

out is zeroed and may start at any size.</p>
            
            <pre><code>func resetFor(m *Modulus) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="maybeSubtractModulus">
            <h2>maybeSubtractModulus</h2>
            <hr />
            
            <p>maybeSubtractModulus computes x -= m if and only if x >= m or if "always" is yes.

It can be used to reduce modulo m a value up to 2m - 1, which is a common
range for results computed by higher level operations.

always is usually a carry that indicates that the operation that produced x
overflowed its size, meaning abstractly x > 2^_W*n > m even if x < m.

x and m operands must have the same announced length.</p>
            
            <pre><code>func maybeSubtractModulus(always choice, m *Modulus)</code></pre>
         </article>
         
         <article class="function" data-name="Sub">
            <h2>Sub</h2>
            <hr />
            
            <p>Sub computes x = x - y mod m.

The length of both operands must be the same as the modulus. Both operands
must already be reduced modulo m.</p>
            
            <pre><code>func Sub(y *Nat, m *Modulus) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="SubOne">
            <h2>SubOne</h2>
            <hr />
            
            <p>SubOne computes x = x - 1 mod m.

The length of x must be the same as the modulus.</p>
            
            <pre><code>func SubOne(m *Modulus) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add computes x = x + y mod m.

The length of both operands must be the same as the modulus. Both operands
must already be reduced modulo m.</p>
            
            <pre><code>func Add(y *Nat, m *Modulus) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="montgomeryRepresentation">
            <h2>montgomeryRepresentation</h2>
            <hr />
            
            <p>montgomeryRepresentation calculates x = x * R mod m, with R = 2^(_W * n) and
n = len(m.nat.limbs).

Faster Montgomery multiplication replaces standard modular multiplication for
numbers in this representation.

This assumes that x is already reduced mod m.</p>
            
            <pre><code>func montgomeryRepresentation(m *Modulus) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="montgomeryReduction">
            <h2>montgomeryReduction</h2>
            <hr />
            
            <p>montgomeryReduction calculates x = x / R mod m, with R = 2^(_W * n) and
n = len(m.nat.limbs).

This assumes that x is already reduced mod m.</p>
            
            <pre><code>func montgomeryReduction(m *Modulus) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="montgomeryMul">
            <h2>montgomeryMul</h2>
            <hr />
            
            <p>montgomeryMul calculates x = a * b / R mod m, with R = 2^(_W * n) and
n = len(m.nat.limbs), also known as a Montgomery multiplication.

All inputs should be the same length and already reduced modulo m.
x will be resized to the size of m and overwritten.</p>
            
            <pre><code>func montgomeryMul(a *Nat, b *Nat, m *Modulus) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="addMulVVW">
            <h2>addMulVVW</h2>
            <hr />
            
            <p>addMulVVW multiplies the multi-word value x by the single-word value y,
adding the result to the multi-word value z and returning the final carry.
It can be thought of as one row of a pen-and-paper column multiplication.</p>
            
            <pre><code>func addMulVVW(z []uint, x []uint, y uint) carry uint</code></pre>
         </article>
         
         <article class="function" data-name="Mul">
            <h2>Mul</h2>
            <hr />
            
            <p>Mul calculates x = x * y mod m.

The length of both operands must be the same as the modulus. Both operands
must already be reduced modulo m.</p>
            
            <pre><code>func Mul(y *Nat, m *Modulus) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="Exp">
            <h2>Exp</h2>
            <hr />
            
            <p>Exp calculates out = x^e mod m.

The exponent e is represented in big-endian order. The output will be resized
to the size of m and overwritten. x must already be reduced modulo m.

m must be odd, or Exp will panic.</p>
            
            <pre><code>func Exp(x *Nat, e []byte, m *Modulus) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="ExpShortVarTime">
            <h2>ExpShortVarTime</h2>
            <hr />
            
            <p>ExpShortVarTime calculates out = x^e mod m.

The output will be resized to the size of m and overwritten. x must already
be reduced modulo m. This leaks the exponent through timing side-channels.

m must be odd, or ExpShortVarTime will panic.</p>
            
            <pre><code>func ExpShortVarTime(x *Nat, e uint, m *Modulus) *Nat</code></pre>
         </article>
         
         <article class="function" data-name="InverseVarTime">
            <h2>InverseVarTime</h2>
            <hr />
            
            <p>InverseVarTime calculates x = a⁻¹ mod m and returns (x, true) if a is
invertible. Otherwise, InverseVarTime returns (x, false) and x is not
modified.

a must be reduced modulo m, but doesn't need to have the same size. The
output will be resized to the size of m and overwritten.</p>
            
            <pre><code>func InverseVarTime(a *Nat, m *Modulus) (*Nat, bool)</code></pre>
         </article>
         
         <article class="function" data-name="GCDVarTime">
            <h2>GCDVarTime</h2>
            <hr />
            
            <p>GCDVarTime calculates x = GCD(a, b) where at least one of a or b is odd, and
both are non-zero. If GCDVarTime returns an error, x is not modified.

The output will be resized to the size of the larger of a and b.</p>
            
            <pre><code>func GCDVarTime(a *Nat, b *Nat) (*Nat, error)</code></pre>
         </article>
         
         <article class="function" data-name="extendedGCD">
            <h2>extendedGCD</h2>
            <hr />
            
            <p>extendedGCD computes u and A such that a = GCD(a, m) and u = A*a - B*m.

u will have the size of the larger of a and m, and A will have the size of m.

It is an error if either a or m is zero, or if they are both even.</p>
            
            <pre><code>func extendedGCD(a *Nat, m *Nat) (u *Nat, A *Nat, err error)</code></pre>
         </article>
         
         <article class="function" data-name="rshift1">
            <h2>rshift1</h2>
            <hr />
            
            <pre><code>func rshift1(a *Nat, carry uint)</code></pre>
         </article>
         
         <article class="function" data-name="DivShortVarTime">
            <h2>DivShortVarTime</h2>
            <hr />
            
            <p>DivShortVarTime calculates x = x / y and returns the remainder.

It panics if y is zero.</p>
            
            <pre><code>func DivShortVarTime(y uint) uint</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="addMulVVW1024">
            <h2>addMulVVW1024</h2>
            <hr />
            
            <pre><code>func addMulVVW1024(z *uint, x *uint, y uint) c uint</code></pre>
         </article>
         
         <article class="function" data-name="addMulVVW1536">
            <h2>addMulVVW1536</h2>
            <hr />
            
            <pre><code>func addMulVVW1536(z *uint, x *uint, y uint) c uint</code></pre>
         </article>
         
         <article class="function" data-name="addMulVVW2048">
            <h2>addMulVVW2048</h2>
            <hr />
            
            <pre><code>func addMulVVW2048(z *uint, x *uint, y uint) c uint</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
