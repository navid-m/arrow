<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - bigmod</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="crypto_internal_fips140_bigmod__asm-docs.html">_asm</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>bigmod</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"unsafe"
"unsafe"
_ "crypto/internal/fips140/check"
"crypto/internal/fips140deps/byteorder"
"errors"
"math/bits"
"crypto/internal/fips140deps/cpu"
"crypto/internal/impl"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="_S" data-name="_S">
               <h3>
                  _S 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_S" class="anchor" title="Link to _S">#</a>
               </h3>
               
                  <p class="doc-comment">_S is the size in bytes of our limbs.</p>
               
               <pre><code class="language-go">const _S = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_W" data-name="_W">
               <h3>
                  _W 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_W" class="anchor" title="Link to _W">#</a>
               </h3>
               
                  <p class="doc-comment">_W is the size in bits of our limbs.</p>
               
               <pre><code class="language-go">const _W = bits.UintSize</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="no" data-name="no">
               <h3>
                  no 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#no" class="anchor" title="Link to no">#</a>
               </h3>
               
               <pre><code class="language-go">const no = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="preallocLimbs" data-name="preallocLimbs">
               <h3>
                  preallocLimbs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#preallocLimbs" class="anchor" title="Link to preallocLimbs">#</a>
               </h3>
               
               <pre><code class="language-go">const preallocLimbs = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="preallocTarget" data-name="preallocTarget">
               <h3>
                  preallocTarget 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#preallocTarget" class="anchor" title="Link to preallocTarget">#</a>
               </h3>
               
                  <p class="doc-comment">preallocTarget is the size in bits of the numbers used to implement the most
common and most performant RSA key size. It's also enough to cover some of
the operations of key sizes up to 4096.</p>
               
               <pre><code class="language-go">const preallocTarget = 2048</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="supportADX" data-name="supportADX">
               <h3>
                  supportADX 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#supportADX" class="anchor" title="Link to supportADX">#</a>
               </h3>
               
               <pre><code class="language-go">var supportADX = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="yes" data-name="yes">
               <h3>
                  yes 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#yes" class="anchor" title="Link to yes">#</a>
               </h3>
               
               <pre><code class="language-go">const yes = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="choice" data-name="choice">
               <h3>
                  choice
                  <span class="badge type-badge">type</span>
                  <a href="#choice" class="anchor" title="Link to choice">#</a>
               </h3>
               
               <p>choice represents a constant-time boolean. The value of choice is always
either 1 or 0. We use an int instead of bool in order to make decisions in
constant time by turning it into a mask.</p>
               
               <pre><code class="language-go">type choice uint</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Modulus" data-name="Modulus">
               <h3>
                  Modulus
                  <span class="badge">struct</span>
                  <a href="#Modulus" class="anchor" title="Link to Modulus">#</a>
               </h3>
               
               <p>Modulus is used for modular arithmetic, precomputing relevant constants.
A Modulus can leak the exact number of bits needed to store its value
and is stored without padding. Its actual value is still kept secret.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Modulus struct {
nat *Nat
odd bool
m0inv uint
rr *Nat
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Nat" data-name="Nat">
               <h3>
                  Nat
                  <span class="badge">struct</span>
                  <a href="#Nat" class="anchor" title="Link to Nat">#</a>
               </h3>
               
               <p>Nat represents an arbitrary natural number
Each Nat has an announced length, which is the number of limbs it has stored.
Operations on this number are allowed to leak this length, but will not leak
any information about the values contained in those limbs.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Nat struct {
limbs []uint
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add computes x = x + y mod m.
The length of both operands must be the same as the modulus. Both operands
must already be reduced modulo m.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) Add(y *Nat, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BitLen" data-name="BitLen">
               <h3>
                  BitLen 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BitLen" class="anchor" title="Link to BitLen">#</a>
               </h3>
               
               <p>BitLen returns the size of m in bits.</p>
               
               <pre><code class="language-go">func (m *Modulus) BitLen() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BitLenVarTime" data-name="BitLenVarTime">
               <h3>
                  BitLenVarTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BitLenVarTime" class="anchor" title="Link to BitLenVarTime">#</a>
               </h3>
               
               <p>BitLenVarTime returns the actual size of x in bits.
The actual size of x (but nothing more) leaks through timing side-channels.
Note that this is ordinarily secret, as opposed to the announced size of x.</p>
               
               <pre><code class="language-go">func (x *Nat) BitLenVarTime() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bits" data-name="Bits">
               <h3>
                  Bits 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bits" class="anchor" title="Link to Bits">#</a>
               </h3>
               
               <p>Bits returns x as a little-endian slice of uint. The length of the slice
matches the announced length of x. The result and x share the same underlying
array.</p>
               
               <pre><code class="language-go">func (x *Nat) Bits() []uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bytes" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bytes" class="anchor" title="Link to Bytes">#</a>
               </h3>
               
               <p>Bytes returns x as a zero-extended big-endian byte slice. The size of the
slice will match the size of m.
x must have the same size as m and it must be less than or equal to m.</p>
               
               <pre><code class="language-go">func (x *Nat) Bytes(m *Modulus) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DivShortVarTime" data-name="DivShortVarTime">
               <h3>
                  DivShortVarTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DivShortVarTime" class="anchor" title="Link to DivShortVarTime">#</a>
               </h3>
               
               <p>DivShortVarTime calculates x = x / y and returns the remainder.
It panics if y is zero.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) DivShortVarTime(y uint) uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Equal" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Equal" class="anchor" title="Link to Equal">#</a>
               </h3>
               
               <p>Equal returns 1 if x == y, and 0 otherwise.
Both operands must have the same announced length.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) Equal(y *Nat) choice</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Exp" data-name="Exp">
               <h3>
                  Exp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Exp" class="anchor" title="Link to Exp">#</a>
               </h3>
               
               <p>Exp calculates out = x^e mod m.
The exponent e is represented in big-endian order. The output will be resized
to the size of m and overwritten. x must already be reduced modulo m.
m must be odd, or Exp will panic.
go:norace</p>
               
               <pre><code class="language-go">func (out *Nat) Exp(x *Nat, e []byte, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ExpShortVarTime" data-name="ExpShortVarTime">
               <h3>
                  ExpShortVarTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ExpShortVarTime" class="anchor" title="Link to ExpShortVarTime">#</a>
               </h3>
               
               <p>ExpShortVarTime calculates out = x^e mod m.
The output will be resized to the size of m and overwritten. x must already
be reduced modulo m. This leaks the exponent through timing side-channels.
m must be odd, or ExpShortVarTime will panic.</p>
               
               <pre><code class="language-go">func (out *Nat) ExpShortVarTime(x *Nat, e uint, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ExpandFor" data-name="ExpandFor">
               <h3>
                  ExpandFor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ExpandFor" class="anchor" title="Link to ExpandFor">#</a>
               </h3>
               
               <p>ExpandFor ensures x has the right size to work with operations modulo m.
The announced size of x must be smaller than or equal to that of m.</p>
               
               <pre><code class="language-go">func (x *Nat) ExpandFor(m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GCDVarTime" data-name="GCDVarTime">
               <h3>
                  GCDVarTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GCDVarTime" class="anchor" title="Link to GCDVarTime">#</a>
               </h3>
               
               <p>GCDVarTime calculates x = GCD(a, b) where at least one of a or b is odd, and
both are non-zero. If GCDVarTime returns an error, x is not modified.
The output will be resized to the size of the larger of a and b.</p>
               
               <pre><code class="language-go">func (x *Nat) GCDVarTime(a *Nat, b *Nat) (*Nat, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InverseVarTime" data-name="InverseVarTime">
               <h3>
                  InverseVarTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InverseVarTime" class="anchor" title="Link to InverseVarTime">#</a>
               </h3>
               
               <p>InverseVarTime calculates x = a⁻¹ mod m and returns (x, true) if a is
invertible. Otherwise, InverseVarTime returns (x, false) and x is not
modified.
a must be reduced modulo m, but doesn't need to have the same size. The
output will be resized to the size of m and overwritten.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) InverseVarTime(a *Nat, m *Modulus) (*Nat, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsMinusOne" data-name="IsMinusOne">
               <h3>
                  IsMinusOne 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsMinusOne" class="anchor" title="Link to IsMinusOne">#</a>
               </h3>
               
               <p>IsMinusOne returns 1 if x == -1 mod m, and 0 otherwise.
The length of x must be the same as the modulus. x must already be reduced
modulo m.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) IsMinusOne(m *Modulus) choice</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsOdd" data-name="IsOdd">
               <h3>
                  IsOdd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsOdd" class="anchor" title="Link to IsOdd">#</a>
               </h3>
               
               <p>IsOdd returns 1 if x is odd, and 0 otherwise.</p>
               
               <pre><code class="language-go">func (x *Nat) IsOdd() choice</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsOne" data-name="IsOne">
               <h3>
                  IsOne 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsOne" class="anchor" title="Link to IsOne">#</a>
               </h3>
               
               <p>IsOne returns 1 if x == 1, and 0 otherwise.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) IsOne() choice</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsZero" data-name="IsZero">
               <h3>
                  IsZero 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsZero" class="anchor" title="Link to IsZero">#</a>
               </h3>
               
               <p>IsZero returns 1 if x == 0, and 0 otherwise.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) IsZero() choice</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mod" data-name="Mod">
               <h3>
                  Mod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mod" class="anchor" title="Link to Mod">#</a>
               </h3>
               
               <p>Mod calculates out = x mod m.
This works regardless how large the value of x is.
The output will be resized to the size of m and overwritten.
go:norace</p>
               
               <pre><code class="language-go">func (out *Nat) Mod(x *Nat, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mul" data-name="Mul">
               <h3>
                  Mul 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mul" class="anchor" title="Link to Mul">#</a>
               </h3>
               
               <p>Mul calculates x = x * y mod m.
The length of both operands must be the same as the modulus. Both operands
must already be reduced modulo m.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) Mul(y *Nat, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Nat" data-name="Nat">
               <h3>
                  Nat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Nat" class="anchor" title="Link to Nat">#</a>
               </h3>
               
               <p>Nat returns m as a Nat.</p>
               
               <pre><code class="language-go">func (m *Modulus) Nat() *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewModulus" data-name="NewModulus">
               <h3>
                  NewModulus 
                  <span class="badge">function</span>
                  
                  <a href="#NewModulus" class="anchor" title="Link to NewModulus">#</a>
               </h3>
               
               <p>NewModulus creates a new Modulus from a slice of big-endian bytes. The
modulus must be greater than one.
The number of significant bits and whether the modulus is even is leaked
through timing side-channels.</p>
               
               <pre><code class="language-go">func NewModulus(b []byte) (*Modulus, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewModulusProduct" data-name="NewModulusProduct">
               <h3>
                  NewModulusProduct 
                  <span class="badge">function</span>
                  
                  <a href="#NewModulusProduct" class="anchor" title="Link to NewModulusProduct">#</a>
               </h3>
               
               <p>NewModulusProduct creates a new Modulus from the product of two numbers
represented as big-endian byte slices. The result must be greater than one.
go:norace</p>
               
               <pre><code class="language-go">func NewModulusProduct(a []byte, b []byte) (*Modulus, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewNat" data-name="NewNat">
               <h3>
                  NewNat 
                  <span class="badge">function</span>
                  
                  <a href="#NewNat" class="anchor" title="Link to NewNat">#</a>
               </h3>
               
               <p>NewNat returns a new nat with a size of zero, just like new(Nat), but with
the preallocated capacity to hold a number of up to preallocTarget bits.
NewNat inlines, so the allocation can live on the stack.</p>
               
               <pre><code class="language-go">func NewNat() *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBytes" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBytes" class="anchor" title="Link to SetBytes">#</a>
               </h3>
               
               <p>SetBytes assigns x = b, where b is a slice of big-endian bytes.
SetBytes returns an error if b >= m.
The output will be resized to the size of m and overwritten.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) SetBytes(b []byte, m *Modulus) (*Nat, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetOverflowingBytes" data-name="SetOverflowingBytes">
               <h3>
                  SetOverflowingBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetOverflowingBytes" class="anchor" title="Link to SetOverflowingBytes">#</a>
               </h3>
               
               <p>SetOverflowingBytes assigns x = b, where b is a slice of big-endian bytes.
SetOverflowingBytes returns an error if b has a longer bit length than m, but
reduces overflowing values up to 2^⌈log2(m)⌉ - 1.
The output will be resized to the size of m and overwritten.</p>
               
               <pre><code class="language-go">func (x *Nat) SetOverflowingBytes(b []byte, m *Modulus) (*Nat, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetUint" data-name="SetUint">
               <h3>
                  SetUint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetUint" class="anchor" title="Link to SetUint">#</a>
               </h3>
               
               <p>SetUint assigns x = y.
The output will be resized to a single limb and overwritten.</p>
               
               <pre><code class="language-go">func (x *Nat) SetUint(y uint) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ShiftRightVarTime" data-name="ShiftRightVarTime">
               <h3>
                  ShiftRightVarTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ShiftRightVarTime" class="anchor" title="Link to ShiftRightVarTime">#</a>
               </h3>
               
               <p>ShiftRightVarTime sets x = x >> n.
The announced length of x is unchanged.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) ShiftRightVarTime(n uint) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <p>Size returns the size of m in bytes.</p>
               
               <pre><code class="language-go">func (m *Modulus) Size() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sub" data-name="Sub">
               <h3>
                  Sub 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sub" class="anchor" title="Link to Sub">#</a>
               </h3>
               
               <p>Sub computes x = x - y mod m.
The length of both operands must be the same as the modulus. Both operands
must already be reduced modulo m.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) Sub(y *Nat, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SubOne" data-name="SubOne">
               <h3>
                  SubOne 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SubOne" class="anchor" title="Link to SubOne">#</a>
               </h3>
               
               <p>SubOne computes x = x - 1 mod m.
The length of x must be the same as the modulus.</p>
               
               <pre><code class="language-go">func (x *Nat) SubOne(m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrailingZeroBitsVarTime" data-name="TrailingZeroBitsVarTime">
               <h3>
                  TrailingZeroBitsVarTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TrailingZeroBitsVarTime" class="anchor" title="Link to TrailingZeroBitsVarTime">#</a>
               </h3>
               
               <p>TrailingZeroBitsVarTime returns the number of trailing zero bits in x.</p>
               
               <pre><code class="language-go">func (x *Nat) TrailingZeroBitsVarTime() uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <p>add computes x += y and returns the carry.
Both operands must have the same announced length.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) add(y *Nat) (c uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addMulVVW" data-name="addMulVVW">
               <h3>
                  addMulVVW 
                  <span class="badge">function</span>
                  
                  <a href="#addMulVVW" class="anchor" title="Link to addMulVVW">#</a>
               </h3>
               
               <p>addMulVVW multiplies the multi-word value x by the single-word value y,
adding the result to the multi-word value z and returning the final carry.
It can be thought of as one row of a pen-and-paper column multiplication.
go:norace</p>
               
               <pre><code class="language-go">func addMulVVW(z []uint, x []uint, y uint) (carry uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addMulVVW1024" data-name="addMulVVW1024">
               <h3>
                  addMulVVW1024 
                  <span class="badge">function</span>
                  
                  <a href="#addMulVVW1024" class="anchor" title="Link to addMulVVW1024">#</a>
               </h3>
               
               <pre><code class="language-go">func addMulVVW1024(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addMulVVW1024" data-name="addMulVVW1024">
               <h3>
                  addMulVVW1024 
                  <span class="badge">function</span>
                  
                  <a href="#addMulVVW1024" class="anchor" title="Link to addMulVVW1024">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func addMulVVW1024(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addMulVVW1024" data-name="addMulVVW1024">
               <h3>
                  addMulVVW1024 
                  <span class="badge">function</span>
                  
                  <a href="#addMulVVW1024" class="anchor" title="Link to addMulVVW1024">#</a>
               </h3>
               
               <pre><code class="language-go">func addMulVVW1024(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addMulVVW1536" data-name="addMulVVW1536">
               <h3>
                  addMulVVW1536 
                  <span class="badge">function</span>
                  
                  <a href="#addMulVVW1536" class="anchor" title="Link to addMulVVW1536">#</a>
               </h3>
               
               <pre><code class="language-go">func addMulVVW1536(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addMulVVW1536" data-name="addMulVVW1536">
               <h3>
                  addMulVVW1536 
                  <span class="badge">function</span>
                  
                  <a href="#addMulVVW1536" class="anchor" title="Link to addMulVVW1536">#</a>
               </h3>
               
               <pre><code class="language-go">func addMulVVW1536(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addMulVVW1536" data-name="addMulVVW1536">
               <h3>
                  addMulVVW1536 
                  <span class="badge">function</span>
                  
                  <a href="#addMulVVW1536" class="anchor" title="Link to addMulVVW1536">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func addMulVVW1536(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addMulVVW2048" data-name="addMulVVW2048">
               <h3>
                  addMulVVW2048 
                  <span class="badge">function</span>
                  
                  <a href="#addMulVVW2048" class="anchor" title="Link to addMulVVW2048">#</a>
               </h3>
               
               <pre><code class="language-go">func addMulVVW2048(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addMulVVW2048" data-name="addMulVVW2048">
               <h3>
                  addMulVVW2048 
                  <span class="badge">function</span>
                  
                  <a href="#addMulVVW2048" class="anchor" title="Link to addMulVVW2048">#</a>
               </h3>
               
               <pre><code class="language-go">func addMulVVW2048(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addMulVVW2048" data-name="addMulVVW2048">
               <h3>
                  addMulVVW2048 
                  <span class="badge">function</span>
                  
                  <a href="#addMulVVW2048" class="anchor" title="Link to addMulVVW2048">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func addMulVVW2048(z *uint, x *uint, y uint) (c uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addMulVVWWasm" data-name="addMulVVWWasm">
               <h3>
                  addMulVVWWasm 
                  <span class="badge">function</span>
                  
                  <a href="#addMulVVWWasm" class="anchor" title="Link to addMulVVWWasm">#</a>
               </h3>
               
               <pre><code class="language-go">func addMulVVWWasm(z *uint, x *uint, y uint, n uintptr) (carry uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assign" data-name="assign">
               <h3>
                  assign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assign" class="anchor" title="Link to assign">#</a>
               </h3>
               
               <p>assign sets x <- y if on == 1, and does nothing otherwise.
Both operands must have the same announced length.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) assign(on choice, y *Nat) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bigEndianUint" data-name="bigEndianUint">
               <h3>
                  bigEndianUint 
                  <span class="badge">function</span>
                  
                  <a href="#bigEndianUint" class="anchor" title="Link to bigEndianUint">#</a>
               </h3>
               
               <p>bigEndianUint returns the contents of buf interpreted as a
big-endian encoded uint value.</p>
               
               <pre><code class="language-go">func bigEndianUint(buf []byte) uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bitLen" data-name="bitLen">
               <h3>
                  bitLen 
                  <span class="badge">function</span>
                  
                  <a href="#bitLen" class="anchor" title="Link to bitLen">#</a>
               </h3>
               
               <p>bitLen is a version of bits.Len that only leaks the bit length of n, but not
its value. bits.Len and bits.LeadingZeros use a lookup table for the
low-order bits on some architectures.</p>
               
               <pre><code class="language-go">func bitLen(n uint) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cmpGeq" data-name="cmpGeq">
               <h3>
                  cmpGeq 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cmpGeq" class="anchor" title="Link to cmpGeq">#</a>
               </h3>
               
               <p>cmpGeq returns 1 if x >= y, and 0 otherwise.
Both operands must have the same announced length.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) cmpGeq(y *Nat) choice</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ctEq" data-name="ctEq">
               <h3>
                  ctEq 
                  <span class="badge">function</span>
                  
                  <a href="#ctEq" class="anchor" title="Link to ctEq">#</a>
               </h3>
               
               <p>ctEq returns 1 if x == y, and 0 otherwise. The execution time of this
function does not depend on its inputs.</p>
               
               <pre><code class="language-go">func ctEq(x uint, y uint) choice</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ctMask" data-name="ctMask">
               <h3>
                  ctMask 
                  <span class="badge">function</span>
                  
                  <a href="#ctMask" class="anchor" title="Link to ctMask">#</a>
               </h3>
               
               <p>ctMask is all 1s if on is yes, and all 0s otherwise.</p>
               
               <pre><code class="language-go">func ctMask(on choice) uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expand" data-name="expand">
               <h3>
                  expand 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expand" class="anchor" title="Link to expand">#</a>
               </h3>
               
               <p>expand expands x to n limbs, leaving its value unchanged.</p>
               
               <pre><code class="language-go">func (x *Nat) expand(n int) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="extendedGCD" data-name="extendedGCD">
               <h3>
                  extendedGCD 
                  <span class="badge">function</span>
                  
                  <a href="#extendedGCD" class="anchor" title="Link to extendedGCD">#</a>
               </h3>
               
               <p>extendedGCD computes u and A such that a = GCD(a, m) and u = A*a - B*m.
u will have the size of the larger of a and m, and A will have the size of m.
It is an error if either a or m is zero, or if they are both even.</p>
               
               <pre><code class="language-go">func extendedGCD(a *Nat, m *Nat) (u *Nat, A *Nat, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="idx" data-name="idx">
               <h3>
                  idx 
                  <span class="badge">function</span>
                  
                  <a href="#idx" class="anchor" title="Link to idx">#</a>
               </h3>
               
               <pre><code class="language-go">func idx(x *uint, i uintptr) *uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maybeSubtractModulus" data-name="maybeSubtractModulus">
               <h3>
                  maybeSubtractModulus 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maybeSubtractModulus" class="anchor" title="Link to maybeSubtractModulus">#</a>
               </h3>
               
               <p>maybeSubtractModulus computes x -= m if and only if x >= m or if "always" is yes.
It can be used to reduce modulo m a value up to 2m - 1, which is a common
range for results computed by higher level operations.
always is usually a carry that indicates that the operation that produced x
overflowed its size, meaning abstractly x > 2^_W*n > m even if x < m.
x and m operands must have the same announced length.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) maybeSubtractModulus(always choice, m *Modulus)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="minusInverseModW" data-name="minusInverseModW">
               <h3>
                  minusInverseModW 
                  <span class="badge">function</span>
                  
                  <a href="#minusInverseModW" class="anchor" title="Link to minusInverseModW">#</a>
               </h3>
               
               <p>minusInverseModW computes -x⁻¹ mod _W with x odd.
This operation is used to precompute a constant involved in Montgomery
multiplication.</p>
               
               <pre><code class="language-go">func minusInverseModW(x uint) uint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="montgomeryMul" data-name="montgomeryMul">
               <h3>
                  montgomeryMul 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#montgomeryMul" class="anchor" title="Link to montgomeryMul">#</a>
               </h3>
               
               <p>montgomeryMul calculates x = a * b / R mod m, with R = 2^(_W * n) and
n = len(m.nat.limbs), also known as a Montgomery multiplication.
All inputs should be the same length and already reduced modulo m.
x will be resized to the size of m and overwritten.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) montgomeryMul(a *Nat, b *Nat, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="montgomeryReduction" data-name="montgomeryReduction">
               <h3>
                  montgomeryReduction 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#montgomeryReduction" class="anchor" title="Link to montgomeryReduction">#</a>
               </h3>
               
               <p>montgomeryReduction calculates x = x / R mod m, with R = 2^(_W * n) and
n = len(m.nat.limbs).
This assumes that x is already reduced mod m.</p>
               
               <pre><code class="language-go">func (x *Nat) montgomeryReduction(m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="montgomeryRepresentation" data-name="montgomeryRepresentation">
               <h3>
                  montgomeryRepresentation 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#montgomeryRepresentation" class="anchor" title="Link to montgomeryRepresentation">#</a>
               </h3>
               
               <p>montgomeryRepresentation calculates x = x * R mod m, with R = 2^(_W * n) and
n = len(m.nat.limbs).
Faster Montgomery multiplication replaces standard modular multiplication for
numbers in this representation.
This assumes that x is already reduced mod m.</p>
               
               <pre><code class="language-go">func (x *Nat) montgomeryRepresentation(m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newModulus" data-name="newModulus">
               <h3>
                  newModulus 
                  <span class="badge">function</span>
                  
                  <a href="#newModulus" class="anchor" title="Link to newModulus">#</a>
               </h3>
               
               <pre><code class="language-go">func newModulus(n *Nat) (*Modulus, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="not" data-name="not">
               <h3>
                  not 
                  <span class="badge">function</span>
                  
                  <a href="#not" class="anchor" title="Link to not">#</a>
               </h3>
               
               <pre><code class="language-go">func not(c choice) choice</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reset" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reset" class="anchor" title="Link to reset">#</a>
               </h3>
               
               <p>reset returns a zero nat of n limbs, reusing x's storage if n <= cap(x.limbs).</p>
               
               <pre><code class="language-go">func (x *Nat) reset(n int) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resetFor" data-name="resetFor">
               <h3>
                  resetFor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#resetFor" class="anchor" title="Link to resetFor">#</a>
               </h3>
               
               <p>resetFor ensures out has the right size to work with operations modulo m.
out is zeroed and may start at any size.</p>
               
               <pre><code class="language-go">func (out *Nat) resetFor(m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resetToBytes" data-name="resetToBytes">
               <h3>
                  resetToBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#resetToBytes" class="anchor" title="Link to resetToBytes">#</a>
               </h3>
               
               <p>resetToBytes assigns x = b, where b is a slice of big-endian bytes, resizing
n to the appropriate size.
The announced length of x is set based on the actual bit size of the input,
ignoring leading zeroes.</p>
               
               <pre><code class="language-go">func (x *Nat) resetToBytes(b []byte) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rr" data-name="rr">
               <h3>
                  rr 
                  <span class="badge">function</span>
                  
                  <a href="#rr" class="anchor" title="Link to rr">#</a>
               </h3>
               
               <p>rr returns R*R with R = 2^(_W * n) and n = len(m.nat.limbs).</p>
               
               <pre><code class="language-go">func rr(m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rshift1" data-name="rshift1">
               <h3>
                  rshift1 
                  <span class="badge">function</span>
                  
                  <a href="#rshift1" class="anchor" title="Link to rshift1">#</a>
               </h3>
               
               <p>go:norace</p>
               
               <pre><code class="language-go">func rshift1(a *Nat, carry uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="set" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#set" class="anchor" title="Link to set">#</a>
               </h3>
               
               <p>set assigns x = y, optionally resizing x to the appropriate size.</p>
               
               <pre><code class="language-go">func (x *Nat) set(y *Nat) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setBytes" data-name="setBytes">
               <h3>
                  setBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setBytes" class="anchor" title="Link to setBytes">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *Nat) setBytes(b []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shiftIn" data-name="shiftIn">
               <h3>
                  shiftIn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shiftIn" class="anchor" title="Link to shiftIn">#</a>
               </h3>
               
               <p>shiftIn calculates x = x << _W + y mod m.
This assumes that x is already reduced mod m.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) shiftIn(y uint, m *Modulus) *Nat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sub" data-name="sub">
               <h3>
                  sub 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sub" class="anchor" title="Link to sub">#</a>
               </h3>
               
               <p>sub computes x -= y. It returns the borrow of the subtraction.
Both operands must have the same announced length.
go:norace</p>
               
               <pre><code class="language-go">func (x *Nat) sub(y *Nat) (c uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trim" data-name="trim">
               <h3>
                  trim 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#trim" class="anchor" title="Link to trim">#</a>
               </h3>
               
               <p>trim reduces the size of x to match its value.</p>
               
               <pre><code class="language-go">func (x *Nat) trim() *Nat</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>