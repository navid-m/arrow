<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - liveness</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>liveness</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"fmt"
"os"
"slices"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/bitvec"
"cmd/compile/internal/ir"
"cmd/compile/internal/ssa"
"cmd/internal/src"
"fmt"
"os"
"path/filepath"
"slices"
"sort"
"strings"
"cmp"
"fmt"
"os"
"slices"
"sort"
"strings"
"cmd/compile/internal/abi"
"cmd/compile/internal/base"
"cmd/compile/internal/bitvec"
"cmd/compile/internal/ir"
"cmd/compile/internal/objw"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/ssa"
"cmd/compile/internal/typebits"
"cmd/compile/internal/types"
"cmd/internal/hash"
"cmd/internal/obj"
"cmd/internal/src"
rtabi "internal/abi"
"fmt"
"internal/abi"
"cmd/compile/internal/base"
"cmd/compile/internal/bitvec"
"cmd/compile/internal/ir"
"cmd/compile/internal/objw"
"cmd/compile/internal/ssa"
"cmd/internal/obj"
"cmd/compile/internal/bitvec"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="allLiveIdx" data-name="allLiveIdx">
               <h3>
                  allLiveIdx 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#allLiveIdx" class="anchor" title="Link to allLiveIdx">#</a>
               </h3>
               
               <pre><code class="language-go">const allLiveIdx = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugtrace" data-name="debugtrace">
               <h3>
                  debugtrace 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debugtrace" class="anchor" title="Link to debugtrace">#</a>
               </h3>
               
               <pre><code class="language-go">const debugtrace = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="h0" data-name="h0">
               <h3>
                  h0 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#h0" class="anchor" title="Link to h0">#</a>
               </h3>
               
               <p>FNV-1 hash function constants.</p>
               
               <pre><code class="language-go">const h0 = 2166136261</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hp" data-name="hp">
               <h3>
                  hp 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#hp" class="anchor" title="Link to hp">#</a>
               </h3>
               
               <p>FNV-1 hash function constants.</p>
               
               <pre><code class="language-go">const hp = 16777619</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="uevar" data-name="uevar">
               <h3>
                  uevar 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#uevar" class="anchor" title="Link to uevar">#</a>
               </h3>
               
               <pre><code class="language-go">const uevar liveEffect = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="varkill" data-name="varkill">
               <h3>
                  varkill 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#varkill" class="anchor" title="Link to varkill">#</a>
               </h3>
               
               <pre><code class="language-go">const varkill</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="Intervals" data-name="Intervals">
               <h3>
                  Intervals
                  <span class="badge type-badge">type</span>
                  <a href="#Intervals" class="anchor" title="Link to Intervals">#</a>
               </h3>
               
               <p>Intervals is a sequence of sorted, disjoint intervals.</p>
               
               <pre><code class="language-go">type Intervals []Interval</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="liveEffect" data-name="liveEffect">
               <h3>
                  liveEffect
                  <span class="badge type-badge">type</span>
                  <a href="#liveEffect" class="anchor" title="Link to liveEffect">#</a>
               </h3>
               
               <p>A liveEffect is a set of flags that describe an instruction's
liveness effects on a variable.
The possible flags are:
uevar - used by the instruction
varkill - killed by the instruction (set)
A kill happens after the use (for an instruction that updates a value, for example).</p>
               
               <pre><code class="language-go">type liveEffect int</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Interval" data-name="Interval">
               <h3>
                  Interval
                  <span class="badge">struct</span>
                  <a href="#Interval" class="anchor" title="Link to Interval">#</a>
               </h3>
               
               <p>Interval hols the range [st,en).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Interval struct {
st int
en int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="IntervalsBuilder" data-name="IntervalsBuilder">
               <h3>
                  IntervalsBuilder
                  <span class="badge">struct</span>
                  <a href="#IntervalsBuilder" class="anchor" title="Link to IntervalsBuilder">#</a>
               </h3>
               
               <p>IntervalsBuilder is a helper for constructing intervals based on
live dataflow sets for a series of BBs where we're making a
backwards pass over each BB looking for uses and kills. The
expected use case is:
- invoke MakeIntervalsBuilder to create a new object "b"
- series of calls to b.Live/b.Kill based on a backwards reverse layout
order scan over instructions
- invoke b.Finish() to produce final set
See the Live method comment for an IR example.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type IntervalsBuilder struct {
s Intervals
lidx int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Map" data-name="Map">
               <h3>
                  Map
                  <span class="badge">struct</span>
                  <a href="#Map" class="anchor" title="Link to Map">#</a>
               </h3>
               
               <p>Map maps from *ssa.Value to StackMapIndex.
Also keeps track of unsafe ssa.Values and ssa.Blocks.
(unsafe = can't be interrupted during GC.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Map struct {
Vals map[ssa.ID]objw.StackMapIndex
UnsafeVals map[ssa.ID]bool
UnsafeBlocks map[ssa.ID]bool
DeferReturn objw.StackMapIndex
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="MergeLocalsState" data-name="MergeLocalsState">
               <h3>
                  MergeLocalsState
                  <span class="badge">struct</span>
                  <a href="#MergeLocalsState" class="anchor" title="Link to MergeLocalsState">#</a>
               </h3>
               
               <p>MergeLocalsState encapsulates information about which AUTO
(stack-allocated) variables within a function can be safely
merged/overlapped, e.g. share a stack slot with some other auto).
An instance of MergeLocalsState is produced by MergeLocals() below
and then consumed in ssagen.AllocFrame. The map 'partition'
contains entries of the form <N,SL> where N is an *ir.Name and SL
is a slice holding the indices (within 'vars') of other variables
that share the same slot, specifically the slot of the first
element in the partition, which we'll call the "leader". For
example, if a function contains five variables where v1/v2/v3 are
safe to overlap and v4/v5 are safe to overlap, the MergeLocalsState
content might look like
vars: [v1, v2, v3, v4, v5]
partition: v1 -> [1, 0, 2], v2 -> [1, 0, 2], v3 -> [1, 0, 2]
v4 -> [3, 4], v5 -> [3, 4]
A nil MergeLocalsState indicates that no local variables meet the
necessary criteria for overlap.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type MergeLocalsState struct {
vars []*ir.Name
partition map[*ir.Name][]int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="argLiveness" data-name="argLiveness">
               <h3>
                  argLiveness
                  <span class="badge">struct</span>
                  <a href="#argLiveness" class="anchor" title="Link to argLiveness">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type argLiveness struct {
fn *ir.Func
f *ssa.Func
args []nameOff
idx map[nameOff]int32
be []blockArgEffects
bvset bvecSet
blockIdx map[ssa.ID]int
valueIdx map[ssa.ID]int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="blockArgEffects" data-name="blockArgEffects">
               <h3>
                  blockArgEffects
                  <span class="badge">struct</span>
                  <a href="#blockArgEffects" class="anchor" title="Link to blockArgEffects">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type blockArgEffects struct {
livein bitvec.BitVec
liveout bitvec.BitVec
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="blockEffects" data-name="blockEffects">
               <h3>
                  blockEffects
                  <span class="badge">struct</span>
                  <a href="#blockEffects" class="anchor" title="Link to blockEffects">#</a>
               </h3>
               
               <p>blockEffects summarizes the liveness effects on an SSA block.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type blockEffects struct {
uevar bitvec.BitVec
varkill bitvec.BitVec
livein bitvec.BitVec
liveout bitvec.BitVec
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="bvecSet" data-name="bvecSet">
               <h3>
                  bvecSet
                  <span class="badge">struct</span>
                  <a href="#bvecSet" class="anchor" title="Link to bvecSet">#</a>
               </h3>
               
               <p>bvecSet is a set of bvecs, in initial insertion order.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type bvecSet struct {
index []int
uniq []bitvec.BitVec
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="candRegion" data-name="candRegion">
               <h3>
                  candRegion
                  <span class="badge">struct</span>
                  <a href="#candRegion" class="anchor" title="Link to candRegion">#</a>
               </h3>
               
               <p>candRegion is a sub-range (start, end) corresponding to an interval
[st,en] within the list of candidate variables.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type candRegion struct {
st int
en int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cstate" data-name="cstate">
               <h3>
                  cstate
                  <span class="badge">struct</span>
                  <a href="#cstate" class="anchor" title="Link to cstate">#</a>
               </h3>
               
               <p>cstate holds state information we'll need during the analysis
phase of stack slot merging but can be discarded when the analysis
is done.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type cstate struct {
fn *ir.Func
f *ssa.Func
lv *liveness
cands []*ir.Name
nameToSlot map[*ir.Name]int32
regions []candRegion
indirectUE map[ssa.ID][]*ir.Name
ivs []Intervals
hashDeselected map[*ir.Name]bool
trace int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="intWithIdx" data-name="intWithIdx">
               <h3>
                  intWithIdx
                  <span class="badge">struct</span>
                  <a href="#intWithIdx" class="anchor" title="Link to intWithIdx">#</a>
               </h3>
               
               <p>intWithIdx holds an interval i and an index pairIndex storing i's
position (either 0 or 1) within some previously specified interval
pair <I1,I2>; a pairIndex of -1 is used to signal "end of
iteration". Used for Intervals operations, not expected to be
exported.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type intWithIdx struct {
i Interval
pairIndex int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="liveness" data-name="liveness">
               <h3>
                  liveness
                  <span class="badge">struct</span>
                  <a href="#liveness" class="anchor" title="Link to liveness">#</a>
               </h3>
               
               <p>A collection of global state used by liveness analysis.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type liveness struct {
fn *ir.Func
f *ssa.Func
vars []*ir.Name
idx map[*ir.Name]int32
stkptrsize int64
be []blockEffects
allUnsafe bool
unsafePoints bitvec.BitVec
unsafeBlocks bitvec.BitVec
livevars []bitvec.BitVec
livenessMap Map
stackMapSet bvecSet
stackMaps []bitvec.BitVec
cache progeffectscache
partLiveArgs map[*ir.Name]bool
doClobber bool
noClobberArgs bool
conservativeWrites bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="livenessFuncCache" data-name="livenessFuncCache">
               <h3>
                  livenessFuncCache
                  <span class="badge">struct</span>
                  <a href="#livenessFuncCache" class="anchor" title="Link to livenessFuncCache">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type livenessFuncCache struct {
be []blockEffects
livenessMap Map
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="nameCount" data-name="nameCount">
               <h3>
                  nameCount
                  <span class="badge">struct</span>
                  <a href="#nameCount" class="anchor" title="Link to nameCount">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type nameCount struct {
n *ir.Name
count int32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="nameOff" data-name="nameOff">
               <h3>
                  nameOff
                  <span class="badge">struct</span>
                  <a href="#nameOff" class="anchor" title="Link to nameOff">#</a>
               </h3>
               
               <p>name and offset</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type nameOff struct {
n *ir.Name
off int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pairVisitor" data-name="pairVisitor">
               <h3>
                  pairVisitor
                  <span class="badge">struct</span>
                  <a href="#pairVisitor" class="anchor" title="Link to pairVisitor">#</a>
               </h3>
               
               <p>pairVisitor provides a way to visit (iterate through) each interval
within a pair of Intervals in order of increasing start time. Expected
usage model:
func example(i1, i2 Intervals) {
var pairVisitor pv
cur := pv.init(i1, i2);
for !cur.done() {
fmt.Printf("interval %s from i%d", cur.i.String(), cur.pairIndex+1)
cur = pv.nxt()
}
}
Used internally for Intervals operations, not expected to be exported.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type pairVisitor struct {
cur intWithIdx
i1pos int
i2pos int
i1 Intervals
i2 Intervals
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="progeffectscache" data-name="progeffectscache">
               <h3>
                  progeffectscache
                  <span class="badge">struct</span>
                  <a href="#progeffectscache" class="anchor" title="Link to progeffectscache">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type progeffectscache struct {
retuevar []int32
tailuevar []int32
initialized bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="ArgLiveness" data-name="ArgLiveness">
               <h3>
                  ArgLiveness 
                  <span class="badge">function</span>
                  
                  <a href="#ArgLiveness" class="anchor" title="Link to ArgLiveness">#</a>
               </h3>
               
               <p>ArgLiveness computes the liveness information of register argument spill slots.
An argument's spill slot is "live" if we know it contains a meaningful value,
that is, we have stored the register value to it.
Returns the liveness map indices at each Block entry and at each Value (where
it changes).</p>
               
               <pre><code class="language-go">func ArgLiveness(fn *ir.Func, f *ssa.Func, pp *objw.Progs) (blockIdx map[ssa.ID]int, valueIdx map[ssa.ID]int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Compute" data-name="Compute">
               <h3>
                  Compute 
                  <span class="badge">function</span>
                  
                  <a href="#Compute" class="anchor" title="Link to Compute">#</a>
               </h3>
               
               <p>Entry pointer for Compute analysis. Solves for the Compute of
pointer variables in the function and emits a runtime data
structure read by the garbage collector.
Returns a map from GC safe points to their corresponding stack map index,
and a map that contains all input parameters that may be partially live.</p>
               
               <pre><code class="language-go">func Compute(curfn *ir.Func, f *ssa.Func, stkptrsize int64, pp *objw.Progs) (Map, map[*ir.Name]bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EstSavings" data-name="EstSavings">
               <h3>
                  EstSavings 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EstSavings" class="anchor" title="Link to EstSavings">#</a>
               </h3>
               
               <p>EstSavings returns the estimated reduction in stack size (number of bytes) for
the given merge locals state via a pair of ints, the first for non-pointer types and the second for pointer types.</p>
               
               <pre><code class="language-go">func (mls *MergeLocalsState) EstSavings() (int, int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Finish" data-name="Finish">
               <h3>
                  Finish 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Finish" class="anchor" title="Link to Finish">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *IntervalsBuilder) Finish() (Intervals, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Followers" data-name="Followers">
               <h3>
                  Followers 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Followers" class="anchor" title="Link to Followers">#</a>
               </h3>
               
               <p>Followers writes a list of the followers for leader n into the slice tmp.</p>
               
               <pre><code class="language-go">func (mls *MergeLocalsState) Followers(n *ir.Name, tmp []*ir.Name) []*ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FrameOffset" data-name="FrameOffset">
               <h3>
                  FrameOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FrameOffset" class="anchor" title="Link to FrameOffset">#</a>
               </h3>
               
               <pre><code class="language-go">func (a nameOff) FrameOffset() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Get" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Get" class="anchor" title="Link to Get">#</a>
               </h3>
               
               <pre><code class="language-go">func (m Map) Get(v *ssa.Value) objw.StackMapIndex</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetUnsafe" data-name="GetUnsafe">
               <h3>
                  GetUnsafe 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GetUnsafe" class="anchor" title="Link to GetUnsafe">#</a>
               </h3>
               
               <pre><code class="language-go">func (m Map) GetUnsafe(v *ssa.Value) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetUnsafeBlock" data-name="GetUnsafeBlock">
               <h3>
                  GetUnsafeBlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GetUnsafeBlock" class="anchor" title="Link to GetUnsafeBlock">#</a>
               </h3>
               
               <pre><code class="language-go">func (m Map) GetUnsafeBlock(b *ssa.Block) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsLeader" data-name="IsLeader">
               <h3>
                  IsLeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsLeader" class="anchor" title="Link to IsLeader">#</a>
               </h3>
               
               <p>IsLeader returns whether a variable n is the leader (first element)
in a sharing partition.</p>
               
               <pre><code class="language-go">func (mls *MergeLocalsState) IsLeader(n *ir.Name) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsUnsafe" data-name="IsUnsafe">
               <h3>
                  IsUnsafe 
                  <span class="badge">function</span>
                  
                  <a href="#IsUnsafe" class="anchor" title="Link to IsUnsafe">#</a>
               </h3>
               
               <p>IsUnsafe indicates that all points in this function are
unsafe-points.</p>
               
               <pre><code class="language-go">func IsUnsafe(f *ssa.Func) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Kill" data-name="Kill">
               <h3>
                  Kill 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Kill" class="anchor" title="Link to Kill">#</a>
               </h3>
               
               <p>Kill method should be invoked on instruction at position p if instr
should be treated as having a kill (lifetime end) for the
resource. See the example in the comment at the beginning of this
file for an example. Note that if we see a kill at position K for a
resource currently live since J, this will result in a lifetime
segment of [K+1,J+1), the assumption being that the first live
instruction will be the one after the kill position, not the kill
position itself.</p>
               
               <pre><code class="language-go">func (c *IntervalsBuilder) Kill(pos int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Leader" data-name="Leader">
               <h3>
                  Leader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Leader" class="anchor" title="Link to Leader">#</a>
               </h3>
               
               <p>Leader returns the leader variable for subsumed var n.</p>
               
               <pre><code class="language-go">func (mls *MergeLocalsState) Leader(n *ir.Name) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Live" data-name="Live">
               <h3>
                  Live 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Live" class="anchor" title="Link to Live">#</a>
               </h3>
               
               <p>Live method should be invoked on instruction at position p if instr
contains an upwards-exposed use of a resource. See the example in
the comment at the beginning of this file for an example.</p>
               
               <pre><code class="language-go">func (c *IntervalsBuilder) Live(pos int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MakeMergeLocalsState" data-name="MakeMergeLocalsState">
               <h3>
                  MakeMergeLocalsState 
                  <span class="badge">function</span>
                  
                  <a href="#MakeMergeLocalsState" class="anchor" title="Link to MakeMergeLocalsState">#</a>
               </h3>
               
               <p>for unit testing only.</p>
               
               <pre><code class="language-go">func MakeMergeLocalsState(partition map[*ir.Name][]int, vars []*ir.Name) (*MergeLocalsState, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Merge" data-name="Merge">
               <h3>
                  Merge 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Merge" class="anchor" title="Link to Merge">#</a>
               </h3>
               
               <p>Merge combines the intervals from "is" and "is2" and returns
a new Intervals object containing all combined ranges from the
two inputs.</p>
               
               <pre><code class="language-go">func (is Intervals) Merge(is2 Intervals) Intervals</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MergeInto" data-name="MergeInto">
               <h3>
                  MergeInto 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MergeInto" class="anchor" title="Link to MergeInto">#</a>
               </h3>
               
               <p>MergeInto merges interval i2 into i1. This version happens to
require that the two intervals either overlap or are adjacent.</p>
               
               <pre><code class="language-go">func (i1 *Interval) MergeInto(i2 Interval) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MergeLocals" data-name="MergeLocals">
               <h3>
                  MergeLocals 
                  <span class="badge">function</span>
                  
                  <a href="#MergeLocals" class="anchor" title="Link to MergeLocals">#</a>
               </h3>
               
               <p>MergeLocals analyzes the specified ssa function f to determine which
of its auto variables can safely share the same stack slot, returning
a state object that describes how the overlap should be done.</p>
               
               <pre><code class="language-go">func MergeLocals(fn *ir.Func, f *ssa.Func) *MergeLocalsState</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Overlaps" data-name="Overlaps">
               <h3>
                  Overlaps 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Overlaps" class="anchor" title="Link to Overlaps">#</a>
               </h3>
               
               <p>Overlaps returns true if here is any overlap between i and i2.</p>
               
               <pre><code class="language-go">func (i Interval) Overlaps(i2 Interval) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Overlaps" data-name="Overlaps">
               <h3>
                  Overlaps 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Overlaps" class="anchor" title="Link to Overlaps">#</a>
               </h3>
               
               <p>Overlaps returns whether any of the component ranges in is overlaps
with some range in is2.</p>
               
               <pre><code class="language-go">func (is Intervals) Overlaps(is2 Intervals) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (is *Intervals) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (i Interval) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (mls *MergeLocalsState) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (a nameOff) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Subsumed" data-name="Subsumed">
               <h3>
                  Subsumed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Subsumed" class="anchor" title="Link to Subsumed">#</a>
               </h3>
               
               <p>Subsumed returns whether variable n is subsumed, e.g. appears
in an overlap position but is not the leader in that partition.</p>
               
               <pre><code class="language-go">func (mls *MergeLocalsState) Subsumed(n *ir.Name) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteFuncMap" data-name="WriteFuncMap">
               <h3>
                  WriteFuncMap 
                  <span class="badge">function</span>
                  
                  <a href="#WriteFuncMap" class="anchor" title="Link to WriteFuncMap">#</a>
               </h3>
               
               <p>WriteFuncMap writes the pointer bitmaps for bodyless function fn's
inputs and outputs as the value of symbol <fn>.args_stackmap.
If fn has outputs, two bitmaps are written, otherwise just one.</p>
               
               <pre><code class="language-go">func WriteFuncMap(fn *ir.Func, abiInfo *abi.ABIParamResultInfo)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <p>add adds bv to the set and returns its index in m.extractUnique,
and whether it is newly added.
If it is newly added, the caller must not modify bv after this.</p>
               
               <pre><code class="language-go">func (m *bvecSet) add(bv bitvec.BitVec) (int, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="adjacent" data-name="adjacent">
               <h3>
                  adjacent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#adjacent" class="anchor" title="Link to adjacent">#</a>
               </h3>
               
               <p>adjacent returns true if the start of one interval is equal to the
end of another interval (e.g. they represent consecutive ranges).</p>
               
               <pre><code class="language-go">func (i1 Interval) adjacent(i2 Interval) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="affectedVar" data-name="affectedVar">
               <h3>
                  affectedVar 
                  <span class="badge">function</span>
                  
                  <a href="#affectedVar" class="anchor" title="Link to affectedVar">#</a>
               </h3>
               
               <p>affectedVar returns the *ir.Name node affected by v.</p>
               
               <pre><code class="language-go">func affectedVar(v *ssa.Value) (*ir.Name, ssa.SymEffect)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="blockEffects" data-name="blockEffects">
               <h3>
                  blockEffects 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#blockEffects" class="anchor" title="Link to blockEffects">#</a>
               </h3>
               
               <pre><code class="language-go">func (lv *liveness) blockEffects(b *ssa.Block) *blockEffects</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="check" data-name="check">
               <h3>
                  check 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#check" class="anchor" title="Link to check">#</a>
               </h3>
               
               <p>check tests for various inconsistencies and problems in mls,
returning an error if any problems are found.</p>
               
               <pre><code class="language-go">func (mls *MergeLocalsState) check() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="check" data-name="check">
               <h3>
                  check 
                  <span class="badge">function</span>
                  
                  <a href="#check" class="anchor" title="Link to check">#</a>
               </h3>
               
               <p>check examines the intervals in "is" to try to find internal
inconsistencies or problems.</p>
               
               <pre><code class="language-go">func check(is Intervals) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clobber" data-name="clobber">
               <h3>
                  clobber 
                  <span class="badge">function</span>
                  
                  <a href="#clobber" class="anchor" title="Link to clobber">#</a>
               </h3>
               
               <p>clobber generates code to clobber pointer slots in all dead variables
(those not marked in live). Clobbering instructions are added to the end
of b.Values.</p>
               
               <pre><code class="language-go">func clobber(lv *liveness, b *ssa.Block, live bitvec.BitVec)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clobber" data-name="clobber">
               <h3>
                  clobber 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#clobber" class="anchor" title="Link to clobber">#</a>
               </h3>
               
               <p>Inserts code to clobber pointer slots in all the dead variables (locals and args)
at every synchronous safepoint in b.</p>
               
               <pre><code class="language-go">func (lv *liveness) clobber(b *ssa.Block)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clobberPtr" data-name="clobberPtr">
               <h3>
                  clobberPtr 
                  <span class="badge">function</span>
                  
                  <a href="#clobberPtr" class="anchor" title="Link to clobberPtr">#</a>
               </h3>
               
               <p>clobberPtr generates a clobber of the pointer at offset offset in v.
The clobber instruction is added at the end of b.</p>
               
               <pre><code class="language-go">func clobberPtr(b *ssa.Block, v *ir.Name, offset int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clobberVar" data-name="clobberVar">
               <h3>
                  clobberVar 
                  <span class="badge">function</span>
                  
                  <a href="#clobberVar" class="anchor" title="Link to clobberVar">#</a>
               </h3>
               
               <p>clobberVar generates code to trash the pointers in v.
Clobbering instructions are added to the end of b.Values.</p>
               
               <pre><code class="language-go">func clobberVar(b *ssa.Block, v *ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clobberWalk" data-name="clobberWalk">
               <h3>
                  clobberWalk 
                  <span class="badge">function</span>
                  
                  <a href="#clobberWalk" class="anchor" title="Link to clobberWalk">#</a>
               </h3>
               
               <p>b = block to which we append instructions
v = variable
offset = offset of (sub-portion of) variable to clobber (in bytes)
t = type of sub-portion of v.</p>
               
               <pre><code class="language-go">func clobberWalk(b *ssa.Block, v *ir.Name, offset int64, t *types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="collectMergeCandidates" data-name="collectMergeCandidates">
               <h3>
                  collectMergeCandidates 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#collectMergeCandidates" class="anchor" title="Link to collectMergeCandidates">#</a>
               </h3>
               
               <p>collectMergeCandidates visits all of the AUTO vars declared in
function fn and identifies a list of candidate variables for
merging / overlapping. On return the "cands" field of cs will be
filled in with our set of potentially overlappable candidate
variables, the "regions" field will hold regions/sequence of
compatible vars within the candidates list, "nameToSlot" field will
be populated, and the "indirectUE" field will be filled in with
information about indirect upwards-exposed uses in the func.</p>
               
               <pre><code class="language-go">func (cs *cstate) collectMergeCandidates()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compact" data-name="compact">
               <h3>
                  compact 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#compact" class="anchor" title="Link to compact">#</a>
               </h3>
               
               <p>Compact coalesces identical bitmaps from lv.livevars into the sets
lv.stackMapSet.
Compact clears lv.livevars.
There are actually two lists of bitmaps, one list for the local variables and one
list for the function arguments. Both lists are indexed by the same PCDATA
index, so the corresponding pairs must be considered together when
merging duplicates. The argument bitmaps change much less often during
function execution than the local variable bitmaps, so it is possible that
we could introduce a separate PCDATA index for arguments vs locals and
then compact the set of argument bitmaps separately from the set of
local variable bitmaps. As of 2014-04-02, doing this to the godoc binary
is actually a net loss: we save about 50k of argument bitmaps but the new
PCDATA tables cost about 100k. So for now we keep using a single index for
both bitmap lists.</p>
               
               <pre><code class="language-go">func (lv *liveness) compact(b *ssa.Block)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="computeIntervals" data-name="computeIntervals">
               <h3>
                  computeIntervals 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#computeIntervals" class="anchor" title="Link to computeIntervals">#</a>
               </h3>
               
               <p>computeIntervals performs a backwards sweep over the instructions
of the function we're compiling, building up an Intervals object
for each candidate variable by looking for upwards exposed uses
and kills.</p>
               
               <pre><code class="language-go">func (cs *cstate) computeIntervals()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="done" data-name="done">
               <h3>
                  done 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#done" class="anchor" title="Link to done">#</a>
               </h3>
               
               <pre><code class="language-go">func (iwi intWithIdx) done() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dumpCand" data-name="dumpCand">
               <h3>
                  dumpCand 
                  <span class="badge">function</span>
                  
                  <a href="#dumpCand" class="anchor" title="Link to dumpCand">#</a>
               </h3>
               
               <pre><code class="language-go">func dumpCand(c *ir.Name, i int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dumpFunc" data-name="dumpFunc">
               <h3>
                  dumpFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dumpFunc" class="anchor" title="Link to dumpFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func (cs *cstate) dumpFunc()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dumpFuncIfSelected" data-name="dumpFuncIfSelected">
               <h3>
                  dumpFuncIfSelected 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dumpFuncIfSelected" class="anchor" title="Link to dumpFuncIfSelected">#</a>
               </h3>
               
               <pre><code class="language-go">func (cs *cstate) dumpFuncIfSelected()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emit" data-name="emit">
               <h3>
                  emit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#emit" class="anchor" title="Link to emit">#</a>
               </h3>
               
               <pre><code class="language-go">func (lv *argLiveness) emit() *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emit" data-name="emit">
               <h3>
                  emit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#emit" class="anchor" title="Link to emit">#</a>
               </h3>
               
               <p>Dumps a slice of bitmaps to a symbol as a sequence of uint32 values. The
first word dumped is the total number of bitmaps. The second word is the
length of the bitmaps. All bitmaps are assumed to be of equal length. The
remaining bytes are the raw bitmaps.</p>
               
               <pre><code class="language-go">func (lv *liveness) emit() (argsSym *obj.LSym, liveSym *obj.LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitStackObjects" data-name="emitStackObjects">
               <h3>
                  emitStackObjects 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#emitStackObjects" class="anchor" title="Link to emitStackObjects">#</a>
               </h3>
               
               <pre><code class="language-go">func (lv *liveness) emitStackObjects() *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="enableClobber" data-name="enableClobber">
               <h3>
                  enableClobber 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#enableClobber" class="anchor" title="Link to enableClobber">#</a>
               </h3>
               
               <pre><code class="language-go">func (lv *liveness) enableClobber()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="epilogue" data-name="epilogue">
               <h3>
                  epilogue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#epilogue" class="anchor" title="Link to epilogue">#</a>
               </h3>
               
               <p>Visits all instructions in a basic block and computes a bit vector of live
variables at each safe point locations.</p>
               
               <pre><code class="language-go">func (lv *liveness) epilogue()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="extractUnique" data-name="extractUnique">
               <h3>
                  extractUnique 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#extractUnique" class="anchor" title="Link to extractUnique">#</a>
               </h3>
               
               <p>extractUnique returns this slice of unique bit vectors in m, as
indexed by the result of bvecSet.add.</p>
               
               <pre><code class="language-go">func (m *bvecSet) extractUnique() []bitvec.BitVec</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtFullPos" data-name="fmtFullPos">
               <h3>
                  fmtFullPos 
                  <span class="badge">function</span>
                  
                  <a href="#fmtFullPos" class="anchor" title="Link to fmtFullPos">#</a>
               </h3>
               
               <pre><code class="language-go">func fmtFullPos(p src.XPos) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="genRegions" data-name="genRegions">
               <h3>
                  genRegions 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#genRegions" class="anchor" title="Link to genRegions">#</a>
               </h3>
               
               <p>genRegions generates a set of regions within cands corresponding
to potentially overlappable/mergeable variables.</p>
               
               <pre><code class="language-go">func (cs *cstate) genRegions(cands []*ir.Name) ([]*ir.Name, []candRegion)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getvariables" data-name="getvariables">
               <h3>
                  getvariables 
                  <span class="badge">function</span>
                  
                  <a href="#getvariables" class="anchor" title="Link to getvariables">#</a>
               </h3>
               
               <p>getvariables returns the list of on-stack variables that we need to track
and a map for looking up indices by *Node.</p>
               
               <pre><code class="language-go">func getvariables(fn *ir.Func) ([]*ir.Name, map[*ir.Name]int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="grow" data-name="grow">
               <h3>
                  grow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#grow" class="anchor" title="Link to grow">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *bvecSet) grow()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasStackMap" data-name="hasStackMap">
               <h3>
                  hasStackMap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasStackMap" class="anchor" title="Link to hasStackMap">#</a>
               </h3>
               
               <p>Returns true for instructions that must have a stack map.
This does not necessarily mean the instruction is a safe-point. In
particular, call Values can have a stack map in case the callee
grows the stack, but not themselves be a safe-point.</p>
               
               <pre><code class="language-go">func (lv *liveness) hasStackMap(v *ssa.Value) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashbitmap" data-name="hashbitmap">
               <h3>
                  hashbitmap 
                  <span class="badge">function</span>
                  
                  <a href="#hashbitmap" class="anchor" title="Link to hashbitmap">#</a>
               </h3>
               
               <pre><code class="language-go">func hashbitmap(h uint32, bv bitvec.BitVec) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="imax" data-name="imax">
               <h3>
                  imax 
                  <span class="badge">function</span>
                  
                  <a href="#imax" class="anchor" title="Link to imax">#</a>
               </h3>
               
               <p>TEMPORARY until bootstrap version catches up.</p>
               
               <pre><code class="language-go">func imax(i int, j int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="imin" data-name="imin">
               <h3>
                  imin 
                  <span class="badge">function</span>
                  
                  <a href="#imin" class="anchor" title="Link to imin">#</a>
               </h3>
               
               <p>TEMPORARY until bootstrap version catches up.</p>
               
               <pre><code class="language-go">func imin(i int, j int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <p>init initializes a pairVisitor for the specified pair of intervals
i1 and i2 and returns an intWithIdx object that points to the first
interval by start position within i1/i2.</p>
               
               <pre><code class="language-go">func (pv *pairVisitor) init(i1 Intervals, i2 Intervals) intWithIdx</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initcache" data-name="initcache">
               <h3>
                  initcache 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initcache" class="anchor" title="Link to initcache">#</a>
               </h3>
               
               <pre><code class="language-go">func (lv *liveness) initcache()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isfat" data-name="isfat">
               <h3>
                  isfat 
                  <span class="badge">function</span>
                  
                  <a href="#isfat" class="anchor" title="Link to isfat">#</a>
               </h3>
               
               <p>isfat reports whether a variable of type t needs multiple assignments to initialize.
For example:
type T struct { x, y int }
x := T{x: 0, y: 1}
Then we need:
var t T
t.x = 0
t.y = 1
to fully initialize t.</p>
               
               <pre><code class="language-go">func isfat(t *types.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="last" data-name="last">
               <h3>
                  last 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#last" class="anchor" title="Link to last">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *IntervalsBuilder) last() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="markUnsafePoints" data-name="markUnsafePoints">
               <h3>
                  markUnsafePoints 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#markUnsafePoints" class="anchor" title="Link to markUnsafePoints">#</a>
               </h3>
               
               <p>markUnsafePoints finds unsafe points and computes lv.unsafePoints.</p>
               
               <pre><code class="language-go">func (lv *liveness) markUnsafePoints()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mayFault" data-name="mayFault">
               <h3>
                  mayFault 
                  <span class="badge">function</span>
                  
                  <a href="#mayFault" class="anchor" title="Link to mayFault">#</a>
               </h3>
               
               <pre><code class="language-go">func mayFault(v *ssa.Value) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mergeVisitRegion" data-name="mergeVisitRegion">
               <h3>
                  mergeVisitRegion 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mergeVisitRegion" class="anchor" title="Link to mergeVisitRegion">#</a>
               </h3>
               
               <p>mergeVisitRegion tries to perform overlapping of variables with a
given subrange of cands described by st and en (indices into our
candidate var list), where the variables within this range have
already been determined to be compatible with respect to type,
size, etc. Overlapping is done in a greedy fashion: we select the
first element in the st->en range, then walk the rest of the
elements adding in vars whose lifetimes don't overlap with the
first element, then repeat the process until we run out of work.
Ordering of the candidates within the region [st,en] is important;
within the list the assumption is that if we overlap two variables
X and Y where X precedes Y in the list, we need to make X the
"leader" (keep X's slot and set Y's frame offset to X's) as opposed
to the other way around, since it's possible that Y is smaller in
size than X.</p>
               
               <pre><code class="language-go">func (cs *cstate) mergeVisitRegion(mls *MergeLocalsState, st int, en int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nameLess" data-name="nameLess">
               <h3>
                  nameLess 
                  <span class="badge">function</span>
                  
                  <a href="#nameLess" class="anchor" title="Link to nameLess">#</a>
               </h3>
               
               <p>nameLess compares ci with cj to see if ci should be less than cj in
a relative ordering of candidate variables. This is used to sort
vars by pointerness (variables with pointers first), then in order
of decreasing alignment, then by decreasing size. We are assuming a
merging algorithm that merges later entries in the list into
earlier entries. An example ordered candidate list produced by
nameLess:
idx   name    type       align    size
0:    abc     [10]*int   8        80
1:    xyz     [9]*int    8        72
2:    qrs     [2]*int    8        16
3:    tuv     [9]int     8        72
4:    wxy     [9]int32   4        36
5:    jkl     [8]int32   4        32</p>
               
               <pre><code class="language-go">func nameLess(ci *ir.Name, cj *ir.Name) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newliveness" data-name="newliveness">
               <h3>
                  newliveness 
                  <span class="badge">function</span>
                  
                  <a href="#newliveness" class="anchor" title="Link to newliveness">#</a>
               </h3>
               
               <p>Constructs a new liveness structure used to hold the global state of the
liveness computation. The cfg argument is a slice of *BasicBlocks and the
vars argument is a slice of *Nodes.</p>
               
               <pre><code class="language-go">func newliveness(fn *ir.Func, f *ssa.Func, vars []*ir.Name, idx map[*ir.Name]int32, stkptrsize int64) *liveness</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nextRegion" data-name="nextRegion">
               <h3>
                  nextRegion 
                  <span class="badge">function</span>
                  
                  <a href="#nextRegion" class="anchor" title="Link to nextRegion">#</a>
               </h3>
               
               <p>nextRegion starts at location idx and walks forward in the cands
slice looking for variables that are "compatible" (potentially
overlappable, in the sense that they could potentially share the
stack slot of cands[idx]); it returns the end of the new region
(range of compatible variables starting at idx).</p>
               
               <pre><code class="language-go">func nextRegion(cands []*ir.Name, idx int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nxt" data-name="nxt">
               <h3>
                  nxt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nxt" class="anchor" title="Link to nxt">#</a>
               </h3>
               
               <p>nxt advances the pairVisitor to the next interval by starting
position within the pair, returning an intWithIdx that describes
the interval.</p>
               
               <pre><code class="language-go">func (pv *pairVisitor) nxt() intWithIdx</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="performMerging" data-name="performMerging">
               <h3>
                  performMerging 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#performMerging" class="anchor" title="Link to performMerging">#</a>
               </h3>
               
               <p>performMerging carries out variable merging within each of the
candidate ranges in regions, returning a state object
that describes the variable overlaps.</p>
               
               <pre><code class="language-go">func (cs *cstate) performMerging() *MergeLocalsState</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pointerMap" data-name="pointerMap">
               <h3>
                  pointerMap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pointerMap" class="anchor" title="Link to pointerMap">#</a>
               </h3>
               
               <p>Generates live pointer value maps for arguments and local variables. The
this argument and the in arguments are always assumed live. The vars
argument is a slice of *Nodes.</p>
               
               <pre><code class="language-go">func (lv *liveness) pointerMap(liveout bitvec.BitVec, vars []*ir.Name, args bitvec.BitVec, locals bitvec.BitVec)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="populateIndirectUseTable" data-name="populateIndirectUseTable">
               <h3>
                  populateIndirectUseTable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#populateIndirectUseTable" class="anchor" title="Link to populateIndirectUseTable">#</a>
               </h3>
               
               <p>populateIndirectUseTable creates and populates the "indirectUE" table
within cs by doing some additional analysis of how the vars in
cands are accessed in the function.
It is possible to have situations where a given ir.Name is
non-address-taken at the source level, but whose address is
materialized in order to accommodate the needs of
architecture-dependent operations or one sort or another (examples
include things like LoweredZero/DuffZero, etc). The issue here is
that the SymAddr op will show up as touching a variable of
interest, but the subsequent memory op will not. This is generally
not an issue for computing whether something is live across a call,
but it is problematic for collecting the more fine-grained live
interval info that drives stack slot merging.
To handle this problem, make a forward pass over each basic block
looking for instructions of the form vK := SymAddr(N) where N is a
raw candidate. Create an entry in a map at that point from vK to
its use count. Continue the walk, looking for uses of vK: when we
see one, record it in a side table as an upwards exposed use of N.
Each time we see a use, decrement the use count in the map, and if
we hit zero, remove the map entry. If we hit the end of the basic
block and we still have map entries, then evict the name in
question from the candidate set.</p>
               
               <pre><code class="language-go">func (cs *cstate) populateIndirectUseTable(cands []*ir.Name) ([]*ir.Name, []candRegion)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="print" data-name="print">
               <h3>
                  print 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#print" class="anchor" title="Link to print">#</a>
               </h3>
               
               <pre><code class="language-go">func (lv *argLiveness) print()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printDebug" data-name="printDebug">
               <h3>
                  printDebug 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#printDebug" class="anchor" title="Link to printDebug">#</a>
               </h3>
               
               <p>Prints the computed liveness information and inputs, for debugging.
This format synthesizes the information used during the multiple passes
into a single presentation.</p>
               
               <pre><code class="language-go">func (lv *liveness) printDebug()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printLivenessVec" data-name="printLivenessVec">
               <h3>
                  printLivenessVec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#printLivenessVec" class="anchor" title="Link to printLivenessVec">#</a>
               </h3>
               
               <pre><code class="language-go">func (lv *argLiveness) printLivenessVec(bv bitvec.BitVec)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printbvec" data-name="printbvec">
               <h3>
                  printbvec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#printbvec" class="anchor" title="Link to printbvec">#</a>
               </h3>
               
               <pre><code class="language-go">func (lv *liveness) printbvec(printed bool, name string, live bitvec.BitVec) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printeffect" data-name="printeffect">
               <h3>
                  printeffect 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#printeffect" class="anchor" title="Link to printeffect">#</a>
               </h3>
               
               <p>printeffect is like printbvec, but for valueEffects.</p>
               
               <pre><code class="language-go">func (lv *liveness) printeffect(printed bool, name string, pos int32, x bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="prologue" data-name="prologue">
               <h3>
                  prologue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#prologue" class="anchor" title="Link to prologue">#</a>
               </h3>
               
               <p>Initializes the sets for solving the live variables. Visits all the
instructions in each basic block to summarizes the information at each basic
block</p>
               
               <pre><code class="language-go">func (lv *liveness) prologue()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reset" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reset" class="anchor" title="Link to reset">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *Map) reset()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sel" data-name="sel">
               <h3>
                  sel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sel" class="anchor" title="Link to sel">#</a>
               </h3>
               
               <p>sel is a helper function used by 'init' and 'nxt' above; it selects
the earlier of the two intervals at the current positions within i1
and i2, or a degenerate (pairIndex -1) intWithIdx if we have no
more intervals to visit.</p>
               
               <pre><code class="language-go">func (pv *pairVisitor) sel() intWithIdx</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="set" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#set" class="anchor" title="Link to set">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *Map) set(v *ssa.Value, i objw.StackMapIndex)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setLast" data-name="setLast">
               <h3>
                  setLast 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setLast" class="anchor" title="Link to setLast">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *IntervalsBuilder) setLast(x int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setUnsafeBlock" data-name="setUnsafeBlock">
               <h3>
                  setUnsafeBlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setUnsafeBlock" class="anchor" title="Link to setUnsafeBlock">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *Map) setUnsafeBlock(b *ssa.Block)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setUnsafeVal" data-name="setUnsafeVal">
               <h3>
                  setUnsafeVal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setUnsafeVal" class="anchor" title="Link to setUnsafeVal">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *Map) setUnsafeVal(v *ssa.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setupHashBisection" data-name="setupHashBisection">
               <h3>
                  setupHashBisection 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setupHashBisection" class="anchor" title="Link to setupHashBisection">#</a>
               </h3>
               
               <p>setupHashBisection checks to see if any of the candidate
variables have been de-selected by our hash debug. Here
we also implement the -d=mergelocalshtrace flag, which turns
on debug tracing only if we have at least two candidates
selected by the hash debug for this function.</p>
               
               <pre><code class="language-go">func (cs *cstate) setupHashBisection(cands []*ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldTrack" data-name="shouldTrack">
               <h3>
                  shouldTrack 
                  <span class="badge">function</span>
                  
                  <a href="#shouldTrack" class="anchor" title="Link to shouldTrack">#</a>
               </h3>
               
               <p>shouldTrack reports whether the liveness analysis
should track the variable n.
We don't care about variables that have no pointers,
nor do we care about non-local variables,
nor do we care about empty structs (handled by the pointer check),
nor do we care about the fake PAUTOHEAP variables.</p>
               
               <pre><code class="language-go">func shouldTrack(n *ir.Name) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="showlive" data-name="showlive">
               <h3>
                  showlive 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#showlive" class="anchor" title="Link to showlive">#</a>
               </h3>
               
               <pre><code class="language-go">func (lv *liveness) showlive(v *ssa.Value, live bitvec.BitVec)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="solve" data-name="solve">
               <h3>
                  solve 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#solve" class="anchor" title="Link to solve">#</a>
               </h3>
               
               <p>Solve the liveness dataflow equations.</p>
               
               <pre><code class="language-go">func (lv *liveness) solve()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="valueEffect" data-name="valueEffect">
               <h3>
                  valueEffect 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#valueEffect" class="anchor" title="Link to valueEffect">#</a>
               </h3>
               
               <p>valueEffect applies the effect of v to live, return whether it is changed.</p>
               
               <pre><code class="language-go">func (lv *argLiveness) valueEffect(v *ssa.Value, live bitvec.BitVec) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="valueEffects" data-name="valueEffects">
               <h3>
                  valueEffects 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#valueEffects" class="anchor" title="Link to valueEffects">#</a>
               </h3>
               
               <p>valueEffects returns the index of a variable in lv.vars and the
liveness effects v has on that variable.
If v does not affect any tracked variables, it returns -1, 0.</p>
               
               <pre><code class="language-go">func (lv *liveness) valueEffects(v *ssa.Value) (int32, liveEffect)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();

               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);

               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;

               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               // Apply Prism highlighting again
               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>