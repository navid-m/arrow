<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - liveness</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>liveness</code>
         </h1>
         <hr />
         
         <article class="global" data-name="seedflag">
            <h2>seedflag</h2>
            <hr />
            
            <pre><code>seedflag</code></pre>
         </article>
         
         <article class="global" data-name="trialsflag">
            <h2>trialsflag</h2>
            <hr />
            
            <pre><code>trialsflag</code></pre>
         </article>
         
         <article class="global" data-name="segsflag">
            <h2>segsflag</h2>
            <hr />
            
            <pre><code>segsflag</code></pre>
         </article>
         
         <article class="global" data-name="limitflag">
            <h2>limitflag</h2>
            <hr />
            
            <pre><code>limitflag</code></pre>
         </article>
         
         <article class="global" data-name="uevar">
            <h2>uevar</h2>
            <hr />
            
            <pre><code>uevar liveEffect</code></pre>
         </article>
         
         <article class="global" data-name="varkill">
            <h2>varkill</h2>
            <hr />
            
            <pre><code>varkill</code></pre>
         </article>
         
         <article class="global" data-name="allLiveIdx">
            <h2>allLiveIdx</h2>
            <hr />
            
            <pre><code>allLiveIdx</code></pre>
         </article>
         
         <article class="global" data-name="h0">
            <h2>h0</h2>
            <hr />
            
            <p>FNV-1 hash function constants.</p>
            
            <pre><code>h0</code></pre>
         </article>
         
         <article class="global" data-name="hp">
            <h2>hp</h2>
            <hr />
            
            <p>FNV-1 hash function constants.</p>
            
            <pre><code>hp</code></pre>
         </article>
         
         <article class="global" data-name="debugtrace">
            <h2>debugtrace</h2>
            <hr />
            
            <pre><code>debugtrace</code></pre>
         </article>
          
         <article class="struct" data-name="MergeLocalsState">
            <h2>type MergeLocalsState struct</h2>
            <hr />
            
            <p>MergeLocalsState encapsulates information about which AUTO
(stack-allocated) variables within a function can be safely
merged/overlapped, e.g. share a stack slot with some other auto).
An instance of MergeLocalsState is produced by MergeLocals() below
and then consumed in ssagen.AllocFrame. The map 'partition'
contains entries of the form <N,SL> where N is an *ir.Name and SL
is a slice holding the indices (within 'vars') of other variables
that share the same slot, specifically the slot of the first
element in the partition, which we'll call the "leader". For
example, if a function contains five variables where v1/v2/v3 are
safe to overlap and v4/v5 are safe to overlap, the MergeLocalsState
content might look like

	vars: [v1, v2, v3, v4, v5]
	partition: v1 -> [1, 0, 2], v2 -> [1, 0, 2], v3 -> [1, 0, 2]
	           v4 -> [3, 4], v5 -> [3, 4]

A nil MergeLocalsState indicates that no local variables meet the
necessary criteria for overlap.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">vars []*ir.Name
partition *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="candRegion">
            <h2>type candRegion struct</h2>
            <hr />
            
            <p>candRegion is a sub-range (start, end) corresponding to an interval
[st,en] within the list of candidate variables.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">st int
en int</code></pre>
         </article>
         
         <article class="struct" data-name="cstate">
            <h2>type cstate struct</h2>
            <hr />
            
            <p>cstate holds state information we'll need during the analysis
phase of stack slot merging but can be discarded when the analysis
is done.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">fn *ir.Func
f *ssa.Func
lv *liveness
cands []*ir.Name
nameToSlot *ast.MapType
regions []candRegion
indirectUE *ast.MapType
ivs []Intervals
hashDeselected *ast.MapType
trace int</code></pre>
         </article>
         
         <article class="struct" data-name="nameCount">
            <h2>type nameCount struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">n *ir.Name
count int32</code></pre>
         </article>
         
         <article class="struct" data-name="blockEffects">
            <h2>type blockEffects struct</h2>
            <hr />
            
            <p>blockEffects summarizes the liveness effects on an SSA block.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">uevar bitvec.BitVec
varkill bitvec.BitVec
livein bitvec.BitVec
liveout bitvec.BitVec</code></pre>
         </article>
         
         <article class="struct" data-name="liveness">
            <h2>type liveness struct</h2>
            <hr />
            
            <p>A collection of global state used by liveness analysis.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">fn *ir.Func
f *ssa.Func
vars []*ir.Name
idx *ast.MapType
stkptrsize int64
be []blockEffects
allUnsafe bool
unsafePoints bitvec.BitVec
unsafeBlocks bitvec.BitVec
livevars []bitvec.BitVec
livenessMap Map
stackMapSet bvecSet
stackMaps []bitvec.BitVec
cache progeffectscache
partLiveArgs *ast.MapType
doClobber bool
noClobberArgs bool
conservativeWrites bool</code></pre>
         </article>
         
         <article class="struct" data-name="Map">
            <h2>type Map struct</h2>
            <hr />
            
            <p>Map maps from *ssa.Value to StackMapIndex.
Also keeps track of unsafe ssa.Values and ssa.Blocks.
(unsafe = can't be interrupted during GC.)</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Vals *ast.MapType
UnsafeVals *ast.MapType
UnsafeBlocks *ast.MapType
DeferReturn objw.StackMapIndex</code></pre>
         </article>
         
         <article class="struct" data-name="progeffectscache">
            <h2>type progeffectscache struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">retuevar []int32
tailuevar []int32
initialized bool</code></pre>
         </article>
         
         <article class="struct" data-name="livenessFuncCache">
            <h2>type livenessFuncCache struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">be []blockEffects
livenessMap Map</code></pre>
         </article>
         
         <article class="struct" data-name="nameOff">
            <h2>type nameOff struct</h2>
            <hr />
            
            <p>name and offset</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">n *ir.Name
off int64</code></pre>
         </article>
         
         <article class="struct" data-name="blockArgEffects">
            <h2>type blockArgEffects struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">livein bitvec.BitVec
liveout bitvec.BitVec</code></pre>
         </article>
         
         <article class="struct" data-name="argLiveness">
            <h2>type argLiveness struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">fn *ir.Func
f *ssa.Func
args []nameOff
idx *ast.MapType
be []blockArgEffects
bvset bvecSet
blockIdx *ast.MapType
valueIdx *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="bvecSet">
            <h2>type bvecSet struct</h2>
            <hr />
            
            <p>bvecSet is a set of bvecs, in initial insertion order.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">index []int
uniq []bitvec.BitVec</code></pre>
         </article>
         
         <article class="struct" data-name="Interval">
            <h2>type Interval struct</h2>
            <hr />
            
            <p>Interval hols the range [st,en).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">st int
en int</code></pre>
         </article>
         
         <article class="struct" data-name="IntervalsBuilder">
            <h2>type IntervalsBuilder struct</h2>
            <hr />
            
            <p>IntervalsBuilder is a helper for constructing intervals based on
live dataflow sets for a series of BBs where we're making a
backwards pass over each BB looking for uses and kills. The
expected use case is:

  - invoke MakeIntervalsBuilder to create a new object "b"
  - series of calls to b.Live/b.Kill based on a backwards reverse layout
    order scan over instructions
  - invoke b.Finish() to produce final set

See the Live method comment for an IR example.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">s Intervals
lidx int</code></pre>
         </article>
         
         <article class="struct" data-name="intWithIdx">
            <h2>type intWithIdx struct</h2>
            <hr />
            
            <p>intWithIdx holds an interval i and an index pairIndex storing i's
position (either 0 or 1) within some previously specified interval
pair <I1,I2>; a pairIndex of -1 is used to signal "end of
iteration". Used for Intervals operations, not expected to be
exported.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">i Interval
pairIndex int</code></pre>
         </article>
         
         <article class="struct" data-name="pairVisitor">
            <h2>type pairVisitor struct</h2>
            <hr />
            
            <p>pairVisitor provides a way to visit (iterate through) each interval
within a pair of Intervals in order of increasing start time. Expected
usage model:

	func example(i1, i2 Intervals) {
	  var pairVisitor pv
	  cur := pv.init(i1, i2);
	  for !cur.done() {
	     fmt.Printf("interval %s from i%d", cur.i.String(), cur.pairIndex+1)
	     cur = pv.nxt()
	  }
	}

Used internally for Intervals operations, not expected to be exported.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">cur intWithIdx
i1pos int
i2pos int
i1 Intervals
i2 Intervals</code></pre>
         </article>
          
         <article class="function" data-name="TestMain">
            <h2>TestMain</h2>
            <hr />
            
            <pre><code>func TestMain(m *testing.M)</code></pre>
         </article>
         
         <article class="function" data-name="TestMakeAndPrint">
            <h2>TestMakeAndPrint</h2>
            <hr />
            
            <pre><code>func TestMakeAndPrint(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIntervalOverlap">
            <h2>TestIntervalOverlap</h2>
            <hr />
            
            <pre><code>func TestIntervalOverlap(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIntervalAdjacent">
            <h2>TestIntervalAdjacent</h2>
            <hr />
            
            <pre><code>func TestIntervalAdjacent(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIntervalMerge">
            <h2>TestIntervalMerge</h2>
            <hr />
            
            <pre><code>func TestIntervalMerge(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIntervalsOverlap">
            <h2>TestIntervalsOverlap</h2>
            <hr />
            
            <pre><code>func TestIntervalsOverlap(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestRandomIntervalsOverlap">
            <h2>TestRandomIntervalsOverlap</h2>
            <hr />
            
            <pre><code>func TestRandomIntervalsOverlap(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIntervalsMerge">
            <h2>TestIntervalsMerge</h2>
            <hr />
            
            <pre><code>func TestIntervalsMerge(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBuilder">
            <h2>TestBuilder</h2>
            <hr />
            
            <pre><code>func TestBuilder(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="makeIntervals">
            <h2>makeIntervals</h2>
            <hr />
            
            <p>makeIntervals constructs an Intervals object from the start/end
sequence in nums, expected to be of the form
s1,en1,st2,en2,...,stk,enk. Used only for unit testing.</p>
            
            <pre><code>func makeIntervals(nums ...int) (Intervals, error)</code></pre>
         </article>
         
         <article class="function" data-name="MergeLocals">
            <h2>MergeLocals</h2>
            <hr />
            
            <p>MergeLocals analyzes the specified ssa function f to determine which
of its auto variables can safely share the same stack slot, returning
a state object that describes how the overlap should be done.</p>
            
            <pre><code>func MergeLocals(fn *ir.Func, f *ssa.Func) *MergeLocalsState</code></pre>
         </article>
         
         <article class="function" data-name="Subsumed">
            <h2>Subsumed</h2>
            <hr />
            
            <p>Subsumed returns whether variable n is subsumed, e.g. appears
in an overlap position but is not the leader in that partition.</p>
            
            <pre><code>func Subsumed(n *ir.Name) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsLeader">
            <h2>IsLeader</h2>
            <hr />
            
            <p>IsLeader returns whether a variable n is the leader (first element)
in a sharing partition.</p>
            
            <pre><code>func IsLeader(n *ir.Name) bool</code></pre>
         </article>
         
         <article class="function" data-name="Leader">
            <h2>Leader</h2>
            <hr />
            
            <p>Leader returns the leader variable for subsumed var n.</p>
            
            <pre><code>func Leader(n *ir.Name) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="Followers">
            <h2>Followers</h2>
            <hr />
            
            <p>Followers writes a list of the followers for leader n into the slice tmp.</p>
            
            <pre><code>func Followers(n *ir.Name, tmp []*ir.Name) []*ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="EstSavings">
            <h2>EstSavings</h2>
            <hr />
            
            <p>EstSavings returns the estimated reduction in stack size (number of bytes) for
the given merge locals state via a pair of ints, the first for non-pointer types and the second for pointer types.</p>
            
            <pre><code>func EstSavings() (int, int)</code></pre>
         </article>
         
         <article class="function" data-name="check">
            <h2>check</h2>
            <hr />
            
            <p>check tests for various inconsistencies and problems in mls,
returning an error if any problems are found.</p>
            
            <pre><code>func check() error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="collectMergeCandidates">
            <h2>collectMergeCandidates</h2>
            <hr />
            
            <p>collectMergeCandidates visits all of the AUTO vars declared in
function fn and identifies a list of candidate variables for
merging / overlapping. On return the "cands" field of cs will be
filled in with our set of potentially overlappable candidate
variables, the "regions" field will hold regions/sequence of
compatible vars within the candidates list, "nameToSlot" field will
be populated, and the "indirectUE" field will be filled in with
information about indirect upwards-exposed uses in the func.</p>
            
            <pre><code>func collectMergeCandidates()</code></pre>
         </article>
         
         <article class="function" data-name="genRegions">
            <h2>genRegions</h2>
            <hr />
            
            <p>genRegions generates a set of regions within cands corresponding
to potentially overlappable/mergeable variables.</p>
            
            <pre><code>func genRegions(cands []*ir.Name) ([]*ir.Name, []candRegion)</code></pre>
         </article>
         
         <article class="function" data-name="dumpFunc">
            <h2>dumpFunc</h2>
            <hr />
            
            <pre><code>func dumpFunc()</code></pre>
         </article>
         
         <article class="function" data-name="dumpFuncIfSelected">
            <h2>dumpFuncIfSelected</h2>
            <hr />
            
            <pre><code>func dumpFuncIfSelected()</code></pre>
         </article>
         
         <article class="function" data-name="setupHashBisection">
            <h2>setupHashBisection</h2>
            <hr />
            
            <p>setupHashBisection checks to see if any of the candidate
variables have been de-selected by our hash debug. Here
we also implement the -d=mergelocalshtrace flag, which turns
on debug tracing only if we have at least two candidates
selected by the hash debug for this function.</p>
            
            <pre><code>func setupHashBisection(cands []*ir.Name)</code></pre>
         </article>
         
         <article class="function" data-name="populateIndirectUseTable">
            <h2>populateIndirectUseTable</h2>
            <hr />
            
            <p>populateIndirectUseTable creates and populates the "indirectUE" table
within cs by doing some additional analysis of how the vars in
cands are accessed in the function.

It is possible to have situations where a given ir.Name is
non-address-taken at the source level, but whose address is
materialized in order to accommodate the needs of
architecture-dependent operations or one sort or another (examples
include things like LoweredZero/DuffZero, etc). The issue here is
that the SymAddr op will show up as touching a variable of
interest, but the subsequent memory op will not. This is generally
not an issue for computing whether something is live across a call,
but it is problematic for collecting the more fine-grained live
interval info that drives stack slot merging.

To handle this problem, make a forward pass over each basic block
looking for instructions of the form vK := SymAddr(N) where N is a
raw candidate. Create an entry in a map at that point from vK to
its use count. Continue the walk, looking for uses of vK: when we
see one, record it in a side table as an upwards exposed use of N.
Each time we see a use, decrement the use count in the map, and if
we hit zero, remove the map entry. If we hit the end of the basic
block and we still have map entries, then evict the name in
question from the candidate set.</p>
            
            <pre><code>func populateIndirectUseTable(cands []*ir.Name) ([]*ir.Name, []candRegion)</code></pre>
         </article>
         
         <article class="function" data-name="nameLess">
            <h2>nameLess</h2>
            <hr />
            
            <p>nameLess compares ci with cj to see if ci should be less than cj in
a relative ordering of candidate variables. This is used to sort
vars by pointerness (variables with pointers first), then in order
of decreasing alignment, then by decreasing size. We are assuming a
merging algorithm that merges later entries in the list into
earlier entries. An example ordered candidate list produced by
nameLess:

	idx   name    type       align    size
	0:    abc     [10]*int   8        80
	1:    xyz     [9]*int    8        72
	2:    qrs     [2]*int    8        16
	3:    tuv     [9]int     8        72
	4:    wxy     [9]int32   4        36
	5:    jkl     [8]int32   4        32</p>
            
            <pre><code>func nameLess(ci *ir.Name, cj *ir.Name) bool</code></pre>
         </article>
         
         <article class="function" data-name="nextRegion">
            <h2>nextRegion</h2>
            <hr />
            
            <p>nextRegion starts at location idx and walks forward in the cands
slice looking for variables that are "compatible" (potentially
overlappable, in the sense that they could potentially share the
stack slot of cands[idx]); it returns the end of the new region
(range of compatible variables starting at idx).</p>
            
            <pre><code>func nextRegion(cands []*ir.Name, idx int) int</code></pre>
         </article>
         
         <article class="function" data-name="mergeVisitRegion">
            <h2>mergeVisitRegion</h2>
            <hr />
            
            <p>mergeVisitRegion tries to perform overlapping of variables with a
given subrange of cands described by st and en (indices into our
candidate var list), where the variables within this range have
already been determined to be compatible with respect to type,
size, etc. Overlapping is done in a greedy fashion: we select the
first element in the st->en range, then walk the rest of the
elements adding in vars whose lifetimes don't overlap with the
first element, then repeat the process until we run out of work.
Ordering of the candidates within the region [st,en] is important;
within the list the assumption is that if we overlap two variables
X and Y where X precedes Y in the list, we need to make X the
"leader" (keep X's slot and set Y's frame offset to X's) as opposed
to the other way around, since it's possible that Y is smaller in
size than X.</p>
            
            <pre><code>func mergeVisitRegion(mls *MergeLocalsState, st int, en int)</code></pre>
         </article>
         
         <article class="function" data-name="performMerging">
            <h2>performMerging</h2>
            <hr />
            
            <p>performMerging carries out variable merging within each of the
candidate ranges in regions, returning a state object
that describes the variable overlaps.</p>
            
            <pre><code>func performMerging() *MergeLocalsState</code></pre>
         </article>
         
         <article class="function" data-name="computeIntervals">
            <h2>computeIntervals</h2>
            <hr />
            
            <p>computeIntervals performs a backwards sweep over the instructions
of the function we're compiling, building up an Intervals object
for each candidate variable by looking for upwards exposed uses
and kills.</p>
            
            <pre><code>func computeIntervals()</code></pre>
         </article>
         
         <article class="function" data-name="fmtFullPos">
            <h2>fmtFullPos</h2>
            <hr />
            
            <pre><code>func fmtFullPos(p src.XPos) string</code></pre>
         </article>
         
         <article class="function" data-name="dumpCand">
            <h2>dumpCand</h2>
            <hr />
            
            <pre><code>func dumpCand(c *ir.Name, i int)</code></pre>
         </article>
         
         <article class="function" data-name="MakeMergeLocalsState">
            <h2>MakeMergeLocalsState</h2>
            <hr />
            
            <p>for unit testing only.</p>
            
            <pre><code>func MakeMergeLocalsState(partition *ast.MapType, vars []*ir.Name) (*MergeLocalsState, error)</code></pre>
         </article>
         
         <article class="function" data-name="reset">
            <h2>reset</h2>
            <hr />
            
            <pre><code>func reset()</code></pre>
         </article>
         
         <article class="function" data-name="set">
            <h2>set</h2>
            <hr />
            
            <pre><code>func set(v *ssa.Value, i objw.StackMapIndex)</code></pre>
         </article>
         
         <article class="function" data-name="setUnsafeVal">
            <h2>setUnsafeVal</h2>
            <hr />
            
            <pre><code>func setUnsafeVal(v *ssa.Value)</code></pre>
         </article>
         
         <article class="function" data-name="setUnsafeBlock">
            <h2>setUnsafeBlock</h2>
            <hr />
            
            <pre><code>func setUnsafeBlock(b *ssa.Block)</code></pre>
         </article>
         
         <article class="function" data-name="Get">
            <h2>Get</h2>
            <hr />
            
            <pre><code>func Get(v *ssa.Value) objw.StackMapIndex</code></pre>
         </article>
         
         <article class="function" data-name="GetUnsafe">
            <h2>GetUnsafe</h2>
            <hr />
            
            <pre><code>func GetUnsafe(v *ssa.Value) bool</code></pre>
         </article>
         
         <article class="function" data-name="GetUnsafeBlock">
            <h2>GetUnsafeBlock</h2>
            <hr />
            
            <pre><code>func GetUnsafeBlock(b *ssa.Block) bool</code></pre>
         </article>
         
         <article class="function" data-name="shouldTrack">
            <h2>shouldTrack</h2>
            <hr />
            
            <p>shouldTrack reports whether the liveness analysis
should track the variable n.
We don't care about variables that have no pointers,
nor do we care about non-local variables,
nor do we care about empty structs (handled by the pointer check),
nor do we care about the fake PAUTOHEAP variables.</p>
            
            <pre><code>func shouldTrack(n *ir.Name) bool</code></pre>
         </article>
         
         <article class="function" data-name="getvariables">
            <h2>getvariables</h2>
            <hr />
            
            <p>getvariables returns the list of on-stack variables that we need to track
and a map for looking up indices by *Node.</p>
            
            <pre><code>func getvariables(fn *ir.Func) ([]*ir.Name, *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="initcache">
            <h2>initcache</h2>
            <hr />
            
            <pre><code>func initcache()</code></pre>
         </article>
         
         <article class="function" data-name="valueEffects">
            <h2>valueEffects</h2>
            <hr />
            
            <p>valueEffects returns the index of a variable in lv.vars and the
liveness effects v has on that variable.
If v does not affect any tracked variables, it returns -1, 0.</p>
            
            <pre><code>func valueEffects(v *ssa.Value) (int32, liveEffect)</code></pre>
         </article>
         
         <article class="function" data-name="affectedVar">
            <h2>affectedVar</h2>
            <hr />
            
            <p>affectedVar returns the *ir.Name node affected by v.</p>
            
            <pre><code>func affectedVar(v *ssa.Value) (*ir.Name, ssa.SymEffect)</code></pre>
         </article>
         
         <article class="function" data-name="newliveness">
            <h2>newliveness</h2>
            <hr />
            
            <p>Constructs a new liveness structure used to hold the global state of the
liveness computation. The cfg argument is a slice of *BasicBlocks and the
vars argument is a slice of *Nodes.</p>
            
            <pre><code>func newliveness(fn *ir.Func, f *ssa.Func, vars []*ir.Name, idx *ast.MapType, stkptrsize int64) *liveness</code></pre>
         </article>
         
         <article class="function" data-name="blockEffects">
            <h2>blockEffects</h2>
            <hr />
            
            <pre><code>func blockEffects(b *ssa.Block) *blockEffects</code></pre>
         </article>
         
         <article class="function" data-name="pointerMap">
            <h2>pointerMap</h2>
            <hr />
            
            <p>Generates live pointer value maps for arguments and local variables. The
this argument and the in arguments are always assumed live. The vars
argument is a slice of *Nodes.</p>
            
            <pre><code>func pointerMap(liveout bitvec.BitVec, vars []*ir.Name, args bitvec.BitVec, locals bitvec.BitVec)</code></pre>
         </article>
         
         <article class="function" data-name="IsUnsafe">
            <h2>IsUnsafe</h2>
            <hr />
            
            <p>IsUnsafe indicates that all points in this function are
unsafe-points.</p>
            
            <pre><code>func IsUnsafe(f *ssa.Func) bool</code></pre>
         </article>
         
         <article class="function" data-name="markUnsafePoints">
            <h2>markUnsafePoints</h2>
            <hr />
            
            <p>markUnsafePoints finds unsafe points and computes lv.unsafePoints.</p>
            
            <pre><code>func markUnsafePoints()</code></pre>
         </article>
         
         <article class="function" data-name="hasStackMap">
            <h2>hasStackMap</h2>
            <hr />
            
            <p>Returns true for instructions that must have a stack map.

This does not necessarily mean the instruction is a safe-point. In
particular, call Values can have a stack map in case the callee
grows the stack, but not themselves be a safe-point.</p>
            
            <pre><code>func hasStackMap(v *ssa.Value) bool</code></pre>
         </article>
         
         <article class="function" data-name="prologue">
            <h2>prologue</h2>
            <hr />
            
            <p>Initializes the sets for solving the live variables. Visits all the
instructions in each basic block to summarizes the information at each basic
block</p>
            
            <pre><code>func prologue()</code></pre>
         </article>
         
         <article class="function" data-name="solve">
            <h2>solve</h2>
            <hr />
            
            <p>Solve the liveness dataflow equations.</p>
            
            <pre><code>func solve()</code></pre>
         </article>
         
         <article class="function" data-name="epilogue">
            <h2>epilogue</h2>
            <hr />
            
            <p>Visits all instructions in a basic block and computes a bit vector of live
variables at each safe point locations.</p>
            
            <pre><code>func epilogue()</code></pre>
         </article>
         
         <article class="function" data-name="compact">
            <h2>compact</h2>
            <hr />
            
            <p>Compact coalesces identical bitmaps from lv.livevars into the sets
lv.stackMapSet.

Compact clears lv.livevars.

There are actually two lists of bitmaps, one list for the local variables and one
list for the function arguments. Both lists are indexed by the same PCDATA
index, so the corresponding pairs must be considered together when
merging duplicates. The argument bitmaps change much less often during
function execution than the local variable bitmaps, so it is possible that
we could introduce a separate PCDATA index for arguments vs locals and
then compact the set of argument bitmaps separately from the set of
local variable bitmaps. As of 2014-04-02, doing this to the godoc binary
is actually a net loss: we save about 50k of argument bitmaps but the new
PCDATA tables cost about 100k. So for now we keep using a single index for
both bitmap lists.</p>
            
            <pre><code>func compact(b *ssa.Block)</code></pre>
         </article>
         
         <article class="function" data-name="enableClobber">
            <h2>enableClobber</h2>
            <hr />
            
            <pre><code>func enableClobber()</code></pre>
         </article>
         
         <article class="function" data-name="clobber">
            <h2>clobber</h2>
            <hr />
            
            <p>Inserts code to clobber pointer slots in all the dead variables (locals and args)
at every synchronous safepoint in b.</p>
            
            <pre><code>func clobber(b *ssa.Block)</code></pre>
         </article>
         
         <article class="function" data-name="clobber">
            <h2>clobber</h2>
            <hr />
            
            <p>clobber generates code to clobber pointer slots in all dead variables
(those not marked in live). Clobbering instructions are added to the end
of b.Values.</p>
            
            <pre><code>func clobber(lv *liveness, b *ssa.Block, live bitvec.BitVec)</code></pre>
         </article>
         
         <article class="function" data-name="clobberVar">
            <h2>clobberVar</h2>
            <hr />
            
            <p>clobberVar generates code to trash the pointers in v.
Clobbering instructions are added to the end of b.Values.</p>
            
            <pre><code>func clobberVar(b *ssa.Block, v *ir.Name)</code></pre>
         </article>
         
         <article class="function" data-name="clobberWalk">
            <h2>clobberWalk</h2>
            <hr />
            
            <p>b = block to which we append instructions
v = variable
offset = offset of (sub-portion of) variable to clobber (in bytes)
t = type of sub-portion of v.</p>
            
            <pre><code>func clobberWalk(b *ssa.Block, v *ir.Name, offset int64, t *types.Type)</code></pre>
         </article>
         
         <article class="function" data-name="clobberPtr">
            <h2>clobberPtr</h2>
            <hr />
            
            <p>clobberPtr generates a clobber of the pointer at offset offset in v.
The clobber instruction is added at the end of b.</p>
            
            <pre><code>func clobberPtr(b *ssa.Block, v *ir.Name, offset int64)</code></pre>
         </article>
         
         <article class="function" data-name="showlive">
            <h2>showlive</h2>
            <hr />
            
            <pre><code>func showlive(v *ssa.Value, live bitvec.BitVec)</code></pre>
         </article>
         
         <article class="function" data-name="printbvec">
            <h2>printbvec</h2>
            <hr />
            
            <pre><code>func printbvec(printed bool, name string, live bitvec.BitVec) bool</code></pre>
         </article>
         
         <article class="function" data-name="printeffect">
            <h2>printeffect</h2>
            <hr />
            
            <p>printeffect is like printbvec, but for valueEffects.</p>
            
            <pre><code>func printeffect(printed bool, name string, pos int32, x bool) bool</code></pre>
         </article>
         
         <article class="function" data-name="printDebug">
            <h2>printDebug</h2>
            <hr />
            
            <p>Prints the computed liveness information and inputs, for debugging.
This format synthesizes the information used during the multiple passes
into a single presentation.</p>
            
            <pre><code>func printDebug()</code></pre>
         </article>
         
         <article class="function" data-name="emit">
            <h2>emit</h2>
            <hr />
            
            <p>Dumps a slice of bitmaps to a symbol as a sequence of uint32 values. The
first word dumped is the total number of bitmaps. The second word is the
length of the bitmaps. All bitmaps are assumed to be of equal length. The
remaining bytes are the raw bitmaps.</p>
            
            <pre><code>func emit() (argsSym *obj.LSym, liveSym *obj.LSym)</code></pre>
         </article>
         
         <article class="function" data-name="Compute">
            <h2>Compute</h2>
            <hr />
            
            <p>Entry pointer for Compute analysis. Solves for the Compute of
pointer variables in the function and emits a runtime data
structure read by the garbage collector.
Returns a map from GC safe points to their corresponding stack map index,
and a map that contains all input parameters that may be partially live.</p>
            
            <pre><code>func Compute(curfn *ir.Func, f *ssa.Func, stkptrsize int64, pp *objw.Progs) (Map, *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="emitStackObjects">
            <h2>emitStackObjects</h2>
            <hr />
            
            <pre><code>func emitStackObjects() *obj.LSym</code></pre>
         </article>
         
         <article class="function" data-name="isfat">
            <h2>isfat</h2>
            <hr />
            
            <p>isfat reports whether a variable of type t needs multiple assignments to initialize.
For example:

	type T struct { x, y int }
	x := T{x: 0, y: 1}

Then we need:

	var t T
	t.x = 0
	t.y = 1

to fully initialize t.</p>
            
            <pre><code>func isfat(t *types.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="WriteFuncMap">
            <h2>WriteFuncMap</h2>
            <hr />
            
            <p>WriteFuncMap writes the pointer bitmaps for bodyless function fn's
inputs and outputs as the value of symbol <fn>.args_stackmap.
If fn has outputs, two bitmaps are written, otherwise just one.</p>
            
            <pre><code>func WriteFuncMap(fn *ir.Func, abiInfo *abi.ABIParamResultInfo)</code></pre>
         </article>
         
         <article class="function" data-name="FrameOffset">
            <h2>FrameOffset</h2>
            <hr />
            
            <pre><code>func FrameOffset() int64</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="ArgLiveness">
            <h2>ArgLiveness</h2>
            <hr />
            
            <p>ArgLiveness computes the liveness information of register argument spill slots.
An argument's spill slot is "live" if we know it contains a meaningful value,
that is, we have stored the register value to it.
Returns the liveness map indices at each Block entry and at each Value (where
it changes).</p>
            
            <pre><code>func ArgLiveness(fn *ir.Func, f *ssa.Func, pp *objw.Progs) (blockIdx *ast.MapType, valueIdx *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="valueEffect">
            <h2>valueEffect</h2>
            <hr />
            
            <p>valueEffect applies the effect of v to live, return whether it is changed.</p>
            
            <pre><code>func valueEffect(v *ssa.Value, live bitvec.BitVec) bool</code></pre>
         </article>
         
         <article class="function" data-name="mayFault">
            <h2>mayFault</h2>
            <hr />
            
            <pre><code>func mayFault(v *ssa.Value) bool</code></pre>
         </article>
         
         <article class="function" data-name="print">
            <h2>print</h2>
            <hr />
            
            <pre><code>func print()</code></pre>
         </article>
         
         <article class="function" data-name="printLivenessVec">
            <h2>printLivenessVec</h2>
            <hr />
            
            <pre><code>func printLivenessVec(bv bitvec.BitVec)</code></pre>
         </article>
         
         <article class="function" data-name="emit">
            <h2>emit</h2>
            <hr />
            
            <pre><code>func emit() *obj.LSym</code></pre>
         </article>
         
         <article class="function" data-name="grow">
            <h2>grow</h2>
            <hr />
            
            <pre><code>func grow()</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <p>add adds bv to the set and returns its index in m.extractUnique,
and whether it is newly added.
If it is newly added, the caller must not modify bv after this.</p>
            
            <pre><code>func add(bv bitvec.BitVec) (int, bool)</code></pre>
         </article>
         
         <article class="function" data-name="extractUnique">
            <h2>extractUnique</h2>
            <hr />
            
            <p>extractUnique returns this slice of unique bit vectors in m, as
indexed by the result of bvecSet.add.</p>
            
            <pre><code>func extractUnique() []bitvec.BitVec</code></pre>
         </article>
         
         <article class="function" data-name="hashbitmap">
            <h2>hashbitmap</h2>
            <hr />
            
            <pre><code>func hashbitmap(h uint32, bv bitvec.BitVec) uint32</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="imin">
            <h2>imin</h2>
            <hr />
            
            <p>TEMPORARY until bootstrap version catches up.</p>
            
            <pre><code>func imin(i int, j int) int</code></pre>
         </article>
         
         <article class="function" data-name="imax">
            <h2>imax</h2>
            <hr />
            
            <p>TEMPORARY until bootstrap version catches up.</p>
            
            <pre><code>func imax(i int, j int) int</code></pre>
         </article>
         
         <article class="function" data-name="Overlaps">
            <h2>Overlaps</h2>
            <hr />
            
            <p>Overlaps returns true if here is any overlap between i and i2.</p>
            
            <pre><code>func Overlaps(i2 Interval) bool</code></pre>
         </article>
         
         <article class="function" data-name="adjacent">
            <h2>adjacent</h2>
            <hr />
            
            <p>adjacent returns true if the start of one interval is equal to the
end of another interval (e.g. they represent consecutive ranges).</p>
            
            <pre><code>func adjacent(i2 Interval) bool</code></pre>
         </article>
         
         <article class="function" data-name="MergeInto">
            <h2>MergeInto</h2>
            <hr />
            
            <p>MergeInto merges interval i2 into i1. This version happens to
require that the two intervals either overlap or are adjacent.</p>
            
            <pre><code>func MergeInto(i2 Interval) error</code></pre>
         </article>
         
         <article class="function" data-name="last">
            <h2>last</h2>
            <hr />
            
            <pre><code>func last() int</code></pre>
         </article>
         
         <article class="function" data-name="setLast">
            <h2>setLast</h2>
            <hr />
            
            <pre><code>func setLast(x int)</code></pre>
         </article>
         
         <article class="function" data-name="Finish">
            <h2>Finish</h2>
            <hr />
            
            <pre><code>func Finish() (Intervals, error)</code></pre>
         </article>
         
         <article class="function" data-name="Live">
            <h2>Live</h2>
            <hr />
            
            <p>Live method should be invoked on instruction at position p if instr
contains an upwards-exposed use of a resource. See the example in
the comment at the beginning of this file for an example.</p>
            
            <pre><code>func Live(pos int) error</code></pre>
         </article>
         
         <article class="function" data-name="Kill">
            <h2>Kill</h2>
            <hr />
            
            <p>Kill method should be invoked on instruction at position p if instr
should be treated as having a kill (lifetime end) for the
resource. See the example in the comment at the beginning of this
file for an example. Note that if we see a kill at position K for a
resource currently live since J, this will result in a lifetime
segment of [K+1,J+1), the assumption being that the first live
instruction will be the one after the kill position, not the kill
position itself.</p>
            
            <pre><code>func Kill(pos int) error</code></pre>
         </article>
         
         <article class="function" data-name="check">
            <h2>check</h2>
            <hr />
            
            <p>check examines the intervals in "is" to try to find internal
inconsistencies or problems.</p>
            
            <pre><code>func check(is Intervals) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="done">
            <h2>done</h2>
            <hr />
            
            <pre><code>func done() bool</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <p>init initializes a pairVisitor for the specified pair of intervals
i1 and i2 and returns an intWithIdx object that points to the first
interval by start position within i1/i2.</p>
            
            <pre><code>func init(i1 Intervals, i2 Intervals) intWithIdx</code></pre>
         </article>
         
         <article class="function" data-name="nxt">
            <h2>nxt</h2>
            <hr />
            
            <p>nxt advances the pairVisitor to the next interval by starting
position within the pair, returning an intWithIdx that describes
the interval.</p>
            
            <pre><code>func nxt() intWithIdx</code></pre>
         </article>
         
         <article class="function" data-name="sel">
            <h2>sel</h2>
            <hr />
            
            <p>sel is a helper function used by 'init' and 'nxt' above; it selects
the earlier of the two intervals at the current positions within i1
and i2, or a degenerate (pairIndex -1) intWithIdx if we have no
more intervals to visit.</p>
            
            <pre><code>func sel() intWithIdx</code></pre>
         </article>
         
         <article class="function" data-name="Overlaps">
            <h2>Overlaps</h2>
            <hr />
            
            <p>Overlaps returns whether any of the component ranges in is overlaps
with some range in is2.</p>
            
            <pre><code>func Overlaps(is2 Intervals) bool</code></pre>
         </article>
         
         <article class="function" data-name="Merge">
            <h2>Merge</h2>
            <hr />
            
            <p>Merge combines the intervals from "is" and "is2" and returns
a new Intervals object containing all combined ranges from the
two inputs.</p>
            
            <pre><code>func Merge(is2 Intervals) Intervals</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
