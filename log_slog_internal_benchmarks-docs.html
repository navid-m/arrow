<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - benchmarks</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>benchmarks</code>
         </h1>
         <hr />
         
         <article class="global" data-name="testMessage">
            <h2>testMessage</h2>
            <hr />
            
            <pre><code>testMessage</code></pre>
         </article>
         
         <article class="global" data-name="testTime">
            <h2>testTime</h2>
            <hr />
            
            <pre><code>testTime</code></pre>
         </article>
         
         <article class="global" data-name="testString">
            <h2>testString</h2>
            <hr />
            
            <pre><code>testString</code></pre>
         </article>
         
         <article class="global" data-name="testInt">
            <h2>testInt</h2>
            <hr />
            
            <pre><code>testInt</code></pre>
         </article>
         
         <article class="global" data-name="testDuration">
            <h2>testDuration</h2>
            <hr />
            
            <pre><code>testDuration</code></pre>
         </article>
         
         <article class="global" data-name="testError">
            <h2>testError</h2>
            <hr />
            
            <pre><code>testError</code></pre>
         </article>
         
         <article class="global" data-name="testAttrs">
            <h2>testAttrs</h2>
            <hr />
            
            <pre><code>testAttrs</code></pre>
         </article>
         
         <article class="global" data-name="wantText">
            <h2>wantText</h2>
            <hr />
            
            <pre><code>wantText</code></pre>
         </article>
          
         <article class="struct" data-name="fastTextHandler">
            <h2>type fastTextHandler struct</h2>
            <hr />
            
            <p>A fastTextHandler writes a Record to an io.Writer in a format similar to
slog.TextHandler, but without quoting or locking. It has a few other
performance-motivated shortcuts, like writing times as seconds since the
epoch instead of strings.

It is intended to represent a high-performance Handler that synchronously
writes text (as opposed to binary).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">w io.Writer</code></pre>
         </article>
         
         <article class="struct" data-name="asyncHandler">
            <h2>type asyncHandler struct</h2>
            <hr />
            
            <p>An asyncHandler simulates a Handler that passes Records to a
background goroutine for processing.
Because sending to a channel can be expensive due to locking,
we simulate a lock-free queue by adding the Record to a ring buffer.
Omitting the locking makes this little more than a copy of the Record,
but that is a worthwhile thing to measure because Records are on the large
side. Since nothing actually reads from the ring buffer, it can handle an
arbitrary number of Records without either blocking or allocation.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ringBuffer []slog.Record
next int</code></pre>
         </article>
         
         <article class="struct" data-name="disabledHandler">
            <h2>type disabledHandler struct</h2>
            <hr />
            
            <p>A disabledHandler's Enabled method always returns false.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
          
         <article class="function" data-name="newFastTextHandler">
            <h2>newFastTextHandler</h2>
            <hr />
            
            <pre><code>func newFastTextHandler(w io.Writer) slog.Handler</code></pre>
         </article>
         
         <article class="function" data-name="Enabled">
            <h2>Enabled</h2>
            <hr />
            
            <pre><code>func Enabled(context.Context, slog.Level) bool</code></pre>
         </article>
         
         <article class="function" data-name="Handle">
            <h2>Handle</h2>
            <hr />
            
            <pre><code>func Handle(_ context.Context, r slog.Record) error</code></pre>
         </article>
         
         <article class="function" data-name="appendValue">
            <h2>appendValue</h2>
            <hr />
            
            <pre><code>func appendValue(buf *buffer.Buffer, v slog.Value)</code></pre>
         </article>
         
         <article class="function" data-name="appendTime">
            <h2>appendTime</h2>
            <hr />
            
            <pre><code>func appendTime(buf *buffer.Buffer, t time.Time)</code></pre>
         </article>
         
         <article class="function" data-name="WithAttrs">
            <h2>WithAttrs</h2>
            <hr />
            
            <pre><code>func WithAttrs([]slog.Attr) slog.Handler</code></pre>
         </article>
         
         <article class="function" data-name="WithGroup">
            <h2>WithGroup</h2>
            <hr />
            
            <pre><code>func WithGroup(string) slog.Handler</code></pre>
         </article>
         
         <article class="function" data-name="newAsyncHandler">
            <h2>newAsyncHandler</h2>
            <hr />
            
            <pre><code>func newAsyncHandler() *asyncHandler</code></pre>
         </article>
         
         <article class="function" data-name="Enabled">
            <h2>Enabled</h2>
            <hr />
            
            <pre><code>func Enabled(context.Context, slog.Level) bool</code></pre>
         </article>
         
         <article class="function" data-name="Handle">
            <h2>Handle</h2>
            <hr />
            
            <pre><code>func Handle(_ context.Context, r slog.Record) error</code></pre>
         </article>
         
         <article class="function" data-name="WithAttrs">
            <h2>WithAttrs</h2>
            <hr />
            
            <pre><code>func WithAttrs([]slog.Attr) slog.Handler</code></pre>
         </article>
         
         <article class="function" data-name="WithGroup">
            <h2>WithGroup</h2>
            <hr />
            
            <pre><code>func WithGroup(string) slog.Handler</code></pre>
         </article>
         
         <article class="function" data-name="Enabled">
            <h2>Enabled</h2>
            <hr />
            
            <pre><code>func Enabled(context.Context, slog.Level) bool</code></pre>
         </article>
         
         <article class="function" data-name="Handle">
            <h2>Handle</h2>
            <hr />
            
            <pre><code>func Handle(context.Context, slog.Record) error</code></pre>
         </article>
         
         <article class="function" data-name="WithAttrs">
            <h2>WithAttrs</h2>
            <hr />
            
            <pre><code>func WithAttrs([]slog.Attr) slog.Handler</code></pre>
         </article>
         
         <article class="function" data-name="WithGroup">
            <h2>WithGroup</h2>
            <hr />
            
            <pre><code>func WithGroup(string) slog.Handler</code></pre>
         </article>
         
         <article class="function" data-name="TestHandlers">
            <h2>TestHandlers</h2>
            <hr />
            
            <pre><code>func TestHandlers(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="attrSlice">
            <h2>attrSlice</h2>
            <hr />
            
            <pre><code>func attrSlice(r slog.Record) []slog.Attr</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkAttrs">
            <h2>BenchmarkAttrs</h2>
            <hr />
            
            <pre><code>func BenchmarkAttrs(b *testing.B)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
