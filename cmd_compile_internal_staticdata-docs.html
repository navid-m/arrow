<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - staticdata</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                   
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>staticdata</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"encoding/base64"
"fmt"
"go/constant"
"io"
"os"
"slices"
"strconv"
"strings"
"sync"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/objw"
"cmd/compile/internal/types"
"cmd/internal/hash"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
"path"
"sort"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/objw"
"cmd/compile/internal/types"
"cmd/internal/obj"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="embedBytes" data-name="embedBytes">
               <h3>
                  embedBytes 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#embedBytes" class="anchor" title="Link to embedBytes">#</a>
               </h3>
               
               <pre><code>const embedBytes</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="embedFiles" data-name="embedFiles">
               <h3>
                  embedFiles 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#embedFiles" class="anchor" title="Link to embedFiles">#</a>
               </h3>
               
               <pre><code>const embedFiles</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="embedString" data-name="embedString">
               <h3>
                  embedString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#embedString" class="anchor" title="Link to embedString">#</a>
               </h3>
               
               <pre><code>const embedString</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="embedUnknown" data-name="embedUnknown">
               <h3>
                  embedUnknown 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#embedUnknown" class="anchor" title="Link to embedUnknown">#</a>
               </h3>
               
               <pre><code>const embedUnknown = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="funcsyms" data-name="funcsyms">
               <h3>
                  funcsyms 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#funcsyms" class="anchor" title="Link to funcsyms">#</a>
               </h3>
               
               <pre><code>var funcsyms []*ir.Name</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="funcsymsmu" data-name="funcsymsmu">
               <h3>
                  funcsymsmu 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#funcsymsmu" class="anchor" title="Link to funcsymsmu">#</a>
               </h3>
               
               <pre><code>var funcsymsmu sync.Mutex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxFileSize" data-name="maxFileSize">
               <h3>
                  maxFileSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxFileSize" class="anchor" title="Link to maxFileSize">#</a>
               </h3>
               
               <p>maxFileSize is the maximum file size permitted by the linker
(see issue #9862).</p>
               
               <pre><code>const maxFileSize = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="slicedataGen" data-name="slicedataGen">
               <h3>
                  slicedataGen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#slicedataGen" class="anchor" title="Link to slicedataGen">#</a>
               </h3>
               
               <pre><code>var slicedataGen int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stringSymPattern" data-name="stringSymPattern">
               <h3>
                  stringSymPattern 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stringSymPattern" class="anchor" title="Link to stringSymPattern">#</a>
               </h3>
               
               <pre><code>const stringSymPattern = ".gostring.%d.%s"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stringSymPrefix" data-name="stringSymPrefix">
               <h3>
                  stringSymPrefix 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stringSymPrefix" class="anchor" title="Link to stringSymPrefix">#</a>
               </h3>
               
               <pre><code>const stringSymPrefix = "go:string."</code></pre>
            </article>
            
         </section>
             
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="FuncLinksym" data-name="FuncLinksym">
               <h3>
                  FuncLinksym 
                  <span class="badge">function</span>
                  
                  <a href="#FuncLinksym" class="anchor" title="Link to FuncLinksym">#</a>
               </h3>
               
               <p>FuncLinksym returns n·f, the function value symbol for n.</p>
               
               <pre><code>func FuncLinksym(n *ir.Name) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GlobalLinksym" data-name="GlobalLinksym">
               <h3>
                  GlobalLinksym 
                  <span class="badge">function</span>
                  
                  <a href="#GlobalLinksym" class="anchor" title="Link to GlobalLinksym">#</a>
               </h3>
               
               <pre><code>func GlobalLinksym(n *ir.Name) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitAddr" data-name="InitAddr">
               <h3>
                  InitAddr 
                  <span class="badge">function</span>
                  
                  <a href="#InitAddr" class="anchor" title="Link to InitAddr">#</a>
               </h3>
               
               <p>InitAddr is InitAddrOffset, with offset fixed to 0.</p>
               
               <pre><code>func InitAddr(n *ir.Name, noff int64, lsym *obj.LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitAddrOffset" data-name="InitAddrOffset">
               <h3>
                  InitAddrOffset 
                  <span class="badge">function</span>
                  
                  <a href="#InitAddrOffset" class="anchor" title="Link to InitAddrOffset">#</a>
               </h3>
               
               <p>InitAddrOffset writes the static name symbol lsym to n, it does not modify n.
It's the caller responsibility to make sure lsym is from ONAME/PEXTERN node.</p>
               
               <pre><code>func InitAddrOffset(n *ir.Name, noff int64, lsym *obj.LSym, off int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitConst" data-name="InitConst">
               <h3>
                  InitConst 
                  <span class="badge">function</span>
                  
                  <a href="#InitConst" class="anchor" title="Link to InitConst">#</a>
               </h3>
               
               <p>InitConst writes the static literal c to n.
Neither n nor c is modified.</p>
               
               <pre><code>func InitConst(n *ir.Name, noff int64, c ir.Node, wid int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitSlice" data-name="InitSlice">
               <h3>
                  InitSlice 
                  <span class="badge">function</span>
                  
                  <a href="#InitSlice" class="anchor" title="Link to InitSlice">#</a>
               </h3>
               
               <p>InitSlice writes a static slice symbol {lsym, lencap, lencap} to n+noff, it does not modify n.
It's the caller responsibility to make sure lsym is from ONAME node.</p>
               
               <pre><code>func InitSlice(n *ir.Name, noff int64, lsym *obj.LSym, lencap int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitSliceBytes" data-name="InitSliceBytes">
               <h3>
                  InitSliceBytes 
                  <span class="badge">function</span>
                  
                  <a href="#InitSliceBytes" class="anchor" title="Link to InitSliceBytes">#</a>
               </h3>
               
               <pre><code>func InitSliceBytes(nam *ir.Name, off int64, s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StringSym" data-name="StringSym">
               <h3>
                  StringSym 
                  <span class="badge">function</span>
                  
                  <a href="#StringSym" class="anchor" title="Link to StringSym">#</a>
               </h3>
               
               <p>StringSym returns a symbol containing the string s.
The symbol contains the string data, not a string header.</p>
               
               <pre><code>func StringSym(pos src.XPos, s string) (data *obj.LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StringSymNoCommon" data-name="StringSymNoCommon">
               <h3>
                  StringSymNoCommon 
                  <span class="badge">function</span>
                  
                  <a href="#StringSymNoCommon" class="anchor" title="Link to StringSymNoCommon">#</a>
               </h3>
               
               <p>StringSymNoCommon is like StringSym, but produces a symbol that is not content-
addressable. This symbol is not supposed to appear in the final binary, it is
only used to pass string arguments to the linker like R_USENAMEDMETHOD does.</p>
               
               <pre><code>func StringSymNoCommon(s string) (data *obj.LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteEmbed" data-name="WriteEmbed">
               <h3>
                  WriteEmbed 
                  <span class="badge">function</span>
                  
                  <a href="#WriteEmbed" class="anchor" title="Link to WriteEmbed">#</a>
               </h3>
               
               <p>WriteEmbed emits the init data for a //go:embed variable,
which is either a string, a []byte, or an embed.FS.</p>
               
               <pre><code>func WriteEmbed(v *ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteFuncSyms" data-name="WriteFuncSyms">
               <h3>
                  WriteFuncSyms 
                  <span class="badge">function</span>
                  
                  <a href="#WriteFuncSyms" class="anchor" title="Link to WriteFuncSyms">#</a>
               </h3>
               
               <pre><code>func WriteFuncSyms()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dstringdata" data-name="dstringdata">
               <h3>
                  dstringdata 
                  <span class="badge">function</span>
                  
                  <a href="#dstringdata" class="anchor" title="Link to dstringdata">#</a>
               </h3>
               
               <pre><code>func dstringdata(s *obj.LSym, off int, t string, pos src.XPos, what string) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="embedFileLess" data-name="embedFileLess">
               <h3>
                  embedFileLess 
                  <span class="badge">function</span>
                  
                  <a href="#embedFileLess" class="anchor" title="Link to embedFileLess">#</a>
               </h3>
               
               <p>embedFileLess implements the sort order for a list of embedded files.
See the comment inside ../../../../embed/embed.go's Files struct for rationale.</p>
               
               <pre><code>func embedFileLess(x string, y string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="embedFileList" data-name="embedFileList">
               <h3>
                  embedFileList 
                  <span class="badge">function</span>
                  
                  <a href="#embedFileList" class="anchor" title="Link to embedFileList">#</a>
               </h3>
               
               <pre><code>func embedFileList(v *ir.Name, kind int) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="embedFileNameSplit" data-name="embedFileNameSplit">
               <h3>
                  embedFileNameSplit 
                  <span class="badge">function</span>
                  
                  <a href="#embedFileNameSplit" class="anchor" title="Link to embedFileNameSplit">#</a>
               </h3>
               
               <pre><code>func embedFileNameSplit(name string) (dir string, elem string, isDir bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="embedKind" data-name="embedKind">
               <h3>
                  embedKind 
                  <span class="badge">function</span>
                  
                  <a href="#embedKind" class="anchor" title="Link to embedKind">#</a>
               </h3>
               
               <p>embedKind determines the kind of embedding variable.</p>
               
               <pre><code>func embedKind(typ *types.Type) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fileStringSym" data-name="fileStringSym">
               <h3>
                  fileStringSym 
                  <span class="badge">function</span>
                  
                  <a href="#fileStringSym" class="anchor" title="Link to fileStringSym">#</a>
               </h3>
               
               <p>fileStringSym returns a symbol for the contents and the size of file.
If readonly is true, the symbol shares storage with any literal string
or other file with the same content and is placed in a read-only section.
If readonly is false, the symbol is a read-write copy separate from any other,
for use as the backing store of a []byte.
The content hash of file is copied into hashBytes. (If hash is nil, nothing is copied.)
The returned symbol contains the data itself, not a string header.</p>
               
               <pre><code>func fileStringSym(pos src.XPos, file string, readonly bool, hashBytes []byte) (*obj.LSym, int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shortHashString" data-name="shortHashString">
               <h3>
                  shortHashString 
                  <span class="badge">function</span>
                  
                  <a href="#shortHashString" class="anchor" title="Link to shortHashString">#</a>
               </h3>
               
               <p>shortHashString converts the hash to a string for use with stringSymPattern.
We cut it to 16 bytes and then base64-encode to make it even smaller.</p>
               
               <pre><code>func shortHashString(hash []byte) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="slicedata" data-name="slicedata">
               <h3>
                  slicedata 
                  <span class="badge">function</span>
                  
                  <a href="#slicedata" class="anchor" title="Link to slicedata">#</a>
               </h3>
               
               <pre><code>func slicedata(pos src.XPos, s string) *obj.LSym</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>