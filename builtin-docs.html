<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - builtin</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>builtin</code>
         </h1>
         <hr />
         
         <article class="global" data-name="true">
            <h2>true</h2>
            <hr />
            
            <p>true and false are the two untyped boolean values.</p>
            
            <pre><code>true</code></pre>
         </article>
         
         <article class="global" data-name="false">
            <h2>false</h2>
            <hr />
            
            <p>true and false are the two untyped boolean values.</p>
            
            <pre><code>false</code></pre>
         </article>
         
         <article class="global" data-name="iota">
            <h2>iota</h2>
            <hr />
            
            <p>iota is a predeclared identifier representing the untyped integer ordinal
number of the current const specification in a (usually parenthesized)
const declaration. It is zero-indexed.</p>
            
            <pre><code>iota</code></pre>
         </article>
         
         <article class="global" data-name="nil">
            <h2>nil</h2>
            <hr />
            
            <p>nil is a predeclared identifier representing the zero value for a
pointer, channel, func, interface, map, or slice type.</p>
            
            <pre><code>nil Type</code></pre>
         </article>
           
         <article class="function" data-name="append">
            <h2>append</h2>
            <hr />
            
            <p>The append built-in function appends elements to the end of a slice. If
it has sufficient capacity, the destination is resliced to accommodate the
new elements. If it does not, a new underlying array will be allocated.
Append returns the updated slice. It is therefore necessary to store the
result of append, often in the variable holding the slice itself:

	slice = append(slice, elem1, elem2)
	slice = append(slice, anotherSlice...)

As a special case, it is legal to append a string to a byte slice, like this:

	slice = append([]byte("hello "), "world"...)</p>
            
            <pre><code>func append(slice []Type, elems ...Type) []Type</code></pre>
         </article>
         
         <article class="function" data-name="copy">
            <h2>copy</h2>
            <hr />
            
            <p>The copy built-in function copies elements from a source slice into a
destination slice. (As a special case, it also will copy bytes from a
string to a slice of bytes.) The source and destination may overlap. Copy
returns the number of elements copied, which will be the minimum of
len(src) and len(dst).</p>
            
            <pre><code>func copy(dst []Type, src []Type) int</code></pre>
         </article>
         
         <article class="function" data-name="delete">
            <h2>delete</h2>
            <hr />
            
            <p>The delete built-in function deletes the element with the specified key
(m[key]) from the map. If m is nil or there is no such element, delete
is a no-op.</p>
            
            <pre><code>func delete(m *ast.MapType, key Type)</code></pre>
         </article>
         
         <article class="function" data-name="len">
            <h2>len</h2>
            <hr />
            
            <p>The len built-in function returns the length of v, according to its type:

  - Array: the number of elements in v.
  - Pointer to array: the number of elements in *v (even if v is nil).
  - Slice, or map: the number of elements in v; if v is nil, len(v) is zero.
  - String: the number of bytes in v.
  - Channel: the number of elements queued (unread) in the channel buffer;
    if v is nil, len(v) is zero.

For some arguments, such as a string literal or a simple array expression, the
result can be a constant. See the Go language specification's "Length and
capacity" section for details.</p>
            
            <pre><code>func len(v Type) int</code></pre>
         </article>
         
         <article class="function" data-name="cap">
            <h2>cap</h2>
            <hr />
            
            <p>The cap built-in function returns the capacity of v, according to its type:

  - Array: the number of elements in v (same as len(v)).
  - Pointer to array: the number of elements in *v (same as len(v)).
  - Slice: the maximum length the slice can reach when resliced;
    if v is nil, cap(v) is zero.
  - Channel: the channel buffer capacity, in units of elements;
    if v is nil, cap(v) is zero.

For some arguments, such as a simple array expression, the result can be a
constant. See the Go language specification's "Length and capacity" section for
details.</p>
            
            <pre><code>func cap(v Type) int</code></pre>
         </article>
         
         <article class="function" data-name="make">
            <h2>make</h2>
            <hr />
            
            <p>The make built-in function allocates and initializes an object of type
slice, map, or chan (only). Like new, the first argument is a type, not a
value. Unlike new, make's return type is the same as the type of its
argument, not a pointer to it. The specification of the result depends on
the type:

  - Slice: The size specifies the length. The capacity of the slice is
    equal to its length. A second integer argument may be provided to
    specify a different capacity; it must be no smaller than the
    length. For example, make([]int, 0, 10) allocates an underlying array
    of size 10 and returns a slice of length 0 and capacity 10 that is
    backed by this underlying array.
  - Map: An empty map is allocated with enough space to hold the
    specified number of elements. The size may be omitted, in which case
    a small starting size is allocated.
  - Channel: The channel's buffer is initialized with the specified
    buffer capacity. If zero, or the size is omitted, the channel is
    unbuffered.</p>
            
            <pre><code>func make(t Type, size ...IntegerType) Type</code></pre>
         </article>
         
         <article class="function" data-name="max">
            <h2>max</h2>
            <hr />
            
            <p>The max built-in function returns the largest value of a fixed number of
arguments of [cmp.Ordered] types. There must be at least one argument.
If T is a floating-point type and any of the arguments are NaNs,
max will return NaN.</p>
            
            <pre><code>func max(x T, y ...T) T</code></pre>
         </article>
         
         <article class="function" data-name="min">
            <h2>min</h2>
            <hr />
            
            <p>The min built-in function returns the smallest value of a fixed number of
arguments of [cmp.Ordered] types. There must be at least one argument.
If T is a floating-point type and any of the arguments are NaNs,
min will return NaN.</p>
            
            <pre><code>func min(x T, y ...T) T</code></pre>
         </article>
         
         <article class="function" data-name="new">
            <h2>new</h2>
            <hr />
            
            <p>The new built-in function allocates memory. The first argument is a type,
not a value, and the value returned is a pointer to a newly
allocated zero value of that type.</p>
            
            <pre><code>func new(Type) *Type</code></pre>
         </article>
         
         <article class="function" data-name="complex">
            <h2>complex</h2>
            <hr />
            
            <p>The complex built-in function constructs a complex value from two
floating-point values. The real and imaginary parts must be of the same
size, either float32 or float64 (or assignable to them), and the return
value will be the corresponding complex type (complex64 for float32,
complex128 for float64).</p>
            
            <pre><code>func complex(r FloatType, i FloatType) ComplexType</code></pre>
         </article>
         
         <article class="function" data-name="real">
            <h2>real</h2>
            <hr />
            
            <p>The real built-in function returns the real part of the complex number c.
The return value will be floating point type corresponding to the type of c.</p>
            
            <pre><code>func real(c ComplexType) FloatType</code></pre>
         </article>
         
         <article class="function" data-name="imag">
            <h2>imag</h2>
            <hr />
            
            <p>The imag built-in function returns the imaginary part of the complex
number c. The return value will be floating point type corresponding to
the type of c.</p>
            
            <pre><code>func imag(c ComplexType) FloatType</code></pre>
         </article>
         
         <article class="function" data-name="clear">
            <h2>clear</h2>
            <hr />
            
            <p>The clear built-in function clears maps and slices.
For maps, clear deletes all entries, resulting in an empty map.
For slices, clear sets all elements up to the length of the slice
to the zero value of the respective element type. If the argument
type is a type parameter, the type parameter's type set must
contain only map or slice types, and clear performs the operation
implied by the type argument. If t is nil, clear is a no-op.</p>
            
            <pre><code>func clear(t T)</code></pre>
         </article>
         
         <article class="function" data-name="close">
            <h2>close</h2>
            <hr />
            
            <p>The close built-in function closes a channel, which must be either
bidirectional or send-only. It should be executed only by the sender,
never the receiver, and has the effect of shutting down the channel after
the last sent value is received. After the last value has been received
from a closed channel c, any receive from c will succeed without
blocking, returning the zero value for the channel element. The form

	x, ok := <-c

will also set ok to false for a closed and empty channel.</p>
            
            <pre><code>func close(c *ast.ChanType)</code></pre>
         </article>
         
         <article class="function" data-name="panic">
            <h2>panic</h2>
            <hr />
            
            <p>The panic built-in function stops normal execution of the current
goroutine. When a function F calls panic, normal execution of F stops
immediately. Any functions whose execution was deferred by F are run in
the usual way, and then F returns to its caller. To the caller G, the
invocation of F then behaves like a call to panic, terminating G's
execution and running any deferred functions. This continues until all
functions in the executing goroutine have stopped, in reverse order. At
that point, the program is terminated with a non-zero exit code. This
termination sequence is called panicking and can be controlled by the
built-in function recover.

Starting in Go 1.21, calling panic with a nil interface value or an
untyped nil causes a run-time error (a different panic).
The GODEBUG setting panicnil=1 disables the run-time error.</p>
            
            <pre><code>func panic(v any)</code></pre>
         </article>
         
         <article class="function" data-name="recover">
            <h2>recover</h2>
            <hr />
            
            <p>The recover built-in function allows a program to manage behavior of a
panicking goroutine. Executing a call to recover inside a deferred
function (but not any function called by it) stops the panicking sequence
by restoring normal execution and retrieves the error value passed to the
call of panic. If recover is called outside the deferred function it will
not stop a panicking sequence. In this case, or when the goroutine is not
panicking, recover returns nil.

Prior to Go 1.21, recover would also return nil if panic is called with
a nil argument. See [panic] for details.</p>
            
            <pre><code>func recover() any</code></pre>
         </article>
         
         <article class="function" data-name="print">
            <h2>print</h2>
            <hr />
            
            <p>The print built-in function formats its arguments in an
implementation-specific way and writes the result to standard error.
Print is useful for bootstrapping and debugging; it is not guaranteed
to stay in the language.</p>
            
            <pre><code>func print(args ...Type)</code></pre>
         </article>
         
         <article class="function" data-name="println">
            <h2>println</h2>
            <hr />
            
            <p>The println built-in function formats its arguments in an
implementation-specific way and writes the result to standard error.
Spaces are always added between arguments and a newline is appended.
Println is useful for bootstrapping and debugging; it is not guaranteed
to stay in the language.</p>
            
            <pre><code>func println(args ...Type)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
