<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>builtin - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                 
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>builtin</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"cmp"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="false" data-name="false">
               <h3>
                  false 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#false" class="anchor" title="Link to false">#</a>
               </h3>
               
                  <p class="doc-comment">true and false are the two untyped boolean values.</p>
               
               <pre><code class="language-go">const false = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="iota" data-name="iota">
               <h3>
                  iota 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#iota" class="anchor" title="Link to iota">#</a>
               </h3>
               
                  <p class="doc-comment">iota is a predeclared identifier representing the untyped integer ordinal
number of the current const specification in a (usually parenthesized)
const declaration. It is zero-indexed.</p>
               
               <pre><code class="language-go">const iota = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nil" data-name="nil">
               <h3>
                  nil 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#nil" class="anchor" title="Link to nil">#</a>
               </h3>
               
                  <p class="doc-comment">nil is a predeclared identifier representing the zero value for a
pointer, channel, func, interface, map, or slice type.</p>
               
               <pre><code class="language-go">var nil Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="true" data-name="true">
               <h3>
                  true 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#true" class="anchor" title="Link to true">#</a>
               </h3>
               
                  <p class="doc-comment">true and false are the two untyped boolean values.</p>
               
               <pre><code class="language-go">const true = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="ComplexType" data-name="ComplexType">
               <h3>
                  ComplexType
                  <span class="badge type-badge">type</span>
                  <a href="#ComplexType" class="anchor" title="Link to ComplexType">#</a>
               </h3>
               
               <p>ComplexType is here for the purposes of documentation only. It is a
stand-in for either complex type: complex64 or complex128.</p>
               
               <pre><code class="language-go">type ComplexType complex64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="FloatType" data-name="FloatType">
               <h3>
                  FloatType
                  <span class="badge type-badge">type</span>
                  <a href="#FloatType" class="anchor" title="Link to FloatType">#</a>
               </h3>
               
               <p>FloatType is here for the purposes of documentation only. It is a stand-in
for either float type: float32 or float64.</p>
               
               <pre><code class="language-go">type FloatType float32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="IntegerType" data-name="IntegerType">
               <h3>
                  IntegerType
                  <span class="badge type-badge">type</span>
                  <a href="#IntegerType" class="anchor" title="Link to IntegerType">#</a>
               </h3>
               
               <p>IntegerType is here for the purposes of documentation only. It is a stand-in
for any integer type: int, uint, int8 etc.</p>
               
               <pre><code class="language-go">type IntegerType int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type
                  <span class="badge type-badge">type</span>
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <p>Type is here for the purposes of documentation only. It is a stand-in
for any Go type, but represents the same type for any given function
invocation.</p>
               
               <pre><code class="language-go">type Type int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Type1" data-name="Type1">
               <h3>
                  Type1
                  <span class="badge type-badge">type</span>
                  <a href="#Type1" class="anchor" title="Link to Type1">#</a>
               </h3>
               
               <p>Type1 is here for the purposes of documentation only. It is a stand-in
for any Go type, but represents the same type for any given function
invocation.</p>
               
               <pre><code class="language-go">type Type1 int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="bool" data-name="bool">
               <h3>
                  bool
                  <span class="badge type-badge">type</span>
                  <a href="#bool" class="anchor" title="Link to bool">#</a>
               </h3>
               
               <p>bool is the set of boolean values, true and false.</p>
               
               <pre><code class="language-go">type bool bool</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="byte" data-name="byte">
               <h3>
                  byte
                  <span class="badge type-badge">type</span>
                  <a href="#byte" class="anchor" title="Link to byte">#</a>
               </h3>
               
               <p>byte is an alias for uint8 and is equivalent to uint8 in all ways. It is
used, by convention, to distinguish byte values from 8-bit unsigned
integer values.</p>
               
               <pre><code class="language-go">type byte uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="complex128" data-name="complex128">
               <h3>
                  complex128
                  <span class="badge type-badge">type</span>
                  <a href="#complex128" class="anchor" title="Link to complex128">#</a>
               </h3>
               
               <p>complex128 is the set of all complex numbers with float64 real and
imaginary parts.</p>
               
               <pre><code class="language-go">type complex128 complex128</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="complex64" data-name="complex64">
               <h3>
                  complex64
                  <span class="badge type-badge">type</span>
                  <a href="#complex64" class="anchor" title="Link to complex64">#</a>
               </h3>
               
               <p>complex64 is the set of all complex numbers with float32 real and
imaginary parts.</p>
               
               <pre><code class="language-go">type complex64 complex64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="float32" data-name="float32">
               <h3>
                  float32
                  <span class="badge type-badge">type</span>
                  <a href="#float32" class="anchor" title="Link to float32">#</a>
               </h3>
               
               <p>float32 is the set of all IEEE 754 32-bit floating-point numbers.</p>
               
               <pre><code class="language-go">type float32 float32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="float64" data-name="float64">
               <h3>
                  float64
                  <span class="badge type-badge">type</span>
                  <a href="#float64" class="anchor" title="Link to float64">#</a>
               </h3>
               
               <p>float64 is the set of all IEEE 754 64-bit floating-point numbers.</p>
               
               <pre><code class="language-go">type float64 float64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="int" data-name="int">
               <h3>
                  int
                  <span class="badge type-badge">type</span>
                  <a href="#int" class="anchor" title="Link to int">#</a>
               </h3>
               
               <p>int is a signed integer type that is at least 32 bits in size. It is a
distinct type, however, and not an alias for, say, int32.</p>
               
               <pre><code class="language-go">type int int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="int16" data-name="int16">
               <h3>
                  int16
                  <span class="badge type-badge">type</span>
                  <a href="#int16" class="anchor" title="Link to int16">#</a>
               </h3>
               
               <p>int16 is the set of all signed 16-bit integers.
Range: -32768 through 32767.</p>
               
               <pre><code class="language-go">type int16 int16</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="int32" data-name="int32">
               <h3>
                  int32
                  <span class="badge type-badge">type</span>
                  <a href="#int32" class="anchor" title="Link to int32">#</a>
               </h3>
               
               <p>int32 is the set of all signed 32-bit integers.
Range: -2147483648 through 2147483647.</p>
               
               <pre><code class="language-go">type int32 int32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="int64" data-name="int64">
               <h3>
                  int64
                  <span class="badge type-badge">type</span>
                  <a href="#int64" class="anchor" title="Link to int64">#</a>
               </h3>
               
               <p>int64 is the set of all signed 64-bit integers.
Range: -9223372036854775808 through 9223372036854775807.</p>
               
               <pre><code class="language-go">type int64 int64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="int8" data-name="int8">
               <h3>
                  int8
                  <span class="badge type-badge">type</span>
                  <a href="#int8" class="anchor" title="Link to int8">#</a>
               </h3>
               
               <p>int8 is the set of all signed 8-bit integers.
Range: -128 through 127.</p>
               
               <pre><code class="language-go">type int8 int8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="rune" data-name="rune">
               <h3>
                  rune
                  <span class="badge type-badge">type</span>
                  <a href="#rune" class="anchor" title="Link to rune">#</a>
               </h3>
               
               <p>rune is an alias for int32 and is equivalent to int32 in all ways. It is
used, by convention, to distinguish character values from integer values.</p>
               
               <pre><code class="language-go">type rune int32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="string" data-name="string">
               <h3>
                  string
                  <span class="badge type-badge">type</span>
                  <a href="#string" class="anchor" title="Link to string">#</a>
               </h3>
               
               <p>string is the set of all strings of 8-bit bytes, conventionally but not
necessarily representing UTF-8-encoded text. A string may be empty, but
not nil. Values of string type are immutable.</p>
               
               <pre><code class="language-go">type string string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="uint" data-name="uint">
               <h3>
                  uint
                  <span class="badge type-badge">type</span>
                  <a href="#uint" class="anchor" title="Link to uint">#</a>
               </h3>
               
               <p>uint is an unsigned integer type that is at least 32 bits in size. It is a
distinct type, however, and not an alias for, say, uint32.</p>
               
               <pre><code class="language-go">type uint uint</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="uint16" data-name="uint16">
               <h3>
                  uint16
                  <span class="badge type-badge">type</span>
                  <a href="#uint16" class="anchor" title="Link to uint16">#</a>
               </h3>
               
               <p>uint16 is the set of all unsigned 16-bit integers.
Range: 0 through 65535.</p>
               
               <pre><code class="language-go">type uint16 uint16</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="uint32" data-name="uint32">
               <h3>
                  uint32
                  <span class="badge type-badge">type</span>
                  <a href="#uint32" class="anchor" title="Link to uint32">#</a>
               </h3>
               
               <p>uint32 is the set of all unsigned 32-bit integers.
Range: 0 through 4294967295.</p>
               
               <pre><code class="language-go">type uint32 uint32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="uint64" data-name="uint64">
               <h3>
                  uint64
                  <span class="badge type-badge">type</span>
                  <a href="#uint64" class="anchor" title="Link to uint64">#</a>
               </h3>
               
               <p>uint64 is the set of all unsigned 64-bit integers.
Range: 0 through 18446744073709551615.</p>
               
               <pre><code class="language-go">type uint64 uint64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="uint8" data-name="uint8">
               <h3>
                  uint8
                  <span class="badge type-badge">type</span>
                  <a href="#uint8" class="anchor" title="Link to uint8">#</a>
               </h3>
               
               <p>uint8 is the set of all unsigned 8-bit integers.
Range: 0 through 255.</p>
               
               <pre><code class="language-go">type uint8 uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="uintptr" data-name="uintptr">
               <h3>
                  uintptr
                  <span class="badge type-badge">type</span>
                  <a href="#uintptr" class="anchor" title="Link to uintptr">#</a>
               </h3>
               
               <p>uintptr is an integer type that is large enough to hold the bit pattern of
any pointer.</p>
               
               <pre><code class="language-go">type uintptr uintptr</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="any" data-name="any">
               <h3>
                  any
                  <span class="badge interface-badge">interface</span>
                  <a href="#any" class="anchor" title="Link to any">#</a>
               </h3>
               
               <p>any is an alias for interface{} and is equivalent to interface{} in all ways.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type any interface {

}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="comparable" data-name="comparable">
               <h3>
                  comparable
                  <span class="badge interface-badge">interface</span>
                  <a href="#comparable" class="anchor" title="Link to comparable">#</a>
               </h3>
               
               <p>comparable is an interface that is implemented by all comparable types
(booleans, numbers, strings, pointers, channels, arrays of comparable types,
structs whose fields are all comparable types).
The comparable interface may only be used as a type parameter constraint,
not as the type of a variable.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type comparable interface {
comparable
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="error" data-name="error">
               <h3>
                  error
                  <span class="badge interface-badge">interface</span>
                  <a href="#error" class="anchor" title="Link to error">#</a>
               </h3>
               
               <p>The error built-in interface type is the conventional interface for
representing an error condition, with the nil value representing no error.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type error interface {
Error() string
}</code></pre>
            </article>
            
         </section>
           
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="append" data-name="append">
               <h3>
                  append 
                  <span class="badge">function</span>
                  
                  <a href="#append" class="anchor" title="Link to append">#</a>
               </h3>
               
               <p>The append built-in function appends elements to the end of a slice. If
it has sufficient capacity, the destination is resliced to accommodate the
new elements. If it does not, a new underlying array will be allocated.
Append returns the updated slice. It is therefore necessary to store the
result of append, often in the variable holding the slice itself:
slice = append(slice, elem1, elem2)
slice = append(slice, anotherSlice...)
As a special case, it is legal to append a string to a byte slice, like this:
slice = append([]byte("hello "), "world"...)</p>
               
               <pre><code class="language-go">func append(slice []Type, elems ...Type) []Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cap" data-name="cap">
               <h3>
                  cap 
                  <span class="badge">function</span>
                  
                  <a href="#cap" class="anchor" title="Link to cap">#</a>
               </h3>
               
               <p>The cap built-in function returns the capacity of v, according to its type:
- Array: the number of elements in v (same as len(v)).
- Pointer to array: the number of elements in *v (same as len(v)).
- Slice: the maximum length the slice can reach when resliced;
if v is nil, cap(v) is zero.
- Channel: the channel buffer capacity, in units of elements;
if v is nil, cap(v) is zero.
For some arguments, such as a simple array expression, the result can be a
constant. See the Go language specification's "Length and capacity" section for
details.</p>
               
               <pre><code class="language-go">func cap(v Type) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clear" data-name="clear">
               <h3>
                  clear 
                  <span class="badge">function</span>
                  
                  <a href="#clear" class="anchor" title="Link to clear">#</a>
               </h3>
               
               <p>The clear built-in function clears maps and slices.
For maps, clear deletes all entries, resulting in an empty map.
For slices, clear sets all elements up to the length of the slice
to the zero value of the respective element type. If the argument
type is a type parameter, the type parameter's type set must
contain only map or slice types, and clear performs the operation
implied by the type argument. If t is nil, clear is a no-op.</p>
               
               <pre><code class="language-go">func clear(t T)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="close" data-name="close">
               <h3>
                  close 
                  <span class="badge">function</span>
                  
                  <a href="#close" class="anchor" title="Link to close">#</a>
               </h3>
               
               <p>The close built-in function closes a channel, which must be either
bidirectional or send-only. It should be executed only by the sender,
never the receiver, and has the effect of shutting down the channel after
the last sent value is received. After the last value has been received
from a closed channel c, any receive from c will succeed without
blocking, returning the zero value for the channel element. The form
x, ok := <-c
will also set ok to false for a closed and empty channel.</p>
               
               <pre><code class="language-go">func close(c chan<- Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="complex" data-name="complex">
               <h3>
                  complex 
                  <span class="badge">function</span>
                  
                  <a href="#complex" class="anchor" title="Link to complex">#</a>
               </h3>
               
               <p>The complex built-in function constructs a complex value from two
floating-point values. The real and imaginary parts must be of the same
size, either float32 or float64 (or assignable to them), and the return
value will be the corresponding complex type (complex64 for float32,
complex128 for float64).</p>
               
               <pre><code class="language-go">func complex(r FloatType, i FloatType) ComplexType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copy" data-name="copy">
               <h3>
                  copy 
                  <span class="badge">function</span>
                  
                  <a href="#copy" class="anchor" title="Link to copy">#</a>
               </h3>
               
               <p>The copy built-in function copies elements from a source slice into a
destination slice. (As a special case, it also will copy bytes from a
string to a slice of bytes.) The source and destination may overlap. Copy
returns the number of elements copied, which will be the minimum of
len(src) and len(dst).</p>
               
               <pre><code class="language-go">func copy(dst []Type, src []Type) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="delete" data-name="delete">
               <h3>
                  delete 
                  <span class="badge">function</span>
                  
                  <a href="#delete" class="anchor" title="Link to delete">#</a>
               </h3>
               
               <p>The delete built-in function deletes the element with the specified key
(m[key]) from the map. If m is nil or there is no such element, delete
is a no-op.</p>
               
               <pre><code class="language-go">func delete(m map[Type]Type1, key Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="imag" data-name="imag">
               <h3>
                  imag 
                  <span class="badge">function</span>
                  
                  <a href="#imag" class="anchor" title="Link to imag">#</a>
               </h3>
               
               <p>The imag built-in function returns the imaginary part of the complex
number c. The return value will be floating point type corresponding to
the type of c.</p>
               
               <pre><code class="language-go">func imag(c ComplexType) FloatType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="len" data-name="len">
               <h3>
                  len 
                  <span class="badge">function</span>
                  
                  <a href="#len" class="anchor" title="Link to len">#</a>
               </h3>
               
               <p>The len built-in function returns the length of v, according to its type:
- Array: the number of elements in v.
- Pointer to array: the number of elements in *v (even if v is nil).
- Slice, or map: the number of elements in v; if v is nil, len(v) is zero.
- String: the number of bytes in v.
- Channel: the number of elements queued (unread) in the channel buffer;
if v is nil, len(v) is zero.
For some arguments, such as a string literal or a simple array expression, the
result can be a constant. See the Go language specification's "Length and
capacity" section for details.</p>
               
               <pre><code class="language-go">func len(v Type) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="make" data-name="make">
               <h3>
                  make 
                  <span class="badge">function</span>
                  
                  <a href="#make" class="anchor" title="Link to make">#</a>
               </h3>
               
               <p>The make built-in function allocates and initializes an object of type
slice, map, or chan (only). Like new, the first argument is a type, not a
value. Unlike new, make's return type is the same as the type of its
argument, not a pointer to it. The specification of the result depends on
the type:
- Slice: The size specifies the length. The capacity of the slice is
equal to its length. A second integer argument may be provided to
specify a different capacity; it must be no smaller than the
length. For example, make([]int, 0, 10) allocates an underlying array
of size 10 and returns a slice of length 0 and capacity 10 that is
backed by this underlying array.
- Map: An empty map is allocated with enough space to hold the
specified number of elements. The size may be omitted, in which case
a small starting size is allocated.
- Channel: The channel's buffer is initialized with the specified
buffer capacity. If zero, or the size is omitted, the channel is
unbuffered.</p>
               
               <pre><code class="language-go">func make(t Type, size ...IntegerType) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="max" data-name="max">
               <h3>
                  max 
                  <span class="badge">function</span>
                  
                  <a href="#max" class="anchor" title="Link to max">#</a>
               </h3>
               
               <p>The max built-in function returns the largest value of a fixed number of
arguments of [cmp.Ordered] types. There must be at least one argument.
If T is a floating-point type and any of the arguments are NaNs,
max will return NaN.</p>
               
               <pre><code class="language-go">func max(x T, y ...T) T</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="min" data-name="min">
               <h3>
                  min 
                  <span class="badge">function</span>
                  
                  <a href="#min" class="anchor" title="Link to min">#</a>
               </h3>
               
               <p>The min built-in function returns the smallest value of a fixed number of
arguments of [cmp.Ordered] types. There must be at least one argument.
If T is a floating-point type and any of the arguments are NaNs,
min will return NaN.</p>
               
               <pre><code class="language-go">func min(x T, y ...T) T</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="new" data-name="new">
               <h3>
                  new 
                  <span class="badge">function</span>
                  
                  <a href="#new" class="anchor" title="Link to new">#</a>
               </h3>
               
               <p>The new built-in function allocates memory. The first argument is a type,
not a value, and the value returned is a pointer to a newly
allocated zero value of that type.</p>
               
               <pre><code class="language-go">func new(Type) *Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="panic" data-name="panic">
               <h3>
                  panic 
                  <span class="badge">function</span>
                  
                  <a href="#panic" class="anchor" title="Link to panic">#</a>
               </h3>
               
               <p>The panic built-in function stops normal execution of the current
goroutine. When a function F calls panic, normal execution of F stops
immediately. Any functions whose execution was deferred by F are run in
the usual way, and then F returns to its caller. To the caller G, the
invocation of F then behaves like a call to panic, terminating G's
execution and running any deferred functions. This continues until all
functions in the executing goroutine have stopped, in reverse order. At
that point, the program is terminated with a non-zero exit code. This
termination sequence is called panicking and can be controlled by the
built-in function recover.
Starting in Go 1.21, calling panic with a nil interface value or an
untyped nil causes a run-time error (a different panic).
The GODEBUG setting panicnil=1 disables the run-time error.</p>
               
               <pre><code class="language-go">func panic(v any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="print" data-name="print">
               <h3>
                  print 
                  <span class="badge">function</span>
                  
                  <a href="#print" class="anchor" title="Link to print">#</a>
               </h3>
               
               <p>The print built-in function formats its arguments in an
implementation-specific way and writes the result to standard error.
Print is useful for bootstrapping and debugging; it is not guaranteed
to stay in the language.</p>
               
               <pre><code class="language-go">func print(args ...Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="println" data-name="println">
               <h3>
                  println 
                  <span class="badge">function</span>
                  
                  <a href="#println" class="anchor" title="Link to println">#</a>
               </h3>
               
               <p>The println built-in function formats its arguments in an
implementation-specific way and writes the result to standard error.
Spaces are always added between arguments and a newline is appended.
Println is useful for bootstrapping and debugging; it is not guaranteed
to stay in the language.</p>
               
               <pre><code class="language-go">func println(args ...Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="real" data-name="real">
               <h3>
                  real 
                  <span class="badge">function</span>
                  
                  <a href="#real" class="anchor" title="Link to real">#</a>
               </h3>
               
               <p>The real built-in function returns the real part of the complex number c.
The return value will be floating point type corresponding to the type of c.</p>
               
               <pre><code class="language-go">func real(c ComplexType) FloatType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recover" data-name="recover">
               <h3>
                  recover 
                  <span class="badge">function</span>
                  
                  <a href="#recover" class="anchor" title="Link to recover">#</a>
               </h3>
               
               <p>The recover built-in function allows a program to manage behavior of a
panicking goroutine. Executing a call to recover inside a deferred
function (but not any function called by it) stops the panicking sequence
by restoring normal execution and retrieves the error value passed to the
call of panic. If recover is called outside the deferred function it will
not stop a panicking sequence. In this case, or when the goroutine is not
panicking, recover returns nil.
Prior to Go 1.21, recover would also return nil if panic is called with
a nil argument. See [panic] for details.</p>
               
               <pre><code class="language-go">func recover() any</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>