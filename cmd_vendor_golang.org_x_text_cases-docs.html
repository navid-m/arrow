<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - cases</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>cases</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"golang.org/x/text/language"
"golang.org/x/text/transform"
"golang.org/x/text/transform"
"strings"
"unicode"
"unicode/utf8"
"golang.org/x/text/internal"
"golang.org/x/text/language"
"golang.org/x/text/transform"
"golang.org/x/text/unicode/norm"
"golang.org/x/text/transform"
"C"
"unsafe"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="Compact">
               <h3>
                  Compact 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Compact omits mappings in case folding for characters that would grow the
input. (Unimplemented.)</p>
               
               <pre><code>var Compact Option = compact</code></pre>
            </article>
            
            <article class="global" data-name="NoLower">
               <h3>
                  NoLower 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>NoLower disables the lowercasing of non-leading letters for a title
caser.</p>
               
               <pre><code>var NoLower Option = noLower</code></pre>
            </article>
            
            <article class="global" data-name="Supported">
               <h3>
                  Supported 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var Supported language.Coverage</code></pre>
            </article>
            
            <article class="global" data-name="UnicodeVersion">
               <h3>
                  UnicodeVersion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
               
               <pre><code>const UnicodeVersion = "15.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="UnicodeVersion">
               <h3>
                  UnicodeVersion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
               
               <pre><code>const UnicodeVersion = "10.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="UnicodeVersion">
               <h3>
                  UnicodeVersion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
               
               <pre><code>const UnicodeVersion = "12.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="UnicodeVersion">
               <h3>
                  UnicodeVersion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
               
               <pre><code>const UnicodeVersion = "11.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="UnicodeVersion">
               <h3>
                  UnicodeVersion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
               
               <pre><code>const UnicodeVersion = "9.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="UnicodeVersion">
               <h3>
                  UnicodeVersion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
               
               <pre><code>const UnicodeVersion = "13.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="above">
               <h3>
                  above 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const above = 230</code></pre>
            </article>
            
            <article class="global" data-name="cIgnorableCased">
               <h3>
                  cIgnorableCased 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.
A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
               
               <pre><code>const cIgnorableCased</code></pre>
            </article>
            
            <article class="global" data-name="cIgnorableUncased">
               <h3>
                  cIgnorableUncased 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.
A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
               
               <pre><code>const cIgnorableUncased</code></pre>
            </article>
            
            <article class="global" data-name="cLower">
               <h3>
                  cLower 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.
A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
               
               <pre><code>const cLower</code></pre>
            </article>
            
            <article class="global" data-name="cTitle">
               <h3>
                  cTitle 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.
A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
               
               <pre><code>const cTitle</code></pre>
            </article>
            
            <article class="global" data-name="cUncased">
               <h3>
                  cUncased 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.
A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
               
               <pre><code>const cUncased info = iota</code></pre>
            </article>
            
            <article class="global" data-name="cUpper">
               <h3>
                  cUpper 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.
A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
               
               <pre><code>const cUpper</code></pre>
            </article>
            
            <article class="global" data-name="cXORCase">
               <h3>
                  cXORCase 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.
A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
               
               <pre><code>const cXORCase</code></pre>
            </article>
            
            <article class="global" data-name="caseIndex">
               <h3>
                  caseIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>caseIndex: 25 blocks, 1600 entries, 3200 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var caseIndex = [1600]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="caseIndex">
               <h3>
                  caseIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>caseIndex: 25 blocks, 1600 entries, 3200 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var caseIndex = [1600]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="caseIndex">
               <h3>
                  caseIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>caseIndex: 25 blocks, 1600 entries, 3200 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var caseIndex = [1600]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="caseIndex">
               <h3>
                  caseIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>caseIndex: 27 blocks, 1728 entries, 3456 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var caseIndex = [1728]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="caseIndex">
               <h3>
                  caseIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>caseIndex: 25 blocks, 1600 entries, 3200 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var caseIndex = [1600]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="caseIndex">
               <h3>
                  caseIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>caseIndex: 25 blocks, 1600 entries, 3200 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var caseIndex = [1600]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="caseValues">
               <h3>
                  caseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>caseValues: 20 blocks, 1280 entries, 2560 bytes
The third block is the zero block.</p>
               
               <pre><code>var caseValues = [1280]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="caseValues">
               <h3>
                  caseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>caseValues: 22 blocks, 1408 entries, 2816 bytes
The third block is the zero block.</p>
               
               <pre><code>var caseValues = [1408]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="caseValues">
               <h3>
                  caseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>caseValues: 22 blocks, 1408 entries, 2816 bytes
The third block is the zero block.</p>
               
               <pre><code>var caseValues = [1408]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="caseValues">
               <h3>
                  caseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>caseValues: 22 blocks, 1408 entries, 2816 bytes
The third block is the zero block.</p>
               
               <pre><code>var caseValues = [1408]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="caseValues">
               <h3>
                  caseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>caseValues: 20 blocks, 1280 entries, 2560 bytes
The third block is the zero block.</p>
               
               <pre><code>var caseValues = [1280]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="caseValues">
               <h3>
                  caseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>caseValues: 24 blocks, 1536 entries, 3072 bytes
The third block is the zero block.</p>
               
               <pre><code>var caseValues = [1536]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="casedMask">
               <h3>
                  casedMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const casedMask = 0x0003</code></pre>
            </article>
            
            <article class="global" data-name="cccAbove">
               <h3>
                  cccAbove 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The case mapping implementation will need to know about various Canonical
Combining Class (CCC) values. We encode two of these in the trie value:
cccZero (0) and cccAbove (230). If the value is cccOther, it means that
CCC(r) > 0, but not 230. A value of cccBreak means that CCC(r) == 0 and that
the rune also has the break category Break (see below).</p>
               
               <pre><code>const cccAbove</code></pre>
            </article>
            
            <article class="global" data-name="cccBreak">
               <h3>
                  cccBreak 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The case mapping implementation will need to know about various Canonical
Combining Class (CCC) values. We encode two of these in the trie value:
cccZero (0) and cccAbove (230). If the value is cccOther, it means that
CCC(r) > 0, but not 230. A value of cccBreak means that CCC(r) == 0 and that
the rune also has the break category Break (see below).</p>
               
               <pre><code>const cccBreak info = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="cccMask">
               <h3>
                  cccMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The case mapping implementation will need to know about various Canonical
Combining Class (CCC) values. We encode two of these in the trie value:
cccZero (0) and cccAbove (230). If the value is cccOther, it means that
CCC(r) > 0, but not 230. A value of cccBreak means that CCC(r) == 0 and that
the rune also has the break category Break (see below).</p>
               
               <pre><code>const cccMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="cccOther">
               <h3>
                  cccOther 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The case mapping implementation will need to know about various Canonical
Combining Class (CCC) values. We encode two of these in the trie value:
cccZero (0) and cccAbove (230). If the value is cccOther, it means that
CCC(r) > 0, but not 230. A value of cccBreak means that CCC(r) == 0 and that
the rune also has the break category Break (see below).</p>
               
               <pre><code>const cccOther</code></pre>
            </article>
            
            <article class="global" data-name="cccZero">
               <h3>
                  cccZero 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The case mapping implementation will need to know about various Canonical
Combining Class (CCC) values. We encode two of these in the trie value:
cccZero (0) and cccAbove (230). If the value is cccOther, it means that
CCC(r) > 0, but not 230. A value of cccBreak means that CCC(r) == 0 and that
the rune also has the break category Break (see below).</p>
               
               <pre><code>const cccZero</code></pre>
            </article>
            
            <article class="global" data-name="exceptionBit">
               <h3>
                  exceptionBit 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const exceptionBit = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="exceptionShift">
               <h3>
                  exceptionShift 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const exceptionShift = 4</code></pre>
            </article>
            
            <article class="global" data-name="exceptions">
               <h3>
                  exceptions 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var exceptions string = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="exceptions">
               <h3>
                  exceptions 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var exceptions string = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="exceptions">
               <h3>
                  exceptions 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var exceptions string = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="exceptions">
               <h3>
                  exceptions 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var exceptions string = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="exceptions">
               <h3>
                  exceptions 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var exceptions string = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="exceptions">
               <h3>
                  exceptions 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var exceptions string = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="fullCasedMask">
               <h3>
                  fullCasedMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fullCasedMask = 0x0007</code></pre>
            </article>
            
            <article class="global" data-name="hasMappingMask">
               <h3>
                  hasMappingMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>There is no mapping if all xor bits and the exception bit are zero.</p>
               
               <pre><code>const hasMappingMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="ignorableMask">
               <h3>
                  ignorableMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ignorableMask = 0x0006</code></pre>
            </article>
            
            <article class="global" data-name="ignorableValue">
               <h3>
                  ignorableValue 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ignorableValue = 0x0004</code></pre>
            </article>
            
            <article class="global" data-name="inverseFoldBit">
               <h3>
                  inverseFoldBit 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const inverseFoldBit = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="iotaSubscript">
               <h3>
                  iotaSubscript 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const iotaSubscript = 240</code></pre>
            </article>
            
            <article class="global" data-name="isMidBit">
               <h3>
                  isMidBit 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const isMidBit = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="lastRuneForTesting">
               <h3>
                  lastRuneForTesting 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>lastRuneForTesting is the last rune used for testing. Everything after this
is boring.</p>
               
               <pre><code>const lastRuneForTesting = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="lengthBits">
               <h3>
                  lengthBits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The exceptions slice holds data that does not fit in a normal info entry.
The entry is pointed to by the exception index in an entry. It has the
following format:
Header:
byte 0:
7..6  unused
5..4  CCC type (same bits as entry)
3  unused
2..0  length of fold
byte 1:
7..6  unused
5..3  length of 1st mapping of case type
2..0  length of 2nd mapping of case type
case     1st    2nd
lower -> upper, title
upper -> lower, title
title -> lower, upper
Lengths with the value 0x7 indicate no value and implies no change.
A length of 0 indicates a mapping to zero-length string.
Body bytes:
case folding bytes
lowercase mapping bytes
uppercase mapping bytes
titlecase mapping bytes
closure mapping bytes (for NFKC_Casefold). (TODO)
Fallbacks:
missing fold  -> lower
missing title -> upper
all missing   -> original rune
exceptions starts with a dummy byte to enforce that there is no zero index
value.</p>
               
               <pre><code>const lengthBits = 3</code></pre>
            </article>
            
            <article class="global" data-name="lengthMask">
               <h3>
                  lengthMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The exceptions slice holds data that does not fit in a normal info entry.
The entry is pointed to by the exception index in an entry. It has the
following format:
Header:
byte 0:
7..6  unused
5..4  CCC type (same bits as entry)
3  unused
2..0  length of fold
byte 1:
7..6  unused
5..3  length of 1st mapping of case type
2..0  length of 2nd mapping of case type
case     1st    2nd
lower -> upper, title
upper -> lower, title
title -> lower, upper
Lengths with the value 0x7 indicate no value and implies no change.
A length of 0 indicates a mapping to zero-length string.
Body bytes:
case folding bytes
lowercase mapping bytes
uppercase mapping bytes
titlecase mapping bytes
closure mapping bytes (for NFKC_Casefold). (TODO)
Fallbacks:
missing fold  -> lower
missing title -> upper
all missing   -> original rune
exceptions starts with a dummy byte to enforce that there is no zero index
value.</p>
               
               <pre><code>const lengthMask = 0x07</code></pre>
            </article>
            
            <article class="global" data-name="lowerFunc">
               <h3>
                  lowerFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var lowerFunc = []mapFunc{...}</code></pre>
            </article>
            
            <article class="global" data-name="matcher">
               <h3>
                  matcher 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var matcher *internal.InheritanceMatcher</code></pre>
            </article>
            
            <article class="global" data-name="maxCaseMode">
               <h3>
                  maxCaseMode 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.
A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
               
               <pre><code>const maxCaseMode = cUpper</code></pre>
            </article>
            
            <article class="global" data-name="maxIgnorable">
               <h3>
                  maxIgnorable 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>maxIgnorable defines the maximum number of ignorables to consider for
lookahead operations.</p>
               
               <pre><code>const maxIgnorable = 30</code></pre>
            </article>
            
            <article class="global" data-name="noChange">
               <h3>
                  noChange 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The exceptions slice holds data that does not fit in a normal info entry.
The entry is pointed to by the exception index in an entry. It has the
following format:
Header:
byte 0:
7..6  unused
5..4  CCC type (same bits as entry)
3  unused
2..0  length of fold
byte 1:
7..6  unused
5..3  length of 1st mapping of case type
2..0  length of 2nd mapping of case type
case     1st    2nd
lower -> upper, title
upper -> lower, title
title -> lower, upper
Lengths with the value 0x7 indicate no value and implies no change.
A length of 0 indicates a mapping to zero-length string.
Body bytes:
case folding bytes
lowercase mapping bytes
uppercase mapping bytes
titlecase mapping bytes
closure mapping bytes (for NFKC_Casefold). (TODO)
Fallbacks:
missing fold  -> lower
missing title -> upper
all missing   -> original rune
exceptions starts with a dummy byte to enforce that there is no zero index
value.</p>
               
               <pre><code>const noChange = 0</code></pre>
            </article>
            
            <article class="global" data-name="numExceptionBits">
               <h3>
                  numExceptionBits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const numExceptionBits = 12</code></pre>
            </article>
            
            <article class="global" data-name="sparse">
               <h3>
                  sparse 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var sparse = sparseBlocks{...}</code></pre>
            </article>
            
            <article class="global" data-name="sparseOffsets">
               <h3>
                  sparseOffsets 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>sparseOffsets: 296 entries, 592 bytes</p>
               
               <pre><code>var sparseOffsets = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="sparseOffsets">
               <h3>
                  sparseOffsets 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>sparseOffsets: 272 entries, 544 bytes</p>
               
               <pre><code>var sparseOffsets = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="sparseOffsets">
               <h3>
                  sparseOffsets 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>sparseOffsets: 277 entries, 554 bytes</p>
               
               <pre><code>var sparseOffsets = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="sparseOffsets">
               <h3>
                  sparseOffsets 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>sparseOffsets: 312 entries, 624 bytes</p>
               
               <pre><code>var sparseOffsets = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="sparseOffsets">
               <h3>
                  sparseOffsets 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>sparseOffsets: 289 entries, 578 bytes</p>
               
               <pre><code>var sparseOffsets = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="sparseOffsets">
               <h3>
                  sparseOffsets 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>sparseOffsets: 282 entries, 564 bytes</p>
               
               <pre><code>var sparseOffsets = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="sparseValues">
               <h3>
                  sparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>sparseValues: 1483 entries, 5932 bytes</p>
               
               <pre><code>var sparseValues = [1483]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="sparseValues">
               <h3>
                  sparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>sparseValues: 1418 entries, 5672 bytes</p>
               
               <pre><code>var sparseValues = [1418]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="sparseValues">
               <h3>
                  sparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>sparseValues: 1360 entries, 5440 bytes</p>
               
               <pre><code>var sparseValues = [1360]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="sparseValues">
               <h3>
                  sparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>sparseValues: 1451 entries, 5804 bytes</p>
               
               <pre><code>var sparseValues = [1451]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="sparseValues">
               <h3>
                  sparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>sparseValues: 1395 entries, 5580 bytes</p>
               
               <pre><code>var sparseValues = [1395]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="sparseValues">
               <h3>
                  sparseValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>sparseValues: 1562 entries, 6248 bytes</p>
               
               <pre><code>var sparseValues = [1562]valueRange{...}</code></pre>
            </article>
            
            <article class="global" data-name="starter">
               <h3>
                  starter 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const starter = 0</code></pre>
            </article>
            
            <article class="global" data-name="supported">
               <h3>
                  supported 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>supported lists the language tags for which we have tailorings.</p>
               
               <pre><code>const supported = "und af az el lt nl tr"</code></pre>
            </article>
            
            <article class="global" data-name="titleInfos">
               <h3>
                  titleInfos 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var titleInfos = []struct{...}{...}</code></pre>
            </article>
            
            <article class="global" data-name="trie">
               <h3>
                  trie 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var trie = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="undLower">
               <h3>
                  undLower 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var undLower transform.SpanningTransformer = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="undLowerIgnoreSigma">
               <h3>
                  undLowerIgnoreSigma 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var undLowerIgnoreSigma transform.SpanningTransformer = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="undUpper">
               <h3>
                  undUpper 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var undUpper transform.SpanningTransformer = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="upperFunc">
               <h3>
                  upperFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Some uppercase mappers are stateless, so we can precompute the
Transformers and save a bit on runtime allocations.</p>
               
               <pre><code>var upperFunc = []struct{...}{...}</code></pre>
            </article>
            
            <article class="global" data-name="xorData">
               <h3>
                  xorData 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var xorData string = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="xorData">
               <h3>
                  xorData 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var xorData string = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="xorData">
               <h3>
                  xorData 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var xorData string = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="xorData">
               <h3>
                  xorData 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var xorData string = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="xorData">
               <h3>
                  xorData 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var xorData string = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="xorData">
               <h3>
                  xorData 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var xorData string = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="xorIndexBit">
               <h3>
                  xorIndexBit 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const xorIndexBit = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="xorShift">
               <h3>
                  xorShift 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const xorShift = 8</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="Option">
               <h3>
                  Option
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An Option is used to modify the behavior of a Caser.</p>
               
               <pre><code>type Option func(o options) options</code></pre>
            </article>
            
            <article class="type" data-name="info">
               <h3>
                  info
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>info holds case information for a single rune. It is the value returned
by a trie lookup. Most mapping information can be stored in a single 16-bit
value. If not, for example when a rune is mapped to multiple runes, the value
stores some basic case data and an index into an array with additional data.
The per-rune values have the following format:
if (exception) {
15..4  unsigned exception index
} else {
15..8  XOR pattern or index to XOR pattern for case mapping
Only 13..8 are used for XOR patterns.
7  inverseFold (fold to upper, not to lower)
6  index: interpret the XOR pattern as an index
or isMid if case mode is cIgnorableUncased.
5..4  CCC: zero (normal or break), above or other
}
3  exception: interpret this value as an exception index
(TODO: is this bit necessary? Probably implied from case mode.)
2..0  case mode
For the non-exceptional cases, a rune must be either uncased, lowercase or
uppercase. If the rune is cased, the XOR pattern maps either a lowercase
rune to uppercase or an uppercase rune to lowercase (applied to the 10
least-significant bits of the rune).
See the definitions below for a more detailed description of the various
bits.</p>
               
               <pre><code>type info uint16</code></pre>
            </article>
            
            <article class="type" data-name="mapFunc">
               <h3>
                  mapFunc
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A mapFunc takes a context set to the current rune and writes the mapped
version to the same context. It may advance the context to the next rune. It
returns whether a checkpoint is possible: whether the pDst bytes written to
dst so far won't need changing as we see more source bytes.</p>
               
               <pre><code>type mapFunc func(*context) bool</code></pre>
            </article>
            
            <article class="type" data-name="spanFunc">
               <h3>
                  spanFunc
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A spanFunc takes a context set to the current rune and returns whether this
rune would be altered when written to the output. It may advance the context
to the next rune. It returns whether a checkpoint is possible.</p>
               
               <pre><code>type spanFunc func(*context) bool</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Caser">
               <h3>
                  Caser
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Caser transforms given input to a certain case. It implements
transform.Transformer.
A Caser may be stateful and should therefore not be shared between
goroutines.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Caser struct {
t transform.SpanningTransformer
}</code></pre>
            </article>
            
            <article class="struct" data-name="caseFolder">
               <h3>
                  caseFolder
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type caseFolder struct {
transform.NopResetter
}</code></pre>
            </article>
            
            <article class="struct" data-name="caseTrie">
               <h3>
                  caseTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>caseTrie. Total size: 12396 bytes (12.11 KiB). Checksum: c0656238384c3da1.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type caseTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="caseTrie">
               <h3>
                  caseTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>caseTrie. Total size: 11742 bytes (11.47 KiB). Checksum: 795fe57ee5135873.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type caseTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="caseTrie">
               <h3>
                  caseTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>caseTrie. Total size: 13398 bytes (13.08 KiB). Checksum: 544af6e6b1b70931.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type caseTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="caseTrie">
               <h3>
                  caseTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>caseTrie. Total size: 12538 bytes (12.24 KiB). Checksum: af4dfa7d60c71d4c.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type caseTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="caseTrie">
               <h3>
                  caseTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>caseTrie. Total size: 12250 bytes (11.96 KiB). Checksum: 53ff6cb7321675e1.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type caseTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="caseTrie">
               <h3>
                  caseTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>caseTrie. Total size: 11892 bytes (11.61 KiB). Checksum: c6f15484b7653775.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type caseTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="context">
               <h3>
                  context
                  <span class="badge">struct</span>
               </h3>
               
               <p>A context is used for iterating over source bytes, fetching case info and
writing to a destination buffer.
Casing operations may need more than one rune of context to decide how a rune
should be cased. Casing implementations should call checkpoint on context
whenever it is known to be safe to return the runes processed so far.
It is recommended for implementations to not allow for more than 30 case
ignorables as lookahead (analogous to the limit in norm) and to use state if
unbounded lookahead is needed for cased runes.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type context struct {
dst []byte
src []byte
atEOF bool
pDst int
pSrc int
nDst int
nSrc int
err error
sz int
info info
isMidWord bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="lowerCaser">
               <h3>
                  lowerCaser
                  <span class="badge">struct</span>
               </h3>
               
               <p>lowerCaser implements the Transformer interface. The default Unicode lower
casing requires different treatment for the first and subsequent characters
of a word, most notably to handle the Greek final Sigma.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type lowerCaser struct {
undLowerIgnoreSigmaCaser
context
first mapFunc
midWord mapFunc
}</code></pre>
            </article>
            
            <article class="struct" data-name="options">
               <h3>
                  options
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type options struct {
noLower bool
simple bool
ignoreFinalSigma bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="simpleCaser">
               <h3>
                  simpleCaser
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type simpleCaser struct {
context
f mapFunc
span spanFunc
}</code></pre>
            </article>
            
            <article class="struct" data-name="sparseBlocks">
               <h3>
                  sparseBlocks
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sparseBlocks struct {
values []valueRange
offsets []uint16
}</code></pre>
            </article>
            
            <article class="struct" data-name="titleCaser">
               <h3>
                  titleCaser
                  <span class="badge">struct</span>
               </h3>
               
               <p>titleCaser implements the Transformer interface. Title casing algorithms
distinguish between the first letter of a word and subsequent letters of the
same word. It uses state to avoid requiring a potentially infinite lookahead.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type titleCaser struct {
context
title mapFunc
lower mapFunc
titleSpan spanFunc
rewrite func(*context)
}</code></pre>
            </article>
            
            <article class="struct" data-name="undLowerCaser">
               <h3>
                  undLowerCaser
                  <span class="badge">struct</span>
               </h3>
               
               <p>undLowerCaser implements the Transformer interface for doing a lower case
mapping for the root locale (und) ignoring final sigma handling. This casing
algorithm is used in some performance-critical packages like secure/precis
and x/net/http/idna, which warrants its special-casing.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type undLowerCaser struct {
transform.NopResetter
}</code></pre>
            </article>
            
            <article class="struct" data-name="undLowerIgnoreSigmaCaser">
               <h3>
                  undLowerIgnoreSigmaCaser
                  <span class="badge">struct</span>
               </h3>
               
               <p>undLowerIgnoreSigmaCaser implements the Transformer interface for doing
a lower case mapping for the root locale (und) ignoring final sigma
handling. This casing algorithm is used in some performance-critical packages
like secure/precis and x/net/http/idna, which warrants its special-casing.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type undLowerIgnoreSigmaCaser struct {
transform.NopResetter
}</code></pre>
            </article>
            
            <article class="struct" data-name="undUpperCaser">
               <h3>
                  undUpperCaser
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type undUpperCaser struct {
transform.NopResetter
}</code></pre>
            </article>
            
            <article class="struct" data-name="valueRange">
               <h3>
                  valueRange
                  <span class="badge">struct</span>
               </h3>
               
               <p>valueRange is an entry in a sparse block.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type valueRange struct {
value uint16
lo byte
hi byte
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bytes returns a new byte slice with the result of converting b to the case
form implemented by c.</p>
               
               <pre><code>func (c Caser) Bytes(b []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="Fold">
               <h3>
                  Fold 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Fold returns a Caser that implements Unicode case folding. The returned Caser
is stateless and safe to use concurrently by multiple goroutines.
Case folding does not normalize the input and may not preserve a normal form.
Use the collate or search package for more convenient and linguistically
sound comparisons. Use golang.org/x/text/secure/precis for string comparisons
where security aspects are a concern.</p>
               
               <pre><code>func Fold(opts ...Option) Caser</code></pre>
            </article>
            
            <article class="function" data-name="HandleFinalSigma">
               <h3>
                  HandleFinalSigma 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>HandleFinalSigma specifies whether the special handling of Greek final sigma
should be enabled. Unicode prescribes handling the Greek final sigma for all
locales, but standards like IDNA and PRECIS override this default.</p>
               
               <pre><code>func HandleFinalSigma(enable bool) Option</code></pre>
            </article>
            
            <article class="function" data-name="Lower">
               <h3>
                  Lower 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Lower returns a Caser for language-specific lowercasing.</p>
               
               <pre><code>func Lower(t language.Tag, opts ...Option) Caser</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *context) Reset()</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reset resets the Caser to be reused for new input after a previous call to
Transform.</p>
               
               <pre><code>func (c Caser) Reset()</code></pre>
            </article>
            
            <article class="function" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *simpleCaser) Span(src []byte, atEOF bool) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *caseFolder) Span(src []byte, atEOF bool) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t undUpperCaser) Span(src []byte, atEOF bool) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Span implements a generic lower-casing. This is possible as isLower works
for all lowercasing variants. All lowercase variants only vary in how they
transform a non-lowercase letter. They will never change an already lowercase
letter. In addition, there is no state.</p>
               
               <pre><code>func (t undLowerIgnoreSigmaCaser) Span(src []byte, atEOF bool) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t undLowerCaser) Span(src []byte, atEOF bool) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Span implements the transform.SpanningTransformer interface.</p>
               
               <pre><code>func (c Caser) Span(src []byte, atEOF bool) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *titleCaser) Span(src []byte, atEOF bool) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a string with the result of transforming s to the case form
implemented by c.</p>
               
               <pre><code>func (c Caser) String(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="Title">
               <h3>
                  Title 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Title returns a Caser for language-specific title casing. It uses an
approximation of the default Unicode Word Break algorithm.</p>
               
               <pre><code>func Title(t language.Tag, opts ...Option) Caser</code></pre>
            </article>
            
            <article class="function" data-name="Transform">
               <h3>
                  Transform 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t undLowerIgnoreSigmaCaser) Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Transform">
               <h3>
                  Transform 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>undUpperCaser implements the Transformer interface for doing an upper case
mapping for the root locale (und). It eliminates the need for an allocation
as it prevents escaping by not using function pointers.</p>
               
               <pre><code>func (t undUpperCaser) Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Transform">
               <h3>
                  Transform 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t undLowerCaser) Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Transform">
               <h3>
                  Transform 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *lowerCaser) Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Transform">
               <h3>
                  Transform 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>caseFolder implements the Transformer interface for doing case folding.</p>
               
               <pre><code>func (t *caseFolder) Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Transform">
               <h3>
                  Transform 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Transform implements the standard Unicode title case algorithm as defined in
Chapter 3 of The Unicode Standard:
toTitlecase(X): Find the word boundaries in X according to Unicode Standard
Annex #29, "Unicode Text Segmentation." For each word boundary, find the
first cased character F following the word boundary. If F exists, map F to
Titlecase_Mapping(F); then map all characters C between F and the following
word boundary to Lowercase_Mapping(C).</p>
               
               <pre><code>func (t *titleCaser) Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Transform">
               <h3>
                  Transform 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>simpleCaser implements the Transformer interface for doing a case operation
on a rune-by-rune basis.</p>
               
               <pre><code>func (t *simpleCaser) Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Transform">
               <h3>
                  Transform 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Transform implements the transform.Transformer interface and transforms the
given input to the case form implemented by c.</p>
               
               <pre><code>func (c Caser) Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Upper">
               <h3>
                  Upper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Upper returns a Caser for language-specific uppercasing.</p>
               
               <pre><code>func Upper(t language.Tag, opts ...Option) Caser</code></pre>
            </article>
            
            <article class="function" data-name="afnlRewrite">
               <h3>
                  afnlRewrite 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Not part of CLDR, but see https://unicode.org/cldr/trac/ticket/7078.</p>
               
               <pre><code>func afnlRewrite(c *context)</code></pre>
            </article>
            
            <article class="function" data-name="aztrLower">
               <h3>
                  aztrLower 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func aztrLower(c *context) (done bool)</code></pre>
            </article>
            
            <article class="function" data-name="aztrUpper">
               <h3>
                  aztrUpper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func aztrUpper(f mapFunc) mapFunc</code></pre>
            </article>
            
            <article class="function" data-name="caseType">
               <h3>
                  caseType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>caseType returns an info with only the case bits, normalized to either
cLower, cUpper, cTitle or cUncased.</p>
               
               <pre><code>func (c *context) caseType() info</code></pre>
            </article>
            
            <article class="function" data-name="cccType">
               <h3>
                  cccType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c info) cccType() info</code></pre>
            </article>
            
            <article class="function" data-name="cccVal">
               <h3>
                  cccVal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c info) cccVal() info</code></pre>
            </article>
            
            <article class="function" data-name="checkpoint">
               <h3>
                  checkpoint 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>checkpoint sets the return value buffer points for Transform to the current
positions.</p>
               
               <pre><code>func (c *context) checkpoint()</code></pre>
            </article>
            
            <article class="function" data-name="compact">
               <h3>
                  compact 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func compact(o options) options</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>copy writes the current rune to dst.</p>
               
               <pre><code>func (c *context) copy() bool</code></pre>
            </article>
            
            <article class="function" data-name="copyXOR">
               <h3>
                  copyXOR 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>copyXOR copies the current rune to dst and modifies it by applying the XOR
pattern of the case info. It is the responsibility of the caller to ensure
that this is a rune with a XOR pattern defined.</p>
               
               <pre><code>func (c *context) copyXOR() bool</code></pre>
            </article>
            
            <article class="function" data-name="doICU">
               <h3>
                  doICU 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func doICU(tag string, caser string, input string) string</code></pre>
            </article>
            
            <article class="function" data-name="elUpper">
               <h3>
                  elUpper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>elUpper implements Greek upper casing, which entails removing a predefined
set of non-blocked modifiers. Note that these accents should not be removed
for title casing!
Example: "Οδός" -> "ΟΔΟΣ".</p>
               
               <pre><code>func elUpper(c *context) bool</code></pre>
            </article>
            
            <article class="function" data-name="finalSigma">
               <h3>
                  finalSigma 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>finalSigma adds Greek final Sigma handing to another casing function. It
determines whether a lowercased sigma should be σ or ς, by looking ahead for
case-ignorables and a cased letters.</p>
               
               <pre><code>func finalSigma(f mapFunc) mapFunc</code></pre>
            </article>
            
            <article class="function" data-name="finalSigmaBody">
               <h3>
                  finalSigmaBody 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func finalSigmaBody(c *context) bool</code></pre>
            </article>
            
            <article class="function" data-name="foldFull">
               <h3>
                  foldFull 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>foldFull writes the foldFull version of the current rune to dst.</p>
               
               <pre><code>func foldFull(c *context) bool</code></pre>
            </article>
            
            <article class="function" data-name="getOpts">
               <h3>
                  getOpts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func getOpts(o ...Option) (res options)</code></pre>
            </article>
            
            <article class="function" data-name="handleFinalSigma">
               <h3>
                  handleFinalSigma 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func handleFinalSigma(o options) options</code></pre>
            </article>
            
            <article class="function" data-name="hasPrefix">
               <h3>
                  hasPrefix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>hasPrefix returns true if src[pSrc:] starts with the given string.</p>
               
               <pre><code>func (c *context) hasPrefix(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="ignoreFinalSigma">
               <h3>
                  ignoreFinalSigma 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ignoreFinalSigma(o options) options</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="isBreak">
               <h3>
                  isBreak 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isBreak returns whether this rune should introduce a break.</p>
               
               <pre><code>func (c info) isBreak() bool</code></pre>
            </article>
            
            <article class="function" data-name="isCaseIgnorable">
               <h3>
                  isCaseIgnorable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c info) isCaseIgnorable() bool</code></pre>
            </article>
            
            <article class="function" data-name="isCaseIgnorableAndNotCased">
               <h3>
                  isCaseIgnorableAndNotCased 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c info) isCaseIgnorableAndNotCased() bool</code></pre>
            </article>
            
            <article class="function" data-name="isCased">
               <h3>
                  isCased 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c info) isCased() bool</code></pre>
            </article>
            
            <article class="function" data-name="isFoldFull">
               <h3>
                  isFoldFull 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isFoldFull reports whether the current run is mapped to foldFull</p>
               
               <pre><code>func isFoldFull(c *context) bool</code></pre>
            </article>
            
            <article class="function" data-name="isLetter">
               <h3>
                  isLetter 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isLetter returns whether the rune is of break type ALetter, Hebrew_Letter,
Numeric, ExtendNumLet, or Extend.</p>
               
               <pre><code>func (c info) isLetter() bool</code></pre>
            </article>
            
            <article class="function" data-name="isLower">
               <h3>
                  isLower 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isLower(c *context) bool</code></pre>
            </article>
            
            <article class="function" data-name="isMid">
               <h3>
                  isMid 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c info) isMid() bool</code></pre>
            </article>
            
            <article class="function" data-name="isNotCasedAndNotCaseIgnorable">
               <h3>
                  isNotCasedAndNotCaseIgnorable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c info) isNotCasedAndNotCaseIgnorable() bool</code></pre>
            </article>
            
            <article class="function" data-name="isTitle">
               <h3>
                  isTitle 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isTitle reports whether the current rune is in title case.</p>
               
               <pre><code>func isTitle(c *context) bool</code></pre>
            </article>
            
            <article class="function" data-name="isUpper">
               <h3>
                  isUpper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isUpper writes the isUppercase version of the current rune to dst.</p>
               
               <pre><code>func isUpper(c *context) bool</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *caseTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *caseTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *caseTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *caseTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the value from values block n for byte b using binary search.</p>
               
               <pre><code>func (s *sparseBlocks) lookup(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *caseTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *caseTrie) lookup(s []byte) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *caseTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *caseTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *caseTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *caseTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *caseTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *caseTrie) lookupString(s string) (v uint16, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *caseTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *caseTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *caseTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *caseTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *caseTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *caseTrie) lookupStringUnsafe(s string) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *caseTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *caseTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *caseTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *caseTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *caseTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *caseTrie) lookupUnsafe(s []byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *caseTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *caseTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *caseTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *caseTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *caseTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *caseTrie) lookupValue(n uint32, b byte) uint16</code></pre>
            </article>
            
            <article class="function" data-name="lower">
               <h3>
                  lower 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lower writes the lowercase version of the current rune to dst.</p>
               
               <pre><code>func lower(c *context) bool</code></pre>
            </article>
            
            <article class="function" data-name="ltLower">
               <h3>
                  ltLower 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ltLower(c *context) bool</code></pre>
            </article>
            
            <article class="function" data-name="ltUpper">
               <h3>
                  ltUpper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ltUpper(f mapFunc) mapFunc</code></pre>
            </article>
            
            <article class="function" data-name="makeFold">
               <h3>
                  makeFold 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeFold(o options) transform.SpanningTransformer</code></pre>
            </article>
            
            <article class="function" data-name="makeLower">
               <h3>
                  makeLower 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeLower(t language.Tag, o options) transform.SpanningTransformer</code></pre>
            </article>
            
            <article class="function" data-name="makeTitle">
               <h3>
                  makeTitle 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeTitle(t language.Tag, o options) transform.SpanningTransformer</code></pre>
            </article>
            
            <article class="function" data-name="makeUpper">
               <h3>
                  makeUpper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeUpper(t language.Tag, o options) transform.SpanningTransformer</code></pre>
            </article>
            
            <article class="function" data-name="newCaseTrie">
               <h3>
                  newCaseTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newCaseTrie(i int) *caseTrie</code></pre>
            </article>
            
            <article class="function" data-name="newCaseTrie">
               <h3>
                  newCaseTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newCaseTrie(i int) *caseTrie</code></pre>
            </article>
            
            <article class="function" data-name="newCaseTrie">
               <h3>
                  newCaseTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newCaseTrie(i int) *caseTrie</code></pre>
            </article>
            
            <article class="function" data-name="newCaseTrie">
               <h3>
                  newCaseTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newCaseTrie(i int) *caseTrie</code></pre>
            </article>
            
            <article class="function" data-name="newCaseTrie">
               <h3>
                  newCaseTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newCaseTrie(i int) *caseTrie</code></pre>
            </article>
            
            <article class="function" data-name="newCaseTrie">
               <h3>
                  newCaseTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newCaseTrie(i int) *caseTrie</code></pre>
            </article>
            
            <article class="function" data-name="next">
               <h3>
                  next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *context) next() bool</code></pre>
            </article>
            
            <article class="function" data-name="nlTitle">
               <h3>
                  nlTitle 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func nlTitle(c *context) bool</code></pre>
            </article>
            
            <article class="function" data-name="nlTitleSpan">
               <h3>
                  nlTitleSpan 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func nlTitleSpan(c *context) bool</code></pre>
            </article>
            
            <article class="function" data-name="noLower">
               <h3>
                  noLower 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func noLower(o options) options</code></pre>
            </article>
            
            <article class="function" data-name="noSpan">
               <h3>
                  noSpan 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func noSpan(c *context) bool</code></pre>
            </article>
            
            <article class="function" data-name="ret">
               <h3>
                  ret 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ret returns the return values for the Transform method. It checks whether
there were insufficient bytes in src to complete and introduces an error
accordingly, if necessary.</p>
               
               <pre><code>func (c *context) ret() (nDst int, nSrc int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="retSpan">
               <h3>
                  retSpan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>retSpan returns the return values for the Span method. It checks whether
there were insufficient bytes in src to complete and introduces an error
accordingly, if necessary.</p>
               
               <pre><code>func (c *context) retSpan() (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="title">
               <h3>
                  title 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>title writes the title case version of the current rune to dst.</p>
               
               <pre><code>func title(c *context) bool</code></pre>
            </article>
            
            <article class="function" data-name="unreadRune">
               <h3>
                  unreadRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>unreadRune causes the last rune read by next to be reread on the next
invocation of next. Only one unreadRune may be called after a call to next.</p>
               
               <pre><code>func (c *context) unreadRune()</code></pre>
            </article>
            
            <article class="function" data-name="upper">
               <h3>
                  upper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>upper writes the uppercase version of the current rune to dst.</p>
               
               <pre><code>func upper(c *context) bool</code></pre>
            </article>
            
            <article class="function" data-name="writeBytes">
               <h3>
                  writeBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeBytes adds bytes to dst.</p>
               
               <pre><code>func (c *context) writeBytes(b []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="writeString">
               <h3>
                  writeString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeString writes the given string to dst.</p>
               
               <pre><code>func (c *context) writeString(s string) bool</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
