<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - cases</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>cases</code>
         </h1>
         <hr />
         
         <article class="global" data-name="maxIgnorable">
            <h2>maxIgnorable</h2>
            <hr />
            
            <p>maxIgnorable defines the maximum number of ignorables to consider for
lookahead operations.</p>
            
            <pre><code>maxIgnorable</code></pre>
         </article>
         
         <article class="global" data-name="supported">
            <h2>supported</h2>
            <hr />
            
            <p>supported lists the language tags for which we have tailorings.</p>
            
            <pre><code>supported</code></pre>
         </article>
         
         <article class="global" data-name="matcher">
            <h2>matcher</h2>
            <hr />
            
            <pre><code>matcher *internal.InheritanceMatcher</code></pre>
         </article>
         
         <article class="global" data-name="Supported">
            <h2>Supported</h2>
            <hr />
            
            <pre><code>Supported language.Coverage</code></pre>
         </article>
         
         <article class="global" data-name="upperFunc">
            <h2>upperFunc</h2>
            <hr />
            
            <p>Some uppercase mappers are stateless, so we can precompute the
Transformers and save a bit on runtime allocations.</p>
            
            <pre><code>upperFunc</code></pre>
         </article>
         
         <article class="global" data-name="undUpper">
            <h2>undUpper</h2>
            <hr />
            
            <pre><code>undUpper transform.SpanningTransformer</code></pre>
         </article>
         
         <article class="global" data-name="undLower">
            <h2>undLower</h2>
            <hr />
            
            <pre><code>undLower transform.SpanningTransformer</code></pre>
         </article>
         
         <article class="global" data-name="undLowerIgnoreSigma">
            <h2>undLowerIgnoreSigma</h2>
            <hr />
            
            <pre><code>undLowerIgnoreSigma transform.SpanningTransformer</code></pre>
         </article>
         
         <article class="global" data-name="lowerFunc">
            <h2>lowerFunc</h2>
            <hr />
            
            <pre><code>lowerFunc</code></pre>
         </article>
         
         <article class="global" data-name="titleInfos">
            <h2>titleInfos</h2>
            <hr />
            
            <pre><code>titleInfos</code></pre>
         </article>
         
         <article class="global" data-name="UnicodeVersion">
            <h2>UnicodeVersion</h2>
            <hr />
            
            <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
            
            <pre><code>UnicodeVersion</code></pre>
         </article>
         
         <article class="global" data-name="xorData">
            <h2>xorData</h2>
            <hr />
            
            <pre><code>xorData string</code></pre>
         </article>
         
         <article class="global" data-name="exceptions">
            <h2>exceptions</h2>
            <hr />
            
            <pre><code>exceptions string</code></pre>
         </article>
         
         <article class="global" data-name="caseValues">
            <h2>caseValues</h2>
            <hr />
            
            <p>caseValues: 20 blocks, 1280 entries, 2560 bytes
The third block is the zero block.</p>
            
            <pre><code>caseValues</code></pre>
         </article>
         
         <article class="global" data-name="caseIndex">
            <h2>caseIndex</h2>
            <hr />
            
            <p>caseIndex: 25 blocks, 1600 entries, 3200 bytes
Block 0 is the zero block.</p>
            
            <pre><code>caseIndex</code></pre>
         </article>
         
         <article class="global" data-name="sparseOffsets">
            <h2>sparseOffsets</h2>
            <hr />
            
            <p>sparseOffsets: 277 entries, 554 bytes</p>
            
            <pre><code>sparseOffsets</code></pre>
         </article>
         
         <article class="global" data-name="sparseValues">
            <h2>sparseValues</h2>
            <hr />
            
            <p>sparseValues: 1395 entries, 5580 bytes</p>
            
            <pre><code>sparseValues</code></pre>
         </article>
         
         <article class="global" data-name="UnicodeVersion">
            <h2>UnicodeVersion</h2>
            <hr />
            
            <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
            
            <pre><code>UnicodeVersion</code></pre>
         </article>
         
         <article class="global" data-name="xorData">
            <h2>xorData</h2>
            <hr />
            
            <pre><code>xorData string</code></pre>
         </article>
         
         <article class="global" data-name="exceptions">
            <h2>exceptions</h2>
            <hr />
            
            <pre><code>exceptions string</code></pre>
         </article>
         
         <article class="global" data-name="caseValues">
            <h2>caseValues</h2>
            <hr />
            
            <p>caseValues: 24 blocks, 1536 entries, 3072 bytes
The third block is the zero block.</p>
            
            <pre><code>caseValues</code></pre>
         </article>
         
         <article class="global" data-name="caseIndex">
            <h2>caseIndex</h2>
            <hr />
            
            <p>caseIndex: 27 blocks, 1728 entries, 3456 bytes
Block 0 is the zero block.</p>
            
            <pre><code>caseIndex</code></pre>
         </article>
         
         <article class="global" data-name="sparseOffsets">
            <h2>sparseOffsets</h2>
            <hr />
            
            <p>sparseOffsets: 312 entries, 624 bytes</p>
            
            <pre><code>sparseOffsets</code></pre>
         </article>
         
         <article class="global" data-name="sparseValues">
            <h2>sparseValues</h2>
            <hr />
            
            <p>sparseValues: 1562 entries, 6248 bytes</p>
            
            <pre><code>sparseValues</code></pre>
         </article>
         
         <article class="global" data-name="UnicodeVersion">
            <h2>UnicodeVersion</h2>
            <hr />
            
            <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
            
            <pre><code>UnicodeVersion</code></pre>
         </article>
         
         <article class="global" data-name="xorData">
            <h2>xorData</h2>
            <hr />
            
            <pre><code>xorData string</code></pre>
         </article>
         
         <article class="global" data-name="exceptions">
            <h2>exceptions</h2>
            <hr />
            
            <pre><code>exceptions string</code></pre>
         </article>
         
         <article class="global" data-name="caseValues">
            <h2>caseValues</h2>
            <hr />
            
            <p>caseValues: 20 blocks, 1280 entries, 2560 bytes
The third block is the zero block.</p>
            
            <pre><code>caseValues</code></pre>
         </article>
         
         <article class="global" data-name="caseIndex">
            <h2>caseIndex</h2>
            <hr />
            
            <p>caseIndex: 25 blocks, 1600 entries, 3200 bytes
Block 0 is the zero block.</p>
            
            <pre><code>caseIndex</code></pre>
         </article>
         
         <article class="global" data-name="sparseOffsets">
            <h2>sparseOffsets</h2>
            <hr />
            
            <p>sparseOffsets: 272 entries, 544 bytes</p>
            
            <pre><code>sparseOffsets</code></pre>
         </article>
         
         <article class="global" data-name="sparseValues">
            <h2>sparseValues</h2>
            <hr />
            
            <p>sparseValues: 1360 entries, 5440 bytes</p>
            
            <pre><code>sparseValues</code></pre>
         </article>
         
         <article class="global" data-name="UnicodeVersion">
            <h2>UnicodeVersion</h2>
            <hr />
            
            <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
            
            <pre><code>UnicodeVersion</code></pre>
         </article>
         
         <article class="global" data-name="xorData">
            <h2>xorData</h2>
            <hr />
            
            <pre><code>xorData string</code></pre>
         </article>
         
         <article class="global" data-name="exceptions">
            <h2>exceptions</h2>
            <hr />
            
            <pre><code>exceptions string</code></pre>
         </article>
         
         <article class="global" data-name="caseValues">
            <h2>caseValues</h2>
            <hr />
            
            <p>caseValues: 22 blocks, 1408 entries, 2816 bytes
The third block is the zero block.</p>
            
            <pre><code>caseValues</code></pre>
         </article>
         
         <article class="global" data-name="caseIndex">
            <h2>caseIndex</h2>
            <hr />
            
            <p>caseIndex: 25 blocks, 1600 entries, 3200 bytes
Block 0 is the zero block.</p>
            
            <pre><code>caseIndex</code></pre>
         </article>
         
         <article class="global" data-name="sparseOffsets">
            <h2>sparseOffsets</h2>
            <hr />
            
            <p>sparseOffsets: 282 entries, 564 bytes</p>
            
            <pre><code>sparseOffsets</code></pre>
         </article>
         
         <article class="global" data-name="sparseValues">
            <h2>sparseValues</h2>
            <hr />
            
            <p>sparseValues: 1418 entries, 5672 bytes</p>
            
            <pre><code>sparseValues</code></pre>
         </article>
         
         <article class="global" data-name="UnicodeVersion">
            <h2>UnicodeVersion</h2>
            <hr />
            
            <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
            
            <pre><code>UnicodeVersion</code></pre>
         </article>
         
         <article class="global" data-name="xorData">
            <h2>xorData</h2>
            <hr />
            
            <pre><code>xorData string</code></pre>
         </article>
         
         <article class="global" data-name="exceptions">
            <h2>exceptions</h2>
            <hr />
            
            <pre><code>exceptions string</code></pre>
         </article>
         
         <article class="global" data-name="caseValues">
            <h2>caseValues</h2>
            <hr />
            
            <p>caseValues: 22 blocks, 1408 entries, 2816 bytes
The third block is the zero block.</p>
            
            <pre><code>caseValues</code></pre>
         </article>
         
         <article class="global" data-name="caseIndex">
            <h2>caseIndex</h2>
            <hr />
            
            <p>caseIndex: 25 blocks, 1600 entries, 3200 bytes
Block 0 is the zero block.</p>
            
            <pre><code>caseIndex</code></pre>
         </article>
         
         <article class="global" data-name="sparseOffsets">
            <h2>sparseOffsets</h2>
            <hr />
            
            <p>sparseOffsets: 289 entries, 578 bytes</p>
            
            <pre><code>sparseOffsets</code></pre>
         </article>
         
         <article class="global" data-name="sparseValues">
            <h2>sparseValues</h2>
            <hr />
            
            <p>sparseValues: 1451 entries, 5804 bytes</p>
            
            <pre><code>sparseValues</code></pre>
         </article>
         
         <article class="global" data-name="UnicodeVersion">
            <h2>UnicodeVersion</h2>
            <hr />
            
            <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
            
            <pre><code>UnicodeVersion</code></pre>
         </article>
         
         <article class="global" data-name="xorData">
            <h2>xorData</h2>
            <hr />
            
            <pre><code>xorData string</code></pre>
         </article>
         
         <article class="global" data-name="exceptions">
            <h2>exceptions</h2>
            <hr />
            
            <pre><code>exceptions string</code></pre>
         </article>
         
         <article class="global" data-name="caseValues">
            <h2>caseValues</h2>
            <hr />
            
            <p>caseValues: 22 blocks, 1408 entries, 2816 bytes
The third block is the zero block.</p>
            
            <pre><code>caseValues</code></pre>
         </article>
         
         <article class="global" data-name="caseIndex">
            <h2>caseIndex</h2>
            <hr />
            
            <p>caseIndex: 25 blocks, 1600 entries, 3200 bytes
Block 0 is the zero block.</p>
            
            <pre><code>caseIndex</code></pre>
         </article>
         
         <article class="global" data-name="sparseOffsets">
            <h2>sparseOffsets</h2>
            <hr />
            
            <p>sparseOffsets: 296 entries, 592 bytes</p>
            
            <pre><code>sparseOffsets</code></pre>
         </article>
         
         <article class="global" data-name="sparseValues">
            <h2>sparseValues</h2>
            <hr />
            
            <p>sparseValues: 1483 entries, 5932 bytes</p>
            
            <pre><code>sparseValues</code></pre>
         </article>
         
         <article class="global" data-name="casedMask">
            <h2>casedMask</h2>
            <hr />
            
            <pre><code>casedMask</code></pre>
         </article>
         
         <article class="global" data-name="fullCasedMask">
            <h2>fullCasedMask</h2>
            <hr />
            
            <pre><code>fullCasedMask</code></pre>
         </article>
         
         <article class="global" data-name="ignorableMask">
            <h2>ignorableMask</h2>
            <hr />
            
            <pre><code>ignorableMask</code></pre>
         </article>
         
         <article class="global" data-name="ignorableValue">
            <h2>ignorableValue</h2>
            <hr />
            
            <pre><code>ignorableValue</code></pre>
         </article>
         
         <article class="global" data-name="inverseFoldBit">
            <h2>inverseFoldBit</h2>
            <hr />
            
            <pre><code>inverseFoldBit</code></pre>
         </article>
         
         <article class="global" data-name="isMidBit">
            <h2>isMidBit</h2>
            <hr />
            
            <pre><code>isMidBit</code></pre>
         </article>
         
         <article class="global" data-name="exceptionBit">
            <h2>exceptionBit</h2>
            <hr />
            
            <pre><code>exceptionBit</code></pre>
         </article>
         
         <article class="global" data-name="exceptionShift">
            <h2>exceptionShift</h2>
            <hr />
            
            <pre><code>exceptionShift</code></pre>
         </article>
         
         <article class="global" data-name="numExceptionBits">
            <h2>numExceptionBits</h2>
            <hr />
            
            <pre><code>numExceptionBits</code></pre>
         </article>
         
         <article class="global" data-name="xorIndexBit">
            <h2>xorIndexBit</h2>
            <hr />
            
            <pre><code>xorIndexBit</code></pre>
         </article>
         
         <article class="global" data-name="xorShift">
            <h2>xorShift</h2>
            <hr />
            
            <pre><code>xorShift</code></pre>
         </article>
         
         <article class="global" data-name="hasMappingMask">
            <h2>hasMappingMask</h2>
            <hr />
            
            <p>There is no mapping if all xor bits and the exception bit are zero.</p>
            
            <pre><code>hasMappingMask</code></pre>
         </article>
         
         <article class="global" data-name="cUncased">
            <h2>cUncased</h2>
            <hr />
            
            <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.

A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
            
            <pre><code>cUncased info</code></pre>
         </article>
         
         <article class="global" data-name="cTitle">
            <h2>cTitle</h2>
            <hr />
            
            <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.

A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
            
            <pre><code>cTitle</code></pre>
         </article>
         
         <article class="global" data-name="cLower">
            <h2>cLower</h2>
            <hr />
            
            <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.

A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
            
            <pre><code>cLower</code></pre>
         </article>
         
         <article class="global" data-name="cUpper">
            <h2>cUpper</h2>
            <hr />
            
            <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.

A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
            
            <pre><code>cUpper</code></pre>
         </article>
         
         <article class="global" data-name="cIgnorableUncased">
            <h2>cIgnorableUncased</h2>
            <hr />
            
            <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.

A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
            
            <pre><code>cIgnorableUncased</code></pre>
         </article>
         
         <article class="global" data-name="cIgnorableCased">
            <h2>cIgnorableCased</h2>
            <hr />
            
            <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.

A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
            
            <pre><code>cIgnorableCased</code></pre>
         </article>
         
         <article class="global" data-name="cXORCase">
            <h2>cXORCase</h2>
            <hr />
            
            <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.

A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
            
            <pre><code>cXORCase</code></pre>
         </article>
         
         <article class="global" data-name="maxCaseMode">
            <h2>maxCaseMode</h2>
            <hr />
            
            <p>The case mode bits encodes the case type of a rune. This includes uncased,
title, upper and lower case and case ignorable. (For a definition of these
terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
cases, a rune can be both cased and case-ignorable. This is encoded by
cIgnorableCased. A rune of this type is always lower case. Some runes are
cased while not having a mapping.

A common pattern for scripts in the Unicode standard is for upper and lower
case runes to alternate for increasing rune values (e.g. the accented Latin
ranges starting from U+0100 and U+1E00 among others and some Cyrillic
characters). We use this property by defining a cXORCase mode, where the case
mode (always upper or lower case) is derived from the rune value. As the XOR
pattern for case mappings is often identical for successive runes, using
cXORCase can result in large series of identical trie values. This, in turn,
allows us to better compress the trie blocks.</p>
            
            <pre><code>maxCaseMode</code></pre>
         </article>
         
         <article class="global" data-name="cccBreak">
            <h2>cccBreak</h2>
            <hr />
            
            <p>The case mapping implementation will need to know about various Canonical
Combining Class (CCC) values. We encode two of these in the trie value:
cccZero (0) and cccAbove (230). If the value is cccOther, it means that
CCC(r) > 0, but not 230. A value of cccBreak means that CCC(r) == 0 and that
the rune also has the break category Break (see below).</p>
            
            <pre><code>cccBreak info</code></pre>
         </article>
         
         <article class="global" data-name="cccZero">
            <h2>cccZero</h2>
            <hr />
            
            <p>The case mapping implementation will need to know about various Canonical
Combining Class (CCC) values. We encode two of these in the trie value:
cccZero (0) and cccAbove (230). If the value is cccOther, it means that
CCC(r) > 0, but not 230. A value of cccBreak means that CCC(r) == 0 and that
the rune also has the break category Break (see below).</p>
            
            <pre><code>cccZero</code></pre>
         </article>
         
         <article class="global" data-name="cccAbove">
            <h2>cccAbove</h2>
            <hr />
            
            <p>The case mapping implementation will need to know about various Canonical
Combining Class (CCC) values. We encode two of these in the trie value:
cccZero (0) and cccAbove (230). If the value is cccOther, it means that
CCC(r) > 0, but not 230. A value of cccBreak means that CCC(r) == 0 and that
the rune also has the break category Break (see below).</p>
            
            <pre><code>cccAbove</code></pre>
         </article>
         
         <article class="global" data-name="cccOther">
            <h2>cccOther</h2>
            <hr />
            
            <p>The case mapping implementation will need to know about various Canonical
Combining Class (CCC) values. We encode two of these in the trie value:
cccZero (0) and cccAbove (230). If the value is cccOther, it means that
CCC(r) > 0, but not 230. A value of cccBreak means that CCC(r) == 0 and that
the rune also has the break category Break (see below).</p>
            
            <pre><code>cccOther</code></pre>
         </article>
         
         <article class="global" data-name="cccMask">
            <h2>cccMask</h2>
            <hr />
            
            <p>The case mapping implementation will need to know about various Canonical
Combining Class (CCC) values. We encode two of these in the trie value:
cccZero (0) and cccAbove (230). If the value is cccOther, it means that
CCC(r) > 0, but not 230. A value of cccBreak means that CCC(r) == 0 and that
the rune also has the break category Break (see below).</p>
            
            <pre><code>cccMask</code></pre>
         </article>
         
         <article class="global" data-name="starter">
            <h2>starter</h2>
            <hr />
            
            <pre><code>starter</code></pre>
         </article>
         
         <article class="global" data-name="above">
            <h2>above</h2>
            <hr />
            
            <pre><code>above</code></pre>
         </article>
         
         <article class="global" data-name="iotaSubscript">
            <h2>iotaSubscript</h2>
            <hr />
            
            <pre><code>iotaSubscript</code></pre>
         </article>
         
         <article class="global" data-name="lengthMask">
            <h2>lengthMask</h2>
            <hr />
            
            <p>The exceptions slice holds data that does not fit in a normal info entry.
The entry is pointed to by the exception index in an entry. It has the
following format:

Header:

	byte 0:
	 7..6  unused
	 5..4  CCC type (same bits as entry)
	    3  unused
	 2..0  length of fold

	byte 1:
	  7..6  unused
	  5..3  length of 1st mapping of case type
	  2..0  length of 2nd mapping of case type

	  case     1st    2nd
	  lower -> upper, title
	  upper -> lower, title
	  title -> lower, upper

Lengths with the value 0x7 indicate no value and implies no change.
A length of 0 indicates a mapping to zero-length string.

Body bytes:

	case folding bytes
	lowercase mapping bytes
	uppercase mapping bytes
	titlecase mapping bytes
	closure mapping bytes (for NFKC_Casefold). (TODO)

Fallbacks:

	missing fold  -> lower
	missing title -> upper
	all missing   -> original rune

exceptions starts with a dummy byte to enforce that there is no zero index
value.</p>
            
            <pre><code>lengthMask</code></pre>
         </article>
         
         <article class="global" data-name="lengthBits">
            <h2>lengthBits</h2>
            <hr />
            
            <p>The exceptions slice holds data that does not fit in a normal info entry.
The entry is pointed to by the exception index in an entry. It has the
following format:

Header:

	byte 0:
	 7..6  unused
	 5..4  CCC type (same bits as entry)
	    3  unused
	 2..0  length of fold

	byte 1:
	  7..6  unused
	  5..3  length of 1st mapping of case type
	  2..0  length of 2nd mapping of case type

	  case     1st    2nd
	  lower -> upper, title
	  upper -> lower, title
	  title -> lower, upper

Lengths with the value 0x7 indicate no value and implies no change.
A length of 0 indicates a mapping to zero-length string.

Body bytes:

	case folding bytes
	lowercase mapping bytes
	uppercase mapping bytes
	titlecase mapping bytes
	closure mapping bytes (for NFKC_Casefold). (TODO)

Fallbacks:

	missing fold  -> lower
	missing title -> upper
	all missing   -> original rune

exceptions starts with a dummy byte to enforce that there is no zero index
value.</p>
            
            <pre><code>lengthBits</code></pre>
         </article>
         
         <article class="global" data-name="noChange">
            <h2>noChange</h2>
            <hr />
            
            <p>The exceptions slice holds data that does not fit in a normal info entry.
The entry is pointed to by the exception index in an entry. It has the
following format:

Header:

	byte 0:
	 7..6  unused
	 5..4  CCC type (same bits as entry)
	    3  unused
	 2..0  length of fold

	byte 1:
	  7..6  unused
	  5..3  length of 1st mapping of case type
	  2..0  length of 2nd mapping of case type

	  case     1st    2nd
	  lower -> upper, title
	  upper -> lower, title
	  title -> lower, upper

Lengths with the value 0x7 indicate no value and implies no change.
A length of 0 indicates a mapping to zero-length string.

Body bytes:

	case folding bytes
	lowercase mapping bytes
	uppercase mapping bytes
	titlecase mapping bytes
	closure mapping bytes (for NFKC_Casefold). (TODO)

Fallbacks:

	missing fold  -> lower
	missing title -> upper
	all missing   -> original rune

exceptions starts with a dummy byte to enforce that there is no zero index
value.</p>
            
            <pre><code>noChange</code></pre>
         </article>
         
         <article class="global" data-name="trie">
            <h2>trie</h2>
            <hr />
            
            <pre><code>trie</code></pre>
         </article>
         
         <article class="global" data-name="sparse">
            <h2>sparse</h2>
            <hr />
            
            <pre><code>sparse</code></pre>
         </article>
         
         <article class="global" data-name="lastRuneForTesting">
            <h2>lastRuneForTesting</h2>
            <hr />
            
            <p>lastRuneForTesting is the last rune used for testing. Everything after this
is boring.</p>
            
            <pre><code>lastRuneForTesting</code></pre>
         </article>
         
         <article class="global" data-name="NoLower">
            <h2>NoLower</h2>
            <hr />
            
            <p>NoLower disables the lowercasing of non-leading letters for a title
caser.</p>
            
            <pre><code>NoLower Option</code></pre>
         </article>
         
         <article class="global" data-name="Compact">
            <h2>Compact</h2>
            <hr />
            
            <p>Compact omits mappings in case folding for characters that would grow the
input. (Unimplemented.)</p>
            
            <pre><code>Compact Option</code></pre>
         </article>
          
         <article class="struct" data-name="undUpperCaser">
            <h2>type undUpperCaser struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">transform.NopResetter</code></pre>
         </article>
         
         <article class="struct" data-name="undLowerIgnoreSigmaCaser">
            <h2>type undLowerIgnoreSigmaCaser struct</h2>
            <hr />
            
            <p>undLowerIgnoreSigmaCaser implements the Transformer interface for doing
a lower case mapping for the root locale (und) ignoring final sigma
handling. This casing algorithm is used in some performance-critical packages
like secure/precis and x/net/http/idna, which warrants its special-casing.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">transform.NopResetter</code></pre>
         </article>
         
         <article class="struct" data-name="simpleCaser">
            <h2>type simpleCaser struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">context
f mapFunc
span spanFunc</code></pre>
         </article>
         
         <article class="struct" data-name="undLowerCaser">
            <h2>type undLowerCaser struct</h2>
            <hr />
            
            <p>undLowerCaser implements the Transformer interface for doing a lower case
mapping for the root locale (und) ignoring final sigma handling. This casing
algorithm is used in some performance-critical packages like secure/precis
and x/net/http/idna, which warrants its special-casing.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">transform.NopResetter</code></pre>
         </article>
         
         <article class="struct" data-name="lowerCaser">
            <h2>type lowerCaser struct</h2>
            <hr />
            
            <p>lowerCaser implements the Transformer interface. The default Unicode lower
casing requires different treatment for the first and subsequent characters
of a word, most notably to handle the Greek final Sigma.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">undLowerIgnoreSigmaCaser
context
first mapFunc
midWord mapFunc</code></pre>
         </article>
         
         <article class="struct" data-name="titleCaser">
            <h2>type titleCaser struct</h2>
            <hr />
            
            <p>titleCaser implements the Transformer interface. Title casing algorithms
distinguish between the first letter of a word and subsequent letters of the
same word. It uses state to avoid requiring a potentially infinite lookahead.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">context
title mapFunc
lower mapFunc
titleSpan spanFunc
rewrite func</code></pre>
         </article>
         
         <article class="struct" data-name="caseTrie">
            <h2>type caseTrie struct</h2>
            <hr />
            
            <p>caseTrie. Total size: 11892 bytes (11.61 KiB). Checksum: c6f15484b7653775.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="caseTrie">
            <h2>type caseTrie struct</h2>
            <hr />
            
            <p>caseTrie. Total size: 13398 bytes (13.08 KiB). Checksum: 544af6e6b1b70931.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="caseTrie">
            <h2>type caseTrie struct</h2>
            <hr />
            
            <p>caseTrie. Total size: 11742 bytes (11.47 KiB). Checksum: 795fe57ee5135873.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="caseTrie">
            <h2>type caseTrie struct</h2>
            <hr />
            
            <p>caseTrie. Total size: 12250 bytes (11.96 KiB). Checksum: 53ff6cb7321675e1.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="caseTrie">
            <h2>type caseTrie struct</h2>
            <hr />
            
            <p>caseTrie. Total size: 12396 bytes (12.11 KiB). Checksum: c0656238384c3da1.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="caseTrie">
            <h2>type caseTrie struct</h2>
            <hr />
            
            <p>caseTrie. Total size: 12538 bytes (12.24 KiB). Checksum: af4dfa7d60c71d4c.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="valueRange">
            <h2>type valueRange struct</h2>
            <hr />
            
            <p>valueRange is an entry in a sparse block.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">value uint16
lo byte
hi byte</code></pre>
         </article>
         
         <article class="struct" data-name="sparseBlocks">
            <h2>type sparseBlocks struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">values []valueRange
offsets []uint16</code></pre>
         </article>
         
         <article class="struct" data-name="Caser">
            <h2>type Caser struct</h2>
            <hr />
            
            <p>A Caser transforms given input to a certain case. It implements
transform.Transformer.

A Caser may be stateful and should therefore not be shared between
goroutines.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">t transform.SpanningTransformer</code></pre>
         </article>
         
         <article class="struct" data-name="options">
            <h2>type options struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">noLower bool
simple bool
ignoreFinalSigma bool</code></pre>
         </article>
         
         <article class="struct" data-name="context">
            <h2>type context struct</h2>
            <hr />
            
            <p>A context is used for iterating over source bytes, fetching case info and
writing to a destination buffer.

Casing operations may need more than one rune of context to decide how a rune
should be cased. Casing implementations should call checkpoint on context
whenever it is known to be safe to return the runes processed so far.

It is recommended for implementations to not allow for more than 30 case
ignorables as lookahead (analogous to the limit in norm) and to use state if
unbounded lookahead is needed for cased runes.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">dst []byte
src []byte
atEOF bool
pDst int
pSrc int
nDst int
nSrc int
err error
sz int
info info
isMidWord bool</code></pre>
         </article>
         
         <article class="struct" data-name="caseFolder">
            <h2>type caseFolder struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">transform.NopResetter</code></pre>
         </article>
          
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="makeUpper">
            <h2>makeUpper</h2>
            <hr />
            
            <pre><code>func makeUpper(t language.Tag, o options) transform.SpanningTransformer</code></pre>
         </article>
         
         <article class="function" data-name="makeLower">
            <h2>makeLower</h2>
            <hr />
            
            <pre><code>func makeLower(t language.Tag, o options) transform.SpanningTransformer</code></pre>
         </article>
         
         <article class="function" data-name="makeTitle">
            <h2>makeTitle</h2>
            <hr />
            
            <pre><code>func makeTitle(t language.Tag, o options) transform.SpanningTransformer</code></pre>
         </article>
         
         <article class="function" data-name="noSpan">
            <h2>noSpan</h2>
            <hr />
            
            <pre><code>func noSpan(c *context) bool</code></pre>
         </article>
         
         <article class="function" data-name="Transform">
            <h2>Transform</h2>
            <hr />
            
            <p>undUpperCaser implements the Transformer interface for doing an upper case
mapping for the root locale (und). It eliminates the need for an allocation
as it prevents escaping by not using function pointers.</p>
            
            <pre><code>func Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Span">
            <h2>Span</h2>
            <hr />
            
            <pre><code>func Span(src []byte, atEOF bool) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Transform">
            <h2>Transform</h2>
            <hr />
            
            <pre><code>func Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Span">
            <h2>Span</h2>
            <hr />
            
            <p>Span implements a generic lower-casing. This is possible as isLower works
for all lowercasing variants. All lowercase variants only vary in how they
transform a non-lowercase letter. They will never change an already lowercase
letter. In addition, there is no state.</p>
            
            <pre><code>func Span(src []byte, atEOF bool) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Transform">
            <h2>Transform</h2>
            <hr />
            
            <p>simpleCaser implements the Transformer interface for doing a case operation
on a rune-by-rune basis.</p>
            
            <pre><code>func Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Span">
            <h2>Span</h2>
            <hr />
            
            <pre><code>func Span(src []byte, atEOF bool) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Transform">
            <h2>Transform</h2>
            <hr />
            
            <pre><code>func Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Span">
            <h2>Span</h2>
            <hr />
            
            <pre><code>func Span(src []byte, atEOF bool) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Transform">
            <h2>Transform</h2>
            <hr />
            
            <pre><code>func Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Transform">
            <h2>Transform</h2>
            <hr />
            
            <p>Transform implements the standard Unicode title case algorithm as defined in
Chapter 3 of The Unicode Standard:
toTitlecase(X): Find the word boundaries in X according to Unicode Standard
Annex #29, "Unicode Text Segmentation." For each word boundary, find the
first cased character F following the word boundary. If F exists, map F to
Titlecase_Mapping(F); then map all characters C between F and the following
word boundary to Lowercase_Mapping(C).</p>
            
            <pre><code>func Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Span">
            <h2>Span</h2>
            <hr />
            
            <pre><code>func Span(src []byte, atEOF bool) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="finalSigma">
            <h2>finalSigma</h2>
            <hr />
            
            <p>finalSigma adds Greek final Sigma handing to another casing function. It
determines whether a lowercased sigma should be σ or ς, by looking ahead for
case-ignorables and a cased letters.</p>
            
            <pre><code>func finalSigma(f mapFunc) mapFunc</code></pre>
         </article>
         
         <article class="function" data-name="finalSigmaBody">
            <h2>finalSigmaBody</h2>
            <hr />
            
            <pre><code>func finalSigmaBody(c *context) bool</code></pre>
         </article>
         
         <article class="function" data-name="elUpper">
            <h2>elUpper</h2>
            <hr />
            
            <p>elUpper implements Greek upper casing, which entails removing a predefined
set of non-blocked modifiers. Note that these accents should not be removed
for title casing!
Example: "Οδός" -> "ΟΔΟΣ".</p>
            
            <pre><code>func elUpper(c *context) bool</code></pre>
         </article>
         
         <article class="function" data-name="ltLower">
            <h2>ltLower</h2>
            <hr />
            
            <pre><code>func ltLower(c *context) bool</code></pre>
         </article>
         
         <article class="function" data-name="ltUpper">
            <h2>ltUpper</h2>
            <hr />
            
            <pre><code>func ltUpper(f mapFunc) mapFunc</code></pre>
         </article>
         
         <article class="function" data-name="aztrUpper">
            <h2>aztrUpper</h2>
            <hr />
            
            <pre><code>func aztrUpper(f mapFunc) mapFunc</code></pre>
         </article>
         
         <article class="function" data-name="aztrLower">
            <h2>aztrLower</h2>
            <hr />
            
            <pre><code>func aztrLower(c *context) done bool</code></pre>
         </article>
         
         <article class="function" data-name="nlTitle">
            <h2>nlTitle</h2>
            <hr />
            
            <pre><code>func nlTitle(c *context) bool</code></pre>
         </article>
         
         <article class="function" data-name="nlTitleSpan">
            <h2>nlTitleSpan</h2>
            <hr />
            
            <pre><code>func nlTitleSpan(c *context) bool</code></pre>
         </article>
         
         <article class="function" data-name="afnlRewrite">
            <h2>afnlRewrite</h2>
            <hr />
            
            <p>Not part of CLDR, but see https://unicode.org/cldr/trac/ticket/7078.</p>
            
            <pre><code>func afnlRewrite(c *context)</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newCaseTrie">
            <h2>newCaseTrie</h2>
            <hr />
            
            <pre><code>func newCaseTrie(i int) *caseTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newCaseTrie">
            <h2>newCaseTrie</h2>
            <hr />
            
            <pre><code>func newCaseTrie(i int) *caseTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newCaseTrie">
            <h2>newCaseTrie</h2>
            <hr />
            
            <pre><code>func newCaseTrie(i int) *caseTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="doICU">
            <h2>doICU</h2>
            <hr />
            
            <pre><code>func doICU(tag string, caser string, input string) string</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newCaseTrie">
            <h2>newCaseTrie</h2>
            <hr />
            
            <pre><code>func newCaseTrie(i int) *caseTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newCaseTrie">
            <h2>newCaseTrie</h2>
            <hr />
            
            <pre><code>func newCaseTrie(i int) *caseTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint16, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint16</code></pre>
         </article>
         
         <article class="function" data-name="newCaseTrie">
            <h2>newCaseTrie</h2>
            <hr />
            
            <pre><code>func newCaseTrie(i int) *caseTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="isCased">
            <h2>isCased</h2>
            <hr />
            
            <pre><code>func isCased() bool</code></pre>
         </article>
         
         <article class="function" data-name="isCaseIgnorable">
            <h2>isCaseIgnorable</h2>
            <hr />
            
            <pre><code>func isCaseIgnorable() bool</code></pre>
         </article>
         
         <article class="function" data-name="isNotCasedAndNotCaseIgnorable">
            <h2>isNotCasedAndNotCaseIgnorable</h2>
            <hr />
            
            <pre><code>func isNotCasedAndNotCaseIgnorable() bool</code></pre>
         </article>
         
         <article class="function" data-name="isCaseIgnorableAndNotCased">
            <h2>isCaseIgnorableAndNotCased</h2>
            <hr />
            
            <pre><code>func isCaseIgnorableAndNotCased() bool</code></pre>
         </article>
         
         <article class="function" data-name="isMid">
            <h2>isMid</h2>
            <hr />
            
            <pre><code>func isMid() bool</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the value from values block n for byte b using binary search.</p>
            
            <pre><code>func lookup(n uint32, b byte) uint16</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <p>Bytes returns a new byte slice with the result of converting b to the case
form implemented by c.</p>
            
            <pre><code>func Bytes(b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns a string with the result of transforming s to the case form
implemented by c.</p>
            
            <pre><code>func String(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="Reset">
            <h2>Reset</h2>
            <hr />
            
            <p>Reset resets the Caser to be reused for new input after a previous call to
Transform.</p>
            
            <pre><code>func Reset()</code></pre>
         </article>
         
         <article class="function" data-name="Transform">
            <h2>Transform</h2>
            <hr />
            
            <p>Transform implements the transform.Transformer interface and transforms the
given input to the case form implemented by c.</p>
            
            <pre><code>func Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Span">
            <h2>Span</h2>
            <hr />
            
            <p>Span implements the transform.SpanningTransformer interface.</p>
            
            <pre><code>func Span(src []byte, atEOF bool) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Upper">
            <h2>Upper</h2>
            <hr />
            
            <p>Upper returns a Caser for language-specific uppercasing.</p>
            
            <pre><code>func Upper(t language.Tag, opts ...Option) Caser</code></pre>
         </article>
         
         <article class="function" data-name="Lower">
            <h2>Lower</h2>
            <hr />
            
            <p>Lower returns a Caser for language-specific lowercasing.</p>
            
            <pre><code>func Lower(t language.Tag, opts ...Option) Caser</code></pre>
         </article>
         
         <article class="function" data-name="Title">
            <h2>Title</h2>
            <hr />
            
            <p>Title returns a Caser for language-specific title casing. It uses an
approximation of the default Unicode Word Break algorithm.</p>
            
            <pre><code>func Title(t language.Tag, opts ...Option) Caser</code></pre>
         </article>
         
         <article class="function" data-name="Fold">
            <h2>Fold</h2>
            <hr />
            
            <p>Fold returns a Caser that implements Unicode case folding. The returned Caser
is stateless and safe to use concurrently by multiple goroutines.

Case folding does not normalize the input and may not preserve a normal form.
Use the collate or search package for more convenient and linguistically
sound comparisons. Use golang.org/x/text/secure/precis for string comparisons
where security aspects are a concern.</p>
            
            <pre><code>func Fold(opts ...Option) Caser</code></pre>
         </article>
         
         <article class="function" data-name="getOpts">
            <h2>getOpts</h2>
            <hr />
            
            <pre><code>func getOpts(o ...Option) res options</code></pre>
         </article>
         
         <article class="function" data-name="noLower">
            <h2>noLower</h2>
            <hr />
            
            <pre><code>func noLower(o options) options</code></pre>
         </article>
         
         <article class="function" data-name="compact">
            <h2>compact</h2>
            <hr />
            
            <pre><code>func compact(o options) options</code></pre>
         </article>
         
         <article class="function" data-name="HandleFinalSigma">
            <h2>HandleFinalSigma</h2>
            <hr />
            
            <p>HandleFinalSigma specifies whether the special handling of Greek final sigma
should be enabled. Unicode prescribes handling the Greek final sigma for all
locales, but standards like IDNA and PRECIS override this default.</p>
            
            <pre><code>func HandleFinalSigma(enable bool) Option</code></pre>
         </article>
         
         <article class="function" data-name="ignoreFinalSigma">
            <h2>ignoreFinalSigma</h2>
            <hr />
            
            <pre><code>func ignoreFinalSigma(o options) options</code></pre>
         </article>
         
         <article class="function" data-name="handleFinalSigma">
            <h2>handleFinalSigma</h2>
            <hr />
            
            <pre><code>func handleFinalSigma(o options) options</code></pre>
         </article>
         
         <article class="function" data-name="Reset">
            <h2>Reset</h2>
            <hr />
            
            <pre><code>func Reset()</code></pre>
         </article>
         
         <article class="function" data-name="ret">
            <h2>ret</h2>
            <hr />
            
            <p>ret returns the return values for the Transform method. It checks whether
there were insufficient bytes in src to complete and introduces an error
accordingly, if necessary.</p>
            
            <pre><code>func ret() (nDst int, nSrc int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="retSpan">
            <h2>retSpan</h2>
            <hr />
            
            <p>retSpan returns the return values for the Span method. It checks whether
there were insufficient bytes in src to complete and introduces an error
accordingly, if necessary.</p>
            
            <pre><code>func retSpan() (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="checkpoint">
            <h2>checkpoint</h2>
            <hr />
            
            <p>checkpoint sets the return value buffer points for Transform to the current
positions.</p>
            
            <pre><code>func checkpoint()</code></pre>
         </article>
         
         <article class="function" data-name="unreadRune">
            <h2>unreadRune</h2>
            <hr />
            
            <p>unreadRune causes the last rune read by next to be reread on the next
invocation of next. Only one unreadRune may be called after a call to next.</p>
            
            <pre><code>func unreadRune()</code></pre>
         </article>
         
         <article class="function" data-name="next">
            <h2>next</h2>
            <hr />
            
            <pre><code>func next() bool</code></pre>
         </article>
         
         <article class="function" data-name="writeBytes">
            <h2>writeBytes</h2>
            <hr />
            
            <p>writeBytes adds bytes to dst.</p>
            
            <pre><code>func writeBytes(b []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="writeString">
            <h2>writeString</h2>
            <hr />
            
            <p>writeString writes the given string to dst.</p>
            
            <pre><code>func writeString(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="copy">
            <h2>copy</h2>
            <hr />
            
            <p>copy writes the current rune to dst.</p>
            
            <pre><code>func copy() bool</code></pre>
         </article>
         
         <article class="function" data-name="copyXOR">
            <h2>copyXOR</h2>
            <hr />
            
            <p>copyXOR copies the current rune to dst and modifies it by applying the XOR
pattern of the case info. It is the responsibility of the caller to ensure
that this is a rune with a XOR pattern defined.</p>
            
            <pre><code>func copyXOR() bool</code></pre>
         </article>
         
         <article class="function" data-name="hasPrefix">
            <h2>hasPrefix</h2>
            <hr />
            
            <p>hasPrefix returns true if src[pSrc:] starts with the given string.</p>
            
            <pre><code>func hasPrefix(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="caseType">
            <h2>caseType</h2>
            <hr />
            
            <p>caseType returns an info with only the case bits, normalized to either
cLower, cUpper, cTitle or cUncased.</p>
            
            <pre><code>func caseType() info</code></pre>
         </article>
         
         <article class="function" data-name="lower">
            <h2>lower</h2>
            <hr />
            
            <p>lower writes the lowercase version of the current rune to dst.</p>
            
            <pre><code>func lower(c *context) bool</code></pre>
         </article>
         
         <article class="function" data-name="isLower">
            <h2>isLower</h2>
            <hr />
            
            <pre><code>func isLower(c *context) bool</code></pre>
         </article>
         
         <article class="function" data-name="upper">
            <h2>upper</h2>
            <hr />
            
            <p>upper writes the uppercase version of the current rune to dst.</p>
            
            <pre><code>func upper(c *context) bool</code></pre>
         </article>
         
         <article class="function" data-name="isUpper">
            <h2>isUpper</h2>
            <hr />
            
            <p>isUpper writes the isUppercase version of the current rune to dst.</p>
            
            <pre><code>func isUpper(c *context) bool</code></pre>
         </article>
         
         <article class="function" data-name="title">
            <h2>title</h2>
            <hr />
            
            <p>title writes the title case version of the current rune to dst.</p>
            
            <pre><code>func title(c *context) bool</code></pre>
         </article>
         
         <article class="function" data-name="isTitle">
            <h2>isTitle</h2>
            <hr />
            
            <p>isTitle reports whether the current rune is in title case.</p>
            
            <pre><code>func isTitle(c *context) bool</code></pre>
         </article>
         
         <article class="function" data-name="foldFull">
            <h2>foldFull</h2>
            <hr />
            
            <p>foldFull writes the foldFull version of the current rune to dst.</p>
            
            <pre><code>func foldFull(c *context) bool</code></pre>
         </article>
         
         <article class="function" data-name="isFoldFull">
            <h2>isFoldFull</h2>
            <hr />
            
            <p>isFoldFull reports whether the current run is mapped to foldFull</p>
            
            <pre><code>func isFoldFull(c *context) bool</code></pre>
         </article>
         
         <article class="function" data-name="Transform">
            <h2>Transform</h2>
            <hr />
            
            <p>caseFolder implements the Transformer interface for doing case folding.</p>
            
            <pre><code>func Transform(dst []byte, src []byte, atEOF bool) (nDst int, nSrc int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Span">
            <h2>Span</h2>
            <hr />
            
            <pre><code>func Span(src []byte, atEOF bool) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="makeFold">
            <h2>makeFold</h2>
            <hr />
            
            <pre><code>func makeFold(o options) transform.SpanningTransformer</code></pre>
         </article>
         
         <article class="function" data-name="cccVal">
            <h2>cccVal</h2>
            <hr />
            
            <pre><code>func cccVal() info</code></pre>
         </article>
         
         <article class="function" data-name="cccType">
            <h2>cccType</h2>
            <hr />
            
            <pre><code>func cccType() info</code></pre>
         </article>
         
         <article class="function" data-name="isBreak">
            <h2>isBreak</h2>
            <hr />
            
            <p>isBreak returns whether this rune should introduce a break.</p>
            
            <pre><code>func isBreak() bool</code></pre>
         </article>
         
         <article class="function" data-name="isLetter">
            <h2>isLetter</h2>
            <hr />
            
            <p>isLetter returns whether the rune is of break type ALetter, Hebrew_Letter,
Numeric, ExtendNumLet, or Extend.</p>
            
            <pre><code>func isLetter() bool</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
