<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - lex</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>lex</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"text/scanner"
"cmd/internal/src"
"go/build/constraint"
"io"
"os"
"strings"
"text/scanner"
"unicode"
"cmd/asm/internal/flags"
"cmd/internal/objabi"
"cmd/internal/src"
"fmt"
"os"
"path/filepath"
"slices"
"strconv"
"strings"
"text/scanner"
"cmd/asm/internal/flags"
"cmd/internal/objabi"
"cmd/internal/src"
"fmt"
"log"
"os"
"strings"
"text/scanner"
"cmd/internal/src"
"text/scanner"
"cmd/internal/src"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="ARR">
               <h3>
                  ARR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ARR</code></pre>
            </article>
            
            <article class="global" data-name="BuildComment">
               <h3>
                  BuildComment 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const BuildComment</code></pre>
            </article>
            
            <article class="global" data-name="Include">
               <h3>
                  Include 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Include</code></pre>
            </article>
            
            <article class="global" data-name="LSH">
               <h3>
                  LSH 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Asm defines some two-character lexemes. We make up
a rune/ScanToken value for them - ugly but simple.</p>
               
               <pre><code>const LSH ScanToken = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="ROT">
               <h3>
                  ROT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ROT</code></pre>
            </article>
            
            <article class="global" data-name="RSH">
               <h3>
                  RSH 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const RSH</code></pre>
            </article>
            
            <article class="global" data-name="macroName">
               <h3>
                  macroName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const macroName</code></pre>
            </article>
            
            <article class="global" data-name="panicOnError">
               <h3>
                  panicOnError 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var panicOnError bool</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="ScanToken">
               <h3>
                  ScanToken
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A ScanToken represents an input item. It is a simple wrapping of rune, as
returned by text/scanner.Scanner, plus a couple of extra values.</p>
               
               <pre><code>type ScanToken rune</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="TokenReader">
               <h3>
                  TokenReader
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A TokenReader is like a reader, but returns lex tokens of type Token. It also can tell you what
the text of the most recently returned token is, and where it was found.
The underlying scanner elides all spaces except newline, so the input looks like a stream of
Tokens; original spacing is lost but we don't need it.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type TokenReader interface {
Next() ScanToken
Text() string
File() string
Base() *src.PosBase
SetBase(*src.PosBase)
Line() int
Col() int
Close()
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Input">
               <h3>
                  Input
                  <span class="badge">struct</span>
               </h3>
               
               <p>Input is the main input: a stack of readers and some macro definitions.
It also handles #include processing (by pushing onto the input stack)
and parses and instantiates macro definitions.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Input struct {
Stack
includes []string
beginningOfLine bool
ifdefStack []bool
macros map[string]*Macro
text string
peek bool
peekToken ScanToken
peekText string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Macro">
               <h3>
                  Macro
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Macro represents the definition of a #defined macro.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Macro struct {
name string
args []string
tokens []Token
}</code></pre>
            </article>
            
            <article class="struct" data-name="Slice">
               <h3>
                  Slice
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Slice reads from a slice of Tokens.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Slice struct {
tokens []Token
base *src.PosBase
line int
pos int
}</code></pre>
            </article>
            
            <article class="struct" data-name="Stack">
               <h3>
                  Stack
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Stack is a stack of TokenReaders. As the top TokenReader hits EOF,
it resumes reading the next one down.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Stack struct {
tr []TokenReader
}</code></pre>
            </article>
            
            <article class="struct" data-name="Token">
               <h3>
                  Token
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Token is a scan token plus its string value.
A macro is stored as a sequence of Tokens with spaces stripped.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Token struct {
ScanToken
text string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Tokenizer">
               <h3>
                  Tokenizer
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Tokenizer is a simple wrapping of text/scanner.Scanner, configured
for our purposes and made a TokenReader. It forms the lowest level,
turning text from readers into tokens.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Tokenizer struct {
tok ScanToken
s *scanner.Scanner
base *src.PosBase
line int
file *os.File
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Base">
               <h3>
                  Base 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Stack) Base() *src.PosBase</code></pre>
            </article>
            
            <article class="function" data-name="Base">
               <h3>
                  Base 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Slice) Base() *src.PosBase</code></pre>
            </article>
            
            <article class="function" data-name="Base">
               <h3>
                  Base 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tokenizer) Base() *src.PosBase</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Slice) Close()</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tokenizer) Close()</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Stack) Close()</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *Input) Close()</code></pre>
            </article>
            
            <article class="function" data-name="Col">
               <h3>
                  Col 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Slice) Col() int</code></pre>
            </article>
            
            <article class="function" data-name="Col">
               <h3>
                  Col 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tokenizer) Col() int</code></pre>
            </article>
            
            <article class="function" data-name="Col">
               <h3>
                  Col 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Stack) Col() int</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *Input) Error(args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="File">
               <h3>
                  File 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Slice) File() string</code></pre>
            </article>
            
            <article class="function" data-name="File">
               <h3>
                  File 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tokenizer) File() string</code></pre>
            </article>
            
            <article class="function" data-name="File">
               <h3>
                  File 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Stack) File() string</code></pre>
            </article>
            
            <article class="function" data-name="IsRegisterShift">
               <h3>
                  IsRegisterShift 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsRegisterShift reports whether the token is one of the ARM register shift operators.</p>
               
               <pre><code>func IsRegisterShift(r ScanToken) bool</code></pre>
            </article>
            
            <article class="function" data-name="Line">
               <h3>
                  Line 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tokenizer) Line() int</code></pre>
            </article>
            
            <article class="function" data-name="Line">
               <h3>
                  Line 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Slice) Line() int</code></pre>
            </article>
            
            <article class="function" data-name="Line">
               <h3>
                  Line 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Stack) Line() int</code></pre>
            </article>
            
            <article class="function" data-name="Make">
               <h3>
                  Make 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Make returns a Token with the given rune (ScanToken) and text representation.</p>
               
               <pre><code>func Make(token ScanToken, text string) Token</code></pre>
            </article>
            
            <article class="function" data-name="NewInput">
               <h3>
                  NewInput 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewInput returns an Input from the given path.</p>
               
               <pre><code>func NewInput(name string) *Input</code></pre>
            </article>
            
            <article class="function" data-name="NewLexer">
               <h3>
                  NewLexer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewLexer returns a lexer for the named file and the given link context.</p>
               
               <pre><code>func NewLexer(name string) TokenReader</code></pre>
            </article>
            
            <article class="function" data-name="NewSlice">
               <h3>
                  NewSlice 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewSlice(base *src.PosBase, line int, tokens []Token) *Slice</code></pre>
            </article>
            
            <article class="function" data-name="NewTokenizer">
               <h3>
                  NewTokenizer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewTokenizer(name string, r io.Reader, file *os.File) *Tokenizer</code></pre>
            </article>
            
            <article class="function" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Stack) Next() ScanToken</code></pre>
            </article>
            
            <article class="function" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *Input) Next() ScanToken</code></pre>
            </article>
            
            <article class="function" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Slice) Next() ScanToken</code></pre>
            </article>
            
            <article class="function" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tokenizer) Next() ScanToken</code></pre>
            </article>
            
            <article class="function" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Push adds tr to the top (end) of the input stack. (Popping happens automatically.)</p>
               
               <pre><code>func (s *Stack) Push(tr TokenReader)</code></pre>
            </article>
            
            <article class="function" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *Input) Push(r TokenReader)</code></pre>
            </article>
            
            <article class="function" data-name="SetBase">
               <h3>
                  SetBase 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Slice) SetBase(base *src.PosBase)</code></pre>
            </article>
            
            <article class="function" data-name="SetBase">
               <h3>
                  SetBase 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Stack) SetBase(base *src.PosBase)</code></pre>
            </article>
            
            <article class="function" data-name="SetBase">
               <h3>
                  SetBase 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tokenizer) SetBase(base *src.PosBase)</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l Token) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t ScanToken) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Text">
               <h3>
                  Text 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *Input) Text() string</code></pre>
            </article>
            
            <article class="function" data-name="Text">
               <h3>
                  Text 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Slice) Text() string</code></pre>
            </article>
            
            <article class="function" data-name="Text">
               <h3>
                  Text 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tokenizer) Text() string</code></pre>
            </article>
            
            <article class="function" data-name="Text">
               <h3>
                  Text 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Stack) Text() string</code></pre>
            </article>
            
            <article class="function" data-name="Tokenize">
               <h3>
                  Tokenize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Tokenize turns a string into a list of Tokens; used to parse the -D flag and in tests.</p>
               
               <pre><code>func Tokenize(str string) []Token</code></pre>
            </article>
            
            <article class="function" data-name="argsFor">
               <h3>
                  argsFor 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>argsFor returns a map from formal name to actual value for this argumented macro invocation.
The opening parenthesis has been absorbed.</p>
               
               <pre><code>func (in *Input) argsFor(macro *Macro) map[string][]Token</code></pre>
            </article>
            
            <article class="function" data-name="collectArgument">
               <h3>
                  collectArgument 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>collectArgument returns the actual tokens for a single argument of a macro.
It also returns the token that terminated the argument, which will always
be either ',' or ')'. The starting '(' has been scanned.</p>
               
               <pre><code>func (in *Input) collectArgument(macro *Macro) ([]Token, ScanToken)</code></pre>
            </article>
            
            <article class="function" data-name="define">
               <h3>
                  define 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>#define processing.</p>
               
               <pre><code>func (in *Input) define()</code></pre>
            </article>
            
            <article class="function" data-name="defineMacro">
               <h3>
                  defineMacro 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>defineMacro stores the macro definition in the Input.</p>
               
               <pre><code>func (in *Input) defineMacro(name string, args []string, tokens []Token)</code></pre>
            </article>
            
            <article class="function" data-name="else_">
               <h3>
                  else_ 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>#else processing</p>
               
               <pre><code>func (in *Input) else_()</code></pre>
            </article>
            
            <article class="function" data-name="enabled">
               <h3>
                  enabled 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>enabled reports whether the input is enabled by an ifdef, or is at the top level.</p>
               
               <pre><code>func (in *Input) enabled() bool</code></pre>
            </article>
            
            <article class="function" data-name="endif">
               <h3>
                  endif 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>#endif processing.</p>
               
               <pre><code>func (in *Input) endif()</code></pre>
            </article>
            
            <article class="function" data-name="expectNewline">
               <h3>
                  expectNewline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *Input) expectNewline(directive string)</code></pre>
            </article>
            
            <article class="function" data-name="expectText">
               <h3>
                  expectText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>expectText is like Error but adds "got XXX" where XXX is a quoted representation of the most recent token.</p>
               
               <pre><code>func (in *Input) expectText(args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="hash">
               <h3>
                  hash 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>hash processes a # preprocessor directive. It reports whether it completes.</p>
               
               <pre><code>func (in *Input) hash() bool</code></pre>
            </article>
            
            <article class="function" data-name="ifdef">
               <h3>
                  ifdef 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>#ifdef and #ifndef processing.</p>
               
               <pre><code>func (in *Input) ifdef(truth bool)</code></pre>
            </article>
            
            <article class="function" data-name="include">
               <h3>
                  include 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>#include processing.</p>
               
               <pre><code>func (in *Input) include()</code></pre>
            </article>
            
            <article class="function" data-name="invokeMacro">
               <h3>
                  invokeMacro 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>invokeMacro pushes onto the input Stack a Slice that holds the macro definition with the actual
parameters substituted for the formals.
Invoking a macro does not touch the PC/line history.</p>
               
               <pre><code>func (in *Input) invokeMacro(macro *Macro)</code></pre>
            </article>
            
            <article class="function" data-name="isIdentRune">
               <h3>
                  isIdentRune 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>We want center dot (·) and division slash (∕) to work as identifier characters.</p>
               
               <pre><code>func isIdentRune(ch rune, i int) bool</code></pre>
            </article>
            
            <article class="function" data-name="line">
               <h3>
                  line 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>#line processing.</p>
               
               <pre><code>func (in *Input) line()</code></pre>
            </article>
            
            <article class="function" data-name="macroDefinition">
               <h3>
                  macroDefinition 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>macroDefinition returns the list of formals and the tokens of the definition.
The argument list is nil for no parens on the definition; otherwise a list of
formal argument names.</p>
               
               <pre><code>func (in *Input) macroDefinition(name string) ([]string, []Token)</code></pre>
            </article>
            
            <article class="function" data-name="macroName">
               <h3>
                  macroName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>macroName returns the name for the macro being referenced.</p>
               
               <pre><code>func (in *Input) macroName() string</code></pre>
            </article>
            
            <article class="function" data-name="predefine">
               <h3>
                  predefine 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>predefine installs the macros set by the -D flag on the command line.</p>
               
               <pre><code>func predefine(defines flags.MultiFlag) map[string]*Macro</code></pre>
            </article>
            
            <article class="function" data-name="undef">
               <h3>
                  undef 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>#undef processing</p>
               
               <pre><code>func (in *Input) undef()</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
