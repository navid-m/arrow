<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>cache - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>cache</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"fmt"
"os"
"path/filepath"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"bytes"
"crypto/sha256"
"fmt"
"hash"
"io"
"os"
"runtime"
"strings"
"sync"
"bufio"
"cmd/go/internal/base"
"cmd/go/internal/cacheprog"
"cmd/internal/quoted"
"context"
"crypto/sha256"
"encoding/base64"
"encoding/json"
"errors"
"fmt"
"internal/goexperiment"
"io"
"log"
"os"
"os/exec"
"sync"
"sync/atomic"
"time"
"bytes"
"crypto/sha256"
"encoding/hex"
"errors"
"fmt"
"internal/godebug"
"io"
"io/fs"
"os"
"path/filepath"
"strconv"
"strings"
"time"
"cmd/go/internal/base"
"cmd/go/internal/lockedfile"
"cmd/go/internal/mmap"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="DebugTest" data-name="DebugTest">
               <h3>
                  DebugTest 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#DebugTest" class="anchor" title="Link to DebugTest">#</a>
               </h3>
               
                  <p class="doc-comment">DebugTest is set when GODEBUG=gocachetest=1 is in the environment.</p>
               
               <pre><code class="language-go">var DebugTest = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="HashSize" data-name="HashSize">
               <h3>
                  HashSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#HashSize" class="anchor" title="Link to HashSize">#</a>
               </h3>
               
                  <p class="doc-comment">HashSize is the number of bytes in a hash.</p>
               
               <pre><code class="language-go">const HashSize = 32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cacheREADME" data-name="cacheREADME">
               <h3>
                  cacheREADME 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#cacheREADME" class="anchor" title="Link to cacheREADME">#</a>
               </h3>
               
                  <p class="doc-comment">cacheREADME is a message stored in a README in the cache directory.
Because the cache lives outside the normal Go trees, we leave the
README as a courtesy to explain where it came from.</p>
               
               <pre><code class="language-go">const cacheREADME = `This directory holds cached build artifacts from the Go build system.
Run "go clean -cache" if the directory is getting too large.
Run "go clean -fuzzcache" to delete the fuzz cache.
See golang.org to learn more about Go.
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugHash" data-name="debugHash">
               <h3>
                  debugHash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#debugHash" class="anchor" title="Link to debugHash">#</a>
               </h3>
               
               <pre><code class="language-go">var debugHash = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultDir" data-name="defaultDir">
               <h3>
                  defaultDir 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#defaultDir" class="anchor" title="Link to defaultDir">#</a>
               </h3>
               
               <pre><code class="language-go">var defaultDir string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultDirChanged" data-name="defaultDirChanged">
               <h3>
                  defaultDirChanged 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#defaultDirChanged" class="anchor" title="Link to defaultDirChanged">#</a>
               </h3>
               
               <pre><code class="language-go">var defaultDirChanged bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultDirErr" data-name="defaultDirErr">
               <h3>
                  defaultDirErr 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#defaultDirErr" class="anchor" title="Link to defaultDirErr">#</a>
               </h3>
               
               <pre><code class="language-go">var defaultDirErr error</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultDirOnce" data-name="defaultDirOnce">
               <h3>
                  defaultDirOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#defaultDirOnce" class="anchor" title="Link to defaultDirOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var defaultDirOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="entrySize" data-name="entrySize">
               <h3>
                  entrySize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#entrySize" class="anchor" title="Link to entrySize">#</a>
               </h3>
               
               <pre><code class="language-go">const entrySize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errCacheprogClosed" data-name="errCacheprogClosed">
               <h3>
                  errCacheprogClosed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errCacheprogClosed" class="anchor" title="Link to errCacheprogClosed">#</a>
               </h3>
               
               <pre><code class="language-go">var errCacheprogClosed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errVerifyMode" data-name="errVerifyMode">
               <h3>
                  errVerifyMode 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errVerifyMode" class="anchor" title="Link to errVerifyMode">#</a>
               </h3>
               
               <pre><code class="language-go">var errVerifyMode = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gocachehash" data-name="gocachehash">
               <h3>
                  gocachehash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gocachehash" class="anchor" title="Link to gocachehash">#</a>
               </h3>
               
               <pre><code class="language-go">var gocachehash = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gocachetest" data-name="gocachetest">
               <h3>
                  gocachetest 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gocachetest" class="anchor" title="Link to gocachetest">#</a>
               </h3>
               
               <pre><code class="language-go">var gocachetest = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gocacheverify" data-name="gocacheverify">
               <h3>
                  gocacheverify 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gocacheverify" class="anchor" title="Link to gocacheverify">#</a>
               </h3>
               
               <pre><code class="language-go">var gocacheverify = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hashDebug" data-name="hashDebug">
               <h3>
                  hashDebug 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#hashDebug" class="anchor" title="Link to hashDebug">#</a>
               </h3>
               
                  <p class="doc-comment">In GODEBUG=gocacheverify=1 mode,
hashDebug holds the input to every computed hash ID,
so that we can work backward from the ID involved in a
cache entry mismatch to a description of what should be there.</p>
               
               <pre><code class="language-go">var hashDebug struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hashFileCache" data-name="hashFileCache">
               <h3>
                  hashFileCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#hashFileCache" class="anchor" title="Link to hashFileCache">#</a>
               </h3>
               
               <pre><code class="language-go">var hashFileCache struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hashSalt" data-name="hashSalt">
               <h3>
                  hashSalt 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#hashSalt" class="anchor" title="Link to hashSalt">#</a>
               </h3>
               
                  <p class="doc-comment">hashSalt is a salt string added to the beginning of every hash
created by NewHash. Using the Go version makes sure that different
versions of the go command (or even different Git commits during
work on the development branch) do not address the same cache
entries, so that a bug in one version does not affect the execution
of other versions. This salt will result in additional ActionID files
in the cache, but not additional copies of the large output files,
which are still addressed by unsalted SHA256.
We strip any GOEXPERIMENTs the go tool was built with from this
version string on the assumption that they shouldn't affect go tool
execution. This allows bootstrapping to converge faster: dist builds
go_bootstrap without any experiments, so by stripping experiments
go_bootstrap and the final go binary will use the same salt.</p>
               
               <pre><code class="language-go">var hashSalt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hexSize" data-name="hexSize">
               <h3>
                  hexSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#hexSize" class="anchor" title="Link to hexSize">#</a>
               </h3>
               
                  <p class="doc-comment">action entry file is "v1 <hex id> <hex out> <decimal size space-padded to 20 bytes> <unixnano space-padded to 20 bytes>\n"</p>
               
               <pre><code class="language-go">const hexSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initDefaultCacheOnce" data-name="initDefaultCacheOnce">
               <h3>
                  initDefaultCacheOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#initDefaultCacheOnce" class="anchor" title="Link to initDefaultCacheOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var initDefaultCacheOnce = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mtimeInterval" data-name="mtimeInterval">
               <h3>
                  mtimeInterval 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mtimeInterval" class="anchor" title="Link to mtimeInterval">#</a>
               </h3>
               
                  <p class="doc-comment">Time constants for cache expiration.
We set the mtime on a cache file on each use, but at most one per mtimeInterval (1 hour),
to avoid causing many unnecessary inode updates. The mtimes therefore
roughly reflect "time of last use" but may in fact be older by at most an hour.
We scan the cache for entries to delete at most once per trimInterval (1 day).
When we do scan the cache, we delete entries that have not been used for
at least trimLimit (5 days). Statistics gathered from a month of usage by
Go developers found that essentially all reuse of cached entries happened
within 5 days of the previous reuse. See golang.org/issue/22990.</p>
               
               <pre><code class="language-go">const mtimeInterval = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="trimInterval" data-name="trimInterval">
               <h3>
                  trimInterval 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#trimInterval" class="anchor" title="Link to trimInterval">#</a>
               </h3>
               
                  <p class="doc-comment">Time constants for cache expiration.
We set the mtime on a cache file on each use, but at most one per mtimeInterval (1 hour),
to avoid causing many unnecessary inode updates. The mtimes therefore
roughly reflect "time of last use" but may in fact be older by at most an hour.
We scan the cache for entries to delete at most once per trimInterval (1 day).
When we do scan the cache, we delete entries that have not been used for
at least trimLimit (5 days). Statistics gathered from a month of usage by
Go developers found that essentially all reuse of cached entries happened
within 5 days of the previous reuse. See golang.org/issue/22990.</p>
               
               <pre><code class="language-go">const trimInterval = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="trimLimit" data-name="trimLimit">
               <h3>
                  trimLimit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#trimLimit" class="anchor" title="Link to trimLimit">#</a>
               </h3>
               
                  <p class="doc-comment">Time constants for cache expiration.
We set the mtime on a cache file on each use, but at most one per mtimeInterval (1 hour),
to avoid causing many unnecessary inode updates. The mtimes therefore
roughly reflect "time of last use" but may in fact be older by at most an hour.
We scan the cache for entries to delete at most once per trimInterval (1 day).
When we do scan the cache, we delete entries that have not been used for
at least trimLimit (5 days). Statistics gathered from a month of usage by
Go developers found that essentially all reuse of cached entries happened
within 5 days of the previous reuse. See golang.org/issue/22990.</p>
               
               <pre><code class="language-go">const trimLimit = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="verify" data-name="verify">
               <h3>
                  verify 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#verify" class="anchor" title="Link to verify">#</a>
               </h3>
               
                  <p class="doc-comment">verify controls whether to run the cache in verify mode.
In verify mode, the cache always returns errMissing from Get
but then double-checks in Put that the data being written
exactly matches any existing entry. This provides an easy
way to detect program behavior that would have been different
had the cache entry been returned from Get.
verify is enabled by setting the environment variable
GODEBUG=gocacheverify=1.</p>
               
               <pre><code class="language-go">var verify = false</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="ActionID" data-name="ActionID">
               <h3>
                  ActionID
                  <span class="badge type-badge">type</span>
                  <a href="#ActionID" class="anchor" title="Link to ActionID">#</a>
               </h3>
               
               <p>An ActionID is a cache action key, the hash of a complete description of a
repeatable computation (command line, environment variables,
input file contents, executable contents).</p>
               
               <pre><code class="language-go">type ActionID [HashSize]byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="OutputID" data-name="OutputID">
               <h3>
                  OutputID
                  <span class="badge type-badge">type</span>
                  <a href="#OutputID" class="anchor" title="Link to OutputID">#</a>
               </h3>
               
               <p>An OutputID is a cache output key, the hash of an output of a computation.</p>
               
               <pre><code class="language-go">type OutputID [HashSize]byte</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Cache" data-name="Cache">
               <h3>
                  Cache
                  <span class="badge interface-badge">interface</span>
                  <a href="#Cache" class="anchor" title="Link to Cache">#</a>
               </h3>
               
               <p>Cache is the interface as used by the cmd/go.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Cache interface {
Get(ActionID) (Entry, error)
Put(ActionID, io.ReadSeeker) (_ OutputID, size int64, _ error)
Close() error
OutputFile(OutputID) string
FuzzDir() string
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="DiskCache" data-name="DiskCache">
               <h3>
                  DiskCache
                  <span class="badge">struct</span>
                  <a href="#DiskCache" class="anchor" title="Link to DiskCache">#</a>
               </h3>
               
               <p>A Cache is a package cache, backed by a file system directory tree.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type DiskCache struct {
dir string
now func() time.Time
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Entry" data-name="Entry">
               <h3>
                  Entry
                  <span class="badge">struct</span>
                  <a href="#Entry" class="anchor" title="Link to Entry">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Entry struct {
OutputID OutputID
Size int64
Time time.Time
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Hash" data-name="Hash">
               <h3>
                  Hash
                  <span class="badge">struct</span>
                  <a href="#Hash" class="anchor" title="Link to Hash">#</a>
               </h3>
               
               <p>A Hash provides access to the canonical hash function used to index the cache.
The current implementation uses salted SHA256, but clients must not assume this.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Hash struct {
h hash.Hash
name string
buf *bytes.Buffer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ProgCache" data-name="ProgCache">
               <h3>
                  ProgCache
                  <span class="badge">struct</span>
                  <a href="#ProgCache" class="anchor" title="Link to ProgCache">#</a>
               </h3>
               
               <p>ProgCache implements Cache via JSON messages over stdin/stdout to a child
helper process which can then implement whatever caching policy/mechanism it
wants.
See https://github.com/golang/go/issues/59719</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ProgCache struct {
cmd *exec.Cmd
stdout io.ReadCloser
stdin io.WriteCloser
bw *bufio.Writer
jenc *json.Encoder
can map[cacheprog.Cmd]bool
fuzzDirCache Cache
closing atomic.Bool
ctx context.Context
ctxCancel context.CancelFunc
readLoopDone chan struct{...}
mu sync.Mutex
nextID int64
inFlight map[int64]chan<- *cacheprog.Response
outputFile map[OutputID]string
writeMu sync.Mutex
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="entryNotFoundError" data-name="entryNotFoundError">
               <h3>
                  entryNotFoundError
                  <span class="badge">struct</span>
                  <a href="#entryNotFoundError" class="anchor" title="Link to entryNotFoundError">#</a>
               </h3>
               
               <p>An entryNotFoundError indicates that a cache entry was not found, with an
optional underlying reason.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type entryNotFoundError struct {
Err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="noVerifyReadSeeker" data-name="noVerifyReadSeeker">
               <h3>
                  noVerifyReadSeeker
                  <span class="badge">struct</span>
                  <a href="#noVerifyReadSeeker" class="anchor" title="Link to noVerifyReadSeeker">#</a>
               </h3>
               
               <p>noVerifyReadSeeker is an io.ReadSeeker wrapper sentinel type
that says that Cache.Put should skip the verify check
(from GODEBUG=goverifycache=1).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type noVerifyReadSeeker struct {
io.ReadSeeker
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *DiskCache) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *ProgCache) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Default" data-name="Default">
               <h3>
                  Default 
                  <span class="badge">function</span>
                  
                  <a href="#Default" class="anchor" title="Link to Default">#</a>
               </h3>
               
               <p>Default returns the default cache to use.
It never returns nil.</p>
               
               <pre><code class="language-go">func Default() Cache</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DefaultDir" data-name="DefaultDir">
               <h3>
                  DefaultDir 
                  <span class="badge">function</span>
                  
                  <a href="#DefaultDir" class="anchor" title="Link to DefaultDir">#</a>
               </h3>
               
               <p>DefaultDir returns the effective GOCACHE setting.
It returns "off" if the cache is disabled,
and reports whether the effective value differs from GOCACHE.</p>
               
               <pre><code class="language-go">func DefaultDir() (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *entryNotFoundError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FileHash" data-name="FileHash">
               <h3>
                  FileHash 
                  <span class="badge">function</span>
                  
                  <a href="#FileHash" class="anchor" title="Link to FileHash">#</a>
               </h3>
               
               <p>FileHash returns the hash of the named file.
It caches repeated lookups for a given file,
and the cache entry for a file can be initialized
using SetFileHash.
The hash used by FileHash is not the same as
the hash used by NewHash.</p>
               
               <pre><code class="language-go">func FileHash(file string) ([HashSize]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FuzzDir" data-name="FuzzDir">
               <h3>
                  FuzzDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FuzzDir" class="anchor" title="Link to FuzzDir">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *ProgCache) FuzzDir() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FuzzDir" data-name="FuzzDir">
               <h3>
                  FuzzDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FuzzDir" class="anchor" title="Link to FuzzDir">#</a>
               </h3>
               
               <p>FuzzDir returns a subdirectory within the cache for storing fuzzing data.
The subdirectory may not exist.
This directory is managed by the internal/fuzz package. Files in this
directory aren't removed by the 'go clean -cache' command or by Trim.
They may be removed with 'go clean -fuzzcache'.
TODO(#48526): make Trim remove unused files from this directory.</p>
               
               <pre><code class="language-go">func (c *DiskCache) FuzzDir() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Get" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Get" class="anchor" title="Link to Get">#</a>
               </h3>
               
               <p>Get looks up the action ID in the cache,
returning the corresponding output ID and file size, if any.
Note that finding an output ID does not guarantee that the
saved file for that output ID is still available.</p>
               
               <pre><code class="language-go">func (c *DiskCache) Get(id ActionID) (Entry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Get" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Get" class="anchor" title="Link to Get">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *ProgCache) Get(a ActionID) (Entry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetBytes" data-name="GetBytes">
               <h3>
                  GetBytes 
                  <span class="badge">function</span>
                  
                  <a href="#GetBytes" class="anchor" title="Link to GetBytes">#</a>
               </h3>
               
               <p>GetBytes looks up the action ID in the cache and returns
the corresponding output bytes.
GetBytes should only be used for data that can be expected to fit in memory.</p>
               
               <pre><code class="language-go">func GetBytes(c Cache, id ActionID) ([]byte, Entry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetFile" data-name="GetFile">
               <h3>
                  GetFile 
                  <span class="badge">function</span>
                  
                  <a href="#GetFile" class="anchor" title="Link to GetFile">#</a>
               </h3>
               
               <p>GetFile looks up the action ID in the cache and returns
the name of the corresponding data file.</p>
               
               <pre><code class="language-go">func GetFile(c Cache, id ActionID) (file string, entry Entry, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetMmap" data-name="GetMmap">
               <h3>
                  GetMmap 
                  <span class="badge">function</span>
                  
                  <a href="#GetMmap" class="anchor" title="Link to GetMmap">#</a>
               </h3>
               
               <p>GetMmap looks up the action ID in the cache and returns
the corresponding output bytes.
GetMmap should only be used for data that can be expected to fit in memory.</p>
               
               <pre><code class="language-go">func GetMmap(c Cache, id ActionID) ([]byte, Entry, bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewHash" data-name="NewHash">
               <h3>
                  NewHash 
                  <span class="badge">function</span>
                  
                  <a href="#NewHash" class="anchor" title="Link to NewHash">#</a>
               </h3>
               
               <p>NewHash returns a new Hash.
The caller is expected to Write data to it and then call Sum.</p>
               
               <pre><code class="language-go">func NewHash(name string) *Hash</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge">function</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <p>Open opens and returns the cache in the given directory.
It is safe for multiple processes on a single machine to use the
same cache directory in a local file system simultaneously.
They will coordinate using operating system file locks and may
duplicate effort but will not corrupt the cache.
However, it is NOT safe for multiple processes on different machines
to share a cache directory (for example, if the directory were stored
in a network file system). File locking is notoriously unreliable in
network file systems and may not suffice to protect the cache.</p>
               
               <pre><code class="language-go">func Open(dir string) (*DiskCache, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OutputFile" data-name="OutputFile">
               <h3>
                  OutputFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OutputFile" class="anchor" title="Link to OutputFile">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *ProgCache) OutputFile(o OutputID) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OutputFile" data-name="OutputFile">
               <h3>
                  OutputFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OutputFile" class="anchor" title="Link to OutputFile">#</a>
               </h3>
               
               <p>OutputFile returns the name of the cache file storing output with the given OutputID.</p>
               
               <pre><code class="language-go">func (c *DiskCache) OutputFile(out OutputID) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Put" data-name="Put">
               <h3>
                  Put 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Put" class="anchor" title="Link to Put">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *ProgCache) Put(a ActionID, file io.ReadSeeker) (_ OutputID, size int64, _ error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Put" data-name="Put">
               <h3>
                  Put 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Put" class="anchor" title="Link to Put">#</a>
               </h3>
               
               <p>Put stores the given output in the cache as the output for the action ID.
It may read file twice. The content of file must not change between the two passes.</p>
               
               <pre><code class="language-go">func (c *DiskCache) Put(id ActionID, file io.ReadSeeker) (OutputID, int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PutBytes" data-name="PutBytes">
               <h3>
                  PutBytes 
                  <span class="badge">function</span>
                  
                  <a href="#PutBytes" class="anchor" title="Link to PutBytes">#</a>
               </h3>
               
               <p>PutBytes stores the given bytes in the cache as the output for the action ID.</p>
               
               <pre><code class="language-go">func PutBytes(c Cache, id ActionID, data []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PutExecutable" data-name="PutExecutable">
               <h3>
                  PutExecutable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PutExecutable" class="anchor" title="Link to PutExecutable">#</a>
               </h3>
               
               <p>PutExecutable is used to store the output as the output for the action ID into a
file with the given base name, with the executable mode bit set.
It may read file twice. The content of file must not change between the two passes.</p>
               
               <pre><code class="language-go">func (c *DiskCache) PutExecutable(id ActionID, name string, file io.ReadSeeker) (OutputID, int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PutNoVerify" data-name="PutNoVerify">
               <h3>
                  PutNoVerify 
                  <span class="badge">function</span>
                  
                  <a href="#PutNoVerify" class="anchor" title="Link to PutNoVerify">#</a>
               </h3>
               
               <p>PutNoVerify is like Put but disables the verify check
when GODEBUG=goverifycache=1 is set.
It is meant for data that is OK to cache but that we expect to vary slightly from run to run,
like test output containing times and the like.</p>
               
               <pre><code class="language-go">func PutNoVerify(c Cache, id ActionID, file io.ReadSeeker) (OutputID, int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetFileHash" data-name="SetFileHash">
               <h3>
                  SetFileHash 
                  <span class="badge">function</span>
                  
                  <a href="#SetFileHash" class="anchor" title="Link to SetFileHash">#</a>
               </h3>
               
               <p>SetFileHash sets the hash returned by FileHash for file.</p>
               
               <pre><code class="language-go">func SetFileHash(file string, sum [HashSize]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Subkey" data-name="Subkey">
               <h3>
                  Subkey 
                  <span class="badge">function</span>
                  
                  <a href="#Subkey" class="anchor" title="Link to Subkey">#</a>
               </h3>
               
               <p>Subkey returns an action ID corresponding to mixing a parent
action ID with a string description of the subkey.</p>
               
               <pre><code class="language-go">func Subkey(parent ActionID, desc string) ActionID</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sum" data-name="Sum">
               <h3>
                  Sum 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sum" class="anchor" title="Link to Sum">#</a>
               </h3>
               
               <p>Sum returns the hash of the data written previously.</p>
               
               <pre><code class="language-go">func (h *Hash) Sum() [HashSize]byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Trim" data-name="Trim">
               <h3>
                  Trim 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Trim" class="anchor" title="Link to Trim">#</a>
               </h3>
               
               <p>Trim removes old cache entries that are likely not to be reused.</p>
               
               <pre><code class="language-go">func (c *DiskCache) Trim() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *entryNotFoundError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write writes data to the running hash.</p>
               
               <pre><code class="language-go">func (h *Hash) Write(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyFile" data-name="copyFile">
               <h3>
                  copyFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#copyFile" class="anchor" title="Link to copyFile">#</a>
               </h3>
               
               <p>copyFile copies file into the cache, expecting it to have the given
output ID and size, if that file is not present already.</p>
               
               <pre><code class="language-go">func (c *DiskCache) copyFile(file io.ReadSeeker, executableName string, out OutputID, size int64, perm os.FileMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fileName" data-name="fileName">
               <h3>
                  fileName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fileName" class="anchor" title="Link to fileName">#</a>
               </h3>
               
               <p>fileName returns the name of the file corresponding to the given id.</p>
               
               <pre><code class="language-go">func (c *DiskCache) fileName(id [HashSize]byte, key string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="get" data-name="get">
               <h3>
                  get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#get" class="anchor" title="Link to get">#</a>
               </h3>
               
               <p>get is Get but does not respect verify mode, so that Put can use it.</p>
               
               <pre><code class="language-go">func (c *DiskCache) get(id ActionID) (Entry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initDefaultCache" data-name="initDefaultCache">
               <h3>
                  initDefaultCache 
                  <span class="badge">function</span>
                  
                  <a href="#initDefaultCache" class="anchor" title="Link to initDefaultCache">#</a>
               </h3>
               
               <p>initDefaultCache does the work of finding the default cache
the first time Default is called.</p>
               
               <pre><code class="language-go">func initDefaultCache() Cache</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initEnv" data-name="initEnv">
               <h3>
                  initEnv 
                  <span class="badge">function</span>
                  
                  <a href="#initEnv" class="anchor" title="Link to initEnv">#</a>
               </h3>
               
               <pre><code class="language-go">func initEnv()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="markUsed" data-name="markUsed">
               <h3>
                  markUsed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#markUsed" class="anchor" title="Link to markUsed">#</a>
               </h3>
               
               <p>markUsed makes a best-effort attempt to update mtime on file,
so that mtime reflects cache access time.
Because the reflection only needs to be approximate,
and to reduce the amount of disk activity caused by using
cache entries, used only updates the mtime if the current
mtime is more than an hour old. This heuristic eliminates
nearly all of the mtime updates that would otherwise happen,
while still keeping the mtimes useful for cache trimming.
markUsed reports whether the file is a directory (an executable cache entry).</p>
               
               <pre><code class="language-go">func (c *DiskCache) markUsed(file string) (isDir bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="noteOutputFile" data-name="noteOutputFile">
               <h3>
                  noteOutputFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#noteOutputFile" class="anchor" title="Link to noteOutputFile">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *ProgCache) noteOutputFile(o OutputID, diskPath string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="put" data-name="put">
               <h3>
                  put 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#put" class="anchor" title="Link to put">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *DiskCache) put(id ActionID, executableName string, file io.ReadSeeker, allowVerify bool) (OutputID, int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="putIndexEntry" data-name="putIndexEntry">
               <h3>
                  putIndexEntry 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#putIndexEntry" class="anchor" title="Link to putIndexEntry">#</a>
               </h3>
               
               <p>putIndexEntry adds an entry to the cache recording that executing the action
with the given id produces an output with the given output id (hash) and size.</p>
               
               <pre><code class="language-go">func (c *DiskCache) putIndexEntry(id ActionID, out OutputID, size int64, allowVerify bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readLoop" data-name="readLoop">
               <h3>
                  readLoop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readLoop" class="anchor" title="Link to readLoop">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *ProgCache) readLoop(readLoopDone chan<- struct{...})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reverseHash" data-name="reverseHash">
               <h3>
                  reverseHash 
                  <span class="badge">function</span>
                  
                  <a href="#reverseHash" class="anchor" title="Link to reverseHash">#</a>
               </h3>
               
               <p>reverseHash returns the input used to compute the hash id.</p>
               
               <pre><code class="language-go">func reverseHash(id [HashSize]byte) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="send" data-name="send">
               <h3>
                  send 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#send" class="anchor" title="Link to send">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *ProgCache) send(ctx context.Context, req *cacheprog.Request) (*cacheprog.Response, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startCacheProg" data-name="startCacheProg">
               <h3>
                  startCacheProg 
                  <span class="badge">function</span>
                  
                  <a href="#startCacheProg" class="anchor" title="Link to startCacheProg">#</a>
               </h3>
               
               <p>startCacheProg starts the prog binary (with optional space-separated flags)
and returns a Cache implementation that talks to it.
It blocks a few seconds to wait for the child process to successfully start
and advertise its capabilities.</p>
               
               <pre><code class="language-go">func startCacheProg(progAndArgs string, fuzzDirCache Cache) Cache</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stripExperiment" data-name="stripExperiment">
               <h3>
                  stripExperiment 
                  <span class="badge">function</span>
                  
                  <a href="#stripExperiment" class="anchor" title="Link to stripExperiment">#</a>
               </h3>
               
               <p>stripExperiment strips any GOEXPERIMENT configuration from the Go
version string.</p>
               
               <pre><code class="language-go">func stripExperiment(version string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimSubdir" data-name="trimSubdir">
               <h3>
                  trimSubdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#trimSubdir" class="anchor" title="Link to trimSubdir">#</a>
               </h3>
               
               <p>trimSubdir trims a single cache subdirectory.</p>
               
               <pre><code class="language-go">func (c *DiskCache) trimSubdir(subdir string, cutoff time.Time)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeToChild" data-name="writeToChild">
               <h3>
                  writeToChild 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeToChild" class="anchor" title="Link to writeToChild">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *ProgCache) writeToChild(req *cacheprog.Request, resc chan<- *cacheprog.Response) (err error)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>