<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - cache</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>cache</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bytes"
"crypto/sha256"
"encoding/hex"
"errors"
"fmt"
"internal/godebug"
"io"
"io/fs"
"os"
"path/filepath"
"strconv"
"strings"
"time"
"cmd/go/internal/base"
"cmd/go/internal/lockedfile"
"cmd/go/internal/mmap"
"fmt"
"os"
"path/filepath"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"bytes"
"crypto/sha256"
"fmt"
"hash"
"io"
"os"
"runtime"
"strings"
"sync"
"bufio"
"cmd/go/internal/base"
"cmd/go/internal/cacheprog"
"cmd/internal/quoted"
"context"
"crypto/sha256"
"encoding/base64"
"encoding/json"
"errors"
"fmt"
"internal/goexperiment"
"io"
"log"
"os"
"os/exec"
"sync"
"sync/atomic"
"time"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="DebugTest">
               <h3>
                  DebugTest 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>DebugTest is set when GODEBUG=gocachetest=1 is in the environment.</p>
               
               <pre><code>var DebugTest = false</code></pre>
            </article>
            
            <article class="global" data-name="HashSize">
               <h3>
                  HashSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>HashSize is the number of bytes in a hash.</p>
               
               <pre><code>const HashSize = 32</code></pre>
            </article>
            
            <article class="global" data-name="cacheREADME">
               <h3>
                  cacheREADME 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>cacheREADME is a message stored in a README in the cache directory.
Because the cache lives outside the normal Go trees, we leave the
README as a courtesy to explain where it came from.</p>
               
               <pre><code>const cacheREADME = `This directory holds cached build artifacts from the Go build system.
Run "go clean -cache" if the directory is getting too large.
Run "go clean -fuzzcache" to delete the fuzz cache.
See golang.org to learn more about Go.
`</code></pre>
            </article>
            
            <article class="global" data-name="debugHash">
               <h3>
                  debugHash 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var debugHash = false</code></pre>
            </article>
            
            <article class="global" data-name="defaultDir">
               <h3>
                  defaultDir 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var defaultDir string</code></pre>
            </article>
            
            <article class="global" data-name="defaultDirChanged">
               <h3>
                  defaultDirChanged 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var defaultDirChanged bool</code></pre>
            </article>
            
            <article class="global" data-name="defaultDirErr">
               <h3>
                  defaultDirErr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var defaultDirErr error</code></pre>
            </article>
            
            <article class="global" data-name="defaultDirOnce">
               <h3>
                  defaultDirOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var defaultDirOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="entrySize">
               <h3>
                  entrySize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const entrySize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="errCacheprogClosed">
               <h3>
                  errCacheprogClosed 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errCacheprogClosed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errVerifyMode">
               <h3>
                  errVerifyMode 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errVerifyMode = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="gocachehash">
               <h3>
                  gocachehash 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var gocachehash = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="gocachetest">
               <h3>
                  gocachetest 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var gocachetest = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="gocacheverify">
               <h3>
                  gocacheverify 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var gocacheverify = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="hashDebug">
               <h3>
                  hashDebug 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>In GODEBUG=gocacheverify=1 mode,
hashDebug holds the input to every computed hash ID,
so that we can work backward from the ID involved in a
cache entry mismatch to a description of what should be there.</p>
               
               <pre><code>var hashDebug struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="hashFileCache">
               <h3>
                  hashFileCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var hashFileCache struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="hashSalt">
               <h3>
                  hashSalt 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>hashSalt is a salt string added to the beginning of every hash
created by NewHash. Using the Go version makes sure that different
versions of the go command (or even different Git commits during
work on the development branch) do not address the same cache
entries, so that a bug in one version does not affect the execution
of other versions. This salt will result in additional ActionID files
in the cache, but not additional copies of the large output files,
which are still addressed by unsalted SHA256.
We strip any GOEXPERIMENTs the go tool was built with from this
version string on the assumption that they shouldn't affect go tool
execution. This allows bootstrapping to converge faster: dist builds
go_bootstrap without any experiments, so by stripping experiments
go_bootstrap and the final go binary will use the same salt.</p>
               
               <pre><code>var hashSalt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="hexSize">
               <h3>
                  hexSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>action entry file is "v1 <hex id> <hex out> <decimal size space-padded to 20 bytes> <unixnano space-padded to 20 bytes>\n"</p>
               
               <pre><code>const hexSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="initDefaultCacheOnce">
               <h3>
                  initDefaultCacheOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var initDefaultCacheOnce = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="mtimeInterval">
               <h3>
                  mtimeInterval 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Time constants for cache expiration.
We set the mtime on a cache file on each use, but at most one per mtimeInterval (1 hour),
to avoid causing many unnecessary inode updates. The mtimes therefore
roughly reflect "time of last use" but may in fact be older by at most an hour.
We scan the cache for entries to delete at most once per trimInterval (1 day).
When we do scan the cache, we delete entries that have not been used for
at least trimLimit (5 days). Statistics gathered from a month of usage by
Go developers found that essentially all reuse of cached entries happened
within 5 days of the previous reuse. See golang.org/issue/22990.</p>
               
               <pre><code>const mtimeInterval = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="trimInterval">
               <h3>
                  trimInterval 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Time constants for cache expiration.
We set the mtime on a cache file on each use, but at most one per mtimeInterval (1 hour),
to avoid causing many unnecessary inode updates. The mtimes therefore
roughly reflect "time of last use" but may in fact be older by at most an hour.
We scan the cache for entries to delete at most once per trimInterval (1 day).
When we do scan the cache, we delete entries that have not been used for
at least trimLimit (5 days). Statistics gathered from a month of usage by
Go developers found that essentially all reuse of cached entries happened
within 5 days of the previous reuse. See golang.org/issue/22990.</p>
               
               <pre><code>const trimInterval = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="trimLimit">
               <h3>
                  trimLimit 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Time constants for cache expiration.
We set the mtime on a cache file on each use, but at most one per mtimeInterval (1 hour),
to avoid causing many unnecessary inode updates. The mtimes therefore
roughly reflect "time of last use" but may in fact be older by at most an hour.
We scan the cache for entries to delete at most once per trimInterval (1 day).
When we do scan the cache, we delete entries that have not been used for
at least trimLimit (5 days). Statistics gathered from a month of usage by
Go developers found that essentially all reuse of cached entries happened
within 5 days of the previous reuse. See golang.org/issue/22990.</p>
               
               <pre><code>const trimLimit = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="verify">
               <h3>
                  verify 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>verify controls whether to run the cache in verify mode.
In verify mode, the cache always returns errMissing from Get
but then double-checks in Put that the data being written
exactly matches any existing entry. This provides an easy
way to detect program behavior that would have been different
had the cache entry been returned from Get.
verify is enabled by setting the environment variable
GODEBUG=gocacheverify=1.</p>
               
               <pre><code>var verify = false</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="ActionID">
               <h3>
                  ActionID
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An ActionID is a cache action key, the hash of a complete description of a
repeatable computation (command line, environment variables,
input file contents, executable contents).</p>
               
               <pre><code>type ActionID [HashSize]byte</code></pre>
            </article>
            
            <article class="type" data-name="OutputID">
               <h3>
                  OutputID
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An OutputID is a cache output key, the hash of an output of a computation.</p>
               
               <pre><code>type OutputID [HashSize]byte</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Cache">
               <h3>
                  Cache
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Cache is the interface as used by the cmd/go.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Cache interface {
Get(ActionID) (Entry, error)
Put(ActionID, io.ReadSeeker) (_ OutputID, size int64, _ error)
Close() error
OutputFile(OutputID) string
FuzzDir() string
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="DiskCache">
               <h3>
                  DiskCache
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Cache is a package cache, backed by a file system directory tree.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type DiskCache struct {
dir string
now func() time.Time
}</code></pre>
            </article>
            
            <article class="struct" data-name="Entry">
               <h3>
                  Entry
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Entry struct {
OutputID OutputID
Size int64
Time time.Time
}</code></pre>
            </article>
            
            <article class="struct" data-name="Hash">
               <h3>
                  Hash
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Hash provides access to the canonical hash function used to index the cache.
The current implementation uses salted SHA256, but clients must not assume this.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Hash struct {
h hash.Hash
name string
buf *bytes.Buffer
}</code></pre>
            </article>
            
            <article class="struct" data-name="ProgCache">
               <h3>
                  ProgCache
                  <span class="badge">struct</span>
               </h3>
               
               <p>ProgCache implements Cache via JSON messages over stdin/stdout to a child
helper process which can then implement whatever caching policy/mechanism it
wants.
See https://github.com/golang/go/issues/59719</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ProgCache struct {
cmd *exec.Cmd
stdout io.ReadCloser
stdin io.WriteCloser
bw *bufio.Writer
jenc *json.Encoder
can map[cacheprog.Cmd]bool
fuzzDirCache Cache
closing atomic.Bool
ctx context.Context
ctxCancel context.CancelFunc
readLoopDone chan struct{...}
mu sync.Mutex
nextID int64
inFlight map[int64]chan<- *cacheprog.Response
outputFile map[OutputID]string
writeMu sync.Mutex
}</code></pre>
            </article>
            
            <article class="struct" data-name="entryNotFoundError">
               <h3>
                  entryNotFoundError
                  <span class="badge">struct</span>
               </h3>
               
               <p>An entryNotFoundError indicates that a cache entry was not found, with an
optional underlying reason.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type entryNotFoundError struct {
Err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="noVerifyReadSeeker">
               <h3>
                  noVerifyReadSeeker
                  <span class="badge">struct</span>
               </h3>
               
               <p>noVerifyReadSeeker is an io.ReadSeeker wrapper sentinel type
that says that Cache.Put should skip the verify check
(from GODEBUG=goverifycache=1).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type noVerifyReadSeeker struct {
io.ReadSeeker
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ProgCache) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *DiskCache) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Default">
               <h3>
                  Default 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Default returns the default cache to use.
It never returns nil.</p>
               
               <pre><code>func Default() Cache</code></pre>
            </article>
            
            <article class="function" data-name="DefaultDir">
               <h3>
                  DefaultDir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DefaultDir returns the effective GOCACHE setting.
It returns "off" if the cache is disabled,
and reports whether the effective value differs from GOCACHE.</p>
               
               <pre><code>func DefaultDir() (string, bool)</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *entryNotFoundError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="FileHash">
               <h3>
                  FileHash 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FileHash returns the hash of the named file.
It caches repeated lookups for a given file,
and the cache entry for a file can be initialized
using SetFileHash.
The hash used by FileHash is not the same as
the hash used by NewHash.</p>
               
               <pre><code>func FileHash(file string) ([HashSize]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="FuzzDir">
               <h3>
                  FuzzDir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ProgCache) FuzzDir() string</code></pre>
            </article>
            
            <article class="function" data-name="FuzzDir">
               <h3>
                  FuzzDir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FuzzDir returns a subdirectory within the cache for storing fuzzing data.
The subdirectory may not exist.
This directory is managed by the internal/fuzz package. Files in this
directory aren't removed by the 'go clean -cache' command or by Trim.
They may be removed with 'go clean -fuzzcache'.
TODO(#48526): make Trim remove unused files from this directory.</p>
               
               <pre><code>func (c *DiskCache) FuzzDir() string</code></pre>
            </article>
            
            <article class="function" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Get looks up the action ID in the cache,
returning the corresponding output ID and file size, if any.
Note that finding an output ID does not guarantee that the
saved file for that output ID is still available.</p>
               
               <pre><code>func (c *DiskCache) Get(id ActionID) (Entry, error)</code></pre>
            </article>
            
            <article class="function" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ProgCache) Get(a ActionID) (Entry, error)</code></pre>
            </article>
            
            <article class="function" data-name="GetBytes">
               <h3>
                  GetBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>GetBytes looks up the action ID in the cache and returns
the corresponding output bytes.
GetBytes should only be used for data that can be expected to fit in memory.</p>
               
               <pre><code>func GetBytes(c Cache, id ActionID) ([]byte, Entry, error)</code></pre>
            </article>
            
            <article class="function" data-name="GetFile">
               <h3>
                  GetFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>GetFile looks up the action ID in the cache and returns
the name of the corresponding data file.</p>
               
               <pre><code>func GetFile(c Cache, id ActionID) (file string, entry Entry, err error)</code></pre>
            </article>
            
            <article class="function" data-name="GetMmap">
               <h3>
                  GetMmap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>GetMmap looks up the action ID in the cache and returns
the corresponding output bytes.
GetMmap should only be used for data that can be expected to fit in memory.</p>
               
               <pre><code>func GetMmap(c Cache, id ActionID) ([]byte, Entry, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewHash">
               <h3>
                  NewHash 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewHash returns a new Hash.
The caller is expected to Write data to it and then call Sum.</p>
               
               <pre><code>func NewHash(name string) *Hash</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Open opens and returns the cache in the given directory.
It is safe for multiple processes on a single machine to use the
same cache directory in a local file system simultaneously.
They will coordinate using operating system file locks and may
duplicate effort but will not corrupt the cache.
However, it is NOT safe for multiple processes on different machines
to share a cache directory (for example, if the directory were stored
in a network file system). File locking is notoriously unreliable in
network file systems and may not suffice to protect the cache.</p>
               
               <pre><code>func Open(dir string) (*DiskCache, error)</code></pre>
            </article>
            
            <article class="function" data-name="OutputFile">
               <h3>
                  OutputFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>OutputFile returns the name of the cache file storing output with the given OutputID.</p>
               
               <pre><code>func (c *DiskCache) OutputFile(out OutputID) string</code></pre>
            </article>
            
            <article class="function" data-name="OutputFile">
               <h3>
                  OutputFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ProgCache) OutputFile(o OutputID) string</code></pre>
            </article>
            
            <article class="function" data-name="Put">
               <h3>
                  Put 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Put stores the given output in the cache as the output for the action ID.
It may read file twice. The content of file must not change between the two passes.</p>
               
               <pre><code>func (c *DiskCache) Put(id ActionID, file io.ReadSeeker) (OutputID, int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="Put">
               <h3>
                  Put 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ProgCache) Put(a ActionID, file io.ReadSeeker) (_ OutputID, size int64, _ error)</code></pre>
            </article>
            
            <article class="function" data-name="PutBytes">
               <h3>
                  PutBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PutBytes stores the given bytes in the cache as the output for the action ID.</p>
               
               <pre><code>func PutBytes(c Cache, id ActionID, data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="PutExecutable">
               <h3>
                  PutExecutable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PutExecutable is used to store the output as the output for the action ID into a
file with the given base name, with the executable mode bit set.
It may read file twice. The content of file must not change between the two passes.</p>
               
               <pre><code>func (c *DiskCache) PutExecutable(id ActionID, name string, file io.ReadSeeker) (OutputID, int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="PutNoVerify">
               <h3>
                  PutNoVerify 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PutNoVerify is like Put but disables the verify check
when GODEBUG=goverifycache=1 is set.
It is meant for data that is OK to cache but that we expect to vary slightly from run to run,
like test output containing times and the like.</p>
               
               <pre><code>func PutNoVerify(c Cache, id ActionID, file io.ReadSeeker) (OutputID, int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="SetFileHash">
               <h3>
                  SetFileHash 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SetFileHash sets the hash returned by FileHash for file.</p>
               
               <pre><code>func SetFileHash(file string, sum [HashSize]byte)</code></pre>
            </article>
            
            <article class="function" data-name="Subkey">
               <h3>
                  Subkey 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Subkey returns an action ID corresponding to mixing a parent
action ID with a string description of the subkey.</p>
               
               <pre><code>func Subkey(parent ActionID, desc string) ActionID</code></pre>
            </article>
            
            <article class="function" data-name="Sum">
               <h3>
                  Sum 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Sum returns the hash of the data written previously.</p>
               
               <pre><code>func (h *Hash) Sum() [HashSize]byte</code></pre>
            </article>
            
            <article class="function" data-name="Trim">
               <h3>
                  Trim 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Trim removes old cache entries that are likely not to be reused.</p>
               
               <pre><code>func (c *DiskCache) Trim() error</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *entryNotFoundError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write writes data to the running hash.</p>
               
               <pre><code>func (h *Hash) Write(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="copyFile">
               <h3>
                  copyFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>copyFile copies file into the cache, expecting it to have the given
output ID and size, if that file is not present already.</p>
               
               <pre><code>func (c *DiskCache) copyFile(file io.ReadSeeker, executableName string, out OutputID, size int64, perm os.FileMode) error</code></pre>
            </article>
            
            <article class="function" data-name="fileName">
               <h3>
                  fileName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fileName returns the name of the file corresponding to the given id.</p>
               
               <pre><code>func (c *DiskCache) fileName(id [HashSize]byte, key string) string</code></pre>
            </article>
            
            <article class="function" data-name="get">
               <h3>
                  get 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>get is Get but does not respect verify mode, so that Put can use it.</p>
               
               <pre><code>func (c *DiskCache) get(id ActionID) (Entry, error)</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="initDefaultCache">
               <h3>
                  initDefaultCache 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>initDefaultCache does the work of finding the default cache
the first time Default is called.</p>
               
               <pre><code>func initDefaultCache() Cache</code></pre>
            </article>
            
            <article class="function" data-name="initEnv">
               <h3>
                  initEnv 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initEnv()</code></pre>
            </article>
            
            <article class="function" data-name="markUsed">
               <h3>
                  markUsed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>markUsed makes a best-effort attempt to update mtime on file,
so that mtime reflects cache access time.
Because the reflection only needs to be approximate,
and to reduce the amount of disk activity caused by using
cache entries, used only updates the mtime if the current
mtime is more than an hour old. This heuristic eliminates
nearly all of the mtime updates that would otherwise happen,
while still keeping the mtimes useful for cache trimming.
markUsed reports whether the file is a directory (an executable cache entry).</p>
               
               <pre><code>func (c *DiskCache) markUsed(file string) (isDir bool)</code></pre>
            </article>
            
            <article class="function" data-name="noteOutputFile">
               <h3>
                  noteOutputFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ProgCache) noteOutputFile(o OutputID, diskPath string)</code></pre>
            </article>
            
            <article class="function" data-name="put">
               <h3>
                  put 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *DiskCache) put(id ActionID, executableName string, file io.ReadSeeker, allowVerify bool) (OutputID, int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="putIndexEntry">
               <h3>
                  putIndexEntry 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>putIndexEntry adds an entry to the cache recording that executing the action
with the given id produces an output with the given output id (hash) and size.</p>
               
               <pre><code>func (c *DiskCache) putIndexEntry(id ActionID, out OutputID, size int64, allowVerify bool) error</code></pre>
            </article>
            
            <article class="function" data-name="readLoop">
               <h3>
                  readLoop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ProgCache) readLoop(readLoopDone chan<- struct{...})</code></pre>
            </article>
            
            <article class="function" data-name="reverseHash">
               <h3>
                  reverseHash 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>reverseHash returns the input used to compute the hash id.</p>
               
               <pre><code>func reverseHash(id [HashSize]byte) string</code></pre>
            </article>
            
            <article class="function" data-name="send">
               <h3>
                  send 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ProgCache) send(ctx context.Context, req *cacheprog.Request) (*cacheprog.Response, error)</code></pre>
            </article>
            
            <article class="function" data-name="startCacheProg">
               <h3>
                  startCacheProg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>startCacheProg starts the prog binary (with optional space-separated flags)
and returns a Cache implementation that talks to it.
It blocks a few seconds to wait for the child process to successfully start
and advertise its capabilities.</p>
               
               <pre><code>func startCacheProg(progAndArgs string, fuzzDirCache Cache) Cache</code></pre>
            </article>
            
            <article class="function" data-name="stripExperiment">
               <h3>
                  stripExperiment 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stripExperiment strips any GOEXPERIMENT configuration from the Go
version string.</p>
               
               <pre><code>func stripExperiment(version string) string</code></pre>
            </article>
            
            <article class="function" data-name="trimSubdir">
               <h3>
                  trimSubdir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>trimSubdir trims a single cache subdirectory.</p>
               
               <pre><code>func (c *DiskCache) trimSubdir(subdir string, cutoff time.Time)</code></pre>
            </article>
            
            <article class="function" data-name="writeToChild">
               <h3>
                  writeToChild 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ProgCache) writeToChild(req *cacheprog.Request, resc chan<- *cacheprog.Response) (err error)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
