<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - cache</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>cache</code>
         </h1>
         <hr />
         
         <article class="global" data-name="hexSize">
            <h2>hexSize</h2>
            <hr />
            
            <p>action entry file is "v1 <hex id> <hex out> <decimal size space-padded to 20 bytes> <unixnano space-padded to 20 bytes>\n"</p>
            
            <pre><code>hexSize</code></pre>
         </article>
         
         <article class="global" data-name="entrySize">
            <h2>entrySize</h2>
            <hr />
            
            <pre><code>entrySize</code></pre>
         </article>
         
         <article class="global" data-name="verify">
            <h2>verify</h2>
            <hr />
            
            <p>verify controls whether to run the cache in verify mode.
In verify mode, the cache always returns errMissing from Get
but then double-checks in Put that the data being written
exactly matches any existing entry. This provides an easy
way to detect program behavior that would have been different
had the cache entry been returned from Get.

verify is enabled by setting the environment variable
GODEBUG=gocacheverify=1.</p>
            
            <pre><code>verify</code></pre>
         </article>
         
         <article class="global" data-name="errVerifyMode">
            <h2>errVerifyMode</h2>
            <hr />
            
            <pre><code>errVerifyMode</code></pre>
         </article>
         
         <article class="global" data-name="DebugTest">
            <h2>DebugTest</h2>
            <hr />
            
            <p>DebugTest is set when GODEBUG=gocachetest=1 is in the environment.</p>
            
            <pre><code>DebugTest</code></pre>
         </article>
         
         <article class="global" data-name="gocacheverify">
            <h2>gocacheverify</h2>
            <hr />
            
            <pre><code>gocacheverify</code></pre>
         </article>
         
         <article class="global" data-name="gocachehash">
            <h2>gocachehash</h2>
            <hr />
            
            <pre><code>gocachehash</code></pre>
         </article>
         
         <article class="global" data-name="gocachetest">
            <h2>gocachetest</h2>
            <hr />
            
            <pre><code>gocachetest</code></pre>
         </article>
         
         <article class="global" data-name="mtimeInterval">
            <h2>mtimeInterval</h2>
            <hr />
            
            <p>Time constants for cache expiration.

We set the mtime on a cache file on each use, but at most one per mtimeInterval (1 hour),
to avoid causing many unnecessary inode updates. The mtimes therefore
roughly reflect "time of last use" but may in fact be older by at most an hour.

We scan the cache for entries to delete at most once per trimInterval (1 day).

When we do scan the cache, we delete entries that have not been used for
at least trimLimit (5 days). Statistics gathered from a month of usage by
Go developers found that essentially all reuse of cached entries happened
within 5 days of the previous reuse. See golang.org/issue/22990.</p>
            
            <pre><code>mtimeInterval</code></pre>
         </article>
         
         <article class="global" data-name="trimInterval">
            <h2>trimInterval</h2>
            <hr />
            
            <p>Time constants for cache expiration.

We set the mtime on a cache file on each use, but at most one per mtimeInterval (1 hour),
to avoid causing many unnecessary inode updates. The mtimes therefore
roughly reflect "time of last use" but may in fact be older by at most an hour.

We scan the cache for entries to delete at most once per trimInterval (1 day).

When we do scan the cache, we delete entries that have not been used for
at least trimLimit (5 days). Statistics gathered from a month of usage by
Go developers found that essentially all reuse of cached entries happened
within 5 days of the previous reuse. See golang.org/issue/22990.</p>
            
            <pre><code>trimInterval</code></pre>
         </article>
         
         <article class="global" data-name="trimLimit">
            <h2>trimLimit</h2>
            <hr />
            
            <p>Time constants for cache expiration.

We set the mtime on a cache file on each use, but at most one per mtimeInterval (1 hour),
to avoid causing many unnecessary inode updates. The mtimes therefore
roughly reflect "time of last use" but may in fact be older by at most an hour.

We scan the cache for entries to delete at most once per trimInterval (1 day).

When we do scan the cache, we delete entries that have not been used for
at least trimLimit (5 days). Statistics gathered from a month of usage by
Go developers found that essentially all reuse of cached entries happened
within 5 days of the previous reuse. See golang.org/issue/22990.</p>
            
            <pre><code>trimLimit</code></pre>
         </article>
         
         <article class="global" data-name="initDefaultCacheOnce">
            <h2>initDefaultCacheOnce</h2>
            <hr />
            
            <pre><code>initDefaultCacheOnce</code></pre>
         </article>
         
         <article class="global" data-name="cacheREADME">
            <h2>cacheREADME</h2>
            <hr />
            
            <p>cacheREADME is a message stored in a README in the cache directory.
Because the cache lives outside the normal Go trees, we leave the
README as a courtesy to explain where it came from.</p>
            
            <pre><code>cacheREADME</code></pre>
         </article>
         
         <article class="global" data-name="defaultDirOnce">
            <h2>defaultDirOnce</h2>
            <hr />
            
            <pre><code>defaultDirOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="defaultDir">
            <h2>defaultDir</h2>
            <hr />
            
            <pre><code>defaultDir string</code></pre>
         </article>
         
         <article class="global" data-name="defaultDirChanged">
            <h2>defaultDirChanged</h2>
            <hr />
            
            <pre><code>defaultDirChanged bool</code></pre>
         </article>
         
         <article class="global" data-name="defaultDirErr">
            <h2>defaultDirErr</h2>
            <hr />
            
            <pre><code>defaultDirErr error</code></pre>
         </article>
         
         <article class="global" data-name="debugHash">
            <h2>debugHash</h2>
            <hr />
            
            <pre><code>debugHash</code></pre>
         </article>
         
         <article class="global" data-name="HashSize">
            <h2>HashSize</h2>
            <hr />
            
            <p>HashSize is the number of bytes in a hash.</p>
            
            <pre><code>HashSize</code></pre>
         </article>
         
         <article class="global" data-name="hashSalt">
            <h2>hashSalt</h2>
            <hr />
            
            <p>hashSalt is a salt string added to the beginning of every hash
created by NewHash. Using the Go version makes sure that different
versions of the go command (or even different Git commits during
work on the development branch) do not address the same cache
entries, so that a bug in one version does not affect the execution
of other versions. This salt will result in additional ActionID files
in the cache, but not additional copies of the large output files,
which are still addressed by unsalted SHA256.

We strip any GOEXPERIMENTs the go tool was built with from this
version string on the assumption that they shouldn't affect go tool
execution. This allows bootstrapping to converge faster: dist builds
go_bootstrap without any experiments, so by stripping experiments
go_bootstrap and the final go binary will use the same salt.</p>
            
            <pre><code>hashSalt</code></pre>
         </article>
         
         <article class="global" data-name="hashDebug">
            <h2>hashDebug</h2>
            <hr />
            
            <p>In GODEBUG=gocacheverify=1 mode,
hashDebug holds the input to every computed hash ID,
so that we can work backward from the ID involved in a
cache entry mismatch to a description of what should be there.</p>
            
            <pre><code>hashDebug *ast.StructType</code></pre>
         </article>
         
         <article class="global" data-name="hashFileCache">
            <h2>hashFileCache</h2>
            <hr />
            
            <pre><code>hashFileCache *ast.StructType</code></pre>
         </article>
         
         <article class="global" data-name="errCacheprogClosed">
            <h2>errCacheprogClosed</h2>
            <hr />
            
            <pre><code>errCacheprogClosed</code></pre>
         </article>
          
         <article class="struct" data-name="DiskCache">
            <h2>type DiskCache struct</h2>
            <hr />
            
            <p>A Cache is a package cache, backed by a file system directory tree.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">dir string
now func</code></pre>
         </article>
         
         <article class="struct" data-name="entryNotFoundError">
            <h2>type entryNotFoundError struct</h2>
            <hr />
            
            <p>An entryNotFoundError indicates that a cache entry was not found, with an
optional underlying reason.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Err error</code></pre>
         </article>
         
         <article class="struct" data-name="Entry">
            <h2>type Entry struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">OutputID OutputID
Size int64
Time time.Time</code></pre>
         </article>
         
         <article class="struct" data-name="noVerifyReadSeeker">
            <h2>type noVerifyReadSeeker struct</h2>
            <hr />
            
            <p>noVerifyReadSeeker is an io.ReadSeeker wrapper sentinel type
that says that Cache.Put should skip the verify check
(from GODEBUG=goverifycache=1).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">io.ReadSeeker</code></pre>
         </article>
         
         <article class="struct" data-name="Hash">
            <h2>type Hash struct</h2>
            <hr />
            
            <p>A Hash provides access to the canonical hash function used to index the cache.
The current implementation uses salted SHA256, but clients must not assume this.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">h hash.Hash
name string
buf *bytes.Buffer</code></pre>
         </article>
         
         <article class="struct" data-name="ProgCache">
            <h2>type ProgCache struct</h2>
            <hr />
            
            <p>ProgCache implements Cache via JSON messages over stdin/stdout to a child
helper process which can then implement whatever caching policy/mechanism it
wants.

See https://github.com/golang/go/issues/59719</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">cmd *exec.Cmd
stdout io.ReadCloser
stdin io.WriteCloser
bw *bufio.Writer
jenc *json.Encoder
can *ast.MapType
fuzzDirCache Cache
closing atomic.Bool
ctx context.Context
ctxCancel context.CancelFunc
readLoopDone *ast.ChanType
mu sync.Mutex
nextID int64
inFlight *ast.MapType
outputFile *ast.MapType
writeMu sync.Mutex</code></pre>
         </article>
          
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <p>Open opens and returns the cache in the given directory.

It is safe for multiple processes on a single machine to use the
same cache directory in a local file system simultaneously.
They will coordinate using operating system file locks and may
duplicate effort but will not corrupt the cache.

However, it is NOT safe for multiple processes on different machines
to share a cache directory (for example, if the directory were stored
in a network file system). File locking is notoriously unreliable in
network file systems and may not suffice to protect the cache.</p>
            
            <pre><code>func Open(dir string) (*DiskCache, error)</code></pre>
         </article>
         
         <article class="function" data-name="fileName">
            <h2>fileName</h2>
            <hr />
            
            <p>fileName returns the name of the file corresponding to the given id.</p>
            
            <pre><code>func fileName(id []byte, key string) string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="initEnv">
            <h2>initEnv</h2>
            <hr />
            
            <pre><code>func initEnv()</code></pre>
         </article>
         
         <article class="function" data-name="Get">
            <h2>Get</h2>
            <hr />
            
            <p>Get looks up the action ID in the cache,
returning the corresponding output ID and file size, if any.
Note that finding an output ID does not guarantee that the
saved file for that output ID is still available.</p>
            
            <pre><code>func Get(id ActionID) (Entry, error)</code></pre>
         </article>
         
         <article class="function" data-name="get">
            <h2>get</h2>
            <hr />
            
            <p>get is Get but does not respect verify mode, so that Put can use it.</p>
            
            <pre><code>func get(id ActionID) (Entry, error)</code></pre>
         </article>
         
         <article class="function" data-name="GetFile">
            <h2>GetFile</h2>
            <hr />
            
            <p>GetFile looks up the action ID in the cache and returns
the name of the corresponding data file.</p>
            
            <pre><code>func GetFile(c Cache, id ActionID) (file string, entry Entry, err error)</code></pre>
         </article>
         
         <article class="function" data-name="GetBytes">
            <h2>GetBytes</h2>
            <hr />
            
            <p>GetBytes looks up the action ID in the cache and returns
the corresponding output bytes.
GetBytes should only be used for data that can be expected to fit in memory.</p>
            
            <pre><code>func GetBytes(c Cache, id ActionID) ([]byte, Entry, error)</code></pre>
         </article>
         
         <article class="function" data-name="GetMmap">
            <h2>GetMmap</h2>
            <hr />
            
            <p>GetMmap looks up the action ID in the cache and returns
the corresponding output bytes.
GetMmap should only be used for data that can be expected to fit in memory.</p>
            
            <pre><code>func GetMmap(c Cache, id ActionID) ([]byte, Entry, bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="OutputFile">
            <h2>OutputFile</h2>
            <hr />
            
            <p>OutputFile returns the name of the cache file storing output with the given OutputID.</p>
            
            <pre><code>func OutputFile(out OutputID) string</code></pre>
         </article>
         
         <article class="function" data-name="markUsed">
            <h2>markUsed</h2>
            <hr />
            
            <p>markUsed makes a best-effort attempt to update mtime on file,
so that mtime reflects cache access time.

Because the reflection only needs to be approximate,
and to reduce the amount of disk activity caused by using
cache entries, used only updates the mtime if the current
mtime is more than an hour old. This heuristic eliminates
nearly all of the mtime updates that would otherwise happen,
while still keeping the mtimes useful for cache trimming.

markUsed reports whether the file is a directory (an executable cache entry).</p>
            
            <pre><code>func markUsed(file string) isDir bool</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="Trim">
            <h2>Trim</h2>
            <hr />
            
            <p>Trim removes old cache entries that are likely not to be reused.</p>
            
            <pre><code>func Trim() error</code></pre>
         </article>
         
         <article class="function" data-name="trimSubdir">
            <h2>trimSubdir</h2>
            <hr />
            
            <p>trimSubdir trims a single cache subdirectory.</p>
            
            <pre><code>func trimSubdir(subdir string, cutoff time.Time)</code></pre>
         </article>
         
         <article class="function" data-name="putIndexEntry">
            <h2>putIndexEntry</h2>
            <hr />
            
            <p>putIndexEntry adds an entry to the cache recording that executing the action
with the given id produces an output with the given output id (hash) and size.</p>
            
            <pre><code>func putIndexEntry(id ActionID, out OutputID, size int64, allowVerify bool) error</code></pre>
         </article>
         
         <article class="function" data-name="Put">
            <h2>Put</h2>
            <hr />
            
            <p>Put stores the given output in the cache as the output for the action ID.
It may read file twice. The content of file must not change between the two passes.</p>
            
            <pre><code>func Put(id ActionID, file io.ReadSeeker) (OutputID, int64, error)</code></pre>
         </article>
         
         <article class="function" data-name="PutExecutable">
            <h2>PutExecutable</h2>
            <hr />
            
            <p>PutExecutable is used to store the output as the output for the action ID into a
file with the given base name, with the executable mode bit set.
It may read file twice. The content of file must not change between the two passes.</p>
            
            <pre><code>func PutExecutable(id ActionID, name string, file io.ReadSeeker) (OutputID, int64, error)</code></pre>
         </article>
         
         <article class="function" data-name="PutNoVerify">
            <h2>PutNoVerify</h2>
            <hr />
            
            <p>PutNoVerify is like Put but disables the verify check
when GODEBUG=goverifycache=1 is set.
It is meant for data that is OK to cache but that we expect to vary slightly from run to run,
like test output containing times and the like.</p>
            
            <pre><code>func PutNoVerify(c Cache, id ActionID, file io.ReadSeeker) (OutputID, int64, error)</code></pre>
         </article>
         
         <article class="function" data-name="put">
            <h2>put</h2>
            <hr />
            
            <pre><code>func put(id ActionID, executableName string, file io.ReadSeeker, allowVerify bool) (OutputID, int64, error)</code></pre>
         </article>
         
         <article class="function" data-name="PutBytes">
            <h2>PutBytes</h2>
            <hr />
            
            <p>PutBytes stores the given bytes in the cache as the output for the action ID.</p>
            
            <pre><code>func PutBytes(c Cache, id ActionID, data []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="copyFile">
            <h2>copyFile</h2>
            <hr />
            
            <p>copyFile copies file into the cache, expecting it to have the given
output ID and size, if that file is not present already.</p>
            
            <pre><code>func copyFile(file io.ReadSeeker, executableName string, out OutputID, size int64, perm os.FileMode) error</code></pre>
         </article>
         
         <article class="function" data-name="FuzzDir">
            <h2>FuzzDir</h2>
            <hr />
            
            <p>FuzzDir returns a subdirectory within the cache for storing fuzzing data.
The subdirectory may not exist.

This directory is managed by the internal/fuzz package. Files in this
directory aren't removed by the 'go clean -cache' command or by Trim.
They may be removed with 'go clean -fuzzcache'.

TODO(#48526): make Trim remove unused files from this directory.</p>
            
            <pre><code>func FuzzDir() string</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="TestBasic">
            <h2>TestBasic</h2>
            <hr />
            
            <pre><code>func TestBasic(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestGrowth">
            <h2>TestGrowth</h2>
            <hr />
            
            <pre><code>func TestGrowth(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestVerifyPanic">
            <h2>TestVerifyPanic</h2>
            <hr />
            
            <pre><code>func TestVerifyPanic(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="dummyID">
            <h2>dummyID</h2>
            <hr />
            
            <pre><code>func dummyID(x int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="TestCacheTrim">
            <h2>TestCacheTrim</h2>
            <hr />
            
            <pre><code>func TestCacheTrim(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Default">
            <h2>Default</h2>
            <hr />
            
            <p>Default returns the default cache to use.
It never returns nil.</p>
            
            <pre><code>func Default() Cache</code></pre>
         </article>
         
         <article class="function" data-name="initDefaultCache">
            <h2>initDefaultCache</h2>
            <hr />
            
            <p>initDefaultCache does the work of finding the default cache
the first time Default is called.</p>
            
            <pre><code>func initDefaultCache() Cache</code></pre>
         </article>
         
         <article class="function" data-name="DefaultDir">
            <h2>DefaultDir</h2>
            <hr />
            
            <p>DefaultDir returns the effective GOCACHE setting.
It returns "off" if the cache is disabled,
and reports whether the effective value differs from GOCACHE.</p>
            
            <pre><code>func DefaultDir() (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="stripExperiment">
            <h2>stripExperiment</h2>
            <hr />
            
            <p>stripExperiment strips any GOEXPERIMENT configuration from the Go
version string.</p>
            
            <pre><code>func stripExperiment(version string) string</code></pre>
         </article>
         
         <article class="function" data-name="Subkey">
            <h2>Subkey</h2>
            <hr />
            
            <p>Subkey returns an action ID corresponding to mixing a parent
action ID with a string description of the subkey.</p>
            
            <pre><code>func Subkey(parent ActionID, desc string) ActionID</code></pre>
         </article>
         
         <article class="function" data-name="NewHash">
            <h2>NewHash</h2>
            <hr />
            
            <p>NewHash returns a new Hash.
The caller is expected to Write data to it and then call Sum.</p>
            
            <pre><code>func NewHash(name string) *Hash</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write writes data to the running hash.</p>
            
            <pre><code>func Write(b []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Sum">
            <h2>Sum</h2>
            <hr />
            
            <p>Sum returns the hash of the data written previously.</p>
            
            <pre><code>func Sum() []byte</code></pre>
         </article>
         
         <article class="function" data-name="reverseHash">
            <h2>reverseHash</h2>
            <hr />
            
            <p>reverseHash returns the input used to compute the hash id.</p>
            
            <pre><code>func reverseHash(id []byte) string</code></pre>
         </article>
         
         <article class="function" data-name="FileHash">
            <h2>FileHash</h2>
            <hr />
            
            <p>FileHash returns the hash of the named file.
It caches repeated lookups for a given file,
and the cache entry for a file can be initialized
using SetFileHash.
The hash used by FileHash is not the same as
the hash used by NewHash.</p>
            
            <pre><code>func FileHash(file string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="SetFileHash">
            <h2>SetFileHash</h2>
            <hr />
            
            <p>SetFileHash sets the hash returned by FileHash for file.</p>
            
            <pre><code>func SetFileHash(file string, sum []byte)</code></pre>
         </article>
         
         <article class="function" data-name="TestHash">
            <h2>TestHash</h2>
            <hr />
            
            <pre><code>func TestHash(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestHashFile">
            <h2>TestHashFile</h2>
            <hr />
            
            <pre><code>func TestHashFile(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="startCacheProg">
            <h2>startCacheProg</h2>
            <hr />
            
            <p>startCacheProg starts the prog binary (with optional space-separated flags)
and returns a Cache implementation that talks to it.

It blocks a few seconds to wait for the child process to successfully start
and advertise its capabilities.</p>
            
            <pre><code>func startCacheProg(progAndArgs string, fuzzDirCache Cache) Cache</code></pre>
         </article>
         
         <article class="function" data-name="readLoop">
            <h2>readLoop</h2>
            <hr />
            
            <pre><code>func readLoop(readLoopDone *ast.ChanType)</code></pre>
         </article>
         
         <article class="function" data-name="send">
            <h2>send</h2>
            <hr />
            
            <pre><code>func send(ctx context.Context, req *cacheprog.Request) (*cacheprog.Response, error)</code></pre>
         </article>
         
         <article class="function" data-name="writeToChild">
            <h2>writeToChild</h2>
            <hr />
            
            <pre><code>func writeToChild(req *cacheprog.Request, resc *ast.ChanType) err error</code></pre>
         </article>
         
         <article class="function" data-name="Get">
            <h2>Get</h2>
            <hr />
            
            <pre><code>func Get(a ActionID) (Entry, error)</code></pre>
         </article>
         
         <article class="function" data-name="noteOutputFile">
            <h2>noteOutputFile</h2>
            <hr />
            
            <pre><code>func noteOutputFile(o OutputID, diskPath string)</code></pre>
         </article>
         
         <article class="function" data-name="OutputFile">
            <h2>OutputFile</h2>
            <hr />
            
            <pre><code>func OutputFile(o OutputID) string</code></pre>
         </article>
         
         <article class="function" data-name="Put">
            <h2>Put</h2>
            <hr />
            
            <pre><code>func Put(a ActionID, file io.ReadSeeker) (_ OutputID, size int64, _ error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="FuzzDir">
            <h2>FuzzDir</h2>
            <hr />
            
            <pre><code>func FuzzDir() string</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
