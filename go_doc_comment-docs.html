<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - comment</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>comment</code>
         </h1>
         <hr />
         
         <article class="global" data-name="oldHeadingTests">
            <h2>oldHeadingTests</h2>
            <hr />
            
            <pre><code>oldHeadingTests</code></pre>
         </article>
         
         <article class="global" data-name="autoURLTests">
            <h2>autoURLTests</h2>
            <hr />
            
            <pre><code>autoURLTests</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ spanKind</code></pre>
         </article>
         
         <article class="global" data-name="spanCode">
            <h2>spanCode</h2>
            <hr />
            
            <pre><code>spanCode</code></pre>
         </article>
         
         <article class="global" data-name="spanHeading">
            <h2>spanHeading</h2>
            <hr />
            
            <pre><code>spanHeading</code></pre>
         </article>
         
         <article class="global" data-name="spanList">
            <h2>spanList</h2>
            <hr />
            
            <pre><code>spanList</code></pre>
         </article>
         
         <article class="global" data-name="spanOldHeading">
            <h2>spanOldHeading</h2>
            <hr />
            
            <pre><code>spanOldHeading</code></pre>
         </article>
         
         <article class="global" data-name="spanPara">
            <h2>spanPara</h2>
            <hr />
            
            <pre><code>spanPara</code></pre>
         </article>
         
         <article class="global" data-name="stdPkgs">
            <h2>stdPkgs</h2>
            <hr />
            
            <pre><code>stdPkgs</code></pre>
         </article>
         
         <article class="global" data-name="wrapSeed">
            <h2>wrapSeed</h2>
            <hr />
            
            <pre><code>wrapSeed</code></pre>
         </article>
          
         <article class="struct" data-name="mdPrinter">
            <h2>type mdPrinter struct</h2>
            <hr />
            
            <p>An mdPrinter holds the state needed for printing a Doc as Markdown.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">*Printer
headingPrefix string
raw bytes.Buffer</code></pre>
         </article>
         
         <article class="struct" data-name="Doc">
            <h2>type Doc struct</h2>
            <hr />
            
            <p>A Doc is a parsed Go doc comment.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Content []Block
Links []*LinkDef</code></pre>
         </article>
         
         <article class="struct" data-name="LinkDef">
            <h2>type LinkDef struct</h2>
            <hr />
            
            <p>A LinkDef is a single link definition.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Text string
URL string
Used bool</code></pre>
         </article>
         
         <article class="struct" data-name="Heading">
            <h2>type Heading struct</h2>
            <hr />
            
            <p>A Heading is a doc comment heading.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Text []Text</code></pre>
         </article>
         
         <article class="struct" data-name="List">
            <h2>type List struct</h2>
            <hr />
            
            <p>A List is a numbered or bullet list.
Lists are always non-empty: len(Items) > 0.
In a numbered list, every Items[i].Number is a non-empty string.
In a bullet list, every Items[i].Number is an empty string.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Items []*ListItem
ForceBlankBefore bool
ForceBlankBetween bool</code></pre>
         </article>
         
         <article class="struct" data-name="ListItem">
            <h2>type ListItem struct</h2>
            <hr />
            
            <p>A ListItem is a single item in a numbered or bullet list.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Number string
Content []Block</code></pre>
         </article>
         
         <article class="struct" data-name="Paragraph">
            <h2>type Paragraph struct</h2>
            <hr />
            
            <p>A Paragraph is a paragraph of text.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Text []Text</code></pre>
         </article>
         
         <article class="struct" data-name="Code">
            <h2>type Code struct</h2>
            <hr />
            
            <p>A Code is a preformatted code block.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Text string</code></pre>
         </article>
         
         <article class="struct" data-name="Link">
            <h2>type Link struct</h2>
            <hr />
            
            <p>A Link is a link to a specific URL.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Auto bool
Text []Text
URL string</code></pre>
         </article>
         
         <article class="struct" data-name="DocLink">
            <h2>type DocLink struct</h2>
            <hr />
            
            <p>A DocLink is a link to documentation for a Go package or symbol.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Text []Text
ImportPath string
Recv string
Name string</code></pre>
         </article>
         
         <article class="struct" data-name="Parser">
            <h2>type Parser struct</h2>
            <hr />
            
            <p>A Parser is a doc comment parser.
The fields in the struct can be filled in before calling [Parser.Parse]
in order to customize the details of the parsing process.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Words *ast.MapType
LookupPackage func
LookupSym func</code></pre>
         </article>
         
         <article class="struct" data-name="parseDoc">
            <h2>type parseDoc struct</h2>
            <hr />
            
            <p>parseDoc is parsing state for a single doc comment.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">*Parser
*Doc
links *ast.MapType
lines []string
lookupSym func</code></pre>
         </article>
         
         <article class="struct" data-name="span">
            <h2>type span struct</h2>
            <hr />
            
            <p>A span represents a single span of comment lines (lines[start:end])
of an identified kind (code, heading, paragraph, and so on).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">start int
end int
kind spanKind</code></pre>
         </article>
         
         <article class="struct" data-name="Printer">
            <h2>type Printer struct</h2>
            <hr />
            
            <p>A Printer is a doc comment printer.
The fields in the struct can be filled in before calling
any of the printing methods
in order to customize the details of the printing process.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">HeadingLevel int
HeadingID func
DocLinkURL func
DocLinkBaseURL string
TextPrefix string
TextCodePrefix string
TextWidth int</code></pre>
         </article>
         
         <article class="struct" data-name="commentPrinter">
            <h2>type commentPrinter struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">*Printer</code></pre>
         </article>
         
         <article class="struct" data-name="textPrinter">
            <h2>type textPrinter struct</h2>
            <hr />
            
            <p>A textPrinter holds the state needed for printing a Doc as plain text.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">*Printer
long strings.Builder
prefix string
codePrefix string
width int</code></pre>
         </article>
         
         <article class="struct" data-name="htmlPrinter">
            <h2>type htmlPrinter struct</h2>
            <hr />
            
            <p>An htmlPrinter holds the state needed for printing a [Doc] as HTML.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">*Printer
tight bool</code></pre>
         </article>
          
         <article class="function" data-name="Markdown">
            <h2>Markdown</h2>
            <hr />
            
            <p>Markdown returns a Markdown formatting of the Doc.
See the [Printer] documentation for ways to customize the Markdown output.</p>
            
            <pre><code>func Markdown(d *Doc) []byte</code></pre>
         </article>
         
         <article class="function" data-name="block">
            <h2>block</h2>
            <hr />
            
            <p>block prints the block x to out.</p>
            
            <pre><code>func block(out *bytes.Buffer, x Block)</code></pre>
         </article>
         
         <article class="function" data-name="text">
            <h2>text</h2>
            <hr />
            
            <p>text prints the text sequence x to out.</p>
            
            <pre><code>func text(out *bytes.Buffer, x []Text)</code></pre>
         </article>
         
         <article class="function" data-name="rawText">
            <h2>rawText</h2>
            <hr />
            
            <p>rawText prints the text sequence x to out,
without worrying about escaping characters
that have special meaning at the start of a Markdown line.</p>
            
            <pre><code>func rawText(out *bytes.Buffer, x []Text)</code></pre>
         </article>
         
         <article class="function" data-name="escape">
            <h2>escape</h2>
            <hr />
            
            <p>escape prints s to out as plain text,
escaping special characters to avoid being misinterpreted
as Markdown markup sequences.</p>
            
            <pre><code>func escape(out *bytes.Buffer, s string)</code></pre>
         </article>
         
         <article class="function" data-name="TestIsOldHeading">
            <h2>TestIsOldHeading</h2>
            <hr />
            
            <pre><code>func TestIsOldHeading(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAutoURL">
            <h2>TestAutoURL</h2>
            <hr />
            
            <pre><code>func TestAutoURL(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="block">
            <h2>block</h2>
            <hr />
            
            <pre><code>func block()</code></pre>
         </article>
         
         <article class="function" data-name="block">
            <h2>block</h2>
            <hr />
            
            <pre><code>func block()</code></pre>
         </article>
         
         <article class="function" data-name="BlankBefore">
            <h2>BlankBefore</h2>
            <hr />
            
            <p>BlankBefore reports whether a reformatting of the comment
should include a blank line before the list.
The default rule is the same as for [BlankBetween]:
if the list item content contains any blank lines
(meaning at least one item has multiple paragraphs)
then the list itself must be preceded by a blank line.
A preceding blank line can be forced by setting [List].ForceBlankBefore.</p>
            
            <pre><code>func BlankBefore() bool</code></pre>
         </article>
         
         <article class="function" data-name="BlankBetween">
            <h2>BlankBetween</h2>
            <hr />
            
            <p>BlankBetween reports whether a reformatting of the comment
should include a blank line between each pair of list items.
The default rule is that if the list item content contains any blank lines
(meaning at least one item has multiple paragraphs)
then list items must themselves be separated by blank lines.
Blank line separators can be forced by setting [List].ForceBlankBetween.</p>
            
            <pre><code>func BlankBetween() bool</code></pre>
         </article>
         
         <article class="function" data-name="block">
            <h2>block</h2>
            <hr />
            
            <pre><code>func block()</code></pre>
         </article>
         
         <article class="function" data-name="block">
            <h2>block</h2>
            <hr />
            
            <pre><code>func block()</code></pre>
         </article>
         
         <article class="function" data-name="text">
            <h2>text</h2>
            <hr />
            
            <pre><code>func text()</code></pre>
         </article>
         
         <article class="function" data-name="text">
            <h2>text</h2>
            <hr />
            
            <pre><code>func text()</code></pre>
         </article>
         
         <article class="function" data-name="text">
            <h2>text</h2>
            <hr />
            
            <pre><code>func text()</code></pre>
         </article>
         
         <article class="function" data-name="text">
            <h2>text</h2>
            <hr />
            
            <pre><code>func text()</code></pre>
         </article>
         
         <article class="function" data-name="lookupPkg">
            <h2>lookupPkg</h2>
            <hr />
            
            <p>lookupPkg is called to look up the pkg in [pkg], [pkg.Name], and [pkg.Name.Recv].
If pkg has a slash, it is assumed to be the full import path and is returned with ok = true.

Otherwise, pkg is probably a simple package name like "rand" (not "crypto/rand" or "math/rand").
d.LookupPackage provides a way for the caller to allow resolving such names with reference
to the imports in the surrounding package.

There is one collision between these two cases: single-element standard library names
like "math" are full import paths but don't contain slashes. We let d.LookupPackage have
the first chance to resolve it, in case there's a different package imported as math,
and otherwise we refer to a built-in list of single-element standard library package names.</p>
            
            <pre><code>func lookupPkg(pkg string) (importPath string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="isStdPkg">
            <h2>isStdPkg</h2>
            <hr />
            
            <pre><code>func isStdPkg(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="DefaultLookupPackage">
            <h2>DefaultLookupPackage</h2>
            <hr />
            
            <p>DefaultLookupPackage is the default package lookup
function, used when [Parser.LookupPackage] is nil.
It recognizes names of the packages from the standard
library with single-element import paths, such as math,
which would otherwise be impossible to name.

Note that the go/doc package provides a more sophisticated
lookup based on the imports used in the current package.</p>
            
            <pre><code>func DefaultLookupPackage(name string) (importPath string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="Parse">
            <h2>Parse</h2>
            <hr />
            
            <p>Parse parses the doc comment text and returns the *[Doc] form.
Comment markers (/* // and */) in the text must have already been removed.</p>
            
            <pre><code>func Parse(text string) *Doc</code></pre>
         </article>
         
         <article class="function" data-name="parseSpans">
            <h2>parseSpans</h2>
            <hr />
            
            <pre><code>func parseSpans(lines []string) []span</code></pre>
         </article>
         
         <article class="function" data-name="indented">
            <h2>indented</h2>
            <hr />
            
            <p>indented reports whether line is indented
(starts with a leading space or tab).</p>
            
            <pre><code>func indented(line string) bool</code></pre>
         </article>
         
         <article class="function" data-name="unindent">
            <h2>unindent</h2>
            <hr />
            
            <p>unindent removes any common space/tab prefix
from each line in lines, returning a copy of lines in which
those prefixes have been trimmed from each line.
It also replaces any lines containing only spaces with blank lines (empty strings).</p>
            
            <pre><code>func unindent(lines []string) []string</code></pre>
         </article>
         
         <article class="function" data-name="isBlank">
            <h2>isBlank</h2>
            <hr />
            
            <p>isBlank reports whether s is a blank line.</p>
            
            <pre><code>func isBlank(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="commonPrefix">
            <h2>commonPrefix</h2>
            <hr />
            
            <p>commonPrefix returns the longest common prefix of a and b.</p>
            
            <pre><code>func commonPrefix(a string, b string) string</code></pre>
         </article>
         
         <article class="function" data-name="leadingSpace">
            <h2>leadingSpace</h2>
            <hr />
            
            <p>leadingSpace returns the longest prefix of s consisting of spaces and tabs.</p>
            
            <pre><code>func leadingSpace(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="isOldHeading">
            <h2>isOldHeading</h2>
            <hr />
            
            <p>isOldHeading reports whether line is an old-style section heading.
line is all[off].</p>
            
            <pre><code>func isOldHeading(line string, all []string, off int) bool</code></pre>
         </article>
         
         <article class="function" data-name="oldHeading">
            <h2>oldHeading</h2>
            <hr />
            
            <p>oldHeading returns the *Heading for the given old-style section heading line.</p>
            
            <pre><code>func oldHeading(line string) Block</code></pre>
         </article>
         
         <article class="function" data-name="isHeading">
            <h2>isHeading</h2>
            <hr />
            
            <p>isHeading reports whether line is a new-style section heading.</p>
            
            <pre><code>func isHeading(line string) bool</code></pre>
         </article>
         
         <article class="function" data-name="heading">
            <h2>heading</h2>
            <hr />
            
            <p>heading returns the *Heading for the given new-style section heading line.</p>
            
            <pre><code>func heading(line string) Block</code></pre>
         </article>
         
         <article class="function" data-name="code">
            <h2>code</h2>
            <hr />
            
            <p>code returns a code block built from the lines.</p>
            
            <pre><code>func code(lines []string) *Code</code></pre>
         </article>
         
         <article class="function" data-name="paragraph">
            <h2>paragraph</h2>
            <hr />
            
            <p>paragraph returns a paragraph block built from the lines.
If the lines are link definitions, paragraph adds them to d and returns nil.</p>
            
            <pre><code>func paragraph(lines []string) Block</code></pre>
         </article>
         
         <article class="function" data-name="parseLink">
            <h2>parseLink</h2>
            <hr />
            
            <p>parseLink parses a single link definition line:

	[text]: url

It returns the link definition and whether the line was well formed.</p>
            
            <pre><code>func parseLink(line string) (*LinkDef, bool)</code></pre>
         </article>
         
         <article class="function" data-name="list">
            <h2>list</h2>
            <hr />
            
            <p>list returns a list built from the indented lines,
using forceBlankBefore as the value of the List's ForceBlankBefore field.</p>
            
            <pre><code>func list(lines []string, forceBlankBefore bool) *List</code></pre>
         </article>
         
         <article class="function" data-name="listMarker">
            <h2>listMarker</h2>
            <hr />
            
            <p>listMarker parses the line as beginning with a list marker.
If it can do that, it returns the numeric marker ("" for a bullet list),
the rest of the line, and ok == true.
Otherwise, it returns "", "", false.</p>
            
            <pre><code>func listMarker(line string) (num string, rest string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="isList">
            <h2>isList</h2>
            <hr />
            
            <p>isList reports whether the line is the first line of a list,
meaning starts with a list marker after any indentation.
(The caller is responsible for checking the line is indented, as appropriate.)</p>
            
            <pre><code>func isList(line string) bool</code></pre>
         </article>
         
         <article class="function" data-name="parseLinkedText">
            <h2>parseLinkedText</h2>
            <hr />
            
            <p>parseLinkedText parses text that is allowed to contain explicit links,
such as [math.Sin] or [Go home page], into a slice of Text items.

A “pkg” is only assumed to be a full import path if it starts with
a domain name (a path element with a dot) or is one of the packages
from the standard library (“[os]”, “[encoding/json]”, and so on).
To avoid problems with maps, generics, and array types, doc links
must be both preceded and followed by punctuation, spaces, tabs,
or the start or end of a line. An example problem would be treating
map[ast.Expr]TypeAndValue as containing a link.</p>
            
            <pre><code>func parseLinkedText(text string) []Text</code></pre>
         </article>
         
         <article class="function" data-name="docLink">
            <h2>docLink</h2>
            <hr />
            
            <p>docLink parses text, which was found inside [ ] brackets,
as a doc link if possible, returning the DocLink and ok == true
or else nil, false.
The before and after strings are the text before the [ and after the ]
on the same line. Doc links must be preceded and followed by
punctuation, spaces, tabs, or the start or end of a line.</p>
            
            <pre><code>func docLink(text string, before string, after string) (link *DocLink, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="splitDocName">
            <h2>splitDocName</h2>
            <hr />
            
            <p>If text is of the form before.Name, where Name is a capitalized Go identifier,
then splitDocName returns before, name, true.
Otherwise it returns text, "", false.</p>
            
            <pre><code>func splitDocName(text string) (before string, name string, foundDot bool)</code></pre>
         </article>
         
         <article class="function" data-name="parseText">
            <h2>parseText</h2>
            <hr />
            
            <p>parseText parses s as text and returns the result of appending
those parsed Text elements to out.
parseText does not handle explicit links like [math.Sin] or [Go home page]:
those are handled by parseLinkedText.
If autoLink is true, then parseText recognizes URLs and words from d.Words
and converts those to links as appropriate.</p>
            
            <pre><code>func parseText(out []Text, s string, autoLink bool) []Text</code></pre>
         </article>
         
         <article class="function" data-name="autoURL">
            <h2>autoURL</h2>
            <hr />
            
            <p>autoURL checks whether s begins with a URL that should be hyperlinked.
If so, it returns the URL, which is a prefix of s, and ok == true.
Otherwise it returns "", false.
The caller should skip over the first len(url) bytes of s
before further processing.</p>
            
            <pre><code>func autoURL(s string) (url string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="isScheme">
            <h2>isScheme</h2>
            <hr />
            
            <p>isScheme reports whether s is a recognized URL scheme.
Note that if strings of new length (beyond 3-7)
are added here, the fast path at the top of autoURL will need updating.</p>
            
            <pre><code>func isScheme(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="isHost">
            <h2>isHost</h2>
            <hr />
            
            <p>isHost reports whether c is a byte that can appear in a URL host,
like www.example.com or user@[::1]:8080</p>
            
            <pre><code>func isHost(c byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="isPunct">
            <h2>isPunct</h2>
            <hr />
            
            <p>isPunct reports whether c is a punctuation byte that can appear
inside a path but not at the end.</p>
            
            <pre><code>func isPunct(c byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="isPath">
            <h2>isPath</h2>
            <hr />
            
            <p>isPath reports whether c is a (non-punctuation) path byte.</p>
            
            <pre><code>func isPath(c byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="isName">
            <h2>isName</h2>
            <hr />
            
            <p>isName reports whether s is a capitalized Go identifier (like Name).</p>
            
            <pre><code>func isName(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="ident">
            <h2>ident</h2>
            <hr />
            
            <p>ident checks whether s begins with a Go identifier.
If so, it returns the identifier, which is a prefix of s, and ok == true.
Otherwise it returns "", false.
The caller should skip over the first len(id) bytes of s
before further processing.</p>
            
            <pre><code>func ident(s string) (id string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="isIdentASCII">
            <h2>isIdentASCII</h2>
            <hr />
            
            <p>isIdentASCII reports whether c is an ASCII identifier byte.</p>
            
            <pre><code>func isIdentASCII(c byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="validImportPath">
            <h2>validImportPath</h2>
            <hr />
            
            <p>validImportPath reports whether path is a valid import path.
It is a lightly edited copy of golang.org/x/mod/module.CheckImportPath.</p>
            
            <pre><code>func validImportPath(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="validImportPathElem">
            <h2>validImportPathElem</h2>
            <hr />
            
            <pre><code>func validImportPathElem(elem string) bool</code></pre>
         </article>
         
         <article class="function" data-name="importPathOK">
            <h2>importPathOK</h2>
            <hr />
            
            <pre><code>func importPathOK(c byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="headingLevel">
            <h2>headingLevel</h2>
            <hr />
            
            <pre><code>func headingLevel() int</code></pre>
         </article>
         
         <article class="function" data-name="headingID">
            <h2>headingID</h2>
            <hr />
            
            <pre><code>func headingID(h *Heading) string</code></pre>
         </article>
         
         <article class="function" data-name="docLinkURL">
            <h2>docLinkURL</h2>
            <hr />
            
            <pre><code>func docLinkURL(link *DocLink) string</code></pre>
         </article>
         
         <article class="function" data-name="DefaultURL">
            <h2>DefaultURL</h2>
            <hr />
            
            <p>DefaultURL constructs and returns the documentation URL for l,
using baseURL as a prefix for links to other packages.

The possible forms returned by DefaultURL are:
  - baseURL/ImportPath, for a link to another package
  - baseURL/ImportPath#Name, for a link to a const, func, type, or var in another package
  - baseURL/ImportPath#Recv.Name, for a link to a method in another package
  - #Name, for a link to a const, func, type, or var in this package
  - #Recv.Name, for a link to a method in this package

If baseURL ends in a trailing slash, then DefaultURL inserts
a slash between ImportPath and # in the anchored forms.
For example, here are some baseURL values and URLs they can generate:

	"/pkg/" → "/pkg/math/#Sqrt"
	"/pkg"  → "/pkg/math#Sqrt"
	"/"     → "/math/#Sqrt"
	""      → "/math#Sqrt"</p>
            
            <pre><code>func DefaultURL(baseURL string) string</code></pre>
         </article>
         
         <article class="function" data-name="DefaultID">
            <h2>DefaultID</h2>
            <hr />
            
            <p>DefaultID returns the default anchor ID for the heading h.

The default anchor ID is constructed by converting every
rune that is not alphanumeric ASCII to an underscore
and then adding the prefix “hdr-”.
For example, if the heading text is “Go Doc Comments”,
the default ID is “hdr-Go_Doc_Comments”.</p>
            
            <pre><code>func DefaultID() string</code></pre>
         </article>
         
         <article class="function" data-name="Comment">
            <h2>Comment</h2>
            <hr />
            
            <p>Comment returns the standard Go formatting of the [Doc],
without any comment markers.</p>
            
            <pre><code>func Comment(d *Doc) []byte</code></pre>
         </article>
         
         <article class="function" data-name="blankBefore">
            <h2>blankBefore</h2>
            <hr />
            
            <p>blankBefore reports whether the block x requires a blank line before it.
All blocks do, except for Lists that return false from x.BlankBefore().</p>
            
            <pre><code>func blankBefore(x Block) bool</code></pre>
         </article>
         
         <article class="function" data-name="block">
            <h2>block</h2>
            <hr />
            
            <p>block prints the block x to out.</p>
            
            <pre><code>func block(out *bytes.Buffer, x Block)</code></pre>
         </article>
         
         <article class="function" data-name="text">
            <h2>text</h2>
            <hr />
            
            <p>text prints the text sequence x to out.</p>
            
            <pre><code>func text(out *bytes.Buffer, indent string, x []Text)</code></pre>
         </article>
         
         <article class="function" data-name="indent">
            <h2>indent</h2>
            <hr />
            
            <p>indent prints s to out, indenting with the indent string
after each newline in s.</p>
            
            <pre><code>func indent(out *bytes.Buffer, indent string, s string)</code></pre>
         </article>
         
         <article class="function" data-name="TestStd">
            <h2>TestStd</h2>
            <hr />
            
            <pre><code>func TestStd(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Text">
            <h2>Text</h2>
            <hr />
            
            <p>Text returns a textual formatting of the [Doc].
See the [Printer] documentation for ways to customize the text output.</p>
            
            <pre><code>func Text(d *Doc) []byte</code></pre>
         </article>
         
         <article class="function" data-name="writeNL">
            <h2>writeNL</h2>
            <hr />
            
            <p>writeNL calls out.WriteByte('\n')
but first trims trailing spaces on the previous line.</p>
            
            <pre><code>func writeNL(out *bytes.Buffer)</code></pre>
         </article>
         
         <article class="function" data-name="block">
            <h2>block</h2>
            <hr />
            
            <p>block prints the block x to out.</p>
            
            <pre><code>func block(out *bytes.Buffer, x Block)</code></pre>
         </article>
         
         <article class="function" data-name="text">
            <h2>text</h2>
            <hr />
            
            <p>text prints the text sequence x to out.</p>
            
            <pre><code>func text(out *bytes.Buffer, indent string, x []Text)</code></pre>
         </article>
         
         <article class="function" data-name="oneLongLine">
            <h2>oneLongLine</h2>
            <hr />
            
            <p>oneLongLine prints the text sequence x to out as one long line,
without worrying about line wrapping.
Explicit links have the [ ] dropped to improve readability.</p>
            
            <pre><code>func oneLongLine(out *strings.Builder, x []Text)</code></pre>
         </article>
         
         <article class="function" data-name="wrap">
            <h2>wrap</h2>
            <hr />
            
            <p>wrap wraps words into lines of at most max runes,
minimizing the sum of the squares of the leftover lengths
at the end of each line (except the last, of course),
with a preference for ending lines at punctuation (.,:;).

The returned slice gives the indexes of the first words
on each line in the wrapped text with a final entry of len(words).
Thus the lines are words[seq[0]:seq[1]], words[seq[1]:seq[2]],
..., words[seq[len(seq)-2]:seq[len(seq)-1]].

The implementation runs in O(n log n) time, where n = len(words),
using the algorithm described in D. S. Hirschberg and L. L. Larmore,
“[The least weight subsequence problem],” FOCS 1985, pp. 137-143.

[The least weight subsequence problem]: https://doi.org/10.1109/SFCS.1985.60</p>
            
            <pre><code>func wrap(words []string, max int) seq []int</code></pre>
         </article>
         
         <article class="function" data-name="wrapPenalty">
            <h2>wrapPenalty</h2>
            <hr />
            
            <p>wrapPenalty is the penalty for inserting a line break after word s.</p>
            
            <pre><code>func wrapPenalty(s string) int64</code></pre>
         </article>
         
         <article class="function" data-name="HTML">
            <h2>HTML</h2>
            <hr />
            
            <p>HTML returns an HTML formatting of the [Doc].
See the [Printer] documentation for ways to customize the HTML output.</p>
            
            <pre><code>func HTML(d *Doc) []byte</code></pre>
         </article>
         
         <article class="function" data-name="block">
            <h2>block</h2>
            <hr />
            
            <p>block prints the block x to out.</p>
            
            <pre><code>func block(out *bytes.Buffer, x Block)</code></pre>
         </article>
         
         <article class="function" data-name="inc">
            <h2>inc</h2>
            <hr />
            
            <p>inc increments the decimal string s.
For example, inc("1199") == "1200".</p>
            
            <pre><code>func inc(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="text">
            <h2>text</h2>
            <hr />
            
            <p>text prints the text sequence x to out.</p>
            
            <pre><code>func text(out *bytes.Buffer, x []Text)</code></pre>
         </article>
         
         <article class="function" data-name="escape">
            <h2>escape</h2>
            <hr />
            
            <p>escape prints s to out as plain text,
escaping < & " ' and > to avoid being misinterpreted
in larger HTML constructs.</p>
            
            <pre><code>func escape(out *bytes.Buffer, s string)</code></pre>
         </article>
         
         <article class="function" data-name="Test52353">
            <h2>Test52353</h2>
            <hr />
            
            <p>See https://golang.org/issue/52353</p>
            
            <pre><code>func Test52353(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestTestdata">
            <h2>TestTestdata</h2>
            <hr />
            
            <pre><code>func TestTestdata(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="dump">
            <h2>dump</h2>
            <hr />
            
            <pre><code>func dump(d *Doc) []byte</code></pre>
         </article>
         
         <article class="function" data-name="dumpTo">
            <h2>dumpTo</h2>
            <hr />
            
            <pre><code>func dumpTo(out *bytes.Buffer, indent int, x any)</code></pre>
         </article>
         
         <article class="function" data-name="dumpNL">
            <h2>dumpNL</h2>
            <hr />
            
            <pre><code>func dumpNL(out *bytes.Buffer, n int)</code></pre>
         </article>
         
         <article class="function" data-name="TestWrap">
            <h2>TestWrap</h2>
            <hr />
            
            <pre><code>func TestWrap(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="wrapSlow">
            <h2>wrapSlow</h2>
            <hr />
            
            <p>wrapSlow is an O(n²) reference implementation for wrap.
It returns a minimal-score sequence along with the score.
It is OK if wrap returns a different sequence as long as that
sequence has the same score.</p>
            
            <pre><code>func wrapSlow(words []string, max int) (seq []int, score int64)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
