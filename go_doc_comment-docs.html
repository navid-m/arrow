<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - comment</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>comment</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"bytes"
"fmt"
"sort"
"strings"
"unicode/utf8"
"bytes"
"fmt"
"strconv"
"bytes"
"fmt"
"strings"
"slices"
"strings"
"unicode"
"unicode/utf8"
"bytes"
"fmt"
"strings"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">const _ spanKind = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="spanCode" data-name="spanCode">
               <h3>
                  spanCode 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#spanCode" class="anchor" title="Link to spanCode">#</a>
               </h3>
               
               <pre><code class="language-go">const spanCode</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="spanHeading" data-name="spanHeading">
               <h3>
                  spanHeading 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#spanHeading" class="anchor" title="Link to spanHeading">#</a>
               </h3>
               
               <pre><code class="language-go">const spanHeading</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="spanList" data-name="spanList">
               <h3>
                  spanList 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#spanList" class="anchor" title="Link to spanList">#</a>
               </h3>
               
               <pre><code class="language-go">const spanList</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="spanOldHeading" data-name="spanOldHeading">
               <h3>
                  spanOldHeading 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#spanOldHeading" class="anchor" title="Link to spanOldHeading">#</a>
               </h3>
               
               <pre><code class="language-go">const spanOldHeading</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="spanPara" data-name="spanPara">
               <h3>
                  spanPara 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#spanPara" class="anchor" title="Link to spanPara">#</a>
               </h3>
               
               <pre><code class="language-go">const spanPara</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdPkgs" data-name="stdPkgs">
               <h3>
                  stdPkgs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#stdPkgs" class="anchor" title="Link to stdPkgs">#</a>
               </h3>
               
               <pre><code class="language-go">var stdPkgs = []string{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="Italic" data-name="Italic">
               <h3>
                  Italic
                  <span class="badge type-badge">type</span>
                  <a href="#Italic" class="anchor" title="Link to Italic">#</a>
               </h3>
               
               <p>An Italic is a string rendered as italicized text.</p>
               
               <pre><code class="language-go">type Italic string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Plain" data-name="Plain">
               <h3>
                  Plain
                  <span class="badge type-badge">type</span>
                  <a href="#Plain" class="anchor" title="Link to Plain">#</a>
               </h3>
               
               <p>A Plain is a string rendered as plain text (not italicized).</p>
               
               <pre><code class="language-go">type Plain string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="spanKind" data-name="spanKind">
               <h3>
                  spanKind
                  <span class="badge type-badge">type</span>
                  <a href="#spanKind" class="anchor" title="Link to spanKind">#</a>
               </h3>
               
               <p>A spanKind describes the kind of span.</p>
               
               <pre><code class="language-go">type spanKind int</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Block" data-name="Block">
               <h3>
                  Block
                  <span class="badge interface-badge">interface</span>
                  <a href="#Block" class="anchor" title="Link to Block">#</a>
               </h3>
               
               <p>A Block is block-level content in a doc comment,
one of [*Code], [*Heading], [*List], or [*Paragraph].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Block interface {
block()
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Text" data-name="Text">
               <h3>
                  Text
                  <span class="badge interface-badge">interface</span>
                  <a href="#Text" class="anchor" title="Link to Text">#</a>
               </h3>
               
               <p>A Text is text-level content in a doc comment,
one of [Plain], [Italic], [*Link], or [*DocLink].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Text interface {
text()
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Code" data-name="Code">
               <h3>
                  Code
                  <span class="badge">struct</span>
                  <a href="#Code" class="anchor" title="Link to Code">#</a>
               </h3>
               
               <p>A Code is a preformatted code block.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Code struct {
Text string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Doc" data-name="Doc">
               <h3>
                  Doc
                  <span class="badge">struct</span>
                  <a href="#Doc" class="anchor" title="Link to Doc">#</a>
               </h3>
               
               <p>A Doc is a parsed Go doc comment.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Doc struct {
Content []Block
Links []*LinkDef
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="DocLink" data-name="DocLink">
               <h3>
                  DocLink
                  <span class="badge">struct</span>
                  <a href="#DocLink" class="anchor" title="Link to DocLink">#</a>
               </h3>
               
               <p>A DocLink is a link to documentation for a Go package or symbol.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type DocLink struct {
Text []Text
ImportPath string
Recv string
Name string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Heading" data-name="Heading">
               <h3>
                  Heading
                  <span class="badge">struct</span>
                  <a href="#Heading" class="anchor" title="Link to Heading">#</a>
               </h3>
               
               <p>A Heading is a doc comment heading.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Heading struct {
Text []Text
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Link" data-name="Link">
               <h3>
                  Link
                  <span class="badge">struct</span>
                  <a href="#Link" class="anchor" title="Link to Link">#</a>
               </h3>
               
               <p>A Link is a link to a specific URL.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Link struct {
Auto bool
Text []Text
URL string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="LinkDef" data-name="LinkDef">
               <h3>
                  LinkDef
                  <span class="badge">struct</span>
                  <a href="#LinkDef" class="anchor" title="Link to LinkDef">#</a>
               </h3>
               
               <p>A LinkDef is a single link definition.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type LinkDef struct {
Text string
URL string
Used bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="List" data-name="List">
               <h3>
                  List
                  <span class="badge">struct</span>
                  <a href="#List" class="anchor" title="Link to List">#</a>
               </h3>
               
               <p>A List is a numbered or bullet list.
Lists are always non-empty: len(Items) > 0.
In a numbered list, every Items[i].Number is a non-empty string.
In a bullet list, every Items[i].Number is an empty string.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type List struct {
Items []*ListItem
ForceBlankBefore bool
ForceBlankBetween bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ListItem" data-name="ListItem">
               <h3>
                  ListItem
                  <span class="badge">struct</span>
                  <a href="#ListItem" class="anchor" title="Link to ListItem">#</a>
               </h3>
               
               <p>A ListItem is a single item in a numbered or bullet list.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ListItem struct {
Number string
Content []Block
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Paragraph" data-name="Paragraph">
               <h3>
                  Paragraph
                  <span class="badge">struct</span>
                  <a href="#Paragraph" class="anchor" title="Link to Paragraph">#</a>
               </h3>
               
               <p>A Paragraph is a paragraph of text.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Paragraph struct {
Text []Text
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Parser" data-name="Parser">
               <h3>
                  Parser
                  <span class="badge">struct</span>
                  <a href="#Parser" class="anchor" title="Link to Parser">#</a>
               </h3>
               
               <p>A Parser is a doc comment parser.
The fields in the struct can be filled in before calling [Parser.Parse]
in order to customize the details of the parsing process.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Parser struct {
Words map[string]string
LookupPackage func(name string) (importPath string, ok bool)
LookupSym func(recv string, name string) ok bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Printer" data-name="Printer">
               <h3>
                  Printer
                  <span class="badge">struct</span>
                  <a href="#Printer" class="anchor" title="Link to Printer">#</a>
               </h3>
               
               <p>A Printer is a doc comment printer.
The fields in the struct can be filled in before calling
any of the printing methods
in order to customize the details of the printing process.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Printer struct {
HeadingLevel int
HeadingID func(h *Heading) string
DocLinkURL func(link *DocLink) string
DocLinkBaseURL string
TextPrefix string
TextCodePrefix string
TextWidth int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="commentPrinter" data-name="commentPrinter">
               <h3>
                  commentPrinter
                  <span class="badge">struct</span>
                  <a href="#commentPrinter" class="anchor" title="Link to commentPrinter">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type commentPrinter struct {
*Printer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="htmlPrinter" data-name="htmlPrinter">
               <h3>
                  htmlPrinter
                  <span class="badge">struct</span>
                  <a href="#htmlPrinter" class="anchor" title="Link to htmlPrinter">#</a>
               </h3>
               
               <p>An htmlPrinter holds the state needed for printing a [Doc] as HTML.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type htmlPrinter struct {
*Printer
tight bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="mdPrinter" data-name="mdPrinter">
               <h3>
                  mdPrinter
                  <span class="badge">struct</span>
                  <a href="#mdPrinter" class="anchor" title="Link to mdPrinter">#</a>
               </h3>
               
               <p>An mdPrinter holds the state needed for printing a Doc as Markdown.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type mdPrinter struct {
*Printer
headingPrefix string
raw bytes.Buffer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="parseDoc" data-name="parseDoc">
               <h3>
                  parseDoc
                  <span class="badge">struct</span>
                  <a href="#parseDoc" class="anchor" title="Link to parseDoc">#</a>
               </h3>
               
               <p>parseDoc is parsing state for a single doc comment.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type parseDoc struct {
*Parser
*Doc
links map[string]*LinkDef
lines []string
lookupSym func(recv string, name string) bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="span" data-name="span">
               <h3>
                  span
                  <span class="badge">struct</span>
                  <a href="#span" class="anchor" title="Link to span">#</a>
               </h3>
               
               <p>A span represents a single span of comment lines (lines[start:end])
of an identified kind (code, heading, paragraph, and so on).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type span struct {
start int
end int
kind spanKind
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="textPrinter" data-name="textPrinter">
               <h3>
                  textPrinter
                  <span class="badge">struct</span>
                  <a href="#textPrinter" class="anchor" title="Link to textPrinter">#</a>
               </h3>
               
               <p>A textPrinter holds the state needed for printing a Doc as plain text.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type textPrinter struct {
*Printer
long strings.Builder
prefix string
codePrefix string
width int
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="BlankBefore" data-name="BlankBefore">
               <h3>
                  BlankBefore 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BlankBefore" class="anchor" title="Link to BlankBefore">#</a>
               </h3>
               
               <p>BlankBefore reports whether a reformatting of the comment
should include a blank line before the list.
The default rule is the same as for [BlankBetween]:
if the list item content contains any blank lines
(meaning at least one item has multiple paragraphs)
then the list itself must be preceded by a blank line.
A preceding blank line can be forced by setting [List].ForceBlankBefore.</p>
               
               <pre><code class="language-go">func (l *List) BlankBefore() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BlankBetween" data-name="BlankBetween">
               <h3>
                  BlankBetween 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BlankBetween" class="anchor" title="Link to BlankBetween">#</a>
               </h3>
               
               <p>BlankBetween reports whether a reformatting of the comment
should include a blank line between each pair of list items.
The default rule is that if the list item content contains any blank lines
(meaning at least one item has multiple paragraphs)
then list items must themselves be separated by blank lines.
Blank line separators can be forced by setting [List].ForceBlankBetween.</p>
               
               <pre><code class="language-go">func (l *List) BlankBetween() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Comment" data-name="Comment">
               <h3>
                  Comment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Comment" class="anchor" title="Link to Comment">#</a>
               </h3>
               
               <p>Comment returns the standard Go formatting of the [Doc],
without any comment markers.</p>
               
               <pre><code class="language-go">func (p *Printer) Comment(d *Doc) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DefaultID" data-name="DefaultID">
               <h3>
                  DefaultID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DefaultID" class="anchor" title="Link to DefaultID">#</a>
               </h3>
               
               <p>DefaultID returns the default anchor ID for the heading h.
The default anchor ID is constructed by converting every
rune that is not alphanumeric ASCII to an underscore
and then adding the prefix “hdr-”.
For example, if the heading text is “Go Doc Comments”,
the default ID is “hdr-Go_Doc_Comments”.</p>
               
               <pre><code class="language-go">func (h *Heading) DefaultID() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DefaultLookupPackage" data-name="DefaultLookupPackage">
               <h3>
                  DefaultLookupPackage 
                  <span class="badge">function</span>
                  
                  <a href="#DefaultLookupPackage" class="anchor" title="Link to DefaultLookupPackage">#</a>
               </h3>
               
               <p>DefaultLookupPackage is the default package lookup
function, used when [Parser.LookupPackage] is nil.
It recognizes names of the packages from the standard
library with single-element import paths, such as math,
which would otherwise be impossible to name.
Note that the go/doc package provides a more sophisticated
lookup based on the imports used in the current package.</p>
               
               <pre><code class="language-go">func DefaultLookupPackage(name string) (importPath string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DefaultURL" data-name="DefaultURL">
               <h3>
                  DefaultURL 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DefaultURL" class="anchor" title="Link to DefaultURL">#</a>
               </h3>
               
               <p>DefaultURL constructs and returns the documentation URL for l,
using baseURL as a prefix for links to other packages.
The possible forms returned by DefaultURL are:
- baseURL/ImportPath, for a link to another package
- baseURL/ImportPath#Name, for a link to a const, func, type, or var in another package
- baseURL/ImportPath#Recv.Name, for a link to a method in another package
- #Name, for a link to a const, func, type, or var in this package
- #Recv.Name, for a link to a method in this package
If baseURL ends in a trailing slash, then DefaultURL inserts
a slash between ImportPath and # in the anchored forms.
For example, here are some baseURL values and URLs they can generate:
"/pkg/" → "/pkg/math/#Sqrt"
"/pkg"  → "/pkg/math#Sqrt"
"/"     → "/math/#Sqrt"
""      → "/math#Sqrt"</p>
               
               <pre><code class="language-go">func (l *DocLink) DefaultURL(baseURL string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HTML" data-name="HTML">
               <h3>
                  HTML 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HTML" class="anchor" title="Link to HTML">#</a>
               </h3>
               
               <p>HTML returns an HTML formatting of the [Doc].
See the [Printer] documentation for ways to customize the HTML output.</p>
               
               <pre><code class="language-go">func (p *Printer) HTML(d *Doc) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Markdown" data-name="Markdown">
               <h3>
                  Markdown 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Markdown" class="anchor" title="Link to Markdown">#</a>
               </h3>
               
               <p>Markdown returns a Markdown formatting of the Doc.
See the [Printer] documentation for ways to customize the Markdown output.</p>
               
               <pre><code class="language-go">func (p *Printer) Markdown(d *Doc) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Parse" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Parse" class="anchor" title="Link to Parse">#</a>
               </h3>
               
               <p>Parse parses the doc comment text and returns the *[Doc] form.
Comment markers (/* // and */) in the text must have already been removed.</p>
               
               <pre><code class="language-go">func (p *Parser) Parse(text string) *Doc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Text" data-name="Text">
               <h3>
                  Text 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Text" class="anchor" title="Link to Text">#</a>
               </h3>
               
               <p>Text returns a textual formatting of the [Doc].
See the [Printer] documentation for ways to customize the text output.</p>
               
               <pre><code class="language-go">func (p *Printer) Text(d *Doc) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="autoURL" data-name="autoURL">
               <h3>
                  autoURL 
                  <span class="badge">function</span>
                  
                  <a href="#autoURL" class="anchor" title="Link to autoURL">#</a>
               </h3>
               
               <p>autoURL checks whether s begins with a URL that should be hyperlinked.
If so, it returns the URL, which is a prefix of s, and ok == true.
Otherwise it returns "", false.
The caller should skip over the first len(url) bytes of s
before further processing.</p>
               
               <pre><code class="language-go">func autoURL(s string) (url string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="blankBefore" data-name="blankBefore">
               <h3>
                  blankBefore 
                  <span class="badge">function</span>
                  
                  <a href="#blankBefore" class="anchor" title="Link to blankBefore">#</a>
               </h3>
               
               <p>blankBefore reports whether the block x requires a blank line before it.
All blocks do, except for Lists that return false from x.BlankBefore().</p>
               
               <pre><code class="language-go">func blankBefore(x Block) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="block" data-name="block">
               <h3>
                  block 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#block" class="anchor" title="Link to block">#</a>
               </h3>
               
               <pre><code class="language-go">func (*Code) block()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="block" data-name="block">
               <h3>
                  block 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#block" class="anchor" title="Link to block">#</a>
               </h3>
               
               <pre><code class="language-go">func (*Paragraph) block()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="block" data-name="block">
               <h3>
                  block 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#block" class="anchor" title="Link to block">#</a>
               </h3>
               
               <p>block prints the block x to out.</p>
               
               <pre><code class="language-go">func (p *htmlPrinter) block(out *bytes.Buffer, x Block)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="block" data-name="block">
               <h3>
                  block 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#block" class="anchor" title="Link to block">#</a>
               </h3>
               
               <p>block prints the block x to out.</p>
               
               <pre><code class="language-go">func (p *mdPrinter) block(out *bytes.Buffer, x Block)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="block" data-name="block">
               <h3>
                  block 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#block" class="anchor" title="Link to block">#</a>
               </h3>
               
               <p>block prints the block x to out.</p>
               
               <pre><code class="language-go">func (p *textPrinter) block(out *bytes.Buffer, x Block)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="block" data-name="block">
               <h3>
                  block 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#block" class="anchor" title="Link to block">#</a>
               </h3>
               
               <pre><code class="language-go">func (*Heading) block()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="block" data-name="block">
               <h3>
                  block 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#block" class="anchor" title="Link to block">#</a>
               </h3>
               
               <pre><code class="language-go">func (*List) block()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="block" data-name="block">
               <h3>
                  block 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#block" class="anchor" title="Link to block">#</a>
               </h3>
               
               <p>block prints the block x to out.</p>
               
               <pre><code class="language-go">func (p *commentPrinter) block(out *bytes.Buffer, x Block)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="code" data-name="code">
               <h3>
                  code 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#code" class="anchor" title="Link to code">#</a>
               </h3>
               
               <p>code returns a code block built from the lines.</p>
               
               <pre><code class="language-go">func (d *parseDoc) code(lines []string) *Code</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="commonPrefix" data-name="commonPrefix">
               <h3>
                  commonPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#commonPrefix" class="anchor" title="Link to commonPrefix">#</a>
               </h3>
               
               <p>commonPrefix returns the longest common prefix of a and b.</p>
               
               <pre><code class="language-go">func commonPrefix(a string, b string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="docLink" data-name="docLink">
               <h3>
                  docLink 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#docLink" class="anchor" title="Link to docLink">#</a>
               </h3>
               
               <p>docLink parses text, which was found inside [ ] brackets,
as a doc link if possible, returning the DocLink and ok == true
or else nil, false.
The before and after strings are the text before the [ and after the ]
on the same line. Doc links must be preceded and followed by
punctuation, spaces, tabs, or the start or end of a line.</p>
               
               <pre><code class="language-go">func (d *parseDoc) docLink(text string, before string, after string) (link *DocLink, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="docLinkURL" data-name="docLinkURL">
               <h3>
                  docLinkURL 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#docLinkURL" class="anchor" title="Link to docLinkURL">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Printer) docLinkURL(link *DocLink) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="escape" data-name="escape">
               <h3>
                  escape 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#escape" class="anchor" title="Link to escape">#</a>
               </h3>
               
               <p>escape prints s to out as plain text,
escaping special characters to avoid being misinterpreted
as Markdown markup sequences.</p>
               
               <pre><code class="language-go">func (p *mdPrinter) escape(out *bytes.Buffer, s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="escape" data-name="escape">
               <h3>
                  escape 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#escape" class="anchor" title="Link to escape">#</a>
               </h3>
               
               <p>escape prints s to out as plain text,
escaping < & " ' and > to avoid being misinterpreted
in larger HTML constructs.</p>
               
               <pre><code class="language-go">func (p *htmlPrinter) escape(out *bytes.Buffer, s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="heading" data-name="heading">
               <h3>
                  heading 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#heading" class="anchor" title="Link to heading">#</a>
               </h3>
               
               <p>heading returns the *Heading for the given new-style section heading line.</p>
               
               <pre><code class="language-go">func (d *parseDoc) heading(line string) Block</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="headingID" data-name="headingID">
               <h3>
                  headingID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#headingID" class="anchor" title="Link to headingID">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Printer) headingID(h *Heading) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="headingLevel" data-name="headingLevel">
               <h3>
                  headingLevel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#headingLevel" class="anchor" title="Link to headingLevel">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Printer) headingLevel() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ident" data-name="ident">
               <h3>
                  ident 
                  <span class="badge">function</span>
                  
                  <a href="#ident" class="anchor" title="Link to ident">#</a>
               </h3>
               
               <p>ident checks whether s begins with a Go identifier.
If so, it returns the identifier, which is a prefix of s, and ok == true.
Otherwise it returns "", false.
The caller should skip over the first len(id) bytes of s
before further processing.</p>
               
               <pre><code class="language-go">func ident(s string) (id string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="importPathOK" data-name="importPathOK">
               <h3>
                  importPathOK 
                  <span class="badge">function</span>
                  
                  <a href="#importPathOK" class="anchor" title="Link to importPathOK">#</a>
               </h3>
               
               <pre><code class="language-go">func importPathOK(c byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inc" data-name="inc">
               <h3>
                  inc 
                  <span class="badge">function</span>
                  
                  <a href="#inc" class="anchor" title="Link to inc">#</a>
               </h3>
               
               <p>inc increments the decimal string s.
For example, inc("1199") == "1200".</p>
               
               <pre><code class="language-go">func inc(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indent" data-name="indent">
               <h3>
                  indent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#indent" class="anchor" title="Link to indent">#</a>
               </h3>
               
               <p>indent prints s to out, indenting with the indent string
after each newline in s.</p>
               
               <pre><code class="language-go">func (p *commentPrinter) indent(out *bytes.Buffer, indent string, s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indented" data-name="indented">
               <h3>
                  indented 
                  <span class="badge">function</span>
                  
                  <a href="#indented" class="anchor" title="Link to indented">#</a>
               </h3>
               
               <p>indented reports whether line is indented
(starts with a leading space or tab).</p>
               
               <pre><code class="language-go">func indented(line string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isBlank" data-name="isBlank">
               <h3>
                  isBlank 
                  <span class="badge">function</span>
                  
                  <a href="#isBlank" class="anchor" title="Link to isBlank">#</a>
               </h3>
               
               <p>isBlank reports whether s is a blank line.</p>
               
               <pre><code class="language-go">func isBlank(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isHeading" data-name="isHeading">
               <h3>
                  isHeading 
                  <span class="badge">function</span>
                  
                  <a href="#isHeading" class="anchor" title="Link to isHeading">#</a>
               </h3>
               
               <p>isHeading reports whether line is a new-style section heading.</p>
               
               <pre><code class="language-go">func isHeading(line string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isHost" data-name="isHost">
               <h3>
                  isHost 
                  <span class="badge">function</span>
                  
                  <a href="#isHost" class="anchor" title="Link to isHost">#</a>
               </h3>
               
               <p>isHost reports whether c is a byte that can appear in a URL host,
like www.example.com or user@[::1]:8080</p>
               
               <pre><code class="language-go">func isHost(c byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isIdentASCII" data-name="isIdentASCII">
               <h3>
                  isIdentASCII 
                  <span class="badge">function</span>
                  
                  <a href="#isIdentASCII" class="anchor" title="Link to isIdentASCII">#</a>
               </h3>
               
               <p>isIdentASCII reports whether c is an ASCII identifier byte.</p>
               
               <pre><code class="language-go">func isIdentASCII(c byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isList" data-name="isList">
               <h3>
                  isList 
                  <span class="badge">function</span>
                  
                  <a href="#isList" class="anchor" title="Link to isList">#</a>
               </h3>
               
               <p>isList reports whether the line is the first line of a list,
meaning starts with a list marker after any indentation.
(The caller is responsible for checking the line is indented, as appropriate.)</p>
               
               <pre><code class="language-go">func isList(line string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isName" data-name="isName">
               <h3>
                  isName 
                  <span class="badge">function</span>
                  
                  <a href="#isName" class="anchor" title="Link to isName">#</a>
               </h3>
               
               <p>isName reports whether s is a capitalized Go identifier (like Name).</p>
               
               <pre><code class="language-go">func isName(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isOldHeading" data-name="isOldHeading">
               <h3>
                  isOldHeading 
                  <span class="badge">function</span>
                  
                  <a href="#isOldHeading" class="anchor" title="Link to isOldHeading">#</a>
               </h3>
               
               <p>isOldHeading reports whether line is an old-style section heading.
line is all[off].</p>
               
               <pre><code class="language-go">func isOldHeading(line string, all []string, off int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isPath" data-name="isPath">
               <h3>
                  isPath 
                  <span class="badge">function</span>
                  
                  <a href="#isPath" class="anchor" title="Link to isPath">#</a>
               </h3>
               
               <p>isPath reports whether c is a (non-punctuation) path byte.</p>
               
               <pre><code class="language-go">func isPath(c byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isPunct" data-name="isPunct">
               <h3>
                  isPunct 
                  <span class="badge">function</span>
                  
                  <a href="#isPunct" class="anchor" title="Link to isPunct">#</a>
               </h3>
               
               <p>isPunct reports whether c is a punctuation byte that can appear
inside a path but not at the end.</p>
               
               <pre><code class="language-go">func isPunct(c byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isScheme" data-name="isScheme">
               <h3>
                  isScheme 
                  <span class="badge">function</span>
                  
                  <a href="#isScheme" class="anchor" title="Link to isScheme">#</a>
               </h3>
               
               <p>isScheme reports whether s is a recognized URL scheme.
Note that if strings of new length (beyond 3-7)
are added here, the fast path at the top of autoURL will need updating.</p>
               
               <pre><code class="language-go">func isScheme(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isStdPkg" data-name="isStdPkg">
               <h3>
                  isStdPkg 
                  <span class="badge">function</span>
                  
                  <a href="#isStdPkg" class="anchor" title="Link to isStdPkg">#</a>
               </h3>
               
               <pre><code class="language-go">func isStdPkg(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="leadingSpace" data-name="leadingSpace">
               <h3>
                  leadingSpace 
                  <span class="badge">function</span>
                  
                  <a href="#leadingSpace" class="anchor" title="Link to leadingSpace">#</a>
               </h3>
               
               <p>leadingSpace returns the longest prefix of s consisting of spaces and tabs.</p>
               
               <pre><code class="language-go">func leadingSpace(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="list" data-name="list">
               <h3>
                  list 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#list" class="anchor" title="Link to list">#</a>
               </h3>
               
               <p>list returns a list built from the indented lines,
using forceBlankBefore as the value of the List's ForceBlankBefore field.</p>
               
               <pre><code class="language-go">func (d *parseDoc) list(lines []string, forceBlankBefore bool) *List</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="listMarker" data-name="listMarker">
               <h3>
                  listMarker 
                  <span class="badge">function</span>
                  
                  <a href="#listMarker" class="anchor" title="Link to listMarker">#</a>
               </h3>
               
               <p>listMarker parses the line as beginning with a list marker.
If it can do that, it returns the numeric marker ("" for a bullet list),
the rest of the line, and ok == true.
Otherwise, it returns "", "", false.</p>
               
               <pre><code class="language-go">func listMarker(line string) (num string, rest string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupPkg" data-name="lookupPkg">
               <h3>
                  lookupPkg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookupPkg" class="anchor" title="Link to lookupPkg">#</a>
               </h3>
               
               <p>lookupPkg is called to look up the pkg in [pkg], [pkg.Name], and [pkg.Name.Recv].
If pkg has a slash, it is assumed to be the full import path and is returned with ok = true.
Otherwise, pkg is probably a simple package name like "rand" (not "crypto/rand" or "math/rand").
d.LookupPackage provides a way for the caller to allow resolving such names with reference
to the imports in the surrounding package.
There is one collision between these two cases: single-element standard library names
like "math" are full import paths but don't contain slashes. We let d.LookupPackage have
the first chance to resolve it, in case there's a different package imported as math,
and otherwise we refer to a built-in list of single-element standard library package names.</p>
               
               <pre><code class="language-go">func (d *parseDoc) lookupPkg(pkg string) (importPath string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="oldHeading" data-name="oldHeading">
               <h3>
                  oldHeading 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#oldHeading" class="anchor" title="Link to oldHeading">#</a>
               </h3>
               
               <p>oldHeading returns the *Heading for the given old-style section heading line.</p>
               
               <pre><code class="language-go">func (d *parseDoc) oldHeading(line string) Block</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="oneLongLine" data-name="oneLongLine">
               <h3>
                  oneLongLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#oneLongLine" class="anchor" title="Link to oneLongLine">#</a>
               </h3>
               
               <p>oneLongLine prints the text sequence x to out as one long line,
without worrying about line wrapping.
Explicit links have the [ ] dropped to improve readability.</p>
               
               <pre><code class="language-go">func (p *textPrinter) oneLongLine(out *strings.Builder, x []Text)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="paragraph" data-name="paragraph">
               <h3>
                  paragraph 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#paragraph" class="anchor" title="Link to paragraph">#</a>
               </h3>
               
               <p>paragraph returns a paragraph block built from the lines.
If the lines are link definitions, paragraph adds them to d and returns nil.</p>
               
               <pre><code class="language-go">func (d *parseDoc) paragraph(lines []string) Block</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseLink" data-name="parseLink">
               <h3>
                  parseLink 
                  <span class="badge">function</span>
                  
                  <a href="#parseLink" class="anchor" title="Link to parseLink">#</a>
               </h3>
               
               <p>parseLink parses a single link definition line:
[text]: url
It returns the link definition and whether the line was well formed.</p>
               
               <pre><code class="language-go">func parseLink(line string) (*LinkDef, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseLinkedText" data-name="parseLinkedText">
               <h3>
                  parseLinkedText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseLinkedText" class="anchor" title="Link to parseLinkedText">#</a>
               </h3>
               
               <p>parseLinkedText parses text that is allowed to contain explicit links,
such as [math.Sin] or [Go home page], into a slice of Text items.
A “pkg” is only assumed to be a full import path if it starts with
a domain name (a path element with a dot) or is one of the packages
from the standard library (“[os]”, “[encoding/json]”, and so on).
To avoid problems with maps, generics, and array types, doc links
must be both preceded and followed by punctuation, spaces, tabs,
or the start or end of a line. An example problem would be treating
map[ast.Expr]TypeAndValue as containing a link.</p>
               
               <pre><code class="language-go">func (d *parseDoc) parseLinkedText(text string) []Text</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseSpans" data-name="parseSpans">
               <h3>
                  parseSpans 
                  <span class="badge">function</span>
                  
                  <a href="#parseSpans" class="anchor" title="Link to parseSpans">#</a>
               </h3>
               
               <pre><code class="language-go">func parseSpans(lines []string) []span</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseText" data-name="parseText">
               <h3>
                  parseText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseText" class="anchor" title="Link to parseText">#</a>
               </h3>
               
               <p>parseText parses s as text and returns the result of appending
those parsed Text elements to out.
parseText does not handle explicit links like [math.Sin] or [Go home page]:
those are handled by parseLinkedText.
If autoLink is true, then parseText recognizes URLs and words from d.Words
and converts those to links as appropriate.</p>
               
               <pre><code class="language-go">func (d *parseDoc) parseText(out []Text, s string, autoLink bool) []Text</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rawText" data-name="rawText">
               <h3>
                  rawText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rawText" class="anchor" title="Link to rawText">#</a>
               </h3>
               
               <p>rawText prints the text sequence x to out,
without worrying about escaping characters
that have special meaning at the start of a Markdown line.</p>
               
               <pre><code class="language-go">func (p *mdPrinter) rawText(out *bytes.Buffer, x []Text)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitDocName" data-name="splitDocName">
               <h3>
                  splitDocName 
                  <span class="badge">function</span>
                  
                  <a href="#splitDocName" class="anchor" title="Link to splitDocName">#</a>
               </h3>
               
               <p>If text is of the form before.Name, where Name is a capitalized Go identifier,
then splitDocName returns before, name, true.
Otherwise it returns text, "", false.</p>
               
               <pre><code class="language-go">func splitDocName(text string) (before string, name string, foundDot bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="text" data-name="text">
               <h3>
                  text 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#text" class="anchor" title="Link to text">#</a>
               </h3>
               
               <pre><code class="language-go">func (Plain) text()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="text" data-name="text">
               <h3>
                  text 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#text" class="anchor" title="Link to text">#</a>
               </h3>
               
               <p>text prints the text sequence x to out.</p>
               
               <pre><code class="language-go">func (p *htmlPrinter) text(out *bytes.Buffer, x []Text)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="text" data-name="text">
               <h3>
                  text 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#text" class="anchor" title="Link to text">#</a>
               </h3>
               
               <p>text prints the text sequence x to out.</p>
               
               <pre><code class="language-go">func (p *commentPrinter) text(out *bytes.Buffer, indent string, x []Text)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="text" data-name="text">
               <h3>
                  text 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#text" class="anchor" title="Link to text">#</a>
               </h3>
               
               <pre><code class="language-go">func (Italic) text()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="text" data-name="text">
               <h3>
                  text 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#text" class="anchor" title="Link to text">#</a>
               </h3>
               
               <pre><code class="language-go">func (*Link) text()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="text" data-name="text">
               <h3>
                  text 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#text" class="anchor" title="Link to text">#</a>
               </h3>
               
               <pre><code class="language-go">func (*DocLink) text()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="text" data-name="text">
               <h3>
                  text 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#text" class="anchor" title="Link to text">#</a>
               </h3>
               
               <p>text prints the text sequence x to out.</p>
               
               <pre><code class="language-go">func (p *mdPrinter) text(out *bytes.Buffer, x []Text)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="text" data-name="text">
               <h3>
                  text 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#text" class="anchor" title="Link to text">#</a>
               </h3>
               
               <p>text prints the text sequence x to out.</p>
               
               <pre><code class="language-go">func (p *textPrinter) text(out *bytes.Buffer, indent string, x []Text)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unindent" data-name="unindent">
               <h3>
                  unindent 
                  <span class="badge">function</span>
                  
                  <a href="#unindent" class="anchor" title="Link to unindent">#</a>
               </h3>
               
               <p>unindent removes any common space/tab prefix
from each line in lines, returning a copy of lines in which
those prefixes have been trimmed from each line.
It also replaces any lines containing only spaces with blank lines (empty strings).</p>
               
               <pre><code class="language-go">func unindent(lines []string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validImportPath" data-name="validImportPath">
               <h3>
                  validImportPath 
                  <span class="badge">function</span>
                  
                  <a href="#validImportPath" class="anchor" title="Link to validImportPath">#</a>
               </h3>
               
               <p>validImportPath reports whether path is a valid import path.
It is a lightly edited copy of golang.org/x/mod/module.CheckImportPath.</p>
               
               <pre><code class="language-go">func validImportPath(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validImportPathElem" data-name="validImportPathElem">
               <h3>
                  validImportPathElem 
                  <span class="badge">function</span>
                  
                  <a href="#validImportPathElem" class="anchor" title="Link to validImportPathElem">#</a>
               </h3>
               
               <pre><code class="language-go">func validImportPathElem(elem string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wrap" data-name="wrap">
               <h3>
                  wrap 
                  <span class="badge">function</span>
                  
                  <a href="#wrap" class="anchor" title="Link to wrap">#</a>
               </h3>
               
               <p>wrap wraps words into lines of at most max runes,
minimizing the sum of the squares of the leftover lengths
at the end of each line (except the last, of course),
with a preference for ending lines at punctuation (.,:;).
The returned slice gives the indexes of the first words
on each line in the wrapped text with a final entry of len(words).
Thus the lines are words[seq[0]:seq[1]], words[seq[1]:seq[2]],
..., words[seq[len(seq)-2]:seq[len(seq)-1]].
The implementation runs in O(n log n) time, where n = len(words),
using the algorithm described in D. S. Hirschberg and L. L. Larmore,
“[The least weight subsequence problem],” FOCS 1985, pp. 137-143.
[The least weight subsequence problem]: https://doi.org/10.1109/SFCS.1985.60</p>
               
               <pre><code class="language-go">func wrap(words []string, max int) (seq []int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wrapPenalty" data-name="wrapPenalty">
               <h3>
                  wrapPenalty 
                  <span class="badge">function</span>
                  
                  <a href="#wrapPenalty" class="anchor" title="Link to wrapPenalty">#</a>
               </h3>
               
               <p>wrapPenalty is the penalty for inserting a line break after word s.</p>
               
               <pre><code class="language-go">func wrapPenalty(s string) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeNL" data-name="writeNL">
               <h3>
                  writeNL 
                  <span class="badge">function</span>
                  
                  <a href="#writeNL" class="anchor" title="Link to writeNL">#</a>
               </h3>
               
               <p>writeNL calls out.WriteByte('\n')
but first trims trailing spaces on the previous line.</p>
               
               <pre><code class="language-go">func writeNL(out *bytes.Buffer)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>