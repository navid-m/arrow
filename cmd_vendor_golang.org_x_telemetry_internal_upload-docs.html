<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - upload</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>upload</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"os"
"path/filepath"
"strings"
"crypto/rand"
"encoding/binary"
"encoding/json"
"fmt"
"math"
"os"
"path/filepath"
"strings"
"time"
"golang.org/x/telemetry/internal/config"
"golang.org/x/telemetry/internal/counter"
"golang.org/x/telemetry/internal/telemetry"
"fmt"
"io"
"log"
"os"
"path"
"path/filepath"
"runtime/debug"
"strings"
"time"
"golang.org/x/telemetry/internal/configstore"
"golang.org/x/telemetry/internal/telemetry"
"bytes"
"net/http"
"os"
"path/filepath"
"regexp"
"strings"
"time"
"golang.org/x/telemetry/internal/telemetry"
"fmt"
"os"
"sync"
"time"
"golang.org/x/telemetry/internal/counter"
"golang.org/x/telemetry/internal/telemetry"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="dateFormat" data-name="dateFormat">
               <h3>
                  dateFormat 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dateFormat" class="anchor" title="Link to dateFormat">#</a>
               </h3>
               
               <pre><code class="language-go">var dateFormat = telemetry.DateOnly</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dateRE" data-name="dateRE">
               <h3>
                  dateRE 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dateRE" class="anchor" title="Link to dateRE">#</a>
               </h3>
               
               <pre><code class="language-go">var dateRE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="distantPast" data-name="distantPast">
               <h3>
                  distantPast 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#distantPast" class="anchor" title="Link to distantPast">#</a>
               </h3>
               
               <pre><code class="language-go">var distantPast = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="RunConfig" data-name="RunConfig">
               <h3>
                  RunConfig
                  <span class="badge">struct</span>
                  <a href="#RunConfig" class="anchor" title="Link to RunConfig">#</a>
               </h3>
               
               <p>RunConfig configures non-default behavior of a call to Run.
All fields are optional, for testing or observability.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type RunConfig struct {
TelemetryDir string
UploadURL string
LogWriter io.Writer
Env []string
StartTime time.Time
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="parsedCache" data-name="parsedCache">
               <h3>
                  parsedCache
                  <span class="badge">struct</span>
                  <a href="#parsedCache" class="anchor" title="Link to parsedCache">#</a>
               </h3>
               
               <p>avoid parsing count files multiple times</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type parsedCache struct {
mu sync.Mutex
m map[string]*counter.File
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="uploader" data-name="uploader">
               <h3>
                  uploader
                  <span class="badge">struct</span>
                  <a href="#uploader" class="anchor" title="Link to uploader">#</a>
               </h3>
               
               <p>uploader encapsulates a single upload operation, carrying parameters and
shared state.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type uploader struct {
config *telemetry.UploadConfig
configVersion string
dir telemetry.Dir
uploadServerURL string
startTime time.Time
cache parsedCache
logFile *os.File
logger *log.Logger
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="work" data-name="work">
               <h3>
                  work
                  <span class="badge">struct</span>
                  <a href="#work" class="anchor" title="Link to work">#</a>
               </h3>
               
               <p>files to handle</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type work struct {
countfiles []string
readyfiles []string
uploaded map[string]bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close cleans up any resources associated with the uploader.</p>
               
               <pre><code class="language-go">func (u *uploader) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Run" data-name="Run">
               <h3>
                  Run 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Run" class="anchor" title="Link to Run">#</a>
               </h3>
               
               <p>Run generates and uploads reports</p>
               
               <pre><code class="language-go">func (u *uploader) Run() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Run" data-name="Run">
               <h3>
                  Run 
                  <span class="badge">function</span>
                  
                  <a href="#Run" class="anchor" title="Link to Run">#</a>
               </h3>
               
               <p>Run generates and uploads reports, as allowed by the mode file.</p>
               
               <pre><code class="language-go">func Run(config RunConfig) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="computeRandom" data-name="computeRandom">
               <h3>
                  computeRandom 
                  <span class="badge">function</span>
                  
                  <a href="#computeRandom" class="anchor" title="Link to computeRandom">#</a>
               </h3>
               
               <p>computeRandom returns a cryptographic random float64 in the range [0, 1],
with 52 bits of precision.</p>
               
               <pre><code class="language-go">func computeRandom() float64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="counterDateSpan" data-name="counterDateSpan">
               <h3>
                  counterDateSpan 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#counterDateSpan" class="anchor" title="Link to counterDateSpan">#</a>
               </h3>
               
               <p>counterDateSpan parses the counter file named fname and returns the (begin,
end) span recorded in its metadata, or an error if this data could not be
extracted.</p>
               
               <pre><code class="language-go">func (u *uploader) counterDateSpan(fname string) (begin time.Time, end time.Time, _ error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="createReport" data-name="createReport">
               <h3>
                  createReport 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#createReport" class="anchor" title="Link to createReport">#</a>
               </h3>
               
               <p>createReport creates local and upload report files by
combining all the count files for the expiryDate, and
returns the upload report file's path.
It may delete the count files once local and upload report
files are successfully created.</p>
               
               <pre><code class="language-go">func (u *uploader) createReport(start time.Time, expiryDate string, countFiles []string, lastWeek string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="debugLogFile" data-name="debugLogFile">
               <h3>
                  debugLogFile 
                  <span class="badge">function</span>
                  
                  <a href="#debugLogFile" class="anchor" title="Link to debugLogFile">#</a>
               </h3>
               
               <p>debugLogFile arranges to write a log file in the given debug directory, if
it exists.</p>
               
               <pre><code class="language-go">func debugLogFile(debugDir string) (*os.File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="deleteFiles" data-name="deleteFiles">
               <h3>
                  deleteFiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#deleteFiles" class="anchor" title="Link to deleteFiles">#</a>
               </h3>
               
               <pre><code class="language-go">func (u *uploader) deleteFiles(files []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exclusiveWrite" data-name="exclusiveWrite">
               <h3>
                  exclusiveWrite 
                  <span class="badge">function</span>
                  
                  <a href="#exclusiveWrite" class="anchor" title="Link to exclusiveWrite">#</a>
               </h3>
               
               <p>exclusiveWrite attempts to create filename exclusively, and if successful,
writes content to the resulting file handle.
It returns a boolean indicating whether the exclusive handle was acquired,
and an error indicating whether the operation succeeded.
If the file already exists, exclusiveWrite returns (false, nil).</p>
               
               <pre><code class="language-go">func exclusiveWrite(filename string, content []byte) (_ bool, rerr error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findProgReport" data-name="findProgReport">
               <h3>
                  findProgReport 
                  <span class="badge">function</span>
                  
                  <a href="#findProgReport" class="anchor" title="Link to findProgReport">#</a>
               </h3>
               
               <p>return an existing ProgremReport, or create anew</p>
               
               <pre><code class="language-go">func findProgReport(meta map[string]string, report *telemetry.Report) *telemetry.ProgramReport</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findWork" data-name="findWork">
               <h3>
                  findWork 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findWork" class="anchor" title="Link to findWork">#</a>
               </h3>
               
               <p>find all the files that look like counter files or reports
that need to be uploaded. (There may be unexpected leftover files
and uploading is supposed to be idempotent.)</p>
               
               <pre><code class="language-go">func (u *uploader) findWork() work</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="latestReport" data-name="latestReport">
               <h3>
                  latestReport 
                  <span class="badge">function</span>
                  
                  <a href="#latestReport" class="anchor" title="Link to latestReport">#</a>
               </h3>
               
               <p>latestReport returns the YYYY-MM-DD of the last report uploaded
or the empty string if there are no reports.</p>
               
               <pre><code class="language-go">func latestReport(uploaded map[string]bool) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newUploader" data-name="newUploader">
               <h3>
                  newUploader 
                  <span class="badge">function</span>
                  
                  <a href="#newUploader" class="anchor" title="Link to newUploader">#</a>
               </h3>
               
               <p>newUploader creates a new uploader to use for running the upload for the
given config.
Uploaders should only be used for one call to [uploader.Run].</p>
               
               <pre><code class="language-go">func newUploader(rcfg RunConfig) (*uploader, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="notNeeded" data-name="notNeeded">
               <h3>
                  notNeeded 
                  <span class="badge">function</span>
                  
                  <a href="#notNeeded" class="anchor" title="Link to notNeeded">#</a>
               </h3>
               
               <p>notNeeded returns true if the report for date has already been created</p>
               
               <pre><code class="language-go">func notNeeded(date string, todo work) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseCountFile" data-name="parseCountFile">
               <h3>
                  parseCountFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseCountFile" class="anchor" title="Link to parseCountFile">#</a>
               </h3>
               
               <pre><code class="language-go">func (u *uploader) parseCountFile(fname string) (*counter.File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reports" data-name="reports">
               <h3>
                  reports 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reports" class="anchor" title="Link to reports">#</a>
               </h3>
               
               <p>reports generates reports from inactive count files</p>
               
               <pre><code class="language-go">func (u *uploader) reports(todo *work) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tooOld" data-name="tooOld">
               <h3>
                  tooOld 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tooOld" class="anchor" title="Link to tooOld">#</a>
               </h3>
               
               <p>reports that are too old (21 days) are not uploaded</p>
               
               <pre><code class="language-go">func (u *uploader) tooOld(date string, uploadStartTime time.Time) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uploadReport" data-name="uploadReport">
               <h3>
                  uploadReport 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uploadReport" class="anchor" title="Link to uploadReport">#</a>
               </h3>
               
               <pre><code class="language-go">func (u *uploader) uploadReport(fname string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uploadReportContents" data-name="uploadReportContents">
               <h3>
                  uploadReportContents 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uploadReportContents" class="anchor" title="Link to uploadReportContents">#</a>
               </h3>
               
               <p>try to upload the report, 'true' if successful</p>
               
               <pre><code class="language-go">func (u *uploader) uploadReportContents(fname string, buf []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uploadReportDate" data-name="uploadReportDate">
               <h3>
                  uploadReportDate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uploadReportDate" class="anchor" title="Link to uploadReportDate">#</a>
               </h3>
               
               <p>uploadReportDate returns the date component of the upload file name, or "" if the
date was unmatched.</p>
               
               <pre><code class="language-go">func (u *uploader) uploadReportDate(fname string) time.Time</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>