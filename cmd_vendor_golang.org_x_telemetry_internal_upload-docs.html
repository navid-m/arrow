<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - upload</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>upload</code>
         </h1>
         <hr />
         
         <article class="global" data-name="dateRE">
            <h2>dateRE</h2>
            <hr />
            
            <pre><code>dateRE</code></pre>
         </article>
         
         <article class="global" data-name="dateFormat">
            <h2>dateFormat</h2>
            <hr />
            
            <pre><code>dateFormat</code></pre>
         </article>
         
         <article class="global" data-name="distantPast">
            <h2>distantPast</h2>
            <hr />
            
            <pre><code>distantPast</code></pre>
         </article>
          
         <article class="struct" data-name="RunConfig">
            <h2>type RunConfig struct</h2>
            <hr />
            
            <p>RunConfig configures non-default behavior of a call to Run.

All fields are optional, for testing or observability.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">TelemetryDir string
UploadURL string
LogWriter io.Writer
Env []string
StartTime time.Time</code></pre>
         </article>
         
         <article class="struct" data-name="uploader">
            <h2>type uploader struct</h2>
            <hr />
            
            <p>uploader encapsulates a single upload operation, carrying parameters and
shared state.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">config *telemetry.UploadConfig
configVersion string
dir telemetry.Dir
uploadServerURL string
startTime time.Time
cache parsedCache
logFile *os.File
logger *log.Logger</code></pre>
         </article>
         
         <article class="struct" data-name="parsedCache">
            <h2>type parsedCache struct</h2>
            <hr />
            
            <p>avoid parsing count files multiple times</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">mu sync.Mutex
m *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="work">
            <h2>type work struct</h2>
            <hr />
            
            <p>files to handle</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">countfiles []string
readyfiles []string
uploaded *ast.MapType</code></pre>
         </article>
          
         <article class="function" data-name="reports">
            <h2>reports</h2>
            <hr />
            
            <p>reports generates reports from inactive count files</p>
            
            <pre><code>func reports(todo *work) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="latestReport">
            <h2>latestReport</h2>
            <hr />
            
            <p>latestReport returns the YYYY-MM-DD of the last report uploaded
or the empty string if there are no reports.</p>
            
            <pre><code>func latestReport(uploaded *ast.MapType) string</code></pre>
         </article>
         
         <article class="function" data-name="notNeeded">
            <h2>notNeeded</h2>
            <hr />
            
            <p>notNeeded returns true if the report for date has already been created</p>
            
            <pre><code>func notNeeded(date string, todo work) bool</code></pre>
         </article>
         
         <article class="function" data-name="deleteFiles">
            <h2>deleteFiles</h2>
            <hr />
            
            <pre><code>func deleteFiles(files []string)</code></pre>
         </article>
         
         <article class="function" data-name="createReport">
            <h2>createReport</h2>
            <hr />
            
            <p>createReport creates local and upload report files by
combining all the count files for the expiryDate, and
returns the upload report file's path.
It may delete the count files once local and upload report
files are successfully created.</p>
            
            <pre><code>func createReport(start time.Time, expiryDate string, countFiles []string, lastWeek string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="exclusiveWrite">
            <h2>exclusiveWrite</h2>
            <hr />
            
            <p>exclusiveWrite attempts to create filename exclusively, and if successful,
writes content to the resulting file handle.

It returns a boolean indicating whether the exclusive handle was acquired,
and an error indicating whether the operation succeeded.
If the file already exists, exclusiveWrite returns (false, nil).</p>
            
            <pre><code>func exclusiveWrite(filename string, content []byte) (_ bool, rerr error)</code></pre>
         </article>
         
         <article class="function" data-name="findProgReport">
            <h2>findProgReport</h2>
            <hr />
            
            <p>return an existing ProgremReport, or create anew</p>
            
            <pre><code>func findProgReport(meta *ast.MapType, report *telemetry.Report) *telemetry.ProgramReport</code></pre>
         </article>
         
         <article class="function" data-name="computeRandom">
            <h2>computeRandom</h2>
            <hr />
            
            <p>computeRandom returns a cryptographic random float64 in the range [0, 1],
with 52 bits of precision.</p>
            
            <pre><code>func computeRandom() float64</code></pre>
         </article>
         
         <article class="function" data-name="Run">
            <h2>Run</h2>
            <hr />
            
            <p>Run generates and uploads reports, as allowed by the mode file.</p>
            
            <pre><code>func Run(config RunConfig) error</code></pre>
         </article>
         
         <article class="function" data-name="newUploader">
            <h2>newUploader</h2>
            <hr />
            
            <p>newUploader creates a new uploader to use for running the upload for the
given config.

Uploaders should only be used for one call to [uploader.Run].</p>
            
            <pre><code>func newUploader(rcfg RunConfig) (*uploader, error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close cleans up any resources associated with the uploader.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="Run">
            <h2>Run</h2>
            <hr />
            
            <p>Run generates and uploads reports</p>
            
            <pre><code>func Run() error</code></pre>
         </article>
         
         <article class="function" data-name="debugLogFile">
            <h2>debugLogFile</h2>
            <hr />
            
            <p>debugLogFile arranges to write a log file in the given debug directory, if
it exists.</p>
            
            <pre><code>func debugLogFile(debugDir string) (*os.File, error)</code></pre>
         </article>
         
         <article class="function" data-name="uploadReportDate">
            <h2>uploadReportDate</h2>
            <hr />
            
            <p>uploadReportDate returns the date component of the upload file name, or "" if the
date was unmatched.</p>
            
            <pre><code>func uploadReportDate(fname string) time.Time</code></pre>
         </article>
         
         <article class="function" data-name="uploadReport">
            <h2>uploadReport</h2>
            <hr />
            
            <pre><code>func uploadReport(fname string)</code></pre>
         </article>
         
         <article class="function" data-name="uploadReportContents">
            <h2>uploadReportContents</h2>
            <hr />
            
            <p>try to upload the report, 'true' if successful</p>
            
            <pre><code>func uploadReportContents(fname string, buf []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="tooOld">
            <h2>tooOld</h2>
            <hr />
            
            <p>reports that are too old (21 days) are not uploaded</p>
            
            <pre><code>func tooOld(date string, uploadStartTime time.Time) bool</code></pre>
         </article>
         
         <article class="function" data-name="counterDateSpan">
            <h2>counterDateSpan</h2>
            <hr />
            
            <p>counterDateSpan parses the counter file named fname and returns the (begin,
end) span recorded in its metadata, or an error if this data could not be
extracted.</p>
            
            <pre><code>func counterDateSpan(fname string) (begin time.Time, end time.Time, _ error)</code></pre>
         </article>
         
         <article class="function" data-name="parseCountFile">
            <h2>parseCountFile</h2>
            <hr />
            
            <pre><code>func parseCountFile(fname string) (*counter.File, error)</code></pre>
         </article>
         
         <article class="function" data-name="findWork">
            <h2>findWork</h2>
            <hr />
            
            <p>find all the files that look like counter files or reports
that need to be uploaded. (There may be unexpected leftover files
and uploading is supposed to be idempotent.)</p>
            
            <pre><code>func findWork() work</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
