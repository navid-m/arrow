<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - unitchecker</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>unitchecker</code>
         </h1>
         <hr />
         
         <article class="global" data-name="makeTypesImporter">
            <h2>makeTypesImporter</h2>
            <hr />
            
            <p>These four hook variables are a proof of concept of a future
parameterization of a unitchecker API that allows the client to
determine how and where facts and types are produced and consumed.
(Note that the eventual API will likely be quite different.)

The defaults honor a Config in a manner compatible with 'go vet'.</p>
            
            <pre><code>makeTypesImporter</code></pre>
         </article>
         
         <article class="global" data-name="exportTypes">
            <h2>exportTypes</h2>
            <hr />
            
            <p>These four hook variables are a proof of concept of a future
parameterization of a unitchecker API that allows the client to
determine how and where facts and types are produced and consumed.
(Note that the eventual API will likely be quite different.)

The defaults honor a Config in a manner compatible with 'go vet'.</p>
            
            <pre><code>exportTypes</code></pre>
         </article>
         
         <article class="global" data-name="makeFactImporter">
            <h2>makeFactImporter</h2>
            <hr />
            
            <p>These four hook variables are a proof of concept of a future
parameterization of a unitchecker API that allows the client to
determine how and where facts and types are produced and consumed.
(Note that the eventual API will likely be quite different.)

The defaults honor a Config in a manner compatible with 'go vet'.</p>
            
            <pre><code>makeFactImporter</code></pre>
         </article>
         
         <article class="global" data-name="exportFacts">
            <h2>exportFacts</h2>
            <hr />
            
            <p>These four hook variables are a proof of concept of a future
parameterization of a unitchecker API that allows the client to
determine how and where facts and types are produced and consumed.
(Note that the eventual API will likely be quite different.)

The defaults honor a Config in a manner compatible with 'go vet'.</p>
            
            <pre><code>exportFacts</code></pre>
         </article>
          
         <article class="struct" data-name="Config">
            <h2>type Config struct</h2>
            <hr />
            
            <p>A Config describes a compilation unit to be analyzed.
It is provided to the tool in a JSON-encoded file
whose name ends with ".cfg".</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ID string
Compiler string
Dir string
ImportPath string
GoVersion string
GoFiles []string
NonGoFiles []string
IgnoredFiles []string
ModulePath string
ModuleVersion string
ImportMap *ast.MapType
PackageFile *ast.MapType
Standard *ast.MapType
PackageVetx *ast.MapType
VetxOnly bool
VetxOutput string
SucceedOnTypecheckFailure bool</code></pre>
         </article>
         
         <article class="struct" data-name="result">
            <h2>type result struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">a *analysis.Analyzer
diagnostics []analysis.Diagnostic
err error</code></pre>
         </article>
          
         <article class="function" data-name="Main">
            <h2>Main</h2>
            <hr />
            
            <p>Main is the main function of a vet-like analysis tool that must be
invoked by a build system to analyze a single package.

The protocol required by 'go vet -vettool=...' is that the tool must support:

	-flags          describe flags in JSON
	-V=full         describe executable for build caching
	foo.cfg         perform separate modular analyze on the single
	                unit described by a JSON config file foo.cfg.</p>
            
            <pre><code>func Main(analyzers ...*analysis.Analyzer)</code></pre>
         </article>
         
         <article class="function" data-name="Run">
            <h2>Run</h2>
            <hr />
            
            <p>Run reads the *.cfg file, runs the analysis,
and calls os.Exit with an appropriate error code.
It assumes flags have already been set.</p>
            
            <pre><code>func Run(configFile string, analyzers []*analysis.Analyzer)</code></pre>
         </article>
         
         <article class="function" data-name="readConfig">
            <h2>readConfig</h2>
            <hr />
            
            <pre><code>func readConfig(filename string) (*Config, error)</code></pre>
         </article>
         
         <article class="function" data-name="run">
            <h2>run</h2>
            <hr />
            
            <pre><code>func run(fset *token.FileSet, cfg *Config, analyzers []*analysis.Analyzer) ([]result, error)</code></pre>
         </article>
         
         <article class="function" data-name="Import">
            <h2>Import</h2>
            <hr />
            
            <pre><code>func Import(path string) (*types.Package, error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
