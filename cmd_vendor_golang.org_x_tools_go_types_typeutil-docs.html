<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - typeutil</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>typeutil</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"go/ast"
"go/types"
"golang.org/x/tools/internal/typeparams"
"go/types"
"bytes"
"fmt"
"go/types"
"reflect"
"golang.org/x/tools/internal/typeparams"
"go/types"
"sync"
"go/types"
</code></pre>
            </article>
         </section>
             
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Hasher" data-name="Hasher">
               <h3>
                  Hasher
                  <span class="badge">struct</span>
                  <a href="#Hasher" class="anchor" title="Link to Hasher">#</a>
               </h3>
               
               <p>A Hasher maps each type to its hash value.
For efficiency, a hasher uses memoization; thus its memory
footprint grows monotonically over time.
Hashers are not thread-safe.
Hashers have reference semantics.
Call MakeHasher to create a Hasher.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Hasher struct {
memo map[types.Type]uint32
ptrMap map[any]uint32
sigTParams *types.TypeParamList
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Map" data-name="Map">
               <h3>
                  Map
                  <span class="badge">struct</span>
                  <a href="#Map" class="anchor" title="Link to Map">#</a>
               </h3>
               
               <p>Map is a hash-table-based mapping from types (types.Type) to
arbitrary any values.  The concrete types that implement
the Type interface are pointers.  Since they are not canonicalized,
== cannot be used to check for equivalence, and thus we cannot
simply use a Go map.
Just as with map[K]V, a nil *Map is a valid empty map.
Not thread-safe.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Map struct {
hasher Hasher
table map[uint32][]entry
length int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="MethodSetCache" data-name="MethodSetCache">
               <h3>
                  MethodSetCache
                  <span class="badge">struct</span>
                  <a href="#MethodSetCache" class="anchor" title="Link to MethodSetCache">#</a>
               </h3>
               
               <p>A MethodSetCache records the method set of each type T for which
MethodSet(T) is called so that repeat queries are fast.
The zero value is a ready-to-use cache instance.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MethodSetCache struct {
mu sync.Mutex
named map[*types.Named]struct{...}
others map[types.Type]*types.MethodSet
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="entry" data-name="entry">
               <h3>
                  entry
                  <span class="badge">struct</span>
                  <a href="#entry" class="anchor" title="Link to entry">#</a>
               </h3>
               
               <p>entry is an entry (key/value association) in a hash bucket.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type entry struct {
key types.Type
value any
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="At" data-name="At">
               <h3>
                  At 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#At" class="anchor" title="Link to At">#</a>
               </h3>
               
               <p>At returns the map entry for the given key.
The result is nil if the entry is not present.</p>
               
               <pre><code>func (m *Map) At(key types.Type) any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Callee" data-name="Callee">
               <h3>
                  Callee 
                  <span class="badge">function</span>
                  
                  <a href="#Callee" class="anchor" title="Link to Callee">#</a>
               </h3>
               
               <p>Callee returns the named target of a function call, if any:
a function, method, builtin, or variable.
Functions and methods may potentially have type parameters.</p>
               
               <pre><code>func Callee(info *types.Info, call *ast.CallExpr) types.Object</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Delete" data-name="Delete">
               <h3>
                  Delete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Delete" class="anchor" title="Link to Delete">#</a>
               </h3>
               
               <p>Delete removes the entry with the given key, if any.
It returns true if the entry was found.</p>
               
               <pre><code>func (m *Map) Delete(key types.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Dependencies" data-name="Dependencies">
               <h3>
                  Dependencies 
                  <span class="badge">function</span>
                  
                  <a href="#Dependencies" class="anchor" title="Link to Dependencies">#</a>
               </h3>
               
               <p>Dependencies returns all dependencies of the specified packages.
Dependent packages appear in topological order: if package P imports
package Q, Q appears earlier than P in the result.
The algorithm follows import statements in the order they
appear in the source code, so the result is a total order.</p>
               
               <pre><code>func Dependencies(pkgs ...*types.Package) []*types.Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Hash" data-name="Hash">
               <h3>
                  Hash 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Hash" class="anchor" title="Link to Hash">#</a>
               </h3>
               
               <p>Hash computes a hash value for the given type t such that
Identical(t, t') => Hash(t) == Hash(t').</p>
               
               <pre><code>func (h Hasher) Hash(t types.Type) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IntuitiveMethodSet" data-name="IntuitiveMethodSet">
               <h3>
                  IntuitiveMethodSet 
                  <span class="badge">function</span>
                  
                  <a href="#IntuitiveMethodSet" class="anchor" title="Link to IntuitiveMethodSet">#</a>
               </h3>
               
               <p>IntuitiveMethodSet returns the intuitive method set of a type T,
which is the set of methods you can call on an addressable value of
that type.
The result always contains MethodSet(T), and is exactly MethodSet(T)
for interface types and for pointer-to-concrete types.
For all other concrete types T, the result additionally
contains each method belonging to *T if there is no identically
named method on T itself.
This corresponds to user intuition about method sets;
this function is intended only for user interfaces.
The order of the result is as for types.MethodSet(T).</p>
               
               <pre><code>func IntuitiveMethodSet(T types.Type, msets *MethodSetCache) []*types.Selection</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Iterate" data-name="Iterate">
               <h3>
                  Iterate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Iterate" class="anchor" title="Link to Iterate">#</a>
               </h3>
               
               <p>Iterate calls function f on each entry in the map in unspecified order.
If f should mutate the map, Iterate provides the same guarantees as
Go maps: if f deletes a map entry that Iterate has not yet reached,
f will not be invoked for it, but if f inserts a map entry that
Iterate has not yet reached, whether or not f will be invoked for
it is unspecified.</p>
               
               <pre><code>func (m *Map) Iterate(f func(key types.Type, value any))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Keys" data-name="Keys">
               <h3>
                  Keys 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Keys" class="anchor" title="Link to Keys">#</a>
               </h3>
               
               <p>Keys returns a new slice containing the set of map keys.
The order is unspecified.</p>
               
               <pre><code>func (m *Map) Keys() []types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="KeysString" data-name="KeysString">
               <h3>
                  KeysString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#KeysString" class="anchor" title="Link to KeysString">#</a>
               </h3>
               
               <p>KeysString returns a string representation of the map's key set.
Order is unspecified.</p>
               
               <pre><code>func (m *Map) KeysString() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <p>Len returns the number of map entries.</p>
               
               <pre><code>func (m *Map) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MakeHasher" data-name="MakeHasher">
               <h3>
                  MakeHasher 
                  <span class="badge">function</span>
                  
                  <a href="#MakeHasher" class="anchor" title="Link to MakeHasher">#</a>
               </h3>
               
               <p>MakeHasher returns a new Hasher instance.</p>
               
               <pre><code>func MakeHasher() Hasher</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MethodSet" data-name="MethodSet">
               <h3>
                  MethodSet 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MethodSet" class="anchor" title="Link to MethodSet">#</a>
               </h3>
               
               <p>MethodSet returns the method set of type T.  It is thread-safe.
If cache is nil, this function is equivalent to types.NewMethodSet(T).
Utility functions can thus expose an optional *MethodSetCache
parameter to clients that care about performance.</p>
               
               <pre><code>func (cache *MethodSetCache) MethodSet(T types.Type) *types.MethodSet</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set sets the map entry for key to val,
and returns the previous entry, if any.</p>
               
               <pre><code>func (m *Map) Set(key types.Type, value any) (prev any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetHasher" data-name="SetHasher">
               <h3>
                  SetHasher 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetHasher" class="anchor" title="Link to SetHasher">#</a>
               </h3>
               
               <p>SetHasher sets the hasher used by Map.
All Hashers are functionally equivalent but contain internal state
used to cache the results of hashing previously seen types.
A single Hasher created by MakeHasher() may be shared among many
Maps.  This is recommended if the instances have many keys in
common, as it will amortize the cost of hash computation.
A Hasher may grow without bound as new types are seen.  Even when a
type is deleted from the map, the Hasher never shrinks, since other
types in the map may reference the deleted type indirectly.
Hashers are not thread-safe, and read-only operations such as
Map.Lookup require updates to the hasher, so a full Mutex lock (not a
read-lock) is require around all Map operations if a shared
hasher is accessed from multiple threads.
If SetHasher is not called, the Map will create a private hasher at
the first call to Insert.</p>
               
               <pre><code>func (m *Map) SetHasher(hasher Hasher)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StaticCallee" data-name="StaticCallee">
               <h3>
                  StaticCallee 
                  <span class="badge">function</span>
                  
                  <a href="#StaticCallee" class="anchor" title="Link to StaticCallee">#</a>
               </h3>
               
               <p>StaticCallee returns the target (function or method) of a static function
call, if any. It returns nil for calls to builtins.
Note: for calls of instantiated functions and methods, StaticCallee returns
the corresponding generic function or method on the generic type.</p>
               
               <pre><code>func StaticCallee(info *types.Info, call *ast.CallExpr) *types.Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns a string representation of the map's entries.
Values are printed using fmt.Sprintf("%v", v).
Order is unspecified.</p>
               
               <pre><code>func (m *Map) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashFor" data-name="hashFor">
               <h3>
                  hashFor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hashFor" class="anchor" title="Link to hashFor">#</a>
               </h3>
               
               <p>hashFor computes the hash of t.</p>
               
               <pre><code>func (h Hasher) hashFor(t types.Type) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashPtr" data-name="hashPtr">
               <h3>
                  hashPtr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hashPtr" class="anchor" title="Link to hashPtr">#</a>
               </h3>
               
               <p>hashPtr hashes the pointer identity of ptr. It uses h.ptrMap to ensure that
pointers values are not dependent on the GC.</p>
               
               <pre><code>func (h Hasher) hashPtr(ptr any) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashString" data-name="hashString">
               <h3>
                  hashString 
                  <span class="badge">function</span>
                  
                  <a href="#hashString" class="anchor" title="Link to hashString">#</a>
               </h3>
               
               <p>hashString computes the Fowler–Noll–Vo hash of s.</p>
               
               <pre><code>func hashString(s string) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashTermSet" data-name="hashTermSet">
               <h3>
                  hashTermSet 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hashTermSet" class="anchor" title="Link to hashTermSet">#</a>
               </h3>
               
               <pre><code>func (h Hasher) hashTermSet(terms []*types.Term) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashTuple" data-name="hashTuple">
               <h3>
                  hashTuple 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hashTuple" class="anchor" title="Link to hashTuple">#</a>
               </h3>
               
               <pre><code>func (h Hasher) hashTuple(tuple *types.Tuple) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashTypeParam" data-name="hashTypeParam">
               <h3>
                  hashTypeParam 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hashTypeParam" class="anchor" title="Link to hashTypeParam">#</a>
               </h3>
               
               <p>hashTypeParam returns a hash of the type parameter t, with a hash value
depending on whether t is contained in h.sigTParams.
If h.sigTParams is set and contains t, then we are in the process of hashing
a signature, and the hash value of t must depend only on t's index and
constraint: signatures are considered identical modulo type parameter
renaming. To avoid infinite recursion, we only hash the type parameter
index, and rely on types.Identical to handle signatures where constraints
are not identical.
Otherwise the hash of t depends only on t's pointer identity.</p>
               
               <pre><code>func (h Hasher) hashTypeParam(t *types.TypeParam) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashUnion" data-name="hashUnion">
               <h3>
                  hashUnion 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hashUnion" class="anchor" title="Link to hashUnion">#</a>
               </h3>
               
               <pre><code>func (h Hasher) hashUnion(t *types.Union) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="interfaceMethod" data-name="interfaceMethod">
               <h3>
                  interfaceMethod 
                  <span class="badge">function</span>
                  
                  <a href="#interfaceMethod" class="anchor" title="Link to interfaceMethod">#</a>
               </h3>
               
               <pre><code>func interfaceMethod(f *types.Func) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupNamed" data-name="lookupNamed">
               <h3>
                  lookupNamed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookupNamed" class="anchor" title="Link to lookupNamed">#</a>
               </h3>
               
               <pre><code>func (cache *MethodSetCache) lookupNamed(named *types.Named) struct{...}</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shallowHash" data-name="shallowHash">
               <h3>
                  shallowHash 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shallowHash" class="anchor" title="Link to shallowHash">#</a>
               </h3>
               
               <p>shallowHash computes a hash of t without looking at any of its
element Types, to avoid potential anonymous cycles in the types of
interface methods.
When an unnamed non-empty interface type appears anywhere among the
arguments or results of an interface method, there is a potential
for endless recursion. Consider:
type X interface { m() []*interface { X } }
The problem is that the Methods of the interface in m's result type
include m itself; there is no mention of the named type X that
might help us break the cycle.
(See comment in go/types.identical, case *Interface, for more.)</p>
               
               <pre><code>func (h Hasher) shallowHash(t types.Type) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toString" data-name="toString">
               <h3>
                  toString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#toString" class="anchor" title="Link to toString">#</a>
               </h3>
               
               <pre><code>func (m *Map) toString(values bool) string</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>