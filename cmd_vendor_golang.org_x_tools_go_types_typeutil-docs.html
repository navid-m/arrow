<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - typeutil</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>typeutil</code>
         </h1>
         <hr />
          
         <article class="struct" data-name="Map">
            <h2>type Map struct</h2>
            <hr />
            
            <p>Map is a hash-table-based mapping from types (types.Type) to
arbitrary any values.  The concrete types that implement
the Type interface are pointers.  Since they are not canonicalized,
== cannot be used to check for equivalence, and thus we cannot
simply use a Go map.

Just as with map[K]V, a nil *Map is a valid empty map.

Not thread-safe.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">hasher Hasher
table *ast.MapType
length int</code></pre>
         </article>
         
         <article class="struct" data-name="entry">
            <h2>type entry struct</h2>
            <hr />
            
            <p>entry is an entry (key/value association) in a hash bucket.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">key types.Type
value any</code></pre>
         </article>
         
         <article class="struct" data-name="Hasher">
            <h2>type Hasher struct</h2>
            <hr />
            
            <p>A Hasher maps each type to its hash value.
For efficiency, a hasher uses memoization; thus its memory
footprint grows monotonically over time.
Hashers are not thread-safe.
Hashers have reference semantics.
Call MakeHasher to create a Hasher.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">memo *ast.MapType
ptrMap *ast.MapType
sigTParams *types.TypeParamList</code></pre>
         </article>
         
         <article class="struct" data-name="MethodSetCache">
            <h2>type MethodSetCache struct</h2>
            <hr />
            
            <p>A MethodSetCache records the method set of each type T for which
MethodSet(T) is called so that repeat queries are fast.
The zero value is a ready-to-use cache instance.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">mu sync.Mutex
named *ast.MapType
others *ast.MapType</code></pre>
         </article>
          
         <article class="function" data-name="Dependencies">
            <h2>Dependencies</h2>
            <hr />
            
            <p>Dependencies returns all dependencies of the specified packages.

Dependent packages appear in topological order: if package P imports
package Q, Q appears earlier than P in the result.
The algorithm follows import statements in the order they
appear in the source code, so the result is a total order.</p>
            
            <pre><code>func Dependencies(pkgs ...*types.Package) []*types.Package</code></pre>
         </article>
         
         <article class="function" data-name="SetHasher">
            <h2>SetHasher</h2>
            <hr />
            
            <p>SetHasher sets the hasher used by Map.

All Hashers are functionally equivalent but contain internal state
used to cache the results of hashing previously seen types.

A single Hasher created by MakeHasher() may be shared among many
Maps.  This is recommended if the instances have many keys in
common, as it will amortize the cost of hash computation.

A Hasher may grow without bound as new types are seen.  Even when a
type is deleted from the map, the Hasher never shrinks, since other
types in the map may reference the deleted type indirectly.

Hashers are not thread-safe, and read-only operations such as
Map.Lookup require updates to the hasher, so a full Mutex lock (not a
read-lock) is require around all Map operations if a shared
hasher is accessed from multiple threads.

If SetHasher is not called, the Map will create a private hasher at
the first call to Insert.</p>
            
            <pre><code>func SetHasher(hasher Hasher)</code></pre>
         </article>
         
         <article class="function" data-name="Delete">
            <h2>Delete</h2>
            <hr />
            
            <p>Delete removes the entry with the given key, if any.
It returns true if the entry was found.</p>
            
            <pre><code>func Delete(key types.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="At">
            <h2>At</h2>
            <hr />
            
            <p>At returns the map entry for the given key.
The result is nil if the entry is not present.</p>
            
            <pre><code>func At(key types.Type) any</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <p>Set sets the map entry for key to val,
and returns the previous entry, if any.</p>
            
            <pre><code>func Set(key types.Type, value any) prev any</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <p>Len returns the number of map entries.</p>
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Iterate">
            <h2>Iterate</h2>
            <hr />
            
            <p>Iterate calls function f on each entry in the map in unspecified order.

If f should mutate the map, Iterate provides the same guarantees as
Go maps: if f deletes a map entry that Iterate has not yet reached,
f will not be invoked for it, but if f inserts a map entry that
Iterate has not yet reached, whether or not f will be invoked for
it is unspecified.</p>
            
            <pre><code>func Iterate(f func)</code></pre>
         </article>
         
         <article class="function" data-name="Keys">
            <h2>Keys</h2>
            <hr />
            
            <p>Keys returns a new slice containing the set of map keys.
The order is unspecified.</p>
            
            <pre><code>func Keys() []types.Type</code></pre>
         </article>
         
         <article class="function" data-name="toString">
            <h2>toString</h2>
            <hr />
            
            <pre><code>func toString(values bool) string</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns a string representation of the map's entries.
Values are printed using fmt.Sprintf("%v", v).
Order is unspecified.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="KeysString">
            <h2>KeysString</h2>
            <hr />
            
            <p>KeysString returns a string representation of the map's key set.
Order is unspecified.</p>
            
            <pre><code>func KeysString() string</code></pre>
         </article>
         
         <article class="function" data-name="MakeHasher">
            <h2>MakeHasher</h2>
            <hr />
            
            <p>MakeHasher returns a new Hasher instance.</p>
            
            <pre><code>func MakeHasher() Hasher</code></pre>
         </article>
         
         <article class="function" data-name="Hash">
            <h2>Hash</h2>
            <hr />
            
            <p>Hash computes a hash value for the given type t such that
Identical(t, t') => Hash(t) == Hash(t').</p>
            
            <pre><code>func Hash(t types.Type) uint32</code></pre>
         </article>
         
         <article class="function" data-name="hashString">
            <h2>hashString</h2>
            <hr />
            
            <p>hashString computes the Fowler–Noll–Vo hash of s.</p>
            
            <pre><code>func hashString(s string) uint32</code></pre>
         </article>
         
         <article class="function" data-name="hashFor">
            <h2>hashFor</h2>
            <hr />
            
            <p>hashFor computes the hash of t.</p>
            
            <pre><code>func hashFor(t types.Type) uint32</code></pre>
         </article>
         
         <article class="function" data-name="hashTuple">
            <h2>hashTuple</h2>
            <hr />
            
            <pre><code>func hashTuple(tuple *types.Tuple) uint32</code></pre>
         </article>
         
         <article class="function" data-name="hashUnion">
            <h2>hashUnion</h2>
            <hr />
            
            <pre><code>func hashUnion(t *types.Union) uint32</code></pre>
         </article>
         
         <article class="function" data-name="hashTermSet">
            <h2>hashTermSet</h2>
            <hr />
            
            <pre><code>func hashTermSet(terms []*types.Term) uint32</code></pre>
         </article>
         
         <article class="function" data-name="hashTypeParam">
            <h2>hashTypeParam</h2>
            <hr />
            
            <p>hashTypeParam returns a hash of the type parameter t, with a hash value
depending on whether t is contained in h.sigTParams.

If h.sigTParams is set and contains t, then we are in the process of hashing
a signature, and the hash value of t must depend only on t's index and
constraint: signatures are considered identical modulo type parameter
renaming. To avoid infinite recursion, we only hash the type parameter
index, and rely on types.Identical to handle signatures where constraints
are not identical.

Otherwise the hash of t depends only on t's pointer identity.</p>
            
            <pre><code>func hashTypeParam(t *types.TypeParam) uint32</code></pre>
         </article>
         
         <article class="function" data-name="hashPtr">
            <h2>hashPtr</h2>
            <hr />
            
            <p>hashPtr hashes the pointer identity of ptr. It uses h.ptrMap to ensure that
pointers values are not dependent on the GC.</p>
            
            <pre><code>func hashPtr(ptr any) uint32</code></pre>
         </article>
         
         <article class="function" data-name="shallowHash">
            <h2>shallowHash</h2>
            <hr />
            
            <p>shallowHash computes a hash of t without looking at any of its
element Types, to avoid potential anonymous cycles in the types of
interface methods.

When an unnamed non-empty interface type appears anywhere among the
arguments or results of an interface method, there is a potential
for endless recursion. Consider:

	type X interface { m() []*interface { X } }

The problem is that the Methods of the interface in m's result type
include m itself; there is no mention of the named type X that
might help us break the cycle.
(See comment in go/types.identical, case *Interface, for more.)</p>
            
            <pre><code>func shallowHash(t types.Type) uint32</code></pre>
         </article>
         
         <article class="function" data-name="MethodSet">
            <h2>MethodSet</h2>
            <hr />
            
            <p>MethodSet returns the method set of type T.  It is thread-safe.

If cache is nil, this function is equivalent to types.NewMethodSet(T).
Utility functions can thus expose an optional *MethodSetCache
parameter to clients that care about performance.</p>
            
            <pre><code>func MethodSet(T types.Type) *types.MethodSet</code></pre>
         </article>
         
         <article class="function" data-name="lookupNamed">
            <h2>lookupNamed</h2>
            <hr />
            
            <pre><code>func lookupNamed(named *types.Named) *ast.StructType</code></pre>
         </article>
         
         <article class="function" data-name="IntuitiveMethodSet">
            <h2>IntuitiveMethodSet</h2>
            <hr />
            
            <p>IntuitiveMethodSet returns the intuitive method set of a type T,
which is the set of methods you can call on an addressable value of
that type.

The result always contains MethodSet(T), and is exactly MethodSet(T)
for interface types and for pointer-to-concrete types.
For all other concrete types T, the result additionally
contains each method belonging to *T if there is no identically
named method on T itself.

This corresponds to user intuition about method sets;
this function is intended only for user interfaces.

The order of the result is as for types.MethodSet(T).</p>
            
            <pre><code>func IntuitiveMethodSet(T types.Type, msets *MethodSetCache) []*types.Selection</code></pre>
         </article>
         
         <article class="function" data-name="Callee">
            <h2>Callee</h2>
            <hr />
            
            <p>Callee returns the named target of a function call, if any:
a function, method, builtin, or variable.

Functions and methods may potentially have type parameters.</p>
            
            <pre><code>func Callee(info *types.Info, call *ast.CallExpr) types.Object</code></pre>
         </article>
         
         <article class="function" data-name="StaticCallee">
            <h2>StaticCallee</h2>
            <hr />
            
            <p>StaticCallee returns the target (function or method) of a static function
call, if any. It returns nil for calls to builtins.

Note: for calls of instantiated functions and methods, StaticCallee returns
the corresponding generic function or method on the generic type.</p>
            
            <pre><code>func StaticCallee(info *types.Info, call *ast.CallExpr) *types.Func</code></pre>
         </article>
         
         <article class="function" data-name="interfaceMethod">
            <h2>interfaceMethod</h2>
            <hr />
            
            <pre><code>func interfaceMethod(f *types.Func) bool</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
