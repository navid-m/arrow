<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - scanner</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>scanner</code>
         </h1>
         <hr />
         
         <article class="global" data-name="segmentList">
            <h2>segmentList</h2>
            <hr />
            
            <pre><code>segmentList</code></pre>
         </article>
         
         <article class="global" data-name="f100">
            <h2>f100</h2>
            <hr />
            
            <pre><code>f100</code></pre>
         </article>
         
         <article class="global" data-name="tokenList">
            <h2>tokenList</h2>
            <hr />
            
            <pre><code>tokenList</code></pre>
         </article>
         
         <article class="global" data-name="ScanIdents">
            <h2>ScanIdents</h2>
            <hr />
            
            <p>Predefined mode bits to control recognition of tokens. For instance,
to configure a [Scanner] such that it only recognizes (Go) identifiers,
integers, and skips comments, set the Scanner's Mode field to:

	ScanIdents | ScanInts | SkipComments

With the exceptions of comments, which are skipped if SkipComments is
set, unrecognized tokens are not ignored. Instead, the scanner simply
returns the respective individual characters (or possibly sub-tokens).
For instance, if the mode is ScanIdents (not ScanStrings), the string
"foo" is scanned as the token sequence '"' [Ident] '"'.

Use GoTokens to configure the Scanner such that it accepts all Go
literal tokens including Go identifiers. Comments will be skipped.</p>
            
            <pre><code>ScanIdents</code></pre>
         </article>
         
         <article class="global" data-name="ScanInts">
            <h2>ScanInts</h2>
            <hr />
            
            <p>Predefined mode bits to control recognition of tokens. For instance,
to configure a [Scanner] such that it only recognizes (Go) identifiers,
integers, and skips comments, set the Scanner's Mode field to:

	ScanIdents | ScanInts | SkipComments

With the exceptions of comments, which are skipped if SkipComments is
set, unrecognized tokens are not ignored. Instead, the scanner simply
returns the respective individual characters (or possibly sub-tokens).
For instance, if the mode is ScanIdents (not ScanStrings), the string
"foo" is scanned as the token sequence '"' [Ident] '"'.

Use GoTokens to configure the Scanner such that it accepts all Go
literal tokens including Go identifiers. Comments will be skipped.</p>
            
            <pre><code>ScanInts</code></pre>
         </article>
         
         <article class="global" data-name="ScanFloats">
            <h2>ScanFloats</h2>
            <hr />
            
            <p>Predefined mode bits to control recognition of tokens. For instance,
to configure a [Scanner] such that it only recognizes (Go) identifiers,
integers, and skips comments, set the Scanner's Mode field to:

	ScanIdents | ScanInts | SkipComments

With the exceptions of comments, which are skipped if SkipComments is
set, unrecognized tokens are not ignored. Instead, the scanner simply
returns the respective individual characters (or possibly sub-tokens).
For instance, if the mode is ScanIdents (not ScanStrings), the string
"foo" is scanned as the token sequence '"' [Ident] '"'.

Use GoTokens to configure the Scanner such that it accepts all Go
literal tokens including Go identifiers. Comments will be skipped.</p>
            
            <pre><code>ScanFloats</code></pre>
         </article>
         
         <article class="global" data-name="ScanChars">
            <h2>ScanChars</h2>
            <hr />
            
            <p>Predefined mode bits to control recognition of tokens. For instance,
to configure a [Scanner] such that it only recognizes (Go) identifiers,
integers, and skips comments, set the Scanner's Mode field to:

	ScanIdents | ScanInts | SkipComments

With the exceptions of comments, which are skipped if SkipComments is
set, unrecognized tokens are not ignored. Instead, the scanner simply
returns the respective individual characters (or possibly sub-tokens).
For instance, if the mode is ScanIdents (not ScanStrings), the string
"foo" is scanned as the token sequence '"' [Ident] '"'.

Use GoTokens to configure the Scanner such that it accepts all Go
literal tokens including Go identifiers. Comments will be skipped.</p>
            
            <pre><code>ScanChars</code></pre>
         </article>
         
         <article class="global" data-name="ScanStrings">
            <h2>ScanStrings</h2>
            <hr />
            
            <p>Predefined mode bits to control recognition of tokens. For instance,
to configure a [Scanner] such that it only recognizes (Go) identifiers,
integers, and skips comments, set the Scanner's Mode field to:

	ScanIdents | ScanInts | SkipComments

With the exceptions of comments, which are skipped if SkipComments is
set, unrecognized tokens are not ignored. Instead, the scanner simply
returns the respective individual characters (or possibly sub-tokens).
For instance, if the mode is ScanIdents (not ScanStrings), the string
"foo" is scanned as the token sequence '"' [Ident] '"'.

Use GoTokens to configure the Scanner such that it accepts all Go
literal tokens including Go identifiers. Comments will be skipped.</p>
            
            <pre><code>ScanStrings</code></pre>
         </article>
         
         <article class="global" data-name="ScanRawStrings">
            <h2>ScanRawStrings</h2>
            <hr />
            
            <p>Predefined mode bits to control recognition of tokens. For instance,
to configure a [Scanner] such that it only recognizes (Go) identifiers,
integers, and skips comments, set the Scanner's Mode field to:

	ScanIdents | ScanInts | SkipComments

With the exceptions of comments, which are skipped if SkipComments is
set, unrecognized tokens are not ignored. Instead, the scanner simply
returns the respective individual characters (or possibly sub-tokens).
For instance, if the mode is ScanIdents (not ScanStrings), the string
"foo" is scanned as the token sequence '"' [Ident] '"'.

Use GoTokens to configure the Scanner such that it accepts all Go
literal tokens including Go identifiers. Comments will be skipped.</p>
            
            <pre><code>ScanRawStrings</code></pre>
         </article>
         
         <article class="global" data-name="ScanComments">
            <h2>ScanComments</h2>
            <hr />
            
            <p>Predefined mode bits to control recognition of tokens. For instance,
to configure a [Scanner] such that it only recognizes (Go) identifiers,
integers, and skips comments, set the Scanner's Mode field to:

	ScanIdents | ScanInts | SkipComments

With the exceptions of comments, which are skipped if SkipComments is
set, unrecognized tokens are not ignored. Instead, the scanner simply
returns the respective individual characters (or possibly sub-tokens).
For instance, if the mode is ScanIdents (not ScanStrings), the string
"foo" is scanned as the token sequence '"' [Ident] '"'.

Use GoTokens to configure the Scanner such that it accepts all Go
literal tokens including Go identifiers. Comments will be skipped.</p>
            
            <pre><code>ScanComments</code></pre>
         </article>
         
         <article class="global" data-name="SkipComments">
            <h2>SkipComments</h2>
            <hr />
            
            <p>Predefined mode bits to control recognition of tokens. For instance,
to configure a [Scanner] such that it only recognizes (Go) identifiers,
integers, and skips comments, set the Scanner's Mode field to:

	ScanIdents | ScanInts | SkipComments

With the exceptions of comments, which are skipped if SkipComments is
set, unrecognized tokens are not ignored. Instead, the scanner simply
returns the respective individual characters (or possibly sub-tokens).
For instance, if the mode is ScanIdents (not ScanStrings), the string
"foo" is scanned as the token sequence '"' [Ident] '"'.

Use GoTokens to configure the Scanner such that it accepts all Go
literal tokens including Go identifiers. Comments will be skipped.</p>
            
            <pre><code>SkipComments</code></pre>
         </article>
         
         <article class="global" data-name="GoTokens">
            <h2>GoTokens</h2>
            <hr />
            
            <p>Predefined mode bits to control recognition of tokens. For instance,
to configure a [Scanner] such that it only recognizes (Go) identifiers,
integers, and skips comments, set the Scanner's Mode field to:

	ScanIdents | ScanInts | SkipComments

With the exceptions of comments, which are skipped if SkipComments is
set, unrecognized tokens are not ignored. Instead, the scanner simply
returns the respective individual characters (or possibly sub-tokens).
For instance, if the mode is ScanIdents (not ScanStrings), the string
"foo" is scanned as the token sequence '"' [Ident] '"'.

Use GoTokens to configure the Scanner such that it accepts all Go
literal tokens including Go identifiers. Comments will be skipped.</p>
            
            <pre><code>GoTokens</code></pre>
         </article>
         
         <article class="global" data-name="EOF">
            <h2>EOF</h2>
            <hr />
            
            <p>The result of Scan is one of these tokens or a Unicode character.</p>
            
            <pre><code>EOF</code></pre>
         </article>
         
         <article class="global" data-name="Ident">
            <h2>Ident</h2>
            <hr />
            
            <p>The result of Scan is one of these tokens or a Unicode character.</p>
            
            <pre><code>Ident</code></pre>
         </article>
         
         <article class="global" data-name="Int">
            <h2>Int</h2>
            <hr />
            
            <p>The result of Scan is one of these tokens or a Unicode character.</p>
            
            <pre><code>Int</code></pre>
         </article>
         
         <article class="global" data-name="Float">
            <h2>Float</h2>
            <hr />
            
            <p>The result of Scan is one of these tokens or a Unicode character.</p>
            
            <pre><code>Float</code></pre>
         </article>
         
         <article class="global" data-name="Char">
            <h2>Char</h2>
            <hr />
            
            <p>The result of Scan is one of these tokens or a Unicode character.</p>
            
            <pre><code>Char</code></pre>
         </article>
         
         <article class="global" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>The result of Scan is one of these tokens or a Unicode character.</p>
            
            <pre><code>String</code></pre>
         </article>
         
         <article class="global" data-name="RawString">
            <h2>RawString</h2>
            <hr />
            
            <p>The result of Scan is one of these tokens or a Unicode character.</p>
            
            <pre><code>RawString</code></pre>
         </article>
         
         <article class="global" data-name="Comment">
            <h2>Comment</h2>
            <hr />
            
            <p>The result of Scan is one of these tokens or a Unicode character.</p>
            
            <pre><code>Comment</code></pre>
         </article>
         
         <article class="global" data-name="skipComment">
            <h2>skipComment</h2>
            <hr />
            
            <p>internal use only</p>
            
            <pre><code>skipComment</code></pre>
         </article>
         
         <article class="global" data-name="tokenString">
            <h2>tokenString</h2>
            <hr />
            
            <pre><code>tokenString</code></pre>
         </article>
         
         <article class="global" data-name="GoWhitespace">
            <h2>GoWhitespace</h2>
            <hr />
            
            <p>GoWhitespace is the default value for the [Scanner]'s Whitespace field.
Its value selects Go's white space characters.</p>
            
            <pre><code>GoWhitespace</code></pre>
         </article>
         
         <article class="global" data-name="bufLen">
            <h2>bufLen</h2>
            <hr />
            
            <pre><code>bufLen</code></pre>
         </article>
          
         <article class="struct" data-name="StringReader">
            <h2>type StringReader struct</h2>
            <hr />
            
            <p>A StringReader delivers its data one string segment at a time via Read.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">data []string
step int</code></pre>
         </article>
         
         <article class="struct" data-name="token">
            <h2>type token struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">tok rune
text string</code></pre>
         </article>
         
         <article class="struct" data-name="errReader">
            <h2>type errReader struct</h2>
            <hr />
            
            <p>An errReader returns (0, err) where err is not io.EOF.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="Position">
            <h2>type Position struct</h2>
            <hr />
            
            <p>Position is a value that represents a source position.
A position is valid if Line > 0.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Filename string
Offset int
Line int
Column int</code></pre>
         </article>
         
         <article class="struct" data-name="Scanner">
            <h2>type Scanner struct</h2>
            <hr />
            
            <p>A Scanner implements reading of Unicode characters and tokens from an [io.Reader].</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">src io.Reader
srcBuf []byte
srcPos int
srcEnd int
srcBufOffset int
line int
column int
lastLineLen int
lastCharLen int
tokBuf bytes.Buffer
tokPos int
tokEnd int
ch rune
Error func
ErrorCount int
Mode uint
Whitespace uint64
IsIdentRune func
Position</code></pre>
         </article>
          
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readRuneSegments">
            <h2>readRuneSegments</h2>
            <hr />
            
            <pre><code>func readRuneSegments(t *testing.T, segments []string)</code></pre>
         </article>
         
         <article class="function" data-name="TestNext">
            <h2>TestNext</h2>
            <hr />
            
            <pre><code>func TestNext(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="makeSource">
            <h2>makeSource</h2>
            <hr />
            
            <pre><code>func makeSource(pattern string) *bytes.Buffer</code></pre>
         </article>
         
         <article class="function" data-name="checkTok">
            <h2>checkTok</h2>
            <hr />
            
            <pre><code>func checkTok(t *testing.T, s *Scanner, line int, got rune, want rune, text string)</code></pre>
         </article>
         
         <article class="function" data-name="checkTokErr">
            <h2>checkTokErr</h2>
            <hr />
            
            <pre><code>func checkTokErr(t *testing.T, s *Scanner, line int, want rune, text string)</code></pre>
         </article>
         
         <article class="function" data-name="countNewlines">
            <h2>countNewlines</h2>
            <hr />
            
            <pre><code>func countNewlines(s string) int</code></pre>
         </article>
         
         <article class="function" data-name="testScan">
            <h2>testScan</h2>
            <hr />
            
            <pre><code>func testScan(t *testing.T, mode uint)</code></pre>
         </article>
         
         <article class="function" data-name="TestScan">
            <h2>TestScan</h2>
            <hr />
            
            <pre><code>func TestScan(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInvalidExponent">
            <h2>TestInvalidExponent</h2>
            <hr />
            
            <pre><code>func TestInvalidExponent(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPosition">
            <h2>TestPosition</h2>
            <hr />
            
            <pre><code>func TestPosition(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanZeroMode">
            <h2>TestScanZeroMode</h2>
            <hr />
            
            <pre><code>func TestScanZeroMode(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testScanSelectedMode">
            <h2>testScanSelectedMode</h2>
            <hr />
            
            <pre><code>func testScanSelectedMode(t *testing.T, mode uint, class rune)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanSelectedMask">
            <h2>TestScanSelectedMask</h2>
            <hr />
            
            <pre><code>func TestScanSelectedMask(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanCustomIdent">
            <h2>TestScanCustomIdent</h2>
            <hr />
            
            <pre><code>func TestScanCustomIdent(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanNext">
            <h2>TestScanNext</h2>
            <hr />
            
            <pre><code>func TestScanNext(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanWhitespace">
            <h2>TestScanWhitespace</h2>
            <hr />
            
            <pre><code>func TestScanWhitespace(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testError">
            <h2>testError</h2>
            <hr />
            
            <pre><code>func testError(t *testing.T, src string, pos string, msg string, tok rune)</code></pre>
         </article>
         
         <article class="function" data-name="TestError">
            <h2>TestError</h2>
            <hr />
            
            <pre><code>func TestError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(b []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestIOError">
            <h2>TestIOError</h2>
            <hr />
            
            <pre><code>func TestIOError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="checkPos">
            <h2>checkPos</h2>
            <hr />
            
            <pre><code>func checkPos(t *testing.T, got Position, want Position)</code></pre>
         </article>
         
         <article class="function" data-name="checkNextPos">
            <h2>checkNextPos</h2>
            <hr />
            
            <pre><code>func checkNextPos(t *testing.T, s *Scanner, offset int, line int, column int, char rune)</code></pre>
         </article>
         
         <article class="function" data-name="checkScanPos">
            <h2>checkScanPos</h2>
            <hr />
            
            <pre><code>func checkScanPos(t *testing.T, s *Scanner, offset int, line int, column int, char rune)</code></pre>
         </article>
         
         <article class="function" data-name="TestPos">
            <h2>TestPos</h2>
            <hr />
            
            <pre><code>func TestPos(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read([]byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestNextEOFHandling">
            <h2>TestNextEOFHandling</h2>
            <hr />
            
            <pre><code>func TestNextEOFHandling(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScanEOFHandling">
            <h2>TestScanEOFHandling</h2>
            <hr />
            
            <pre><code>func TestScanEOFHandling(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue29723">
            <h2>TestIssue29723</h2>
            <hr />
            
            <pre><code>func TestIssue29723(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNumbers">
            <h2>TestNumbers</h2>
            <hr />
            
            <pre><code>func TestNumbers(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue30320">
            <h2>TestIssue30320</h2>
            <hr />
            
            <pre><code>func TestIssue30320(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="extractInts">
            <h2>extractInts</h2>
            <hr />
            
            <pre><code>func extractInts(t string, mode uint) res string</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue50909">
            <h2>TestIssue50909</h2>
            <hr />
            
            <pre><code>func TestIssue50909(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="IsValid">
            <h2>IsValid</h2>
            <hr />
            
            <p>IsValid reports whether the position is valid.</p>
            
            <pre><code>func IsValid() bool</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="TokenString">
            <h2>TokenString</h2>
            <hr />
            
            <p>TokenString returns a printable string for a token or Unicode character.</p>
            
            <pre><code>func TokenString(tok rune) string</code></pre>
         </article>
         
         <article class="function" data-name="Init">
            <h2>Init</h2>
            <hr />
            
            <p>Init initializes a [Scanner] with a new source and returns s.
[Scanner.Error] is set to nil, [Scanner.ErrorCount] is set to 0, [Scanner.Mode] is set to [GoTokens],
and [Scanner.Whitespace] is set to [GoWhitespace].</p>
            
            <pre><code>func Init(src io.Reader) *Scanner</code></pre>
         </article>
         
         <article class="function" data-name="next">
            <h2>next</h2>
            <hr />
            
            <p>next reads and returns the next Unicode character. It is designed such
that only a minimal amount of work needs to be done in the common ASCII
case (one test to check for both ASCII and end-of-buffer, and one test
to check for newlines).</p>
            
            <pre><code>func next() rune</code></pre>
         </article>
         
         <article class="function" data-name="Next">
            <h2>Next</h2>
            <hr />
            
            <p>Next reads and returns the next Unicode character.
It returns [EOF] at the end of the source. It reports
a read error by calling s.Error, if not nil; otherwise
it prints an error message to [os.Stderr]. Next does not
update the [Scanner.Position] field; use [Scanner.Pos]() to
get the current position.</p>
            
            <pre><code>func Next() rune</code></pre>
         </article>
         
         <article class="function" data-name="Peek">
            <h2>Peek</h2>
            <hr />
            
            <p>Peek returns the next Unicode character in the source without advancing
the scanner. It returns [EOF] if the scanner's position is at the last
character of the source.</p>
            
            <pre><code>func Peek() rune</code></pre>
         </article>
         
         <article class="function" data-name="error">
            <h2>error</h2>
            <hr />
            
            <pre><code>func error(msg string)</code></pre>
         </article>
         
         <article class="function" data-name="errorf">
            <h2>errorf</h2>
            <hr />
            
            <pre><code>func errorf(format string, args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="isIdentRune">
            <h2>isIdentRune</h2>
            <hr />
            
            <pre><code>func isIdentRune(ch rune, i int) bool</code></pre>
         </article>
         
         <article class="function" data-name="scanIdentifier">
            <h2>scanIdentifier</h2>
            <hr />
            
            <pre><code>func scanIdentifier() rune</code></pre>
         </article>
         
         <article class="function" data-name="lower">
            <h2>lower</h2>
            <hr />
            
            <pre><code>func lower(ch rune) rune</code></pre>
         </article>
         
         <article class="function" data-name="isDecimal">
            <h2>isDecimal</h2>
            <hr />
            
            <pre><code>func isDecimal(ch rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="isHex">
            <h2>isHex</h2>
            <hr />
            
            <pre><code>func isHex(ch rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="digits">
            <h2>digits</h2>
            <hr />
            
            <p>digits accepts the sequence { digit | '_' } starting with ch0.
If base <= 10, digits accepts any decimal digit but records
the first invalid digit >= base in *invalid if *invalid == 0.
digits returns the first rune that is not part of the sequence
anymore, and a bitset describing whether the sequence contained
digits (bit 0 is set), or separators '_' (bit 1 is set).</p>
            
            <pre><code>func digits(ch0 rune, base int, invalid *rune) (ch rune, digsep int)</code></pre>
         </article>
         
         <article class="function" data-name="scanNumber">
            <h2>scanNumber</h2>
            <hr />
            
            <pre><code>func scanNumber(ch rune, seenDot bool) (rune, rune)</code></pre>
         </article>
         
         <article class="function" data-name="litname">
            <h2>litname</h2>
            <hr />
            
            <pre><code>func litname(prefix rune) string</code></pre>
         </article>
         
         <article class="function" data-name="invalidSep">
            <h2>invalidSep</h2>
            <hr />
            
            <p>invalidSep returns the index of the first invalid separator in x, or -1.</p>
            
            <pre><code>func invalidSep(x string) int</code></pre>
         </article>
         
         <article class="function" data-name="digitVal">
            <h2>digitVal</h2>
            <hr />
            
            <pre><code>func digitVal(ch rune) int</code></pre>
         </article>
         
         <article class="function" data-name="scanDigits">
            <h2>scanDigits</h2>
            <hr />
            
            <pre><code>func scanDigits(ch rune, base int, n int) rune</code></pre>
         </article>
         
         <article class="function" data-name="scanEscape">
            <h2>scanEscape</h2>
            <hr />
            
            <pre><code>func scanEscape(quote rune) rune</code></pre>
         </article>
         
         <article class="function" data-name="scanString">
            <h2>scanString</h2>
            <hr />
            
            <pre><code>func scanString(quote rune) n int</code></pre>
         </article>
         
         <article class="function" data-name="scanRawString">
            <h2>scanRawString</h2>
            <hr />
            
            <pre><code>func scanRawString()</code></pre>
         </article>
         
         <article class="function" data-name="scanChar">
            <h2>scanChar</h2>
            <hr />
            
            <pre><code>func scanChar()</code></pre>
         </article>
         
         <article class="function" data-name="scanComment">
            <h2>scanComment</h2>
            <hr />
            
            <pre><code>func scanComment(ch rune) rune</code></pre>
         </article>
         
         <article class="function" data-name="Scan">
            <h2>Scan</h2>
            <hr />
            
            <p>Scan reads the next token or Unicode character from source and returns it.
It only recognizes tokens t for which the respective [Scanner.Mode] bit (1<<-t) is set.
It returns [EOF] at the end of the source. It reports scanner errors (read and
token errors) by calling s.Error, if not nil; otherwise it prints an error
message to [os.Stderr].</p>
            
            <pre><code>func Scan() rune</code></pre>
         </article>
         
         <article class="function" data-name="Pos">
            <h2>Pos</h2>
            <hr />
            
            <p>Pos returns the position of the character immediately after
the character or token returned by the last call to [Scanner.Next] or [Scanner.Scan].
Use the [Scanner.Position] field for the start position of the most
recently scanned token.</p>
            
            <pre><code>func Pos() pos Position</code></pre>
         </article>
         
         <article class="function" data-name="TokenText">
            <h2>TokenText</h2>
            <hr />
            
            <p>TokenText returns the string corresponding to the most recently scanned token.
Valid after calling [Scanner.Scan] and in calls of [Scanner.Error].</p>
            
            <pre><code>func TokenText() string</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
