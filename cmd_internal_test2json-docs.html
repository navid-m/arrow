<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - test2json</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>test2json</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"bytes"
"encoding/json"
"fmt"
"io"
"strconv"
"strings"
"time"
"unicode"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="Timestamp" data-name="Timestamp">
               <h3>
                  Timestamp 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Timestamp" class="anchor" title="Link to Timestamp">#</a>
               </h3>
               
               <pre><code class="language-go">const Timestamp Mode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="benchmark" data-name="benchmark">
               <h3>
                  benchmark 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#benchmark" class="anchor" title="Link to benchmark">#</a>
               </h3>
               
               <pre><code class="language-go">var benchmark = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bigFail" data-name="bigFail">
               <h3>
                  bigFail 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bigFail" class="anchor" title="Link to bigFail">#</a>
               </h3>
               
                  <p class="doc-comment">printed by test after a normal test failure.</p>
               
               <pre><code class="language-go">var bigFail = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bigFailErrorPrefix" data-name="bigFailErrorPrefix">
               <h3>
                  bigFailErrorPrefix 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bigFailErrorPrefix" class="anchor" title="Link to bigFailErrorPrefix">#</a>
               </h3>
               
                  <p class="doc-comment">printed by 'go test' along with an error if the test binary terminates
with an error.</p>
               
               <pre><code class="language-go">var bigFailErrorPrefix = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bigPass" data-name="bigPass">
               <h3>
                  bigPass 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bigPass" class="anchor" title="Link to bigPass">#</a>
               </h3>
               
                  <p class="doc-comment">printed by test on successful run.</p>
               
               <pre><code class="language-go">var bigPass = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="emptyName" data-name="emptyName">
               <h3>
                  emptyName 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#emptyName" class="anchor" title="Link to emptyName">#</a>
               </h3>
               
                  <p class="doc-comment">an === NAME line with no test name, if trailing spaces are deleted</p>
               
               <pre><code class="language-go">var emptyName = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="emptyNameLine" data-name="emptyNameLine">
               <h3>
                  emptyNameLine 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#emptyNameLine" class="anchor" title="Link to emptyNameLine">#</a>
               </h3>
               
               <pre><code class="language-go">var emptyNameLine = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fourSpace" data-name="fourSpace">
               <h3>
                  fourSpace 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#fourSpace" class="anchor" title="Link to fourSpace">#</a>
               </h3>
               
               <pre><code class="language-go">var fourSpace = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inBuffer" data-name="inBuffer">
               <h3>
                  inBuffer 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#inBuffer" class="anchor" title="Link to inBuffer">#</a>
               </h3>
               
                  <p class="doc-comment">inBuffer and outBuffer are the input and output buffer sizes.
They're variables so that they can be reduced during testing.
The input buffer needs to be able to hold any single test
directive line we want to recognize, like:
<many spaces> --- PASS: very/nested/s/u/b/t/e/s/t
If anyone reports a test directive line > 4k not working, it will
be defensible to suggest they restructure their test or test names.
The output buffer must be >= utf8.UTFMax, so that it can
accumulate any single UTF8 sequence. Lines that fit entirely
within the output buffer are emitted in single output events.
Otherwise they are split into multiple events.
The output buffer size therefore limits the size of the encoding
of a single JSON output event. 1k seems like a reasonable balance
between wanting to avoid splitting an output line and not wanting to
generate enormous output events.</p>
               
               <pre><code class="language-go">var inBuffer = 4096</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="marker" data-name="marker">
               <h3>
                  marker 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#marker" class="anchor" title="Link to marker">#</a>
               </h3>
               
               <pre><code class="language-go">const marker = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="outBuffer" data-name="outBuffer">
               <h3>
                  outBuffer 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#outBuffer" class="anchor" title="Link to outBuffer">#</a>
               </h3>
               
                  <p class="doc-comment">inBuffer and outBuffer are the input and output buffer sizes.
They're variables so that they can be reduced during testing.
The input buffer needs to be able to hold any single test
directive line we want to recognize, like:
<many spaces> --- PASS: very/nested/s/u/b/t/e/s/t
If anyone reports a test directive line > 4k not working, it will
be defensible to suggest they restructure their test or test names.
The output buffer must be >= utf8.UTFMax, so that it can
accumulate any single UTF8 sequence. Lines that fit entirely
within the output buffer are emitted in single output events.
Otherwise they are split into multiple events.
The output buffer size therefore limits the size of the encoding
of a single JSON output event. 1k seems like a reasonable balance
between wanting to avoid splitting an output line and not wanting to
generate enormous output events.</p>
               
               <pre><code class="language-go">var outBuffer = 1024</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="reports" data-name="reports">
               <h3>
                  reports 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#reports" class="anchor" title="Link to reports">#</a>
               </h3>
               
               <pre><code class="language-go">var reports = [][]byte{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="skipLinePrefix" data-name="skipLinePrefix">
               <h3>
                  skipLinePrefix 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#skipLinePrefix" class="anchor" title="Link to skipLinePrefix">#</a>
               </h3>
               
               <pre><code class="language-go">var skipLinePrefix = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="skipLineSuffix" data-name="skipLineSuffix">
               <h3>
                  skipLineSuffix 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#skipLineSuffix" class="anchor" title="Link to skipLineSuffix">#</a>
               </h3>
               
               <pre><code class="language-go">var skipLineSuffix = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="updates" data-name="updates">
               <h3>
                  updates 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#updates" class="anchor" title="Link to updates">#</a>
               </h3>
               
               <pre><code class="language-go">var updates = [][]byte{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="Mode" data-name="Mode">
               <h3>
                  Mode
                  <span class="badge type-badge">type</span>
                  <a href="#Mode" class="anchor" title="Link to Mode">#</a>
               </h3>
               
               <p>Mode controls details of the conversion.</p>
               
               <pre><code class="language-go">type Mode int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="textBytes" data-name="textBytes">
               <h3>
                  textBytes
                  <span class="badge type-badge">type</span>
                  <a href="#textBytes" class="anchor" title="Link to textBytes">#</a>
               </h3>
               
               <p>textBytes is a hack to get JSON to emit a []byte as a string
without actually copying it to a string.
It implements encoding.TextMarshaler, which returns its text form as a []byte,
and then json encodes that text form as a string (which was our goal).</p>
               
               <pre><code class="language-go">type textBytes []byte</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Converter" data-name="Converter">
               <h3>
                  Converter
                  <span class="badge">struct</span>
                  <a href="#Converter" class="anchor" title="Link to Converter">#</a>
               </h3>
               
               <p>A Converter holds the state of a test-to-JSON conversion.
It implements io.WriteCloser; the caller writes test output in,
and the converter writes JSON output to w.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Converter struct {
w io.Writer
pkg string
mode Mode
start time.Time
testName string
report []*event
result string
input lineBuffer
output lineBuffer
needMarker bool
failedBuild string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="event" data-name="event">
               <h3>
                  event
                  <span class="badge">struct</span>
                  <a href="#event" class="anchor" title="Link to event">#</a>
               </h3>
               
               <p>event is the JSON struct we emit.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type event struct {
Time *time.Time `json:",omitempty"`
Action string
Package string `json:",omitempty"`
Test string `json:",omitempty"`
Elapsed *float64 `json:",omitempty"`
Output *textBytes `json:",omitempty"`
FailedBuild string `json:",omitempty"`
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="lineBuffer" data-name="lineBuffer">
               <h3>
                  lineBuffer
                  <span class="badge">struct</span>
                  <a href="#lineBuffer" class="anchor" title="Link to lineBuffer">#</a>
               </h3>
               
               <p>A lineBuffer is an I/O buffer that reacts to writes by invoking
input-processing callbacks on whole lines or (for long lines that
have been split) line fragments.
It should be initialized with b set to a buffer of length 0 but non-zero capacity,
and line and part set to the desired input processors.
The lineBuffer will call line(x) for any whole line x (including the final newline)
that fits entirely in cap(b). It will handle input lines longer than cap(b) by
calling part(x) for sections of the line. The line will be split at UTF8 boundaries,
and the final call to part for a long line includes the final newline.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type lineBuffer struct {
b []byte
mid bool
line func([]byte)
part func([]byte)
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close marks the end of the go test output.
It flushes any pending input and then output (only partial lines at this point)
and then emits the final overall package-level pass/fail event.</p>
               
               <pre><code class="language-go">func (c *Converter) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Exited" data-name="Exited">
               <h3>
                  Exited 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Exited" class="anchor" title="Link to Exited">#</a>
               </h3>
               
               <p>Exited marks the test process as having exited with the given error.</p>
               
               <pre><code class="language-go">func (c *Converter) Exited(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalText" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalText" class="anchor" title="Link to MarshalText">#</a>
               </h3>
               
               <pre><code class="language-go">func (b textBytes) MarshalText() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewConverter" data-name="NewConverter">
               <h3>
                  NewConverter 
                  <span class="badge">function</span>
                  
                  <a href="#NewConverter" class="anchor" title="Link to NewConverter">#</a>
               </h3>
               
               <p>NewConverter returns a "test to json" converter.
Writes on the returned writer are written as JSON to w,
with minimal delay.
The writes to w are whole JSON events ending in \n,
so that it is safe to run multiple tests writing to multiple converters
writing to a single underlying output stream w.
As long as the underlying output w can handle concurrent writes
from multiple goroutines, the result will be a JSON stream
describing the relative ordering of execution in all the concurrent tests.
The mode flag adjusts the behavior of the converter.
Passing ModeTime includes event timestamps and elapsed times.
The pkg string, if present, specifies the import path to
report in the JSON stream.</p>
               
               <pre><code class="language-go">func NewConverter(w io.Writer, pkg string, mode Mode) *Converter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetFailedBuild" data-name="SetFailedBuild">
               <h3>
                  SetFailedBuild 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetFailedBuild" class="anchor" title="Link to SetFailedBuild">#</a>
               </h3>
               
               <p>SetFailedBuild sets the package ID that is the root cause of a build failure
for this test. This will be reported in the final "fail" event's FailedBuild
field.</p>
               
               <pre><code class="language-go">func (c *Converter) SetFailedBuild(pkgID string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write writes the test input to the converter.</p>
               
               <pre><code class="language-go">func (c *Converter) Write(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flush" data-name="flush">
               <h3>
                  flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flush" class="anchor" title="Link to flush">#</a>
               </h3>
               
               <p>flush flushes the line buffer.</p>
               
               <pre><code class="language-go">func (l *lineBuffer) flush()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flushReport" data-name="flushReport">
               <h3>
                  flushReport 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flushReport" class="anchor" title="Link to flushReport">#</a>
               </h3>
               
               <p>flushReport flushes all pending PASS/FAIL reports at levels >= depth.</p>
               
               <pre><code class="language-go">func (c *Converter) flushReport(depth int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handleInputLine" data-name="handleInputLine">
               <h3>
                  handleInputLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handleInputLine" class="anchor" title="Link to handleInputLine">#</a>
               </h3>
               
               <p>handleInputLine handles a single whole test output line.
It must write the line to c.output but may choose to do so
before or after emitting other events.</p>
               
               <pre><code class="language-go">func (c *Converter) handleInputLine(line []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indexEOL" data-name="indexEOL">
               <h3>
                  indexEOL 
                  <span class="badge">function</span>
                  
                  <a href="#indexEOL" class="anchor" title="Link to indexEOL">#</a>
               </h3>
               
               <p>indexEOL finds the index of a line ending,
returning its position and output width.
A line ending is either a \n or the empty string just before a ^V not beginning a line.
The output width for \n is 1 (meaning it should be printed)
but the output width for ^V is 0 (meaning it should be left to begin the next line).</p>
               
               <pre><code class="language-go">func indexEOL(b []byte) (pos int, wid int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isBenchmarkName" data-name="isBenchmarkName">
               <h3>
                  isBenchmarkName 
                  <span class="badge">function</span>
                  
                  <a href="#isBenchmarkName" class="anchor" title="Link to isBenchmarkName">#</a>
               </h3>
               
               <p>isBenchmarkName reports whether b is a valid benchmark name
that might appear as the first field in a benchmark result line.</p>
               
               <pre><code class="language-go">func isBenchmarkName(b []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimUTF8" data-name="trimUTF8">
               <h3>
                  trimUTF8 
                  <span class="badge">function</span>
                  
                  <a href="#trimUTF8" class="anchor" title="Link to trimUTF8">#</a>
               </h3>
               
               <p>trimUTF8 returns a length t as close to len(b) as possible such that b[:t]
does not end in the middle of a possibly-valid UTF-8 sequence.
If a large text buffer must be split before position i at the latest,
splitting at position trimUTF(b[:i]) avoids splitting a UTF-8 sequence.</p>
               
               <pre><code class="language-go">func trimUTF8(b []byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="write" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#write" class="anchor" title="Link to write">#</a>
               </h3>
               
               <p>write writes b to the buffer.</p>
               
               <pre><code class="language-go">func (l *lineBuffer) write(b []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeEvent" data-name="writeEvent">
               <h3>
                  writeEvent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeEvent" class="anchor" title="Link to writeEvent">#</a>
               </h3>
               
               <p>writeEvent writes a single event.
It adds the package, time (if requested), and test name (if needed).</p>
               
               <pre><code class="language-go">func (c *Converter) writeEvent(e *event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeOutputEvent" data-name="writeOutputEvent">
               <h3>
                  writeOutputEvent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeOutputEvent" class="anchor" title="Link to writeOutputEvent">#</a>
               </h3>
               
               <p>writeOutputEvent writes a single output event with the given bytes.</p>
               
               <pre><code class="language-go">func (c *Converter) writeOutputEvent(out []byte)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>