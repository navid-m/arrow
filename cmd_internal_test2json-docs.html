<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - test2json</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>test2json</code>
         </h1>
         <hr />
         
         <article class="global" data-name="Timestamp">
            <h2>Timestamp</h2>
            <hr />
            
            <pre><code>Timestamp Mode</code></pre>
         </article>
         
         <article class="global" data-name="inBuffer">
            <h2>inBuffer</h2>
            <hr />
            
            <p>inBuffer and outBuffer are the input and output buffer sizes.
They're variables so that they can be reduced during testing.

The input buffer needs to be able to hold any single test
directive line we want to recognize, like:

	<many spaces> --- PASS: very/nested/s/u/b/t/e/s/t

If anyone reports a test directive line > 4k not working, it will
be defensible to suggest they restructure their test or test names.

The output buffer must be >= utf8.UTFMax, so that it can
accumulate any single UTF8 sequence. Lines that fit entirely
within the output buffer are emitted in single output events.
Otherwise they are split into multiple events.
The output buffer size therefore limits the size of the encoding
of a single JSON output event. 1k seems like a reasonable balance
between wanting to avoid splitting an output line and not wanting to
generate enormous output events.</p>
            
            <pre><code>inBuffer</code></pre>
         </article>
         
         <article class="global" data-name="outBuffer">
            <h2>outBuffer</h2>
            <hr />
            
            <p>inBuffer and outBuffer are the input and output buffer sizes.
They're variables so that they can be reduced during testing.

The input buffer needs to be able to hold any single test
directive line we want to recognize, like:

	<many spaces> --- PASS: very/nested/s/u/b/t/e/s/t

If anyone reports a test directive line > 4k not working, it will
be defensible to suggest they restructure their test or test names.

The output buffer must be >= utf8.UTFMax, so that it can
accumulate any single UTF8 sequence. Lines that fit entirely
within the output buffer are emitted in single output events.
Otherwise they are split into multiple events.
The output buffer size therefore limits the size of the encoding
of a single JSON output event. 1k seems like a reasonable balance
between wanting to avoid splitting an output line and not wanting to
generate enormous output events.</p>
            
            <pre><code>outBuffer</code></pre>
         </article>
         
         <article class="global" data-name="marker">
            <h2>marker</h2>
            <hr />
            
            <pre><code>marker</code></pre>
         </article>
         
         <article class="global" data-name="bigPass">
            <h2>bigPass</h2>
            <hr />
            
            <p>printed by test on successful run.</p>
            
            <pre><code>bigPass</code></pre>
         </article>
         
         <article class="global" data-name="bigFail">
            <h2>bigFail</h2>
            <hr />
            
            <p>printed by test after a normal test failure.</p>
            
            <pre><code>bigFail</code></pre>
         </article>
         
         <article class="global" data-name="bigFailErrorPrefix">
            <h2>bigFailErrorPrefix</h2>
            <hr />
            
            <p>printed by 'go test' along with an error if the test binary terminates
with an error.</p>
            
            <pre><code>bigFailErrorPrefix</code></pre>
         </article>
         
         <article class="global" data-name="emptyName">
            <h2>emptyName</h2>
            <hr />
            
            <p>an === NAME line with no test name, if trailing spaces are deleted</p>
            
            <pre><code>emptyName</code></pre>
         </article>
         
         <article class="global" data-name="emptyNameLine">
            <h2>emptyNameLine</h2>
            <hr />
            
            <pre><code>emptyNameLine</code></pre>
         </article>
         
         <article class="global" data-name="updates">
            <h2>updates</h2>
            <hr />
            
            <pre><code>updates</code></pre>
         </article>
         
         <article class="global" data-name="reports">
            <h2>reports</h2>
            <hr />
            
            <pre><code>reports</code></pre>
         </article>
         
         <article class="global" data-name="fourSpace">
            <h2>fourSpace</h2>
            <hr />
            
            <pre><code>fourSpace</code></pre>
         </article>
         
         <article class="global" data-name="skipLinePrefix">
            <h2>skipLinePrefix</h2>
            <hr />
            
            <pre><code>skipLinePrefix</code></pre>
         </article>
         
         <article class="global" data-name="skipLineSuffix">
            <h2>skipLineSuffix</h2>
            <hr />
            
            <pre><code>skipLineSuffix</code></pre>
         </article>
         
         <article class="global" data-name="benchmark">
            <h2>benchmark</h2>
            <hr />
            
            <pre><code>benchmark</code></pre>
         </article>
         
         <article class="global" data-name="update">
            <h2>update</h2>
            <hr />
            
            <pre><code>update</code></pre>
         </article>
          
         <article class="struct" data-name="event">
            <h2>type event struct</h2>
            <hr />
            
            <p>event is the JSON struct we emit.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Time *time.Time
Action string
Package string
Test string
Elapsed *float64
Output *textBytes
FailedBuild string</code></pre>
         </article>
         
         <article class="struct" data-name="Converter">
            <h2>type Converter struct</h2>
            <hr />
            
            <p>A Converter holds the state of a test-to-JSON conversion.
It implements io.WriteCloser; the caller writes test output in,
and the converter writes JSON output to w.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">w io.Writer
pkg string
mode Mode
start time.Time
testName string
report []*event
result string
input lineBuffer
output lineBuffer
needMarker bool
failedBuild string</code></pre>
         </article>
         
         <article class="struct" data-name="lineBuffer">
            <h2>type lineBuffer struct</h2>
            <hr />
            
            <p>A lineBuffer is an I/O buffer that reacts to writes by invoking
input-processing callbacks on whole lines or (for long lines that
have been split) line fragments.

It should be initialized with b set to a buffer of length 0 but non-zero capacity,
and line and part set to the desired input processors.
The lineBuffer will call line(x) for any whole line x (including the final newline)
that fits entirely in cap(b). It will handle input lines longer than cap(b) by
calling part(x) for sections of the line. The line will be split at UTF8 boundaries,
and the final call to part for a long line includes the final newline.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">b []byte
mid bool
line func
part func</code></pre>
         </article>
          
         <article class="function" data-name="MarshalText">
            <h2>MarshalText</h2>
            <hr />
            
            <pre><code>func MarshalText() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="NewConverter">
            <h2>NewConverter</h2>
            <hr />
            
            <p>NewConverter returns a "test to json" converter.
Writes on the returned writer are written as JSON to w,
with minimal delay.

The writes to w are whole JSON events ending in \n,
so that it is safe to run multiple tests writing to multiple converters
writing to a single underlying output stream w.
As long as the underlying output w can handle concurrent writes
from multiple goroutines, the result will be a JSON stream
describing the relative ordering of execution in all the concurrent tests.

The mode flag adjusts the behavior of the converter.
Passing ModeTime includes event timestamps and elapsed times.

The pkg string, if present, specifies the import path to
report in the JSON stream.</p>
            
            <pre><code>func NewConverter(w io.Writer, pkg string, mode Mode) *Converter</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write writes the test input to the converter.</p>
            
            <pre><code>func Write(b []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Exited">
            <h2>Exited</h2>
            <hr />
            
            <p>Exited marks the test process as having exited with the given error.</p>
            
            <pre><code>func Exited(err error)</code></pre>
         </article>
         
         <article class="function" data-name="SetFailedBuild">
            <h2>SetFailedBuild</h2>
            <hr />
            
            <p>SetFailedBuild sets the package ID that is the root cause of a build failure
for this test. This will be reported in the final "fail" event's FailedBuild
field.</p>
            
            <pre><code>func SetFailedBuild(pkgID string)</code></pre>
         </article>
         
         <article class="function" data-name="handleInputLine">
            <h2>handleInputLine</h2>
            <hr />
            
            <p>handleInputLine handles a single whole test output line.
It must write the line to c.output but may choose to do so
before or after emitting other events.</p>
            
            <pre><code>func handleInputLine(line []byte)</code></pre>
         </article>
         
         <article class="function" data-name="flushReport">
            <h2>flushReport</h2>
            <hr />
            
            <p>flushReport flushes all pending PASS/FAIL reports at levels >= depth.</p>
            
            <pre><code>func flushReport(depth int)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close marks the end of the go test output.
It flushes any pending input and then output (only partial lines at this point)
and then emits the final overall package-level pass/fail event.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="writeOutputEvent">
            <h2>writeOutputEvent</h2>
            <hr />
            
            <p>writeOutputEvent writes a single output event with the given bytes.</p>
            
            <pre><code>func writeOutputEvent(out []byte)</code></pre>
         </article>
         
         <article class="function" data-name="writeEvent">
            <h2>writeEvent</h2>
            <hr />
            
            <p>writeEvent writes a single event.
It adds the package, time (if requested), and test name (if needed).</p>
            
            <pre><code>func writeEvent(e *event)</code></pre>
         </article>
         
         <article class="function" data-name="write">
            <h2>write</h2>
            <hr />
            
            <p>write writes b to the buffer.</p>
            
            <pre><code>func write(b []byte)</code></pre>
         </article>
         
         <article class="function" data-name="indexEOL">
            <h2>indexEOL</h2>
            <hr />
            
            <p>indexEOL finds the index of a line ending,
returning its position and output width.
A line ending is either a \n or the empty string just before a ^V not beginning a line.
The output width for \n is 1 (meaning it should be printed)
but the output width for ^V is 0 (meaning it should be left to begin the next line).</p>
            
            <pre><code>func indexEOL(b []byte) (pos int, wid int)</code></pre>
         </article>
         
         <article class="function" data-name="flush">
            <h2>flush</h2>
            <hr />
            
            <p>flush flushes the line buffer.</p>
            
            <pre><code>func flush()</code></pre>
         </article>
         
         <article class="function" data-name="isBenchmarkName">
            <h2>isBenchmarkName</h2>
            <hr />
            
            <p>isBenchmarkName reports whether b is a valid benchmark name
that might appear as the first field in a benchmark result line.</p>
            
            <pre><code>func isBenchmarkName(b []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="trimUTF8">
            <h2>trimUTF8</h2>
            <hr />
            
            <p>trimUTF8 returns a length t as close to len(b) as possible such that b[:t]
does not end in the middle of a possibly-valid UTF-8 sequence.

If a large text buffer must be split before position i at the latest,
splitting at position trimUTF(b[:i]) avoids splitting a UTF-8 sequence.</p>
            
            <pre><code>func trimUTF8(b []byte) int</code></pre>
         </article>
         
         <article class="function" data-name="TestGolden">
            <h2>TestGolden</h2>
            <hr />
            
            <pre><code>func TestGolden(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="writeAndKill">
            <h2>writeAndKill</h2>
            <hr />
            
            <p>writeAndKill writes b to w and then fills b with Zs.
The filling makes sure that if w is holding onto b for
future use, that future use will have obviously wrong data.</p>
            
            <pre><code>func writeAndKill(w io.Writer, b []byte)</code></pre>
         </article>
         
         <article class="function" data-name="diffJSON">
            <h2>diffJSON</h2>
            <hr />
            
            <p>diffJSON diffs the stream we have against the stream we want
and fails the test with a useful message if they don't match.</p>
            
            <pre><code>func diffJSON(t *testing.T, have []byte, want []byte)</code></pre>
         </article>
         
         <article class="function" data-name="TestTrimUTF8">
            <h2>TestTrimUTF8</h2>
            <hr />
            
            <pre><code>func TestTrimUTF8(t *testing.T)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
