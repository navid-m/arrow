<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - cfile</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="internal_coverage_cfile_testdata-docs.html">testdata</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>cfile</code>
         </h1>
         <hr />
         
         <article class="global" data-name="hellogo">
            <h2>hellogo</h2>
            <hr />
            
            <pre><code>hellogo</code></pre>
         </article>
         
         <article class="global" data-name="finalHash">
            <h2>finalHash</h2>
            <hr />
            
            <p>finalHash is computed at init time from the list of meta-data
symbols registered during init. It is used both for writing the
meta-data file and counter-data files.</p>
            
            <pre><code>finalHash []byte</code></pre>
         </article>
         
         <article class="global" data-name="finalHashComputed">
            <h2>finalHashComputed</h2>
            <hr />
            
            <p>Set to true when we've computed finalHash + finalMetaLen.</p>
            
            <pre><code>finalHashComputed bool</code></pre>
         </article>
         
         <article class="global" data-name="finalMetaLen">
            <h2>finalMetaLen</h2>
            <hr />
            
            <p>Total meta-data length.</p>
            
            <pre><code>finalMetaLen uint64</code></pre>
         </article>
         
         <article class="global" data-name="metaDataEmitAttempted">
            <h2>metaDataEmitAttempted</h2>
            <hr />
            
            <p>Records whether we've already attempted to write meta-data.</p>
            
            <pre><code>metaDataEmitAttempted bool</code></pre>
         </article>
         
         <article class="global" data-name="cmode">
            <h2>cmode</h2>
            <hr />
            
            <p>Counter mode for this instrumented program run.</p>
            
            <pre><code>cmode coverage.CounterMode</code></pre>
         </article>
         
         <article class="global" data-name="cgran">
            <h2>cgran</h2>
            <hr />
            
            <p>Counter granularity for this instrumented program run.</p>
            
            <pre><code>cgran coverage.CounterGranularity</code></pre>
         </article>
         
         <article class="global" data-name="goCoverDir">
            <h2>goCoverDir</h2>
            <hr />
            
            <p>Cached value of GOCOVERDIR environment variable.</p>
            
            <pre><code>goCoverDir string</code></pre>
         </article>
         
         <article class="global" data-name="capturedOsArgs">
            <h2>capturedOsArgs</h2>
            <hr />
            
            <p>Copy of os.Args made at init time, converted into map format.</p>
            
            <pre><code>capturedOsArgs *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="covProfileAlreadyEmitted">
            <h2>covProfileAlreadyEmitted</h2>
            <hr />
            
            <p>Flag used in tests to signal that coverage data already written.</p>
            
            <pre><code>covProfileAlreadyEmitted bool</code></pre>
         </article>
         
         <article class="global" data-name="noFile">
            <h2>noFile</h2>
            <hr />
            
            <pre><code>noFile</code></pre>
         </article>
         
         <article class="global" data-name="metaDataFile">
            <h2>metaDataFile</h2>
            <hr />
            
            <pre><code>metaDataFile</code></pre>
         </article>
         
         <article class="global" data-name="counterDataFile">
            <h2>counterDataFile</h2>
            <hr />
            
            <pre><code>counterDataFile</code></pre>
         </article>
         
         <article class="global" data-name="fixedTestDir">
            <h2>fixedTestDir</h2>
            <hr />
            
            <p>Set to true for debugging (linux only).</p>
            
            <pre><code>fixedTestDir</code></pre>
         </article>
         
         <article class="global" data-name="funcInvoked">
            <h2>funcInvoked</h2>
            <hr />
            
            <pre><code>funcInvoked bool</code></pre>
         </article>
          
         <article class="struct" data-name="tstate">
            <h2>type tstate struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">calloc.BatchCounterAlloc
cm *cmerge.Merger
cf *cformat.Formatter
cmode coverage.CounterMode</code></pre>
         </article>
         
         <article class="struct" data-name="pkfunc">
            <h2>type pkfunc struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pk uint32
fcn uint32</code></pre>
         </article>
         
         <article class="struct" data-name="emitState">
            <h2>type emitState struct</h2>
            <hr />
            
            <p>emitState holds useful state information during the emit process.

When an instrumented program finishes execution and starts the
process of writing out coverage data, it's possible that an
existing meta-data file already exists in the output directory. In
this case openOutputFiles() below will leave the 'mf' field below
as nil. If a new meta-data file is needed, field 'mfname' will be
the final desired path of the meta file, 'mftmp' will be a
temporary file, and 'mf' will be an open os.File pointer for
'mftmp'. The meta-data file payload will be written to 'mf', the
temp file will be then closed and renamed (from 'mftmp' to
'mfname'), so as to insure that the meta-data file is created
atomically; we want this so that things work smoothly in cases
where there are several instances of a given instrumented program
all terminating at the same time and trying to create meta-data
files simultaneously.

For counter data files there is less chance of a collision, hence
the openOutputFiles() stores the counter data file in 'cfname' and
then places the *io.File into 'cf'.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">mfname string
mftmp string
mf *os.File
cfname string
cftmp string
cf *os.File
outdir string
metalist []rtcov.CovMetaBlob
counterlist []rtcov.CovCounterBlob
pkgmap *ast.MapType
debug bool</code></pre>
         </article>
          
         <article class="function" data-name="ProcessCoverTestDir">
            <h2>ProcessCoverTestDir</h2>
            <hr />
            
            <p>ProcessCoverTestDir is called from
testmain code when "go test -cover" is in effect. It is not
intended to be used other than internally by the Go command's
generated code.</p>
            
            <pre><code>func ProcessCoverTestDir(dir string, cfile string, cm string, cpkg string, w io.Writer, selpkgs []string) error</code></pre>
         </article>
         
         <article class="function" data-name="processPod">
            <h2>processPod</h2>
            <hr />
            
            <p>processPod reads coverage counter data for a specific pod.</p>
            
            <pre><code>func processPod(p pods.Pod, importpaths *ast.MapType) error</code></pre>
         </article>
         
         <article class="function" data-name="readAuxMetaFiles">
            <h2>readAuxMetaFiles</h2>
            <hr />
            
            <pre><code>func readAuxMetaFiles(metafiles string, importpaths *ast.MapType) error</code></pre>
         </article>
         
         <article class="function" data-name="Snapshot">
            <h2>Snapshot</h2>
            <hr />
            
            <p>Snapshot returns a snapshot of coverage percentage at a moment of
time within a running test, so as to support the testing.Coverage()
function. This version doesn't examine coverage meta-data, so the
result it returns will be less accurate (more "slop") due to the
fact that we don't look at the meta data to see how many statements
are associated with each counter.</p>
            
            <pre><code>func Snapshot() float64</code></pre>
         </article>
         
         <article class="function" data-name="testGoCoverDir">
            <h2>testGoCoverDir</h2>
            <hr />
            
            <pre><code>func testGoCoverDir(t *testing.T) string</code></pre>
         </article>
         
         <article class="function" data-name="TestTestSupport">
            <h2>TestTestSupport</h2>
            <hr />
            
            <p>TestTestSupport does a basic verification of the functionality in
ProcessCoverTestDir (doing this here as opposed to
relying on other test paths will provide a better signal when
running "go test -cover" for this package).</p>
            
            <pre><code>func TestTestSupport(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCoverageSnapshot">
            <h2>TestCoverageSnapshot</h2>
            <hr />
            
            <p>Kicks off a sub-test to verify that Snapshot() works properly.
We do this as a separate shell-out, so as to avoid potential
interactions with -coverpkg. For example, if you do

	$ cd `go env GOROOT`
	$ cd src/internal/coverage
	$ go test -coverpkg=internal/coverage/decodecounter ./...
	...
	$

The previous version of this test could fail due to the fact
that "cfile" itself was not being instrumented, as in the
scenario above.</p>
            
            <pre><code>func TestCoverageSnapshot(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="genAuxMeta">
            <h2>genAuxMeta</h2>
            <hr />
            
            <p>Returns a pair F,T where F is a meta-data file generated from
"hello.go" above, and T is a token to look for that should be
present in the coverage report from F.</p>
            
            <pre><code>func genAuxMeta(t *testing.T, dstdir string) (string, string)</code></pre>
         </article>
         
         <article class="function" data-name="TestAuxMetaDataFiles">
            <h2>TestAuxMetaDataFiles</h2>
            <hr />
            
            <pre><code>func TestAuxMetaDataFiles(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="WriteMetaDir">
            <h2>WriteMetaDir</h2>
            <hr />
            
            <p>WriteMetaDir implements [runtime/coverage.WriteMetaDir].</p>
            
            <pre><code>func WriteMetaDir(dir string) error</code></pre>
         </article>
         
         <article class="function" data-name="WriteMeta">
            <h2>WriteMeta</h2>
            <hr />
            
            <p>WriteMeta implements [runtime/coverage.WriteMeta].</p>
            
            <pre><code>func WriteMeta(w io.Writer) error</code></pre>
         </article>
         
         <article class="function" data-name="WriteCountersDir">
            <h2>WriteCountersDir</h2>
            <hr />
            
            <p>WriteCountersDir implements [runtime/coverage.WriteCountersDir].</p>
            
            <pre><code>func WriteCountersDir(dir string) error</code></pre>
         </article>
         
         <article class="function" data-name="WriteCounters">
            <h2>WriteCounters</h2>
            <hr />
            
            <p>WriteCounters implements [runtime/coverage.WriteCounters].</p>
            
            <pre><code>func WriteCounters(w io.Writer) error</code></pre>
         </article>
         
         <article class="function" data-name="ClearCounters">
            <h2>ClearCounters</h2>
            <hr />
            
            <p>ClearCounters implements [runtime/coverage.ClearCounters].</p>
            
            <pre><code>func ClearCounters() error</code></pre>
         </article>
         
         <article class="function" data-name="getCovCounterList">
            <h2>getCovCounterList</h2>
            <hr />
            
            <p>getCovCounterList returns a list of counter-data blobs registered
for the currently executing instrumented program. It is defined in the
runtime.</p>
            
            <pre><code>func getCovCounterList() []rtcov.CovCounterBlob</code></pre>
         </article>
         
         <article class="function" data-name="emitMetaData">
            <h2>emitMetaData</h2>
            <hr />
            
            <p>emitMetaData emits the meta-data output file for this coverage run.
This entry point is intended to be invoked by the compiler from
an instrumented program's main package init func.</p>
            
            <pre><code>func emitMetaData()</code></pre>
         </article>
         
         <article class="function" data-name="modeClash">
            <h2>modeClash</h2>
            <hr />
            
            <pre><code>func modeClash(m coverage.CounterMode) bool</code></pre>
         </article>
         
         <article class="function" data-name="granClash">
            <h2>granClash</h2>
            <hr />
            
            <pre><code>func granClash(g coverage.CounterGranularity) bool</code></pre>
         </article>
         
         <article class="function" data-name="prepareForMetaEmit">
            <h2>prepareForMetaEmit</h2>
            <hr />
            
            <p>prepareForMetaEmit performs preparatory steps needed prior to
emitting a meta-data file, notably computing a final hash of
all meta-data blobs and capturing os args.</p>
            
            <pre><code>func prepareForMetaEmit() ([]rtcov.CovMetaBlob, error)</code></pre>
         </article>
         
         <article class="function" data-name="emitMetaDataToDirectory">
            <h2>emitMetaDataToDirectory</h2>
            <hr />
            
            <p>emitMetaDataToDirectory emits the meta-data output file to the specified
directory, returning an error if something went wrong.</p>
            
            <pre><code>func emitMetaDataToDirectory(outdir string, ml []rtcov.CovMetaBlob) error</code></pre>
         </article>
         
         <article class="function" data-name="emitCounterData">
            <h2>emitCounterData</h2>
            <hr />
            
            <p>emitCounterData emits the counter data output file for this coverage run.
This entry point is intended to be invoked by the runtime when an
instrumented program is terminating or calling os.Exit().</p>
            
            <pre><code>func emitCounterData()</code></pre>
         </article>
         
         <article class="function" data-name="emitCounterDataToDirectory">
            <h2>emitCounterDataToDirectory</h2>
            <hr />
            
            <p>emitCounterDataToDirectory emits the counter-data output file for this coverage run.</p>
            
            <pre><code>func emitCounterDataToDirectory(outdir string) error</code></pre>
         </article>
         
         <article class="function" data-name="emitCounterDataToWriter">
            <h2>emitCounterDataToWriter</h2>
            <hr />
            
            <p>emitCounterDataToWriter emits counter data for this coverage run to an io.Writer.</p>
            
            <pre><code>func emitCounterDataToWriter(w io.Writer) error</code></pre>
         </article>
         
         <article class="function" data-name="openMetaFile">
            <h2>openMetaFile</h2>
            <hr />
            
            <p>openMetaFile determines whether we need to emit a meta-data output
file, or whether we can reuse the existing file in the coverage out
dir. It updates mfname/mftmp/mf fields in 's', returning an error
if something went wrong. See the comment on the emitState type
definition above for more on how file opening is managed.</p>
            
            <pre><code>func openMetaFile(metaHash []byte, metaLen uint64) error</code></pre>
         </article>
         
         <article class="function" data-name="openCounterFile">
            <h2>openCounterFile</h2>
            <hr />
            
            <p>openCounterFile opens an output file for the counter data portion
of a test coverage run. If updates the 'cfname' and 'cf' fields in
's', returning an error if something went wrong.</p>
            
            <pre><code>func openCounterFile(metaHash []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="openOutputFiles">
            <h2>openOutputFiles</h2>
            <hr />
            
            <p>openOutputFiles opens output files in preparation for emitting
coverage data. In the case of the meta-data file, openOutputFiles
may determine that we can reuse an existing meta-data file in the
outdir, in which case it will leave the 'mf' field in the state
struct as nil. If a new meta-file is needed, the field 'mfname'
will be the final desired path of the meta file, 'mftmp' will be a
temporary file, and 'mf' will be an open os.File pointer for
'mftmp'. The idea is that the client/caller will write content into
'mf', close it, and then rename 'mftmp' to 'mfname'. This function
also opens the counter data output file, setting 'cf' and 'cfname'
in the state struct.</p>
            
            <pre><code>func openOutputFiles(metaHash []byte, metaLen uint64, which fileType) error</code></pre>
         </article>
         
         <article class="function" data-name="emitMetaDataFile">
            <h2>emitMetaDataFile</h2>
            <hr />
            
            <p>emitMetaDataFile emits coverage meta-data to a previously opened
temporary file (s.mftmp), then renames the generated file to the
final path (s.mfname).</p>
            
            <pre><code>func emitMetaDataFile(finalHash []byte, tlen uint64) error</code></pre>
         </article>
         
         <article class="function" data-name="needMetaDataFile">
            <h2>needMetaDataFile</h2>
            <hr />
            
            <p>needMetaDataFile returns TRUE if we need to emit a meta-data file
for this program run. It should be used only after
openOutputFiles() has been invoked.</p>
            
            <pre><code>func needMetaDataFile() bool</code></pre>
         </article>
         
         <article class="function" data-name="writeMetaData">
            <h2>writeMetaData</h2>
            <hr />
            
            <pre><code>func writeMetaData(w io.Writer, metalist []rtcov.CovMetaBlob, cmode coverage.CounterMode, gran coverage.CounterGranularity, finalHash []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="VisitFuncs">
            <h2>VisitFuncs</h2>
            <hr />
            
            <pre><code>func VisitFuncs(f encodecounter.CounterVisitorFn) error</code></pre>
         </article>
         
         <article class="function" data-name="captureOsArgs">
            <h2>captureOsArgs</h2>
            <hr />
            
            <p>captureOsArgs converts os.Args() into the format we use to store
this info in the counter data file (counter data file "args"
section is a generic key-value collection). See the 'args' section
in internal/coverage/defs.go for more info. The args map
is also used to capture GOOS + GOARCH values as well.</p>
            
            <pre><code>func captureOsArgs() *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="emitCounterDataFile">
            <h2>emitCounterDataFile</h2>
            <hr />
            
            <p>emitCounterDataFile emits the counter data portion of a
coverage output file (to the file 's.cf').</p>
            
            <pre><code>func emitCounterDataFile(finalHash []byte, w io.Writer) error</code></pre>
         </article>
         
         <article class="function" data-name="MarkProfileEmitted">
            <h2>MarkProfileEmitted</h2>
            <hr />
            
            <p>MarkProfileEmitted signals the coverage machinery that
coverage data output files have already been written out, and there
is no need to take any additional action at exit time. This
function is called from the coverage-related boilerplate code in _testmain.go
emitted for go unit tests.</p>
            
            <pre><code>func MarkProfileEmitted(val bool)</code></pre>
         </article>
         
         <article class="function" data-name="reportErrorInHardcodedList">
            <h2>reportErrorInHardcodedList</h2>
            <hr />
            
            <pre><code>func reportErrorInHardcodedList(slot int32, pkgID int32, fnID uint32, nCtrs uint32)</code></pre>
         </article>
         
         <article class="function" data-name="TestCoverageApis">
            <h2>TestCoverageApis</h2>
            <hr />
            
            <pre><code>func TestCoverageApis(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="upmergeCoverData">
            <h2>upmergeCoverData</h2>
            <hr />
            
            <p>upmergeCoverData helps improve coverage data for this package
itself. If this test itself is being invoked with "-cover", then
what we'd like is for package coverage data (that is, coverage for
routines in "runtime/coverage") to be incorporated into the test
run from the "harness.exe" runs we've just done. We can accomplish
this by doing a merge from the harness gocoverdir's to the test
gocoverdir.</p>
            
            <pre><code>func upmergeCoverData(t *testing.T, gocoverdir string, mode string)</code></pre>
         </article>
         
         <article class="function" data-name="buildHarness">
            <h2>buildHarness</h2>
            <hr />
            
            <p>buildHarness builds the helper program "harness.exe".</p>
            
            <pre><code>func buildHarness(t *testing.T, dir string, opts []string) string</code></pre>
         </article>
         
         <article class="function" data-name="mkdir">
            <h2>mkdir</h2>
            <hr />
            
            <pre><code>func mkdir(t *testing.T, d string) string</code></pre>
         </article>
         
         <article class="function" data-name="updateGoCoverDir">
            <h2>updateGoCoverDir</h2>
            <hr />
            
            <p>updateGoCoverDir updates the specified environment 'env' to set
GOCOVERDIR to 'gcd' (if setGoCoverDir is TRUE) or removes
GOCOVERDIR from the environment (if setGoCoverDir is false).</p>
            
            <pre><code>func updateGoCoverDir(env []string, gcd string, setGoCoverDir bool) []string</code></pre>
         </article>
         
         <article class="function" data-name="runHarness">
            <h2>runHarness</h2>
            <hr />
            
            <pre><code>func runHarness(t *testing.T, harnessPath string, tp string, setGoCoverDir bool, rdir string, edir string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="testForSpecificFunctions">
            <h2>testForSpecificFunctions</h2>
            <hr />
            
            <pre><code>func testForSpecificFunctions(t *testing.T, dir string, want []string, avoid []string) string</code></pre>
         </article>
         
         <article class="function" data-name="withAndWithoutRunner">
            <h2>withAndWithoutRunner</h2>
            <hr />
            
            <pre><code>func withAndWithoutRunner(f func)</code></pre>
         </article>
         
         <article class="function" data-name="mktestdirs">
            <h2>mktestdirs</h2>
            <hr />
            
            <pre><code>func mktestdirs(t *testing.T, tag string, tp string, dir string) (string, string)</code></pre>
         </article>
         
         <article class="function" data-name="testEmitToDir">
            <h2>testEmitToDir</h2>
            <hr />
            
            <pre><code>func testEmitToDir(t *testing.T, harnessPath string, dir string)</code></pre>
         </article>
         
         <article class="function" data-name="testEmitToWriter">
            <h2>testEmitToWriter</h2>
            <hr />
            
            <pre><code>func testEmitToWriter(t *testing.T, harnessPath string, dir string)</code></pre>
         </article>
         
         <article class="function" data-name="testEmitToNonexistentDir">
            <h2>testEmitToNonexistentDir</h2>
            <hr />
            
            <pre><code>func testEmitToNonexistentDir(t *testing.T, harnessPath string, dir string)</code></pre>
         </article>
         
         <article class="function" data-name="testEmitToUnwritableDir">
            <h2>testEmitToUnwritableDir</h2>
            <hr />
            
            <pre><code>func testEmitToUnwritableDir(t *testing.T, harnessPath string, dir string)</code></pre>
         </article>
         
         <article class="function" data-name="testEmitToNilWriter">
            <h2>testEmitToNilWriter</h2>
            <hr />
            
            <pre><code>func testEmitToNilWriter(t *testing.T, harnessPath string, dir string)</code></pre>
         </article>
         
         <article class="function" data-name="testEmitToFailingWriter">
            <h2>testEmitToFailingWriter</h2>
            <hr />
            
            <pre><code>func testEmitToFailingWriter(t *testing.T, harnessPath string, dir string)</code></pre>
         </article>
         
         <article class="function" data-name="testEmitWithCounterClear">
            <h2>testEmitWithCounterClear</h2>
            <hr />
            
            <pre><code>func testEmitWithCounterClear(t *testing.T, harnessPath string, dir string)</code></pre>
         </article>
         
         <article class="function" data-name="testEmitToDirNonAtomic">
            <h2>testEmitToDirNonAtomic</h2>
            <hr />
            
            <pre><code>func testEmitToDirNonAtomic(t *testing.T, harnessPath string, naMode string, dir string)</code></pre>
         </article>
         
         <article class="function" data-name="testEmitToWriterNonAtomic">
            <h2>testEmitToWriterNonAtomic</h2>
            <hr />
            
            <pre><code>func testEmitToWriterNonAtomic(t *testing.T, harnessPath string, naMode string, dir string)</code></pre>
         </article>
         
         <article class="function" data-name="testEmitWithCounterClearNonAtomic">
            <h2>testEmitWithCounterClearNonAtomic</h2>
            <hr />
            
            <pre><code>func testEmitWithCounterClearNonAtomic(t *testing.T, harnessPath string, naMode string, dir string)</code></pre>
         </article>
         
         <article class="function" data-name="TestApisOnNocoverBinary">
            <h2>TestApisOnNocoverBinary</h2>
            <hr />
            
            <pre><code>func TestApisOnNocoverBinary(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue56006EmitDataRaceCoverRunningGoroutine">
            <h2>TestIssue56006EmitDataRaceCoverRunningGoroutine</h2>
            <hr />
            
            <pre><code>func TestIssue56006EmitDataRaceCoverRunningGoroutine(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue59563TruncatedCoverPkgAll">
            <h2>TestIssue59563TruncatedCoverPkgAll</h2>
            <hr />
            
            <pre><code>func TestIssue59563TruncatedCoverPkgAll(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="InitHook">
            <h2>InitHook</h2>
            <hr />
            
            <p>InitHook is invoked from the main package "init" routine in
programs built with "-cover". This function is intended to be
called only by the compiler (via runtime/coverage.initHook).

If 'istest' is false, it indicates we're building a regular program
("go build -cover ..."), in which case we immediately try to write
out the meta-data file, and register emitCounterData as an exit
hook.

If 'istest' is true (indicating that the program in question is a
Go test binary), then we tentatively queue up both emitMetaData and
emitCounterData as exit hooks. In the normal case (e.g. regular "go
test -cover" run) the testmain.go boilerplate will run at the end
of the test, write out the coverage percentage, and then invoke
MarkProfileEmitted to indicate that no more work needs to be
done. If however that call is never made, this is a sign that the
test binary is being used as a replacement binary for the tool
being tested, hence we do want to run exit hooks when the program
terminates.</p>
            
            <pre><code>func InitHook(istest bool)</code></pre>
         </article>
         
         <article class="function" data-name="thisFunctionOnlyCalledFromSnapshotTest">
            <h2>thisFunctionOnlyCalledFromSnapshotTest</h2>
            <hr />
            
            <pre><code>func thisFunctionOnlyCalledFromSnapshotTest(n int) int</code></pre>
         </article>
         
         <article class="function" data-name="TestCoverageSnapshotImpl">
            <h2>TestCoverageSnapshotImpl</h2>
            <hr />
            
            <p>Tests runtime/coverage.snapshot() directly. Note that if
coverage is not enabled, the hook is designed to just return
zero.</p>
            
            <pre><code>func TestCoverageSnapshotImpl(t *testing.T)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
