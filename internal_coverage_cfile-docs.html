<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - cfile</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>cfile</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"fmt"
"internal/coverage"
"internal/coverage/rtcov"
"io"
"sync/atomic"
"unsafe"
"fmt"
"hash/fnv"
"internal/coverage"
"internal/coverage/encodecounter"
"internal/coverage/encodemeta"
"internal/coverage/rtcov"
"io"
"os"
"path/filepath"
"runtime"
"strconv"
"sync/atomic"
"time"
"unsafe"
"internal/runtime/exithook"
"encoding/json"
"fmt"
"internal/coverage"
"internal/coverage/calloc"
"internal/coverage/cformat"
"internal/coverage/cmerge"
"internal/coverage/decodecounter"
"internal/coverage/decodemeta"
"internal/coverage/pods"
"internal/coverage/rtcov"
"internal/runtime/atomic"
"io"
"os"
"path/filepath"
"strings"
"unsafe"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="capturedOsArgs" data-name="capturedOsArgs">
               <h3>
                  capturedOsArgs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#capturedOsArgs" class="anchor" title="Link to capturedOsArgs">#</a>
               </h3>
               
               <p>Copy of os.Args made at init time, converted into map format.</p>
               
               <pre><code>var capturedOsArgs map[string]string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cgran" data-name="cgran">
               <h3>
                  cgran 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cgran" class="anchor" title="Link to cgran">#</a>
               </h3>
               
               <p>Counter granularity for this instrumented program run.</p>
               
               <pre><code>var cgran coverage.CounterGranularity</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cmode" data-name="cmode">
               <h3>
                  cmode 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cmode" class="anchor" title="Link to cmode">#</a>
               </h3>
               
               <p>Counter mode for this instrumented program run.</p>
               
               <pre><code>var cmode coverage.CounterMode</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="counterDataFile" data-name="counterDataFile">
               <h3>
                  counterDataFile 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#counterDataFile" class="anchor" title="Link to counterDataFile">#</a>
               </h3>
               
               <pre><code>const counterDataFile</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="covProfileAlreadyEmitted" data-name="covProfileAlreadyEmitted">
               <h3>
                  covProfileAlreadyEmitted 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#covProfileAlreadyEmitted" class="anchor" title="Link to covProfileAlreadyEmitted">#</a>
               </h3>
               
               <p>Flag used in tests to signal that coverage data already written.</p>
               
               <pre><code>var covProfileAlreadyEmitted bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="finalHash" data-name="finalHash">
               <h3>
                  finalHash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#finalHash" class="anchor" title="Link to finalHash">#</a>
               </h3>
               
               <p>finalHash is computed at init time from the list of meta-data
symbols registered during init. It is used both for writing the
meta-data file and counter-data files.</p>
               
               <pre><code>var finalHash [16]byte</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="finalHashComputed" data-name="finalHashComputed">
               <h3>
                  finalHashComputed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#finalHashComputed" class="anchor" title="Link to finalHashComputed">#</a>
               </h3>
               
               <p>Set to true when we've computed finalHash + finalMetaLen.</p>
               
               <pre><code>var finalHashComputed bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="finalMetaLen" data-name="finalMetaLen">
               <h3>
                  finalMetaLen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#finalMetaLen" class="anchor" title="Link to finalMetaLen">#</a>
               </h3>
               
               <p>Total meta-data length.</p>
               
               <pre><code>var finalMetaLen uint64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goCoverDir" data-name="goCoverDir">
               <h3>
                  goCoverDir 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#goCoverDir" class="anchor" title="Link to goCoverDir">#</a>
               </h3>
               
               <p>Cached value of GOCOVERDIR environment variable.</p>
               
               <pre><code>var goCoverDir string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="metaDataEmitAttempted" data-name="metaDataEmitAttempted">
               <h3>
                  metaDataEmitAttempted 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#metaDataEmitAttempted" class="anchor" title="Link to metaDataEmitAttempted">#</a>
               </h3>
               
               <p>Records whether we've already attempted to write meta-data.</p>
               
               <pre><code>var metaDataEmitAttempted bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="metaDataFile" data-name="metaDataFile">
               <h3>
                  metaDataFile 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#metaDataFile" class="anchor" title="Link to metaDataFile">#</a>
               </h3>
               
               <pre><code>const metaDataFile</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noFile" data-name="noFile">
               <h3>
                  noFile 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#noFile" class="anchor" title="Link to noFile">#</a>
               </h3>
               
               <pre><code>const noFile = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="fileType" data-name="fileType">
               <h3>
                  fileType
                  <span class="badge type-badge">type</span>
                  <a href="#fileType" class="anchor" title="Link to fileType">#</a>
               </h3>
               
               <p>fileType is used to select between counter-data files and
meta-data files.</p>
               
               <pre><code>type fileType int</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="emitState" data-name="emitState">
               <h3>
                  emitState
                  <span class="badge">struct</span>
                  <a href="#emitState" class="anchor" title="Link to emitState">#</a>
               </h3>
               
               <p>emitState holds useful state information during the emit process.
When an instrumented program finishes execution and starts the
process of writing out coverage data, it's possible that an
existing meta-data file already exists in the output directory. In
this case openOutputFiles() below will leave the 'mf' field below
as nil. If a new meta-data file is needed, field 'mfname' will be
the final desired path of the meta file, 'mftmp' will be a
temporary file, and 'mf' will be an open os.File pointer for
'mftmp'. The meta-data file payload will be written to 'mf', the
temp file will be then closed and renamed (from 'mftmp' to
'mfname'), so as to insure that the meta-data file is created
atomically; we want this so that things work smoothly in cases
where there are several instances of a given instrumented program
all terminating at the same time and trying to create meta-data
files simultaneously.
For counter data files there is less chance of a collision, hence
the openOutputFiles() stores the counter data file in 'cfname' and
then places the *io.File into 'cf'.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type emitState struct {
mfname string
mftmp string
mf *os.File
cfname string
cftmp string
cf *os.File
outdir string
metalist []rtcov.CovMetaBlob
counterlist []rtcov.CovCounterBlob
pkgmap map[int]int
debug bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pkfunc" data-name="pkfunc">
               <h3>
                  pkfunc
                  <span class="badge">struct</span>
                  <a href="#pkfunc" class="anchor" title="Link to pkfunc">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pkfunc struct {
pk uint32
fcn uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="tstate" data-name="tstate">
               <h3>
                  tstate
                  <span class="badge">struct</span>
                  <a href="#tstate" class="anchor" title="Link to tstate">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type tstate struct {
calloc.BatchCounterAlloc
cm *cmerge.Merger
cf *cformat.Formatter
cmode coverage.CounterMode
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="ClearCounters" data-name="ClearCounters">
               <h3>
                  ClearCounters 
                  <span class="badge">function</span>
                  
                  <a href="#ClearCounters" class="anchor" title="Link to ClearCounters">#</a>
               </h3>
               
               <p>ClearCounters implements [runtime/coverage.ClearCounters].</p>
               
               <pre><code>func ClearCounters() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitHook" data-name="InitHook">
               <h3>
                  InitHook 
                  <span class="badge">function</span>
                  
                  <a href="#InitHook" class="anchor" title="Link to InitHook">#</a>
               </h3>
               
               <p>InitHook is invoked from the main package "init" routine in
programs built with "-cover". This function is intended to be
called only by the compiler (via runtime/coverage.initHook).
If 'istest' is false, it indicates we're building a regular program
("go build -cover ..."), in which case we immediately try to write
out the meta-data file, and register emitCounterData as an exit
hook.
If 'istest' is true (indicating that the program in question is a
Go test binary), then we tentatively queue up both emitMetaData and
emitCounterData as exit hooks. In the normal case (e.g. regular "go
test -cover" run) the testmain.go boilerplate will run at the end
of the test, write out the coverage percentage, and then invoke
MarkProfileEmitted to indicate that no more work needs to be
done. If however that call is never made, this is a sign that the
test binary is being used as a replacement binary for the tool
being tested, hence we do want to run exit hooks when the program
terminates.</p>
               
               <pre><code>func InitHook(istest bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarkProfileEmitted" data-name="MarkProfileEmitted">
               <h3>
                  MarkProfileEmitted 
                  <span class="badge">function</span>
                  
                  <a href="#MarkProfileEmitted" class="anchor" title="Link to MarkProfileEmitted">#</a>
               </h3>
               
               <p>MarkProfileEmitted signals the coverage machinery that
coverage data output files have already been written out, and there
is no need to take any additional action at exit time. This
function is called from the coverage-related boilerplate code in _testmain.go
emitted for go unit tests.</p>
               
               <pre><code>func MarkProfileEmitted(val bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ProcessCoverTestDir" data-name="ProcessCoverTestDir">
               <h3>
                  ProcessCoverTestDir 
                  <span class="badge">function</span>
                  
                  <a href="#ProcessCoverTestDir" class="anchor" title="Link to ProcessCoverTestDir">#</a>
               </h3>
               
               <p>ProcessCoverTestDir is called from
testmain code when "go test -cover" is in effect. It is not
intended to be used other than internally by the Go command's
generated code.</p>
               
               <pre><code>func ProcessCoverTestDir(dir string, cfile string, cm string, cpkg string, w io.Writer, selpkgs []string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Snapshot" data-name="Snapshot">
               <h3>
                  Snapshot 
                  <span class="badge">function</span>
                  
                  <a href="#Snapshot" class="anchor" title="Link to Snapshot">#</a>
               </h3>
               
               <p>Snapshot returns a snapshot of coverage percentage at a moment of
time within a running test, so as to support the testing.Coverage()
function. This version doesn't examine coverage meta-data, so the
result it returns will be less accurate (more "slop") due to the
fact that we don't look at the meta data to see how many statements
are associated with each counter.</p>
               
               <pre><code>func Snapshot() float64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="VisitFuncs" data-name="VisitFuncs">
               <h3>
                  VisitFuncs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#VisitFuncs" class="anchor" title="Link to VisitFuncs">#</a>
               </h3>
               
               <pre><code>func (s *emitState) VisitFuncs(f encodecounter.CounterVisitorFn) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteCounters" data-name="WriteCounters">
               <h3>
                  WriteCounters 
                  <span class="badge">function</span>
                  
                  <a href="#WriteCounters" class="anchor" title="Link to WriteCounters">#</a>
               </h3>
               
               <p>WriteCounters implements [runtime/coverage.WriteCounters].</p>
               
               <pre><code>func WriteCounters(w io.Writer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteCountersDir" data-name="WriteCountersDir">
               <h3>
                  WriteCountersDir 
                  <span class="badge">function</span>
                  
                  <a href="#WriteCountersDir" class="anchor" title="Link to WriteCountersDir">#</a>
               </h3>
               
               <p>WriteCountersDir implements [runtime/coverage.WriteCountersDir].</p>
               
               <pre><code>func WriteCountersDir(dir string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteMeta" data-name="WriteMeta">
               <h3>
                  WriteMeta 
                  <span class="badge">function</span>
                  
                  <a href="#WriteMeta" class="anchor" title="Link to WriteMeta">#</a>
               </h3>
               
               <p>WriteMeta implements [runtime/coverage.WriteMeta].</p>
               
               <pre><code>func WriteMeta(w io.Writer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteMetaDir" data-name="WriteMetaDir">
               <h3>
                  WriteMetaDir 
                  <span class="badge">function</span>
                  
                  <a href="#WriteMetaDir" class="anchor" title="Link to WriteMetaDir">#</a>
               </h3>
               
               <p>WriteMetaDir implements [runtime/coverage.WriteMetaDir].</p>
               
               <pre><code>func WriteMetaDir(dir string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="captureOsArgs" data-name="captureOsArgs">
               <h3>
                  captureOsArgs 
                  <span class="badge">function</span>
                  
                  <a href="#captureOsArgs" class="anchor" title="Link to captureOsArgs">#</a>
               </h3>
               
               <p>captureOsArgs converts os.Args() into the format we use to store
this info in the counter data file (counter data file "args"
section is a generic key-value collection). See the 'args' section
in internal/coverage/defs.go for more info. The args map
is also used to capture GOOS + GOARCH values as well.</p>
               
               <pre><code>func captureOsArgs() map[string]string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitCounterData" data-name="emitCounterData">
               <h3>
                  emitCounterData 
                  <span class="badge">function</span>
                  
                  <a href="#emitCounterData" class="anchor" title="Link to emitCounterData">#</a>
               </h3>
               
               <p>emitCounterData emits the counter data output file for this coverage run.
This entry point is intended to be invoked by the runtime when an
instrumented program is terminating or calling os.Exit().</p>
               
               <pre><code>func emitCounterData()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitCounterDataFile" data-name="emitCounterDataFile">
               <h3>
                  emitCounterDataFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#emitCounterDataFile" class="anchor" title="Link to emitCounterDataFile">#</a>
               </h3>
               
               <p>emitCounterDataFile emits the counter data portion of a
coverage output file (to the file 's.cf').</p>
               
               <pre><code>func (s *emitState) emitCounterDataFile(finalHash [16]byte, w io.Writer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitCounterDataToDirectory" data-name="emitCounterDataToDirectory">
               <h3>
                  emitCounterDataToDirectory 
                  <span class="badge">function</span>
                  
                  <a href="#emitCounterDataToDirectory" class="anchor" title="Link to emitCounterDataToDirectory">#</a>
               </h3>
               
               <p>emitCounterDataToDirectory emits the counter-data output file for this coverage run.</p>
               
               <pre><code>func emitCounterDataToDirectory(outdir string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitCounterDataToWriter" data-name="emitCounterDataToWriter">
               <h3>
                  emitCounterDataToWriter 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#emitCounterDataToWriter" class="anchor" title="Link to emitCounterDataToWriter">#</a>
               </h3>
               
               <p>emitCounterDataToWriter emits counter data for this coverage run to an io.Writer.</p>
               
               <pre><code>func (s *emitState) emitCounterDataToWriter(w io.Writer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitMetaData" data-name="emitMetaData">
               <h3>
                  emitMetaData 
                  <span class="badge">function</span>
                  
                  <a href="#emitMetaData" class="anchor" title="Link to emitMetaData">#</a>
               </h3>
               
               <p>emitMetaData emits the meta-data output file for this coverage run.
This entry point is intended to be invoked by the compiler from
an instrumented program's main package init func.</p>
               
               <pre><code>func emitMetaData()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitMetaDataFile" data-name="emitMetaDataFile">
               <h3>
                  emitMetaDataFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#emitMetaDataFile" class="anchor" title="Link to emitMetaDataFile">#</a>
               </h3>
               
               <p>emitMetaDataFile emits coverage meta-data to a previously opened
temporary file (s.mftmp), then renames the generated file to the
final path (s.mfname).</p>
               
               <pre><code>func (s *emitState) emitMetaDataFile(finalHash [16]byte, tlen uint64) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitMetaDataToDirectory" data-name="emitMetaDataToDirectory">
               <h3>
                  emitMetaDataToDirectory 
                  <span class="badge">function</span>
                  
                  <a href="#emitMetaDataToDirectory" class="anchor" title="Link to emitMetaDataToDirectory">#</a>
               </h3>
               
               <p>emitMetaDataToDirectory emits the meta-data output file to the specified
directory, returning an error if something went wrong.</p>
               
               <pre><code>func emitMetaDataToDirectory(outdir string, ml []rtcov.CovMetaBlob) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getCovCounterList" data-name="getCovCounterList">
               <h3>
                  getCovCounterList 
                  <span class="badge">function</span>
                  
                  <a href="#getCovCounterList" class="anchor" title="Link to getCovCounterList">#</a>
               </h3>
               
               <p>getCovCounterList returns a list of counter-data blobs registered
for the currently executing instrumented program. It is defined in the
runtime.
go:linkname getCovCounterList</p>
               
               <pre><code>func getCovCounterList() []rtcov.CovCounterBlob</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="granClash" data-name="granClash">
               <h3>
                  granClash 
                  <span class="badge">function</span>
                  
                  <a href="#granClash" class="anchor" title="Link to granClash">#</a>
               </h3>
               
               <pre><code>func granClash(g coverage.CounterGranularity) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modeClash" data-name="modeClash">
               <h3>
                  modeClash 
                  <span class="badge">function</span>
                  
                  <a href="#modeClash" class="anchor" title="Link to modeClash">#</a>
               </h3>
               
               <pre><code>func modeClash(m coverage.CounterMode) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="needMetaDataFile" data-name="needMetaDataFile">
               <h3>
                  needMetaDataFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#needMetaDataFile" class="anchor" title="Link to needMetaDataFile">#</a>
               </h3>
               
               <p>needMetaDataFile returns TRUE if we need to emit a meta-data file
for this program run. It should be used only after
openOutputFiles() has been invoked.</p>
               
               <pre><code>func (s *emitState) needMetaDataFile() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openCounterFile" data-name="openCounterFile">
               <h3>
                  openCounterFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#openCounterFile" class="anchor" title="Link to openCounterFile">#</a>
               </h3>
               
               <p>openCounterFile opens an output file for the counter data portion
of a test coverage run. If updates the 'cfname' and 'cf' fields in
's', returning an error if something went wrong.</p>
               
               <pre><code>func (s *emitState) openCounterFile(metaHash [16]byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openMetaFile" data-name="openMetaFile">
               <h3>
                  openMetaFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#openMetaFile" class="anchor" title="Link to openMetaFile">#</a>
               </h3>
               
               <p>openMetaFile determines whether we need to emit a meta-data output
file, or whether we can reuse the existing file in the coverage out
dir. It updates mfname/mftmp/mf fields in 's', returning an error
if something went wrong. See the comment on the emitState type
definition above for more on how file opening is managed.</p>
               
               <pre><code>func (s *emitState) openMetaFile(metaHash [16]byte, metaLen uint64) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openOutputFiles" data-name="openOutputFiles">
               <h3>
                  openOutputFiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#openOutputFiles" class="anchor" title="Link to openOutputFiles">#</a>
               </h3>
               
               <p>openOutputFiles opens output files in preparation for emitting
coverage data. In the case of the meta-data file, openOutputFiles
may determine that we can reuse an existing meta-data file in the
outdir, in which case it will leave the 'mf' field in the state
struct as nil. If a new meta-file is needed, the field 'mfname'
will be the final desired path of the meta file, 'mftmp' will be a
temporary file, and 'mf' will be an open os.File pointer for
'mftmp'. The idea is that the client/caller will write content into
'mf', close it, and then rename 'mftmp' to 'mfname'. This function
also opens the counter data output file, setting 'cf' and 'cfname'
in the state struct.</p>
               
               <pre><code>func (s *emitState) openOutputFiles(metaHash [16]byte, metaLen uint64, which fileType) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="prepareForMetaEmit" data-name="prepareForMetaEmit">
               <h3>
                  prepareForMetaEmit 
                  <span class="badge">function</span>
                  
                  <a href="#prepareForMetaEmit" class="anchor" title="Link to prepareForMetaEmit">#</a>
               </h3>
               
               <p>prepareForMetaEmit performs preparatory steps needed prior to
emitting a meta-data file, notably computing a final hash of
all meta-data blobs and capturing os args.</p>
               
               <pre><code>func prepareForMetaEmit() ([]rtcov.CovMetaBlob, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processPod" data-name="processPod">
               <h3>
                  processPod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processPod" class="anchor" title="Link to processPod">#</a>
               </h3>
               
               <p>processPod reads coverage counter data for a specific pod.</p>
               
               <pre><code>func (ts *tstate) processPod(p pods.Pod, importpaths map[string]struct{...}) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readAuxMetaFiles" data-name="readAuxMetaFiles">
               <h3>
                  readAuxMetaFiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readAuxMetaFiles" class="anchor" title="Link to readAuxMetaFiles">#</a>
               </h3>
               
               <pre><code>func (ts *tstate) readAuxMetaFiles(metafiles string, importpaths map[string]struct{...}) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reportErrorInHardcodedList" data-name="reportErrorInHardcodedList">
               <h3>
                  reportErrorInHardcodedList 
                  <span class="badge">function</span>
                  
                  <a href="#reportErrorInHardcodedList" class="anchor" title="Link to reportErrorInHardcodedList">#</a>
               </h3>
               
               <pre><code>func reportErrorInHardcodedList(slot int32, pkgID int32, fnID uint32, nCtrs uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeMetaData" data-name="writeMetaData">
               <h3>
                  writeMetaData 
                  <span class="badge">function</span>
                  
                  <a href="#writeMetaData" class="anchor" title="Link to writeMetaData">#</a>
               </h3>
               
               <pre><code>func writeMetaData(w io.Writer, metalist []rtcov.CovMetaBlob, cmode coverage.CounterMode, gran coverage.CounterGranularity, finalHash [16]byte) error</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>