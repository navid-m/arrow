<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - poll</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>poll</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"internal/itoa"
"runtime"
"sync"
"syscall"
"sync/atomic"
"errors"
"sync"
"syscall"
"time"
_ "unsafe"
"syscall"
"syscall"
"syscall"
"errors"
"internal/syscall/unix"
"syscall"
"syscall"
"time"
"syscall"
"unsafe"
"syscall"
"unsafe"
"internal/syscall/unix"
"io"
"syscall"
"errors"
"internal/race"
"internal/syscall/windows"
"io"
"sync"
"syscall"
"unicode/utf16"
"unicode/utf8"
"unsafe"
"syscall"
"syscall"
"syscall"
"errors"
"internal/stringslite"
"io"
"sync"
"syscall"
"time"
"syscall"
"syscall"
"io"
"runtime"
"syscall"
"internal/syscall/unix"
"sync"
"syscall"
"syscall"
"syscall"
_ "unsafe"
"syscall"
"syscall"
"syscall"
"io"
"syscall"
"errors"
"syscall"
_ "unsafe"
"internal/itoa"
"internal/syscall/unix"
"io"
"sync/atomic"
"syscall"
"syscall"
"internal/syscall/unix"
"runtime"
"sync"
"syscall"
"unsafe"
"syscall"
"internal/syscall/unix"
"syscall"
"io"
"runtime"
"syscall"
"internal/syscall/unix"
"syscall"
"syscall"
"internal/byteorder"
"sync/atomic"
"syscall"
"unsafe"
"syscall"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="Accept4Func">
               <h3>
                  Accept4Func 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Accept4Func is used to hook the accept4 call.</p>
               
               <pre><code>var Accept4Func func(int, int) (int, syscall.Sockaddr, error) = syscall.Accept4</code></pre>
            </article>
            
            <article class="global" data-name="AcceptFunc">
               <h3>
                  AcceptFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>AcceptFunc is used to hook the accept call.</p>
               
               <pre><code>var AcceptFunc func(syscall.Handle, syscall.Handle, *byte, uint32, uint32, uint32, *uint32, *syscall.Overlapped) error = syscall.AcceptEx</code></pre>
            </article>
            
            <article class="global" data-name="AcceptFunc">
               <h3>
                  AcceptFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>AcceptFunc is used to hook the accept call.</p>
               
               <pre><code>var AcceptFunc func(int) (int, syscall.Sockaddr, error) = syscall.Accept</code></pre>
            </article>
            
            <article class="global" data-name="CloseFunc">
               <h3>
                  CloseFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>CloseFunc is used to hook the close call.</p>
               
               <pre><code>var CloseFunc func(syscall.Handle) error = syscall.Closesocket</code></pre>
            </article>
            
            <article class="global" data-name="CloseFunc">
               <h3>
                  CloseFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>CloseFunc is used to hook the close call.</p>
               
               <pre><code>var CloseFunc func(int) error = syscall.Close</code></pre>
            </article>
            
            <article class="global" data-name="ConnectExFunc">
               <h3>
                  ConnectExFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ConnectExFunc is used to hook the ConnectEx call.</p>
               
               <pre><code>var ConnectExFunc func(syscall.Handle, syscall.Sockaddr, *byte, uint32, *uint32, *syscall.Overlapped) error = syscall.ConnectEx</code></pre>
            </article>
            
            <article class="global" data-name="ErrDeadlineExceeded">
               <h3>
                  ErrDeadlineExceeded 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrDeadlineExceeded is returned for an expired deadline.
This is exported by the os package as os.ErrDeadlineExceeded.</p>
               
               <pre><code>var ErrDeadlineExceeded error = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrFileClosing">
               <h3>
                  ErrFileClosing 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrFileClosing is returned when a file descriptor is used after it
has been closed.</p>
               
               <pre><code>var ErrFileClosing = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrNetClosing">
               <h3>
                  ErrNetClosing 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrNetClosing is returned when a network descriptor is used after
it has been closed.</p>
               
               <pre><code>var ErrNetClosing = errNetClosing{...}</code></pre>
            </article>
            
            <article class="global" data-name="ErrNoDeadline">
               <h3>
                  ErrNoDeadline 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrNoDeadline is returned when a request is made to set a deadline
on a file type that does not use the poller.</p>
               
               <pre><code>var ErrNoDeadline = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrNotPollable">
               <h3>
                  ErrNotPollable 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrNotPollable is returned when the file or socket is not suitable
for event notification.</p>
               
               <pre><code>var ErrNotPollable = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="InitWSA">
               <h3>
                  InitWSA 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>InitWSA initiates the use of the Winsock DLL by the current process.
It is called from the net package at init time to avoid
loading ws2_32.dll when net is not used.</p>
               
               <pre><code>var InitWSA = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ReadConsole">
               <h3>
                  ReadConsole 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ReadConsole = syscall.ReadConsole</code></pre>
            </article>
            
            <article class="global" data-name="TestHookDidSendFile">
               <h3>
                  TestHookDidSendFile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var TestHookDidSendFile = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global" data-name="TestHookDidWritev">
               <h3>
                  TestHookDidWritev 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>TestHookDidWritev is a hook for testing writev.</p>
               
               <pre><code>var TestHookDidWritev = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global" data-name="dupCloexecUnsupported">
               <h3>
                  dupCloexecUnsupported 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>dupCloexecUnsupported indicates whether F_DUPFD_CLOEXEC is supported by the kernel.</p>
               
               <pre><code>var dupCloexecUnsupported atomic.Bool</code></pre>
            </article>
            
            <article class="global" data-name="errEAGAIN">
               <h3>
                  errEAGAIN 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Do the interface allocations only once for common
Errno values.</p>
               
               <pre><code>var errEAGAIN error = syscall.EAGAIN</code></pre>
            </article>
            
            <article class="global" data-name="errEINVAL">
               <h3>
                  errEINVAL 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Do the interface allocations only once for common
Errno values.</p>
               
               <pre><code>var errEINVAL error = syscall.EINVAL</code></pre>
            </article>
            
            <article class="global" data-name="errENOENT">
               <h3>
                  errENOENT 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Do the interface allocations only once for common
Errno values.</p>
               
               <pre><code>var errENOENT error = syscall.ENOENT</code></pre>
            </article>
            
            <article class="global" data-name="errERROR_IO_PENDING">
               <h3>
                  errERROR_IO_PENDING 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errERROR_IO_PENDING error = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="initErr">
               <h3>
                  initErr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var initErr error</code></pre>
            </article>
            
            <article class="global" data-name="ioSync">
               <h3>
                  ioSync 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ioSync uint64</code></pre>
            </article>
            
            <article class="global" data-name="isKernelVersionGE53">
               <h3>
                  isKernelVersionGE53 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var isKernelVersionGE53 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="kindConsole">
               <h3>
                  kindConsole 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const kindConsole</code></pre>
            </article>
            
            <article class="global" data-name="kindFile">
               <h3>
                  kindFile 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const kindFile</code></pre>
            </article>
            
            <article class="global" data-name="kindNet">
               <h3>
                  kindNet 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const kindNet fileKind = iota</code></pre>
            </article>
            
            <article class="global" data-name="kindPipe">
               <h3>
                  kindPipe 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const kindPipe</code></pre>
            </article>
            
            <article class="global" data-name="logInitFD">
               <h3>
                  logInitFD 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>logInitFD is set by tests to enable file descriptor initialization logging.</p>
               
               <pre><code>var logInitFD func(net string, fd *FD, err error)</code></pre>
            </article>
            
            <article class="global" data-name="maxCopyFileRangeRound">
               <h3>
                  maxCopyFileRangeRound 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For best performance, call copy_file_range() with the largest len value
possible. It is interruptible on most file systems, so there is no penalty
for using very large len values, even SSIZE_MAX.</p>
               
               <pre><code>const maxCopyFileRangeRound = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxCopyFileRangeRound">
               <h3>
                  maxCopyFileRangeRound 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>For best performance, call copy_file_range() with the largest len value
possible. Linux sets up a limitation of data transfer for most of its I/O
system calls, as MAX_RW_COUNT (INT_MAX & PAGE_MASK). This value equals to
the maximum integer value minus a page size that is typically 2^12=4096 bytes.
That is to say, it's the maximum integer value with the lowest 12 bits unset,
which is 0x7ffff000.</p>
               
               <pre><code>const maxCopyFileRangeRound = 0x7ffff000</code></pre>
            </article>
            
            <article class="global" data-name="maxRW">
               <h3>
                  maxRW 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Darwin and FreeBSD can't read or write 2GB+ files at a time,
even on 64-bit systems.
The same is true of socket implementations on many systems.
See golang.org/issue/7812 and golang.org/issue/16266.
Use 1GB instead of, say, 2GB-1, to keep subsequent reads aligned.</p>
               
               <pre><code>const maxRW = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxRW">
               <h3>
                  maxRW 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Windows ReadFile and WSARecv use DWORD (uint32) parameter to pass buffer length.
This prevents us reading blocks larger than 4GB.
See golang.org/issue/26923.</p>
               
               <pre><code>const maxRW = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxSpliceSize">
               <h3>
                  maxSpliceSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>maxSpliceSize is the maximum amount of data Splice asks
the kernel to move in a single call to splice(2).
We use 1MB as Splice writes data through a pipe, and 1MB is the default maximum pipe buffer size,
which is determined by /proc/sys/fs/pipe-max-size.</p>
               
               <pre><code>const maxSpliceSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="mutexClosed">
               <h3>
                  mutexClosed 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>fdMutex.state is organized as follows:
1 bit - whether FD is closed, if set all subsequent lock operations will fail.
1 bit - lock for read operations.
1 bit - lock for write operations.
20 bits - total number of references (read+write+misc).
20 bits - number of outstanding read waiters.
20 bits - number of outstanding write waiters.</p>
               
               <pre><code>const mutexClosed = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="mutexRLock">
               <h3>
                  mutexRLock 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>fdMutex.state is organized as follows:
1 bit - whether FD is closed, if set all subsequent lock operations will fail.
1 bit - lock for read operations.
1 bit - lock for write operations.
20 bits - total number of references (read+write+misc).
20 bits - number of outstanding read waiters.
20 bits - number of outstanding write waiters.</p>
               
               <pre><code>const mutexRLock = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="mutexRMask">
               <h3>
                  mutexRMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>fdMutex.state is organized as follows:
1 bit - whether FD is closed, if set all subsequent lock operations will fail.
1 bit - lock for read operations.
1 bit - lock for write operations.
20 bits - total number of references (read+write+misc).
20 bits - number of outstanding read waiters.
20 bits - number of outstanding write waiters.</p>
               
               <pre><code>const mutexRMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="mutexRWait">
               <h3>
                  mutexRWait 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>fdMutex.state is organized as follows:
1 bit - whether FD is closed, if set all subsequent lock operations will fail.
1 bit - lock for read operations.
1 bit - lock for write operations.
20 bits - total number of references (read+write+misc).
20 bits - number of outstanding read waiters.
20 bits - number of outstanding write waiters.</p>
               
               <pre><code>const mutexRWait = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="mutexRef">
               <h3>
                  mutexRef 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>fdMutex.state is organized as follows:
1 bit - whether FD is closed, if set all subsequent lock operations will fail.
1 bit - lock for read operations.
1 bit - lock for write operations.
20 bits - total number of references (read+write+misc).
20 bits - number of outstanding read waiters.
20 bits - number of outstanding write waiters.</p>
               
               <pre><code>const mutexRef = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="mutexRefMask">
               <h3>
                  mutexRefMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>fdMutex.state is organized as follows:
1 bit - whether FD is closed, if set all subsequent lock operations will fail.
1 bit - lock for read operations.
1 bit - lock for write operations.
20 bits - total number of references (read+write+misc).
20 bits - number of outstanding read waiters.
20 bits - number of outstanding write waiters.</p>
               
               <pre><code>const mutexRefMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="mutexWLock">
               <h3>
                  mutexWLock 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>fdMutex.state is organized as follows:
1 bit - whether FD is closed, if set all subsequent lock operations will fail.
1 bit - lock for read operations.
1 bit - lock for write operations.
20 bits - total number of references (read+write+misc).
20 bits - number of outstanding read waiters.
20 bits - number of outstanding write waiters.</p>
               
               <pre><code>const mutexWLock = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="mutexWMask">
               <h3>
                  mutexWMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>fdMutex.state is organized as follows:
1 bit - whether FD is closed, if set all subsequent lock operations will fail.
1 bit - lock for read operations.
1 bit - lock for write operations.
20 bits - total number of references (read+write+misc).
20 bits - number of outstanding read waiters.
20 bits - number of outstanding write waiters.</p>
               
               <pre><code>const mutexWMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="mutexWWait">
               <h3>
                  mutexWWait 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>fdMutex.state is organized as follows:
1 bit - whether FD is closed, if set all subsequent lock operations will fail.
1 bit - lock for read operations.
1 bit - lock for write operations.
20 bits - total number of references (read+write+misc).
20 bits - number of outstanding read waiters.
20 bits - number of outstanding write waiters.</p>
               
               <pre><code>const mutexWWait = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="overflowMsg">
               <h3>
                  overflowMsg 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const overflowMsg = "too many concurrent operations on a single file or socket (max 1048575)"</code></pre>
            </article>
            
            <article class="global" data-name="pollErrClosing">
               <h3>
                  pollErrClosing 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Error values returned by runtime_pollReset and runtime_pollWait.
These must match the values in runtime/netpoll.go.</p>
               
               <pre><code>const pollErrClosing = 1</code></pre>
            </article>
            
            <article class="global" data-name="pollErrNotPollable">
               <h3>
                  pollErrNotPollable 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Error values returned by runtime_pollReset and runtime_pollWait.
These must match the values in runtime/netpoll.go.</p>
               
               <pre><code>const pollErrNotPollable = 3</code></pre>
            </article>
            
            <article class="global" data-name="pollErrTimeout">
               <h3>
                  pollErrTimeout 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Error values returned by runtime_pollReset and runtime_pollWait.
These must match the values in runtime/netpoll.go.</p>
               
               <pre><code>const pollErrTimeout = 2</code></pre>
            </article>
            
            <article class="global" data-name="pollNoError">
               <h3>
                  pollNoError 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Error values returned by runtime_pollReset and runtime_pollWait.
These must match the values in runtime/netpoll.go.</p>
               
               <pre><code>const pollNoError = 0</code></pre>
            </article>
            
            <article class="global" data-name="serverInit">
               <h3>
                  serverInit 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var serverInit sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="sizeOfDirent">
               <h3>
                  sizeOfDirent 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>https://github.com/WebAssembly/WASI/blob/main/legacy/preview1/docs.md#-dirent-record</p>
               
               <pre><code>const sizeOfDirent = 24</code></pre>
            </article>
            
            <article class="global" data-name="spliceNonblock">
               <h3>
                  spliceNonblock 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>spliceNonblock doesn't make the splice itself necessarily nonblocking
(because the actual file descriptors that are spliced from/to may block
unless they have the O_NONBLOCK flag set), but it makes the splice pipe
operations nonblocking.</p>
               
               <pre><code>const spliceNonblock = 0x2</code></pre>
            </article>
            
            <article class="global" data-name="splicePipePool">
               <h3>
                  splicePipePool 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>splicePipePool caches pipes to avoid high-frequency construction and destruction of pipe buffers.
The garbage collector will free all pipes in the sync.Pool periodically, thus we need to set up
a finalizer for each pipe to close its file descriptors before the actual GC.</p>
               
               <pre><code>var splicePipePool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global" data-name="useSetFileCompletionNotificationModes">
               <h3>
                  useSetFileCompletionNotificationModes 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var useSetFileCompletionNotificationModes bool</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="String">
               <h3>
                  String
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>String is an internal string definition for methods/functions
that is not intended for use outside the standard libraries.
Other packages in std that import internal/poll and have some
exported APIs (now we've got some in net.rawConn) which are only used
internally and are not intended to be used outside the standard libraries,
Therefore, we make those APIs use internal types like poll.FD or poll.String
in their function signatures to disable the usability of these APIs from
external codebase.</p>
               
               <pre><code>type String string</code></pre>
            </article>
            
            <article class="type" data-name="fileKind">
               <h3>
                  fileKind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>fileKind describes the kind of file.</p>
               
               <pre><code>type fileKind byte</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="DeadlineExceededError">
               <h3>
                  DeadlineExceededError
                  <span class="badge">struct</span>
               </h3>
               
               <p>DeadlineExceededError is returned for an expired deadline.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type DeadlineExceededError struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="FD">
               <h3>
                  FD
                  <span class="badge">struct</span>
               </h3>
               
               <p>FD is a file descriptor. The net and os packages embed this type in
a larger type representing a network connection or OS file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FD struct {
fdmu fdMutex
Sysfd syscall.Handle
rop operation
wop operation
pd pollDesc
l sync.Mutex
lastbits []byte
readuint16 []uint16
readbyte []byte
readbyteOffset int
csema uint32
skipSyncNotif bool
IsStream bool
ZeroReadIsEOF bool
isFile bool
kind fileKind
}</code></pre>
            </article>
            
            <article class="struct" data-name="FD">
               <h3>
                  FD
                  <span class="badge">struct</span>
               </h3>
               
               <p>FD is a file descriptor. The net and os packages use this type as a
field of a larger type representing a network connection or OS file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FD struct {
fdmu fdMutex
Sysfd int
SysFile
pd pollDesc
csema uint32
isBlocking uint32
IsStream bool
ZeroReadIsEOF bool
isFile bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="FD">
               <h3>
                  FD
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FD struct {
fdmu fdMutex
Destroy func()
rmu sync.Mutex
wmu sync.Mutex
raio *asyncIO
waio *asyncIO
rtimer *time.Timer
wtimer *time.Timer
rtimedout bool
wtimedout bool
isFile bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="FDMutex">
               <h3>
                  FDMutex
                  <span class="badge">struct</span>
               </h3>
               
               <p>FDMutex is an exported fdMutex, only for Plan 9.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FDMutex struct {
fdmu fdMutex
}</code></pre>
            </article>
            
            <article class="struct" data-name="SysFile">
               <h3>
                  SysFile
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SysFile struct {
iovecs *[]syscall.Iovec
}</code></pre>
            </article>
            
            <article class="struct" data-name="SysFile">
               <h3>
                  SysFile
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SysFile struct {
RefCountPtr *int32
RefCount int32
Filetype uint32
Dircookie uint64
Path string
}</code></pre>
            </article>
            
            <article class="struct" data-name="asyncIO">
               <h3>
                  asyncIO
                  <span class="badge">struct</span>
               </h3>
               
               <p>asyncIO implements asynchronous cancelable I/O.
An asyncIO represents a single asynchronous Read or Write
operation. The result is returned on the result channel.
The undergoing I/O system call can either complete or be
interrupted by a note.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type asyncIO struct {
res chan result
mu sync.Mutex
pid int
}</code></pre>
            </article>
            
            <article class="struct" data-name="errNetClosing">
               <h3>
                  errNetClosing
                  <span class="badge">struct</span>
               </h3>
               
               <p>errNetClosing is the type of the variable ErrNetClosing.
This is used to implement the net.Error interface.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type errNetClosing struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="fdMutex">
               <h3>
                  fdMutex
                  <span class="badge">struct</span>
               </h3>
               
               <p>fdMutex is a specialized synchronization primitive that manages
lifetime of an fd and serializes access to Read, Write and Close
methods on FD.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fdMutex struct {
state uint64
rsema uint32
wsema uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="operation">
               <h3>
                  operation
                  <span class="badge">struct</span>
               </h3>
               
               <p>operation contains superset of data necessary to perform all async IO.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type operation struct {
o syscall.Overlapped
runtimeCtx uintptr
mode int32
fd *FD
buf syscall.WSABuf
msg windows.WSAMsg
sa syscall.Sockaddr
rsa *syscall.RawSockaddrAny
rsan int32
handle syscall.Handle
flags uint32
qty uint32
bufs []syscall.WSABuf
}</code></pre>
            </article>
            
            <article class="struct" data-name="pollDesc">
               <h3>
                  pollDesc
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pollDesc struct {
fd *FD
closing bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="pollDesc">
               <h3>
                  pollDesc
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pollDesc struct {
runtimeCtx uintptr
}</code></pre>
            </article>
            
            <article class="struct" data-name="result">
               <h3>
                  result
                  <span class="badge">struct</span>
               </h3>
               
               <p>result is the return value of a Read or Write operation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type result struct {
n int
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="splicePipe">
               <h3>
                  splicePipe
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type splicePipe struct {
splicePipeFields
_ [*ast.BinaryExpr]byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="splicePipeFields">
               <h3>
                  splicePipeFields
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type splicePipeFields struct {
rfd int
wfd int
data int
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Accept">
               <h3>
                  Accept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Accept handles accepting a socket. The sysSocket parameter is used
to allocate the net socket.</p>
               
               <pre><code>func (fd *FD) Accept(sysSocket func() (syscall.Handle, error)) (syscall.Handle, []syscall.RawSockaddrAny, uint32, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="Accept">
               <h3>
                  Accept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Accept wraps the accept network call.</p>
               
               <pre><code>func (fd *FD) Accept() (int, syscall.Sockaddr, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="Cancel">
               <h3>
                  Cancel 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Cancel interrupts the I/O operation, causing
the Wait function to return.</p>
               
               <pre><code>func (aio *asyncIO) Cancel()</code></pre>
            </article>
            
            <article class="function" data-name="ClearBufs">
               <h3>
                  ClearBufs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ClearBufs clears all pointers to Buffers parameter captured
by InitBufs, so it can be released by garbage collector.</p>
               
               <pre><code>func (o *operation) ClearBufs()</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close handles the locking for closing an FD. The real operation
is in the net package.</p>
               
               <pre><code>func (fd *FD) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close closes the FD. The underlying file descriptor is closed by
the destroy method when there are no remaining references.</p>
               
               <pre><code>func (fd *FD) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close closes the FD. The underlying file descriptor is closed by the
destroy method when there are no remaining references.</p>
               
               <pre><code>func (fd *FD) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="ConnectEx">
               <h3>
                  ConnectEx 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Call ConnectEx. This doesn't need any locking, since it is only
called when the descriptor is first created. This is here rather
than in the net package so that it can use fd.wop.</p>
               
               <pre><code>func (fd *FD) ConnectEx(ra syscall.Sockaddr) error</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Copy creates a copy of the FD.
The FD instance points to the same underlying file descriptor. The file
descriptor isn't closed until all FD instances that refer to it have been
closed/destroyed.</p>
               
               <pre><code>func (fd *FD) Copy() FD</code></pre>
            </article>
            
            <article class="function" data-name="CopyFileRange">
               <h3>
                  CopyFileRange 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CopyFileRange copies at most remain bytes of data from src to dst, using
the copy_file_range system call. dst and src must refer to regular files.</p>
               
               <pre><code>func CopyFileRange(dst *FD, src *FD, remain int64) (written int64, handled bool, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Decref">
               <h3>
                  Decref 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fdmu *FDMutex) Decref() bool</code></pre>
            </article>
            
            <article class="function" data-name="Dup">
               <h3>
                  Dup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Dup duplicates the file descriptor.</p>
               
               <pre><code>func (fd *FD) Dup() (int, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="DupCloseOnExec">
               <h3>
                  DupCloseOnExec 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func DupCloseOnExec(fd int) (int, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="DupCloseOnExec">
               <h3>
                  DupCloseOnExec 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DupCloseOnExec dups fd and marks it close-on-exec.</p>
               
               <pre><code>func DupCloseOnExec(fd int) (int, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="DupCloseOnExec">
               <h3>
                  DupCloseOnExec 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func DupCloseOnExec(fd int) (int, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Error returns the error message for ErrNetClosing.
Keep this string consistent because of issue #4373:
since historically programs have not been able to detect
this error, they look for the string.</p>
               
               <pre><code>func (e errNetClosing) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Implement the net.Error interface.
The string is "i/o timeout" because that is what was returned
by earlier Go versions. Changing it may break programs that
match on error strings.</p>
               
               <pre><code>func (e *DeadlineExceededError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Fchdir">
               <h3>
                  Fchdir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fchdir wraps syscall.Fchdir.</p>
               
               <pre><code>func (fd *FD) Fchdir() error</code></pre>
            </article>
            
            <article class="function" data-name="Fchdir">
               <h3>
                  Fchdir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fchdir wraps syscall.Fchdir.</p>
               
               <pre><code>func (fd *FD) Fchdir() error</code></pre>
            </article>
            
            <article class="function" data-name="Fchdir">
               <h3>
                  Fchdir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fchdir wraps syscall.Fchdir.</p>
               
               <pre><code>func (fd *FD) Fchdir() error</code></pre>
            </article>
            
            <article class="function" data-name="Fchmod">
               <h3>
                  Fchmod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fchmod updates syscall.ByHandleFileInformation.Fileattributes when needed.</p>
               
               <pre><code>func (fd *FD) Fchmod(mode uint32) error</code></pre>
            </article>
            
            <article class="function" data-name="Fchmod">
               <h3>
                  Fchmod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fchmod wraps syscall.Fchmod.</p>
               
               <pre><code>func (fd *FD) Fchmod(mode uint32) error</code></pre>
            </article>
            
            <article class="function" data-name="Fchown">
               <h3>
                  Fchown 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fchown wraps syscall.Fchown.</p>
               
               <pre><code>func (fd *FD) Fchown(uid int, gid int) error</code></pre>
            </article>
            
            <article class="function" data-name="Fstat">
               <h3>
                  Fstat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fstat wraps syscall.Fstat</p>
               
               <pre><code>func (fd *FD) Fstat(s *syscall.Stat_t) error</code></pre>
            </article>
            
            <article class="function" data-name="Fsync">
               <h3>
                  Fsync 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fsync wraps syscall.Fsync.</p>
               
               <pre><code>func (fd *FD) Fsync() error</code></pre>
            </article>
            
            <article class="function" data-name="Fsync">
               <h3>
                  Fsync 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fsync invokes SYS_FCNTL with SYS_FULLFSYNC because
on OS X, SYS_FSYNC doesn't fully flush contents to disk.
See Issue #26650 as well as the man page for fsync on OS X.</p>
               
               <pre><code>func (fd *FD) Fsync() error</code></pre>
            </article>
            
            <article class="function" data-name="Fsync">
               <h3>
                  Fsync 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Fsync wraps syscall.Fsync.</p>
               
               <pre><code>func (fd *FD) Fsync() error</code></pre>
            </article>
            
            <article class="function" data-name="Ftruncate">
               <h3>
                  Ftruncate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Ftruncate wraps syscall.Ftruncate.</p>
               
               <pre><code>func (fd *FD) Ftruncate(size int64) error</code></pre>
            </article>
            
            <article class="function" data-name="GetFileInformationByHandle">
               <h3>
                  GetFileInformationByHandle 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GetFileInformationByHandle wraps GetFileInformationByHandle.</p>
               
               <pre><code>func (fd *FD) GetFileInformationByHandle(data *syscall.ByHandleFileInformation) error</code></pre>
            </article>
            
            <article class="function" data-name="GetFileType">
               <h3>
                  GetFileType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GetFileType wraps syscall.GetFileType.</p>
               
               <pre><code>func (fd *FD) GetFileType() (uint32, error)</code></pre>
            </article>
            
            <article class="function" data-name="GetsockoptInt">
               <h3>
                  GetsockoptInt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GetsockoptInt wraps the getsockopt network call with an int argument.</p>
               
               <pre><code>func (fd *FD) GetsockoptInt(level int, name int) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Incref">
               <h3>
                  Incref 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fdmu *FDMutex) Incref() bool</code></pre>
            </article>
            
            <article class="function" data-name="IncrefAndClose">
               <h3>
                  IncrefAndClose 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fdmu *FDMutex) IncrefAndClose() bool</code></pre>
            </article>
            
            <article class="function" data-name="Init">
               <h3>
                  Init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Init initializes the FD. The Sysfd field should already be set.
This can be called multiple times on a single FD.
The net argument is a network name from the net package (e.g., "tcp"),
or "file" or "console" or "dir".
Set pollable to true if fd should be managed by runtime netpoll.</p>
               
               <pre><code>func (fd *FD) Init(net string, pollable bool) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="Init">
               <h3>
                  Init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Init initializes the FD. The Sysfd field should already be set.
This can be called multiple times on a single FD.
The net argument is a network name from the net package (e.g., "tcp"),
or "file".
Set pollable to true if fd should be managed by runtime netpoll.</p>
               
               <pre><code>func (fd *FD) Init(net string, pollable bool) error</code></pre>
            </article>
            
            <article class="function" data-name="InitBuf">
               <h3>
                  InitBuf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *operation) InitBuf(buf []byte)</code></pre>
            </article>
            
            <article class="function" data-name="InitBufs">
               <h3>
                  InitBufs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *operation) InitBufs(buf *[][]byte)</code></pre>
            </article>
            
            <article class="function" data-name="InitMsg">
               <h3>
                  InitMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *operation) InitMsg(p []byte, oob []byte)</code></pre>
            </article>
            
            <article class="function" data-name="IsPollDescriptor">
               <h3>
                  IsPollDescriptor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsPollDescriptor reports whether fd is the descriptor being used by the poller.
This is only used for testing.</p>
               
               <pre><code>func IsPollDescriptor(fd uintptr) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPollDescriptor">
               <h3>
                  IsPollDescriptor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsPollDescriptor reports whether fd is the descriptor being used by the poller.
This is only used for testing.</p>
               
               <pre><code>func IsPollDescriptor(fd uintptr) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPollDescriptor">
               <h3>
                  IsPollDescriptor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsPollDescriptor reports whether fd is the descriptor being used by the poller.
This is only used for testing.
IsPollDescriptor should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/opencontainers/runc
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname IsPollDescriptor</p>
               
               <pre><code>func IsPollDescriptor(fd uintptr) bool</code></pre>
            </article>
            
            <article class="function" data-name="OpenDir">
               <h3>
                  OpenDir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>OpenDir returns a pointer to a DIR structure suitable for
ReadDir. In case of an error, the name of the failed
syscall is returned along with a syscall.Errno.</p>
               
               <pre><code>func (fd *FD) OpenDir() (uintptr, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="Pread">
               <h3>
                  Pread 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Pread wraps the pread system call.</p>
               
               <pre><code>func (fd *FD) Pread(p []byte, off int64) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Pread">
               <h3>
                  Pread 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Pread emulates the Unix pread system call.</p>
               
               <pre><code>func (fd *FD) Pread(b []byte, off int64) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Pwrite">
               <h3>
                  Pwrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Pwrite wraps the pwrite system call.</p>
               
               <pre><code>func (fd *FD) Pwrite(p []byte, off int64) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Pwrite">
               <h3>
                  Pwrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Pwrite emulates the Unix pwrite system call.</p>
               
               <pre><code>func (fd *FD) Pwrite(buf []byte, off int64) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="RawControl">
               <h3>
                  RawControl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RawControl invokes the user-defined function f for a non-IO
operation.</p>
               
               <pre><code>func (fd *FD) RawControl(f func(uintptr)) error</code></pre>
            </article>
            
            <article class="function" data-name="RawControl">
               <h3>
                  RawControl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RawControl invokes the user-defined function f for a non-IO
operation.</p>
               
               <pre><code>func (fd *FD) RawControl(f func(uintptr)) error</code></pre>
            </article>
            
            <article class="function" data-name="RawRead">
               <h3>
                  RawRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RawRead invokes the user-defined function f for a read operation.</p>
               
               <pre><code>func (fd *FD) RawRead(f func(uintptr) bool) error</code></pre>
            </article>
            
            <article class="function" data-name="RawRead">
               <h3>
                  RawRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RawRead invokes the user-defined function f for a read operation.</p>
               
               <pre><code>func (fd *FD) RawRead(f func(uintptr) bool) error</code></pre>
            </article>
            
            <article class="function" data-name="RawRead">
               <h3>
                  RawRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RawRead invokes the user-defined function f for a read operation.</p>
               
               <pre><code>func (fd *FD) RawRead(f func(uintptr) bool) error</code></pre>
            </article>
            
            <article class="function" data-name="RawWrite">
               <h3>
                  RawWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RawWrite invokes the user-defined function f for a write operation.</p>
               
               <pre><code>func (fd *FD) RawWrite(f func(uintptr) bool) error</code></pre>
            </article>
            
            <article class="function" data-name="RawWrite">
               <h3>
                  RawWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RawWrite invokes the user-defined function f for a write operation.</p>
               
               <pre><code>func (fd *FD) RawWrite(f func(uintptr) bool) error</code></pre>
            </article>
            
            <article class="function" data-name="RawWrite">
               <h3>
                  RawWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RawWrite invokes the user-defined function f for a write operation.</p>
               
               <pre><code>func (fd *FD) RawWrite(f func(uintptr) bool) error</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Read implements io.Reader.</p>
               
               <pre><code>func (fd *FD) Read(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Read implements io.Reader.</p>
               
               <pre><code>func (fd *FD) Read(buf []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Read implements io.Reader.</p>
               
               <pre><code>func (fd *FD) Read(fn func([]byte) (int, error), b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadDir">
               <h3>
                  ReadDir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadDir wraps syscall.ReadDir.
We treat this like an ordinary system call rather than a call
that tries to fill the buffer.</p>
               
               <pre><code>func (fd *FD) ReadDir(buf []byte, cookie syscall.Dircookie) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadDirent">
               <h3>
                  ReadDirent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *FD) ReadDirent(buf []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadDirent">
               <h3>
                  ReadDirent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadDirent wraps syscall.ReadDirent.
We treat this like an ordinary system call rather than a call
that tries to fill the buffer.</p>
               
               <pre><code>func (fd *FD) ReadDirent(buf []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadFrom wraps the recvfrom network call.</p>
               
               <pre><code>func (fd *FD) ReadFrom(buf []byte) (int, syscall.Sockaddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadFrom wraps the recvfrom network call.</p>
               
               <pre><code>func (fd *FD) ReadFrom(p []byte) (int, syscall.Sockaddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFromInet4">
               <h3>
                  ReadFromInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadFromInet4 wraps the recvfrom network call for IPv4.</p>
               
               <pre><code>func (fd *FD) ReadFromInet4(p []byte, from *syscall.SockaddrInet4) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFromInet4">
               <h3>
                  ReadFromInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadFromInet4 wraps the recvfrom network call for IPv4.</p>
               
               <pre><code>func (fd *FD) ReadFromInet4(buf []byte, sa4 *syscall.SockaddrInet4) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFromInet6">
               <h3>
                  ReadFromInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadFromInet6 wraps the recvfrom network call for IPv6.</p>
               
               <pre><code>func (fd *FD) ReadFromInet6(buf []byte, sa6 *syscall.SockaddrInet6) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFromInet6">
               <h3>
                  ReadFromInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadFromInet6 wraps the recvfrom network call for IPv6.</p>
               
               <pre><code>func (fd *FD) ReadFromInet6(p []byte, from *syscall.SockaddrInet6) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadLock">
               <h3>
                  ReadLock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fdmu *FDMutex) ReadLock() bool</code></pre>
            </article>
            
            <article class="function" data-name="ReadLock">
               <h3>
                  ReadLock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadLock wraps FD.readLock.</p>
               
               <pre><code>func (fd *FD) ReadLock() error</code></pre>
            </article>
            
            <article class="function" data-name="ReadMsg">
               <h3>
                  ReadMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadMsg wraps the recvmsg network call.</p>
               
               <pre><code>func (fd *FD) ReadMsg(p []byte, oob []byte, flags int) (int, int, int, syscall.Sockaddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadMsg">
               <h3>
                  ReadMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadMsg wraps the WSARecvMsg network call.</p>
               
               <pre><code>func (fd *FD) ReadMsg(p []byte, oob []byte, flags int) (int, int, int, syscall.Sockaddr, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadMsgInet4">
               <h3>
                  ReadMsgInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadMsgInet4 is ReadMsg, but specialized for syscall.SockaddrInet4.</p>
               
               <pre><code>func (fd *FD) ReadMsgInet4(p []byte, oob []byte, flags int, sa4 *syscall.SockaddrInet4) (int, int, int, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadMsgInet4">
               <h3>
                  ReadMsgInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadMsgInet4 is ReadMsg, but specialized to return a syscall.SockaddrInet4.</p>
               
               <pre><code>func (fd *FD) ReadMsgInet4(p []byte, oob []byte, flags int, sa4 *syscall.SockaddrInet4) (int, int, int, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadMsgInet6">
               <h3>
                  ReadMsgInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadMsgInet6 is ReadMsg, but specialized for syscall.SockaddrInet6.</p>
               
               <pre><code>func (fd *FD) ReadMsgInet6(p []byte, oob []byte, flags int, sa6 *syscall.SockaddrInet6) (int, int, int, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadMsgInet6">
               <h3>
                  ReadMsgInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadMsgInet6 is ReadMsg, but specialized to return a syscall.SockaddrInet6.</p>
               
               <pre><code>func (fd *FD) ReadMsgInet6(p []byte, oob []byte, flags int, sa6 *syscall.SockaddrInet6) (int, int, int, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadUnlock">
               <h3>
                  ReadUnlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadUnlock wraps FD.readUnlock.</p>
               
               <pre><code>func (fd *FD) ReadUnlock()</code></pre>
            </article>
            
            <article class="function" data-name="ReadUnlock">
               <h3>
                  ReadUnlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fdmu *FDMutex) ReadUnlock() bool</code></pre>
            </article>
            
            <article class="function" data-name="Seek">
               <h3>
                  Seek 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Seek wraps syscall.Seek.</p>
               
               <pre><code>func (fd *FD) Seek(offset int64, whence int) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="Seek">
               <h3>
                  Seek 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Seek wraps syscall.Seek.</p>
               
               <pre><code>func (fd *FD) Seek(offset int64, whence int) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="Seek">
               <h3>
                  Seek 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Seek wraps syscall.Seek.</p>
               
               <pre><code>func (fd *FD) Seek(offset int64, whence int) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="SendFile">
               <h3>
                  SendFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SendFile wraps the sendfile system call.
It copies data from src (a file descriptor) to dstFD,
starting at the current position of src.
It updates the current position of src to after the
copied data.
If size is zero, it copies the rest of src.
Otherwise, it copies up to size bytes.
The handled return parameter indicates whether SendFile
was able to handle some or all of the operation.
If handled is false, sendfile was unable to perform the copy,
has not modified the source or destination,
and the caller should perform the copy using a fallback implementation.</p>
               
               <pre><code>func SendFile(dstFD *FD, src int, size int64) (n int64, err error, handled bool)</code></pre>
            </article>
            
            <article class="function" data-name="SendFile">
               <h3>
                  SendFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SendFile wraps the TransmitFile call.</p>
               
               <pre><code>func SendFile(fd *FD, src syscall.Handle, n int64) (written int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="SetBlocking">
               <h3>
                  SetBlocking 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetBlocking puts the file into blocking mode.</p>
               
               <pre><code>func (fd *FD) SetBlocking() error</code></pre>
            </article>
            
            <article class="function" data-name="SetDeadline">
               <h3>
                  SetDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetDeadline sets the read and write deadlines associated with fd.</p>
               
               <pre><code>func (fd *FD) SetDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetDeadline">
               <h3>
                  SetDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetDeadline sets the read and write deadlines associated with fd.</p>
               
               <pre><code>func (fd *FD) SetDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetDeadline">
               <h3>
                  SetDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetDeadline sets the read and write deadlines associated with fd.</p>
               
               <pre><code>func (fd *FD) SetDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetReadDeadline">
               <h3>
                  SetReadDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetReadDeadline sets the read deadline associated with fd.</p>
               
               <pre><code>func (fd *FD) SetReadDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetReadDeadline">
               <h3>
                  SetReadDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetReadDeadline sets the read deadline associated with fd.</p>
               
               <pre><code>func (fd *FD) SetReadDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetReadDeadline">
               <h3>
                  SetReadDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetReadDeadline sets the read deadline associated with fd.</p>
               
               <pre><code>func (fd *FD) SetReadDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetWriteDeadline">
               <h3>
                  SetWriteDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetWriteDeadline sets the write deadline associated with fd.</p>
               
               <pre><code>func (fd *FD) SetWriteDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetWriteDeadline">
               <h3>
                  SetWriteDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetWriteDeadline sets the write deadline associated with fd.</p>
               
               <pre><code>func (fd *FD) SetWriteDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetWriteDeadline">
               <h3>
                  SetWriteDeadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetWriteDeadline sets the write deadline associated with fd.</p>
               
               <pre><code>func (fd *FD) SetWriteDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function" data-name="SetsockoptByte">
               <h3>
                  SetsockoptByte 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetsockoptByte wraps the setsockopt network call with a byte argument.</p>
               
               <pre><code>func (fd *FD) SetsockoptByte(level int, name int, arg byte) error</code></pre>
            </article>
            
            <article class="function" data-name="SetsockoptIPMreq">
               <h3>
                  SetsockoptIPMreq 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetsockoptIPMreq wraps the setsockopt network call with an IPMreq argument.</p>
               
               <pre><code>func (fd *FD) SetsockoptIPMreq(level int, name int, mreq *syscall.IPMreq) error</code></pre>
            </article>
            
            <article class="function" data-name="SetsockoptIPMreqn">
               <h3>
                  SetsockoptIPMreqn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetsockoptIPMreqn wraps the setsockopt network call with an IPMreqn argument.</p>
               
               <pre><code>func (fd *FD) SetsockoptIPMreqn(level int, name int, mreq *syscall.IPMreqn) error</code></pre>
            </article>
            
            <article class="function" data-name="SetsockoptIPv6Mreq">
               <h3>
                  SetsockoptIPv6Mreq 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetsockoptIPv6Mreq wraps the setsockopt network call with an IPv6Mreq argument.</p>
               
               <pre><code>func (fd *FD) SetsockoptIPv6Mreq(level int, name int, mreq *syscall.IPv6Mreq) error</code></pre>
            </article>
            
            <article class="function" data-name="SetsockoptInet4Addr">
               <h3>
                  SetsockoptInet4Addr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetsockoptInet4Addr wraps the setsockopt network call with an IPv4 address.</p>
               
               <pre><code>func (fd *FD) SetsockoptInet4Addr(level int, name int, arg [4]byte) error</code></pre>
            </article>
            
            <article class="function" data-name="SetsockoptInt">
               <h3>
                  SetsockoptInt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetsockoptInt wraps the setsockopt network call with an int argument.</p>
               
               <pre><code>func (fd *FD) SetsockoptInt(level int, name int, arg int) error</code></pre>
            </article>
            
            <article class="function" data-name="SetsockoptLinger">
               <h3>
                  SetsockoptLinger 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetsockoptLinger wraps the setsockopt network call with a Linger argument.</p>
               
               <pre><code>func (fd *FD) SetsockoptLinger(level int, name int, l *syscall.Linger) error</code></pre>
            </article>
            
            <article class="function" data-name="Shutdown">
               <h3>
                  Shutdown 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Shutdown wraps syscall.Shutdown.</p>
               
               <pre><code>func (fd *FD) Shutdown(how int) error</code></pre>
            </article>
            
            <article class="function" data-name="Splice">
               <h3>
                  Splice 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Splice transfers at most remain bytes of data from src to dst, using the
splice system call to minimize copies of data from and to userspace.
Splice gets a pipe buffer from the pool or creates a new one if needed, to serve as a buffer for the data transfer.
src and dst must both be stream-oriented sockets.</p>
               
               <pre><code>func Splice(dst *FD, src *FD, remain int64) (written int64, handled bool, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e errNetClosing) Temporary() bool</code></pre>
            </article>
            
            <article class="function" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *DeadlineExceededError) Temporary() bool</code></pre>
            </article>
            
            <article class="function" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *DeadlineExceededError) Timeout() bool</code></pre>
            </article>
            
            <article class="function" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e errNetClosing) Timeout() bool</code></pre>
            </article>
            
            <article class="function" data-name="WSAIoctl">
               <h3>
                  WSAIoctl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WSAIoctl wraps the WSAIoctl network call.</p>
               
               <pre><code>func (fd *FD) WSAIoctl(iocc uint32, inbuf *byte, cbif uint32, outbuf *byte, cbob uint32, cbbr *uint32, overlapped *syscall.Overlapped, completionRoutine uintptr) error</code></pre>
            </article>
            
            <article class="function" data-name="Wait">
               <h3>
                  Wait 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Wait for the I/O operation to complete.</p>
               
               <pre><code>func (aio *asyncIO) Wait() (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WaitWrite">
               <h3>
                  WaitWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WaitWrite waits until data can be written to fd.</p>
               
               <pre><code>func (fd *FD) WaitWrite() error</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write implements io.Writer.</p>
               
               <pre><code>func (fd *FD) Write(fn func([]byte) (int, error), b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write implements io.Writer.</p>
               
               <pre><code>func (fd *FD) Write(buf []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write implements io.Writer.</p>
               
               <pre><code>func (fd *FD) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteLock">
               <h3>
                  WriteLock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fdmu *FDMutex) WriteLock() bool</code></pre>
            </article>
            
            <article class="function" data-name="WriteMsg">
               <h3>
                  WriteMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteMsg wraps the WSASendMsg network call.</p>
               
               <pre><code>func (fd *FD) WriteMsg(p []byte, oob []byte, sa syscall.Sockaddr) (int, int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteMsg">
               <h3>
                  WriteMsg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteMsg wraps the sendmsg network call.</p>
               
               <pre><code>func (fd *FD) WriteMsg(p []byte, oob []byte, sa syscall.Sockaddr) (int, int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteMsgInet4">
               <h3>
                  WriteMsgInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteMsgInet4 is WriteMsg specialized for syscall.SockaddrInet4.</p>
               
               <pre><code>func (fd *FD) WriteMsgInet4(p []byte, oob []byte, sa *syscall.SockaddrInet4) (int, int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteMsgInet4">
               <h3>
                  WriteMsgInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteMsgInet4 is WriteMsg specialized for syscall.SockaddrInet4.</p>
               
               <pre><code>func (fd *FD) WriteMsgInet4(p []byte, oob []byte, sa *syscall.SockaddrInet4) (int, int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteMsgInet6">
               <h3>
                  WriteMsgInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteMsgInet6 is WriteMsg specialized for syscall.SockaddrInet6.</p>
               
               <pre><code>func (fd *FD) WriteMsgInet6(p []byte, oob []byte, sa *syscall.SockaddrInet6) (int, int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteMsgInet6">
               <h3>
                  WriteMsgInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteMsgInet6 is WriteMsg specialized for syscall.SockaddrInet6.</p>
               
               <pre><code>func (fd *FD) WriteMsgInet6(p []byte, oob []byte, sa *syscall.SockaddrInet6) (int, int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteOnce">
               <h3>
                  WriteOnce 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteOnce is for testing only. It makes a single write call.</p>
               
               <pre><code>func (fd *FD) WriteOnce(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteTo wraps the sendto network call.</p>
               
               <pre><code>func (fd *FD) WriteTo(p []byte, sa syscall.Sockaddr) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteTo wraps the sendto network call.</p>
               
               <pre><code>func (fd *FD) WriteTo(buf []byte, sa syscall.Sockaddr) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteToInet4">
               <h3>
                  WriteToInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteToInet4 wraps the sendto network call for IPv4 addresses.</p>
               
               <pre><code>func (fd *FD) WriteToInet4(p []byte, sa *syscall.SockaddrInet4) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteToInet4">
               <h3>
                  WriteToInet4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteToInet4 is WriteTo, specialized for syscall.SockaddrInet4.</p>
               
               <pre><code>func (fd *FD) WriteToInet4(buf []byte, sa4 *syscall.SockaddrInet4) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteToInet6">
               <h3>
                  WriteToInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteToInet6 wraps the sendto network call for IPv6 addresses.</p>
               
               <pre><code>func (fd *FD) WriteToInet6(p []byte, sa *syscall.SockaddrInet6) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteToInet6">
               <h3>
                  WriteToInet6 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteToInet6 is WriteTo, specialized for syscall.SockaddrInet6.</p>
               
               <pre><code>func (fd *FD) WriteToInet6(buf []byte, sa6 *syscall.SockaddrInet6) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteUnlock">
               <h3>
                  WriteUnlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fdmu *FDMutex) WriteUnlock() bool</code></pre>
            </article>
            
            <article class="function" data-name="Writev">
               <h3>
                  Writev 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Writev emulates the Unix writev system call.</p>
               
               <pre><code>func (fd *FD) Writev(buf *[][]byte) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="Writev">
               <h3>
                  Writev 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Writev wraps the writev system call.</p>
               
               <pre><code>func (fd *FD) Writev(v *[][]byte) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="accept">
               <h3>
                  accept 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Wrapper around the accept system call that marks the returned file
descriptor as nonblocking and close-on-exec.</p>
               
               <pre><code>func accept(s int) (int, syscall.Sockaddr, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="accept">
               <h3>
                  accept 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Wrapper around the accept system call that marks the returned file
descriptor as nonblocking and close-on-exec.</p>
               
               <pre><code>func accept(s int) (int, syscall.Sockaddr, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="accept">
               <h3>
                  accept 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Wrapper around the accept system call that marks the returned file
descriptor as nonblocking and close-on-exec.</p>
               
               <pre><code>func accept(s int) (int, syscall.Sockaddr, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="acceptOne">
               <h3>
                  acceptOne 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *FD) acceptOne(s syscall.Handle, rawsa []syscall.RawSockaddrAny, o *operation) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="checkSetFileCompletionNotificationModes">
               <h3>
                  checkSetFileCompletionNotificationModes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkSetFileCompletionNotificationModes verifies that
SetFileCompletionNotificationModes Windows API is present
on the system and is safe to use.
See https://support.microsoft.com/kb/2568167 for details.</p>
               
               <pre><code>func checkSetFileCompletionNotificationModes()</code></pre>
            </article>
            
            <article class="function" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) close()</code></pre>
            </article>
            
            <article class="function" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) close()</code></pre>
            </article>
            
            <article class="function" data-name="consume">
               <h3>
                  consume 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>consume removes data from a slice of byte slices, for writev.</p>
               
               <pre><code>func consume(v *[][]byte, n int64)</code></pre>
            </article>
            
            <article class="function" data-name="convertErr">
               <h3>
                  convertErr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func convertErr(res int, isFile bool) error</code></pre>
            </article>
            
            <article class="function" data-name="copyFileRange">
               <h3>
                  copyFileRange 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>copyFileRange performs one round of copy_file_range(2).</p>
               
               <pre><code>func copyFileRange(dst *FD, src *FD, max int) (written int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="decref">
               <h3>
                  decref 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>decref removes a reference from fd.
It also closes fd when the state of fd is set to closed and there
is no remaining reference.</p>
               
               <pre><code>func (fd *FD) decref() error</code></pre>
            </article>
            
            <article class="function" data-name="decref">
               <h3>
                  decref 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>decref removes a reference from mu.
It reports whether there is no remaining reference.</p>
               
               <pre><code>func (mu *fdMutex) decref() bool</code></pre>
            </article>
            
            <article class="function" data-name="destroy">
               <h3>
                  destroy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *SysFile) destroy(fd int) error</code></pre>
            </article>
            
            <article class="function" data-name="destroy">
               <h3>
                  destroy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>We need this to close out a file descriptor when it is unlocked,
but the real implementation has to live in the net package because
it uses os.File's.</p>
               
               <pre><code>func (fd *FD) destroy() error</code></pre>
            </article>
            
            <article class="function" data-name="destroy">
               <h3>
                  destroy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *SysFile) destroy(fd int) error</code></pre>
            </article>
            
            <article class="function" data-name="destroy">
               <h3>
                  destroy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fd *FD) destroy() error</code></pre>
            </article>
            
            <article class="function" data-name="destroy">
               <h3>
                  destroy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Destroy closes the file descriptor. This is called when there are
no remaining references.</p>
               
               <pre><code>func (fd *FD) destroy() error</code></pre>
            </article>
            
            <article class="function" data-name="destroyPipe">
               <h3>
                  destroyPipe 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>destroyPipe destroys a pipe.</p>
               
               <pre><code>func destroyPipe(p *splicePipe)</code></pre>
            </article>
            
            <article class="function" data-name="direntNamlen">
               <h3>
                  direntNamlen 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function" data-name="direntNext">
               <h3>
                  direntNext 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func direntNext(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function" data-name="direntReclen">
               <h3>
                  direntReclen 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function" data-name="dupCloseOnExecOld">
               <h3>
                  dupCloseOnExecOld 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dupCloseOnExecOld is the traditional way to dup an fd and
set its O_CLOEXEC bit, using two system calls.</p>
               
               <pre><code>func dupCloseOnExecOld(fd int) (int, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="dupCloseOnExecOld">
               <h3>
                  dupCloseOnExecOld 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dupCloseOnExecOld always errors on wasip1 because there is no mechanism to
duplicate file descriptors.</p>
               
               <pre><code>func dupCloseOnExecOld(fd int) (int, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="eofError">
               <h3>
                  eofError 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>eofError returns io.EOF when fd is available for reading end of
file.</p>
               
               <pre><code>func (fd *FD) eofError(n int, err error) error</code></pre>
            </article>
            
            <article class="function" data-name="errClosing">
               <h3>
                  errClosing 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Return the appropriate closing error based on isFile.</p>
               
               <pre><code>func errClosing(isFile bool) error</code></pre>
            </article>
            
            <article class="function" data-name="errnoErr">
               <h3>
                  errnoErr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>errnoErr returns common boxed Errno values, to prevent
allocations at runtime.</p>
               
               <pre><code>func errnoErr(e syscall.Errno) error</code></pre>
            </article>
            
            <article class="function" data-name="errnoErr">
               <h3>
                  errnoErr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>errnoErr returns common boxed Errno values, to prevent
allocations at runtime.</p>
               
               <pre><code>func errnoErr(e syscall.Errno) error</code></pre>
            </article>
            
            <article class="function" data-name="evict">
               <h3>
                  evict 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Evict evicts fd from the pending list, unblocking any I/O running on fd.</p>
               
               <pre><code>func (pd *pollDesc) evict()</code></pre>
            </article>
            
            <article class="function" data-name="evict">
               <h3>
                  evict 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) evict()</code></pre>
            </article>
            
            <article class="function" data-name="execIO">
               <h3>
                  execIO 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>execIO executes a single IO operation o. It submits and cancels
IO in the current thread for systems where Windows CancelIoEx API
is available. Alternatively, it passes the request onto
runtime netpoll and waits for completion or cancels request.</p>
               
               <pre><code>func execIO(o *operation, submit func(o *operation) error) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="fdopendir">
               <h3>
                  fdopendir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Implemented in syscall/syscall_darwin.go.
go:linkname fdopendir syscall.fdopendir</p>
               
               <pre><code>func fdopendir(fd int) (dir uintptr, err error)</code></pre>
            </article>
            
            <article class="function" data-name="getPipe">
               <h3>
                  getPipe 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>getPipe tries to acquire a pipe buffer from the pool or create a new one with newPipe() if it gets nil from the cache.</p>
               
               <pre><code>func getPipe() (*splicePipe, error)</code></pre>
            </article>
            
            <article class="function" data-name="handleCopyFileRangeErr">
               <h3>
                  handleCopyFileRangeErr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func handleCopyFileRangeErr(err error, copied int64, written int64) (bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="handleCopyFileRangeErr">
               <h3>
                  handleCopyFileRangeErr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func handleCopyFileRangeErr(err error, copied int64, written int64) (bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="ignoringEINTR">
               <h3>
                  ignoringEINTR 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ignoringEINTR makes a function call and repeats it if it returns
an EINTR error. This appears to be required even though we install all
signal handlers with SA_RESTART: see #22838, #38033, #38836, #40846.
Also #20400 and #36644 are issues in which a signal handler is
installed without setting SA_RESTART. None of these are the common case,
but there are enough of them that it seems that we can't avoid
an EINTR loop.</p>
               
               <pre><code>func ignoringEINTR(fn func() error) error</code></pre>
            </article>
            
            <article class="function" data-name="ignoringEINTR2">
               <h3>
                  ignoringEINTR2 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ignoringEINTR2 is ignoringEINTR, but returning an additional value.</p>
               
               <pre><code>func ignoringEINTR2(fn func() (T, error)) (T, error)</code></pre>
            </article>
            
            <article class="function" data-name="ignoringEINTRIO">
               <h3>
                  ignoringEINTRIO 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ignoringEINTRIO is like ignoringEINTR, but just for IO calls.</p>
               
               <pre><code>func ignoringEINTRIO(fn func(fd int, p []byte) (int, error), fd int, p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="incref">
               <h3>
                  incref 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>incref adds a reference to fd.
It returns an error when fd cannot be used.</p>
               
               <pre><code>func (fd *FD) incref() error</code></pre>
            </article>
            
            <article class="function" data-name="incref">
               <h3>
                  incref 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>incref adds a reference to mu.
It reports whether mu is available for reading or writing.</p>
               
               <pre><code>func (mu *fdMutex) incref() bool</code></pre>
            </article>
            
            <article class="function" data-name="increfAndClose">
               <h3>
                  increfAndClose 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>increfAndClose sets the state of mu to closed.
It returns false if the file was already closed.</p>
               
               <pre><code>func (mu *fdMutex) increfAndClose() bool</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) init(fd *FD) error</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) init(fd *FD) error</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *SysFile) init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *SysFile) init()</code></pre>
            </article>
            
            <article class="function" data-name="isHangup">
               <h3>
                  isHangup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isHangup(err error) bool</code></pre>
            </article>
            
            <article class="function" data-name="isInterrupted">
               <h3>
                  isInterrupted 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isInterrupted(err error) bool</code></pre>
            </article>
            
            <article class="function" data-name="newAsyncIO">
               <h3>
                  newAsyncIO 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newAsyncIO returns a new asyncIO that performs an I/O
operation by calling fn, which must do one and only one
interruptible system call.</p>
               
               <pre><code>func newAsyncIO(fn func([]byte) (int, error), b []byte) *asyncIO</code></pre>
            </article>
            
            <article class="function" data-name="newIovecWithBase">
               <h3>
                  newIovecWithBase 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newIovecWithBase(base *byte) syscall.Iovec</code></pre>
            </article>
            
            <article class="function" data-name="newIovecWithBase">
               <h3>
                  newIovecWithBase 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newIovecWithBase(base *byte) syscall.Iovec</code></pre>
            </article>
            
            <article class="function" data-name="newPipe">
               <h3>
                  newPipe 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newPipe sets up a pipe for a splice operation.</p>
               
               <pre><code>func newPipe() *splicePipe</code></pre>
            </article>
            
            <article class="function" data-name="newPoolPipe">
               <h3>
                  newPoolPipe 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newPoolPipe() any</code></pre>
            </article>
            
            <article class="function" data-name="pollable">
               <h3>
                  pollable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) pollable() bool</code></pre>
            </article>
            
            <article class="function" data-name="pollable">
               <h3>
                  pollable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) pollable() bool</code></pre>
            </article>
            
            <article class="function" data-name="prepare">
               <h3>
                  prepare 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) prepare(mode int, isFile bool) error</code></pre>
            </article>
            
            <article class="function" data-name="prepare">
               <h3>
                  prepare 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) prepare(mode int, isFile bool) error</code></pre>
            </article>
            
            <article class="function" data-name="prepareRead">
               <h3>
                  prepareRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) prepareRead(isFile bool) error</code></pre>
            </article>
            
            <article class="function" data-name="prepareRead">
               <h3>
                  prepareRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) prepareRead(isFile bool) error</code></pre>
            </article>
            
            <article class="function" data-name="prepareWrite">
               <h3>
                  prepareWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) prepareWrite(isFile bool) error</code></pre>
            </article>
            
            <article class="function" data-name="prepareWrite">
               <h3>
                  prepareWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) prepareWrite(isFile bool) error</code></pre>
            </article>
            
            <article class="function" data-name="putPipe">
               <h3>
                  putPipe 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func putPipe(p *splicePipe)</code></pre>
            </article>
            
            <article class="function" data-name="rawToSockaddrInet4">
               <h3>
                  rawToSockaddrInet4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func rawToSockaddrInet4(rsa *syscall.RawSockaddrAny, sa *syscall.SockaddrInet4)</code></pre>
            </article>
            
            <article class="function" data-name="rawToSockaddrInet6">
               <h3>
                  rawToSockaddrInet6 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func rawToSockaddrInet6(rsa *syscall.RawSockaddrAny, sa *syscall.SockaddrInet6)</code></pre>
            </article>
            
            <article class="function" data-name="readConsole">
               <h3>
                  readConsole 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>readConsole reads utf16 characters from console File,
encodes them into utf8 and stores them in buffer b.
It returns the number of utf8 bytes read and an error, if any.</p>
               
               <pre><code>func (fd *FD) readConsole(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="readInt">
               <h3>
                  readInt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readInt returns the size-bytes unsigned integer in native byte order at offset off.</p>
               
               <pre><code>func readInt(b []byte, off uintptr, size uintptr) (u uint64, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="readIntLE">
               <h3>
                  readIntLE 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func readIntLE(b []byte, size uintptr) uint64</code></pre>
            </article>
            
            <article class="function" data-name="readLock">
               <h3>
                  readLock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>readLock adds a reference to fd and locks fd for reading.
It returns an error when fd cannot be used for reading.</p>
               
               <pre><code>func (fd *FD) readLock() error</code></pre>
            </article>
            
            <article class="function" data-name="readUnlock">
               <h3>
                  readUnlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>readUnlock removes a reference from fd and unlocks fd for reading.
It also closes fd when the state of fd is set to closed and there
is no remaining reference.</p>
               
               <pre><code>func (fd *FD) readUnlock()</code></pre>
            </article>
            
            <article class="function" data-name="ref">
               <h3>
                  ref 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *SysFile) ref() SysFile</code></pre>
            </article>
            
            <article class="function" data-name="runtimeNano">
               <h3>
                  runtimeNano 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>runtimeNano returns the current value of the runtime clock in nanoseconds.
go:linkname runtimeNano runtime.nanotime</p>
               
               <pre><code>func runtimeNano() int64</code></pre>
            </article>
            
            <article class="function" data-name="runtime_Semacquire">
               <h3>
                  runtime_Semacquire 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Implemented in runtime package.</p>
               
               <pre><code>func runtime_Semacquire(sema *uint32)</code></pre>
            </article>
            
            <article class="function" data-name="runtime_Semrelease">
               <h3>
                  runtime_Semrelease 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runtime_Semrelease(sema *uint32)</code></pre>
            </article>
            
            <article class="function" data-name="runtime_ignoreHangup">
               <h3>
                  runtime_ignoreHangup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>The following functions, provided by the runtime, are used to
ignore and unignore the "hangup" signal received by the process.</p>
               
               <pre><code>func runtime_ignoreHangup()</code></pre>
            </article>
            
            <article class="function" data-name="runtime_isPollServerDescriptor">
               <h3>
                  runtime_isPollServerDescriptor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runtime_isPollServerDescriptor(fd uintptr) bool</code></pre>
            </article>
            
            <article class="function" data-name="runtime_pollClose">
               <h3>
                  runtime_pollClose 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runtime_pollClose(ctx uintptr)</code></pre>
            </article>
            
            <article class="function" data-name="runtime_pollOpen">
               <h3>
                  runtime_pollOpen 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runtime_pollOpen(fd uintptr) (uintptr, int)</code></pre>
            </article>
            
            <article class="function" data-name="runtime_pollReset">
               <h3>
                  runtime_pollReset 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runtime_pollReset(ctx uintptr, mode int) int</code></pre>
            </article>
            
            <article class="function" data-name="runtime_pollServerInit">
               <h3>
                  runtime_pollServerInit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runtime_pollServerInit()</code></pre>
            </article>
            
            <article class="function" data-name="runtime_pollSetDeadline">
               <h3>
                  runtime_pollSetDeadline 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runtime_pollSetDeadline(ctx uintptr, d int64, mode int)</code></pre>
            </article>
            
            <article class="function" data-name="runtime_pollUnblock">
               <h3>
                  runtime_pollUnblock 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runtime_pollUnblock(ctx uintptr)</code></pre>
            </article>
            
            <article class="function" data-name="runtime_pollWait">
               <h3>
                  runtime_pollWait 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runtime_pollWait(ctx uintptr, mode int) int</code></pre>
            </article>
            
            <article class="function" data-name="runtime_pollWaitCanceled">
               <h3>
                  runtime_pollWaitCanceled 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runtime_pollWaitCanceled(ctx uintptr, mode int)</code></pre>
            </article>
            
            <article class="function" data-name="runtime_unignoreHangup">
               <h3>
                  runtime_unignoreHangup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runtime_unignoreHangup()</code></pre>
            </article>
            
            <article class="function" data-name="rwlock">
               <h3>
                  rwlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lock adds a reference to mu and locks mu.
It reports whether mu is available for reading or writing.</p>
               
               <pre><code>func (mu *fdMutex) rwlock(read bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="rwunlock">
               <h3>
                  rwunlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>unlock removes a reference from mu and unlocks mu.
It reports whether there is no remaining reference.</p>
               
               <pre><code>func (mu *fdMutex) rwunlock(read bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="sendFile">
               <h3>
                  sendFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>sendFile wraps the sendfile system call.</p>
               
               <pre><code>func sendFile(dstFD *FD, src int, offset *int64, size int64) (written int64, err error, handled bool)</code></pre>
            </article>
            
            <article class="function" data-name="sendFileChunk">
               <h3>
                  sendFileChunk 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sendFileChunk(dst int, src int, offset *int64, size int, written int64) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="setDeadlineImpl">
               <h3>
                  setDeadlineImpl 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDeadlineImpl(fd *FD, t time.Time, mode int) error</code></pre>
            </article>
            
            <article class="function" data-name="setDeadlineImpl">
               <h3>
                  setDeadlineImpl 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDeadlineImpl(fd *FD, t time.Time, mode int) error</code></pre>
            </article>
            
            <article class="function" data-name="setDeadlineImpl">
               <h3>
                  setDeadlineImpl 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setDeadlineImpl(fd *FD, t time.Time, mode int) error</code></pre>
            </article>
            
            <article class="function" data-name="sockaddrInet4ToRaw">
               <h3>
                  sockaddrInet4ToRaw 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sockaddrInet4ToRaw(rsa *syscall.RawSockaddrAny, sa *syscall.SockaddrInet4) int32</code></pre>
            </article>
            
            <article class="function" data-name="sockaddrInet6ToRaw">
               <h3>
                  sockaddrInet6ToRaw 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sockaddrInet6ToRaw(rsa *syscall.RawSockaddrAny, sa *syscall.SockaddrInet6) int32</code></pre>
            </article>
            
            <article class="function" data-name="sockaddrToRaw">
               <h3>
                  sockaddrToRaw 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sockaddrToRaw(rsa *syscall.RawSockaddrAny, sa syscall.Sockaddr) (int32, error)</code></pre>
            </article>
            
            <article class="function" data-name="splice">
               <h3>
                  splice 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>splice wraps the splice system call. Since the current implementation
only uses splice on sockets and pipes, the offset arguments are unused.
splice returns int instead of int64, because callers never ask it to
move more data in a single call than can fit in an int32.</p>
               
               <pre><code>func splice(out int, in int, max int, flags int) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="spliceDrain">
               <h3>
                  spliceDrain 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>spliceDrain moves data from a socket to a pipe.
Invariant: when entering spliceDrain, the pipe is empty. It is either in its
initial state, or splicePump has emptied it previously.
Given this, spliceDrain can reasonably assume that the pipe is ready for
writing, so if splice returns EAGAIN, it must be because the socket is not
ready for reading.
If spliceDrain returns (0, nil), src is at EOF.</p>
               
               <pre><code>func spliceDrain(pipefd int, sock *FD, max int) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="splicePump">
               <h3>
                  splicePump 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>splicePump moves all the buffered data from a pipe to a socket.
Invariant: when entering splicePump, there are exactly inPipe
bytes of data in the pipe, from a previous call to spliceDrain.
By analogy to the condition from spliceDrain, splicePump
only needs to poll the socket for readiness, if splice returns
EAGAIN.
If splicePump cannot move all the data in a single call to
splice(2), it loops over the buffered data until it has written
all of it to the socket. This behavior is similar to the Write
step of an io.Copy in userspace.</p>
               
               <pre><code>func splicePump(sock *FD, pipefd int, inPipe int) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="supportCopyFileRange">
               <h3>
                  supportCopyFileRange 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func supportCopyFileRange() bool</code></pre>
            </article>
            
            <article class="function" data-name="supportCopyFileRange">
               <h3>
                  supportCopyFileRange 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func supportCopyFileRange() bool</code></pre>
            </article>
            
            <article class="function" data-name="wait">
               <h3>
                  wait 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) wait(mode int, isFile bool) error</code></pre>
            </article>
            
            <article class="function" data-name="wait">
               <h3>
                  wait 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) wait(mode int, isFile bool) error</code></pre>
            </article>
            
            <article class="function" data-name="waitCanceled">
               <h3>
                  waitCanceled 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) waitCanceled(mode int)</code></pre>
            </article>
            
            <article class="function" data-name="waitCanceled">
               <h3>
                  waitCanceled 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) waitCanceled(mode int)</code></pre>
            </article>
            
            <article class="function" data-name="waitRead">
               <h3>
                  waitRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) waitRead(isFile bool) error</code></pre>
            </article>
            
            <article class="function" data-name="waitRead">
               <h3>
                  waitRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) waitRead(isFile bool) error</code></pre>
            </article>
            
            <article class="function" data-name="waitWrite">
               <h3>
                  waitWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) waitWrite(isFile bool) error</code></pre>
            </article>
            
            <article class="function" data-name="waitWrite">
               <h3>
                  waitWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pd *pollDesc) waitWrite(isFile bool) error</code></pre>
            </article>
            
            <article class="function" data-name="writeConsole">
               <h3>
                  writeConsole 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeConsole writes len(b) bytes to the console File.
It returns the number of bytes written and an error, if any.</p>
               
               <pre><code>func (fd *FD) writeConsole(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="writeLock">
               <h3>
                  writeLock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeLock adds a reference to fd and locks fd for writing.
It returns an error when fd cannot be used for writing.</p>
               
               <pre><code>func (fd *FD) writeLock() error</code></pre>
            </article>
            
            <article class="function" data-name="writeUnlock">
               <h3>
                  writeUnlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeUnlock removes a reference from fd and unlocks fd for writing.
It also closes fd when the state of fd is set to closed and there
is no remaining reference.</p>
               
               <pre><code>func (fd *FD) writeUnlock()</code></pre>
            </article>
            
            <article class="function" data-name="writev">
               <h3>
                  writev 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func writev(fd int, iovecs []syscall.Iovec) (uintptr, error)</code></pre>
            </article>
            
            <article class="function" data-name="writev">
               <h3>
                  writev 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname writev syscall.writev</p>
               
               <pre><code>func writev(fd int, iovecs []syscall.Iovec) (uintptr, error)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
