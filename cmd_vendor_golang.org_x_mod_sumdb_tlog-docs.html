<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - tlog</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>tlog</code>
         </h1>
         <hr />
         
         <article class="global" data-name="HashSize">
            <h2>HashSize</h2>
            <hr />
            
            <p>HashSize is the size of a Hash in bytes.</p>
            
            <pre><code>HashSize</code></pre>
         </article>
         
         <article class="global" data-name="zeroPrefix">
            <h2>zeroPrefix</h2>
            <hr />
            
            <pre><code>zeroPrefix</code></pre>
         </article>
         
         <article class="global" data-name="emptyHash">
            <h2>emptyHash</h2>
            <hr />
            
            <p>emptyHash is the hash of the empty tree, per RFC 6962, Section 2.1.
It is the hash of the empty string.</p>
            
            <pre><code>emptyHash</code></pre>
         </article>
         
         <article class="global" data-name="errProofFailed">
            <h2>errProofFailed</h2>
            <hr />
            
            <pre><code>errProofFailed</code></pre>
         </article>
         
         <article class="global" data-name="errMalformedTree">
            <h2>errMalformedTree</h2>
            <hr />
            
            <pre><code>errMalformedTree</code></pre>
         </article>
         
         <article class="global" data-name="treePrefix">
            <h2>treePrefix</h2>
            <hr />
            
            <pre><code>treePrefix</code></pre>
         </article>
         
         <article class="global" data-name="errMalformedRecord">
            <h2>errMalformedRecord</h2>
            <hr />
            
            <pre><code>errMalformedRecord</code></pre>
         </article>
         
         <article class="global" data-name="pathBase">
            <h2>pathBase</h2>
            <hr />
            
            <p>To limit the size of any particular directory listing,
we encode the (possibly very large) number N
by encoding three digits at a time.
For example, 123456789 encodes as x123/x456/789.
Each directory has at most 1000 each xNNN, NNN, and NNN.p children,
so there are at most 3000 entries in any one directory.</p>
            
            <pre><code>pathBase</code></pre>
         </article>
          
         <article class="struct" data-name="Tree">
            <h2>type Tree struct</h2>
            <hr />
            
            <p>A Tree is a tree description, to be signed by a go.sum database server.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">N int64
Hash Hash</code></pre>
         </article>
         
         <article class="struct" data-name="Tile">
            <h2>type Tile struct</h2>
            <hr />
            
            <p>A Tile is a description of a transparency log tile.
A tile of height H at level L offset N lists W consecutive hashes
at level H*L of the tree starting at offset N*(2**H).
A complete tile lists 2**H hashes; a partial tile lists fewer.
Note that a tile represents the entire subtree of height H
with those hashes as the leaves. The levels above H*L
can be reconstructed by hashing the leaves.

Each Tile can be encoded as a “tile coordinate path”
of the form tile/H/L/NNN[.p/W].
The .p/W suffix is present only for partial tiles, meaning W < 2**H.
The NNN element is an encoding of N into 3-digit path elements.
All but the last path element begins with an "x".
For example,
Tile{H: 3, L: 4, N: 1234067, W: 1}'s path
is tile/3/4/x001/x234/067.p/1, and
Tile{H: 3, L: 4, N: 1234067, W: 8}'s path
is tile/3/4/x001/x234/067.
See the [Tile.Path] method and the [ParseTilePath] function.

The special level L=-1 holds raw record data instead of hashes.
In this case, the level encodes into a tile path as the path element
"data" instead of "-1".

See also https://golang.org/design/25530-sumdb#checksum-database
and https://research.swtch.com/tlog#tiling_a_log.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">H int
L int
N int64
W int</code></pre>
         </article>
         
         <article class="struct" data-name="badPathError">
            <h2>type badPathError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string</code></pre>
         </article>
         
         <article class="struct" data-name="tileHashReader">
            <h2>type tileHashReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">tree Tree
tr TileReader</code></pre>
         </article>
          
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns a base64 representation of the hash for printing.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="MarshalJSON">
            <h2>MarshalJSON</h2>
            <hr />
            
            <p>MarshalJSON marshals the hash as a JSON string containing the base64-encoded hash.</p>
            
            <pre><code>func MarshalJSON() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="UnmarshalJSON">
            <h2>UnmarshalJSON</h2>
            <hr />
            
            <p>UnmarshalJSON unmarshals a hash from JSON string containing the a base64-encoded hash.</p>
            
            <pre><code>func UnmarshalJSON(data []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="ParseHash">
            <h2>ParseHash</h2>
            <hr />
            
            <p>ParseHash parses the base64-encoded string form of a hash.</p>
            
            <pre><code>func ParseHash(s string) (Hash, error)</code></pre>
         </article>
         
         <article class="function" data-name="maxpow2">
            <h2>maxpow2</h2>
            <hr />
            
            <p>maxpow2 returns k, the maximum power of 2 smaller than n,
as well as l = log₂ k (so k = 1<<l).</p>
            
            <pre><code>func maxpow2(n int64) (k int64, l int)</code></pre>
         </article>
         
         <article class="function" data-name="RecordHash">
            <h2>RecordHash</h2>
            <hr />
            
            <p>RecordHash returns the content hash for the given record data.</p>
            
            <pre><code>func RecordHash(data []byte) Hash</code></pre>
         </article>
         
         <article class="function" data-name="NodeHash">
            <h2>NodeHash</h2>
            <hr />
            
            <p>NodeHash returns the hash for an interior tree node with the given left and right hashes.</p>
            
            <pre><code>func NodeHash(left Hash, right Hash) Hash</code></pre>
         </article>
         
         <article class="function" data-name="StoredHashIndex">
            <h2>StoredHashIndex</h2>
            <hr />
            
            <p>StoredHashIndex maps the tree coordinates (level, n)
to a dense linear ordering that can be used for hash storage.
Hash storage implementations that store hashes in sequential
storage can use this function to compute where to read or write
a given hash.</p>
            
            <pre><code>func StoredHashIndex(level int, n int64) int64</code></pre>
         </article>
         
         <article class="function" data-name="SplitStoredHashIndex">
            <h2>SplitStoredHashIndex</h2>
            <hr />
            
            <p>SplitStoredHashIndex is the inverse of [StoredHashIndex].
That is, SplitStoredHashIndex(StoredHashIndex(level, n)) == level, n.</p>
            
            <pre><code>func SplitStoredHashIndex(index int64) (level int, n int64)</code></pre>
         </article>
         
         <article class="function" data-name="StoredHashCount">
            <h2>StoredHashCount</h2>
            <hr />
            
            <p>StoredHashCount returns the number of stored hashes
that are expected for a tree with n records.</p>
            
            <pre><code>func StoredHashCount(n int64) int64</code></pre>
         </article>
         
         <article class="function" data-name="StoredHashes">
            <h2>StoredHashes</h2>
            <hr />
            
            <p>StoredHashes returns the hashes that must be stored when writing
record n with the given data. The hashes should be stored starting
at StoredHashIndex(0, n). The result will have at most 1 + log₂ n hashes,
but it will average just under two per call for a sequence of calls for n=1..k.

StoredHashes may read up to log n earlier hashes from r
in order to compute hashes for completed subtrees.</p>
            
            <pre><code>func StoredHashes(n int64, data []byte, r HashReader) ([]Hash, error)</code></pre>
         </article>
         
         <article class="function" data-name="StoredHashesForRecordHash">
            <h2>StoredHashesForRecordHash</h2>
            <hr />
            
            <p>StoredHashesForRecordHash is like [StoredHashes] but takes
as its second argument RecordHash(data) instead of data itself.</p>
            
            <pre><code>func StoredHashesForRecordHash(n int64, h Hash, r HashReader) ([]Hash, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadHashes">
            <h2>ReadHashes</h2>
            <hr />
            
            <pre><code>func ReadHashes(indexes []int64) ([]Hash, error)</code></pre>
         </article>
         
         <article class="function" data-name="TreeHash">
            <h2>TreeHash</h2>
            <hr />
            
            <p>TreeHash computes the hash for the root of the tree with n records,
using the HashReader to obtain previously stored hashes
(those returned by StoredHashes during the writes of those n records).
TreeHash makes a single call to ReadHash requesting at most 1 + log₂ n hashes.</p>
            
            <pre><code>func TreeHash(n int64, r HashReader) (Hash, error)</code></pre>
         </article>
         
         <article class="function" data-name="subTreeIndex">
            <h2>subTreeIndex</h2>
            <hr />
            
            <p>subTreeIndex returns the storage indexes needed to compute
the hash for the subtree containing records [lo, hi),
appending them to need and returning the result.
See https://tools.ietf.org/html/rfc6962#section-2.1</p>
            
            <pre><code>func subTreeIndex(lo int64, hi int64, need []int64) []int64</code></pre>
         </article>
         
         <article class="function" data-name="subTreeHash">
            <h2>subTreeHash</h2>
            <hr />
            
            <p>subTreeHash computes the hash for the subtree containing records [lo, hi),
assuming that hashes are the hashes corresponding to the indexes
returned by subTreeIndex(lo, hi).
It returns any leftover hashes.</p>
            
            <pre><code>func subTreeHash(lo int64, hi int64, hashes []Hash) (Hash, []Hash)</code></pre>
         </article>
         
         <article class="function" data-name="ProveRecord">
            <h2>ProveRecord</h2>
            <hr />
            
            <p>ProveRecord returns the proof that the tree of size t contains the record with index n.</p>
            
            <pre><code>func ProveRecord(t int64, n int64, r HashReader) (RecordProof, error)</code></pre>
         </article>
         
         <article class="function" data-name="leafProofIndex">
            <h2>leafProofIndex</h2>
            <hr />
            
            <p>leafProofIndex builds the list of indexes needed to construct the proof
that leaf n is contained in the subtree with leaves [lo, hi).
It appends those indexes to need and returns the result.
See https://tools.ietf.org/html/rfc6962#section-2.1.1</p>
            
            <pre><code>func leafProofIndex(lo int64, hi int64, n int64, need []int64) []int64</code></pre>
         </article>
         
         <article class="function" data-name="leafProof">
            <h2>leafProof</h2>
            <hr />
            
            <p>leafProof constructs the proof that leaf n is contained in the subtree with leaves [lo, hi).
It returns any leftover hashes as well.
See https://tools.ietf.org/html/rfc6962#section-2.1.1</p>
            
            <pre><code>func leafProof(lo int64, hi int64, n int64, hashes []Hash) (RecordProof, []Hash)</code></pre>
         </article>
         
         <article class="function" data-name="CheckRecord">
            <h2>CheckRecord</h2>
            <hr />
            
            <p>CheckRecord verifies that p is a valid proof that the tree of size t
with hash th has an n'th record with hash h.</p>
            
            <pre><code>func CheckRecord(p RecordProof, t int64, th Hash, n int64, h Hash) error</code></pre>
         </article>
         
         <article class="function" data-name="runRecordProof">
            <h2>runRecordProof</h2>
            <hr />
            
            <p>runRecordProof runs the proof p that leaf n is contained in the subtree with leaves [lo, hi).
Running the proof means constructing and returning the implied hash of that
subtree.</p>
            
            <pre><code>func runRecordProof(p RecordProof, lo int64, hi int64, n int64, leafHash Hash) (Hash, error)</code></pre>
         </article>
         
         <article class="function" data-name="ProveTree">
            <h2>ProveTree</h2>
            <hr />
            
            <p>ProveTree returns the proof that the tree of size t contains
as a prefix all the records from the tree of smaller size n.</p>
            
            <pre><code>func ProveTree(t int64, n int64, h HashReader) (TreeProof, error)</code></pre>
         </article>
         
         <article class="function" data-name="treeProofIndex">
            <h2>treeProofIndex</h2>
            <hr />
            
            <p>treeProofIndex builds the list of indexes needed to construct
the sub-proof related to the subtree containing records [lo, hi).
See https://tools.ietf.org/html/rfc6962#section-2.1.2.</p>
            
            <pre><code>func treeProofIndex(lo int64, hi int64, n int64, need []int64) []int64</code></pre>
         </article>
         
         <article class="function" data-name="treeProof">
            <h2>treeProof</h2>
            <hr />
            
            <p>treeProof constructs the sub-proof related to the subtree containing records [lo, hi).
It returns any leftover hashes as well.
See https://tools.ietf.org/html/rfc6962#section-2.1.2.</p>
            
            <pre><code>func treeProof(lo int64, hi int64, n int64, hashes []Hash) (TreeProof, []Hash)</code></pre>
         </article>
         
         <article class="function" data-name="CheckTree">
            <h2>CheckTree</h2>
            <hr />
            
            <p>CheckTree verifies that p is a valid proof that the tree of size t with hash th
contains as a prefix the tree of size n with hash h.</p>
            
            <pre><code>func CheckTree(p TreeProof, t int64, th Hash, n int64, h Hash) error</code></pre>
         </article>
         
         <article class="function" data-name="runTreeProof">
            <h2>runTreeProof</h2>
            <hr />
            
            <p>runTreeProof runs the sub-proof p related to the subtree containing records [lo, hi),
where old is the hash of the old tree with n records.
Running the proof means constructing and returning the implied hashes of that
subtree in both the old and new tree.</p>
            
            <pre><code>func runTreeProof(p TreeProof, lo int64, hi int64, n int64, old Hash) (Hash, Hash, error)</code></pre>
         </article>
         
         <article class="function" data-name="FormatTree">
            <h2>FormatTree</h2>
            <hr />
            
            <p>FormatTree formats a tree description for inclusion in a note.

The encoded form is three lines, each ending in a newline (U+000A):

	go.sum database tree
	N
	Hash

where N is in decimal and Hash is in base64.

A future backwards-compatible encoding may add additional lines,
which the parser can ignore.
A future backwards-incompatible encoding would use a different
first line (for example, "go.sum database tree v2").</p>
            
            <pre><code>func FormatTree(tree Tree) []byte</code></pre>
         </article>
         
         <article class="function" data-name="ParseTree">
            <h2>ParseTree</h2>
            <hr />
            
            <p>ParseTree parses a formatted tree root description.</p>
            
            <pre><code>func ParseTree(text []byte) (tree Tree, err error)</code></pre>
         </article>
         
         <article class="function" data-name="FormatRecord">
            <h2>FormatRecord</h2>
            <hr />
            
            <p>FormatRecord formats a record for serving to a client
in a lookup response.

The encoded form is the record ID as a single number,
then the text of the record, and then a terminating blank line.
Record text must be valid UTF-8 and must not contain any ASCII control
characters (those below U+0020) other than newline (U+000A).
It must end in a terminating newline and not contain any blank lines.

Responses to data tiles consist of concatenated formatted records from each of
which the first line, with the record ID, is removed.</p>
            
            <pre><code>func FormatRecord(id int64, text []byte) (msg []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="isValidRecordText">
            <h2>isValidRecordText</h2>
            <hr />
            
            <p>isValidRecordText reports whether text is syntactically valid record text.</p>
            
            <pre><code>func isValidRecordText(text []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="ParseRecord">
            <h2>ParseRecord</h2>
            <hr />
            
            <p>ParseRecord parses a record description at the start of text,
stopping immediately after the terminating blank line.
It returns the record id, the record text, and the remainder of text.</p>
            
            <pre><code>func ParseRecord(msg []byte) (id int64, text []byte, rest []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TileForIndex">
            <h2>TileForIndex</h2>
            <hr />
            
            <p>TileForIndex returns the tile of fixed height h ≥ 1
and least width storing the given hash storage index.

If h ≤ 0, [TileForIndex] panics.</p>
            
            <pre><code>func TileForIndex(h int, index int64) Tile</code></pre>
         </article>
         
         <article class="function" data-name="tileForIndex">
            <h2>tileForIndex</h2>
            <hr />
            
            <p>tileForIndex returns the tile of height h ≥ 1
storing the given hash index, which can be
reconstructed using tileHash(data[start:end]).</p>
            
            <pre><code>func tileForIndex(h int, index int64) (t Tile, start int, end int)</code></pre>
         </article>
         
         <article class="function" data-name="HashFromTile">
            <h2>HashFromTile</h2>
            <hr />
            
            <p>HashFromTile returns the hash at the given storage index,
provided that t == TileForIndex(t.H, index) or a wider version,
and data is t's tile data (of length at least t.W*HashSize).</p>
            
            <pre><code>func HashFromTile(t Tile, data []byte, index int64) (Hash, error)</code></pre>
         </article>
         
         <article class="function" data-name="tileHash">
            <h2>tileHash</h2>
            <hr />
            
            <p>tileHash computes the subtree hash corresponding to the (2^K)-1 hashes in data.</p>
            
            <pre><code>func tileHash(data []byte) Hash</code></pre>
         </article>
         
         <article class="function" data-name="NewTiles">
            <h2>NewTiles</h2>
            <hr />
            
            <p>NewTiles returns the coordinates of the tiles of height h ≥ 1
that must be published when publishing from a tree of
size newTreeSize to replace a tree of size oldTreeSize.
(No tiles need to be published for a tree of size zero.)

If h ≤ 0, NewTiles panics.</p>
            
            <pre><code>func NewTiles(h int, oldTreeSize int64, newTreeSize int64) []Tile</code></pre>
         </article>
         
         <article class="function" data-name="ReadTileData">
            <h2>ReadTileData</h2>
            <hr />
            
            <p>ReadTileData reads the hashes for tile t from r
and returns the corresponding tile data.</p>
            
            <pre><code>func ReadTileData(t Tile, r HashReader) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="Path">
            <h2>Path</h2>
            <hr />
            
            <p>Path returns a tile coordinate path describing t.</p>
            
            <pre><code>func Path() string</code></pre>
         </article>
         
         <article class="function" data-name="ParseTilePath">
            <h2>ParseTilePath</h2>
            <hr />
            
            <p>ParseTilePath parses a tile coordinate path.</p>
            
            <pre><code>func ParseTilePath(path string) (Tile, error)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="TileHashReader">
            <h2>TileHashReader</h2>
            <hr />
            
            <p>TileHashReader returns a HashReader that satisfies requests
by loading tiles of the given tree.

The returned [HashReader] checks that loaded tiles are
valid for the given tree. Therefore, any hashes returned
by the HashReader are already proven to be in the tree.</p>
            
            <pre><code>func TileHashReader(tree Tree, tr TileReader) HashReader</code></pre>
         </article>
         
         <article class="function" data-name="tileParent">
            <h2>tileParent</h2>
            <hr />
            
            <p>tileParent returns t's k'th tile parent in the tiles for a tree of size n.
If there is no such parent, tileParent returns Tile{}.</p>
            
            <pre><code>func tileParent(t Tile, k int, n int64) Tile</code></pre>
         </article>
         
         <article class="function" data-name="ReadHashes">
            <h2>ReadHashes</h2>
            <hr />
            
            <pre><code>func ReadHashes(indexes []int64) ([]Hash, error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
