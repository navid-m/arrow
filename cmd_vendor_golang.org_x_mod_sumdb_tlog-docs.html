<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - tlog</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>tlog</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"bytes"
"encoding/base64"
"errors"
"fmt"
"strconv"
"strings"
"unicode/utf8"
"fmt"
"strconv"
"strings"
"crypto/sha256"
"encoding/base64"
"errors"
"fmt"
"math/bits"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="HashSize" data-name="HashSize">
               <h3>
                  HashSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#HashSize" class="anchor" title="Link to HashSize">#</a>
               </h3>
               
                  <p class="doc-comment">HashSize is the size of a Hash in bytes.</p>
               
               <pre><code class="language-go">const HashSize = 32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="emptyHash" data-name="emptyHash">
               <h3>
                  emptyHash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#emptyHash" class="anchor" title="Link to emptyHash">#</a>
               </h3>
               
                  <p class="doc-comment">emptyHash is the hash of the empty tree, per RFC 6962, Section 2.1.
It is the hash of the empty string.</p>
               
               <pre><code class="language-go">var emptyHash = Hash{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errMalformedRecord" data-name="errMalformedRecord">
               <h3>
                  errMalformedRecord 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errMalformedRecord" class="anchor" title="Link to errMalformedRecord">#</a>
               </h3>
               
               <pre><code class="language-go">var errMalformedRecord = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errMalformedTree" data-name="errMalformedTree">
               <h3>
                  errMalformedTree 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errMalformedTree" class="anchor" title="Link to errMalformedTree">#</a>
               </h3>
               
               <pre><code class="language-go">var errMalformedTree = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errProofFailed" data-name="errProofFailed">
               <h3>
                  errProofFailed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errProofFailed" class="anchor" title="Link to errProofFailed">#</a>
               </h3>
               
               <pre><code class="language-go">var errProofFailed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pathBase" data-name="pathBase">
               <h3>
                  pathBase 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#pathBase" class="anchor" title="Link to pathBase">#</a>
               </h3>
               
                  <p class="doc-comment">To limit the size of any particular directory listing,
we encode the (possibly very large) number N
by encoding three digits at a time.
For example, 123456789 encodes as x123/x456/789.
Each directory has at most 1000 each xNNN, NNN, and NNN.p children,
so there are at most 3000 entries in any one directory.</p>
               
               <pre><code class="language-go">const pathBase = 1000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="treePrefix" data-name="treePrefix">
               <h3>
                  treePrefix 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#treePrefix" class="anchor" title="Link to treePrefix">#</a>
               </h3>
               
               <pre><code class="language-go">var treePrefix = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="zeroPrefix" data-name="zeroPrefix">
               <h3>
                  zeroPrefix 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#zeroPrefix" class="anchor" title="Link to zeroPrefix">#</a>
               </h3>
               
               <pre><code class="language-go">var zeroPrefix = []byte{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="Hash" data-name="Hash">
               <h3>
                  Hash
                  <span class="badge type-badge">type</span>
                  <a href="#Hash" class="anchor" title="Link to Hash">#</a>
               </h3>
               
               <p>A Hash is a hash identifying a log record or tree root.</p>
               
               <pre><code class="language-go">type Hash [HashSize]byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="HashReaderFunc" data-name="HashReaderFunc">
               <h3>
                  HashReaderFunc
                  <span class="badge type-badge">type</span>
                  <a href="#HashReaderFunc" class="anchor" title="Link to HashReaderFunc">#</a>
               </h3>
               
               <p>A HashReaderFunc is a function implementing [HashReader].</p>
               
               <pre><code class="language-go">type HashReaderFunc func([]int64) ([]Hash, error)</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="RecordProof" data-name="RecordProof">
               <h3>
                  RecordProof
                  <span class="badge type-badge">type</span>
                  <a href="#RecordProof" class="anchor" title="Link to RecordProof">#</a>
               </h3>
               
               <p>A RecordProof is a verifiable proof that a particular log root contains a particular record.
RFC 6962 calls this a “Merkle audit path.”</p>
               
               <pre><code class="language-go">type RecordProof []Hash</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="TreeProof" data-name="TreeProof">
               <h3>
                  TreeProof
                  <span class="badge type-badge">type</span>
                  <a href="#TreeProof" class="anchor" title="Link to TreeProof">#</a>
               </h3>
               
               <p>A TreeProof is a verifiable proof that a particular log tree contains
as a prefix all records present in an earlier tree.
RFC 6962 calls this a “Merkle consistency proof.”</p>
               
               <pre><code class="language-go">type TreeProof []Hash</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="HashReader" data-name="HashReader">
               <h3>
                  HashReader
                  <span class="badge interface-badge">interface</span>
                  <a href="#HashReader" class="anchor" title="Link to HashReader">#</a>
               </h3>
               
               <p>A HashReader can read hashes for nodes in the log's tree structure.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type HashReader interface {
ReadHashes(indexes []int64) ([]Hash, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="TileReader" data-name="TileReader">
               <h3>
                  TileReader
                  <span class="badge interface-badge">interface</span>
                  <a href="#TileReader" class="anchor" title="Link to TileReader">#</a>
               </h3>
               
               <p>A TileReader reads tiles from a go.sum database log.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type TileReader interface {
Height() int
ReadTiles(tiles []Tile) (data [][]byte, err error)
SaveTiles(tiles []Tile, data [][]byte)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Tile" data-name="Tile">
               <h3>
                  Tile
                  <span class="badge">struct</span>
                  <a href="#Tile" class="anchor" title="Link to Tile">#</a>
               </h3>
               
               <p>A Tile is a description of a transparency log tile.
A tile of height H at level L offset N lists W consecutive hashes
at level H*L of the tree starting at offset N*(2**H).
A complete tile lists 2**H hashes; a partial tile lists fewer.
Note that a tile represents the entire subtree of height H
with those hashes as the leaves. The levels above H*L
can be reconstructed by hashing the leaves.
Each Tile can be encoded as a “tile coordinate path”
of the form tile/H/L/NNN[.p/W].
The .p/W suffix is present only for partial tiles, meaning W < 2**H.
The NNN element is an encoding of N into 3-digit path elements.
All but the last path element begins with an "x".
For example,
Tile{H: 3, L: 4, N: 1234067, W: 1}'s path
is tile/3/4/x001/x234/067.p/1, and
Tile{H: 3, L: 4, N: 1234067, W: 8}'s path
is tile/3/4/x001/x234/067.
See the [Tile.Path] method and the [ParseTilePath] function.
The special level L=-1 holds raw record data instead of hashes.
In this case, the level encodes into a tile path as the path element
"data" instead of "-1".
See also https://golang.org/design/25530-sumdb#checksum-database
and https://research.swtch.com/tlog#tiling_a_log.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Tile struct {
H int
L int
N int64
W int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Tree" data-name="Tree">
               <h3>
                  Tree
                  <span class="badge">struct</span>
                  <a href="#Tree" class="anchor" title="Link to Tree">#</a>
               </h3>
               
               <p>A Tree is a tree description, to be signed by a go.sum database server.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Tree struct {
N int64
Hash Hash
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="badPathError" data-name="badPathError">
               <h3>
                  badPathError
                  <span class="badge">struct</span>
                  <a href="#badPathError" class="anchor" title="Link to badPathError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type badPathError struct {
path string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="tileHashReader" data-name="tileHashReader">
               <h3>
                  tileHashReader
                  <span class="badge">struct</span>
                  <a href="#tileHashReader" class="anchor" title="Link to tileHashReader">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type tileHashReader struct {
tree Tree
tr TileReader
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="CheckRecord" data-name="CheckRecord">
               <h3>
                  CheckRecord 
                  <span class="badge">function</span>
                  
                  <a href="#CheckRecord" class="anchor" title="Link to CheckRecord">#</a>
               </h3>
               
               <p>CheckRecord verifies that p is a valid proof that the tree of size t
with hash th has an n'th record with hash h.</p>
               
               <pre><code class="language-go">func CheckRecord(p RecordProof, t int64, th Hash, n int64, h Hash) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckTree" data-name="CheckTree">
               <h3>
                  CheckTree 
                  <span class="badge">function</span>
                  
                  <a href="#CheckTree" class="anchor" title="Link to CheckTree">#</a>
               </h3>
               
               <p>CheckTree verifies that p is a valid proof that the tree of size t with hash th
contains as a prefix the tree of size n with hash h.</p>
               
               <pre><code class="language-go">func CheckTree(p TreeProof, t int64, th Hash, n int64, h Hash) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *badPathError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FormatRecord" data-name="FormatRecord">
               <h3>
                  FormatRecord 
                  <span class="badge">function</span>
                  
                  <a href="#FormatRecord" class="anchor" title="Link to FormatRecord">#</a>
               </h3>
               
               <p>FormatRecord formats a record for serving to a client
in a lookup response.
The encoded form is the record ID as a single number,
then the text of the record, and then a terminating blank line.
Record text must be valid UTF-8 and must not contain any ASCII control
characters (those below U+0020) other than newline (U+000A).
It must end in a terminating newline and not contain any blank lines.
Responses to data tiles consist of concatenated formatted records from each of
which the first line, with the record ID, is removed.</p>
               
               <pre><code class="language-go">func FormatRecord(id int64, text []byte) (msg []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FormatTree" data-name="FormatTree">
               <h3>
                  FormatTree 
                  <span class="badge">function</span>
                  
                  <a href="#FormatTree" class="anchor" title="Link to FormatTree">#</a>
               </h3>
               
               <p>FormatTree formats a tree description for inclusion in a note.
The encoded form is three lines, each ending in a newline (U+000A):
go.sum database tree
N
Hash
where N is in decimal and Hash is in base64.
A future backwards-compatible encoding may add additional lines,
which the parser can ignore.
A future backwards-incompatible encoding would use a different
first line (for example, "go.sum database tree v2").</p>
               
               <pre><code class="language-go">func FormatTree(tree Tree) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HashFromTile" data-name="HashFromTile">
               <h3>
                  HashFromTile 
                  <span class="badge">function</span>
                  
                  <a href="#HashFromTile" class="anchor" title="Link to HashFromTile">#</a>
               </h3>
               
               <p>HashFromTile returns the hash at the given storage index,
provided that t == TileForIndex(t.H, index) or a wider version,
and data is t's tile data (of length at least t.W*HashSize).</p>
               
               <pre><code class="language-go">func HashFromTile(t Tile, data []byte, index int64) (Hash, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalJSON" data-name="MarshalJSON">
               <h3>
                  MarshalJSON 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalJSON" class="anchor" title="Link to MarshalJSON">#</a>
               </h3>
               
               <p>MarshalJSON marshals the hash as a JSON string containing the base64-encoded hash.</p>
               
               <pre><code class="language-go">func (h Hash) MarshalJSON() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewTiles" data-name="NewTiles">
               <h3>
                  NewTiles 
                  <span class="badge">function</span>
                  
                  <a href="#NewTiles" class="anchor" title="Link to NewTiles">#</a>
               </h3>
               
               <p>NewTiles returns the coordinates of the tiles of height h ≥ 1
that must be published when publishing from a tree of
size newTreeSize to replace a tree of size oldTreeSize.
(No tiles need to be published for a tree of size zero.)
If h ≤ 0, NewTiles panics.</p>
               
               <pre><code class="language-go">func NewTiles(h int, oldTreeSize int64, newTreeSize int64) []Tile</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NodeHash" data-name="NodeHash">
               <h3>
                  NodeHash 
                  <span class="badge">function</span>
                  
                  <a href="#NodeHash" class="anchor" title="Link to NodeHash">#</a>
               </h3>
               
               <p>NodeHash returns the hash for an interior tree node with the given left and right hashes.</p>
               
               <pre><code class="language-go">func NodeHash(left Hash, right Hash) Hash</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseHash" data-name="ParseHash">
               <h3>
                  ParseHash 
                  <span class="badge">function</span>
                  
                  <a href="#ParseHash" class="anchor" title="Link to ParseHash">#</a>
               </h3>
               
               <p>ParseHash parses the base64-encoded string form of a hash.</p>
               
               <pre><code class="language-go">func ParseHash(s string) (Hash, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseRecord" data-name="ParseRecord">
               <h3>
                  ParseRecord 
                  <span class="badge">function</span>
                  
                  <a href="#ParseRecord" class="anchor" title="Link to ParseRecord">#</a>
               </h3>
               
               <p>ParseRecord parses a record description at the start of text,
stopping immediately after the terminating blank line.
It returns the record id, the record text, and the remainder of text.</p>
               
               <pre><code class="language-go">func ParseRecord(msg []byte) (id int64, text []byte, rest []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseTilePath" data-name="ParseTilePath">
               <h3>
                  ParseTilePath 
                  <span class="badge">function</span>
                  
                  <a href="#ParseTilePath" class="anchor" title="Link to ParseTilePath">#</a>
               </h3>
               
               <p>ParseTilePath parses a tile coordinate path.</p>
               
               <pre><code class="language-go">func ParseTilePath(path string) (Tile, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseTree" data-name="ParseTree">
               <h3>
                  ParseTree 
                  <span class="badge">function</span>
                  
                  <a href="#ParseTree" class="anchor" title="Link to ParseTree">#</a>
               </h3>
               
               <p>ParseTree parses a formatted tree root description.</p>
               
               <pre><code class="language-go">func ParseTree(text []byte) (tree Tree, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Path" data-name="Path">
               <h3>
                  Path 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Path" class="anchor" title="Link to Path">#</a>
               </h3>
               
               <p>Path returns a tile coordinate path describing t.</p>
               
               <pre><code class="language-go">func (t Tile) Path() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ProveRecord" data-name="ProveRecord">
               <h3>
                  ProveRecord 
                  <span class="badge">function</span>
                  
                  <a href="#ProveRecord" class="anchor" title="Link to ProveRecord">#</a>
               </h3>
               
               <p>ProveRecord returns the proof that the tree of size t contains the record with index n.</p>
               
               <pre><code class="language-go">func ProveRecord(t int64, n int64, r HashReader) (RecordProof, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ProveTree" data-name="ProveTree">
               <h3>
                  ProveTree 
                  <span class="badge">function</span>
                  
                  <a href="#ProveTree" class="anchor" title="Link to ProveTree">#</a>
               </h3>
               
               <p>ProveTree returns the proof that the tree of size t contains
as a prefix all the records from the tree of smaller size n.</p>
               
               <pre><code class="language-go">func ProveTree(t int64, n int64, h HashReader) (TreeProof, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadHashes" data-name="ReadHashes">
               <h3>
                  ReadHashes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadHashes" class="anchor" title="Link to ReadHashes">#</a>
               </h3>
               
               <pre><code class="language-go">func (f HashReaderFunc) ReadHashes(indexes []int64) ([]Hash, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadHashes" data-name="ReadHashes">
               <h3>
                  ReadHashes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadHashes" class="anchor" title="Link to ReadHashes">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *tileHashReader) ReadHashes(indexes []int64) ([]Hash, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadTileData" data-name="ReadTileData">
               <h3>
                  ReadTileData 
                  <span class="badge">function</span>
                  
                  <a href="#ReadTileData" class="anchor" title="Link to ReadTileData">#</a>
               </h3>
               
               <p>ReadTileData reads the hashes for tile t from r
and returns the corresponding tile data.</p>
               
               <pre><code class="language-go">func ReadTileData(t Tile, r HashReader) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RecordHash" data-name="RecordHash">
               <h3>
                  RecordHash 
                  <span class="badge">function</span>
                  
                  <a href="#RecordHash" class="anchor" title="Link to RecordHash">#</a>
               </h3>
               
               <p>RecordHash returns the content hash for the given record data.</p>
               
               <pre><code class="language-go">func RecordHash(data []byte) Hash</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SplitStoredHashIndex" data-name="SplitStoredHashIndex">
               <h3>
                  SplitStoredHashIndex 
                  <span class="badge">function</span>
                  
                  <a href="#SplitStoredHashIndex" class="anchor" title="Link to SplitStoredHashIndex">#</a>
               </h3>
               
               <p>SplitStoredHashIndex is the inverse of [StoredHashIndex].
That is, SplitStoredHashIndex(StoredHashIndex(level, n)) == level, n.</p>
               
               <pre><code class="language-go">func SplitStoredHashIndex(index int64) (level int, n int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StoredHashCount" data-name="StoredHashCount">
               <h3>
                  StoredHashCount 
                  <span class="badge">function</span>
                  
                  <a href="#StoredHashCount" class="anchor" title="Link to StoredHashCount">#</a>
               </h3>
               
               <p>StoredHashCount returns the number of stored hashes
that are expected for a tree with n records.</p>
               
               <pre><code class="language-go">func StoredHashCount(n int64) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StoredHashIndex" data-name="StoredHashIndex">
               <h3>
                  StoredHashIndex 
                  <span class="badge">function</span>
                  
                  <a href="#StoredHashIndex" class="anchor" title="Link to StoredHashIndex">#</a>
               </h3>
               
               <p>StoredHashIndex maps the tree coordinates (level, n)
to a dense linear ordering that can be used for hash storage.
Hash storage implementations that store hashes in sequential
storage can use this function to compute where to read or write
a given hash.</p>
               
               <pre><code class="language-go">func StoredHashIndex(level int, n int64) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StoredHashes" data-name="StoredHashes">
               <h3>
                  StoredHashes 
                  <span class="badge">function</span>
                  
                  <a href="#StoredHashes" class="anchor" title="Link to StoredHashes">#</a>
               </h3>
               
               <p>StoredHashes returns the hashes that must be stored when writing
record n with the given data. The hashes should be stored starting
at StoredHashIndex(0, n). The result will have at most 1 + log₂ n hashes,
but it will average just under two per call for a sequence of calls for n=1..k.
StoredHashes may read up to log n earlier hashes from r
in order to compute hashes for completed subtrees.</p>
               
               <pre><code class="language-go">func StoredHashes(n int64, data []byte, r HashReader) ([]Hash, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StoredHashesForRecordHash" data-name="StoredHashesForRecordHash">
               <h3>
                  StoredHashesForRecordHash 
                  <span class="badge">function</span>
                  
                  <a href="#StoredHashesForRecordHash" class="anchor" title="Link to StoredHashesForRecordHash">#</a>
               </h3>
               
               <p>StoredHashesForRecordHash is like [StoredHashes] but takes
as its second argument RecordHash(data) instead of data itself.</p>
               
               <pre><code class="language-go">func StoredHashesForRecordHash(n int64, h Hash, r HashReader) ([]Hash, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns a base64 representation of the hash for printing.</p>
               
               <pre><code class="language-go">func (h Hash) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TileForIndex" data-name="TileForIndex">
               <h3>
                  TileForIndex 
                  <span class="badge">function</span>
                  
                  <a href="#TileForIndex" class="anchor" title="Link to TileForIndex">#</a>
               </h3>
               
               <p>TileForIndex returns the tile of fixed height h ≥ 1
and least width storing the given hash storage index.
If h ≤ 0, [TileForIndex] panics.</p>
               
               <pre><code class="language-go">func TileForIndex(h int, index int64) Tile</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TileHashReader" data-name="TileHashReader">
               <h3>
                  TileHashReader 
                  <span class="badge">function</span>
                  
                  <a href="#TileHashReader" class="anchor" title="Link to TileHashReader">#</a>
               </h3>
               
               <p>TileHashReader returns a HashReader that satisfies requests
by loading tiles of the given tree.
The returned [HashReader] checks that loaded tiles are
valid for the given tree. Therefore, any hashes returned
by the HashReader are already proven to be in the tree.</p>
               
               <pre><code class="language-go">func TileHashReader(tree Tree, tr TileReader) HashReader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TreeHash" data-name="TreeHash">
               <h3>
                  TreeHash 
                  <span class="badge">function</span>
                  
                  <a href="#TreeHash" class="anchor" title="Link to TreeHash">#</a>
               </h3>
               
               <p>TreeHash computes the hash for the root of the tree with n records,
using the HashReader to obtain previously stored hashes
(those returned by StoredHashes during the writes of those n records).
TreeHash makes a single call to ReadHash requesting at most 1 + log₂ n hashes.</p>
               
               <pre><code class="language-go">func TreeHash(n int64, r HashReader) (Hash, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalJSON" data-name="UnmarshalJSON">
               <h3>
                  UnmarshalJSON 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnmarshalJSON" class="anchor" title="Link to UnmarshalJSON">#</a>
               </h3>
               
               <p>UnmarshalJSON unmarshals a hash from JSON string containing the a base64-encoded hash.</p>
               
               <pre><code class="language-go">func (h *Hash) UnmarshalJSON(data []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isValidRecordText" data-name="isValidRecordText">
               <h3>
                  isValidRecordText 
                  <span class="badge">function</span>
                  
                  <a href="#isValidRecordText" class="anchor" title="Link to isValidRecordText">#</a>
               </h3>
               
               <p>isValidRecordText reports whether text is syntactically valid record text.</p>
               
               <pre><code class="language-go">func isValidRecordText(text []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="leafProof" data-name="leafProof">
               <h3>
                  leafProof 
                  <span class="badge">function</span>
                  
                  <a href="#leafProof" class="anchor" title="Link to leafProof">#</a>
               </h3>
               
               <p>leafProof constructs the proof that leaf n is contained in the subtree with leaves [lo, hi).
It returns any leftover hashes as well.
See https://tools.ietf.org/html/rfc6962#section-2.1.1</p>
               
               <pre><code class="language-go">func leafProof(lo int64, hi int64, n int64, hashes []Hash) (RecordProof, []Hash)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="leafProofIndex" data-name="leafProofIndex">
               <h3>
                  leafProofIndex 
                  <span class="badge">function</span>
                  
                  <a href="#leafProofIndex" class="anchor" title="Link to leafProofIndex">#</a>
               </h3>
               
               <p>leafProofIndex builds the list of indexes needed to construct the proof
that leaf n is contained in the subtree with leaves [lo, hi).
It appends those indexes to need and returns the result.
See https://tools.ietf.org/html/rfc6962#section-2.1.1</p>
               
               <pre><code class="language-go">func leafProofIndex(lo int64, hi int64, n int64, need []int64) []int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maxpow2" data-name="maxpow2">
               <h3>
                  maxpow2 
                  <span class="badge">function</span>
                  
                  <a href="#maxpow2" class="anchor" title="Link to maxpow2">#</a>
               </h3>
               
               <p>maxpow2 returns k, the maximum power of 2 smaller than n,
as well as l = log₂ k (so k = 1<<l).</p>
               
               <pre><code class="language-go">func maxpow2(n int64) (k int64, l int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runRecordProof" data-name="runRecordProof">
               <h3>
                  runRecordProof 
                  <span class="badge">function</span>
                  
                  <a href="#runRecordProof" class="anchor" title="Link to runRecordProof">#</a>
               </h3>
               
               <p>runRecordProof runs the proof p that leaf n is contained in the subtree with leaves [lo, hi).
Running the proof means constructing and returning the implied hash of that
subtree.</p>
               
               <pre><code class="language-go">func runRecordProof(p RecordProof, lo int64, hi int64, n int64, leafHash Hash) (Hash, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runTreeProof" data-name="runTreeProof">
               <h3>
                  runTreeProof 
                  <span class="badge">function</span>
                  
                  <a href="#runTreeProof" class="anchor" title="Link to runTreeProof">#</a>
               </h3>
               
               <p>runTreeProof runs the sub-proof p related to the subtree containing records [lo, hi),
where old is the hash of the old tree with n records.
Running the proof means constructing and returning the implied hashes of that
subtree in both the old and new tree.</p>
               
               <pre><code class="language-go">func runTreeProof(p TreeProof, lo int64, hi int64, n int64, old Hash) (Hash, Hash, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subTreeHash" data-name="subTreeHash">
               <h3>
                  subTreeHash 
                  <span class="badge">function</span>
                  
                  <a href="#subTreeHash" class="anchor" title="Link to subTreeHash">#</a>
               </h3>
               
               <p>subTreeHash computes the hash for the subtree containing records [lo, hi),
assuming that hashes are the hashes corresponding to the indexes
returned by subTreeIndex(lo, hi).
It returns any leftover hashes.</p>
               
               <pre><code class="language-go">func subTreeHash(lo int64, hi int64, hashes []Hash) (Hash, []Hash)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subTreeIndex" data-name="subTreeIndex">
               <h3>
                  subTreeIndex 
                  <span class="badge">function</span>
                  
                  <a href="#subTreeIndex" class="anchor" title="Link to subTreeIndex">#</a>
               </h3>
               
               <p>subTreeIndex returns the storage indexes needed to compute
the hash for the subtree containing records [lo, hi),
appending them to need and returning the result.
See https://tools.ietf.org/html/rfc6962#section-2.1</p>
               
               <pre><code class="language-go">func subTreeIndex(lo int64, hi int64, need []int64) []int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tileForIndex" data-name="tileForIndex">
               <h3>
                  tileForIndex 
                  <span class="badge">function</span>
                  
                  <a href="#tileForIndex" class="anchor" title="Link to tileForIndex">#</a>
               </h3>
               
               <p>tileForIndex returns the tile of height h ≥ 1
storing the given hash index, which can be
reconstructed using tileHash(data[start:end]).</p>
               
               <pre><code class="language-go">func tileForIndex(h int, index int64) (t Tile, start int, end int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tileHash" data-name="tileHash">
               <h3>
                  tileHash 
                  <span class="badge">function</span>
                  
                  <a href="#tileHash" class="anchor" title="Link to tileHash">#</a>
               </h3>
               
               <p>tileHash computes the subtree hash corresponding to the (2^K)-1 hashes in data.</p>
               
               <pre><code class="language-go">func tileHash(data []byte) Hash</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tileParent" data-name="tileParent">
               <h3>
                  tileParent 
                  <span class="badge">function</span>
                  
                  <a href="#tileParent" class="anchor" title="Link to tileParent">#</a>
               </h3>
               
               <p>tileParent returns t's k'th tile parent in the tiles for a tree of size n.
If there is no such parent, tileParent returns Tile{}.</p>
               
               <pre><code class="language-go">func tileParent(t Tile, k int, n int64) Tile</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="treeProof" data-name="treeProof">
               <h3>
                  treeProof 
                  <span class="badge">function</span>
                  
                  <a href="#treeProof" class="anchor" title="Link to treeProof">#</a>
               </h3>
               
               <p>treeProof constructs the sub-proof related to the subtree containing records [lo, hi).
It returns any leftover hashes as well.
See https://tools.ietf.org/html/rfc6962#section-2.1.2.</p>
               
               <pre><code class="language-go">func treeProof(lo int64, hi int64, n int64, hashes []Hash) (TreeProof, []Hash)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="treeProofIndex" data-name="treeProofIndex">
               <h3>
                  treeProofIndex 
                  <span class="badge">function</span>
                  
                  <a href="#treeProofIndex" class="anchor" title="Link to treeProofIndex">#</a>
               </h3>
               
               <p>treeProofIndex builds the list of indexes needed to construct
the sub-proof related to the subtree containing records [lo, hi).
See https://tools.ietf.org/html/rfc6962#section-2.1.2.</p>
               
               <pre><code class="language-go">func treeProofIndex(lo int64, hi int64, n int64, need []int64) []int64</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>