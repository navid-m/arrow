<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - ecdsa</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>ecdsa</code>
         </h1>
         <hr />
         
         <article class="global" data-name="supportsKDSA">
            <h2>supportsKDSA</h2>
            <hr />
            
            <pre><code>supportsKDSA</code></pre>
         </article>
         
         <article class="global" data-name="reseedInterval">
            <h2>reseedInterval</h2>
            <hr />
            
            <pre><code>reseedInterval</code></pre>
         </article>
         
         <article class="global" data-name="maxRequestSize">
            <h2>maxRequestSize</h2>
            <hr />
            
            <pre><code>maxRequestSize</code></pre>
         </article>
         
         <article class="global" data-name="fipsSelfTest">
            <h2>fipsSelfTest</h2>
            <hr />
            
            <pre><code>fipsSelfTest</code></pre>
         </article>
         
         <article class="global" data-name="fipsSelfTestDeterministic">
            <h2>fipsSelfTestDeterministic</h2>
            <hr />
            
            <pre><code>fipsSelfTestDeterministic</code></pre>
         </article>
         
         <article class="global" data-name="p224">
            <h2>p224</h2>
            <hr />
            
            <pre><code>p224 curveID</code></pre>
         </article>
         
         <article class="global" data-name="p256">
            <h2>p256</h2>
            <hr />
            
            <pre><code>p256 curveID</code></pre>
         </article>
         
         <article class="global" data-name="p384">
            <h2>p384</h2>
            <hr />
            
            <pre><code>p384 curveID</code></pre>
         </article>
         
         <article class="global" data-name="p521">
            <h2>p521</h2>
            <hr />
            
            <pre><code>p521 curveID</code></pre>
         </article>
         
         <article class="global" data-name="_P224">
            <h2>_P224</h2>
            <hr />
            
            <pre><code>_P224</code></pre>
         </article>
         
         <article class="global" data-name="p224Order">
            <h2>p224Order</h2>
            <hr />
            
            <pre><code>p224Order</code></pre>
         </article>
         
         <article class="global" data-name="_P256">
            <h2>_P256</h2>
            <hr />
            
            <pre><code>_P256</code></pre>
         </article>
         
         <article class="global" data-name="p256Order">
            <h2>p256Order</h2>
            <hr />
            
            <pre><code>p256Order</code></pre>
         </article>
         
         <article class="global" data-name="_P384">
            <h2>_P384</h2>
            <hr />
            
            <pre><code>_P384</code></pre>
         </article>
         
         <article class="global" data-name="p384Order">
            <h2>p384Order</h2>
            <hr />
            
            <pre><code>p384Order</code></pre>
         </article>
         
         <article class="global" data-name="_P521">
            <h2>_P521</h2>
            <hr />
            
            <pre><code>_P521</code></pre>
         </article>
         
         <article class="global" data-name="p521Order">
            <h2>p521Order</h2>
            <hr />
            
            <pre><code>p521Order</code></pre>
         </article>
         
         <article class="global" data-name="testingOnlyRejectionSamplingLooped">
            <h2>testingOnlyRejectionSamplingLooped</h2>
            <hr />
            
            <p>testingOnlyRejectionSamplingLooped is called when rejection sampling in
randomPoint rejects a candidate for being higher than the modulus.</p>
            
            <pre><code>testingOnlyRejectionSamplingLooped func</code></pre>
         </article>
          
         <article class="struct" data-name="hmacDRBG">
            <h2>type hmacDRBG struct</h2>
            <hr />
            
            <p>hmacDRBG is an SP 800-90A Rev. 1 HMAC_DRBG.

It is only intended to be used to generate ECDSA nonces. Since it will be
instantiated ex-novo for each signature, its Generate function will only be
invoked once or twice (only for P-256, with probability 2⁻³²).

Per Table 2, it has a reseed interval of 2^48 requests, and a maximum request
size of 2^19 bits (2^16 bytes, 64 KiB).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">newHMAC func
hK *hmac.HMAC
V []byte
reseedCounter uint64</code></pre>
         </article>
         
         <article class="struct" data-name="PrivateKey">
            <h2>type PrivateKey struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pub PublicKey
d []byte</code></pre>
         </article>
         
         <article class="struct" data-name="PublicKey">
            <h2>type PublicKey struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">curve curveID
q []byte</code></pre>
         </article>
         
         <article class="struct" data-name="Curve">
            <h2>type Curve struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">curve curveID
newPoint func
ordInverse func
N *bigmod.Modulus
nMinus2 []byte</code></pre>
         </article>
         
         <article class="struct" data-name="Signature">
            <h2>type Signature struct</h2>
            <hr />
            
            <p>Signature is an ECDSA signature, where r and s are represented as big-endian
byte slices of the same length as the curve order.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">R []byte
S []byte</code></pre>
         </article>
          
         <article class="function" data-name="kdsa">
            <h2>kdsa</h2>
            <hr />
            
            <p>kdsa invokes the "compute digital signature authentication"
instruction with the given function code and 4096 byte
parameter block.

The return value corresponds to the condition code set by the
instruction. Interrupted invocations are handled by the
function.</p>
            
            <pre><code>func kdsa(fc uint64, params *[]byte) errn uint64</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="canUseKDSA">
            <h2>canUseKDSA</h2>
            <hr />
            
            <p>canUseKDSA checks if KDSA instruction is available, and if it is, it checks
the name of the curve to see if it matches the curves supported(P-256, P-384, P-521).
Then, based on the curve name, a function code and a block size will be assigned.
If KDSA instruction is not available or if the curve is not supported, canUseKDSA
will set ok to false.</p>
            
            <pre><code>func canUseKDSA(c curveID) (functionCode uint64, blockSize int, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="hashToBytes">
            <h2>hashToBytes</h2>
            <hr />
            
            <pre><code>func hashToBytes(c **ast.IndexExpr, hash []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="randomScalar">
            <h2>randomScalar</h2>
            <hr />
            
            <p>randomScalar is a copy of [randomPoint] that doesn't call ScalarBaseMult.</p>
            
            <pre><code>func randomScalar(c **ast.IndexExpr, generate func) (k *bigmod.Nat, err error)</code></pre>
         </article>
         
         <article class="function" data-name="appendBlock">
            <h2>appendBlock</h2>
            <hr />
            
            <pre><code>func appendBlock(p []byte, blocksize int, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="trimBlock">
            <h2>trimBlock</h2>
            <hr />
            
            <pre><code>func trimBlock(p []byte, size int) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="sign">
            <h2>sign</h2>
            <hr />
            
            <pre><code>func sign(c **ast.IndexExpr, priv *PrivateKey, drbg *hmacDRBG, hash []byte) (*Signature, error)</code></pre>
         </article>
         
         <article class="function" data-name="verify">
            <h2>verify</h2>
            <hr />
            
            <pre><code>func verify(c **ast.IndexExpr, pub *PublicKey, hash []byte, sig *Signature) error</code></pre>
         </article>
         
         <article class="function" data-name="TestRandomPoint">
            <h2>TestRandomPoint</h2>
            <hr />
            
            <pre><code>func TestRandomPoint(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testRandomPoint">
            <h2>testRandomPoint</h2>
            <hr />
            
            <pre><code>func testRandomPoint(t *testing.T, c **ast.IndexExpr)</code></pre>
         </article>
         
         <article class="function" data-name="TestHashToNat">
            <h2>TestHashToNat</h2>
            <hr />
            
            <pre><code>func TestHashToNat(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testHashToNat">
            <h2>testHashToNat</h2>
            <hr />
            
            <pre><code>func testHashToNat(t *testing.T, c **ast.IndexExpr)</code></pre>
         </article>
         
         <article class="function" data-name="isPersonalizationString">
            <h2>isPersonalizationString</h2>
            <hr />
            
            <pre><code>func isPersonalizationString()</code></pre>
         </article>
         
         <article class="function" data-name="isPersonalizationString">
            <h2>isPersonalizationString</h2>
            <hr />
            
            <pre><code>func isPersonalizationString()</code></pre>
         </article>
         
         <article class="function" data-name="newDRBG">
            <h2>newDRBG</h2>
            <hr />
            
            <pre><code>func newDRBG(hash func, entropy []byte, nonce []byte, s personalizationString) *hmacDRBG</code></pre>
         </article>
         
         <article class="function" data-name="TestingOnlyNewDRBG">
            <h2>TestingOnlyNewDRBG</h2>
            <hr />
            
            <p>TestingOnlyNewDRBG creates an SP 800-90A Rev. 1 HMAC_DRBG with a plain
personalization string.

This should only be used for ACVP testing. hmacDRBG is not intended to be
used directly.</p>
            
            <pre><code>func TestingOnlyNewDRBG(hash func, entropy []byte, nonce []byte, s []byte) *hmacDRBG</code></pre>
         </article>
         
         <article class="function" data-name="pad000">
            <h2>pad000</h2>
            <hr />
            
            <pre><code>func pad000(h *hmac.HMAC, writtenSoFar int)</code></pre>
         </article>
         
         <article class="function" data-name="Generate">
            <h2>Generate</h2>
            <hr />
            
            <p>Generate produces at most maxRequestSize bytes of random data in out.</p>
            
            <pre><code>func Generate(out []byte)</code></pre>
         </article>
         
         <article class="function" data-name="testPrivateKey">
            <h2>testPrivateKey</h2>
            <hr />
            
            <pre><code>func testPrivateKey() *PrivateKey</code></pre>
         </article>
         
         <article class="function" data-name="testHash">
            <h2>testHash</h2>
            <hr />
            
            <pre><code>func testHash() []byte</code></pre>
         </article>
         
         <article class="function" data-name="fipsPCT">
            <h2>fipsPCT</h2>
            <hr />
            
            <pre><code>func fipsPCT(c **ast.IndexExpr, k *PrivateKey) error</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <pre><code>func Bytes() []byte</code></pre>
         </article>
         
         <article class="function" data-name="PublicKey">
            <h2>PublicKey</h2>
            <hr />
            
            <pre><code>func PublicKey() *PublicKey</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <pre><code>func Bytes() []byte</code></pre>
         </article>
         
         <article class="function" data-name="precomputeParams">
            <h2>precomputeParams</h2>
            <hr />
            
            <pre><code>func precomputeParams(c **ast.IndexExpr, order []byte)</code></pre>
         </article>
         
         <article class="function" data-name="P224">
            <h2>P224</h2>
            <hr />
            
            <pre><code>func P224() **ast.IndexExpr</code></pre>
         </article>
         
         <article class="function" data-name="P256">
            <h2>P256</h2>
            <hr />
            
            <pre><code>func P256() **ast.IndexExpr</code></pre>
         </article>
         
         <article class="function" data-name="P384">
            <h2>P384</h2>
            <hr />
            
            <pre><code>func P384() **ast.IndexExpr</code></pre>
         </article>
         
         <article class="function" data-name="P521">
            <h2>P521</h2>
            <hr />
            
            <pre><code>func P521() **ast.IndexExpr</code></pre>
         </article>
         
         <article class="function" data-name="NewPrivateKey">
            <h2>NewPrivateKey</h2>
            <hr />
            
            <pre><code>func NewPrivateKey(c **ast.IndexExpr, D []byte, Q []byte) (*PrivateKey, error)</code></pre>
         </article>
         
         <article class="function" data-name="NewPublicKey">
            <h2>NewPublicKey</h2>
            <hr />
            
            <pre><code>func NewPublicKey(c **ast.IndexExpr, Q []byte) (*PublicKey, error)</code></pre>
         </article>
         
         <article class="function" data-name="GenerateKey">
            <h2>GenerateKey</h2>
            <hr />
            
            <p>GenerateKey generates a new ECDSA private key pair for the specified curve.</p>
            
            <pre><code>func GenerateKey(c **ast.IndexExpr, rand io.Reader) (*PrivateKey, error)</code></pre>
         </article>
         
         <article class="function" data-name="randomPoint">
            <h2>randomPoint</h2>
            <hr />
            
            <p>randomPoint returns a random scalar and the corresponding point using a
procedure equivalent to FIPS 186-5, Appendix A.2.2 (ECDSA Key Pair Generation
by Rejection Sampling) and to Appendix A.3.2 (Per-Message Secret Number
Generation of Private Keys by Rejection Sampling) or Appendix A.3.3
(Per-Message Secret Number Generation for Deterministic ECDSA) followed by
Step 5 of Section 6.4.1.</p>
            
            <pre><code>func randomPoint(c **ast.IndexExpr, generate func) (k *bigmod.Nat, p P, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Sign">
            <h2>Sign</h2>
            <hr />
            
            <p>Sign signs a hash (which shall be the result of hashing a larger message with
the hash function H) using the private key, priv. If the hash is longer than
the bit-length of the private key's curve order, the hash will be truncated
to that length.</p>
            
            <pre><code>func Sign(c **ast.IndexExpr, h func, priv *PrivateKey, rand io.Reader, hash []byte) (*Signature, error)</code></pre>
         </article>
         
         <article class="function" data-name="SignDeterministic">
            <h2>SignDeterministic</h2>
            <hr />
            
            <p>SignDeterministic signs a hash (which shall be the result of hashing a
larger message with the hash function H) using the private key, priv. If the
hash is longer than the bit-length of the private key's curve order, the hash
will be truncated to that length. This applies Deterministic ECDSA as
specified in FIPS 186-5 and RFC 6979.</p>
            
            <pre><code>func SignDeterministic(c **ast.IndexExpr, h func, priv *PrivateKey, hash []byte) (*Signature, error)</code></pre>
         </article>
         
         <article class="function" data-name="bits2octets">
            <h2>bits2octets</h2>
            <hr />
            
            <p>bits2octets as specified in FIPS 186-5, Appendix B.2.4 or RFC 6979,
Section 2.3.4. See RFC 6979, Section 3.5 for the rationale.</p>
            
            <pre><code>func bits2octets(c **ast.IndexExpr, hash []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="signGeneric">
            <h2>signGeneric</h2>
            <hr />
            
            <pre><code>func signGeneric(c **ast.IndexExpr, priv *PrivateKey, drbg *hmacDRBG, hash []byte) (*Signature, error)</code></pre>
         </article>
         
         <article class="function" data-name="inverse">
            <h2>inverse</h2>
            <hr />
            
            <p>inverse sets kInv to the inverse of k modulo the order of the curve.</p>
            
            <pre><code>func inverse(c **ast.IndexExpr, kInv *bigmod.Nat, k *bigmod.Nat)</code></pre>
         </article>
         
         <article class="function" data-name="hashToNat">
            <h2>hashToNat</h2>
            <hr />
            
            <p>hashToNat sets e to the left-most bits of hash, according to
FIPS 186-5, Section 6.4.1, point 2 and Section 6.4.2, point 3.</p>
            
            <pre><code>func hashToNat(c **ast.IndexExpr, e *bigmod.Nat, hash []byte)</code></pre>
         </article>
         
         <article class="function" data-name="rightShift">
            <h2>rightShift</h2>
            <hr />
            
            <p>rightShift implements the right shift necessary for bits2int, which takes the
leftmost bits of either the hash or HMAC_DRBG output.

Note how taking the rightmost bits would have been as easy as masking the
first byte, but we can't have nice things.</p>
            
            <pre><code>func rightShift(b []byte, shift int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Verify">
            <h2>Verify</h2>
            <hr />
            
            <p>Verify verifies the signature, sig, of hash (which should be the result of
hashing a larger message) using the public key, pub. If the hash is longer
than the bit-length of the private key's curve order, the hash will be
truncated to that length.

The inputs are not considered confidential, and may leak through timing side
channels, or if an attacker has control of part of the inputs.</p>
            
            <pre><code>func Verify(c **ast.IndexExpr, pub *PublicKey, hash []byte, sig *Signature) error</code></pre>
         </article>
         
         <article class="function" data-name="verifyGeneric">
            <h2>verifyGeneric</h2>
            <hr />
            
            <pre><code>func verifyGeneric(c **ast.IndexExpr, pub *PublicKey, hash []byte, sig *Signature) error</code></pre>
         </article>
         
         <article class="function" data-name="sign">
            <h2>sign</h2>
            <hr />
            
            <pre><code>func sign(c **ast.IndexExpr, priv *PrivateKey, drbg *hmacDRBG, hash []byte) (*Signature, error)</code></pre>
         </article>
         
         <article class="function" data-name="verify">
            <h2>verify</h2>
            <hr />
            
            <pre><code>func verify(c **ast.IndexExpr, pub *PublicKey, hash []byte, sig *Signature) error</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
