<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - bidi</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>bidi</code>
         </h1>
         <hr />
         
         <article class="global" data-name="UnicodeVersion">
            <h2>UnicodeVersion</h2>
            <hr />
            
            <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
            
            <pre><code>UnicodeVersion</code></pre>
         </article>
         
         <article class="global" data-name="xorMasks">
            <h2>xorMasks</h2>
            <hr />
            
            <p>xorMasks contains masks to be xor-ed with brackets to get the reverse
version.</p>
            
            <pre><code>xorMasks</code></pre>
         </article>
         
         <article class="global" data-name="bidiValues">
            <h2>bidiValues</h2>
            <hr />
            
            <p>bidiValues: 222 blocks, 14208 entries, 14208 bytes
The third block is the zero block.</p>
            
            <pre><code>bidiValues</code></pre>
         </article>
         
         <article class="global" data-name="bidiIndex">
            <h2>bidiIndex</h2>
            <hr />
            
            <p>bidiIndex: 24 blocks, 1536 entries, 1536 bytes
Block 0 is the zero block.</p>
            
            <pre><code>bidiIndex</code></pre>
         </article>
         
         <article class="global" data-name="LeftToRight">
            <h2>LeftToRight</h2>
            <hr />
            
            <p>LeftToRight indicates the text contains no right-to-left characters and
that either there are some left-to-right characters or the option
DefaultDirection(LeftToRight) was passed.</p>
            
            <pre><code>LeftToRight Direction</code></pre>
         </article>
         
         <article class="global" data-name="RightToLeft">
            <h2>RightToLeft</h2>
            <hr />
            
            <p>RightToLeft indicates the text contains no left-to-right characters and
that either there are some right-to-left characters or the option
DefaultDirection(RightToLeft) was passed.</p>
            
            <pre><code>RightToLeft</code></pre>
         </article>
         
         <article class="global" data-name="Mixed">
            <h2>Mixed</h2>
            <hr />
            
            <p>Mixed indicates text contains both left-to-right and right-to-left
characters.</p>
            
            <pre><code>Mixed</code></pre>
         </article>
         
         <article class="global" data-name="Neutral">
            <h2>Neutral</h2>
            <hr />
            
            <p>Neutral means that text contains no left-to-right and right-to-left
characters and that no default direction has been set.</p>
            
            <pre><code>Neutral</code></pre>
         </article>
         
         <article class="global" data-name="bpNone">
            <h2>bpNone</h2>
            <hr />
            
            <pre><code>bpNone bracketType</code></pre>
         </article>
         
         <article class="global" data-name="bpOpen">
            <h2>bpOpen</h2>
            <hr />
            
            <pre><code>bpOpen</code></pre>
         </article>
         
         <article class="global" data-name="bpClose">
            <h2>bpClose</h2>
            <hr />
            
            <pre><code>bpClose</code></pre>
         </article>
         
         <article class="global" data-name="maxPairingDepth">
            <h2>maxPairingDepth</h2>
            <hr />
            
            <pre><code>maxPairingDepth</code></pre>
         </article>
         
         <article class="global" data-name="implicitLevel">
            <h2>implicitLevel</h2>
            <hr />
            
            <pre><code>implicitLevel level</code></pre>
         </article>
         
         <article class="global" data-name="maxDepth">
            <h2>maxDepth</h2>
            <hr />
            
            <pre><code>maxDepth</code></pre>
         </article>
         
         <article class="global" data-name="UnicodeVersion">
            <h2>UnicodeVersion</h2>
            <hr />
            
            <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
            
            <pre><code>UnicodeVersion</code></pre>
         </article>
         
         <article class="global" data-name="xorMasks">
            <h2>xorMasks</h2>
            <hr />
            
            <p>xorMasks contains masks to be xor-ed with brackets to get the reverse
version.</p>
            
            <pre><code>xorMasks</code></pre>
         </article>
         
         <article class="global" data-name="bidiValues">
            <h2>bidiValues</h2>
            <hr />
            
            <p>bidiValues: 228 blocks, 14592 entries, 14592 bytes
The third block is the zero block.</p>
            
            <pre><code>bidiValues</code></pre>
         </article>
         
         <article class="global" data-name="bidiIndex">
            <h2>bidiIndex</h2>
            <hr />
            
            <p>bidiIndex: 24 blocks, 1536 entries, 1536 bytes
Block 0 is the zero block.</p>
            
            <pre><code>bidiIndex</code></pre>
         </article>
         
         <article class="global" data-name="UnicodeVersion">
            <h2>UnicodeVersion</h2>
            <hr />
            
            <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
            
            <pre><code>UnicodeVersion</code></pre>
         </article>
         
         <article class="global" data-name="xorMasks">
            <h2>xorMasks</h2>
            <hr />
            
            <p>xorMasks contains masks to be xor-ed with brackets to get the reverse
version.</p>
            
            <pre><code>xorMasks</code></pre>
         </article>
         
         <article class="global" data-name="bidiValues">
            <h2>bidiValues</h2>
            <hr />
            
            <p>bidiValues: 259 blocks, 16576 entries, 16576 bytes
The third block is the zero block.</p>
            
            <pre><code>bidiValues</code></pre>
         </article>
         
         <article class="global" data-name="bidiIndex">
            <h2>bidiIndex</h2>
            <hr />
            
            <p>bidiIndex: 26 blocks, 1664 entries, 3328 bytes
Block 0 is the zero block.</p>
            
            <pre><code>bidiIndex</code></pre>
         </article>
         
         <article class="global" data-name="L">
            <h2>L</h2>
            <hr />
            
            <pre><code>L Class</code></pre>
         </article>
         
         <article class="global" data-name="R">
            <h2>R</h2>
            <hr />
            
            <pre><code>R</code></pre>
         </article>
         
         <article class="global" data-name="EN">
            <h2>EN</h2>
            <hr />
            
            <pre><code>EN</code></pre>
         </article>
         
         <article class="global" data-name="ES">
            <h2>ES</h2>
            <hr />
            
            <pre><code>ES</code></pre>
         </article>
         
         <article class="global" data-name="ET">
            <h2>ET</h2>
            <hr />
            
            <pre><code>ET</code></pre>
         </article>
         
         <article class="global" data-name="AN">
            <h2>AN</h2>
            <hr />
            
            <pre><code>AN</code></pre>
         </article>
         
         <article class="global" data-name="CS">
            <h2>CS</h2>
            <hr />
            
            <pre><code>CS</code></pre>
         </article>
         
         <article class="global" data-name="B">
            <h2>B</h2>
            <hr />
            
            <pre><code>B</code></pre>
         </article>
         
         <article class="global" data-name="S">
            <h2>S</h2>
            <hr />
            
            <pre><code>S</code></pre>
         </article>
         
         <article class="global" data-name="WS">
            <h2>WS</h2>
            <hr />
            
            <pre><code>WS</code></pre>
         </article>
         
         <article class="global" data-name="ON">
            <h2>ON</h2>
            <hr />
            
            <pre><code>ON</code></pre>
         </article>
         
         <article class="global" data-name="BN">
            <h2>BN</h2>
            <hr />
            
            <pre><code>BN</code></pre>
         </article>
         
         <article class="global" data-name="NSM">
            <h2>NSM</h2>
            <hr />
            
            <pre><code>NSM</code></pre>
         </article>
         
         <article class="global" data-name="AL">
            <h2>AL</h2>
            <hr />
            
            <pre><code>AL</code></pre>
         </article>
         
         <article class="global" data-name="Control">
            <h2>Control</h2>
            <hr />
            
            <pre><code>Control</code></pre>
         </article>
         
         <article class="global" data-name="numClass">
            <h2>numClass</h2>
            <hr />
            
            <pre><code>numClass</code></pre>
         </article>
         
         <article class="global" data-name="LRO">
            <h2>LRO</h2>
            <hr />
            
            <pre><code>LRO</code></pre>
         </article>
         
         <article class="global" data-name="RLO">
            <h2>RLO</h2>
            <hr />
            
            <pre><code>RLO</code></pre>
         </article>
         
         <article class="global" data-name="LRE">
            <h2>LRE</h2>
            <hr />
            
            <pre><code>LRE</code></pre>
         </article>
         
         <article class="global" data-name="RLE">
            <h2>RLE</h2>
            <hr />
            
            <pre><code>RLE</code></pre>
         </article>
         
         <article class="global" data-name="PDF">
            <h2>PDF</h2>
            <hr />
            
            <pre><code>PDF</code></pre>
         </article>
         
         <article class="global" data-name="LRI">
            <h2>LRI</h2>
            <hr />
            
            <pre><code>LRI</code></pre>
         </article>
         
         <article class="global" data-name="RLI">
            <h2>RLI</h2>
            <hr />
            
            <pre><code>RLI</code></pre>
         </article>
         
         <article class="global" data-name="FSI">
            <h2>FSI</h2>
            <hr />
            
            <pre><code>FSI</code></pre>
         </article>
         
         <article class="global" data-name="PDI">
            <h2>PDI</h2>
            <hr />
            
            <pre><code>PDI</code></pre>
         </article>
         
         <article class="global" data-name="unknownClass">
            <h2>unknownClass</h2>
            <hr />
            
            <pre><code>unknownClass</code></pre>
         </article>
         
         <article class="global" data-name="openMask">
            <h2>openMask</h2>
            <hr />
            
            <pre><code>openMask</code></pre>
         </article>
         
         <article class="global" data-name="xorMaskShift">
            <h2>xorMaskShift</h2>
            <hr />
            
            <pre><code>xorMaskShift</code></pre>
         </article>
         
         <article class="global" data-name="trie">
            <h2>trie</h2>
            <hr />
            
            <pre><code>trie</code></pre>
         </article>
         
         <article class="global" data-name="controlByteToClass">
            <h2>controlByteToClass</h2>
            <hr />
            
            <pre><code>controlByteToClass</code></pre>
         </article>
         
         <article class="global" data-name="UnicodeVersion">
            <h2>UnicodeVersion</h2>
            <hr />
            
            <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
            
            <pre><code>UnicodeVersion</code></pre>
         </article>
         
         <article class="global" data-name="xorMasks">
            <h2>xorMasks</h2>
            <hr />
            
            <p>xorMasks contains masks to be xor-ed with brackets to get the reverse
version.</p>
            
            <pre><code>xorMasks</code></pre>
         </article>
         
         <article class="global" data-name="bidiValues">
            <h2>bidiValues</h2>
            <hr />
            
            <p>bidiValues: 234 blocks, 14976 entries, 14976 bytes
The third block is the zero block.</p>
            
            <pre><code>bidiValues</code></pre>
         </article>
         
         <article class="global" data-name="bidiIndex">
            <h2>bidiIndex</h2>
            <hr />
            
            <p>bidiIndex: 24 blocks, 1536 entries, 1536 bytes
Block 0 is the zero block.</p>
            
            <pre><code>bidiIndex</code></pre>
         </article>
         
         <article class="global" data-name="UnicodeVersion">
            <h2>UnicodeVersion</h2>
            <hr />
            
            <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
            
            <pre><code>UnicodeVersion</code></pre>
         </article>
         
         <article class="global" data-name="xorMasks">
            <h2>xorMasks</h2>
            <hr />
            
            <p>xorMasks contains masks to be xor-ed with brackets to get the reverse
version.</p>
            
            <pre><code>xorMasks</code></pre>
         </article>
         
         <article class="global" data-name="bidiValues">
            <h2>bidiValues</h2>
            <hr />
            
            <p>bidiValues: 240 blocks, 15360 entries, 15360 bytes
The third block is the zero block.</p>
            
            <pre><code>bidiValues</code></pre>
         </article>
         
         <article class="global" data-name="bidiIndex">
            <h2>bidiIndex</h2>
            <hr />
            
            <p>bidiIndex: 24 blocks, 1536 entries, 1536 bytes
Block 0 is the zero block.</p>
            
            <pre><code>bidiIndex</code></pre>
         </article>
         
         <article class="global" data-name="UnicodeVersion">
            <h2>UnicodeVersion</h2>
            <hr />
            
            <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
            
            <pre><code>UnicodeVersion</code></pre>
         </article>
         
         <article class="global" data-name="xorMasks">
            <h2>xorMasks</h2>
            <hr />
            
            <p>xorMasks contains masks to be xor-ed with brackets to get the reverse
version.</p>
            
            <pre><code>xorMasks</code></pre>
         </article>
         
         <article class="global" data-name="bidiValues">
            <h2>bidiValues</h2>
            <hr />
            
            <p>bidiValues: 248 blocks, 15872 entries, 15872 bytes
The third block is the zero block.</p>
            
            <pre><code>bidiValues</code></pre>
         </article>
         
         <article class="global" data-name="bidiIndex">
            <h2>bidiIndex</h2>
            <hr />
            
            <p>bidiIndex: 24 blocks, 1536 entries, 1536 bytes
Block 0 is the zero block.</p>
            
            <pre><code>bidiIndex</code></pre>
         </article>
          
         <article class="struct" data-name="bidiTrie">
            <h2>type bidiTrie struct</h2>
            <hr />
            
            <p>bidiTrie. Total size: 15744 bytes (15.38 KiB). Checksum: b4c3b70954803b86.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="options">
            <h2>type options struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">defaultDirection Direction</code></pre>
         </article>
         
         <article class="struct" data-name="Paragraph">
            <h2>type Paragraph struct</h2>
            <hr />
            
            <p>A Paragraph holds a single Paragraph for Bidi processing.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">p []byte
o Ordering
opts []Option
types []Class
pairTypes []bracketType
pairValues []rune
runes []rune
options options</code></pre>
         </article>
         
         <article class="struct" data-name="Ordering">
            <h2>type Ordering struct</h2>
            <hr />
            
            <p>An Ordering holds the computed visual order of runs of a Paragraph. Calling
SetBytes or SetString on the originating Paragraph invalidates an Ordering.
The methods of an Ordering should only be called by one goroutine at a time.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">runes [][]rune
directions []Direction
startpos []int</code></pre>
         </article>
         
         <article class="struct" data-name="Run">
            <h2>type Run struct</h2>
            <hr />
            
            <p>A Run is a continuous sequence of characters of a single direction.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">runes []rune
direction Direction
startpos int</code></pre>
         </article>
         
         <article class="struct" data-name="bracketPair">
            <h2>type bracketPair struct</h2>
            <hr />
            
            <p>bracketPair holds a pair of index values for opening and closing bracket
location of a bracket pair.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">opener int
closer int</code></pre>
         </article>
         
         <article class="struct" data-name="bracketPairer">
            <h2>type bracketPairer struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">sos Class
openers *list.List
pairPositions bracketPairs
codesIsolatedRun []Class
indexes []int</code></pre>
         </article>
         
         <article class="struct" data-name="paragraph">
            <h2>type paragraph struct</h2>
            <hr />
            
            <p>A paragraph contains the state of a paragraph.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">initialTypes []Class
pairTypes []bracketType
pairValues []rune
embeddingLevel level
resultTypes []Class
resultLevels []level
matchingPDI []int
matchingIsolateInitiator []int</code></pre>
         </article>
         
         <article class="struct" data-name="directionalStatusStack">
            <h2>type directionalStatusStack struct</h2>
            <hr />
            
            <p>This stack will store the embedding levels and override and isolated
statuses</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">stackCounter int
embeddingLevelStack []level
overrideStatusStack []Class
isolateStatusStack []bool</code></pre>
         </article>
         
         <article class="struct" data-name="isolatingRunSequence">
            <h2>type isolatingRunSequence struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">p *paragraph
indexes []int
types []Class
resolvedLevels []level
level level
sos Class
eos Class</code></pre>
         </article>
         
         <article class="struct" data-name="bidiTrie">
            <h2>type bidiTrie struct</h2>
            <hr />
            
            <p>bidiTrie. Total size: 16128 bytes (15.75 KiB). Checksum: 8122d83e461996f.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="bidiTrie">
            <h2>type bidiTrie struct</h2>
            <hr />
            
            <p>bidiTrie. Total size: 19904 bytes (19.44 KiB). Checksum: b1f201ed2debb6c8.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="Properties">
            <h2>type Properties struct</h2>
            <hr />
            
            <p>Properties provides access to BiDi properties of runes.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">entry uint8
last uint8</code></pre>
         </article>
         
         <article class="struct" data-name="bidiTrie">
            <h2>type bidiTrie struct</h2>
            <hr />
            
            <p>bidiTrie. Total size: 16512 bytes (16.12 KiB). Checksum: 2a9cf1317f2ffaa.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="bidiTrie">
            <h2>type bidiTrie struct</h2>
            <hr />
            
            <p>bidiTrie. Total size: 16896 bytes (16.50 KiB). Checksum: 6f0927067913dc6d.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="bidiTrie">
            <h2>type bidiTrie struct</h2>
            <hr />
            
            <p>bidiTrie. Total size: 17408 bytes (17.00 KiB). Checksum: df85fcbfe9b8377f.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
          
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint8, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint8</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint8, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint8</code></pre>
         </article>
         
         <article class="function" data-name="newBidiTrie">
            <h2>newBidiTrie</h2>
            <hr />
            
            <pre><code>func newBidiTrie(i int) *bidiTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint8</code></pre>
         </article>
         
         <article class="function" data-name="DefaultDirection">
            <h2>DefaultDirection</h2>
            <hr />
            
            <p>DefaultDirection sets the default direction for a Paragraph. The direction is
overridden if the text contains directional characters.</p>
            
            <pre><code>func DefaultDirection(d Direction) Option</code></pre>
         </article>
         
         <article class="function" data-name="prepareInput">
            <h2>prepareInput</h2>
            <hr />
            
            <p>Initialize the p.pairTypes, p.pairValues and p.types from the input previously
set by p.SetBytes() or p.SetString(). Also limit the input up to (and including) a paragraph
separator (bidi class B).

The function p.Order() needs these values to be set, so this preparation could be postponed.
But since the SetBytes and SetStrings functions return the length of the input up to the paragraph
separator, the whole input needs to be processed anyway and should not be done twice.

The function has the same return values as SetBytes() / SetString()</p>
            
            <pre><code>func prepareInput() (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="SetBytes">
            <h2>SetBytes</h2>
            <hr />
            
            <p>SetBytes configures p for the given paragraph text. It replaces text
previously set by SetBytes or SetString. If b contains a paragraph separator
it will only process the first paragraph and report the number of bytes
consumed from b including this separator. Error may be non-nil if options are
given.</p>
            
            <pre><code>func SetBytes(b []byte, opts ...Option) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="SetString">
            <h2>SetString</h2>
            <hr />
            
            <p>SetString configures s for the given paragraph text. It replaces text
previously set by SetBytes or SetString. If s contains a paragraph separator
it will only process the first paragraph and report the number of bytes
consumed from s including this separator. Error may be non-nil if options are
given.</p>
            
            <pre><code>func SetString(s string, opts ...Option) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="IsLeftToRight">
            <h2>IsLeftToRight</h2>
            <hr />
            
            <p>IsLeftToRight reports whether the principle direction of rendering for this
paragraphs is left-to-right. If this returns false, the principle direction
of rendering is right-to-left.</p>
            
            <pre><code>func IsLeftToRight() bool</code></pre>
         </article>
         
         <article class="function" data-name="Direction">
            <h2>Direction</h2>
            <hr />
            
            <p>Direction returns the direction of the text of this paragraph.

The direction may be LeftToRight, RightToLeft, Mixed, or Neutral.</p>
            
            <pre><code>func Direction() Direction</code></pre>
         </article>
         
         <article class="function" data-name="RunAt">
            <h2>RunAt</h2>
            <hr />
            
            <p>RunAt reports the Run at the given position of the input text.

This method can be used for computing line breaks on paragraphs.</p>
            
            <pre><code>func RunAt(pos int) Run</code></pre>
         </article>
         
         <article class="function" data-name="calculateOrdering">
            <h2>calculateOrdering</h2>
            <hr />
            
            <pre><code>func calculateOrdering(levels []level, runes []rune) Ordering</code></pre>
         </article>
         
         <article class="function" data-name="Order">
            <h2>Order</h2>
            <hr />
            
            <p>Order computes the visual ordering of all the runs in a Paragraph.</p>
            
            <pre><code>func Order() (Ordering, error)</code></pre>
         </article>
         
         <article class="function" data-name="Line">
            <h2>Line</h2>
            <hr />
            
            <p>Line computes the visual ordering of runs for a single line starting and
ending at the given positions in the original text.</p>
            
            <pre><code>func Line(start int, end int) (Ordering, error)</code></pre>
         </article>
         
         <article class="function" data-name="Direction">
            <h2>Direction</h2>
            <hr />
            
            <p>Direction reports the directionality of the runs.

The direction may be LeftToRight, RightToLeft, Mixed, or Neutral.</p>
            
            <pre><code>func Direction() Direction</code></pre>
         </article>
         
         <article class="function" data-name="NumRuns">
            <h2>NumRuns</h2>
            <hr />
            
            <p>NumRuns returns the number of runs.</p>
            
            <pre><code>func NumRuns() int</code></pre>
         </article>
         
         <article class="function" data-name="Run">
            <h2>Run</h2>
            <hr />
            
            <p>Run returns the ith run within the ordering.</p>
            
            <pre><code>func Run(i int) Run</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns the text of the run in its original order.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <p>Bytes returns the text of the run in its original order.</p>
            
            <pre><code>func Bytes() []byte</code></pre>
         </article>
         
         <article class="function" data-name="Direction">
            <h2>Direction</h2>
            <hr />
            
            <p>Direction reports the direction of the run.</p>
            
            <pre><code>func Direction() Direction</code></pre>
         </article>
         
         <article class="function" data-name="Pos">
            <h2>Pos</h2>
            <hr />
            
            <p>Pos returns the position of the Run within the text passed to SetBytes or SetString of the
originating Paragraph value.</p>
            
            <pre><code>func Pos() (start int, end int)</code></pre>
         </article>
         
         <article class="function" data-name="AppendReverse">
            <h2>AppendReverse</h2>
            <hr />
            
            <p>AppendReverse reverses the order of characters of in, appends them to out,
and returns the result. Modifiers will still follow the runes they modify.
Brackets are replaced with their counterparts.</p>
            
            <pre><code>func AppendReverse(out []byte, in []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="ReverseString">
            <h2>ReverseString</h2>
            <hr />
            
            <p>ReverseString reverses the order of characters in s and returns a new string.
Modifiers will still follow the runes they modify. Brackets are replaced with
their counterparts.</p>
            
            <pre><code>func ReverseString(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="resolvePairedBrackets">
            <h2>resolvePairedBrackets</h2>
            <hr />
            
            <p>resolvePairedBrackets runs the paired bracket part of the UBA algorithm.

For each rune, it takes the indexes into the original string, the class the
bracket type (in pairTypes) and the bracket identifier (pairValues). It also
takes the direction type for the start-of-sentence and the embedding level.

The identifiers for bracket types are the rune of the canonicalized opening
bracket for brackets (open or close) or 0 for runes that are not brackets.</p>
            
            <pre><code>func resolvePairedBrackets(s *isolatingRunSequence)</code></pre>
         </article>
         
         <article class="function" data-name="matchOpener">
            <h2>matchOpener</h2>
            <hr />
            
            <p>matchOpener reports whether characters at given positions form a matching
bracket pair.</p>
            
            <pre><code>func matchOpener(pairValues []rune, opener int, closer int) bool</code></pre>
         </article>
         
         <article class="function" data-name="locateBrackets">
            <h2>locateBrackets</h2>
            <hr />
            
            <p>locateBrackets locates matching bracket pairs according to BD16.

This implementation uses a linked list instead of a stack, because, while
elements are added at the front (like a push) they are not generally removed
in atomic 'pop' operations, reducing the benefit of the stack archetype.</p>
            
            <pre><code>func locateBrackets(pairTypes []bracketType, pairValues []rune)</code></pre>
         </article>
         
         <article class="function" data-name="getStrongTypeN0">
            <h2>getStrongTypeN0</h2>
            <hr />
            
            <p>getStrongTypeN0 maps character's directional code to strong type as required
by rule N0.

TODO: have separate type for "strong" directionality.</p>
            
            <pre><code>func getStrongTypeN0(index int) Class</code></pre>
         </article>
         
         <article class="function" data-name="classifyPairContent">
            <h2>classifyPairContent</h2>
            <hr />
            
            <p>classifyPairContent reports the strong types contained inside a Bracket Pair,
assuming the given embedding direction.

It returns ON if no strong type is found. If a single strong type is found,
it returns this type. Otherwise it returns the embedding direction.

TODO: use separate type for "strong" directionality.</p>
            
            <pre><code>func classifyPairContent(loc bracketPair, dirEmbed Class) Class</code></pre>
         </article>
         
         <article class="function" data-name="classBeforePair">
            <h2>classBeforePair</h2>
            <hr />
            
            <p>classBeforePair determines which strong types are present before a Bracket
Pair. Return R or L if strong type found, otherwise ON.</p>
            
            <pre><code>func classBeforePair(loc bracketPair) Class</code></pre>
         </article>
         
         <article class="function" data-name="assignBracketType">
            <h2>assignBracketType</h2>
            <hr />
            
            <p>assignBracketType implements rule N0 for a single bracket pair.</p>
            
            <pre><code>func assignBracketType(loc bracketPair, dirEmbed Class, initialTypes []Class)</code></pre>
         </article>
         
         <article class="function" data-name="setBracketsToType">
            <h2>setBracketsToType</h2>
            <hr />
            
            <pre><code>func setBracketsToType(loc bracketPair, dirPair Class, initialTypes []Class)</code></pre>
         </article>
         
         <article class="function" data-name="resolveBrackets">
            <h2>resolveBrackets</h2>
            <hr />
            
            <p>resolveBrackets implements rule N0 for a list of pairs.</p>
            
            <pre><code>func resolveBrackets(dirEmbed Class, initialTypes []Class)</code></pre>
         </article>
         
         <article class="function" data-name="in">
            <h2>in</h2>
            <hr />
            
            <p>in returns if x is equal to any of the values in set.</p>
            
            <pre><code>func in(set ...Class) bool</code></pre>
         </article>
         
         <article class="function" data-name="newParagraph">
            <h2>newParagraph</h2>
            <hr />
            
            <p>newParagraph initializes a paragraph. The user needs to supply a few arrays
corresponding to the preprocessed text input. The types correspond to the
Unicode BiDi classes for each rune. pairTypes indicates the bracket type for
each rune. pairValues provides a unique bracket class identifier for each
rune (suggested is the rune of the open bracket for opening and matching
close brackets, after normalization). The embedding levels are optional, but
may be supplied to encode embedding levels of styled text.</p>
            
            <pre><code>func newParagraph(types []Class, pairTypes []bracketType, pairValues []rune, levels level) (*paragraph, error)</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="run">
            <h2>run</h2>
            <hr />
            
            <p>The algorithm. Does not include line-based processing (Rules L1, L2).
These are applied later in the line-based phase of the algorithm.</p>
            
            <pre><code>func run()</code></pre>
         </article>
         
         <article class="function" data-name="determineMatchingIsolates">
            <h2>determineMatchingIsolates</h2>
            <hr />
            
            <p>determineMatchingIsolates determines the matching PDI for each isolate
initiator and vice versa.

Definition BD9.

At the end of this function:

  - The member variable matchingPDI is set to point to the index of the
    matching PDI character for each isolate initiator character. If there is
    no matching PDI, it is set to the length of the input text. For other
    characters, it is set to -1.
  - The member variable matchingIsolateInitiator is set to point to the
    index of the matching isolate initiator character for each PDI character.
    If there is no matching isolate initiator, or the character is not a PDI,
    it is set to -1.</p>
            
            <pre><code>func determineMatchingIsolates()</code></pre>
         </article>
         
         <article class="function" data-name="determineParagraphEmbeddingLevel">
            <h2>determineParagraphEmbeddingLevel</h2>
            <hr />
            
            <p>determineParagraphEmbeddingLevel reports the resolved paragraph direction of
the substring limited by the given range [start, end).

Determines the paragraph level based on rules P2, P3. This is also used
in rule X5c to find if an FSI should resolve to LRI or RLI.</p>
            
            <pre><code>func determineParagraphEmbeddingLevel(start int, end int) level</code></pre>
         </article>
         
         <article class="function" data-name="empty">
            <h2>empty</h2>
            <hr />
            
            <pre><code>func empty()</code></pre>
         </article>
         
         <article class="function" data-name="pop">
            <h2>pop</h2>
            <hr />
            
            <pre><code>func pop()</code></pre>
         </article>
         
         <article class="function" data-name="depth">
            <h2>depth</h2>
            <hr />
            
            <pre><code>func depth() int</code></pre>
         </article>
         
         <article class="function" data-name="push">
            <h2>push</h2>
            <hr />
            
            <pre><code>func push(level level, overrideStatus Class, isolateStatus bool)</code></pre>
         </article>
         
         <article class="function" data-name="lastEmbeddingLevel">
            <h2>lastEmbeddingLevel</h2>
            <hr />
            
            <pre><code>func lastEmbeddingLevel() level</code></pre>
         </article>
         
         <article class="function" data-name="lastDirectionalOverrideStatus">
            <h2>lastDirectionalOverrideStatus</h2>
            <hr />
            
            <pre><code>func lastDirectionalOverrideStatus() Class</code></pre>
         </article>
         
         <article class="function" data-name="lastDirectionalIsolateStatus">
            <h2>lastDirectionalIsolateStatus</h2>
            <hr />
            
            <pre><code>func lastDirectionalIsolateStatus() bool</code></pre>
         </article>
         
         <article class="function" data-name="determineExplicitEmbeddingLevels">
            <h2>determineExplicitEmbeddingLevels</h2>
            <hr />
            
            <p>Determine explicit levels using rules X1 - X8</p>
            
            <pre><code>func determineExplicitEmbeddingLevels()</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="maxLevel">
            <h2>maxLevel</h2>
            <hr />
            
            <pre><code>func maxLevel(a level, b level) level</code></pre>
         </article>
         
         <article class="function" data-name="isolatingRunSequence">
            <h2>isolatingRunSequence</h2>
            <hr />
            
            <p>Rule X10, second bullet: Determine the start-of-sequence (sos) and end-of-sequence (eos) types,
either L or R, for each isolating run sequence.</p>
            
            <pre><code>func isolatingRunSequence(indexes []int) *isolatingRunSequence</code></pre>
         </article>
         
         <article class="function" data-name="resolveWeakTypes">
            <h2>resolveWeakTypes</h2>
            <hr />
            
            <p>Resolving weak types Rules W1-W7.

Note that some weak types (EN, AN) remain after this processing is
complete.</p>
            
            <pre><code>func resolveWeakTypes()</code></pre>
         </article>
         
         <article class="function" data-name="resolveNeutralTypes">
            <h2>resolveNeutralTypes</h2>
            <hr />
            
            <p>6) resolving neutral types Rules N1-N2.</p>
            
            <pre><code>func resolveNeutralTypes()</code></pre>
         </article>
         
         <article class="function" data-name="setLevels">
            <h2>setLevels</h2>
            <hr />
            
            <pre><code>func setLevels(levels []level, newLevel level)</code></pre>
         </article>
         
         <article class="function" data-name="setTypes">
            <h2>setTypes</h2>
            <hr />
            
            <pre><code>func setTypes(types []Class, newType Class)</code></pre>
         </article>
         
         <article class="function" data-name="resolveImplicitLevels">
            <h2>resolveImplicitLevels</h2>
            <hr />
            
            <p>7) resolving implicit embedding levels Rules I1, I2.</p>
            
            <pre><code>func resolveImplicitLevels()</code></pre>
         </article>
         
         <article class="function" data-name="applyLevelsAndTypes">
            <h2>applyLevelsAndTypes</h2>
            <hr />
            
            <p>Applies the levels and types resolved in rules W1-I2 to the
resultLevels array.</p>
            
            <pre><code>func applyLevelsAndTypes()</code></pre>
         </article>
         
         <article class="function" data-name="findRunLimit">
            <h2>findRunLimit</h2>
            <hr />
            
            <p>Return the limit of the run consisting only of the types in validSet
starting at index. This checks the value at index, and will return
index if that value is not in validSet.</p>
            
            <pre><code>func findRunLimit(index int, validSet ...Class) int</code></pre>
         </article>
         
         <article class="function" data-name="assertOnly">
            <h2>assertOnly</h2>
            <hr />
            
            <p>Algorithm validation. Assert that all values in types are in the
provided set.</p>
            
            <pre><code>func assertOnly(codes ...Class)</code></pre>
         </article>
         
         <article class="function" data-name="determineLevelRuns">
            <h2>determineLevelRuns</h2>
            <hr />
            
            <p>determineLevelRuns returns an array of level runs. Each level run is
described as an array of indexes into the input string.

Determines the level runs. Rule X9 will be applied in determining the
runs, in the way that makes sure the characters that are supposed to be
removed are not included in the runs.</p>
            
            <pre><code>func determineLevelRuns() [][]int</code></pre>
         </article>
         
         <article class="function" data-name="determineIsolatingRunSequences">
            <h2>determineIsolatingRunSequences</h2>
            <hr />
            
            <p>Definition BD13. Determine isolating run sequences.</p>
            
            <pre><code>func determineIsolatingRunSequences() []*isolatingRunSequence</code></pre>
         </article>
         
         <article class="function" data-name="assignLevelsToCharactersRemovedByX9">
            <h2>assignLevelsToCharactersRemovedByX9</h2>
            <hr />
            
            <p>Assign level information to characters removed by rule X9. This is for
ease of relating the level information to the original input data. Note
that the levels assigned to these codes are arbitrary, they're chosen so
as to avoid breaking level runs.</p>
            
            <pre><code>func assignLevelsToCharactersRemovedByX9()</code></pre>
         </article>
         
         <article class="function" data-name="getLevels">
            <h2>getLevels</h2>
            <hr />
            
            <p>getLevels computes levels array breaking lines at offsets in linebreaks.
Rule L1.

The linebreaks array must include at least one value. The values must be
in strictly increasing order (no duplicates) between 1 and the length of
the text, inclusive. The last value must be the length of the text.</p>
            
            <pre><code>func getLevels(linebreaks []int) []level</code></pre>
         </article>
         
         <article class="function" data-name="getReordering">
            <h2>getReordering</h2>
            <hr />
            
            <p>getReordering returns the reordering of lines from a visual index to a
logical index for line breaks at the given offsets.

Lines are concatenated from left to right. So for example, the fifth
character from the left on the third line is

	getReordering(linebreaks)[linebreaks[1] + 4]

(linebreaks[1] is the position after the last character of the second
line, which is also the index of the first character on the third line,
and adding four gets the fifth character from the left).

The linebreaks array must include at least one value. The values must be
in strictly increasing order (no duplicates) between 1 and the length of
the text, inclusive. The last value must be the length of the text.</p>
            
            <pre><code>func getReordering(linebreaks []int) []int</code></pre>
         </article>
         
         <article class="function" data-name="computeMultilineReordering">
            <h2>computeMultilineReordering</h2>
            <hr />
            
            <p>Return multiline reordering array for a given level array. Reordering
does not occur across a line break.</p>
            
            <pre><code>func computeMultilineReordering(levels []level, linebreaks []int) []int</code></pre>
         </article>
         
         <article class="function" data-name="computeReordering">
            <h2>computeReordering</h2>
            <hr />
            
            <p>Return reordering array for a given level array. This reorders a single
line. The reordering is a visual to logical map. For example, the
leftmost char is string.charAt(order[0]). Rule L2.</p>
            
            <pre><code>func computeReordering(levels []level) []int</code></pre>
         </article>
         
         <article class="function" data-name="isWhitespace">
            <h2>isWhitespace</h2>
            <hr />
            
            <p>isWhitespace reports whether the type is considered a whitespace type for the
line break rules.</p>
            
            <pre><code>func isWhitespace(c Class) bool</code></pre>
         </article>
         
         <article class="function" data-name="isRemovedByX9">
            <h2>isRemovedByX9</h2>
            <hr />
            
            <p>isRemovedByX9 reports whether the type is one of the types removed in X9.</p>
            
            <pre><code>func isRemovedByX9(c Class) bool</code></pre>
         </article>
         
         <article class="function" data-name="typeForLevel">
            <h2>typeForLevel</h2>
            <hr />
            
            <p>typeForLevel reports the strong type (L or R) corresponding to the level.</p>
            
            <pre><code>func typeForLevel(level level) Class</code></pre>
         </article>
         
         <article class="function" data-name="validateTypes">
            <h2>validateTypes</h2>
            <hr />
            
            <pre><code>func validateTypes(types []Class) error</code></pre>
         </article>
         
         <article class="function" data-name="validateParagraphEmbeddingLevel">
            <h2>validateParagraphEmbeddingLevel</h2>
            <hr />
            
            <pre><code>func validateParagraphEmbeddingLevel(embeddingLevel level) error</code></pre>
         </article>
         
         <article class="function" data-name="validateLineBreaks">
            <h2>validateLineBreaks</h2>
            <hr />
            
            <pre><code>func validateLineBreaks(linebreaks []int, textLength int) error</code></pre>
         </article>
         
         <article class="function" data-name="validatePbTypes">
            <h2>validatePbTypes</h2>
            <hr />
            
            <pre><code>func validatePbTypes(pairTypes []bracketType) error</code></pre>
         </article>
         
         <article class="function" data-name="validatePbValues">
            <h2>validatePbValues</h2>
            <hr />
            
            <pre><code>func validatePbValues(pairValues []rune, pairTypes []bracketType) error</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint8, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint8</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint8, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint8</code></pre>
         </article>
         
         <article class="function" data-name="newBidiTrie">
            <h2>newBidiTrie</h2>
            <hr />
            
            <pre><code>func newBidiTrie(i int) *bidiTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint8</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint8, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint8</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint8, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint8</code></pre>
         </article>
         
         <article class="function" data-name="newBidiTrie">
            <h2>newBidiTrie</h2>
            <hr />
            
            <pre><code>func newBidiTrie(i int) *bidiTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint8</code></pre>
         </article>
         
         <article class="function" data-name="Class">
            <h2>Class</h2>
            <hr />
            
            <p>Class returns the Bidi class for p.</p>
            
            <pre><code>func Class() Class</code></pre>
         </article>
         
         <article class="function" data-name="IsBracket">
            <h2>IsBracket</h2>
            <hr />
            
            <p>IsBracket reports whether the rune is a bracket.</p>
            
            <pre><code>func IsBracket() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsOpeningBracket">
            <h2>IsOpeningBracket</h2>
            <hr />
            
            <p>IsOpeningBracket reports whether the rune is an opening bracket.
IsBracket must return true.</p>
            
            <pre><code>func IsOpeningBracket() bool</code></pre>
         </article>
         
         <article class="function" data-name="reverseBracket">
            <h2>reverseBracket</h2>
            <hr />
            
            <p>TODO: find a better API and expose.</p>
            
            <pre><code>func reverseBracket(r rune) rune</code></pre>
         </article>
         
         <article class="function" data-name="LookupRune">
            <h2>LookupRune</h2>
            <hr />
            
            <p>LookupRune returns properties for r.</p>
            
            <pre><code>func LookupRune(r rune) (p Properties, size int)</code></pre>
         </article>
         
         <article class="function" data-name="Lookup">
            <h2>Lookup</h2>
            <hr />
            
            <p>Lookup returns properties for the first rune in s and the width in bytes of
its encoding. The size will be 0 if s does not hold enough bytes to complete
the encoding.</p>
            
            <pre><code>func Lookup(s []byte) (p Properties, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="LookupString">
            <h2>LookupString</h2>
            <hr />
            
            <p>LookupString returns properties for the first rune in s and the width in
bytes of its encoding. The size will be 0 if s does not hold enough bytes to
complete the encoding.</p>
            
            <pre><code>func LookupString(s string) (p Properties, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint8, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint8</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint8, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint8</code></pre>
         </article>
         
         <article class="function" data-name="newBidiTrie">
            <h2>newBidiTrie</h2>
            <hr />
            
            <pre><code>func newBidiTrie(i int) *bidiTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint8</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint8, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint8</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint8, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint8</code></pre>
         </article>
         
         <article class="function" data-name="newBidiTrie">
            <h2>newBidiTrie</h2>
            <hr />
            
            <pre><code>func newBidiTrie(i int) *bidiTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint8</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookup(s []byte) (v uint8, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupUnsafe">
            <h2>lookupUnsafe</h2>
            <hr />
            
            <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupUnsafe(s []byte) uint8</code></pre>
         </article>
         
         <article class="function" data-name="lookupString">
            <h2>lookupString</h2>
            <hr />
            
            <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
            
            <pre><code>func lookupString(s string) (v uint8, sz int)</code></pre>
         </article>
         
         <article class="function" data-name="lookupStringUnsafe">
            <h2>lookupStringUnsafe</h2>
            <hr />
            
            <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
            
            <pre><code>func lookupStringUnsafe(s string) uint8</code></pre>
         </article>
         
         <article class="function" data-name="newBidiTrie">
            <h2>newBidiTrie</h2>
            <hr />
            
            <pre><code>func newBidiTrie(i int) *bidiTrie</code></pre>
         </article>
         
         <article class="function" data-name="lookupValue">
            <h2>lookupValue</h2>
            <hr />
            
            <p>lookupValue determines the type of block n and looks up the value for b.</p>
            
            <pre><code>func lookupValue(n uint32, b byte) uint8</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
