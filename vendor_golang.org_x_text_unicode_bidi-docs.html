<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - bidi</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>bidi</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bytes"
"container/list"
"fmt"
"sort"
"unicode/utf8"
"fmt"
"log"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="AL">
               <h3>
                  AL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const AL</code></pre>
            </article>
            
            <article class="global" data-name="AN">
               <h3>
                  AN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const AN</code></pre>
            </article>
            
            <article class="global" data-name="B">
               <h3>
                  B 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const B</code></pre>
            </article>
            
            <article class="global" data-name="BN">
               <h3>
                  BN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const BN</code></pre>
            </article>
            
            <article class="global" data-name="CS">
               <h3>
                  CS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const CS</code></pre>
            </article>
            
            <article class="global" data-name="Control">
               <h3>
                  Control 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Control</code></pre>
            </article>
            
            <article class="global" data-name="EN">
               <h3>
                  EN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EN</code></pre>
            </article>
            
            <article class="global" data-name="ES">
               <h3>
                  ES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ES</code></pre>
            </article>
            
            <article class="global" data-name="ET">
               <h3>
                  ET 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ET</code></pre>
            </article>
            
            <article class="global" data-name="FSI">
               <h3>
                  FSI 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FSI</code></pre>
            </article>
            
            <article class="global" data-name="L">
               <h3>
                  L 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const L Class = iota</code></pre>
            </article>
            
            <article class="global" data-name="LRE">
               <h3>
                  LRE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const LRE</code></pre>
            </article>
            
            <article class="global" data-name="LRI">
               <h3>
                  LRI 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const LRI</code></pre>
            </article>
            
            <article class="global" data-name="LRO">
               <h3>
                  LRO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const LRO</code></pre>
            </article>
            
            <article class="global" data-name="LeftToRight">
               <h3>
                  LeftToRight 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>LeftToRight indicates the text contains no right-to-left characters and
that either there are some left-to-right characters or the option
DefaultDirection(LeftToRight) was passed.</p>
               
               <pre><code>const LeftToRight Direction = iota</code></pre>
            </article>
            
            <article class="global" data-name="Mixed">
               <h3>
                  Mixed 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Mixed indicates text contains both left-to-right and right-to-left
characters.</p>
               
               <pre><code>const Mixed</code></pre>
            </article>
            
            <article class="global" data-name="NSM">
               <h3>
                  NSM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NSM</code></pre>
            </article>
            
            <article class="global" data-name="Neutral">
               <h3>
                  Neutral 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Neutral means that text contains no left-to-right and right-to-left
characters and that no default direction has been set.</p>
               
               <pre><code>const Neutral</code></pre>
            </article>
            
            <article class="global" data-name="ON">
               <h3>
                  ON 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ON</code></pre>
            </article>
            
            <article class="global" data-name="PDF">
               <h3>
                  PDF 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const PDF</code></pre>
            </article>
            
            <article class="global" data-name="PDI">
               <h3>
                  PDI 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const PDI</code></pre>
            </article>
            
            <article class="global" data-name="R">
               <h3>
                  R 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const R</code></pre>
            </article>
            
            <article class="global" data-name="RLE">
               <h3>
                  RLE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const RLE</code></pre>
            </article>
            
            <article class="global" data-name="RLI">
               <h3>
                  RLI 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const RLI</code></pre>
            </article>
            
            <article class="global" data-name="RLO">
               <h3>
                  RLO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const RLO</code></pre>
            </article>
            
            <article class="global" data-name="RightToLeft">
               <h3>
                  RightToLeft 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>RightToLeft indicates the text contains no left-to-right characters and
that either there are some right-to-left characters or the option
DefaultDirection(RightToLeft) was passed.</p>
               
               <pre><code>const RightToLeft</code></pre>
            </article>
            
            <article class="global" data-name="S">
               <h3>
                  S 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const S</code></pre>
            </article>
            
            <article class="global" data-name="UnicodeVersion">
               <h3>
                  UnicodeVersion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
               
               <pre><code>const UnicodeVersion = "12.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="UnicodeVersion">
               <h3>
                  UnicodeVersion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
               
               <pre><code>const UnicodeVersion = "10.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="UnicodeVersion">
               <h3>
                  UnicodeVersion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
               
               <pre><code>const UnicodeVersion = "11.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="UnicodeVersion">
               <h3>
                  UnicodeVersion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
               
               <pre><code>const UnicodeVersion = "13.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="UnicodeVersion">
               <h3>
                  UnicodeVersion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
               
               <pre><code>const UnicodeVersion = "9.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="UnicodeVersion">
               <h3>
                  UnicodeVersion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UnicodeVersion is the Unicode version from which the tables in this package are derived.</p>
               
               <pre><code>const UnicodeVersion = "15.0.0"</code></pre>
            </article>
            
            <article class="global" data-name="WS">
               <h3>
                  WS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const WS</code></pre>
            </article>
            
            <article class="global" data-name="bidiIndex">
               <h3>
                  bidiIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>bidiIndex: 24 blocks, 1536 entries, 1536 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var bidiIndex = [1536]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="bidiIndex">
               <h3>
                  bidiIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>bidiIndex: 24 blocks, 1536 entries, 1536 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var bidiIndex = [1536]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="bidiIndex">
               <h3>
                  bidiIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>bidiIndex: 24 blocks, 1536 entries, 1536 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var bidiIndex = [1536]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="bidiIndex">
               <h3>
                  bidiIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>bidiIndex: 24 blocks, 1536 entries, 1536 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var bidiIndex = [1536]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="bidiIndex">
               <h3>
                  bidiIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>bidiIndex: 24 blocks, 1536 entries, 1536 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var bidiIndex = [1536]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="bidiIndex">
               <h3>
                  bidiIndex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>bidiIndex: 26 blocks, 1664 entries, 3328 bytes
Block 0 is the zero block.</p>
               
               <pre><code>var bidiIndex = [1664]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="bidiValues">
               <h3>
                  bidiValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>bidiValues: 234 blocks, 14976 entries, 14976 bytes
The third block is the zero block.</p>
               
               <pre><code>var bidiValues = [14976]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="bidiValues">
               <h3>
                  bidiValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>bidiValues: 248 blocks, 15872 entries, 15872 bytes
The third block is the zero block.</p>
               
               <pre><code>var bidiValues = [15872]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="bidiValues">
               <h3>
                  bidiValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>bidiValues: 222 blocks, 14208 entries, 14208 bytes
The third block is the zero block.</p>
               
               <pre><code>var bidiValues = [14208]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="bidiValues">
               <h3>
                  bidiValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>bidiValues: 228 blocks, 14592 entries, 14592 bytes
The third block is the zero block.</p>
               
               <pre><code>var bidiValues = [14592]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="bidiValues">
               <h3>
                  bidiValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>bidiValues: 240 blocks, 15360 entries, 15360 bytes
The third block is the zero block.</p>
               
               <pre><code>var bidiValues = [15360]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="bidiValues">
               <h3>
                  bidiValues 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>bidiValues: 259 blocks, 16576 entries, 16576 bytes
The third block is the zero block.</p>
               
               <pre><code>var bidiValues = [16576]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="bpClose">
               <h3>
                  bpClose 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const bpClose</code></pre>
            </article>
            
            <article class="global" data-name="bpNone">
               <h3>
                  bpNone 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const bpNone bracketType = iota</code></pre>
            </article>
            
            <article class="global" data-name="bpOpen">
               <h3>
                  bpOpen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const bpOpen</code></pre>
            </article>
            
            <article class="global" data-name="controlByteToClass">
               <h3>
                  controlByteToClass 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var controlByteToClass = [16]Class{...}</code></pre>
            </article>
            
            <article class="global" data-name="implicitLevel">
               <h3>
                  implicitLevel 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const implicitLevel level = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxDepth">
               <h3>
                  maxDepth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxDepth = 125</code></pre>
            </article>
            
            <article class="global" data-name="maxPairingDepth">
               <h3>
                  maxPairingDepth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxPairingDepth = 63</code></pre>
            </article>
            
            <article class="global" data-name="numClass">
               <h3>
                  numClass 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const numClass</code></pre>
            </article>
            
            <article class="global" data-name="openMask">
               <h3>
                  openMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const openMask = 0x10</code></pre>
            </article>
            
            <article class="global" data-name="trie">
               <h3>
                  trie 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var trie = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="unknownClass">
               <h3>
                  unknownClass 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const unknownClass = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="xorMaskShift">
               <h3>
                  xorMaskShift 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const xorMaskShift = 5</code></pre>
            </article>
            
            <article class="global" data-name="xorMasks">
               <h3>
                  xorMasks 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>xorMasks contains masks to be xor-ed with brackets to get the reverse
version.</p>
               
               <pre><code>var xorMasks = []int32{...}</code></pre>
            </article>
            
            <article class="global" data-name="xorMasks">
               <h3>
                  xorMasks 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>xorMasks contains masks to be xor-ed with brackets to get the reverse
version.</p>
               
               <pre><code>var xorMasks = []int32{...}</code></pre>
            </article>
            
            <article class="global" data-name="xorMasks">
               <h3>
                  xorMasks 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>xorMasks contains masks to be xor-ed with brackets to get the reverse
version.</p>
               
               <pre><code>var xorMasks = []int32{...}</code></pre>
            </article>
            
            <article class="global" data-name="xorMasks">
               <h3>
                  xorMasks 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>xorMasks contains masks to be xor-ed with brackets to get the reverse
version.</p>
               
               <pre><code>var xorMasks = []int32{...}</code></pre>
            </article>
            
            <article class="global" data-name="xorMasks">
               <h3>
                  xorMasks 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>xorMasks contains masks to be xor-ed with brackets to get the reverse
version.</p>
               
               <pre><code>var xorMasks = []int32{...}</code></pre>
            </article>
            
            <article class="global" data-name="xorMasks">
               <h3>
                  xorMasks 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>xorMasks contains masks to be xor-ed with brackets to get the reverse
version.</p>
               
               <pre><code>var xorMasks = []int32{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="Class">
               <h3>
                  Class
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Class is the Unicode BiDi class. Each rune has a single class.</p>
               
               <pre><code>type Class uint</code></pre>
            </article>
            
            <article class="type" data-name="Direction">
               <h3>
                  Direction
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Direction indicates the overall flow of text.</p>
               
               <pre><code>type Direction int</code></pre>
            </article>
            
            <article class="type" data-name="Option">
               <h3>
                  Option
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An Option is an option for Bidi processing.</p>
               
               <pre><code>type Option func(*options)</code></pre>
            </article>
            
            <article class="type" data-name="bracketPairs">
               <h3>
                  bracketPairs
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>bracketPairs is a slice of bracketPairs with a sort.Interface implementation.</p>
               
               <pre><code>type bracketPairs []bracketPair</code></pre>
            </article>
            
            <article class="type" data-name="bracketType">
               <h3>
                  bracketType
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Bidi_Paired_Bracket_Type
BD14. An opening paired bracket is a character whose
Bidi_Paired_Bracket_Type property value is Open.
BD15. A closing paired bracket is a character whose
Bidi_Paired_Bracket_Type property value is Close.</p>
               
               <pre><code>type bracketType byte</code></pre>
            </article>
            
            <article class="type" data-name="level">
               <h3>
                  level
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>level is the embedding level of a character. Even embedding levels indicate
left-to-right order and odd levels indicate right-to-left order. The special
level of -1 is reserved for undefined order.</p>
               
               <pre><code>type level int8</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Ordering">
               <h3>
                  Ordering
                  <span class="badge">struct</span>
               </h3>
               
               <p>An Ordering holds the computed visual order of runs of a Paragraph. Calling
SetBytes or SetString on the originating Paragraph invalidates an Ordering.
The methods of an Ordering should only be called by one goroutine at a time.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Ordering struct {
runes [][]rune
directions []Direction
startpos []int
}</code></pre>
            </article>
            
            <article class="struct" data-name="Paragraph">
               <h3>
                  Paragraph
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Paragraph holds a single Paragraph for Bidi processing.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Paragraph struct {
p []byte
o Ordering
opts []Option
types []Class
pairTypes []bracketType
pairValues []rune
runes []rune
options options
}</code></pre>
            </article>
            
            <article class="struct" data-name="Properties">
               <h3>
                  Properties
                  <span class="badge">struct</span>
               </h3>
               
               <p>Properties provides access to BiDi properties of runes.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Properties struct {
entry uint8
last uint8
}</code></pre>
            </article>
            
            <article class="struct" data-name="Run">
               <h3>
                  Run
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Run is a continuous sequence of characters of a single direction.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Run struct {
runes []rune
direction Direction
startpos int
}</code></pre>
            </article>
            
            <article class="struct" data-name="bidiTrie">
               <h3>
                  bidiTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>bidiTrie. Total size: 17408 bytes (17.00 KiB). Checksum: df85fcbfe9b8377f.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type bidiTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="bidiTrie">
               <h3>
                  bidiTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>bidiTrie. Total size: 15744 bytes (15.38 KiB). Checksum: b4c3b70954803b86.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type bidiTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="bidiTrie">
               <h3>
                  bidiTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>bidiTrie. Total size: 19904 bytes (19.44 KiB). Checksum: b1f201ed2debb6c8.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type bidiTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="bidiTrie">
               <h3>
                  bidiTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>bidiTrie. Total size: 16128 bytes (15.75 KiB). Checksum: 8122d83e461996f.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type bidiTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="bidiTrie">
               <h3>
                  bidiTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>bidiTrie. Total size: 16512 bytes (16.12 KiB). Checksum: 2a9cf1317f2ffaa.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type bidiTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="bidiTrie">
               <h3>
                  bidiTrie
                  <span class="badge">struct</span>
               </h3>
               
               <p>bidiTrie. Total size: 16896 bytes (16.50 KiB). Checksum: 6f0927067913dc6d.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type bidiTrie struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="bracketPair">
               <h3>
                  bracketPair
                  <span class="badge">struct</span>
               </h3>
               
               <p>bracketPair holds a pair of index values for opening and closing bracket
location of a bracket pair.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type bracketPair struct {
opener int
closer int
}</code></pre>
            </article>
            
            <article class="struct" data-name="bracketPairer">
               <h3>
                  bracketPairer
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type bracketPairer struct {
sos Class
openers *list.List
pairPositions bracketPairs
codesIsolatedRun []Class
indexes []int
}</code></pre>
            </article>
            
            <article class="struct" data-name="directionalStatusStack">
               <h3>
                  directionalStatusStack
                  <span class="badge">struct</span>
               </h3>
               
               <p>This stack will store the embedding levels and override and isolated
statuses</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type directionalStatusStack struct {
stackCounter int
embeddingLevelStack [*ast.BinaryExpr]level
overrideStatusStack [*ast.BinaryExpr]Class
isolateStatusStack [*ast.BinaryExpr]bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="isolatingRunSequence">
               <h3>
                  isolatingRunSequence
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type isolatingRunSequence struct {
p *paragraph
indexes []int
types []Class
resolvedLevels []level
level level
sos Class
eos Class
}</code></pre>
            </article>
            
            <article class="struct" data-name="options">
               <h3>
                  options
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type options struct {
defaultDirection Direction
}</code></pre>
            </article>
            
            <article class="struct" data-name="paragraph">
               <h3>
                  paragraph
                  <span class="badge">struct</span>
               </h3>
               
               <p>A paragraph contains the state of a paragraph.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type paragraph struct {
initialTypes []Class
pairTypes []bracketType
pairValues []rune
embeddingLevel level
resultTypes []Class
resultLevels []level
matchingPDI []int
matchingIsolateInitiator []int
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="AppendReverse">
               <h3>
                  AppendReverse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AppendReverse reverses the order of characters of in, appends them to out,
and returns the result. Modifiers will still follow the runes they modify.
Brackets are replaced with their counterparts.</p>
               
               <pre><code>func AppendReverse(out []byte, in []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bytes returns the text of the run in its original order.</p>
               
               <pre><code>func (r *Run) Bytes() []byte</code></pre>
            </article>
            
            <article class="function" data-name="Class">
               <h3>
                  Class 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Class returns the Bidi class for p.</p>
               
               <pre><code>func (p Properties) Class() Class</code></pre>
            </article>
            
            <article class="function" data-name="DefaultDirection">
               <h3>
                  DefaultDirection 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DefaultDirection sets the default direction for a Paragraph. The direction is
overridden if the text contains directional characters.</p>
               
               <pre><code>func DefaultDirection(d Direction) Option</code></pre>
            </article>
            
            <article class="function" data-name="Direction">
               <h3>
                  Direction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Direction reports the directionality of the runs.
The direction may be LeftToRight, RightToLeft, Mixed, or Neutral.</p>
               
               <pre><code>func (o *Ordering) Direction() Direction</code></pre>
            </article>
            
            <article class="function" data-name="Direction">
               <h3>
                  Direction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Direction returns the direction of the text of this paragraph.
The direction may be LeftToRight, RightToLeft, Mixed, or Neutral.</p>
               
               <pre><code>func (p *Paragraph) Direction() Direction</code></pre>
            </article>
            
            <article class="function" data-name="Direction">
               <h3>
                  Direction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Direction reports the direction of the run.</p>
               
               <pre><code>func (r *Run) Direction() Direction</code></pre>
            </article>
            
            <article class="function" data-name="IsBracket">
               <h3>
                  IsBracket 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsBracket reports whether the rune is a bracket.</p>
               
               <pre><code>func (p Properties) IsBracket() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsLeftToRight">
               <h3>
                  IsLeftToRight 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsLeftToRight reports whether the principle direction of rendering for this
paragraphs is left-to-right. If this returns false, the principle direction
of rendering is right-to-left.</p>
               
               <pre><code>func (p *Paragraph) IsLeftToRight() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsOpeningBracket">
               <h3>
                  IsOpeningBracket 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsOpeningBracket reports whether the rune is an opening bracket.
IsBracket must return true.</p>
               
               <pre><code>func (p Properties) IsOpeningBracket() bool</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *paragraph) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i *isolatingRunSequence) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b bracketPairs) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b bracketPairs) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="Line">
               <h3>
                  Line 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Line computes the visual ordering of runs for a single line starting and
ending at the given positions in the original text.</p>
               
               <pre><code>func (p *Paragraph) Line(start int, end int) (Ordering, error)</code></pre>
            </article>
            
            <article class="function" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Lookup returns properties for the first rune in s and the width in bytes of
its encoding. The size will be 0 if s does not hold enough bytes to complete
the encoding.</p>
               
               <pre><code>func Lookup(s []byte) (p Properties, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="LookupRune">
               <h3>
                  LookupRune 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LookupRune returns properties for r.</p>
               
               <pre><code>func LookupRune(r rune) (p Properties, size int)</code></pre>
            </article>
            
            <article class="function" data-name="LookupString">
               <h3>
                  LookupString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LookupString returns properties for the first rune in s and the width in
bytes of its encoding. The size will be 0 if s does not hold enough bytes to
complete the encoding.</p>
               
               <pre><code>func LookupString(s string) (p Properties, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="NumRuns">
               <h3>
                  NumRuns 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NumRuns returns the number of runs.</p>
               
               <pre><code>func (o *Ordering) NumRuns() int</code></pre>
            </article>
            
            <article class="function" data-name="Order">
               <h3>
                  Order 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Order computes the visual ordering of all the runs in a Paragraph.</p>
               
               <pre><code>func (p *Paragraph) Order() (Ordering, error)</code></pre>
            </article>
            
            <article class="function" data-name="Pos">
               <h3>
                  Pos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Pos returns the position of the Run within the text passed to SetBytes or SetString of the
originating Paragraph value.</p>
               
               <pre><code>func (r *Run) Pos() (start int, end int)</code></pre>
            </article>
            
            <article class="function" data-name="ReverseString">
               <h3>
                  ReverseString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ReverseString reverses the order of characters in s and returns a new string.
Modifiers will still follow the runes they modify. Brackets are replaced with
their counterparts.</p>
               
               <pre><code>func ReverseString(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="Run">
               <h3>
                  Run 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Run returns the ith run within the ordering.</p>
               
               <pre><code>func (o *Ordering) Run(i int) Run</code></pre>
            </article>
            
            <article class="function" data-name="RunAt">
               <h3>
                  RunAt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RunAt reports the Run at the given position of the input text.
This method can be used for computing line breaks on paragraphs.</p>
               
               <pre><code>func (p *Paragraph) RunAt(pos int) Run</code></pre>
            </article>
            
            <article class="function" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetBytes configures p for the given paragraph text. It replaces text
previously set by SetBytes or SetString. If b contains a paragraph separator
it will only process the first paragraph and report the number of bytes
consumed from b including this separator. Error may be non-nil if options are
given.</p>
               
               <pre><code>func (p *Paragraph) SetBytes(b []byte, opts ...Option) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="SetString">
               <h3>
                  SetString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetString configures s for the given paragraph text. It replaces text
previously set by SetBytes or SetString. If s contains a paragraph separator
it will only process the first paragraph and report the number of bytes
consumed from s including this separator. Error may be non-nil if options are
given.</p>
               
               <pre><code>func (p *Paragraph) SetString(s string, opts ...Option) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *bracketPair) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the text of the run in its original order.</p>
               
               <pre><code>func (r *Run) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b bracketPairs) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="applyLevelsAndTypes">
               <h3>
                  applyLevelsAndTypes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Applies the levels and types resolved in rules W1-I2 to the
resultLevels array.</p>
               
               <pre><code>func (s *isolatingRunSequence) applyLevelsAndTypes()</code></pre>
            </article>
            
            <article class="function" data-name="assertOnly">
               <h3>
                  assertOnly 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Algorithm validation. Assert that all values in types are in the
provided set.</p>
               
               <pre><code>func (s *isolatingRunSequence) assertOnly(codes ...Class)</code></pre>
            </article>
            
            <article class="function" data-name="assignBracketType">
               <h3>
                  assignBracketType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>assignBracketType implements rule N0 for a single bracket pair.</p>
               
               <pre><code>func (p *bracketPairer) assignBracketType(loc bracketPair, dirEmbed Class, initialTypes []Class)</code></pre>
            </article>
            
            <article class="function" data-name="assignLevelsToCharactersRemovedByX9">
               <h3>
                  assignLevelsToCharactersRemovedByX9 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Assign level information to characters removed by rule X9. This is for
ease of relating the level information to the original input data. Note
that the levels assigned to these codes are arbitrary, they're chosen so
as to avoid breaking level runs.</p>
               
               <pre><code>func (p *paragraph) assignLevelsToCharactersRemovedByX9()</code></pre>
            </article>
            
            <article class="function" data-name="calculateOrdering">
               <h3>
                  calculateOrdering 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func calculateOrdering(levels []level, runes []rune) Ordering</code></pre>
            </article>
            
            <article class="function" data-name="classBeforePair">
               <h3>
                  classBeforePair 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>classBeforePair determines which strong types are present before a Bracket
Pair. Return R or L if strong type found, otherwise ON.</p>
               
               <pre><code>func (p *bracketPairer) classBeforePair(loc bracketPair) Class</code></pre>
            </article>
            
            <article class="function" data-name="classifyPairContent">
               <h3>
                  classifyPairContent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>classifyPairContent reports the strong types contained inside a Bracket Pair,
assuming the given embedding direction.
It returns ON if no strong type is found. If a single strong type is found,
it returns this type. Otherwise it returns the embedding direction.
TODO: use separate type for "strong" directionality.</p>
               
               <pre><code>func (p *bracketPairer) classifyPairContent(loc bracketPair, dirEmbed Class) Class</code></pre>
            </article>
            
            <article class="function" data-name="computeMultilineReordering">
               <h3>
                  computeMultilineReordering 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Return multiline reordering array for a given level array. Reordering
does not occur across a line break.</p>
               
               <pre><code>func computeMultilineReordering(levels []level, linebreaks []int) []int</code></pre>
            </article>
            
            <article class="function" data-name="computeReordering">
               <h3>
                  computeReordering 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Return reordering array for a given level array. This reorders a single
line. The reordering is a visual to logical map. For example, the
leftmost char is string.charAt(order[0]). Rule L2.</p>
               
               <pre><code>func computeReordering(levels []level) []int</code></pre>
            </article>
            
            <article class="function" data-name="depth">
               <h3>
                  depth 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *directionalStatusStack) depth() int</code></pre>
            </article>
            
            <article class="function" data-name="determineExplicitEmbeddingLevels">
               <h3>
                  determineExplicitEmbeddingLevels 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Determine explicit levels using rules X1 - X8</p>
               
               <pre><code>func (p *paragraph) determineExplicitEmbeddingLevels()</code></pre>
            </article>
            
            <article class="function" data-name="determineIsolatingRunSequences">
               <h3>
                  determineIsolatingRunSequences 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Definition BD13. Determine isolating run sequences.</p>
               
               <pre><code>func (p *paragraph) determineIsolatingRunSequences() []*isolatingRunSequence</code></pre>
            </article>
            
            <article class="function" data-name="determineLevelRuns">
               <h3>
                  determineLevelRuns 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>determineLevelRuns returns an array of level runs. Each level run is
described as an array of indexes into the input string.
Determines the level runs. Rule X9 will be applied in determining the
runs, in the way that makes sure the characters that are supposed to be
removed are not included in the runs.</p>
               
               <pre><code>func (p *paragraph) determineLevelRuns() [][]int</code></pre>
            </article>
            
            <article class="function" data-name="determineMatchingIsolates">
               <h3>
                  determineMatchingIsolates 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>determineMatchingIsolates determines the matching PDI for each isolate
initiator and vice versa.
Definition BD9.
At the end of this function:
- The member variable matchingPDI is set to point to the index of the
matching PDI character for each isolate initiator character. If there is
no matching PDI, it is set to the length of the input text. For other
characters, it is set to -1.
- The member variable matchingIsolateInitiator is set to point to the
index of the matching isolate initiator character for each PDI character.
If there is no matching isolate initiator, or the character is not a PDI,
it is set to -1.</p>
               
               <pre><code>func (p *paragraph) determineMatchingIsolates()</code></pre>
            </article>
            
            <article class="function" data-name="determineParagraphEmbeddingLevel">
               <h3>
                  determineParagraphEmbeddingLevel 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>determineParagraphEmbeddingLevel reports the resolved paragraph direction of
the substring limited by the given range [start, end).
Determines the paragraph level based on rules P2, P3. This is also used
in rule X5c to find if an FSI should resolve to LRI or RLI.</p>
               
               <pre><code>func (p *paragraph) determineParagraphEmbeddingLevel(start int, end int) level</code></pre>
            </article>
            
            <article class="function" data-name="empty">
               <h3>
                  empty 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *directionalStatusStack) empty()</code></pre>
            </article>
            
            <article class="function" data-name="findRunLimit">
               <h3>
                  findRunLimit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Return the limit of the run consisting only of the types in validSet
starting at index. This checks the value at index, and will return
index if that value is not in validSet.</p>
               
               <pre><code>func (s *isolatingRunSequence) findRunLimit(index int, validSet ...Class) int</code></pre>
            </article>
            
            <article class="function" data-name="getLevels">
               <h3>
                  getLevels 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>getLevels computes levels array breaking lines at offsets in linebreaks.
Rule L1.
The linebreaks array must include at least one value. The values must be
in strictly increasing order (no duplicates) between 1 and the length of
the text, inclusive. The last value must be the length of the text.</p>
               
               <pre><code>func (p *paragraph) getLevels(linebreaks []int) []level</code></pre>
            </article>
            
            <article class="function" data-name="getReordering">
               <h3>
                  getReordering 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>getReordering returns the reordering of lines from a visual index to a
logical index for line breaks at the given offsets.
Lines are concatenated from left to right. So for example, the fifth
character from the left on the third line is
getReordering(linebreaks)[linebreaks[1] + 4]
(linebreaks[1] is the position after the last character of the second
line, which is also the index of the first character on the third line,
and adding four gets the fifth character from the left).
The linebreaks array must include at least one value. The values must be
in strictly increasing order (no duplicates) between 1 and the length of
the text, inclusive. The last value must be the length of the text.</p>
               
               <pre><code>func (p *paragraph) getReordering(linebreaks []int) []int</code></pre>
            </article>
            
            <article class="function" data-name="getStrongTypeN0">
               <h3>
                  getStrongTypeN0 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>getStrongTypeN0 maps character's directional code to strong type as required
by rule N0.
TODO: have separate type for "strong" directionality.</p>
               
               <pre><code>func (p *bracketPairer) getStrongTypeN0(index int) Class</code></pre>
            </article>
            
            <article class="function" data-name="in">
               <h3>
                  in 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>in returns if x is equal to any of the values in set.</p>
               
               <pre><code>func (c Class) in(set ...Class) bool</code></pre>
            </article>
            
            <article class="function" data-name="isRemovedByX9">
               <h3>
                  isRemovedByX9 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isRemovedByX9 reports whether the type is one of the types removed in X9.</p>
               
               <pre><code>func isRemovedByX9(c Class) bool</code></pre>
            </article>
            
            <article class="function" data-name="isWhitespace">
               <h3>
                  isWhitespace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isWhitespace reports whether the type is considered a whitespace type for the
line break rules.</p>
               
               <pre><code>func isWhitespace(c Class) bool</code></pre>
            </article>
            
            <article class="function" data-name="isolatingRunSequence">
               <h3>
                  isolatingRunSequence 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Rule X10, second bullet: Determine the start-of-sequence (sos) and end-of-sequence (eos) types,
either L or R, for each isolating run sequence.</p>
               
               <pre><code>func (p *paragraph) isolatingRunSequence(indexes []int) *isolatingRunSequence</code></pre>
            </article>
            
            <article class="function" data-name="lastDirectionalIsolateStatus">
               <h3>
                  lastDirectionalIsolateStatus 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *directionalStatusStack) lastDirectionalIsolateStatus() bool</code></pre>
            </article>
            
            <article class="function" data-name="lastDirectionalOverrideStatus">
               <h3>
                  lastDirectionalOverrideStatus 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *directionalStatusStack) lastDirectionalOverrideStatus() Class</code></pre>
            </article>
            
            <article class="function" data-name="lastEmbeddingLevel">
               <h3>
                  lastEmbeddingLevel 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *directionalStatusStack) lastEmbeddingLevel() level</code></pre>
            </article>
            
            <article class="function" data-name="locateBrackets">
               <h3>
                  locateBrackets 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>locateBrackets locates matching bracket pairs according to BD16.
This implementation uses a linked list instead of a stack, because, while
elements are added at the front (like a push) they are not generally removed
in atomic 'pop' operations, reducing the benefit of the stack archetype.</p>
               
               <pre><code>func (p *bracketPairer) locateBrackets(pairTypes []bracketType, pairValues []rune)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *bidiTrie) lookup(s []byte) (v uint8, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *bidiTrie) lookup(s []byte) (v uint8, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *bidiTrie) lookup(s []byte) (v uint8, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *bidiTrie) lookup(s []byte) (v uint8, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *bidiTrie) lookup(s []byte) (v uint8, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *bidiTrie) lookup(s []byte) (v uint8, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *bidiTrie) lookupString(s string) (v uint8, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *bidiTrie) lookupString(s string) (v uint8, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *bidiTrie) lookupString(s string) (v uint8, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *bidiTrie) lookupString(s string) (v uint8, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *bidiTrie) lookupString(s string) (v uint8, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupString">
               <h3>
                  lookupString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupString returns the trie value for the first UTF-8 encoding in s and
the width in bytes of this encoding. The size will be 0 if s does not
hold enough bytes to complete the encoding. len(s) must be greater than 0.</p>
               
               <pre><code>func (t *bidiTrie) lookupString(s string) (v uint8, sz int)</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *bidiTrie) lookupStringUnsafe(s string) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *bidiTrie) lookupStringUnsafe(s string) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *bidiTrie) lookupStringUnsafe(s string) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *bidiTrie) lookupStringUnsafe(s string) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *bidiTrie) lookupStringUnsafe(s string) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupStringUnsafe">
               <h3>
                  lookupStringUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *bidiTrie) lookupStringUnsafe(s string) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *bidiTrie) lookupUnsafe(s []byte) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *bidiTrie) lookupUnsafe(s []byte) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *bidiTrie) lookupUnsafe(s []byte) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *bidiTrie) lookupUnsafe(s []byte) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *bidiTrie) lookupUnsafe(s []byte) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupUnsafe">
               <h3>
                  lookupUnsafe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupUnsafe returns the trie value for the first UTF-8 encoding in s.
s must start with a full and valid UTF-8 encoded rune.</p>
               
               <pre><code>func (t *bidiTrie) lookupUnsafe(s []byte) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *bidiTrie) lookupValue(n uint32, b byte) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *bidiTrie) lookupValue(n uint32, b byte) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *bidiTrie) lookupValue(n uint32, b byte) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *bidiTrie) lookupValue(n uint32, b byte) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *bidiTrie) lookupValue(n uint32, b byte) uint8</code></pre>
            </article>
            
            <article class="function" data-name="lookupValue">
               <h3>
                  lookupValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupValue determines the type of block n and looks up the value for b.</p>
               
               <pre><code>func (t *bidiTrie) lookupValue(n uint32, b byte) uint8</code></pre>
            </article>
            
            <article class="function" data-name="matchOpener">
               <h3>
                  matchOpener 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>matchOpener reports whether characters at given positions form a matching
bracket pair.</p>
               
               <pre><code>func (p *bracketPairer) matchOpener(pairValues []rune, opener int, closer int) bool</code></pre>
            </article>
            
            <article class="function" data-name="maxLevel">
               <h3>
                  maxLevel 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func maxLevel(a level, b level) level</code></pre>
            </article>
            
            <article class="function" data-name="newBidiTrie">
               <h3>
                  newBidiTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newBidiTrie(i int) *bidiTrie</code></pre>
            </article>
            
            <article class="function" data-name="newBidiTrie">
               <h3>
                  newBidiTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newBidiTrie(i int) *bidiTrie</code></pre>
            </article>
            
            <article class="function" data-name="newBidiTrie">
               <h3>
                  newBidiTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newBidiTrie(i int) *bidiTrie</code></pre>
            </article>
            
            <article class="function" data-name="newBidiTrie">
               <h3>
                  newBidiTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newBidiTrie(i int) *bidiTrie</code></pre>
            </article>
            
            <article class="function" data-name="newBidiTrie">
               <h3>
                  newBidiTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newBidiTrie(i int) *bidiTrie</code></pre>
            </article>
            
            <article class="function" data-name="newBidiTrie">
               <h3>
                  newBidiTrie 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newBidiTrie(i int) *bidiTrie</code></pre>
            </article>
            
            <article class="function" data-name="newParagraph">
               <h3>
                  newParagraph 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newParagraph initializes a paragraph. The user needs to supply a few arrays
corresponding to the preprocessed text input. The types correspond to the
Unicode BiDi classes for each rune. pairTypes indicates the bracket type for
each rune. pairValues provides a unique bracket class identifier for each
rune (suggested is the rune of the open bracket for opening and matching
close brackets, after normalization). The embedding levels are optional, but
may be supplied to encode embedding levels of styled text.</p>
               
               <pre><code>func newParagraph(types []Class, pairTypes []bracketType, pairValues []rune, levels level) (*paragraph, error)</code></pre>
            </article>
            
            <article class="function" data-name="pop">
               <h3>
                  pop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *directionalStatusStack) pop()</code></pre>
            </article>
            
            <article class="function" data-name="prepareInput">
               <h3>
                  prepareInput 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Initialize the p.pairTypes, p.pairValues and p.types from the input previously
set by p.SetBytes() or p.SetString(). Also limit the input up to (and including) a paragraph
separator (bidi class B).
The function p.Order() needs these values to be set, so this preparation could be postponed.
But since the SetBytes and SetStrings functions return the length of the input up to the paragraph
separator, the whole input needs to be processed anyway and should not be done twice.
The function has the same return values as SetBytes() / SetString()</p>
               
               <pre><code>func (p *Paragraph) prepareInput() (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *directionalStatusStack) push(level level, overrideStatus Class, isolateStatus bool)</code></pre>
            </article>
            
            <article class="function" data-name="resolveBrackets">
               <h3>
                  resolveBrackets 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>resolveBrackets implements rule N0 for a list of pairs.</p>
               
               <pre><code>func (p *bracketPairer) resolveBrackets(dirEmbed Class, initialTypes []Class)</code></pre>
            </article>
            
            <article class="function" data-name="resolveImplicitLevels">
               <h3>
                  resolveImplicitLevels 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>7) resolving implicit embedding levels Rules I1, I2.</p>
               
               <pre><code>func (s *isolatingRunSequence) resolveImplicitLevels()</code></pre>
            </article>
            
            <article class="function" data-name="resolveNeutralTypes">
               <h3>
                  resolveNeutralTypes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>6) resolving neutral types Rules N1-N2.</p>
               
               <pre><code>func (s *isolatingRunSequence) resolveNeutralTypes()</code></pre>
            </article>
            
            <article class="function" data-name="resolvePairedBrackets">
               <h3>
                  resolvePairedBrackets 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>resolvePairedBrackets runs the paired bracket part of the UBA algorithm.
For each rune, it takes the indexes into the original string, the class the
bracket type (in pairTypes) and the bracket identifier (pairValues). It also
takes the direction type for the start-of-sentence and the embedding level.
The identifiers for bracket types are the rune of the canonicalized opening
bracket for brackets (open or close) or 0 for runes that are not brackets.</p>
               
               <pre><code>func resolvePairedBrackets(s *isolatingRunSequence)</code></pre>
            </article>
            
            <article class="function" data-name="resolveWeakTypes">
               <h3>
                  resolveWeakTypes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Resolving weak types Rules W1-W7.
Note that some weak types (EN, AN) remain after this processing is
complete.</p>
               
               <pre><code>func (s *isolatingRunSequence) resolveWeakTypes()</code></pre>
            </article>
            
            <article class="function" data-name="reverseBracket">
               <h3>
                  reverseBracket 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TODO: find a better API and expose.</p>
               
               <pre><code>func (p Properties) reverseBracket(r rune) rune</code></pre>
            </article>
            
            <article class="function" data-name="run">
               <h3>
                  run 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>The algorithm. Does not include line-based processing (Rules L1, L2).
These are applied later in the line-based phase of the algorithm.</p>
               
               <pre><code>func (p *paragraph) run()</code></pre>
            </article>
            
            <article class="function" data-name="setBracketsToType">
               <h3>
                  setBracketsToType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *bracketPairer) setBracketsToType(loc bracketPair, dirPair Class, initialTypes []Class)</code></pre>
            </article>
            
            <article class="function" data-name="setLevels">
               <h3>
                  setLevels 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setLevels(levels []level, newLevel level)</code></pre>
            </article>
            
            <article class="function" data-name="setTypes">
               <h3>
                  setTypes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func setTypes(types []Class, newType Class)</code></pre>
            </article>
            
            <article class="function" data-name="typeForLevel">
               <h3>
                  typeForLevel 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>typeForLevel reports the strong type (L or R) corresponding to the level.</p>
               
               <pre><code>func typeForLevel(level level) Class</code></pre>
            </article>
            
            <article class="function" data-name="validateLineBreaks">
               <h3>
                  validateLineBreaks 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func validateLineBreaks(linebreaks []int, textLength int) error</code></pre>
            </article>
            
            <article class="function" data-name="validateParagraphEmbeddingLevel">
               <h3>
                  validateParagraphEmbeddingLevel 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func validateParagraphEmbeddingLevel(embeddingLevel level) error</code></pre>
            </article>
            
            <article class="function" data-name="validatePbTypes">
               <h3>
                  validatePbTypes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func validatePbTypes(pairTypes []bracketType) error</code></pre>
            </article>
            
            <article class="function" data-name="validatePbValues">
               <h3>
                  validatePbValues 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func validatePbValues(pairValues []rune, pairTypes []bracketType) error</code></pre>
            </article>
            
            <article class="function" data-name="validateTypes">
               <h3>
                  validateTypes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func validateTypes(types []Class) error</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
