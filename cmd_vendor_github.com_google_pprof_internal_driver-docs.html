<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - driver</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>driver</code>
         </h1>
         <hr />
         
         <article class="global" data-name="tempFiles">
            <h2>tempFiles</h2>
            <hr />
            
            <pre><code>tempFiles []string</code></pre>
         </article>
         
         <article class="global" data-name="tempFilesMu">
            <h2>tempFilesMu</h2>
            <hr />
            
            <pre><code>tempFilesMu</code></pre>
         </article>
         
         <article class="global" data-name="commentStart">
            <h2>commentStart</h2>
            <hr />
            
            <pre><code>commentStart</code></pre>
         </article>
         
         <article class="global" data-name="tailDigitsRE">
            <h2>tailDigitsRE</h2>
            <hr />
            
            <pre><code>tailDigitsRE</code></pre>
         </article>
         
         <article class="global" data-name="generateReportWrapper">
            <h2>generateReportWrapper</h2>
            <hr />
            
            <pre><code>generateReportWrapper</code></pre>
         </article>
         
         <article class="global" data-name="pprofShortcuts">
            <h2>pprofShortcuts</h2>
            <hr />
            
            <pre><code>pprofShortcuts</code></pre>
         </article>
         
         <article class="global" data-name="viewBox">
            <h2>viewBox</h2>
            <hr />
            
            <pre><code>viewBox</code></pre>
         </article>
         
         <article class="global" data-name="graphID">
            <h2>graphID</h2>
            <hr />
            
            <pre><code>graphID</code></pre>
         </article>
         
         <article class="global" data-name="svgClose">
            <h2>svgClose</h2>
            <hr />
            
            <pre><code>svgClose</code></pre>
         </article>
         
         <article class="global" data-name="htmlTemplates">
            <h2>htmlTemplates</h2>
            <hr />
            
            <pre><code>htmlTemplates *template.Template</code></pre>
         </article>
         
         <article class="global" data-name="htmlTemplateInit">
            <h2>htmlTemplateInit</h2>
            <hr />
            
            <pre><code>htmlTemplateInit sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="embeddedFiles">
            <h2>embeddedFiles</h2>
            <hr />
            
            <pre><code>embeddedFiles embed.FS</code></pre>
         </article>
         
         <article class="global" data-name="maxEntries">
            <h2>maxEntries</h2>
            <hr />
            
            <p>maxEntries is the maximum number of entries to print for text interfaces.</p>
            
            <pre><code>maxEntries</code></pre>
         </article>
         
         <article class="global" data-name="usageMsgHdr">
            <h2>usageMsgHdr</h2>
            <hr />
            
            <pre><code>usageMsgHdr</code></pre>
         </article>
         
         <article class="global" data-name="usageMsgSrc">
            <h2>usageMsgSrc</h2>
            <hr />
            
            <pre><code>usageMsgSrc</code></pre>
         </article>
         
         <article class="global" data-name="usageMsgVars">
            <h2>usageMsgVars</h2>
            <hr />
            
            <pre><code>usageMsgVars</code></pre>
         </article>
         
         <article class="global" data-name="testSourceAddress">
            <h2>testSourceAddress</h2>
            <hr />
            
            <pre><code>testSourceAddress</code></pre>
         </article>
         
         <article class="global" data-name="interactiveMode">
            <h2>interactiveMode</h2>
            <hr />
            
            <p>interactiveMode is true if pprof is running on interactive mode, reading
commands from its shell.</p>
            
            <pre><code>interactiveMode</code></pre>
         </article>
         
         <article class="global" data-name="pprofCommands">
            <h2>pprofCommands</h2>
            <hr />
            
            <p>pprofCommands are the report generation commands recognized by pprof.</p>
            
            <pre><code>pprofCommands</code></pre>
         </article>
         
         <article class="global" data-name="configHelp">
            <h2>configHelp</h2>
            <hr />
            
            <p>configHelp contains help text per configuration parameter.</p>
            
            <pre><code>configHelp</code></pre>
         </article>
         
         <article class="global" data-name="kcachegrind">
            <h2>kcachegrind</h2>
            <hr />
            
            <pre><code>kcachegrind</code></pre>
         </article>
         
         <article class="global" data-name="currentCfg">
            <h2>currentCfg</h2>
            <hr />
            
            <p>currentConfig holds the current configuration values; it is affected by
flags and interactive assignments.</p>
            
            <pre><code>currentCfg</code></pre>
         </article>
         
         <article class="global" data-name="currentMu">
            <h2>currentMu</h2>
            <hr />
            
            <pre><code>currentMu sync.Mutex</code></pre>
         </article>
         
         <article class="global" data-name="configFields">
            <h2>configFields</h2>
            <hr />
            
            <pre><code>configFields []configField</code></pre>
         </article>
         
         <article class="global" data-name="configFieldMap">
            <h2>configFieldMap</h2>
            <hr />
            
            <p>configFieldMap holds an entry for every config field as well as an
entry for every valid choice for a multi-choice field.</p>
            
            <pre><code>configFieldMap *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="tagFilterRangeRx">
            <h2>tagFilterRangeRx</h2>
            <hr />
            
            <pre><code>tagFilterRangeRx</code></pre>
         </article>
          
         <article class="struct" data-name="webInterface">
            <h2>type webInterface struct</h2>
            <hr />
            
            <p>webInterface holds the state needed for serving a browser based interface.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">prof *profile.Profile
copier profileCopier
options *plugin.Options
help *ast.MapType
settingsFile string</code></pre>
         </article>
         
         <article class="struct" data-name="errorCatcher">
            <h2>type errorCatcher struct</h2>
            <hr />
            
            <p>errorCatcher is a UI that captures errors for reporting to the browser.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">plugin.UI
errors []string</code></pre>
         </article>
         
         <article class="struct" data-name="webArgs">
            <h2>type webArgs struct</h2>
            <hr />
            
            <p>webArgs contains arguments passed to templates in webhtml.go.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Title string
Errors []string
Total int64
SampleTypes []string
Legend []string
DocURL string
Standalone bool
Help *ast.MapType
Nodes []string
HTMLBody template.HTML
TextBody string
Top []report.TextItem
Listing report.WebListData
FlameGraph template.JS
Stacks template.JS
Configs []configMenuEntry
UnitDefs []measurement.UnitType</code></pre>
         </article>
         
         <article class="struct" data-name="source">
            <h2>type source struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Sources []string
ExecName string
BuildID string
Base []string
DiffBase bool
Normalize bool
Seconds int
Timeout int
Symbolize string
HTTPHostport string
HTTPDisableBrowser bool
Comment string</code></pre>
         </article>
         
         <article class="struct" data-name="profileSource">
            <h2>type profileSource struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">addr string
source *source
p *profile.Profile
msrc plugin.MappingSources
remote bool
err error</code></pre>
         </article>
         
         <article class="struct" data-name="GoFlags">
            <h2>type GoFlags struct</h2>
            <hr />
            
            <p>GoFlags implements the plugin.FlagSet interface.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">UsageMsgs []string</code></pre>
         </article>
         
         <article class="struct" data-name="command">
            <h2>type command struct</h2>
            <hr />
            
            <p>command describes the actions for a pprof command. Includes a
function for command-line completion, the report format to use
during report generation, any postprocessing functions, and whether
the command expects a regexp parameter (typically a function name).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">format int
postProcess PostProcessor
visualizer PostProcessor
hasParam bool
description string
usage string</code></pre>
         </article>
         
         <article class="struct" data-name="config">
            <h2>type config struct</h2>
            <hr />
            
            <p>config holds settings for a single named config.
The JSON tag name for a field is used both for JSON encoding and as
a named variable.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Output string
CallTree bool
RelativePercentages bool
Unit string
CompactLabels bool
SourcePath string
TrimPath string
IntelSyntax bool
Mean bool
SampleIndex string
DivideBy float64
Normalize bool
Sort string
TagRoot string
TagLeaf string
DropNegative bool
NodeCount int
NodeFraction float64
EdgeFraction float64
Trim bool
Focus string
Ignore string
PruneFrom string
Hide string
Show string
ShowFrom string
TagFocus string
TagIgnore string
TagShow string
TagHide string
NoInlines bool
ShowColumns bool
Granularity string</code></pre>
         </article>
         
         <article class="struct" data-name="configField">
            <h2>type configField struct</h2>
            <hr />
            
            <p>configField contains metadata for a single configuration field.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
urlparam string
saved bool
field reflect.StructField
choices []string
defaultValue string</code></pre>
         </article>
         
         <article class="struct" data-name="settings">
            <h2>type settings struct</h2>
            <hr />
            
            <p>settings holds pprof settings.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Configs []namedConfig</code></pre>
         </article>
         
         <article class="struct" data-name="namedConfig">
            <h2>type namedConfig struct</h2>
            <hr />
            
            <p>namedConfig associates a name with a config.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name string
config</code></pre>
         </article>
         
         <article class="struct" data-name="configMenuEntry">
            <h2>type configMenuEntry struct</h2>
            <hr />
            
            <p>configMenuEntry holds information for a single config menu entry.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name string
URL string
Current bool
UserConfig bool</code></pre>
         </article>
         
         <article class="struct" data-name="stdUI">
            <h2>type stdUI struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">r *bufio.Reader</code></pre>
         </article>
         
         <article class="struct" data-name="oswriter">
            <h2>type oswriter struct</h2>
            <hr />
            
            <p>oswriter implements the Writer interface using a regular file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
          
         <article class="function" data-name="newTempFile">
            <h2>newTempFile</h2>
            <hr />
            
            <p>newTempFile returns a new output file in dir with the provided prefix and suffix.</p>
            
            <pre><code>func newTempFile(dir string, prefix string, suffix string) (*os.File, error)</code></pre>
         </article>
         
         <article class="function" data-name="deferDeleteTempFile">
            <h2>deferDeleteTempFile</h2>
            <hr />
            
            <p>deferDeleteTempFile marks a file to be deleted by next call to Cleanup()</p>
            
            <pre><code>func deferDeleteTempFile(path string)</code></pre>
         </article>
         
         <article class="function" data-name="cleanupTempFiles">
            <h2>cleanupTempFiles</h2>
            <hr />
            
            <p>cleanupTempFiles removes any temporary files selected for deferred cleaning.</p>
            
            <pre><code>func cleanupTempFiles() error</code></pre>
         </article>
         
         <article class="function" data-name="PProf">
            <h2>PProf</h2>
            <hr />
            
            <p>PProf acquires a profile, and symbolizes it using a profile
manager. Then it generates a report formatted according to the
options selected through the flags package.</p>
            
            <pre><code>func PProf(eo *plugin.Options) error</code></pre>
         </article>
         
         <article class="function" data-name="generateRawReport">
            <h2>generateRawReport</h2>
            <hr />
            
            <p>generateRawReport is allowed to modify p.</p>
            
            <pre><code>func generateRawReport(p *profile.Profile, cmd []string, cfg config, o *plugin.Options) (*command, *report.Report, error)</code></pre>
         </article>
         
         <article class="function" data-name="generateReport">
            <h2>generateReport</h2>
            <hr />
            
            <p>generateReport is allowed to modify p.</p>
            
            <pre><code>func generateReport(p *profile.Profile, cmd []string, cfg config, o *plugin.Options) error</code></pre>
         </article>
         
         <article class="function" data-name="printWebList">
            <h2>printWebList</h2>
            <hr />
            
            <pre><code>func printWebList(dst io.Writer, rpt *report.Report, obj plugin.ObjTool) error</code></pre>
         </article>
         
         <article class="function" data-name="applyCommandOverrides">
            <h2>applyCommandOverrides</h2>
            <hr />
            
            <pre><code>func applyCommandOverrides(cmd string, outputFormat int, cfg config) config</code></pre>
         </article>
         
         <article class="function" data-name="generateTagRootsLeaves">
            <h2>generateTagRootsLeaves</h2>
            <hr />
            
            <p>generateTagRootsLeaves generates extra nodes from the tagroot and tagleaf options.</p>
            
            <pre><code>func generateTagRootsLeaves(prof *profile.Profile, cfg config, ui plugin.UI)</code></pre>
         </article>
         
         <article class="function" data-name="dropEmptyStrings">
            <h2>dropEmptyStrings</h2>
            <hr />
            
            <p>dropEmptyStrings filters a slice to only non-empty strings</p>
            
            <pre><code>func dropEmptyStrings(in []string) out []string</code></pre>
         </article>
         
         <article class="function" data-name="aggregate">
            <h2>aggregate</h2>
            <hr />
            
            <pre><code>func aggregate(prof *profile.Profile, cfg config) error</code></pre>
         </article>
         
         <article class="function" data-name="reportOptions">
            <h2>reportOptions</h2>
            <hr />
            
            <pre><code>func reportOptions(p *profile.Profile, numLabelUnits *ast.MapType, cfg config) (*report.Options, error)</code></pre>
         </article>
         
         <article class="function" data-name="identifyNumLabelUnits">
            <h2>identifyNumLabelUnits</h2>
            <hr />
            
            <p>identifyNumLabelUnits returns a map of numeric label keys to the units
associated with those keys.</p>
            
            <pre><code>func identifyNumLabelUnits(p *profile.Profile, ui plugin.UI) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="sampleFormat">
            <h2>sampleFormat</h2>
            <hr />
            
            <p>sampleFormat returns a function to extract values out of a profile.Sample,
and the type/units of those values.</p>
            
            <pre><code>func sampleFormat(p *profile.Profile, sampleIndex string, mean bool) (value sampleValueFunc, meanDiv sampleValueFunc, v *profile.ValueType, err error)</code></pre>
         </article>
         
         <article class="function" data-name="valueExtractor">
            <h2>valueExtractor</h2>
            <hr />
            
            <pre><code>func valueExtractor(ix int) sampleValueFunc</code></pre>
         </article>
         
         <article class="function" data-name="makeProfileCopier">
            <h2>makeProfileCopier</h2>
            <hr />
            
            <pre><code>func makeProfileCopier(src *profile.Profile) profileCopier</code></pre>
         </article>
         
         <article class="function" data-name="newCopy">
            <h2>newCopy</h2>
            <hr />
            
            <p>newCopy returns a new copy of the profile.</p>
            
            <pre><code>func newCopy() *profile.Profile</code></pre>
         </article>
         
         <article class="function" data-name="interactive">
            <h2>interactive</h2>
            <hr />
            
            <p>interactive starts a shell to read pprof commands.</p>
            
            <pre><code>func interactive(p *profile.Profile, o *plugin.Options) error</code></pre>
         </article>
         
         <article class="function" data-name="greetings">
            <h2>greetings</h2>
            <hr />
            
            <p>greetings prints a brief welcome and some overall profile
information before accepting interactive commands.</p>
            
            <pre><code>func greetings(p *profile.Profile, ui plugin.UI)</code></pre>
         </article>
         
         <article class="function" data-name="expand">
            <h2>expand</h2>
            <hr />
            
            <pre><code>func expand(input string) []string</code></pre>
         </article>
         
         <article class="function" data-name="profileShortcuts">
            <h2>profileShortcuts</h2>
            <hr />
            
            <p>profileShortcuts creates macros for convenience and backward compatibility.</p>
            
            <pre><code>func profileShortcuts(p *profile.Profile) shortcuts</code></pre>
         </article>
         
         <article class="function" data-name="sampleTypes">
            <h2>sampleTypes</h2>
            <hr />
            
            <pre><code>func sampleTypes(p *profile.Profile) []string</code></pre>
         </article>
         
         <article class="function" data-name="printCurrentOptions">
            <h2>printCurrentOptions</h2>
            <hr />
            
            <pre><code>func printCurrentOptions(p *profile.Profile, ui plugin.UI)</code></pre>
         </article>
         
         <article class="function" data-name="parseCommandLine">
            <h2>parseCommandLine</h2>
            <hr />
            
            <p>parseCommandLine parses a command and returns the pprof command to
execute and the configuration to use for the report.</p>
            
            <pre><code>func parseCommandLine(input []string) ([]string, config, error)</code></pre>
         </article>
         
         <article class="function" data-name="catRegex">
            <h2>catRegex</h2>
            <hr />
            
            <pre><code>func catRegex(a string, b string) string</code></pre>
         </article>
         
         <article class="function" data-name="commandHelp">
            <h2>commandHelp</h2>
            <hr />
            
            <p>commandHelp displays help and usage information for all Commands
and Variables or a specific Command or Variable.</p>
            
            <pre><code>func commandHelp(args string, ui plugin.UI)</code></pre>
         </article>
         
         <article class="function" data-name="newCompleter">
            <h2>newCompleter</h2>
            <hr />
            
            <p>newCompleter creates an autocompletion function for a set of commands.</p>
            
            <pre><code>func newCompleter(fns []string) func</code></pre>
         </article>
         
         <article class="function" data-name="matchVariableOrCommand">
            <h2>matchVariableOrCommand</h2>
            <hr />
            
            <p>matchVariableOrCommand attempts to match a string token to the prefix of a Command.</p>
            
            <pre><code>func matchVariableOrCommand(token string) string</code></pre>
         </article>
         
         <article class="function" data-name="functionCompleter">
            <h2>functionCompleter</h2>
            <hr />
            
            <p>functionCompleter replaces provided substring with a function
name retrieved from a profile if a single match exists. Otherwise,
it returns unchanged substring. It defaults to no-op if the profile
is not specified.</p>
            
            <pre><code>func functionCompleter(substring string, fns []string) string</code></pre>
         </article>
         
         <article class="function" data-name="functionNames">
            <h2>functionNames</h2>
            <hr />
            
            <pre><code>func functionNames(p *profile.Profile) []string</code></pre>
         </article>
         
         <article class="function" data-name="massageSVG">
            <h2>massageSVG</h2>
            <hr />
            
            <p>massageSVG enhances the SVG output from DOT to provide better
panning inside a web browser. It uses the svgpan library, which is
embedded into the svgpan.JSSource variable.</p>
            
            <pre><code>func massageSVG(svg string) string</code></pre>
         </article>
         
         <article class="function" data-name="addLabelNodes">
            <h2>addLabelNodes</h2>
            <hr />
            
            <p>addLabelNodes adds pseudo stack frames "label:value" to each Sample with
labels matching the supplied keys.

rootKeys adds frames at the root of the callgraph (first key becomes new root).
leafKeys adds frames at the leaf of the callgraph (last key becomes new leaf).

Returns whether there were matches found for the label keys.</p>
            
            <pre><code>func addLabelNodes(p *profile.Profile, rootKeys []string, leafKeys []string, outputUnit string) (rootm bool, leafm bool)</code></pre>
         </article>
         
         <article class="function" data-name="formatLabelValues">
            <h2>formatLabelValues</h2>
            <hr />
            
            <p>formatLabelValues returns all the string and numeric labels in Sample, with
the numeric labels formatted according to outputUnit.</p>
            
            <pre><code>func formatLabelValues(s *profile.Sample, k string, outputUnit string) []string</code></pre>
         </article>
         
         <article class="function" data-name="getHTMLTemplates">
            <h2>getHTMLTemplates</h2>
            <hr />
            
            <p>getHTMLTemplates returns the set of HTML templates used by pprof,
initializing them if necessary.</p>
            
            <pre><code>func getHTMLTemplates() *template.Template</code></pre>
         </article>
         
         <article class="function" data-name="addTemplates">
            <h2>addTemplates</h2>
            <hr />
            
            <p>addTemplates adds a set of template definitions to templates.</p>
            
            <pre><code>func addTemplates(templates *template.Template)</code></pre>
         </article>
         
         <article class="function" data-name="makeWebInterface">
            <h2>makeWebInterface</h2>
            <hr />
            
            <pre><code>func makeWebInterface(p *profile.Profile, copier profileCopier, opt *plugin.Options) (*webInterface, error)</code></pre>
         </article>
         
         <article class="function" data-name="PrintErr">
            <h2>PrintErr</h2>
            <hr />
            
            <pre><code>func PrintErr(args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="serveWebInterface">
            <h2>serveWebInterface</h2>
            <hr />
            
            <pre><code>func serveWebInterface(hostport string, p *profile.Profile, o *plugin.Options, disableBrowser bool) error</code></pre>
         </article>
         
         <article class="function" data-name="getHostAndPort">
            <h2>getHostAndPort</h2>
            <hr />
            
            <pre><code>func getHostAndPort(hostport string) (string, int, error)</code></pre>
         </article>
         
         <article class="function" data-name="defaultWebServer">
            <h2>defaultWebServer</h2>
            <hr />
            
            <pre><code>func defaultWebServer(args *plugin.HTTPServerArgs) error</code></pre>
         </article>
         
         <article class="function" data-name="redirectWithQuery">
            <h2>redirectWithQuery</h2>
            <hr />
            
            <p>redirectWithQuery responds with a given redirect code, preserving query
parameters in the redirect URL. It does not convert relative paths to
absolute paths like http.Redirect does, so that HTTPServerArgs.Handlers can
generate relative redirects that work with the external prefixing.</p>
            
            <pre><code>func redirectWithQuery(path string, code int) http.HandlerFunc</code></pre>
         </article>
         
         <article class="function" data-name="isLocalhost">
            <h2>isLocalhost</h2>
            <hr />
            
            <pre><code>func isLocalhost(host string) bool</code></pre>
         </article>
         
         <article class="function" data-name="openBrowser">
            <h2>openBrowser</h2>
            <hr />
            
            <pre><code>func openBrowser(url string, o *plugin.Options)</code></pre>
         </article>
         
         <article class="function" data-name="makeReport">
            <h2>makeReport</h2>
            <hr />
            
            <p>makeReport generates a report for the specified command.
If configEditor is not null, it is used to edit the config used for the report.</p>
            
            <pre><code>func makeReport(w http.ResponseWriter, req *http.Request, cmd []string, configEditor func) (*report.Report, []string)</code></pre>
         </article>
         
         <article class="function" data-name="renderHTML">
            <h2>renderHTML</h2>
            <hr />
            
            <p>renderHTML generates html using the named template based on the contents of data.</p>
            
            <pre><code>func renderHTML(dst io.Writer, tmpl string, rpt *report.Report, errList []string, legend []string, data webArgs) error</code></pre>
         </article>
         
         <article class="function" data-name="render">
            <h2>render</h2>
            <hr />
            
            <p>render responds with html generated by passing data to the named template.</p>
            
            <pre><code>func render(w http.ResponseWriter, req *http.Request, tmpl string, rpt *report.Report, errList []string, legend []string, data webArgs)</code></pre>
         </article>
         
         <article class="function" data-name="dot">
            <h2>dot</h2>
            <hr />
            
            <p>dot generates a web page containing an svg diagram.</p>
            
            <pre><code>func dot(w http.ResponseWriter, req *http.Request)</code></pre>
         </article>
         
         <article class="function" data-name="dotToSvg">
            <h2>dotToSvg</h2>
            <hr />
            
            <pre><code>func dotToSvg(dot []byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="top">
            <h2>top</h2>
            <hr />
            
            <pre><code>func top(w http.ResponseWriter, req *http.Request)</code></pre>
         </article>
         
         <article class="function" data-name="disasm">
            <h2>disasm</h2>
            <hr />
            
            <p>disasm generates a web page containing disassembly.</p>
            
            <pre><code>func disasm(w http.ResponseWriter, req *http.Request)</code></pre>
         </article>
         
         <article class="function" data-name="source">
            <h2>source</h2>
            <hr />
            
            <p>source generates a web page containing source code annotated with profile
data.</p>
            
            <pre><code>func source(w http.ResponseWriter, req *http.Request)</code></pre>
         </article>
         
         <article class="function" data-name="peek">
            <h2>peek</h2>
            <hr />
            
            <p>peek generates a web page listing callers/callers.</p>
            
            <pre><code>func peek(w http.ResponseWriter, req *http.Request)</code></pre>
         </article>
         
         <article class="function" data-name="saveConfig">
            <h2>saveConfig</h2>
            <hr />
            
            <p>saveConfig saves URL configuration.</p>
            
            <pre><code>func saveConfig(w http.ResponseWriter, req *http.Request)</code></pre>
         </article>
         
         <article class="function" data-name="deleteConfig">
            <h2>deleteConfig</h2>
            <hr />
            
            <p>deleteConfig deletes a configuration.</p>
            
            <pre><code>func deleteConfig(w http.ResponseWriter, req *http.Request)</code></pre>
         </article>
         
         <article class="function" data-name="getFromLegend">
            <h2>getFromLegend</h2>
            <hr />
            
            <p>getFromLegend returns the suffix of an entry in legend that starts
with param.  It returns def if no such entry is found.</p>
            
            <pre><code>func getFromLegend(legend []string, param string, def string) string</code></pre>
         </article>
         
         <article class="function" data-name="parseFlags">
            <h2>parseFlags</h2>
            <hr />
            
            <p>parseFlags parses the command lines through the specified flags package
and returns the source of the profile and optionally the command
for the kind of report to generate (nil for interactive use).</p>
            
            <pre><code>func parseFlags(o *plugin.Options) (*source, []string, error)</code></pre>
         </article>
         
         <article class="function" data-name="addBaseProfiles">
            <h2>addBaseProfiles</h2>
            <hr />
            
            <p>addBaseProfiles adds the list of base profiles or diff base profiles to
the source. This function will return an error if both base and diff base
profiles are specified.</p>
            
            <pre><code>func addBaseProfiles(flagBase []*string, flagDiffBase []*string) error</code></pre>
         </article>
         
         <article class="function" data-name="dropEmpty">
            <h2>dropEmpty</h2>
            <hr />
            
            <p>dropEmpty list takes a slice of string pointers, and outputs a slice of
non-empty strings associated with the flag.</p>
            
            <pre><code>func dropEmpty(list []*string) []string</code></pre>
         </article>
         
         <article class="function" data-name="installConfigFlags">
            <h2>installConfigFlags</h2>
            <hr />
            
            <p>installConfigFlags creates command line flags for configuration
fields and returns a function which can be called after flags have
been parsed to copy any flags specified on the command line to
*cfg.</p>
            
            <pre><code>func installConfigFlags(flag plugin.FlagSet, cfg *config) func</code></pre>
         </article>
         
         <article class="function" data-name="sampleIndex">
            <h2>sampleIndex</h2>
            <hr />
            
            <pre><code>func sampleIndex(flag *bool, si string, sampleType string, option string, ui plugin.UI) string</code></pre>
         </article>
         
         <article class="function" data-name="outputFormat">
            <h2>outputFormat</h2>
            <hr />
            
            <pre><code>func outputFormat(bcmd *ast.MapType, acmd *ast.MapType) (cmd []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="fetchProfiles">
            <h2>fetchProfiles</h2>
            <hr />
            
            <p>fetchProfiles fetches and symbolizes the profiles specified by s.
It will merge all the profiles it is able to retrieve, even if
there are some failures. It will return an error if it is unable to
fetch any profiles.</p>
            
            <pre><code>func fetchProfiles(s *source, o *plugin.Options) (*profile.Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="grabSourcesAndBases">
            <h2>grabSourcesAndBases</h2>
            <hr />
            
            <pre><code>func grabSourcesAndBases(sources []profileSource, bases []profileSource, fetch plugin.Fetcher, obj plugin.ObjTool, ui plugin.UI, tr http.RoundTripper) (*profile.Profile, *profile.Profile, plugin.MappingSources, plugin.MappingSources, bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="chunkedGrab">
            <h2>chunkedGrab</h2>
            <hr />
            
            <p>chunkedGrab fetches the profiles described in source and merges them into
a single profile. It fetches a chunk of profiles concurrently, with a maximum
chunk size to limit its memory usage.</p>
            
            <pre><code>func chunkedGrab(sources []profileSource, fetch plugin.Fetcher, obj plugin.ObjTool, ui plugin.UI, tr http.RoundTripper) (*profile.Profile, plugin.MappingSources, bool, int, error)</code></pre>
         </article>
         
         <article class="function" data-name="concurrentGrab">
            <h2>concurrentGrab</h2>
            <hr />
            
            <p>concurrentGrab fetches multiple profiles concurrently</p>
            
            <pre><code>func concurrentGrab(sources []profileSource, fetch plugin.Fetcher, obj plugin.ObjTool, ui plugin.UI, tr http.RoundTripper) (*profile.Profile, plugin.MappingSources, bool, int, error)</code></pre>
         </article>
         
         <article class="function" data-name="combineProfiles">
            <h2>combineProfiles</h2>
            <hr />
            
            <pre><code>func combineProfiles(profiles []*profile.Profile, msrcs []plugin.MappingSources) (*profile.Profile, plugin.MappingSources, error)</code></pre>
         </article>
         
         <article class="function" data-name="homeEnv">
            <h2>homeEnv</h2>
            <hr />
            
            <pre><code>func homeEnv() string</code></pre>
         </article>
         
         <article class="function" data-name="setTmpDir">
            <h2>setTmpDir</h2>
            <hr />
            
            <p>setTmpDir prepares the directory to use to save profiles retrieved
remotely. It is selected from PPROF_TMPDIR, defaults to $HOME/pprof, and, if
$HOME is not set, falls back to os.TempDir().</p>
            
            <pre><code>func setTmpDir(ui plugin.UI) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="grabProfile">
            <h2>grabProfile</h2>
            <hr />
            
            <p>grabProfile fetches a profile. Returns the profile, sources for the
profile mappings, a bool indicating if the profile was fetched
remotely, and an error.</p>
            
            <pre><code>func grabProfile(s *source, source string, fetcher plugin.Fetcher, obj plugin.ObjTool, ui plugin.UI, tr http.RoundTripper) (p *profile.Profile, msrc plugin.MappingSources, remote bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="collectMappingSources">
            <h2>collectMappingSources</h2>
            <hr />
            
            <p>collectMappingSources saves the mapping sources of a profile.</p>
            
            <pre><code>func collectMappingSources(p *profile.Profile, source string) plugin.MappingSources</code></pre>
         </article>
         
         <article class="function" data-name="unsourceMappings">
            <h2>unsourceMappings</h2>
            <hr />
            
            <p>unsourceMappings iterates over the mappings in a profile and replaces file
set to the remote source URL by collectMappingSources back to empty string.</p>
            
            <pre><code>func unsourceMappings(p *profile.Profile)</code></pre>
         </article>
         
         <article class="function" data-name="locateBinaries">
            <h2>locateBinaries</h2>
            <hr />
            
            <p>locateBinaries searches for binary files listed in the profile and, if found,
updates the profile accordingly.</p>
            
            <pre><code>func locateBinaries(p *profile.Profile, s *source, obj plugin.ObjTool, ui plugin.UI)</code></pre>
         </article>
         
         <article class="function" data-name="fetch">
            <h2>fetch</h2>
            <hr />
            
            <p>fetch fetches a profile from source, within the timeout specified,
producing messages through the ui. It returns the profile and the
url of the actual source of the profile for remote profiles.</p>
            
            <pre><code>func fetch(source string, duration time.Duration, timeout time.Duration, ui plugin.UI, tr http.RoundTripper) (p *profile.Profile, src string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="fetchURL">
            <h2>fetchURL</h2>
            <hr />
            
            <p>fetchURL fetches a profile from a URL using HTTP.</p>
            
            <pre><code>func fetchURL(source string, timeout time.Duration, tr http.RoundTripper) (io.ReadCloser, error)</code></pre>
         </article>
         
         <article class="function" data-name="statusCodeError">
            <h2>statusCodeError</h2>
            <hr />
            
            <pre><code>func statusCodeError(resp *http.Response) error</code></pre>
         </article>
         
         <article class="function" data-name="isPerfFile">
            <h2>isPerfFile</h2>
            <hr />
            
            <p>isPerfFile checks if a file is in perf.data format. It also returns false
if it encounters an error during the check.</p>
            
            <pre><code>func isPerfFile(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="convertPerfData">
            <h2>convertPerfData</h2>
            <hr />
            
            <p>convertPerfData converts the file at path which should be in perf.data format
using the perf_to_profile tool and returns the file containing the
profile.proto formatted data.</p>
            
            <pre><code>func convertPerfData(perfPath string, ui plugin.UI) (*os.File, error)</code></pre>
         </article>
         
         <article class="function" data-name="adjustURL">
            <h2>adjustURL</h2>
            <hr />
            
            <p>adjustURL validates if a profile source is a URL and returns an
cleaned up URL and the timeout to use for retrieval over HTTP.
If the source cannot be recognized as a URL it returns an empty string.</p>
            
            <pre><code>func adjustURL(source string, duration time.Duration, timeout time.Duration) (string, time.Duration)</code></pre>
         </article>
         
         <article class="function" data-name="Bool">
            <h2>Bool</h2>
            <hr />
            
            <p>Bool implements the plugin.FlagSet interface.</p>
            
            <pre><code>func Bool(o string, d bool, c string) *bool</code></pre>
         </article>
         
         <article class="function" data-name="Int">
            <h2>Int</h2>
            <hr />
            
            <p>Int implements the plugin.FlagSet interface.</p>
            
            <pre><code>func Int(o string, d int, c string) *int</code></pre>
         </article>
         
         <article class="function" data-name="Float64">
            <h2>Float64</h2>
            <hr />
            
            <p>Float64 implements the plugin.FlagSet interface.</p>
            
            <pre><code>func Float64(o string, d float64, c string) *float64</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String implements the plugin.FlagSet interface.</p>
            
            <pre><code>func String(o string, d string, c string) *string</code></pre>
         </article>
         
         <article class="function" data-name="StringList">
            <h2>StringList</h2>
            <hr />
            
            <p>StringList implements the plugin.FlagSet interface.</p>
            
            <pre><code>func StringList(o string, d string, c string) *[]*string</code></pre>
         </article>
         
         <article class="function" data-name="ExtraUsage">
            <h2>ExtraUsage</h2>
            <hr />
            
            <p>ExtraUsage implements the plugin.FlagSet interface.</p>
            
            <pre><code>func ExtraUsage() string</code></pre>
         </article>
         
         <article class="function" data-name="AddExtraUsage">
            <h2>AddExtraUsage</h2>
            <hr />
            
            <p>AddExtraUsage implements the plugin.FlagSet interface.</p>
            
            <pre><code>func AddExtraUsage(eu string)</code></pre>
         </article>
         
         <article class="function" data-name="Parse">
            <h2>Parse</h2>
            <hr />
            
            <p>Parse implements the plugin.FlagSet interface.</p>
            
            <pre><code>func Parse(usage func) []string</code></pre>
         </article>
         
         <article class="function" data-name="stackView">
            <h2>stackView</h2>
            <hr />
            
            <p>stackView generates the flamegraph view.</p>
            
            <pre><code>func stackView(w http.ResponseWriter, req *http.Request)</code></pre>
         </article>
         
         <article class="function" data-name="help">
            <h2>help</h2>
            <hr />
            
            <p>help returns a help string for a command.</p>
            
            <pre><code>func help(name string) string</code></pre>
         </article>
         
         <article class="function" data-name="AddCommand">
            <h2>AddCommand</h2>
            <hr />
            
            <p>AddCommand adds an additional command to the set of commands
accepted by pprof. This enables extensions to add new commands for
specialized visualization formats. If the command specified already
exists, it is overwritten.</p>
            
            <pre><code>func AddCommand(cmd string, format int, post PostProcessor, desc string, usage string)</code></pre>
         </article>
         
         <article class="function" data-name="SetVariableDefault">
            <h2>SetVariableDefault</h2>
            <hr />
            
            <p>SetVariableDefault sets the default value for a pprof
variable. This enables extensions to set their own defaults.</p>
            
            <pre><code>func SetVariableDefault(variable string, value string)</code></pre>
         </article>
         
         <article class="function" data-name="helpText">
            <h2>helpText</h2>
            <hr />
            
            <pre><code>func helpText(s ...string) string</code></pre>
         </article>
         
         <article class="function" data-name="usage">
            <h2>usage</h2>
            <hr />
            
            <p>usage returns a string describing the pprof commands and configuration
options.  if commandLine is set, the output reflect cli usage.</p>
            
            <pre><code>func usage(commandLine bool) string</code></pre>
         </article>
         
         <article class="function" data-name="reportHelp">
            <h2>reportHelp</h2>
            <hr />
            
            <pre><code>func reportHelp(c string, cum bool, redirect bool) string</code></pre>
         </article>
         
         <article class="function" data-name="listHelp">
            <h2>listHelp</h2>
            <hr />
            
            <pre><code>func listHelp(c string, redirect bool) string</code></pre>
         </article>
         
         <article class="function" data-name="browsers">
            <h2>browsers</h2>
            <hr />
            
            <p>browsers returns a list of commands to attempt for web visualization.</p>
            
            <pre><code>func browsers() []string</code></pre>
         </article>
         
         <article class="function" data-name="awayFromTTY">
            <h2>awayFromTTY</h2>
            <hr />
            
            <p>awayFromTTY saves the output in a file if it would otherwise go to
the terminal screen. This is used to avoid dumping binary data on
the screen.</p>
            
            <pre><code>func awayFromTTY(format string) PostProcessor</code></pre>
         </article>
         
         <article class="function" data-name="invokeDot">
            <h2>invokeDot</h2>
            <hr />
            
            <pre><code>func invokeDot(format string) PostProcessor</code></pre>
         </article>
         
         <article class="function" data-name="massageDotSVG">
            <h2>massageDotSVG</h2>
            <hr />
            
            <p>massageDotSVG invokes the dot tool to generate an SVG image and alters
the image to have panning capabilities when viewed in a browser.</p>
            
            <pre><code>func massageDotSVG() PostProcessor</code></pre>
         </article>
         
         <article class="function" data-name="invokeVisualizer">
            <h2>invokeVisualizer</h2>
            <hr />
            
            <pre><code>func invokeVisualizer(suffix string, visualizers []string) PostProcessor</code></pre>
         </article>
         
         <article class="function" data-name="stringToBool">
            <h2>stringToBool</h2>
            <hr />
            
            <p>stringToBool is a custom parser for bools. We avoid using strconv.ParseBool
to remain compatible with old pprof behavior (e.g., treating "" as true).</p>
            
            <pre><code>func stringToBool(s string) (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="defaultConfig">
            <h2>defaultConfig</h2>
            <hr />
            
            <p>defaultConfig returns the default configuration values; it is unaffected by
flags and interactive assignments.</p>
            
            <pre><code>func defaultConfig() config</code></pre>
         </article>
         
         <article class="function" data-name="currentConfig">
            <h2>currentConfig</h2>
            <hr />
            
            <pre><code>func currentConfig() config</code></pre>
         </article>
         
         <article class="function" data-name="setCurrentConfig">
            <h2>setCurrentConfig</h2>
            <hr />
            
            <pre><code>func setCurrentConfig(cfg config)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="fieldPtr">
            <h2>fieldPtr</h2>
            <hr />
            
            <p>fieldPtr returns a pointer to the field identified by f in *cfg.</p>
            
            <pre><code>func fieldPtr(f configField) *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="get">
            <h2>get</h2>
            <hr />
            
            <p>get returns the value of field f in cfg.</p>
            
            <pre><code>func get(f configField) string</code></pre>
         </article>
         
         <article class="function" data-name="set">
            <h2>set</h2>
            <hr />
            
            <p>set sets the value of field f in cfg to value.</p>
            
            <pre><code>func set(f configField, value string) error</code></pre>
         </article>
         
         <article class="function" data-name="isConfigurable">
            <h2>isConfigurable</h2>
            <hr />
            
            <p>isConfigurable returns true if name is either the name of a config field, or
a valid value for a multi-choice config field.</p>
            
            <pre><code>func isConfigurable(name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="isBoolConfig">
            <h2>isBoolConfig</h2>
            <hr />
            
            <p>isBoolConfig returns true if name is either name of a boolean config field,
or a valid value for a multi-choice config field.</p>
            
            <pre><code>func isBoolConfig(name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="completeConfig">
            <h2>completeConfig</h2>
            <hr />
            
            <p>completeConfig returns the list of configurable names starting with prefix.</p>
            
            <pre><code>func completeConfig(prefix string) []string</code></pre>
         </article>
         
         <article class="function" data-name="configure">
            <h2>configure</h2>
            <hr />
            
            <p>configure stores the name=value mapping into the current config, correctly
handling the case when name identifies a particular choice in a field.</p>
            
            <pre><code>func configure(name string, value string) error</code></pre>
         </article>
         
         <article class="function" data-name="resetTransient">
            <h2>resetTransient</h2>
            <hr />
            
            <p>resetTransient sets all transient fields in *cfg to their currently
configured values.</p>
            
            <pre><code>func resetTransient()</code></pre>
         </article>
         
         <article class="function" data-name="applyURL">
            <h2>applyURL</h2>
            <hr />
            
            <p>applyURL updates *cfg based on params.</p>
            
            <pre><code>func applyURL(params url.Values) error</code></pre>
         </article>
         
         <article class="function" data-name="makeURL">
            <h2>makeURL</h2>
            <hr />
            
            <p>makeURL returns a URL based on initialURL that contains the config contents
as parameters.  The second result is true iff a parameter value was changed.</p>
            
            <pre><code>func makeURL(initialURL url.URL) (url.URL, bool)</code></pre>
         </article>
         
         <article class="function" data-name="applyFocus">
            <h2>applyFocus</h2>
            <hr />
            
            <p>applyFocus filters samples based on the focus/ignore options</p>
            
            <pre><code>func applyFocus(prof *profile.Profile, numLabelUnits *ast.MapType, cfg config, ui plugin.UI) error</code></pre>
         </article>
         
         <article class="function" data-name="compileRegexOption">
            <h2>compileRegexOption</h2>
            <hr />
            
            <pre><code>func compileRegexOption(name string, value string, err error) (*regexp.Regexp, error)</code></pre>
         </article>
         
         <article class="function" data-name="compileTagFilter">
            <h2>compileTagFilter</h2>
            <hr />
            
            <pre><code>func compileTagFilter(name string, value string, numLabelUnits *ast.MapType, ui plugin.UI, err error) (func, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseTagFilterRange">
            <h2>parseTagFilterRange</h2>
            <hr />
            
            <p>parseTagFilterRange returns a function to checks if a value is
contained on the range described by a string. It can recognize
strings of the form:
"32kb" -- matches values == 32kb
":64kb" -- matches values <= 64kb
"4mb:" -- matches values >= 4mb
"12kb:64mb" -- matches values between 12kb and 64mb (both included).</p>
            
            <pre><code>func parseTagFilterRange(filter string) func</code></pre>
         </article>
         
         <article class="function" data-name="warnNoMatches">
            <h2>warnNoMatches</h2>
            <hr />
            
            <pre><code>func warnNoMatches(match bool, option string, ui plugin.UI)</code></pre>
         </article>
         
         <article class="function" data-name="settingsFileName">
            <h2>settingsFileName</h2>
            <hr />
            
            <p>settingsFileName returns the name of the file where settings should be saved.</p>
            
            <pre><code>func settingsFileName() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="readSettings">
            <h2>readSettings</h2>
            <hr />
            
            <p>readSettings reads settings from fname.</p>
            
            <pre><code>func readSettings(fname string) (*settings, error)</code></pre>
         </article>
         
         <article class="function" data-name="writeSettings">
            <h2>writeSettings</h2>
            <hr />
            
            <p>writeSettings saves settings to fname.</p>
            
            <pre><code>func writeSettings(fname string, settings *settings) error</code></pre>
         </article>
         
         <article class="function" data-name="configMenu">
            <h2>configMenu</h2>
            <hr />
            
            <p>configMenu returns a list of items to add to a menu in the web UI.</p>
            
            <pre><code>func configMenu(fname string, u url.URL) []configMenuEntry</code></pre>
         </article>
         
         <article class="function" data-name="editSettings">
            <h2>editSettings</h2>
            <hr />
            
            <p>editSettings edits settings by applying fn to them.</p>
            
            <pre><code>func editSettings(fname string, fn func) error</code></pre>
         </article>
         
         <article class="function" data-name="setConfig">
            <h2>setConfig</h2>
            <hr />
            
            <p>setConfig saves the config specified in request to fname.</p>
            
            <pre><code>func setConfig(fname string, request url.URL) error</code></pre>
         </article>
         
         <article class="function" data-name="removeConfig">
            <h2>removeConfig</h2>
            <hr />
            
            <p>removeConfig removes config from fname.</p>
            
            <pre><code>func removeConfig(fname string, config string) error</code></pre>
         </article>
         
         <article class="function" data-name="setDefaults">
            <h2>setDefaults</h2>
            <hr />
            
            <p>setDefaults returns a new plugin.Options with zero fields sets to
sensible defaults.</p>
            
            <pre><code>func setDefaults(o *plugin.Options) *plugin.Options</code></pre>
         </article>
         
         <article class="function" data-name="ReadLine">
            <h2>ReadLine</h2>
            <hr />
            
            <pre><code>func ReadLine(prompt string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="Print">
            <h2>Print</h2>
            <hr />
            
            <pre><code>func Print(args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="PrintErr">
            <h2>PrintErr</h2>
            <hr />
            
            <pre><code>func PrintErr(args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="IsTerminal">
            <h2>IsTerminal</h2>
            <hr />
            
            <pre><code>func IsTerminal() bool</code></pre>
         </article>
         
         <article class="function" data-name="WantBrowser">
            <h2>WantBrowser</h2>
            <hr />
            
            <pre><code>func WantBrowser() bool</code></pre>
         </article>
         
         <article class="function" data-name="SetAutoComplete">
            <h2>SetAutoComplete</h2>
            <hr />
            
            <pre><code>func SetAutoComplete(func)</code></pre>
         </article>
         
         <article class="function" data-name="fprint">
            <h2>fprint</h2>
            <hr />
            
            <pre><code>func fprint(f *os.File, args []*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <pre><code>func Open(name string) (io.WriteCloser, error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
