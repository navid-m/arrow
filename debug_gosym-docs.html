<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - gosym</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="debug_gosym_testdata-docs.html">testdata</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>gosym</code>
         </h1>
         <hr />
         
         <article class="global" data-name="verUnknown">
            <h2>verUnknown</h2>
            <hr />
            
            <pre><code>verUnknown version</code></pre>
         </article>
         
         <article class="global" data-name="ver11">
            <h2>ver11</h2>
            <hr />
            
            <pre><code>ver11</code></pre>
         </article>
         
         <article class="global" data-name="ver12">
            <h2>ver12</h2>
            <hr />
            
            <pre><code>ver12</code></pre>
         </article>
         
         <article class="global" data-name="ver116">
            <h2>ver116</h2>
            <hr />
            
            <pre><code>ver116</code></pre>
         </article>
         
         <article class="global" data-name="ver118">
            <h2>ver118</h2>
            <hr />
            
            <pre><code>ver118</code></pre>
         </article>
         
         <article class="global" data-name="ver120">
            <h2>ver120</h2>
            <hr />
            
            <pre><code>ver120</code></pre>
         </article>
         
         <article class="global" data-name="oldQuantum">
            <h2>oldQuantum</h2>
            <hr />
            
            <p>NOTE(rsc): This is wrong for GOARCH=arm, which uses a quantum of 4,
but we have no idea whether we're using arm or not. This only
matters in the old (pre-Go 1.2) symbol table format, so it's not worth
fixing.</p>
            
            <pre><code>oldQuantum</code></pre>
         </article>
         
         <article class="global" data-name="go12magic">
            <h2>go12magic</h2>
            <hr />
            
            <pre><code>go12magic</code></pre>
         </article>
         
         <article class="global" data-name="go116magic">
            <h2>go116magic</h2>
            <hr />
            
            <pre><code>go116magic</code></pre>
         </article>
         
         <article class="global" data-name="go118magic">
            <h2>go118magic</h2>
            <hr />
            
            <pre><code>go118magic</code></pre>
         </article>
         
         <article class="global" data-name="go120magic">
            <h2>go120magic</h2>
            <hr />
            
            <pre><code>go120magic</code></pre>
         </article>
         
         <article class="global" data-name="disableRecover">
            <h2>disableRecover</h2>
            <hr />
            
            <p>disableRecover causes this package not to swallow panics.
This is useful when making changes.</p>
            
            <pre><code>disableRecover</code></pre>
         </article>
         
         <article class="global" data-name="pclineTempDir">
            <h2>pclineTempDir</h2>
            <hr />
            
            <pre><code>pclineTempDir string</code></pre>
         </article>
         
         <article class="global" data-name="pclinetestBinary">
            <h2>pclinetestBinary</h2>
            <hr />
            
            <pre><code>pclinetestBinary string</code></pre>
         </article>
         
         <article class="global" data-name="sinkLineTable">
            <h2>sinkLineTable</h2>
            <hr />
            
            <pre><code>sinkLineTable *LineTable</code></pre>
         </article>
         
         <article class="global" data-name="sinkTable">
            <h2>sinkTable</h2>
            <hr />
            
            <pre><code>sinkTable *Table</code></pre>
         </article>
         
         <article class="global" data-name="littleEndianSymtab">
            <h2>littleEndianSymtab</h2>
            <hr />
            
            <pre><code>littleEndianSymtab</code></pre>
         </article>
         
         <article class="global" data-name="bigEndianSymtab">
            <h2>bigEndianSymtab</h2>
            <hr />
            
            <pre><code>bigEndianSymtab</code></pre>
         </article>
         
         <article class="global" data-name="oldLittleEndianSymtab">
            <h2>oldLittleEndianSymtab</h2>
            <hr />
            
            <pre><code>oldLittleEndianSymtab</code></pre>
         </article>
          
         <article class="struct" data-name="LineTable">
            <h2>type LineTable struct</h2>
            <hr />
            
            <p>A LineTable is a data structure mapping program counters to line numbers.

In Go 1.1 and earlier, each function (represented by a [Func]) had its own LineTable,
and the line number corresponded to a numbering of all source lines in the
program, across all files. That absolute line number would then have to be
converted separately to a file name and line number within the file.

In Go 1.2, the format of the data changed so that there is a single LineTable
for the entire program, shared by all Funcs, and there are no absolute line
numbers, just line numbers within specific files.

For the most part, LineTable's methods should be treated as an internal
detail of the package; callers should use the methods on [Table] instead.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Data []byte
PC uint64
Line int
mu sync.Mutex
version version
binary binary.ByteOrder
quantum uint32
ptrsize uint32
textStart uint64
funcnametab []byte
cutab []byte
funcdata []byte
functab []byte
nfunctab uint32
filetab []byte
pctab []byte
nfiletab uint32
funcNames *ast.MapType
strings *ast.MapType
fileMap *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="funcTab">
            <h2>type funcTab struct</h2>
            <hr />
            
            <p>funcTab is memory corresponding to a slice of functab structs, followed by an invalid PC.
A functab struct is a PC and a func offset.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">*LineTable
sz int</code></pre>
         </article>
         
         <article class="struct" data-name="funcData">
            <h2>type funcData struct</h2>
            <hr />
            
            <p>funcData is memory corresponding to an _func struct.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">t *LineTable
data []byte</code></pre>
         </article>
         
         <article class="struct" data-name="Sym">
            <h2>type Sym struct</h2>
            <hr />
            
            <p>A Sym represents a single symbol table entry.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Value uint64
Type byte
Name string
GoType uint64
Func *Func
goVersion version</code></pre>
         </article>
         
         <article class="struct" data-name="Func">
            <h2>type Func struct</h2>
            <hr />
            
            <p>A Func collects information about a single function.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Entry uint64
*Sym
End uint64
Params []*Sym
Locals []*Sym
FrameSize int
LineTable *LineTable
Obj *Obj</code></pre>
         </article>
         
         <article class="struct" data-name="Obj">
            <h2>type Obj struct</h2>
            <hr />
            
            <p>An Obj represents a collection of functions in a symbol table.

The exact method of division of a binary into separate Objs is an internal detail
of the symbol table format.

In early versions of Go each source file became a different Obj.

In Go 1 and Go 1.1, each package produced one Obj for all Go sources
and one Obj per C source file.

In Go 1.2, there is a single Obj for the entire program.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Funcs []Func
Paths []Sym</code></pre>
         </article>
         
         <article class="struct" data-name="Table">
            <h2>type Table struct</h2>
            <hr />
            
            <p>Table represents a Go symbol table. It stores all of the
symbols decoded from the program and provides methods to translate
between symbols, names, and addresses.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Syms []Sym
Funcs []Func
Files *ast.MapType
Objs []Obj
go12line *LineTable</code></pre>
         </article>
         
         <article class="struct" data-name="sym">
            <h2>type sym struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">value uint64
gotype uint64
typ byte
name []byte</code></pre>
         </article>
         
         <article class="struct" data-name="UnknownLineError">
            <h2>type UnknownLineError struct</h2>
            <hr />
            
            <p>UnknownLineError represents a failure to map a line to a program
counter, either because the line is beyond the bounds of the file
or because there is no code on the given line.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">File string
Line int</code></pre>
         </article>
         
         <article class="struct" data-name="DecodingError">
            <h2>type DecodingError struct</h2>
            <hr />
            
            <p>DecodingError represents an error during the decoding of
the symbol table.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">off int
msg string
val any</code></pre>
         </article>
          
         <article class="function" data-name="parse">
            <h2>parse</h2>
            <hr />
            
            <pre><code>func parse(targetPC uint64, targetLine int) (b []byte, pc uint64, line int)</code></pre>
         </article>
         
         <article class="function" data-name="slice">
            <h2>slice</h2>
            <hr />
            
            <pre><code>func slice(pc uint64) *LineTable</code></pre>
         </article>
         
         <article class="function" data-name="PCToLine">
            <h2>PCToLine</h2>
            <hr />
            
            <p>PCToLine returns the line number for the given program counter.

Deprecated: Use Table's PCToLine method instead.</p>
            
            <pre><code>func PCToLine(pc uint64) int</code></pre>
         </article>
         
         <article class="function" data-name="LineToPC">
            <h2>LineToPC</h2>
            <hr />
            
            <p>LineToPC returns the program counter for the given line number,
considering only program counters before maxpc.

Deprecated: Use Table's LineToPC method instead.</p>
            
            <pre><code>func LineToPC(line int, maxpc uint64) uint64</code></pre>
         </article>
         
         <article class="function" data-name="NewLineTable">
            <h2>NewLineTable</h2>
            <hr />
            
            <p>NewLineTable returns a new PC/line table
corresponding to the encoded data.
Text must be the start address of the
corresponding text segment, with the exact
value stored in the 'runtime.text' symbol.
This value may differ from the start
address of the text segment if
binary was built with cgo enabled.</p>
            
            <pre><code>func NewLineTable(data []byte, text uint64) *LineTable</code></pre>
         </article>
         
         <article class="function" data-name="isGo12">
            <h2>isGo12</h2>
            <hr />
            
            <p>isGo12 reports whether this is a Go 1.2 (or later) symbol table.</p>
            
            <pre><code>func isGo12() bool</code></pre>
         </article>
         
         <article class="function" data-name="uintptr">
            <h2>uintptr</h2>
            <hr />
            
            <p>uintptr returns the pointer-sized value encoded at b.
The pointer size is dictated by the table being read.</p>
            
            <pre><code>func uintptr(b []byte) uint64</code></pre>
         </article>
         
         <article class="function" data-name="parsePclnTab">
            <h2>parsePclnTab</h2>
            <hr />
            
            <p>parsePclnTab parses the pclntab, setting the version.</p>
            
            <pre><code>func parsePclnTab()</code></pre>
         </article>
         
         <article class="function" data-name="go12Funcs">
            <h2>go12Funcs</h2>
            <hr />
            
            <p>go12Funcs returns a slice of Funcs derived from the Go 1.2+ pcln table.</p>
            
            <pre><code>func go12Funcs() []Func</code></pre>
         </article>
         
         <article class="function" data-name="findFunc">
            <h2>findFunc</h2>
            <hr />
            
            <p>findFunc returns the funcData corresponding to the given program counter.</p>
            
            <pre><code>func findFunc(pc uint64) funcData</code></pre>
         </article>
         
         <article class="function" data-name="readvarint">
            <h2>readvarint</h2>
            <hr />
            
            <p>readvarint reads, removes, and returns a varint from *pp.</p>
            
            <pre><code>func readvarint(pp *[]byte) uint32</code></pre>
         </article>
         
         <article class="function" data-name="funcName">
            <h2>funcName</h2>
            <hr />
            
            <p>funcName returns the name of the function found at off.</p>
            
            <pre><code>func funcName(off uint32) string</code></pre>
         </article>
         
         <article class="function" data-name="stringFrom">
            <h2>stringFrom</h2>
            <hr />
            
            <p>stringFrom returns a Go string found at off from a position.</p>
            
            <pre><code>func stringFrom(arr []byte, off uint32) string</code></pre>
         </article>
         
         <article class="function" data-name="string">
            <h2>string</h2>
            <hr />
            
            <p>string returns a Go string found at off.</p>
            
            <pre><code>func string(off uint32) string</code></pre>
         </article>
         
         <article class="function" data-name="functabFieldSize">
            <h2>functabFieldSize</h2>
            <hr />
            
            <p>functabFieldSize returns the size in bytes of a single functab field.</p>
            
            <pre><code>func functabFieldSize() int</code></pre>
         </article>
         
         <article class="function" data-name="funcTab">
            <h2>funcTab</h2>
            <hr />
            
            <p>funcTab returns t's funcTab.</p>
            
            <pre><code>func funcTab() funcTab</code></pre>
         </article>
         
         <article class="function" data-name="Count">
            <h2>Count</h2>
            <hr />
            
            <p>Count returns the number of func entries in f.</p>
            
            <pre><code>func Count() int</code></pre>
         </article>
         
         <article class="function" data-name="pc">
            <h2>pc</h2>
            <hr />
            
            <p>pc returns the PC of the i'th func in f.</p>
            
            <pre><code>func pc(i int) uint64</code></pre>
         </article>
         
         <article class="function" data-name="funcOff">
            <h2>funcOff</h2>
            <hr />
            
            <p>funcOff returns the funcdata offset of the i'th func in f.</p>
            
            <pre><code>func funcOff(i int) uint64</code></pre>
         </article>
         
         <article class="function" data-name="uint">
            <h2>uint</h2>
            <hr />
            
            <p>uint returns the uint stored at b.</p>
            
            <pre><code>func uint(b []byte) uint64</code></pre>
         </article>
         
         <article class="function" data-name="funcData">
            <h2>funcData</h2>
            <hr />
            
            <p>funcData returns the ith funcData in t.functab.</p>
            
            <pre><code>func funcData(i uint32) funcData</code></pre>
         </article>
         
         <article class="function" data-name="IsZero">
            <h2>IsZero</h2>
            <hr />
            
            <p>IsZero reports whether f is the zero value.</p>
            
            <pre><code>func IsZero() bool</code></pre>
         </article>
         
         <article class="function" data-name="entryPC">
            <h2>entryPC</h2>
            <hr />
            
            <p>entryPC returns the func's entry PC.</p>
            
            <pre><code>func entryPC() uint64</code></pre>
         </article>
         
         <article class="function" data-name="nameOff">
            <h2>nameOff</h2>
            <hr />
            
            <pre><code>func nameOff() uint32</code></pre>
         </article>
         
         <article class="function" data-name="deferreturn">
            <h2>deferreturn</h2>
            <hr />
            
            <pre><code>func deferreturn() uint32</code></pre>
         </article>
         
         <article class="function" data-name="pcfile">
            <h2>pcfile</h2>
            <hr />
            
            <pre><code>func pcfile() uint32</code></pre>
         </article>
         
         <article class="function" data-name="pcln">
            <h2>pcln</h2>
            <hr />
            
            <pre><code>func pcln() uint32</code></pre>
         </article>
         
         <article class="function" data-name="cuOffset">
            <h2>cuOffset</h2>
            <hr />
            
            <pre><code>func cuOffset() uint32</code></pre>
         </article>
         
         <article class="function" data-name="field">
            <h2>field</h2>
            <hr />
            
            <p>field returns the nth field of the _func struct.
It panics if n == 0 or n > 9; for n == 0, call f.entryPC.
Most callers should use a named field accessor (just above).</p>
            
            <pre><code>func field(n uint32) uint32</code></pre>
         </article>
         
         <article class="function" data-name="step">
            <h2>step</h2>
            <hr />
            
            <p>step advances to the next pc, value pair in the encoded table.</p>
            
            <pre><code>func step(p *[]byte, pc *uint64, val *int32, first bool) bool</code></pre>
         </article>
         
         <article class="function" data-name="pcvalue">
            <h2>pcvalue</h2>
            <hr />
            
            <p>pcvalue reports the value associated with the target pc.
off is the offset to the beginning of the pc-value table,
and entry is the start PC for the corresponding function.</p>
            
            <pre><code>func pcvalue(off uint32, entry uint64, targetpc uint64) int32</code></pre>
         </article>
         
         <article class="function" data-name="findFileLine">
            <h2>findFileLine</h2>
            <hr />
            
            <p>findFileLine scans one function in the binary looking for a
program counter in the given file on the given line.
It does so by running the pc-value tables mapping program counter
to file number. Since most functions come from a single file, these
are usually short and quick to scan. If a file match is found, then the
code goes to the expense of looking for a simultaneous line number match.</p>
            
            <pre><code>func findFileLine(entry uint64, filetab uint32, linetab uint32, filenum int32, line int32, cutab []byte) uint64</code></pre>
         </article>
         
         <article class="function" data-name="go12PCToLine">
            <h2>go12PCToLine</h2>
            <hr />
            
            <p>go12PCToLine maps program counter to line number for the Go 1.2+ pcln table.</p>
            
            <pre><code>func go12PCToLine(pc uint64) line int</code></pre>
         </article>
         
         <article class="function" data-name="go12PCToFile">
            <h2>go12PCToFile</h2>
            <hr />
            
            <p>go12PCToFile maps program counter to file name for the Go 1.2+ pcln table.</p>
            
            <pre><code>func go12PCToFile(pc uint64) file string</code></pre>
         </article>
         
         <article class="function" data-name="go12LineToPC">
            <h2>go12LineToPC</h2>
            <hr />
            
            <p>go12LineToPC maps a (file, line) pair to a program counter for the Go 1.2+ pcln table.</p>
            
            <pre><code>func go12LineToPC(file string, line int) pc uint64</code></pre>
         </article>
         
         <article class="function" data-name="initFileMap">
            <h2>initFileMap</h2>
            <hr />
            
            <p>initFileMap initializes the map from file name to file number.</p>
            
            <pre><code>func initFileMap()</code></pre>
         </article>
         
         <article class="function" data-name="go12MapFiles">
            <h2>go12MapFiles</h2>
            <hr />
            
            <p>go12MapFiles adds to m a key for every file in the Go 1.2 LineTable.
Every key maps to obj. That's not a very interesting map, but it provides
a way for callers to obtain the list of files in the program.</p>
            
            <pre><code>func go12MapFiles(m *ast.MapType, obj *Obj)</code></pre>
         </article>
         
         <article class="function" data-name="dotest">
            <h2>dotest</h2>
            <hr />
            
            <pre><code>func dotest(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="endtest">
            <h2>endtest</h2>
            <hr />
            
            <pre><code>func endtest()</code></pre>
         </article>
         
         <article class="function" data-name="skipIfNotELF">
            <h2>skipIfNotELF</h2>
            <hr />
            
            <p>skipIfNotELF skips the test if we are not running on an ELF system.
These tests open and examine the test binary, and use elf.Open to do so.</p>
            
            <pre><code>func skipIfNotELF(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="getTable">
            <h2>getTable</h2>
            <hr />
            
            <pre><code>func getTable(t *testing.T) *Table</code></pre>
         </article>
         
         <article class="function" data-name="crack">
            <h2>crack</h2>
            <hr />
            
            <pre><code>func crack(file string, t *testing.T) (*elf.File, *Table)</code></pre>
         </article>
         
         <article class="function" data-name="parse">
            <h2>parse</h2>
            <hr />
            
            <pre><code>func parse(file string, f *elf.File, t *testing.T) (*elf.File, *Table)</code></pre>
         </article>
         
         <article class="function" data-name="TestLineFromAline">
            <h2>TestLineFromAline</h2>
            <hr />
            
            <pre><code>func TestLineFromAline(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLineAline">
            <h2>TestLineAline</h2>
            <hr />
            
            <pre><code>func TestLineAline(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPCLine">
            <h2>TestPCLine</h2>
            <hr />
            
            <pre><code>func TestPCLine(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSymVersion">
            <h2>TestSymVersion</h2>
            <hr />
            
            <pre><code>func TestSymVersion(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="read115Executable">
            <h2>read115Executable</h2>
            <hr />
            
            <p>read115Executable returns a hello world executable compiled by Go 1.15.

The file was compiled in /tmp/hello.go:

	package main

	func main() {
		println("hello")
	}</p>
            
            <pre><code>func read115Executable(tb testing.TB) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Test115PclnParsing">
            <h2>Test115PclnParsing</h2>
            <hr />
            
            <p>Test that we can parse a pclntab from 1.15.</p>
            
            <pre><code>func Test115PclnParsing(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Benchmark115">
            <h2>Benchmark115</h2>
            <hr />
            
            <pre><code>func Benchmark115(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="Static">
            <h2>Static</h2>
            <hr />
            
            <p>Static reports whether this symbol is static (not visible outside its file).</p>
            
            <pre><code>func Static() bool</code></pre>
         </article>
         
         <article class="function" data-name="nameWithoutInst">
            <h2>nameWithoutInst</h2>
            <hr />
            
            <p>nameWithoutInst returns s.Name if s.Name has no brackets (does not reference an
instantiated type, function, or method). If s.Name contains brackets, then it
returns s.Name with all the contents between (and including) the outermost left
and right bracket removed. This is useful to ignore any extra slashes or dots
inside the brackets from the string searches below, where needed.</p>
            
            <pre><code>func nameWithoutInst() string</code></pre>
         </article>
         
         <article class="function" data-name="PackageName">
            <h2>PackageName</h2>
            <hr />
            
            <p>PackageName returns the package part of the symbol name,
or the empty string if there is none.</p>
            
            <pre><code>func PackageName() string</code></pre>
         </article>
         
         <article class="function" data-name="ReceiverName">
            <h2>ReceiverName</h2>
            <hr />
            
            <p>ReceiverName returns the receiver type name of this symbol,
or the empty string if there is none.  A receiver name is only detected in
the case that s.Name is fully-specified with a package name.</p>
            
            <pre><code>func ReceiverName() string</code></pre>
         </article>
         
         <article class="function" data-name="BaseName">
            <h2>BaseName</h2>
            <hr />
            
            <p>BaseName returns the symbol name without the package or receiver name.</p>
            
            <pre><code>func BaseName() string</code></pre>
         </article>
         
         <article class="function" data-name="walksymtab">
            <h2>walksymtab</h2>
            <hr />
            
            <pre><code>func walksymtab(data []byte, fn func) error</code></pre>
         </article>
         
         <article class="function" data-name="NewTable">
            <h2>NewTable</h2>
            <hr />
            
            <p>NewTable decodes the Go symbol table (the ".gosymtab" section in ELF),
returning an in-memory representation.
Starting with Go 1.3, the Go symbol table no longer includes symbol data.</p>
            
            <pre><code>func NewTable(symtab []byte, pcln *LineTable) (*Table, error)</code></pre>
         </article>
         
         <article class="function" data-name="PCToFunc">
            <h2>PCToFunc</h2>
            <hr />
            
            <p>PCToFunc returns the function containing the program counter pc,
or nil if there is no such function.</p>
            
            <pre><code>func PCToFunc(pc uint64) *Func</code></pre>
         </article>
         
         <article class="function" data-name="PCToLine">
            <h2>PCToLine</h2>
            <hr />
            
            <p>PCToLine looks up line number information for a program counter.
If there is no information, it returns fn == nil.</p>
            
            <pre><code>func PCToLine(pc uint64) (file string, line int, fn *Func)</code></pre>
         </article>
         
         <article class="function" data-name="LineToPC">
            <h2>LineToPC</h2>
            <hr />
            
            <p>LineToPC looks up the first program counter on the given line in
the named file. It returns [UnknownFileError] or [UnknownLineError] if
there is an error looking up this line.</p>
            
            <pre><code>func LineToPC(file string, line int) (pc uint64, fn *Func, err error)</code></pre>
         </article>
         
         <article class="function" data-name="LookupSym">
            <h2>LookupSym</h2>
            <hr />
            
            <p>LookupSym returns the text, data, or bss symbol with the given name,
or nil if no such symbol is found.</p>
            
            <pre><code>func LookupSym(name string) *Sym</code></pre>
         </article>
         
         <article class="function" data-name="LookupFunc">
            <h2>LookupFunc</h2>
            <hr />
            
            <p>LookupFunc returns the text, data, or bss symbol with the given name,
or nil if no such symbol is found.</p>
            
            <pre><code>func LookupFunc(name string) *Func</code></pre>
         </article>
         
         <article class="function" data-name="SymByAddr">
            <h2>SymByAddr</h2>
            <hr />
            
            <p>SymByAddr returns the text, data, or bss symbol starting at the given address.</p>
            
            <pre><code>func SymByAddr(addr uint64) *Sym</code></pre>
         </article>
         
         <article class="function" data-name="lineFromAline">
            <h2>lineFromAline</h2>
            <hr />
            
            <pre><code>func lineFromAline(aline int) (string, int)</code></pre>
         </article>
         
         <article class="function" data-name="alineFromLine">
            <h2>alineFromLine</h2>
            <hr />
            
            <pre><code>func alineFromLine(path string, line int) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="assertString">
            <h2>assertString</h2>
            <hr />
            
            <pre><code>func assertString(t *testing.T, dsc string, out string, tgt string)</code></pre>
         </article>
         
         <article class="function" data-name="TestStandardLibPackage">
            <h2>TestStandardLibPackage</h2>
            <hr />
            
            <pre><code>func TestStandardLibPackage(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestStandardLibPathPackage">
            <h2>TestStandardLibPathPackage</h2>
            <hr />
            
            <pre><code>func TestStandardLibPathPackage(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestGenericNames">
            <h2>TestGenericNames</h2>
            <hr />
            
            <pre><code>func TestGenericNames(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestRemotePackage">
            <h2>TestRemotePackage</h2>
            <hr />
            
            <pre><code>func TestRemotePackage(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue29551">
            <h2>TestIssue29551</h2>
            <hr />
            
            <pre><code>func TestIssue29551(t *testing.T)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
