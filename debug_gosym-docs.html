<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - gosym</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>gosym</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bytes"
"encoding/binary"
"sort"
"sync"
"bytes"
"encoding/binary"
"fmt"
"strconv"
"strings"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="bigEndianSymtab">
               <h3>
                  bigEndianSymtab 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var bigEndianSymtab = []byte{...}</code></pre>
            </article>
            
            <article class="global" data-name="disableRecover">
               <h3>
                  disableRecover 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>disableRecover causes this package not to swallow panics.
This is useful when making changes.</p>
               
               <pre><code>const disableRecover = false</code></pre>
            </article>
            
            <article class="global" data-name="go116magic">
               <h3>
                  go116magic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const go116magic = 0xfffffffa</code></pre>
            </article>
            
            <article class="global" data-name="go118magic">
               <h3>
                  go118magic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const go118magic = 0xfffffff0</code></pre>
            </article>
            
            <article class="global" data-name="go120magic">
               <h3>
                  go120magic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const go120magic = 0xfffffff1</code></pre>
            </article>
            
            <article class="global" data-name="go12magic">
               <h3>
                  go12magic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const go12magic = 0xfffffffb</code></pre>
            </article>
            
            <article class="global" data-name="littleEndianSymtab">
               <h3>
                  littleEndianSymtab 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var littleEndianSymtab = []byte{...}</code></pre>
            </article>
            
            <article class="global" data-name="oldLittleEndianSymtab">
               <h3>
                  oldLittleEndianSymtab 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var oldLittleEndianSymtab = []byte{...}</code></pre>
            </article>
            
            <article class="global" data-name="oldQuantum">
               <h3>
                  oldQuantum 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>NOTE(rsc): This is wrong for GOARCH=arm, which uses a quantum of 4,
but we have no idea whether we're using arm or not. This only
matters in the old (pre-Go 1.2) symbol table format, so it's not worth
fixing.</p>
               
               <pre><code>const oldQuantum = 1</code></pre>
            </article>
            
            <article class="global" data-name="ver11">
               <h3>
                  ver11 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ver11</code></pre>
            </article>
            
            <article class="global" data-name="ver116">
               <h3>
                  ver116 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ver116</code></pre>
            </article>
            
            <article class="global" data-name="ver118">
               <h3>
                  ver118 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ver118</code></pre>
            </article>
            
            <article class="global" data-name="ver12">
               <h3>
                  ver12 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ver12</code></pre>
            </article>
            
            <article class="global" data-name="ver120">
               <h3>
                  ver120 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ver120</code></pre>
            </article>
            
            <article class="global" data-name="verUnknown">
               <h3>
                  verUnknown 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const verUnknown version = iota</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="UnknownFileError">
               <h3>
                  UnknownFileError
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>UnknownFileError represents a failure to find the specific file in
the symbol table.</p>
               
               <pre><code>type UnknownFileError string</code></pre>
            </article>
            
            <article class="type" data-name="version">
               <h3>
                  version
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>version of the pclntab</p>
               
               <pre><code>type version int</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="DecodingError">
               <h3>
                  DecodingError
                  <span class="badge">struct</span>
               </h3>
               
               <p>DecodingError represents an error during the decoding of
the symbol table.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type DecodingError struct {
off int
msg string
val any
}</code></pre>
            </article>
            
            <article class="struct" data-name="Func">
               <h3>
                  Func
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Func collects information about a single function.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Func struct {
Entry uint64
*Sym
End uint64
Params []*Sym
Locals []*Sym
FrameSize int
LineTable *LineTable
Obj *Obj
}</code></pre>
            </article>
            
            <article class="struct" data-name="LineTable">
               <h3>
                  LineTable
                  <span class="badge">struct</span>
               </h3>
               
               <p>A LineTable is a data structure mapping program counters to line numbers.
In Go 1.1 and earlier, each function (represented by a [Func]) had its own LineTable,
and the line number corresponded to a numbering of all source lines in the
program, across all files. That absolute line number would then have to be
converted separately to a file name and line number within the file.
In Go 1.2, the format of the data changed so that there is a single LineTable
for the entire program, shared by all Funcs, and there are no absolute line
numbers, just line numbers within specific files.
For the most part, LineTable's methods should be treated as an internal
detail of the package; callers should use the methods on [Table] instead.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type LineTable struct {
Data []byte
PC uint64
Line int
mu sync.Mutex
version version
binary binary.ByteOrder
quantum uint32
ptrsize uint32
textStart uint64
funcnametab []byte
cutab []byte
funcdata []byte
functab []byte
nfunctab uint32
filetab []byte
pctab []byte
nfiletab uint32
funcNames map[uint32]string
strings map[uint32]string
fileMap map[string]uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="Obj">
               <h3>
                  Obj
                  <span class="badge">struct</span>
               </h3>
               
               <p>An Obj represents a collection of functions in a symbol table.
The exact method of division of a binary into separate Objs is an internal detail
of the symbol table format.
In early versions of Go each source file became a different Obj.
In Go 1 and Go 1.1, each package produced one Obj for all Go sources
and one Obj per C source file.
In Go 1.2, there is a single Obj for the entire program.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Obj struct {
Funcs []Func
Paths []Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="Sym">
               <h3>
                  Sym
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Sym represents a single symbol table entry.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Sym struct {
Value uint64
Type byte
Name string
GoType uint64
Func *Func
goVersion version
}</code></pre>
            </article>
            
            <article class="struct" data-name="Table">
               <h3>
                  Table
                  <span class="badge">struct</span>
               </h3>
               
               <p>Table represents a Go symbol table. It stores all of the
symbols decoded from the program and provides methods to translate
between symbols, names, and addresses.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Table struct {
Syms []Sym
Funcs []Func
Files map[string]*Obj
Objs []Obj
go12line *LineTable
}</code></pre>
            </article>
            
            <article class="struct" data-name="UnknownLineError">
               <h3>
                  UnknownLineError
                  <span class="badge">struct</span>
               </h3>
               
               <p>UnknownLineError represents a failure to map a line to a program
counter, either because the line is beyond the bounds of the file
or because there is no code on the given line.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UnknownLineError struct {
File string
Line int
}</code></pre>
            </article>
            
            <article class="struct" data-name="funcData">
               <h3>
                  funcData
                  <span class="badge">struct</span>
               </h3>
               
               <p>funcData is memory corresponding to an _func struct.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type funcData struct {
t *LineTable
data []byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="funcTab">
               <h3>
                  funcTab
                  <span class="badge">struct</span>
               </h3>
               
               <p>funcTab is memory corresponding to a slice of functab structs, followed by an invalid PC.
A functab struct is a PC and a func offset.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type funcTab struct {
*LineTable
sz int
}</code></pre>
            </article>
            
            <article class="struct" data-name="sym">
               <h3>
                  sym
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sym struct {
value uint64
gotype uint64
typ byte
name []byte
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="BaseName">
               <h3>
                  BaseName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BaseName returns the symbol name without the package or receiver name.</p>
               
               <pre><code>func (s *Sym) BaseName() string</code></pre>
            </article>
            
            <article class="function" data-name="Count">
               <h3>
                  Count 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Count returns the number of func entries in f.</p>
               
               <pre><code>func (f funcTab) Count() int</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *UnknownLineError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *DecodingError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e UnknownFileError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="IsZero">
               <h3>
                  IsZero 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsZero reports whether f is the zero value.</p>
               
               <pre><code>func (f funcData) IsZero() bool</code></pre>
            </article>
            
            <article class="function" data-name="LineToPC">
               <h3>
                  LineToPC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LineToPC looks up the first program counter on the given line in
the named file. It returns [UnknownFileError] or [UnknownLineError] if
there is an error looking up this line.</p>
               
               <pre><code>func (t *Table) LineToPC(file string, line int) (pc uint64, fn *Func, err error)</code></pre>
            </article>
            
            <article class="function" data-name="LineToPC">
               <h3>
                  LineToPC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LineToPC returns the program counter for the given line number,
considering only program counters before maxpc.
Deprecated: Use Table's LineToPC method instead.</p>
               
               <pre><code>func (t *LineTable) LineToPC(line int, maxpc uint64) uint64</code></pre>
            </article>
            
            <article class="function" data-name="LookupFunc">
               <h3>
                  LookupFunc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupFunc returns the text, data, or bss symbol with the given name,
or nil if no such symbol is found.</p>
               
               <pre><code>func (t *Table) LookupFunc(name string) *Func</code></pre>
            </article>
            
            <article class="function" data-name="LookupSym">
               <h3>
                  LookupSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LookupSym returns the text, data, or bss symbol with the given name,
or nil if no such symbol is found.</p>
               
               <pre><code>func (t *Table) LookupSym(name string) *Sym</code></pre>
            </article>
            
            <article class="function" data-name="NewLineTable">
               <h3>
                  NewLineTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewLineTable returns a new PC/line table
corresponding to the encoded data.
Text must be the start address of the
corresponding text segment, with the exact
value stored in the 'runtime.text' symbol.
This value may differ from the start
address of the text segment if
binary was built with cgo enabled.</p>
               
               <pre><code>func NewLineTable(data []byte, text uint64) *LineTable</code></pre>
            </article>
            
            <article class="function" data-name="NewTable">
               <h3>
                  NewTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewTable decodes the Go symbol table (the ".gosymtab" section in ELF),
returning an in-memory representation.
Starting with Go 1.3, the Go symbol table no longer includes symbol data.</p>
               
               <pre><code>func NewTable(symtab []byte, pcln *LineTable) (*Table, error)</code></pre>
            </article>
            
            <article class="function" data-name="PCToFunc">
               <h3>
                  PCToFunc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PCToFunc returns the function containing the program counter pc,
or nil if there is no such function.</p>
               
               <pre><code>func (t *Table) PCToFunc(pc uint64) *Func</code></pre>
            </article>
            
            <article class="function" data-name="PCToLine">
               <h3>
                  PCToLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PCToLine looks up line number information for a program counter.
If there is no information, it returns fn == nil.</p>
               
               <pre><code>func (t *Table) PCToLine(pc uint64) (file string, line int, fn *Func)</code></pre>
            </article>
            
            <article class="function" data-name="PCToLine">
               <h3>
                  PCToLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PCToLine returns the line number for the given program counter.
Deprecated: Use Table's PCToLine method instead.</p>
               
               <pre><code>func (t *LineTable) PCToLine(pc uint64) int</code></pre>
            </article>
            
            <article class="function" data-name="PackageName">
               <h3>
                  PackageName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PackageName returns the package part of the symbol name,
or the empty string if there is none.</p>
               
               <pre><code>func (s *Sym) PackageName() string</code></pre>
            </article>
            
            <article class="function" data-name="ReceiverName">
               <h3>
                  ReceiverName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReceiverName returns the receiver type name of this symbol,
or the empty string if there is none.  A receiver name is only detected in
the case that s.Name is fully-specified with a package name.</p>
               
               <pre><code>func (s *Sym) ReceiverName() string</code></pre>
            </article>
            
            <article class="function" data-name="Static">
               <h3>
                  Static 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Static reports whether this symbol is static (not visible outside its file).</p>
               
               <pre><code>func (s *Sym) Static() bool</code></pre>
            </article>
            
            <article class="function" data-name="SymByAddr">
               <h3>
                  SymByAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SymByAddr returns the text, data, or bss symbol starting at the given address.</p>
               
               <pre><code>func (t *Table) SymByAddr(addr uint64) *Sym</code></pre>
            </article>
            
            <article class="function" data-name="alineFromLine">
               <h3>
                  alineFromLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *Obj) alineFromLine(path string, line int) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="cuOffset">
               <h3>
                  cuOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f funcData) cuOffset() uint32</code></pre>
            </article>
            
            <article class="function" data-name="deferreturn">
               <h3>
                  deferreturn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f funcData) deferreturn() uint32</code></pre>
            </article>
            
            <article class="function" data-name="entryPC">
               <h3>
                  entryPC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>entryPC returns the func's entry PC.</p>
               
               <pre><code>func (f *funcData) entryPC() uint64</code></pre>
            </article>
            
            <article class="function" data-name="field">
               <h3>
                  field 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>field returns the nth field of the _func struct.
It panics if n == 0 or n > 9; for n == 0, call f.entryPC.
Most callers should use a named field accessor (just above).</p>
               
               <pre><code>func (f funcData) field(n uint32) uint32</code></pre>
            </article>
            
            <article class="function" data-name="findFileLine">
               <h3>
                  findFileLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>findFileLine scans one function in the binary looking for a
program counter in the given file on the given line.
It does so by running the pc-value tables mapping program counter
to file number. Since most functions come from a single file, these
are usually short and quick to scan. If a file match is found, then the
code goes to the expense of looking for a simultaneous line number match.</p>
               
               <pre><code>func (t *LineTable) findFileLine(entry uint64, filetab uint32, linetab uint32, filenum int32, line int32, cutab []byte) uint64</code></pre>
            </article>
            
            <article class="function" data-name="findFunc">
               <h3>
                  findFunc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>findFunc returns the funcData corresponding to the given program counter.</p>
               
               <pre><code>func (t *LineTable) findFunc(pc uint64) funcData</code></pre>
            </article>
            
            <article class="function" data-name="funcData">
               <h3>
                  funcData 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>funcData returns the ith funcData in t.functab.</p>
               
               <pre><code>func (t *LineTable) funcData(i uint32) funcData</code></pre>
            </article>
            
            <article class="function" data-name="funcName">
               <h3>
                  funcName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>funcName returns the name of the function found at off.</p>
               
               <pre><code>func (t *LineTable) funcName(off uint32) string</code></pre>
            </article>
            
            <article class="function" data-name="funcOff">
               <h3>
                  funcOff 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>funcOff returns the funcdata offset of the i'th func in f.</p>
               
               <pre><code>func (f funcTab) funcOff(i int) uint64</code></pre>
            </article>
            
            <article class="function" data-name="funcTab">
               <h3>
                  funcTab 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>funcTab returns t's funcTab.</p>
               
               <pre><code>func (t *LineTable) funcTab() funcTab</code></pre>
            </article>
            
            <article class="function" data-name="functabFieldSize">
               <h3>
                  functabFieldSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>functabFieldSize returns the size in bytes of a single functab field.</p>
               
               <pre><code>func (t *LineTable) functabFieldSize() int</code></pre>
            </article>
            
            <article class="function" data-name="go12Funcs">
               <h3>
                  go12Funcs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>go12Funcs returns a slice of Funcs derived from the Go 1.2+ pcln table.</p>
               
               <pre><code>func (t *LineTable) go12Funcs() []Func</code></pre>
            </article>
            
            <article class="function" data-name="go12LineToPC">
               <h3>
                  go12LineToPC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>go12LineToPC maps a (file, line) pair to a program counter for the Go 1.2+ pcln table.</p>
               
               <pre><code>func (t *LineTable) go12LineToPC(file string, line int) (pc uint64)</code></pre>
            </article>
            
            <article class="function" data-name="go12MapFiles">
               <h3>
                  go12MapFiles 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>go12MapFiles adds to m a key for every file in the Go 1.2 LineTable.
Every key maps to obj. That's not a very interesting map, but it provides
a way for callers to obtain the list of files in the program.</p>
               
               <pre><code>func (t *LineTable) go12MapFiles(m map[string]*Obj, obj *Obj)</code></pre>
            </article>
            
            <article class="function" data-name="go12PCToFile">
               <h3>
                  go12PCToFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>go12PCToFile maps program counter to file name for the Go 1.2+ pcln table.</p>
               
               <pre><code>func (t *LineTable) go12PCToFile(pc uint64) (file string)</code></pre>
            </article>
            
            <article class="function" data-name="go12PCToLine">
               <h3>
                  go12PCToLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>go12PCToLine maps program counter to line number for the Go 1.2+ pcln table.</p>
               
               <pre><code>func (t *LineTable) go12PCToLine(pc uint64) (line int)</code></pre>
            </article>
            
            <article class="function" data-name="initFileMap">
               <h3>
                  initFileMap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>initFileMap initializes the map from file name to file number.</p>
               
               <pre><code>func (t *LineTable) initFileMap()</code></pre>
            </article>
            
            <article class="function" data-name="isGo12">
               <h3>
                  isGo12 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isGo12 reports whether this is a Go 1.2 (or later) symbol table.</p>
               
               <pre><code>func (t *LineTable) isGo12() bool</code></pre>
            </article>
            
            <article class="function" data-name="lineFromAline">
               <h3>
                  lineFromAline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *Obj) lineFromAline(aline int) (string, int)</code></pre>
            </article>
            
            <article class="function" data-name="nameOff">
               <h3>
                  nameOff 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f funcData) nameOff() uint32</code></pre>
            </article>
            
            <article class="function" data-name="nameWithoutInst">
               <h3>
                  nameWithoutInst 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>nameWithoutInst returns s.Name if s.Name has no brackets (does not reference an
instantiated type, function, or method). If s.Name contains brackets, then it
returns s.Name with all the contents between (and including) the outermost left
and right bracket removed. This is useful to ignore any extra slashes or dots
inside the brackets from the string searches below, where needed.</p>
               
               <pre><code>func (s *Sym) nameWithoutInst() string</code></pre>
            </article>
            
            <article class="function" data-name="parse">
               <h3>
                  parse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *LineTable) parse(targetPC uint64, targetLine int) (b []byte, pc uint64, line int)</code></pre>
            </article>
            
            <article class="function" data-name="parsePclnTab">
               <h3>
                  parsePclnTab 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parsePclnTab parses the pclntab, setting the version.</p>
               
               <pre><code>func (t *LineTable) parsePclnTab()</code></pre>
            </article>
            
            <article class="function" data-name="pc">
               <h3>
                  pc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>pc returns the PC of the i'th func in f.</p>
               
               <pre><code>func (f funcTab) pc(i int) uint64</code></pre>
            </article>
            
            <article class="function" data-name="pcfile">
               <h3>
                  pcfile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f funcData) pcfile() uint32</code></pre>
            </article>
            
            <article class="function" data-name="pcln">
               <h3>
                  pcln 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f funcData) pcln() uint32</code></pre>
            </article>
            
            <article class="function" data-name="pcvalue">
               <h3>
                  pcvalue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>pcvalue reports the value associated with the target pc.
off is the offset to the beginning of the pc-value table,
and entry is the start PC for the corresponding function.</p>
               
               <pre><code>func (t *LineTable) pcvalue(off uint32, entry uint64, targetpc uint64) int32</code></pre>
            </article>
            
            <article class="function" data-name="readvarint">
               <h3>
                  readvarint 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>readvarint reads, removes, and returns a varint from *pp.</p>
               
               <pre><code>func (t *LineTable) readvarint(pp *[]byte) uint32</code></pre>
            </article>
            
            <article class="function" data-name="slice">
               <h3>
                  slice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *LineTable) slice(pc uint64) *LineTable</code></pre>
            </article>
            
            <article class="function" data-name="step">
               <h3>
                  step 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>step advances to the next pc, value pair in the encoded table.</p>
               
               <pre><code>func (t *LineTable) step(p *[]byte, pc *uint64, val *int32, first bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="string">
               <h3>
                  string 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>string returns a Go string found at off.</p>
               
               <pre><code>func (t *LineTable) string(off uint32) string</code></pre>
            </article>
            
            <article class="function" data-name="stringFrom">
               <h3>
                  stringFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>stringFrom returns a Go string found at off from a position.</p>
               
               <pre><code>func (t *LineTable) stringFrom(arr []byte, off uint32) string</code></pre>
            </article>
            
            <article class="function" data-name="uint">
               <h3>
                  uint 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>uint returns the uint stored at b.</p>
               
               <pre><code>func (f funcTab) uint(b []byte) uint64</code></pre>
            </article>
            
            <article class="function" data-name="uintptr">
               <h3>
                  uintptr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>uintptr returns the pointer-sized value encoded at b.
The pointer size is dictated by the table being read.</p>
               
               <pre><code>func (t *LineTable) uintptr(b []byte) uint64</code></pre>
            </article>
            
            <article class="function" data-name="walksymtab">
               <h3>
                  walksymtab 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func walksymtab(data []byte, fn func(sym) error) error</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
