<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - main</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>main</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"fmt"
"go/ast"
"go/printer"
"go/token"
"os"
"path/filepath"
"strings"
"flag"
"fmt"
"go/ast"
"go/printer"
"go/token"
"internal/buildcfg"
"io"
"maps"
"os"
"path/filepath"
"reflect"
"runtime"
"sort"
"strings"
"sync"
"cmd/internal/edit"
"cmd/internal/hash"
"cmd/internal/objabi"
"cmd/internal/telemetry/counter"
"bytes"
"cmd/internal/pkgpath"
"debug/elf"
"debug/macho"
"debug/pe"
"fmt"
"go/ast"
"go/printer"
"go/token"
"internal/xcoff"
"io"
"os"
"os/exec"
"path/filepath"
"regexp"
"sort"
"strings"
"unicode"
"fmt"
"go/ast"
"go/format"
"go/parser"
"go/scanner"
"go/token"
"os"
"strings"
"go/ast"
"go/token"
"go/ast"
"go/token"
"bytes"
"debug/dwarf"
"debug/elf"
"debug/macho"
"debug/pe"
"encoding/binary"
"errors"
"flag"
"fmt"
"go/ast"
"go/parser"
"go/token"
"internal/xcoff"
"math"
"os"
"os/exec"
"slices"
"strconv"
"strings"
"unicode"
"unicode/utf8"
"cmd/internal/quoted"
"bytes"
"fmt"
"go/token"
"os"
"os/exec"
"slices"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="anonymousStructTag" data-name="anonymousStructTag">
               <h3>
                  anonymousStructTag 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#anonymousStructTag" class="anchor" title="Link to anonymousStructTag">#</a>
               </h3>
               
                  <p class="doc-comment">anonymousStructTag provides a consistent tag for an anonymous struct.
The same dwarf.StructType pointer will always get the same tag.</p>
               
               <pre><code class="language-go">var anonymousStructTag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="builtinDefs" data-name="builtinDefs">
               <h3>
                  builtinDefs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#builtinDefs" class="anchor" title="Link to builtinDefs">#</a>
               </h3>
               
               <pre><code class="language-go">var builtinDefs = map[string]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="builtinExportProlog" data-name="builtinExportProlog">
               <h3>
                  builtinExportProlog 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#builtinExportProlog" class="anchor" title="Link to builtinExportProlog">#</a>
               </h3>
               
                  <p class="doc-comment">builtinExportProlog is a shorter version of builtinProlog,
to be put into the _cgo_export.h file.
For historical reasons we can't use builtinProlog in _cgo_export.h,
because _cgo_export.h defines GoString as a struct while builtinProlog
defines it as a function. We don't change this to avoid unnecessarily
breaking existing code.
The test of GO_CGO_GOSTRING_TYPEDEF avoids a duplicate definition
error if a Go file with a cgo comment #include's the export header
generated by a different package.</p>
               
               <pre><code class="language-go">const builtinExportProlog = `
#line 1 "cgo-builtin-export-prolog"

#include <stddef.h>

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; ptrdiff_t n; } _GoString_;
#endif

#endif
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="builtinProlog" data-name="builtinProlog">
               <h3>
                  builtinProlog 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#builtinProlog" class="anchor" title="Link to builtinProlog">#</a>
               </h3>
               
               <pre><code class="language-go">const builtinProlog = `
#line 1 "cgo-builtin-prolog"
#include <stddef.h>

/* Define intgo when compiling with GCC.  */
typedef ptrdiff_t intgo;

#define GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; intgo n; } _GoString_;
typedef struct { char *p; intgo n; intgo c; } _GoBytes_;
_GoString_ GoString(char *p);
_GoString_ GoStringN(char *p, int l);
_GoBytes_ GoBytes(void *p, int n);
char *CString(_GoString_);
void *CBytes(_GoBytes_);
void *_CMalloc(size_t);

__attribute__ ((unused))
static size_t _GoStringLen(_GoString_ s) { return (size_t)s.n; }

__attribute__ ((unused))
static const char *_GoStringPtr(_GoString_ s) { return s.p; }
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cBytesDef" data-name="cBytesDef">
               <h3>
                  cBytesDef 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#cBytesDef" class="anchor" title="Link to cBytesDef">#</a>
               </h3>
               
               <pre><code class="language-go">const cBytesDef = `
// CBytes converts the Go []byte slice b to a C array.
//
// The C array is allocated in the C heap using malloc.
// It is the caller's responsibility to arrange for it to be
// freed, such as by calling C.free (be sure to include stdlib.h
// if C.free is needed).
func _Cfunc_CBytes(b []byte) unsafe.Pointer {
	p := _cgo_cmalloc(uint64(len(b)))
	sliceHeader := struct {
		p   unsafe.Pointer
		len int
		cap int
	}{p, len(b), len(b)}
	s := *(*[]byte)(unsafe.Pointer(&sliceHeader))
	copy(s, b)
	return p
}
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cMallocDef" data-name="cMallocDef">
               <h3>
                  cMallocDef 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#cMallocDef" class="anchor" title="Link to cMallocDef">#</a>
               </h3>
               
               <pre><code class="language-go">const cMallocDef = `
func _Cfunc__CMalloc(n _Ctype_size_t) unsafe.Pointer {
	return _cgo_cmalloc(uint64(n))
}
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cMallocDefC" data-name="cMallocDefC">
               <h3>
                  cMallocDefC 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#cMallocDefC" class="anchor" title="Link to cMallocDefC">#</a>
               </h3>
               
                  <p class="doc-comment">cMallocDefC defines the C version of C.malloc for the gc compiler.
It is defined here because C.CString and friends need a definition.
We define it by hand, rather than simply inventing a reference to
C.malloc, because <stdlib.h> may not have been included.
This is approximately what writeOutputFunc would generate, but
skips the cgo_topofstack code (which is only needed if the C code
calls back into Go). This also avoids returning nil for an
allocation of 0 bytes.</p>
               
               <pre><code class="language-go">const cMallocDefC = `
CGO_NO_SANITIZE_THREAD
void _cgoPREFIX_Cfunc__Cmalloc(void *v) {
	struct {
		unsigned long long p0;
		void *r1;
	} PACKED *a = v;
	void *ret;
	_cgo_tsan_acquire();
	ret = malloc(a->p0);
	if (ret == 0 && a->p0 == 0) {
		ret = malloc(1);
	}
	a->r1 = ret;
	_cgo_tsan_release();
}
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cMallocDefGo" data-name="cMallocDefGo">
               <h3>
                  cMallocDefGo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#cMallocDefGo" class="anchor" title="Link to cMallocDefGo">#</a>
               </h3>
               
               <pre><code class="language-go">const cMallocDefGo = `
//go:cgo_import_static _cgoPREFIX_Cfunc__Cmalloc
//go:linkname __cgofn__cgoPREFIX_Cfunc__Cmalloc _cgoPREFIX_Cfunc__Cmalloc
var __cgofn__cgoPREFIX_Cfunc__Cmalloc byte
var _cgoPREFIX_Cfunc__Cmalloc = unsafe.Pointer(&__cgofn__cgoPREFIX_Cfunc__Cmalloc)

//go:linkname runtime_throw runtime.throw
func runtime_throw(string)

//go:cgo_unsafe_args
func _cgo_cmalloc(p0 uint64) (r1 unsafe.Pointer) {
	_cgo_runtime_cgocall(_cgoPREFIX_Cfunc__Cmalloc, uintptr(unsafe.Pointer(&p0)))
	if r1 == nil {
		runtime_throw("runtime: C malloc failed")
	}
	return
}
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cPrefix" data-name="cPrefix">
               <h3>
                  cPrefix 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cPrefix" class="anchor" title="Link to cPrefix">#</a>
               </h3>
               
               <pre><code class="language-go">var cPrefix string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cPrologGccgo" data-name="cPrologGccgo">
               <h3>
                  cPrologGccgo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#cPrologGccgo" class="anchor" title="Link to cPrologGccgo">#</a>
               </h3>
               
               <pre><code class="language-go">const cPrologGccgo = `
#line 1 "cgo-c-prolog-gccgo"
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

typedef unsigned char byte;
typedef intptr_t intgo;

struct __go_string {
	const unsigned char *__data;
	intgo __length;
};

typedef struct __go_open_array {
	void* __values;
	intgo __count;
	intgo __capacity;
} Slice;

struct __go_string __go_byte_array_to_string(const void* p, intgo len);
struct __go_open_array __go_string_to_byte_array (struct __go_string str);

extern void runtime_throw(const char *);

const char *_cgoPREFIX_Cfunc_CString(struct __go_string s) {
	char *p = malloc(s.__length+1);
	if(p == NULL)
		runtime_throw("runtime: C malloc failed");
	memmove(p, s.__data, s.__length);
	p[s.__length] = 0;
	return p;
}

void *_cgoPREFIX_Cfunc_CBytes(struct __go_open_array b) {
	char *p = malloc(b.__count);
	if(p == NULL)
		runtime_throw("runtime: C malloc failed");
	memmove(p, b.__values, b.__count);
	return p;
}

struct __go_string _cgoPREFIX_Cfunc_GoString(char *p) {
	intgo len = (p != NULL) ? strlen(p) : 0;
	return __go_byte_array_to_string(p, len);
}

struct __go_string _cgoPREFIX_Cfunc_GoStringN(char *p, int32_t n) {
	return __go_byte_array_to_string(p, n);
}

Slice _cgoPREFIX_Cfunc_GoBytes(char *p, int32_t n) {
	struct __go_string s = { (const unsigned char *)p, n };
	return __go_string_to_byte_array(s);
}

void *_cgoPREFIX_Cfunc__CMalloc(size_t n) {
	void *p = malloc(n);
	if(p == NULL && n == 0)
		p = malloc(1);
	if(p == NULL)
		runtime_throw("runtime: C malloc failed");
	return p;
}

struct __go_type_descriptor;
typedef struct __go_empty_interface {
	const struct __go_type_descriptor *__type_descriptor;
	void *__object;
} Eface;

extern void runtimeCgoCheckPointer(Eface, Eface)
	__asm__("runtime.cgoCheckPointer")
	__attribute__((weak));

extern void localCgoCheckPointer(Eface, Eface)
	__asm__("GCCGOSYMBOLPREF._cgoCheckPointer");

void localCgoCheckPointer(Eface ptr, Eface arg) {
	if(runtimeCgoCheckPointer) {
		runtimeCgoCheckPointer(ptr, arg);
	}
}

extern void runtimeCgoCheckResult(Eface)
	__asm__("runtime.cgoCheckResult")
	__attribute__((weak));

extern void localCgoCheckResult(Eface)
	__asm__("GCCGOSYMBOLPREF._cgoCheckResult");

void localCgoCheckResult(Eface val) {
	if(runtimeCgoCheckResult) {
		runtimeCgoCheckResult(val);
	}
}
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cStringDef" data-name="cStringDef">
               <h3>
                  cStringDef 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#cStringDef" class="anchor" title="Link to cStringDef">#</a>
               </h3>
               
               <pre><code class="language-go">const cStringDef = `
// CString converts the Go string s to a C string.
//
// The C string is allocated in the C heap using malloc.
// It is the caller's responsibility to arrange for it to be
// freed, such as by calling C.free (be sure to include stdlib.h
// if C.free is needed).
func _Cfunc_CString(s string) *_Ctype_char {
	if len(s)+1 <= 0 {
		panic("string too large")
	}
	p := _cgo_cmalloc(uint64(len(s)+1))
	sliceHeader := struct {
		p   unsafe.Pointer
		len int
		cap int
	}{p, len(s)+1, len(s)+1}
	b := *(*[]byte)(unsafe.Pointer(&sliceHeader))
	copy(b, s)
	b[len(s)] = 0
	return (*_Ctype_char)(p)
}
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="conf" data-name="conf">
               <h3>
                  conf 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#conf" class="anchor" title="Link to conf">#</a>
               </h3>
               
               <pre><code class="language-go">var conf = printer.Config{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxAssign2" data-name="ctxAssign2">
               <h3>
                  ctxAssign2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxAssign2" class="anchor" title="Link to ctxAssign2">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxAssign2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxCall" data-name="ctxCall">
               <h3>
                  ctxCall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxCall" class="anchor" title="Link to ctxCall">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxCall</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxCall2" data-name="ctxCall2">
               <h3>
                  ctxCall2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxCall2" class="anchor" title="Link to ctxCall2">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxCall2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxDecl" data-name="ctxDecl">
               <h3>
                  ctxDecl 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxDecl" class="anchor" title="Link to ctxDecl">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxDecl</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxDefer" data-name="ctxDefer">
               <h3>
                  ctxDefer 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxDefer" class="anchor" title="Link to ctxDefer">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxDefer</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxEmbedType" data-name="ctxEmbedType">
               <h3>
                  ctxEmbedType 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxEmbedType" class="anchor" title="Link to ctxEmbedType">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxEmbedType</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxExpr" data-name="ctxExpr">
               <h3>
                  ctxExpr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxExpr" class="anchor" title="Link to ctxExpr">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxField" data-name="ctxField">
               <h3>
                  ctxField 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxField" class="anchor" title="Link to ctxField">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxField</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxFile" data-name="ctxFile">
               <h3>
                  ctxFile 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxFile" class="anchor" title="Link to ctxFile">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxFile</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxParam" data-name="ctxParam">
               <h3>
                  ctxParam 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxParam" class="anchor" title="Link to ctxParam">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxParam</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxProg" data-name="ctxProg">
               <h3>
                  ctxProg 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxProg" class="anchor" title="Link to ctxProg">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxProg astContext = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxSelector" data-name="ctxSelector">
               <h3>
                  ctxSelector 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxSelector" class="anchor" title="Link to ctxSelector">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxSelector</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxSpec" data-name="ctxSpec">
               <h3>
                  ctxSpec 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxSpec" class="anchor" title="Link to ctxSpec">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxSpec</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxStmt" data-name="ctxStmt">
               <h3>
                  ctxStmt 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxStmt" class="anchor" title="Link to ctxStmt">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxStmt</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxSwitch" data-name="ctxSwitch">
               <h3>
                  ctxSwitch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxSwitch" class="anchor" title="Link to ctxSwitch">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxSwitch</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxType" data-name="ctxType">
               <h3>
                  ctxType 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxType" class="anchor" title="Link to ctxType">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxType</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxTypeSwitch" data-name="ctxTypeSwitch">
               <h3>
                  ctxTypeSwitch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxTypeSwitch" class="anchor" title="Link to ctxTypeSwitch">#</a>
               </h3>
               
               <pre><code class="language-go">const ctxTypeSwitch</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugDefine" data-name="debugDefine">
               <h3>
                  debugDefine 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#debugDefine" class="anchor" title="Link to debugDefine">#</a>
               </h3>
               
               <pre><code class="language-go">var debugDefine = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugGcc" data-name="debugGcc">
               <h3>
                  debugGcc 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#debugGcc" class="anchor" title="Link to debugGcc">#</a>
               </h3>
               
               <pre><code class="language-go">var debugGcc = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultPkgConfig" data-name="defaultPkgConfig">
               <h3>
                  defaultPkgConfig 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#defaultPkgConfig" class="anchor" title="Link to defaultPkgConfig">#</a>
               </h3>
               
               <pre><code class="language-go">const defaultPkgConfig = `pkg-config`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dwarfToName" data-name="dwarfToName">
               <h3>
                  dwarfToName 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dwarfToName" class="anchor" title="Link to dwarfToName">#</a>
               </h3>
               
                  <p class="doc-comment">Map from dwarf text names to aliases we use in package "C".</p>
               
               <pre><code class="language-go">var dwarfToName = map[string]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dynlinker" data-name="dynlinker">
               <h3>
                  dynlinker 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dynlinker" class="anchor" title="Link to dynlinker">#</a>
               </h3>
               
               <pre><code class="language-go">var dynlinker = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dynobj" data-name="dynobj">
               <h3>
                  dynobj 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dynobj" class="anchor" title="Link to dynobj">#</a>
               </h3>
               
               <pre><code class="language-go">var dynobj = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dynout" data-name="dynout">
               <h3>
                  dynout 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dynout" class="anchor" title="Link to dynout">#</a>
               </h3>
               
               <pre><code class="language-go">var dynout = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dynpackage" data-name="dynpackage">
               <h3>
                  dynpackage 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dynpackage" class="anchor" title="Link to dynpackage">#</a>
               </h3>
               
               <pre><code class="language-go">var dynpackage = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exportHeader" data-name="exportHeader">
               <h3>
                  exportHeader 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#exportHeader" class="anchor" title="Link to exportHeader">#</a>
               </h3>
               
               <pre><code class="language-go">var exportHeader = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fset" data-name="fset">
               <h3>
                  fset 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#fset" class="anchor" title="Link to fset">#</a>
               </h3>
               
               <pre><code class="language-go">var fset = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccBaseCmd" data-name="gccBaseCmd">
               <h3>
                  gccBaseCmd 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gccBaseCmd" class="anchor" title="Link to gccBaseCmd">#</a>
               </h3>
               
               <pre><code class="language-go">var gccBaseCmd []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccExportHeaderEpilog" data-name="gccExportHeaderEpilog">
               <h3>
                  gccExportHeaderEpilog 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccExportHeaderEpilog" class="anchor" title="Link to gccExportHeaderEpilog">#</a>
               </h3>
               
                  <p class="doc-comment">gccExportHeaderEpilog goes at the end of the generated header file.</p>
               
               <pre><code class="language-go">const gccExportHeaderEpilog = `
#ifdef __cplusplus
}
#endif
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccExportHeaderProlog" data-name="gccExportHeaderProlog">
               <h3>
                  gccExportHeaderProlog 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccExportHeaderProlog" class="anchor" title="Link to gccExportHeaderProlog">#</a>
               </h3>
               
                  <p class="doc-comment">gccExportHeaderProlog is written to the exported header, after the
import "C" comment preamble but before the generated declarations
of exported functions. This permits the generated declarations to
use the type names that appear in goTypes, above.
The test of GO_CGO_GOSTRING_TYPEDEF avoids a duplicate definition
error if a Go file with a cgo comment #include's the export header
generated by a different package. Unfortunately GoString means two
different things: in this prolog it means a C name for the Go type,
while in the prolog written into the start of the C code generated
from a cgo-using Go file it means the C.GoString function. There is
no way to resolve this conflict, but it also doesn't make much
difference, as Go code never wants to refer to the latter meaning.</p>
               
               <pre><code class="language-go">const gccExportHeaderProlog = `
/* Start of boilerplate cgo prologue.  */
#line 1 "cgo-gcc-export-header-prolog"

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoIntGOINTBITS GoInt;
typedef GoUintGOINTBITS GoUint;
typedef size_t GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
#ifdef _MSC_VER
#include <complex.h>
typedef _Fcomplex GoComplex64;
typedef _Dcomplex GoComplex128;
#else
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;
#endif

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_GOINTBITS_bit_pointer_matching_GoInt[sizeof(void*)==GOINTBITS/8 ? 1:-1];

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef _GoString_ GoString;
#endif
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccProlog" data-name="gccProlog">
               <h3>
                  gccProlog 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccProlog" class="anchor" title="Link to gccProlog">#</a>
               </h3>
               
               <pre><code class="language-go">const gccProlog = `
#line 1 "cgo-gcc-prolog"
/*
  If x and y are not equal, the type will be invalid
  (have a negative array count) and an inscrutable error will come
  out of the compiler and hopefully mention "name".
*/
#define __cgo_compile_assert_eq(x, y, name) typedef char name[(x-y)*(x-y)*-2UL+1UL];

/* Check at compile time that the sizes we use match our expectations. */
#define __cgo_size_assert(t, n) __cgo_compile_assert_eq(sizeof(t), (size_t)n, _cgo_sizeof_##t##_is_not_##n)

__cgo_size_assert(char, 1)
__cgo_size_assert(short, 2)
__cgo_size_assert(int, 4)
typedef long long __cgo_long_long;
__cgo_size_assert(__cgo_long_long, 8)
__cgo_size_assert(float, 4)
__cgo_size_assert(double, 8)

extern char* _cgo_topofstack(void);

/*
  We use packed structs, but they are always aligned.
  The pragmas and address-of-packed-member are only recognized as warning
  groups in clang 4.0+, so ignore unknown pragmas first.
*/
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
#pragma GCC diagnostic ignored "-Wpragmas"
#pragma GCC diagnostic ignored "-Waddress-of-packed-member"
#pragma GCC diagnostic ignored "-Wunknown-warning-option"
#pragma GCC diagnostic ignored "-Wunaligned-access"

#include <errno.h>
#include <string.h>
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgo" data-name="gccgo">
               <h3>
                  gccgo 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gccgo" class="anchor" title="Link to gccgo">#</a>
               </h3>
               
               <pre><code class="language-go">var gccgo = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoDefineCgoIncomplete" data-name="gccgoDefineCgoIncomplete">
               <h3>
                  gccgoDefineCgoIncomplete 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gccgoDefineCgoIncomplete" class="anchor" title="Link to gccgoDefineCgoIncomplete">#</a>
               </h3>
               
               <pre><code class="language-go">var gccgoDefineCgoIncomplete = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoExportFileProlog" data-name="gccgoExportFileProlog">
               <h3>
                  gccgoExportFileProlog 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoExportFileProlog" class="anchor" title="Link to gccgoExportFileProlog">#</a>
               </h3>
               
                  <p class="doc-comment">gccgoExportFileProlog is written to the _cgo_export.c file when
using gccgo.
We use weak declarations, and test the addresses, so that this code
works with older versions of gccgo.</p>
               
               <pre><code class="language-go">const gccgoExportFileProlog = `
#line 1 "cgo-gccgo-export-file-prolog"
extern _Bool runtime_iscgo __attribute__ ((weak));

static void GoInit(void) __attribute__ ((constructor));
static void GoInit(void) {
	if(&runtime_iscgo)
		runtime_iscgo = 1;
}

extern size_t _cgo_wait_runtime_init_done(void) __attribute__ ((weak));
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoGoProlog" data-name="gccgoGoProlog">
               <h3>
                  gccgoGoProlog 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoGoProlog" class="anchor" title="Link to gccgoGoProlog">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoGoProlog = `
func _cgoCheckPointer(interface{}, interface{})

func _cgoCheckResult(interface{})
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoMangler" data-name="gccgoMangler">
               <h3>
                  gccgoMangler 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gccgoMangler" class="anchor" title="Link to gccgoMangler">#</a>
               </h3>
               
               <pre><code class="language-go">var gccgoMangler func(string) string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgopkgpath" data-name="gccgopkgpath">
               <h3>
                  gccgopkgpath 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gccgopkgpath" class="anchor" title="Link to gccgopkgpath">#</a>
               </h3>
               
               <pre><code class="language-go">var gccgopkgpath = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoprefix" data-name="gccgoprefix">
               <h3>
                  gccgoprefix 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gccgoprefix" class="anchor" title="Link to gccgoprefix">#</a>
               </h3>
               
               <pre><code class="language-go">var gccgoprefix = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goBytesDef" data-name="goBytesDef">
               <h3>
                  goBytesDef 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#goBytesDef" class="anchor" title="Link to goBytesDef">#</a>
               </h3>
               
               <pre><code class="language-go">const goBytesDef = `
//go:linkname _cgo_runtime_gobytes runtime.gobytes
func _cgo_runtime_gobytes(unsafe.Pointer, int) []byte

// GoBytes converts the C data p with explicit length l to a Go []byte.
func _Cfunc_GoBytes(p unsafe.Pointer, l _Ctype_int) []byte {
	return _cgo_runtime_gobytes(p, int(l))
}
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goIdent" data-name="goIdent">
               <h3>
                  goIdent 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#goIdent" class="anchor" title="Link to goIdent">#</a>
               </h3>
               
               <pre><code class="language-go">var goIdent = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goProlog" data-name="goProlog">
               <h3>
                  goProlog 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#goProlog" class="anchor" title="Link to goProlog">#</a>
               </h3>
               
               <pre><code class="language-go">const goProlog = `
//go:linkname _cgo_runtime_cgocall runtime.cgocall
func _cgo_runtime_cgocall(unsafe.Pointer, uintptr) int32

//go:linkname _cgoCheckPointer runtime.cgoCheckPointer
//go:noescape
func _cgoCheckPointer(interface{}, interface{})

//go:linkname _cgoCheckResult runtime.cgoCheckResult
//go:noescape
func _cgoCheckResult(interface{})
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goStringDef" data-name="goStringDef">
               <h3>
                  goStringDef 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#goStringDef" class="anchor" title="Link to goStringDef">#</a>
               </h3>
               
               <pre><code class="language-go">const goStringDef = `
//go:linkname _cgo_runtime_gostring runtime.gostring
func _cgo_runtime_gostring(*_Ctype_char) string

// GoString converts the C string p into a Go string.
func _Cfunc_GoString(p *_Ctype_char) string {
	return _cgo_runtime_gostring(p)
}
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goStringNDef" data-name="goStringNDef">
               <h3>
                  goStringNDef 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#goStringNDef" class="anchor" title="Link to goStringNDef">#</a>
               </h3>
               
               <pre><code class="language-go">const goStringNDef = `
//go:linkname _cgo_runtime_gostringn runtime.gostringn
func _cgo_runtime_gostringn(*_Ctype_char, int) string

// GoStringN converts the C data p with explicit length l to a Go string.
func _Cfunc_GoStringN(p *_Ctype_char, l _Ctype_int) string {
	return _cgo_runtime_gostringn(p, int(l))
}
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goTypes" data-name="goTypes">
               <h3>
                  goTypes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#goTypes" class="anchor" title="Link to goTypes">#</a>
               </h3>
               
                  <p class="doc-comment">Map predeclared Go types to Type.</p>
               
               <pre><code class="language-go">var goTypes = map[string]*Type{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goarch" data-name="goarch">
               <h3>
                  goarch 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#goarch" class="anchor" title="Link to goarch">#</a>
               </h3>
               
               <pre><code class="language-go">var goarch string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="godefs" data-name="godefs">
               <h3>
                  godefs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#godefs" class="anchor" title="Link to godefs">#</a>
               </h3>
               
                  <p class="doc-comment">This flag is for bootstrapping a new Go implementation,
to generate Go types that match the data layout and
constant values used in the host's C libraries and system calls.</p>
               
               <pre><code class="language-go">var godefs = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gofmtBuf" data-name="gofmtBuf">
               <h3>
                  gofmtBuf 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gofmtBuf" class="anchor" title="Link to gofmtBuf">#</a>
               </h3>
               
               <pre><code class="language-go">var gofmtBuf strings.Builder</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gomips" data-name="gomips">
               <h3>
                  gomips 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gomips" class="anchor" title="Link to gomips">#</a>
               </h3>
               
               <pre><code class="language-go">var gomips string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gomips64" data-name="gomips64">
               <h3>
                  gomips64 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gomips64" class="anchor" title="Link to gomips64">#</a>
               </h3>
               
               <pre><code class="language-go">var gomips64 string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goos" data-name="goos">
               <h3>
                  goos 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#goos" class="anchor" title="Link to goos">#</a>
               </h3>
               
               <pre><code class="language-go">var goos string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="importPath" data-name="importPath">
               <h3>
                  importPath 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#importPath" class="anchor" title="Link to importPath">#</a>
               </h3>
               
               <pre><code class="language-go">var importPath = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="importRuntimeCgo" data-name="importRuntimeCgo">
               <h3>
                  importRuntimeCgo 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#importRuntimeCgo" class="anchor" title="Link to importRuntimeCgo">#</a>
               </h3>
               
               <pre><code class="language-go">var importRuntimeCgo = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="importSyscall" data-name="importSyscall">
               <h3>
                  importSyscall 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#importSyscall" class="anchor" title="Link to importSyscall">#</a>
               </h3>
               
               <pre><code class="language-go">var importSyscall = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="incomplete" data-name="incomplete">
               <h3>
                  incomplete 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#incomplete" class="anchor" title="Link to incomplete">#</a>
               </h3>
               
               <pre><code class="language-go">var incomplete = "_cgopackage.Incomplete"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="intSizeMap" data-name="intSizeMap">
               <h3>
                  intSizeMap 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#intSizeMap" class="anchor" title="Link to intSizeMap">#</a>
               </h3>
               
               <pre><code class="language-go">var intSizeMap = map[string]int64{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="isBuiltin" data-name="isBuiltin">
               <h3>
                  isBuiltin 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#isBuiltin" class="anchor" title="Link to isBuiltin">#</a>
               </h3>
               
               <pre><code class="language-go">var isBuiltin = map[string]bool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="jniTypes" data-name="jniTypes">
               <h3>
                  jniTypes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#jniTypes" class="anchor" title="Link to jniTypes">#</a>
               </h3>
               
                  <p class="doc-comment">jniTypes maps from JNI types that we want to be uintptrs, to the underlying type to which
they are mapped. The base "jobject" maps to the empty string.</p>
               
               <pre><code class="language-go">var jniTypes = map[string]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ldflags" data-name="ldflags">
               <h3>
                  ldflags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ldflags" class="anchor" title="Link to ldflags">#</a>
               </h3>
               
               <pre><code class="language-go">var ldflags = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="msanProlog" data-name="msanProlog">
               <h3>
                  msanProlog 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#msanProlog" class="anchor" title="Link to msanProlog">#</a>
               </h3>
               
                  <p class="doc-comment">msanProlog is set to yesMsanProlog if we see -fsanitize=memory in the flags
for the C compiler.</p>
               
               <pre><code class="language-go">var msanProlog = noMsanProlog</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nameKinds" data-name="nameKinds">
               <h3>
                  nameKinds 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#nameKinds" class="anchor" title="Link to nameKinds">#</a>
               </h3>
               
               <pre><code class="language-go">var nameKinds = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nameToC" data-name="nameToC">
               <h3>
                  nameToC 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#nameToC" class="anchor" title="Link to nameToC">#</a>
               </h3>
               
               <pre><code class="language-go">var nameToC = map[string]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nerrors" data-name="nerrors">
               <h3>
                  nerrors 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#nerrors" class="anchor" title="Link to nerrors">#</a>
               </h3>
               
               <pre><code class="language-go">var nerrors int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noMsanProlog" data-name="noMsanProlog">
               <h3>
                  noMsanProlog 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#noMsanProlog" class="anchor" title="Link to noMsanProlog">#</a>
               </h3>
               
                  <p class="doc-comment">noMsanProlog is a prologue defining an MSAN function in C.
This is used when not compiling with -fsanitize=memory.</p>
               
               <pre><code class="language-go">const noMsanProlog = `
#define _cgo_msan_write(addr, sz)
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noSourceConf" data-name="noSourceConf">
               <h3>
                  noSourceConf 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#noSourceConf" class="anchor" title="Link to noSourceConf">#</a>
               </h3>
               
               <pre><code class="language-go">var noSourceConf = printer.Config{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noTsanProlog" data-name="noTsanProlog">
               <h3>
                  noTsanProlog 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#noTsanProlog" class="anchor" title="Link to noTsanProlog">#</a>
               </h3>
               
                  <p class="doc-comment">Prologue defining TSAN functions in C.</p>
               
               <pre><code class="language-go">const noTsanProlog = `
#define CGO_NO_SANITIZE_THREAD
#define _cgo_tsan_acquire()
#define _cgo_tsan_release()
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="objDir" data-name="objDir">
               <h3>
                  objDir 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#objDir" class="anchor" title="Link to objDir">#</a>
               </h3>
               
               <pre><code class="language-go">var objDir = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ptrSizeMap" data-name="ptrSizeMap">
               <h3>
                  ptrSizeMap 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ptrSizeMap" class="anchor" title="Link to ptrSizeMap">#</a>
               </h3>
               
               <pre><code class="language-go">var ptrSizeMap = map[string]int64{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="signedDelta" data-name="signedDelta">
               <h3>
                  signedDelta 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#signedDelta" class="anchor" title="Link to signedDelta">#</a>
               </h3>
               
               <pre><code class="language-go">const signedDelta = 64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="srcDir" data-name="srcDir">
               <h3>
                  srcDir 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#srcDir" class="anchor" title="Link to srcDir">#</a>
               </h3>
               
               <pre><code class="language-go">var srcDir = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="tagGen" data-name="tagGen">
               <h3>
                  tagGen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#tagGen" class="anchor" title="Link to tagGen">#</a>
               </h3>
               
               <pre><code class="language-go">var tagGen int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="trimpath" data-name="trimpath">
               <h3>
                  trimpath 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#trimpath" class="anchor" title="Link to trimpath">#</a>
               </h3>
               
               <pre><code class="language-go">var trimpath = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="tsanProlog" data-name="tsanProlog">
               <h3>
                  tsanProlog 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#tsanProlog" class="anchor" title="Link to tsanProlog">#</a>
               </h3>
               
                  <p class="doc-comment">Set to yesTsanProlog if we see -fsanitize=thread in the flags for gcc.</p>
               
               <pre><code class="language-go">var tsanProlog = noTsanProlog</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="typedef" data-name="typedef">
               <h3>
                  typedef 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#typedef" class="anchor" title="Link to typedef">#</a>
               </h3>
               
               <pre><code class="language-go">var typedef = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unionWithPointer" data-name="unionWithPointer">
               <h3>
                  unionWithPointer 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#unionWithPointer" class="anchor" title="Link to unionWithPointer">#</a>
               </h3>
               
                  <p class="doc-comment">unionWithPointer is true for a Go type that represents a C union (or class)
that may contain a pointer. This is used for cgo pointer checking.</p>
               
               <pre><code class="language-go">var unionWithPointer = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="yesMsanProlog" data-name="yesMsanProlog">
               <h3>
                  yesMsanProlog 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#yesMsanProlog" class="anchor" title="Link to yesMsanProlog">#</a>
               </h3>
               
                  <p class="doc-comment">yesMsanProlog is a prologue defining an MSAN function in C.
This is used when compiling with -fsanitize=memory.
See the comment above where _cgo_msan_write is called.</p>
               
               <pre><code class="language-go">const yesMsanProlog = `
extern void __msan_unpoison(const volatile void *, size_t);

#define _cgo_msan_write(addr, sz) __msan_unpoison((addr), (sz))
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="yesTsanProlog" data-name="yesTsanProlog">
               <h3>
                  yesTsanProlog 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#yesTsanProlog" class="anchor" title="Link to yesTsanProlog">#</a>
               </h3>
               
                  <p class="doc-comment">This must match the TSAN code in runtime/cgo/libcgo.h.
This is used when the code is built with the C/C++ Thread SANitizer,
which is not the same as the Go race detector.
__tsan_acquire tells TSAN that we are acquiring a lock on a variable,
in this case _cgo_sync. __tsan_release releases the lock.
(There is no actual lock, we are just telling TSAN that there is.)
When we call from Go to C we call _cgo_tsan_acquire.
When the C function returns we call _cgo_tsan_release.
Similarly, when C calls back into Go we call _cgo_tsan_release
and then call _cgo_tsan_acquire when we return to C.
These calls tell TSAN that there is a serialization point at the C call.
This is necessary because TSAN, which is a C/C++ tool, can not see
the synchronization in the Go code. Without these calls, when
multiple goroutines call into C code, TSAN does not understand
that the calls are properly synchronized on the Go side.
To be clear, if the calls are not properly synchronized on the Go side,
we will be hiding races. But when using TSAN on mixed Go C/C++ code
it is more important to avoid false positives, which reduce confidence
in the tool, than to avoid false negatives.</p>
               
               <pre><code class="language-go">const yesTsanProlog = `
#line 1 "cgo-tsan-prolog"
#define CGO_NO_SANITIZE_THREAD __attribute__ ((no_sanitize_thread))

long long _cgo_sync __attribute__ ((common));

extern void __tsan_acquire(void*);
extern void __tsan_release(void*);

__attribute__ ((unused))
static void _cgo_tsan_acquire() {
	__tsan_acquire(&_cgo_sync);
}

__attribute__ ((unused))
static void _cgo_tsan_release() {
	__tsan_release(&_cgo_sync);
}
`</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="astContext" data-name="astContext">
               <h3>
                  astContext
                  <span class="badge type-badge">type</span>
                  <a href="#astContext" class="anchor" title="Link to astContext">#</a>
               </h3>
               
               <pre><code class="language-go">type astContext int</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Call" data-name="Call">
               <h3>
                  Call
                  <span class="badge">struct</span>
                  <a href="#Call" class="anchor" title="Link to Call">#</a>
               </h3>
               
               <p>A Call refers to a call of a C.xxx function in the AST.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Call struct {
Call *ast.CallExpr
Deferred bool
Done bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ExpFunc" data-name="ExpFunc">
               <h3>
                  ExpFunc
                  <span class="badge">struct</span>
                  <a href="#ExpFunc" class="anchor" title="Link to ExpFunc">#</a>
               </h3>
               
               <p>An ExpFunc is an exported function, callable from C.
Such functions are identified in the Go input file
by doc comments containing the line //export ExpName</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ExpFunc struct {
Func *ast.FuncDecl
ExpName string
Doc string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="File" data-name="File">
               <h3>
                  File
                  <span class="badge">struct</span>
                  <a href="#File" class="anchor" title="Link to File">#</a>
               </h3>
               
               <p>A File collects information about a single Go input file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type File struct {
AST *ast.File
Comments []*ast.CommentGroup
Package string
Preamble string
Ref []*Ref
Calls []*Call
ExpFunc []*ExpFunc
Name map[string]*Name
NamePos map[*Name]token.Pos
NoCallbacks map[string]bool
NoEscapes map[string]bool
Edit *edit.Buffer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="FuncType" data-name="FuncType">
               <h3>
                  FuncType
                  <span class="badge">struct</span>
                  <a href="#FuncType" class="anchor" title="Link to FuncType">#</a>
               </h3>
               
               <p>A FuncType collects information about a function type in both the C and Go worlds.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type FuncType struct {
Params []*Type
Result *Type
Go *ast.FuncType
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name
                  <span class="badge">struct</span>
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <p>A Name collects information about C.xxx.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Name struct {
Go string
Mangle string
C string
Define string
Kind string
Type *Type
FuncType *FuncType
AddError bool
Const string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Package" data-name="Package">
               <h3>
                  Package
                  <span class="badge">struct</span>
                  <a href="#Package" class="anchor" title="Link to Package">#</a>
               </h3>
               
               <p>A Package collects information about the package we're going to write.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Package struct {
PackageName string
PackagePath string
PtrSize int64
IntSize int64
GccOptions []string
GccIsClang bool
LdFlags []string
Written map[string]bool
Name map[string]*Name
ExpFunc []*ExpFunc
Decl []ast.Decl
GoFiles []string
GccFiles []string
Preamble string
typedefs map[string]bool
typedefList []typedefInfo
noCallbacks map[string]bool
noEscapes map[string]bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Ref" data-name="Ref">
               <h3>
                  Ref
                  <span class="badge">struct</span>
                  <a href="#Ref" class="anchor" title="Link to Ref">#</a>
               </h3>
               
               <p>A Ref refers to an expression of the form C.xxx in the AST.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Ref struct {
Name *Name
Expr *ast.Expr
Context astContext
Done bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type
                  <span class="badge">struct</span>
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <p>A Type collects information about a type in both the C and Go worlds.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Type struct {
Size int64
Align int64
C *TypeRepr
Go ast.Expr
EnumValues map[string]int64
Typedef string
BadPointer bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TypeRepr" data-name="TypeRepr">
               <h3>
                  TypeRepr
                  <span class="badge">struct</span>
                  <a href="#TypeRepr" class="anchor" title="Link to TypeRepr">#</a>
               </h3>
               
               <p>A TypeRepr contains the string representation of a type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type TypeRepr struct {
Repr string
FormatArgs []interface{}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="typeConv" data-name="typeConv">
               <h3>
                  typeConv
                  <span class="badge">struct</span>
                  <a href="#typeConv" class="anchor" title="Link to typeConv">#</a>
               </h3>
               
               <p>A typeConv is a translator from dwarf types to Go types
with equivalent memory layout.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type typeConv struct {
m map[string]*Type
ptrs map[string][]*Type
ptrKeys []dwarf.Type
getTypeIDs map[string]bool
incompleteStructs map[string]bool
bool ast.Expr
byte ast.Expr
int8 ast.Expr
int16 ast.Expr
int32 ast.Expr
int64 ast.Expr
uint8 ast.Expr
uint16 ast.Expr
uint32 ast.Expr
uint64 ast.Expr
uintptr ast.Expr
float32 ast.Expr
float64 ast.Expr
complex64 ast.Expr
complex128 ast.Expr
void ast.Expr
string ast.Expr
goVoid ast.Expr
goVoidPtr ast.Expr
ptrSize int64
intSize int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="typedefInfo" data-name="typedefInfo">
               <h3>
                  typedefInfo
                  <span class="badge">struct</span>
                  <a href="#typedefInfo" class="anchor" title="Link to typedefInfo">#</a>
               </h3>
               
               <p>A typedefInfo is an element on Package.typedefList: a typedef name
and the position where it was required.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type typedefInfo struct {
typedef string
pos token.Pos
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Empty" data-name="Empty">
               <h3>
                  Empty 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Empty" class="anchor" title="Link to Empty">#</a>
               </h3>
               
               <p>Empty reports whether the result of String would be "".</p>
               
               <pre><code class="language-go">func (tr *TypeRepr) Empty() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FinishType" data-name="FinishType">
               <h3>
                  FinishType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FinishType" class="anchor" title="Link to FinishType">#</a>
               </h3>
               
               <p>FinishType completes any outstanding type mapping work.
In particular, it resolves incomplete pointer types.</p>
               
               <pre><code class="language-go">func (c *typeConv) FinishType(pos token.Pos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FuncArg" data-name="FuncArg">
               <h3>
                  FuncArg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FuncArg" class="anchor" title="Link to FuncArg">#</a>
               </h3>
               
               <p>FuncArg returns a Go type with the same memory layout as
dtype when used as the type of a C function argument.</p>
               
               <pre><code class="language-go">func (c *typeConv) FuncArg(dtype dwarf.Type, pos token.Pos) *Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FuncType" data-name="FuncType">
               <h3>
                  FuncType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FuncType" class="anchor" title="Link to FuncType">#</a>
               </h3>
               
               <p>FuncType returns the Go type analogous to dtype.
There is no guarantee about matching memory layout.</p>
               
               <pre><code class="language-go">func (c *typeConv) FuncType(dtype *dwarf.FuncType, pos token.Pos) *FuncType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Ident" data-name="Ident">
               <h3>
                  Ident 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Ident" class="anchor" title="Link to Ident">#</a>
               </h3>
               
               <p>Identifier</p>
               
               <pre><code class="language-go">func (c *typeConv) Ident(s string) *ast.Ident</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Init" data-name="Init">
               <h3>
                  Init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Init" class="anchor" title="Link to Init">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *typeConv) Init(ptrSize int64, intSize int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsConst" data-name="IsConst">
               <h3>
                  IsConst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsConst" class="anchor" title="Link to IsConst">#</a>
               </h3>
               
               <p>IsConst reports whether Kind is either "iconst", "fconst" or "sconst"</p>
               
               <pre><code class="language-go">func (n *Name) IsConst() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsVar" data-name="IsVar">
               <h3>
                  IsVar 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsVar" class="anchor" title="Link to IsVar">#</a>
               </h3>
               
               <p>IsVar reports whether Kind is either "var" or "fpvar"</p>
               
               <pre><code class="language-go">func (n *Name) IsVar() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Opaque" data-name="Opaque">
               <h3>
                  Opaque 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Opaque" class="anchor" title="Link to Opaque">#</a>
               </h3>
               
               <p>Opaque type of n bytes.</p>
               
               <pre><code class="language-go">func (c *typeConv) Opaque(n int64) ast.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseGo" data-name="ParseGo">
               <h3>
                  ParseGo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ParseGo" class="anchor" title="Link to ParseGo">#</a>
               </h3>
               
               <p>ParseGo populates f with information learned from the Go source code
which was read from the named file. It gathers the C preamble
attached to the import "C" comment, a list of references to C.xxx,
a list of exported functions, and the actual AST, to be rewritten and
printed.</p>
               
               <pre><code class="language-go">func (f *File) ParseGo(abspath string, src []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pos" data-name="Pos">
               <h3>
                  Pos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pos" class="anchor" title="Link to Pos">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *Ref) Pos() token.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ProcessCgoDirectives" data-name="ProcessCgoDirectives">
               <h3>
                  ProcessCgoDirectives 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ProcessCgoDirectives" class="anchor" title="Link to ProcessCgoDirectives">#</a>
               </h3>
               
               <p>ProcessCgoDirectives processes the import C preamble:
1. discards all #cgo CFLAGS, LDFLAGS, nocallback and noescape directives,
so they don't make their way into _cgo_export.h.
2. parse the nocallback and noescape directives.</p>
               
               <pre><code class="language-go">func (f *File) ProcessCgoDirectives()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Record" data-name="Record">
               <h3>
                  Record 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Record" class="anchor" title="Link to Record">#</a>
               </h3>
               
               <p>Record what needs to be recorded about f.</p>
               
               <pre><code class="language-go">func (p *Package) Record(f *File)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set modifies the type representation.
If fargs are provided, repr is used as a format for fmt.Sprintf.
Otherwise, repr is used unprocessed as the type representation.</p>
               
               <pre><code class="language-go">func (tr *TypeRepr) Set(repr string, fargs ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns the current type representation. Format arguments
are assembled within this method so that any changes in mutable
values are taken into account.</p>
               
               <pre><code class="language-go">func (tr *TypeRepr) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Struct" data-name="Struct">
               <h3>
                  Struct 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Struct" class="anchor" title="Link to Struct">#</a>
               </h3>
               
               <p>Struct conversion: return Go and (gc) C syntax for type.</p>
               
               <pre><code class="language-go">func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.StructType, csyntax string, align int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Translate" data-name="Translate">
               <h3>
                  Translate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Translate" class="anchor" title="Link to Translate">#</a>
               </h3>
               
               <p>Translate rewrites f.AST, the original Go input, to remove
references to the imported package C, replacing them with
references to the equivalent Go types, functions, and variables.</p>
               
               <pre><code class="language-go">func (p *Package) Translate(f *File)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <p>Type returns a *Type with the same memory layout as
dtype when used as the type of a variable or a struct field.</p>
               
               <pre><code class="language-go">func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addToFlag" data-name="addToFlag">
               <h3>
                  addToFlag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addToFlag" class="anchor" title="Link to addToFlag">#</a>
               </h3>
               
               <p>addToFlag appends args to flag.</p>
               
               <pre><code class="language-go">func (p *Package) addToFlag(flag string, args []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="anonymousStructTypedef" data-name="anonymousStructTypedef">
               <h3>
                  anonymousStructTypedef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#anonymousStructTypedef" class="anchor" title="Link to anonymousStructTypedef">#</a>
               </h3>
               
               <p>anonymousStructTypedef reports whether dt is a C typedef for an anonymous
struct.</p>
               
               <pre><code class="language-go">func (c *typeConv) anonymousStructTypedef(dt *dwarf.TypedefType) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badCFType" data-name="badCFType">
               <h3>
                  badCFType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#badCFType" class="anchor" title="Link to badCFType">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *typeConv) badCFType(dt *dwarf.TypedefType) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badEGLType" data-name="badEGLType">
               <h3>
                  badEGLType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#badEGLType" class="anchor" title="Link to badEGLType">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *typeConv) badEGLType(dt *dwarf.TypedefType) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badJNI" data-name="badJNI">
               <h3>
                  badJNI 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#badJNI" class="anchor" title="Link to badJNI">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *typeConv) badJNI(dt *dwarf.TypedefType) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badPointerTypedef" data-name="badPointerTypedef">
               <h3>
                  badPointerTypedef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#badPointerTypedef" class="anchor" title="Link to badPointerTypedef">#</a>
               </h3>
               
               <p>badPointerTypedef reports whether dt is a C typedef that should not be
considered a pointer in Go. A typedef is bad if C code sometimes stores
non-pointers in this type.
TODO: Currently our best solution is to find these manually and list them as
they come up. A better solution is desired.
Note: DEPRECATED. There is now a better solution. Search for incomplete in this file.</p>
               
               <pre><code class="language-go">func (c *typeConv) badPointerTypedef(dt *dwarf.TypedefType) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badStructPointerTypedef" data-name="badStructPointerTypedef">
               <h3>
                  badStructPointerTypedef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#badStructPointerTypedef" class="anchor" title="Link to badStructPointerTypedef">#</a>
               </h3>
               
               <p>badStructPointerTypedef is like badVoidPointerTypedef but for structs.</p>
               
               <pre><code class="language-go">func (c *typeConv) badStructPointerTypedef(name string, dt *dwarf.StructType) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badVoidPointerTypedef" data-name="badVoidPointerTypedef">
               <h3>
                  badVoidPointerTypedef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#badVoidPointerTypedef" class="anchor" title="Link to badVoidPointerTypedef">#</a>
               </h3>
               
               <p>badVoidPointerTypedef is like badPointerTypeDef, but for "void *" typedefs that should be _cgopackage.Incomplete.</p>
               
               <pre><code class="language-go">func (c *typeConv) badVoidPointerTypedef(dt *dwarf.TypedefType) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="base" data-name="base">
               <h3>
                  base 
                  <span class="badge">function</span>
                  
                  <a href="#base" class="anchor" title="Link to base">#</a>
               </h3>
               
               <p>base strips away qualifiers and typedefs to get the underlying type.</p>
               
               <pre><code class="language-go">func base(dt dwarf.Type) dwarf.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="baseBadPointerTypedef" data-name="baseBadPointerTypedef">
               <h3>
                  baseBadPointerTypedef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#baseBadPointerTypedef" class="anchor" title="Link to baseBadPointerTypedef">#</a>
               </h3>
               
               <p>baseBadPointerTypedef reports whether the base of a chain of typedefs is a bad typedef
as badPointerTypedef reports.</p>
               
               <pre><code class="language-go">func (c *typeConv) baseBadPointerTypedef(dt *dwarf.TypedefType) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="c" data-name="c">
               <h3>
                  c 
                  <span class="badge">function</span>
                  
                  <a href="#c" class="anchor" title="Link to c">#</a>
               </h3>
               
               <pre><code class="language-go">func c(repr string, args ...interface{}) *TypeRepr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cPrologGccgo" data-name="cPrologGccgo">
               <h3>
                  cPrologGccgo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cPrologGccgo" class="anchor" title="Link to cPrologGccgo">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Package) cPrologGccgo() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cgoType" data-name="cgoType">
               <h3>
                  cgoType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cgoType" class="anchor" title="Link to cgoType">#</a>
               </h3>
               
               <p>Map an ast type to a Type.</p>
               
               <pre><code class="language-go">func (p *Package) cgoType(e ast.Expr) *Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkAddr" data-name="checkAddr">
               <h3>
                  checkAddr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkAddr" class="anchor" title="Link to checkAddr">#</a>
               </h3>
               
               <p>checkAddr checks whether arg has the form &x, possibly inside type
conversions. If so, it writes
_cgoBaseNN := &x
_cgoNN := _cgoBaseNN // with type conversions, if any
to sb, and writes
_cgoCheckPointer(_cgoBaseNN, true)
to sbCheck, and returns true. This tells _cgoCheckPointer to check
just the contents of the pointer being passed, not any other part
of the memory allocation. This is run after checkIndex, which looks
for the special case of &a[i], which requires different checks.</p>
               
               <pre><code class="language-go">func (p *Package) checkAddr(sb *bytes.Buffer, sbCheck *bytes.Buffer, arg ast.Expr, i int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkGCCBaseCmd" data-name="checkGCCBaseCmd">
               <h3>
                  checkGCCBaseCmd 
                  <span class="badge">function</span>
                  
                  <a href="#checkGCCBaseCmd" class="anchor" title="Link to checkGCCBaseCmd">#</a>
               </h3>
               
               <p>checkGCCBaseCmd returns the start of the compiler command line.
It uses $CC if set, or else $GCC, or else the compiler recorded
during the initial build as defaultCC.
defaultCC is defined in zdefaultcc.go, written by cmd/dist.
The compiler command line is split into arguments on whitespace. Quotes
are understood, so arguments may contain whitespace.
checkGCCBaseCmd confirms that the compiler exists in PATH, returning
an error if it does not.</p>
               
               <pre><code class="language-go">func checkGCCBaseCmd() ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkImportSymName" data-name="checkImportSymName">
               <h3>
                  checkImportSymName 
                  <span class="badge">function</span>
                  
                  <a href="#checkImportSymName" class="anchor" title="Link to checkImportSymName">#</a>
               </h3>
               
               <p>checkImportSymName checks a symbol name we are going to emit as part
of a //go:cgo_import_dynamic pragma. These names come from object
files, so they may be corrupt. We are going to emit them unquoted,
so while they don't need to be valid symbol names (and in some cases,
involving symbol versions, they won't be) they must contain only
graphic characters and must not contain Go comments.</p>
               
               <pre><code class="language-go">func checkImportSymName(s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkIndex" data-name="checkIndex">
               <h3>
                  checkIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkIndex" class="anchor" title="Link to checkIndex">#</a>
               </h3>
               
               <p>checkIndex checks whether arg has the form &a[i], possibly inside
type conversions. If so, then in the general case it writes
_cgoIndexNN := a
_cgoNN := &cgoIndexNN[i] // with type conversions, if any
to sb, and writes
_cgoCheckPointer(_cgoNN, _cgoIndexNN)
to sbCheck, and returns true. If a is a simple variable or field reference,
it writes
_cgoIndexNN := &a
and dereferences the uses of _cgoIndexNN. Taking the address avoids
making a copy of an array.
This tells _cgoCheckPointer to check the complete contents of the
slice or array being indexed, but no other part of the memory allocation.</p>
               
               <pre><code class="language-go">func (p *Package) checkIndex(sb *bytes.Buffer, sbCheck *bytes.Buffer, arg ast.Expr, i int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkSlice" data-name="checkSlice">
               <h3>
                  checkSlice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkSlice" class="anchor" title="Link to checkSlice">#</a>
               </h3>
               
               <p>checkSlice checks whether arg has the form x[i:j], possibly inside
type conversions. If so, it writes
_cgoSliceNN := x[i:j]
_cgoNN := _cgoSliceNN // with type conversions, if any
to sb, and writes
_cgoCheckPointer(_cgoSliceNN, true)
to sbCheck, and returns true. This tells _cgoCheckPointer to check
just the contents of the slice being passed, not any other part
of the memory allocation.</p>
               
               <pre><code class="language-go">func (p *Package) checkSlice(sb *bytes.Buffer, sbCheck *bytes.Buffer, arg ast.Expr, i int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkUnsafeStringData" data-name="checkUnsafeStringData">
               <h3>
                  checkUnsafeStringData 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkUnsafeStringData" class="anchor" title="Link to checkUnsafeStringData">#</a>
               </h3>
               
               <p>checkUnsafeStringData checks for a call to unsafe.StringData.
The result of that call can't contain a pointer so there is
no need to call _cgoCheckPointer.</p>
               
               <pre><code class="language-go">func (p *Package) checkUnsafeStringData(arg ast.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cname" data-name="cname">
               <h3>
                  cname 
                  <span class="badge">function</span>
                  
                  <a href="#cname" class="anchor" title="Link to cname">#</a>
               </h3>
               
               <p>cname returns the C name to use for C.s.
The expansions are listed in nameToC and also
struct_foo becomes "struct foo", and similarly for
union and enum.</p>
               
               <pre><code class="language-go">func cname(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="commentText" data-name="commentText">
               <h3>
                  commentText 
                  <span class="badge">function</span>
                  
                  <a href="#commentText" class="anchor" title="Link to commentText">#</a>
               </h3>
               
               <p>Like ast.CommentGroup's Text method but preserves
leading blank lines, so that line numbers line up.</p>
               
               <pre><code class="language-go">func commentText(g *ast.CommentGroup) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="creat" data-name="creat">
               <h3>
                  creat 
                  <span class="badge">function</span>
                  
                  <a href="#creat" class="anchor" title="Link to creat">#</a>
               </h3>
               
               <pre><code class="language-go">func creat(name string) *os.File</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defaultCC" data-name="defaultCC">
               <h3>
                  defaultCC 
                  <span class="badge">function</span>
                  
                  <a href="#defaultCC" class="anchor" title="Link to defaultCC">#</a>
               </h3>
               
               <pre><code class="language-go">func defaultCC(goos string, goarch string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defaultCXX" data-name="defaultCXX">
               <h3>
                  defaultCXX 
                  <span class="badge">function</span>
                  
                  <a href="#defaultCXX" class="anchor" title="Link to defaultCXX">#</a>
               </h3>
               
               <pre><code class="language-go">func defaultCXX(goos string, goarch string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doCgoType" data-name="doCgoType">
               <h3>
                  doCgoType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doCgoType" class="anchor" title="Link to doCgoType">#</a>
               </h3>
               
               <p>Map an ast type to a Type, avoiding cycles.</p>
               
               <pre><code class="language-go">func (p *Package) doCgoType(e ast.Expr, m map[ast.Expr]bool) *Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dwarfHasPointer" data-name="dwarfHasPointer">
               <h3>
                  dwarfHasPointer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dwarfHasPointer" class="anchor" title="Link to dwarfHasPointer">#</a>
               </h3>
               
               <p>dwarfHasPointer reports whether the DWARF type dt contains a pointer.</p>
               
               <pre><code class="language-go">func (c *typeConv) dwarfHasPointer(dt dwarf.Type, pos token.Pos) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dynimport" data-name="dynimport">
               <h3>
                  dynimport 
                  <span class="badge">function</span>
                  
                  <a href="#dynimport" class="anchor" title="Link to dynimport">#</a>
               </h3>
               
               <pre><code class="language-go">func dynimport(obj string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="elfImportedSymbols" data-name="elfImportedSymbols">
               <h3>
                  elfImportedSymbols 
                  <span class="badge">function</span>
                  
                  <a href="#elfImportedSymbols" class="anchor" title="Link to elfImportedSymbols">#</a>
               </h3>
               
               <p>elfImportedSymbols is like elf.File.ImportedSymbols, but it
includes weak symbols.
A bug in some versions of LLD (at least LLD 8) cause it to emit
several pthreads symbols as weak, but we need to import those. See
issue #31912 or https://bugs.llvm.org/show_bug.cgi?id=42442.
When doing external linking, we hand everything off to the external
linker, which will create its own dynamic symbol tables. For
internal linking, this may turn weak imports into strong imports,
which could cause dynamic linking to fail if a symbol really isn't
defined. However, the standard library depends on everything it
imports, and this is the primary use of dynamic symbol tables with
internal linking.</p>
               
               <pre><code class="language-go">func elfImportedSymbols(f *elf.File) []elf.ImportedSymbol</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="error_" data-name="error_">
               <h3>
                  error_ 
                  <span class="badge">function</span>
                  
                  <a href="#error_" class="anchor" title="Link to error_">#</a>
               </h3>
               
               <pre><code class="language-go">func error_(pos token.Pos, msg string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exportParamName" data-name="exportParamName">
               <h3>
                  exportParamName 
                  <span class="badge">function</span>
                  
                  <a href="#exportParamName" class="anchor" title="Link to exportParamName">#</a>
               </h3>
               
               <p>exportParamName returns the value of param as it should be
displayed in a c header file. If param contains any non-ASCII
characters, this function will return the character p followed by
the value of position; otherwise, this function will return the
value of param.</p>
               
               <pre><code class="language-go">func exportParamName(param string, position int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fatalf" data-name="fatalf">
               <h3>
                  fatalf 
                  <span class="badge">function</span>
                  
                  <a href="#fatalf" class="anchor" title="Link to fatalf">#</a>
               </h3>
               
               <p>Die with an error message.</p>
               
               <pre><code class="language-go">func fatalf(msg string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fieldPrefix" data-name="fieldPrefix">
               <h3>
                  fieldPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#fieldPrefix" class="anchor" title="Link to fieldPrefix">#</a>
               </h3>
               
               <p>fieldPrefix returns the prefix that should be removed from all the
field names when generating the C or Go code. For generated
C, we leave the names as is (tv_sec, tv_usec), since that's what
people are used to seeing in C.  For generated Go code, such as
package syscall's data structures, we drop a common prefix
(so sec, usec, which will get turned into Sec, Usec for exporting).</p>
               
               <pre><code class="language-go">func fieldPrefix(fld []*ast.Field) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fixGo" data-name="fixGo">
               <h3>
                  fixGo 
                  <span class="badge">function</span>
                  
                  <a href="#fixGo" class="anchor" title="Link to fixGo">#</a>
               </h3>
               
               <p>fixGo converts the internal Name.Go field into the name we should show
to users in error messages. There's only one for now: on input we rewrite
C.malloc into C._CMalloc, so change it back here.</p>
               
               <pre><code class="language-go">func fixGo(name string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="forFieldList" data-name="forFieldList">
               <h3>
                  forFieldList 
                  <span class="badge">function</span>
                  
                  <a href="#forFieldList" class="anchor" title="Link to forFieldList">#</a>
               </h3>
               
               <p>Call a function for each entry in an ast.FieldList, passing the
index into the list, the name if any, and the type.</p>
               
               <pre><code class="language-go">func forFieldList(fl *ast.FieldList, fn func(int, string, ast.Expr))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcTypeTypeParams" data-name="funcTypeTypeParams">
               <h3>
                  funcTypeTypeParams 
                  <span class="badge">function</span>
                  
                  <a href="#funcTypeTypeParams" class="anchor" title="Link to funcTypeTypeParams">#</a>
               </h3>
               
               <pre><code class="language-go">func funcTypeTypeParams(n *ast.FuncType) *ast.FieldList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcTypeTypeParams" data-name="funcTypeTypeParams">
               <h3>
                  funcTypeTypeParams 
                  <span class="badge">function</span>
                  
                  <a href="#funcTypeTypeParams" class="anchor" title="Link to funcTypeTypeParams">#</a>
               </h3>
               
               <pre><code class="language-go">func funcTypeTypeParams(n *ast.FuncType) *ast.FieldList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fuzzyMatch" data-name="fuzzyMatch">
               <h3>
                  fuzzyMatch 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fuzzyMatch" class="anchor" title="Link to fuzzyMatch">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *Type) fuzzyMatch(t2 *Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fuzzyMatch" data-name="fuzzyMatch">
               <h3>
                  fuzzyMatch 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fuzzyMatch" class="anchor" title="Link to fuzzyMatch">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *FuncType) fuzzyMatch(t2 *FuncType) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccCmd" data-name="gccCmd">
               <h3>
                  gccCmd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gccCmd" class="anchor" title="Link to gccCmd">#</a>
               </h3>
               
               <p>gccCmd returns the gcc command line to use for compiling
the input.</p>
               
               <pre><code class="language-go">func (p *Package) gccCmd() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccDebug" data-name="gccDebug">
               <h3>
                  gccDebug 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gccDebug" class="anchor" title="Link to gccDebug">#</a>
               </h3>
               
               <p>gccDebug runs gcc -gdwarf-2 over the C program stdin and
returns the corresponding DWARF data and, if present, debug data block.</p>
               
               <pre><code class="language-go">func (p *Package) gccDebug(stdin []byte, nnames int) (d *dwarf.Data, ints []int64, floats []float64, strs []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccDefines" data-name="gccDefines">
               <h3>
                  gccDefines 
                  <span class="badge">function</span>
                  
                  <a href="#gccDefines" class="anchor" title="Link to gccDefines">#</a>
               </h3>
               
               <p>gccDefines runs gcc -E -dM -xc - over the C program stdin
and returns the corresponding standard output, which is the
#defines that gcc encountered while processing the input
and its included files.</p>
               
               <pre><code class="language-go">func gccDefines(stdin []byte, gccOptions []string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccErrors" data-name="gccErrors">
               <h3>
                  gccErrors 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gccErrors" class="anchor" title="Link to gccErrors">#</a>
               </h3>
               
               <p>gccErrors runs gcc over the C program stdin and returns
the errors that gcc prints. That is, this function expects
gcc to fail.</p>
               
               <pre><code class="language-go">func (p *Package) gccErrors(stdin []byte, extraArgs ...string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccExportHeaderProlog" data-name="gccExportHeaderProlog">
               <h3>
                  gccExportHeaderProlog 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gccExportHeaderProlog" class="anchor" title="Link to gccExportHeaderProlog">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Package) gccExportHeaderProlog() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccMachine" data-name="gccMachine">
               <h3>
                  gccMachine 
                  <span class="badge">function</span>
                  
                  <a href="#gccMachine" class="anchor" title="Link to gccMachine">#</a>
               </h3>
               
               <p>gccMachine returns the gcc -m flag to use, either "-m32", "-m64" or "-marm".</p>
               
               <pre><code class="language-go">func gccMachine() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccTmp" data-name="gccTmp">
               <h3>
                  gccTmp 
                  <span class="badge">function</span>
                  
                  <a href="#gccTmp" class="anchor" title="Link to gccTmp">#</a>
               </h3>
               
               <pre><code class="language-go">func gccTmp() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccgoSymbolPrefix" data-name="gccgoSymbolPrefix">
               <h3>
                  gccgoSymbolPrefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gccgoSymbolPrefix" class="anchor" title="Link to gccgoSymbolPrefix">#</a>
               </h3>
               
               <p>Return the package prefix when using gccgo.</p>
               
               <pre><code class="language-go">func (p *Package) gccgoSymbolPrefix() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccgoToSymbol" data-name="gccgoToSymbol">
               <h3>
                  gccgoToSymbol 
                  <span class="badge">function</span>
                  
                  <a href="#gccgoToSymbol" class="anchor" title="Link to gccgoToSymbol">#</a>
               </h3>
               
               <p>gccgoToSymbol converts a name to a mangled symbol for gccgo.</p>
               
               <pre><code class="language-go">func gccgoToSymbol(ppath string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="godefs" data-name="godefs">
               <h3>
                  godefs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#godefs" class="anchor" title="Link to godefs">#</a>
               </h3>
               
               <p>godefs returns the output for -godefs mode.</p>
               
               <pre><code class="language-go">func (p *Package) godefs(f *File, args []string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="godefsFields" data-name="godefsFields">
               <h3>
                  godefsFields 
                  <span class="badge">function</span>
                  
                  <a href="#godefsFields" class="anchor" title="Link to godefsFields">#</a>
               </h3>
               
               <p>godefsFields rewrites field names for use in Go or C definitions.
It strips leading common prefixes (like tv_ in tv_sec, tv_usec)
converts names to upper case, and rewrites _ into Pad_godefs_n,
so that all fields are exported.</p>
               
               <pre><code class="language-go">func godefsFields(fld []*ast.Field)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gofmt" data-name="gofmt">
               <h3>
                  gofmt 
                  <span class="badge">function</span>
                  
                  <a href="#gofmt" class="anchor" title="Link to gofmt">#</a>
               </h3>
               
               <p>gofmt returns the gofmt-formatted string for an AST node.</p>
               
               <pre><code class="language-go">func gofmt(n interface{}) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gofmtPos" data-name="gofmtPos">
               <h3>
                  gofmtPos 
                  <span class="badge">function</span>
                  
                  <a href="#gofmtPos" class="anchor" title="Link to gofmtPos">#</a>
               </h3>
               
               <p>gofmtPos returns the gofmt-formatted string for an AST node,
with a comment setting the position before the node.</p>
               
               <pre><code class="language-go">func gofmtPos(n ast.Expr, pos token.Pos) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="guessKinds" data-name="guessKinds">
               <h3>
                  guessKinds 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#guessKinds" class="anchor" title="Link to guessKinds">#</a>
               </h3>
               
               <p>guessKinds tricks gcc into revealing the kind of each
name xxx for the references C.xxx in the Go input.
The kind is either a constant, type, or variable.</p>
               
               <pre><code class="language-go">func (p *Package) guessKinds(f *File) []*Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasPointer" data-name="hasPointer">
               <h3>
                  hasPointer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasPointer" class="anchor" title="Link to hasPointer">#</a>
               </h3>
               
               <p>hasPointer is used by needsPointerCheck. If top is true it returns
whether t is or contains a pointer that might point to a pointer.
If top is false it reports whether t is or contains a pointer.
f may be nil.</p>
               
               <pre><code class="language-go">func (p *Package) hasPointer(f *File, t ast.Expr, top bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="incompleteTypedef" data-name="incompleteTypedef">
               <h3>
                  incompleteTypedef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#incompleteTypedef" class="anchor" title="Link to incompleteTypedef">#</a>
               </h3>
               
               <p>incompleteTypedef reports whether t appears to be an incomplete
typedef definition.</p>
               
               <pre><code class="language-go">func (p *Package) incompleteTypedef(t *Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="intExpr" data-name="intExpr">
               <h3>
                  intExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#intExpr" class="anchor" title="Link to intExpr">#</a>
               </h3>
               
               <p>Expr for integer n.</p>
               
               <pre><code class="language-go">func (c *typeConv) intExpr(n int64) ast.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isMangledName" data-name="isMangledName">
               <h3>
                  isMangledName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isMangledName" class="anchor" title="Link to isMangledName">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) isMangledName(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isStructUnionClass" data-name="isStructUnionClass">
               <h3>
                  isStructUnionClass 
                  <span class="badge">function</span>
                  
                  <a href="#isStructUnionClass" class="anchor" title="Link to isStructUnionClass">#</a>
               </h3>
               
               <p>isStructUnionClass reports whether the type described by the Go syntax x
is a struct, union, or class with a tag.</p>
               
               <pre><code class="language-go">func isStructUnionClass(x ast.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isType" data-name="isType">
               <h3>
                  isType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isType" class="anchor" title="Link to isType">#</a>
               </h3>
               
               <p>isType reports whether the expression is definitely a type.
This is conservative--it returns false for an unknown identifier.</p>
               
               <pre><code class="language-go">func (p *Package) isType(t ast.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isUnsafeData" data-name="isUnsafeData">
               <h3>
                  isUnsafeData 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isUnsafeData" class="anchor" title="Link to isUnsafeData">#</a>
               </h3>
               
               <p>isUnsafeData reports whether the expression is unsafe.StringData
or unsafe.SliceData. We can ignore these when checking for pointers
because they don't change whether or not their argument contains
any Go pointers. If onlyStringData is true we only check for StringData.</p>
               
               <pre><code class="language-go">func (p *Package) isUnsafeData(x ast.Expr, onlyStringData bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isVariable" data-name="isVariable">
               <h3>
                  isVariable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isVariable" class="anchor" title="Link to isVariable">#</a>
               </h3>
               
               <p>isVariable reports whether x is a variable, possibly with field references.</p>
               
               <pre><code class="language-go">func (p *Package) isVariable(x ast.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lineno" data-name="lineno">
               <h3>
                  lineno 
                  <span class="badge">function</span>
                  
                  <a href="#lineno" class="anchor" title="Link to lineno">#</a>
               </h3>
               
               <pre><code class="language-go">func lineno(pos token.Pos) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadDWARF" data-name="loadDWARF">
               <h3>
                  loadDWARF 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#loadDWARF" class="anchor" title="Link to loadDWARF">#</a>
               </h3>
               
               <p>loadDWARF parses the DWARF debug information generated
by gcc to learn the details of the constants, variables, and types
being referred to as C.xxx.</p>
               
               <pre><code class="language-go">func (p *Package) loadDWARF(f *File, conv *typeConv, names []*Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadDefines" data-name="loadDefines">
               <h3>
                  loadDefines 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#loadDefines" class="anchor" title="Link to loadDefines">#</a>
               </h3>
               
               <p>loadDefines coerces gcc into spitting out the #defines in use
in the file f and saves relevant renamings in f.Name[name].Define.
Returns true if env:CC is Clang</p>
               
               <pre><code class="language-go">func (f *File) loadDefines(gccOptions []string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadType" data-name="loadType">
               <h3>
                  loadType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#loadType" class="anchor" title="Link to loadType">#</a>
               </h3>
               
               <p>loadType recursively loads the requested dtype and its dependency graph.</p>
               
               <pre><code class="language-go">func (c *typeConv) loadType(dtype dwarf.Type, pos token.Pos, parent string) *Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="main" data-name="main">
               <h3>
                  main 
                  <span class="badge">function</span>
                  
                  <a href="#main" class="anchor" title="Link to main">#</a>
               </h3>
               
               <pre><code class="language-go">func main()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mangle" data-name="mangle">
               <h3>
                  mangle 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mangle" class="anchor" title="Link to mangle">#</a>
               </h3>
               
               <p>mangle replaces references to C names in arg with the mangled names,
rewriting calls when it finds them.
It removes the corresponding references in f.Ref and f.Calls, so that we
don't try to do the replacement again in rewriteRef or rewriteCall.
If addPosition is true, add position info to the idents of C names in arg.</p>
               
               <pre><code class="language-go">func (p *Package) mangle(f *File, arg *ast.Expr, addPosition bool) (ast.Expr, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mangleName" data-name="mangleName">
               <h3>
                  mangleName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mangleName" class="anchor" title="Link to mangleName">#</a>
               </h3>
               
               <p>mangleName does name mangling to translate names
from the original Go source files to the names
used in the final Go files generated by cgo.</p>
               
               <pre><code class="language-go">func (p *Package) mangleName(n *Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nameKeys" data-name="nameKeys">
               <h3>
                  nameKeys 
                  <span class="badge">function</span>
                  
                  <a href="#nameKeys" class="anchor" title="Link to nameKeys">#</a>
               </h3>
               
               <pre><code class="language-go">func nameKeys(m map[string]*Name) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="needsPointerCheck" data-name="needsPointerCheck">
               <h3>
                  needsPointerCheck 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#needsPointerCheck" class="anchor" title="Link to needsPointerCheck">#</a>
               </h3>
               
               <p>needsPointerCheck reports whether the type t needs a pointer check.
This is true if t is a pointer and if the value to which it points
might contain a pointer.</p>
               
               <pre><code class="language-go">func (p *Package) needsPointerCheck(f *File, t ast.Expr, arg ast.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newPackage" data-name="newPackage">
               <h3>
                  newPackage 
                  <span class="badge">function</span>
                  
                  <a href="#newPackage" class="anchor" title="Link to newPackage">#</a>
               </h3>
               
               <p>newPackage returns a new Package that will invoke
gcc with the additional arguments specified in args.</p>
               
               <pre><code class="language-go">func newPackage(args []string) *Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="offset" data-name="offset">
               <h3>
                  offset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#offset" class="anchor" title="Link to offset">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) offset(p token.Pos) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="packedAttribute" data-name="packedAttribute">
               <h3>
                  packedAttribute 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#packedAttribute" class="anchor" title="Link to packedAttribute">#</a>
               </h3>
               
               <p>packedAttribute returns host compiler struct attribute that will be
used to match gc's struct layout. For example, on 386 Windows,
gcc wants to 8-align int64s, but gc does not.
Use __gcc_struct__ to work around https://gcc.gnu.org/PR52991 on x86,
and https://golang.org/issue/5603.</p>
               
               <pre><code class="language-go">func (p *Package) packedAttribute() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pad" data-name="pad">
               <h3>
                  pad 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pad" class="anchor" title="Link to pad">#</a>
               </h3>
               
               <p>Add padding of given size to fld.</p>
               
               <pre><code class="language-go">func (c *typeConv) pad(fld []*ast.Field, sizes []int64, size int64) ([]*ast.Field, []int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parse" data-name="parse">
               <h3>
                  parse 
                  <span class="badge">function</span>
                  
                  <a href="#parse" class="anchor" title="Link to parse">#</a>
               </h3>
               
               <pre><code class="language-go">func parse(name string, src []byte, flags parser.Mode) *ast.File</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="prepareNames" data-name="prepareNames">
               <h3>
                  prepareNames 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#prepareNames" class="anchor" title="Link to prepareNames">#</a>
               </h3>
               
               <p>prepareNames finalizes the Kind field of not-type names and sets
the mangled name of all names.</p>
               
               <pre><code class="language-go">func (p *Package) prepareNames(f *File)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordTypedefs" data-name="recordTypedefs">
               <h3>
                  recordTypedefs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordTypedefs" class="anchor" title="Link to recordTypedefs">#</a>
               </h3>
               
               <p>recordTypedefs remembers in p.typedefs all the typedefs used in dtypes and its children.</p>
               
               <pre><code class="language-go">func (p *Package) recordTypedefs(dtype dwarf.Type, pos token.Pos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordTypedefs1" data-name="recordTypedefs1">
               <h3>
                  recordTypedefs1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordTypedefs1" class="anchor" title="Link to recordTypedefs1">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Package) recordTypedefs1(dtype dwarf.Type, pos token.Pos, visited map[dwarf.Type]bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rewriteCall" data-name="rewriteCall">
               <h3>
                  rewriteCall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rewriteCall" class="anchor" title="Link to rewriteCall">#</a>
               </h3>
               
               <p>rewriteCall rewrites one call to add pointer checks.
If any pointer checks are required, we rewrite the call into a
function literal that calls _cgoCheckPointer for each pointer
argument and then calls the original function.
This returns the rewritten call and whether the package needs to
import unsafe as _cgo_unsafe.
If it returns the empty string, the call did not need to be rewritten.</p>
               
               <pre><code class="language-go">func (p *Package) rewriteCall(f *File, call *Call) (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rewriteCalls" data-name="rewriteCalls">
               <h3>
                  rewriteCalls 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rewriteCalls" class="anchor" title="Link to rewriteCalls">#</a>
               </h3>
               
               <p>rewriteCalls rewrites all calls that pass pointers to check that
they follow the rules for passing pointers between Go and C.
This reports whether the package needs to import unsafe as _cgo_unsafe.</p>
               
               <pre><code class="language-go">func (p *Package) rewriteCalls(f *File) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rewriteName" data-name="rewriteName">
               <h3>
                  rewriteName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rewriteName" class="anchor" title="Link to rewriteName">#</a>
               </h3>
               
               <p>rewriteName returns the expression used to rewrite a reference.
If addPosition is true, add position info in the ident name.</p>
               
               <pre><code class="language-go">func (p *Package) rewriteName(f *File, r *Ref, addPosition bool) ast.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rewriteRef" data-name="rewriteRef">
               <h3>
                  rewriteRef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rewriteRef" class="anchor" title="Link to rewriteRef">#</a>
               </h3>
               
               <p>rewriteRef rewrites all the C.xxx references in f.AST to refer to the
Go equivalents, now that we have figured out the meaning of all
the xxx. In *godefs mode, rewriteRef replaces the names
with full definitions instead of mangled names.</p>
               
               <pre><code class="language-go">func (p *Package) rewriteRef(f *File)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rewriteUnsafe" data-name="rewriteUnsafe">
               <h3>
                  rewriteUnsafe 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rewriteUnsafe" class="anchor" title="Link to rewriteUnsafe">#</a>
               </h3>
               
               <p>rewriteUnsafe returns a version of t with references to unsafe.Pointer
rewritten to use _cgo_unsafe.Pointer instead.</p>
               
               <pre><code class="language-go">func (p *Package) rewriteUnsafe(t ast.Expr) ast.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="run" data-name="run">
               <h3>
                  run 
                  <span class="badge">function</span>
                  
                  <a href="#run" class="anchor" title="Link to run">#</a>
               </h3>
               
               <p>run runs the command argv, feeding in stdin on standard input.
It returns the output to standard output and standard error.
ok indicates whether the command exited successfully.</p>
               
               <pre><code class="language-go">func run(stdin []byte, argv []string) (stdout []byte, stderr []byte, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runGcc" data-name="runGcc">
               <h3>
                  runGcc 
                  <span class="badge">function</span>
                  
                  <a href="#runGcc" class="anchor" title="Link to runGcc">#</a>
               </h3>
               
               <p>runGcc runs the gcc command line args with stdin on standard input.
If the command exits with a non-zero exit status, runGcc prints
details about what was run and exits.
Otherwise runGcc returns the data written to standard output and standard error.
Note that for some of the uses we expect useful data back
on standard error, but for those uses gcc must still exit 0.</p>
               
               <pre><code class="language-go">func runGcc(stdin []byte, args []string) (string, string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="saveCall" data-name="saveCall">
               <h3>
                  saveCall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#saveCall" class="anchor" title="Link to saveCall">#</a>
               </h3>
               
               <p>Save calls to C.xxx for later processing.</p>
               
               <pre><code class="language-go">func (f *File) saveCall(call *ast.CallExpr, context astContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="saveExport" data-name="saveExport">
               <h3>
                  saveExport 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#saveExport" class="anchor" title="Link to saveExport">#</a>
               </h3>
               
               <p>If a function should be exported add it to ExpFunc.</p>
               
               <pre><code class="language-go">func (f *File) saveExport(x interface{}, context astContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="saveExport2" data-name="saveExport2">
               <h3>
                  saveExport2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#saveExport2" class="anchor" title="Link to saveExport2">#</a>
               </h3>
               
               <p>Make f.ExpFunc[i] point at the Func from this AST instead of the other one.</p>
               
               <pre><code class="language-go">func (f *File) saveExport2(x interface{}, context astContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="saveExprs" data-name="saveExprs">
               <h3>
                  saveExprs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#saveExprs" class="anchor" title="Link to saveExprs">#</a>
               </h3>
               
               <p>Save various references we are going to need later.</p>
               
               <pre><code class="language-go">func (f *File) saveExprs(x interface{}, context astContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="saveRef" data-name="saveRef">
               <h3>
                  saveRef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#saveRef" class="anchor" title="Link to saveRef">#</a>
               </h3>
               
               <p>Save references to C.xxx for later processing.</p>
               
               <pre><code class="language-go">func (f *File) saveRef(n *ast.Expr, context astContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sourceLine" data-name="sourceLine">
               <h3>
                  sourceLine 
                  <span class="badge">function</span>
                  
                  <a href="#sourceLine" class="anchor" title="Link to sourceLine">#</a>
               </h3>
               
               <pre><code class="language-go">func sourceLine(n ast.Node) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitQuoted" data-name="splitQuoted">
               <h3>
                  splitQuoted 
                  <span class="badge">function</span>
                  
                  <a href="#splitQuoted" class="anchor" title="Link to splitQuoted">#</a>
               </h3>
               
               <p>splitQuoted splits the string s around each instance of one or more consecutive
white space characters while taking into account quotes and escaping, and
returns an array of substrings of s or an empty list if s contains only white space.
Single quotes and double quotes are recognized to prevent splitting within the
quoted region, and are removed from the resulting substrings. If a quote in s
isn't closed err will be set and r will have the unclosed argument as the
last element. The backslash is used for escaping.
For example, the following string:
`a b:"c d" 'e''f'  "g\""`
Would be parsed as:
[]string{"a", "b:c d", "ef", `g"`}</p>
               
               <pre><code class="language-go">func splitQuoted(s string) (r []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="structType" data-name="structType">
               <h3>
                  structType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#structType" class="anchor" title="Link to structType">#</a>
               </h3>
               
               <p>Construct a gcc struct matching the gc argument frame.
Assumes that in gcc, char is 1 byte, short 2 bytes, int 4 bytes, long long 8 bytes.
These assumptions are checked by the gccProlog.
Also assumes that gc convention is to word-align the
input and output parameters.</p>
               
               <pre><code class="language-go">func (p *Package) structType(n *Name) (string, int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeSpecTypeParams" data-name="typeSpecTypeParams">
               <h3>
                  typeSpecTypeParams 
                  <span class="badge">function</span>
                  
                  <a href="#typeSpecTypeParams" class="anchor" title="Link to typeSpecTypeParams">#</a>
               </h3>
               
               <pre><code class="language-go">func typeSpecTypeParams(n *ast.TypeSpec) *ast.FieldList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeSpecTypeParams" data-name="typeSpecTypeParams">
               <h3>
                  typeSpecTypeParams 
                  <span class="badge">function</span>
                  
                  <a href="#typeSpecTypeParams" class="anchor" title="Link to typeSpecTypeParams">#</a>
               </h3>
               
               <pre><code class="language-go">func typeSpecTypeParams(n *ast.TypeSpec) *ast.FieldList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unparen" data-name="unparen">
               <h3>
                  unparen 
                  <span class="badge">function</span>
                  
                  <a href="#unparen" class="anchor" title="Link to unparen">#</a>
               </h3>
               
               <p>If x is of the form (T), unparen returns unparen(T), otherwise it returns x.</p>
               
               <pre><code class="language-go">func unparen(x ast.Expr) ast.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unqual" data-name="unqual">
               <h3>
                  unqual 
                  <span class="badge">function</span>
                  
                  <a href="#unqual" class="anchor" title="Link to unqual">#</a>
               </h3>
               
               <p>unqual strips away qualifiers from a DWARF type.
In general we don't care about top-level qualifiers.</p>
               
               <pre><code class="language-go">func unqual(dt dwarf.Type) dwarf.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="upper" data-name="upper">
               <h3>
                  upper 
                  <span class="badge">function</span>
                  
                  <a href="#upper" class="anchor" title="Link to upper">#</a>
               </h3>
               
               <pre><code class="language-go">func upper(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="usage" data-name="usage">
               <h3>
                  usage 
                  <span class="badge">function</span>
                  
                  <a href="#usage" class="anchor" title="Link to usage">#</a>
               </h3>
               
               <pre><code class="language-go">func usage()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validateIdents" data-name="validateIdents">
               <h3>
                  validateIdents 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#validateIdents" class="anchor" title="Link to validateIdents">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) validateIdents(x interface{}, context astContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walk" data-name="walk">
               <h3>
                  walk 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#walk" class="anchor" title="Link to walk">#</a>
               </h3>
               
               <p>walk walks the AST x, calling visit(f, x, context) for each node.</p>
               
               <pre><code class="language-go">func (f *File) walk(x interface{}, context astContext, visit func(*File, interface{}, astContext))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkUnexpected" data-name="walkUnexpected">
               <h3>
                  walkUnexpected 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#walkUnexpected" class="anchor" title="Link to walkUnexpected">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) walkUnexpected(x interface{}, context astContext, visit func(*File, interface{}, astContext))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkUnexpected" data-name="walkUnexpected">
               <h3>
                  walkUnexpected 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#walkUnexpected" class="anchor" title="Link to walkUnexpected">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) walkUnexpected(x interface{}, context astContext, visit func(*File, interface{}, astContext))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeDefs" data-name="writeDefs">
               <h3>
                  writeDefs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeDefs" class="anchor" title="Link to writeDefs">#</a>
               </h3>
               
               <p>writeDefs creates output files to be compiled by gc and gcc.</p>
               
               <pre><code class="language-go">func (p *Package) writeDefs()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeDefsFunc" data-name="writeDefsFunc">
               <h3>
                  writeDefsFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeDefsFunc" class="anchor" title="Link to writeDefsFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Package) writeDefsFunc(fgo2 io.Writer, n *Name, callsMalloc *bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeExportHeader" data-name="writeExportHeader">
               <h3>
                  writeExportHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeExportHeader" class="anchor" title="Link to writeExportHeader">#</a>
               </h3>
               
               <p>writeExportHeader writes out the start of the _cgo_export.h file.</p>
               
               <pre><code class="language-go">func (p *Package) writeExportHeader(fgcch io.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeExports" data-name="writeExports">
               <h3>
                  writeExports 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeExports" class="anchor" title="Link to writeExports">#</a>
               </h3>
               
               <p>Write out the various stubs we need to support functions exported
from Go so that they are callable from C.</p>
               
               <pre><code class="language-go">func (p *Package) writeExports(fgo2 io.Writer, fm io.Writer, fgcc io.Writer, fgcch io.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeGccgoExports" data-name="writeGccgoExports">
               <h3>
                  writeGccgoExports 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeGccgoExports" class="anchor" title="Link to writeGccgoExports">#</a>
               </h3>
               
               <p>Write out the C header allowing C code to call exported gccgo functions.</p>
               
               <pre><code class="language-go">func (p *Package) writeGccgoExports(fgo2 io.Writer, fm io.Writer, fgcc io.Writer, fgcch io.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeGccgoOutputFunc" data-name="writeGccgoOutputFunc">
               <h3>
                  writeGccgoOutputFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeGccgoOutputFunc" class="anchor" title="Link to writeGccgoOutputFunc">#</a>
               </h3>
               
               <p>Write out a wrapper for a function when using gccgo. This is a
simple wrapper that just calls the real function. We only need a
wrapper to support static functions in the prologue--without a
wrapper, we can't refer to the function, since the reference is in
a different file.</p>
               
               <pre><code class="language-go">func (p *Package) writeGccgoOutputFunc(fgcc *os.File, n *Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeOutput" data-name="writeOutput">
               <h3>
                  writeOutput 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeOutput" class="anchor" title="Link to writeOutput">#</a>
               </h3>
               
               <p>writeOutput creates stubs for a specific source file to be compiled by gc</p>
               
               <pre><code class="language-go">func (p *Package) writeOutput(f *File, srcfile string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeOutputFunc" data-name="writeOutputFunc">
               <h3>
                  writeOutputFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeOutputFunc" class="anchor" title="Link to writeOutputFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Package) writeOutputFunc(fgcc *os.File, n *Name)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>