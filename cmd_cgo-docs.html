<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - main</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>main</code>
         </h1>
         <hr />
         
         <article class="global" data-name="debugDefine">
            <h2>debugDefine</h2>
            <hr />
            
            <pre><code>debugDefine</code></pre>
         </article>
         
         <article class="global" data-name="debugGcc">
            <h2>debugGcc</h2>
            <hr />
            
            <pre><code>debugGcc</code></pre>
         </article>
         
         <article class="global" data-name="nameToC">
            <h2>nameToC</h2>
            <hr />
            
            <pre><code>nameToC</code></pre>
         </article>
         
         <article class="global" data-name="incomplete">
            <h2>incomplete</h2>
            <hr />
            
            <pre><code>incomplete</code></pre>
         </article>
         
         <article class="global" data-name="tagGen">
            <h2>tagGen</h2>
            <hr />
            
            <pre><code>tagGen int</code></pre>
         </article>
         
         <article class="global" data-name="typedef">
            <h2>typedef</h2>
            <hr />
            
            <pre><code>typedef</code></pre>
         </article>
         
         <article class="global" data-name="goIdent">
            <h2>goIdent</h2>
            <hr />
            
            <pre><code>goIdent</code></pre>
         </article>
         
         <article class="global" data-name="unionWithPointer">
            <h2>unionWithPointer</h2>
            <hr />
            
            <p>unionWithPointer is true for a Go type that represents a C union (or class)
that may contain a pointer. This is used for cgo pointer checking.</p>
            
            <pre><code>unionWithPointer</code></pre>
         </article>
         
         <article class="global" data-name="anonymousStructTag">
            <h2>anonymousStructTag</h2>
            <hr />
            
            <p>anonymousStructTag provides a consistent tag for an anonymous struct.
The same dwarf.StructType pointer will always get the same tag.</p>
            
            <pre><code>anonymousStructTag</code></pre>
         </article>
         
         <article class="global" data-name="dwarfToName">
            <h2>dwarfToName</h2>
            <hr />
            
            <p>Map from dwarf text names to aliases we use in package "C".</p>
            
            <pre><code>dwarfToName</code></pre>
         </article>
         
         <article class="global" data-name="signedDelta">
            <h2>signedDelta</h2>
            <hr />
            
            <pre><code>signedDelta</code></pre>
         </article>
         
         <article class="global" data-name="jniTypes">
            <h2>jniTypes</h2>
            <hr />
            
            <p>jniTypes maps from JNI types that we want to be uintptrs, to the underlying type to which
they are mapped. The base "jobject" maps to the empty string.</p>
            
            <pre><code>jniTypes</code></pre>
         </article>
         
         <article class="global" data-name="nameKinds">
            <h2>nameKinds</h2>
            <hr />
            
            <pre><code>nameKinds</code></pre>
         </article>
         
         <article class="global" data-name="ptrSizeMap">
            <h2>ptrSizeMap</h2>
            <hr />
            
            <pre><code>ptrSizeMap</code></pre>
         </article>
         
         <article class="global" data-name="intSizeMap">
            <h2>intSizeMap</h2>
            <hr />
            
            <pre><code>intSizeMap</code></pre>
         </article>
         
         <article class="global" data-name="cPrefix">
            <h2>cPrefix</h2>
            <hr />
            
            <pre><code>cPrefix string</code></pre>
         </article>
         
         <article class="global" data-name="fset">
            <h2>fset</h2>
            <hr />
            
            <pre><code>fset</code></pre>
         </article>
         
         <article class="global" data-name="dynobj">
            <h2>dynobj</h2>
            <hr />
            
            <pre><code>dynobj</code></pre>
         </article>
         
         <article class="global" data-name="dynout">
            <h2>dynout</h2>
            <hr />
            
            <pre><code>dynout</code></pre>
         </article>
         
         <article class="global" data-name="dynpackage">
            <h2>dynpackage</h2>
            <hr />
            
            <pre><code>dynpackage</code></pre>
         </article>
         
         <article class="global" data-name="dynlinker">
            <h2>dynlinker</h2>
            <hr />
            
            <pre><code>dynlinker</code></pre>
         </article>
         
         <article class="global" data-name="godefs">
            <h2>godefs</h2>
            <hr />
            
            <p>This flag is for bootstrapping a new Go implementation,
to generate Go types that match the data layout and
constant values used in the host's C libraries and system calls.</p>
            
            <pre><code>godefs</code></pre>
         </article>
         
         <article class="global" data-name="srcDir">
            <h2>srcDir</h2>
            <hr />
            
            <pre><code>srcDir</code></pre>
         </article>
         
         <article class="global" data-name="objDir">
            <h2>objDir</h2>
            <hr />
            
            <pre><code>objDir</code></pre>
         </article>
         
         <article class="global" data-name="importPath">
            <h2>importPath</h2>
            <hr />
            
            <pre><code>importPath</code></pre>
         </article>
         
         <article class="global" data-name="exportHeader">
            <h2>exportHeader</h2>
            <hr />
            
            <pre><code>exportHeader</code></pre>
         </article>
         
         <article class="global" data-name="ldflags">
            <h2>ldflags</h2>
            <hr />
            
            <pre><code>ldflags</code></pre>
         </article>
         
         <article class="global" data-name="gccgo">
            <h2>gccgo</h2>
            <hr />
            
            <pre><code>gccgo</code></pre>
         </article>
         
         <article class="global" data-name="gccgoprefix">
            <h2>gccgoprefix</h2>
            <hr />
            
            <pre><code>gccgoprefix</code></pre>
         </article>
         
         <article class="global" data-name="gccgopkgpath">
            <h2>gccgopkgpath</h2>
            <hr />
            
            <pre><code>gccgopkgpath</code></pre>
         </article>
         
         <article class="global" data-name="gccgoMangler">
            <h2>gccgoMangler</h2>
            <hr />
            
            <pre><code>gccgoMangler func</code></pre>
         </article>
         
         <article class="global" data-name="gccgoDefineCgoIncomplete">
            <h2>gccgoDefineCgoIncomplete</h2>
            <hr />
            
            <pre><code>gccgoDefineCgoIncomplete</code></pre>
         </article>
         
         <article class="global" data-name="importRuntimeCgo">
            <h2>importRuntimeCgo</h2>
            <hr />
            
            <pre><code>importRuntimeCgo</code></pre>
         </article>
         
         <article class="global" data-name="importSyscall">
            <h2>importSyscall</h2>
            <hr />
            
            <pre><code>importSyscall</code></pre>
         </article>
         
         <article class="global" data-name="trimpath">
            <h2>trimpath</h2>
            <hr />
            
            <pre><code>trimpath</code></pre>
         </article>
         
         <article class="global" data-name="goarch">
            <h2>goarch</h2>
            <hr />
            
            <pre><code>goarch string</code></pre>
         </article>
         
         <article class="global" data-name="goos">
            <h2>goos</h2>
            <hr />
            
            <pre><code>goos string</code></pre>
         </article>
         
         <article class="global" data-name="gomips">
            <h2>gomips</h2>
            <hr />
            
            <pre><code>gomips string</code></pre>
         </article>
         
         <article class="global" data-name="gomips64">
            <h2>gomips64</h2>
            <hr />
            
            <pre><code>gomips64 string</code></pre>
         </article>
         
         <article class="global" data-name="gccBaseCmd">
            <h2>gccBaseCmd</h2>
            <hr />
            
            <pre><code>gccBaseCmd []string</code></pre>
         </article>
         
         <article class="global" data-name="nerrors">
            <h2>nerrors</h2>
            <hr />
            
            <pre><code>nerrors int</code></pre>
         </article>
         
         <article class="global" data-name="gofmtBuf">
            <h2>gofmtBuf</h2>
            <hr />
            
            <pre><code>gofmtBuf strings.Builder</code></pre>
         </article>
         
         <article class="global" data-name="conf">
            <h2>conf</h2>
            <hr />
            
            <pre><code>conf</code></pre>
         </article>
         
         <article class="global" data-name="noSourceConf">
            <h2>noSourceConf</h2>
            <hr />
            
            <pre><code>noSourceConf</code></pre>
         </article>
         
         <article class="global" data-name="isBuiltin">
            <h2>isBuiltin</h2>
            <hr />
            
            <pre><code>isBuiltin</code></pre>
         </article>
         
         <article class="global" data-name="goTypes">
            <h2>goTypes</h2>
            <hr />
            
            <p>Map predeclared Go types to Type.</p>
            
            <pre><code>goTypes</code></pre>
         </article>
         
         <article class="global" data-name="gccProlog">
            <h2>gccProlog</h2>
            <hr />
            
            <pre><code>gccProlog</code></pre>
         </article>
         
         <article class="global" data-name="noTsanProlog">
            <h2>noTsanProlog</h2>
            <hr />
            
            <p>Prologue defining TSAN functions in C.</p>
            
            <pre><code>noTsanProlog</code></pre>
         </article>
         
         <article class="global" data-name="yesTsanProlog">
            <h2>yesTsanProlog</h2>
            <hr />
            
            <p>This must match the TSAN code in runtime/cgo/libcgo.h.
This is used when the code is built with the C/C++ Thread SANitizer,
which is not the same as the Go race detector.
__tsan_acquire tells TSAN that we are acquiring a lock on a variable,
in this case _cgo_sync. __tsan_release releases the lock.
(There is no actual lock, we are just telling TSAN that there is.)

When we call from Go to C we call _cgo_tsan_acquire.
When the C function returns we call _cgo_tsan_release.
Similarly, when C calls back into Go we call _cgo_tsan_release
and then call _cgo_tsan_acquire when we return to C.
These calls tell TSAN that there is a serialization point at the C call.

This is necessary because TSAN, which is a C/C++ tool, can not see
the synchronization in the Go code. Without these calls, when
multiple goroutines call into C code, TSAN does not understand
that the calls are properly synchronized on the Go side.

To be clear, if the calls are not properly synchronized on the Go side,
we will be hiding races. But when using TSAN on mixed Go C/C++ code
it is more important to avoid false positives, which reduce confidence
in the tool, than to avoid false negatives.</p>
            
            <pre><code>yesTsanProlog</code></pre>
         </article>
         
         <article class="global" data-name="tsanProlog">
            <h2>tsanProlog</h2>
            <hr />
            
            <p>Set to yesTsanProlog if we see -fsanitize=thread in the flags for gcc.</p>
            
            <pre><code>tsanProlog</code></pre>
         </article>
         
         <article class="global" data-name="noMsanProlog">
            <h2>noMsanProlog</h2>
            <hr />
            
            <p>noMsanProlog is a prologue defining an MSAN function in C.
This is used when not compiling with -fsanitize=memory.</p>
            
            <pre><code>noMsanProlog</code></pre>
         </article>
         
         <article class="global" data-name="yesMsanProlog">
            <h2>yesMsanProlog</h2>
            <hr />
            
            <p>yesMsanProlog is a prologue defining an MSAN function in C.
This is used when compiling with -fsanitize=memory.
See the comment above where _cgo_msan_write is called.</p>
            
            <pre><code>yesMsanProlog</code></pre>
         </article>
         
         <article class="global" data-name="msanProlog">
            <h2>msanProlog</h2>
            <hr />
            
            <p>msanProlog is set to yesMsanProlog if we see -fsanitize=memory in the flags
for the C compiler.</p>
            
            <pre><code>msanProlog</code></pre>
         </article>
         
         <article class="global" data-name="builtinProlog">
            <h2>builtinProlog</h2>
            <hr />
            
            <pre><code>builtinProlog</code></pre>
         </article>
         
         <article class="global" data-name="goProlog">
            <h2>goProlog</h2>
            <hr />
            
            <pre><code>goProlog</code></pre>
         </article>
         
         <article class="global" data-name="gccgoGoProlog">
            <h2>gccgoGoProlog</h2>
            <hr />
            
            <pre><code>gccgoGoProlog</code></pre>
         </article>
         
         <article class="global" data-name="goStringDef">
            <h2>goStringDef</h2>
            <hr />
            
            <pre><code>goStringDef</code></pre>
         </article>
         
         <article class="global" data-name="goStringNDef">
            <h2>goStringNDef</h2>
            <hr />
            
            <pre><code>goStringNDef</code></pre>
         </article>
         
         <article class="global" data-name="goBytesDef">
            <h2>goBytesDef</h2>
            <hr />
            
            <pre><code>goBytesDef</code></pre>
         </article>
         
         <article class="global" data-name="cStringDef">
            <h2>cStringDef</h2>
            <hr />
            
            <pre><code>cStringDef</code></pre>
         </article>
         
         <article class="global" data-name="cBytesDef">
            <h2>cBytesDef</h2>
            <hr />
            
            <pre><code>cBytesDef</code></pre>
         </article>
         
         <article class="global" data-name="cMallocDef">
            <h2>cMallocDef</h2>
            <hr />
            
            <pre><code>cMallocDef</code></pre>
         </article>
         
         <article class="global" data-name="builtinDefs">
            <h2>builtinDefs</h2>
            <hr />
            
            <pre><code>builtinDefs</code></pre>
         </article>
         
         <article class="global" data-name="cMallocDefGo">
            <h2>cMallocDefGo</h2>
            <hr />
            
            <pre><code>cMallocDefGo</code></pre>
         </article>
         
         <article class="global" data-name="cMallocDefC">
            <h2>cMallocDefC</h2>
            <hr />
            
            <p>cMallocDefC defines the C version of C.malloc for the gc compiler.
It is defined here because C.CString and friends need a definition.
We define it by hand, rather than simply inventing a reference to
C.malloc, because <stdlib.h> may not have been included.
This is approximately what writeOutputFunc would generate, but
skips the cgo_topofstack code (which is only needed if the C code
calls back into Go). This also avoids returning nil for an
allocation of 0 bytes.</p>
            
            <pre><code>cMallocDefC</code></pre>
         </article>
         
         <article class="global" data-name="cPrologGccgo">
            <h2>cPrologGccgo</h2>
            <hr />
            
            <pre><code>cPrologGccgo</code></pre>
         </article>
         
         <article class="global" data-name="builtinExportProlog">
            <h2>builtinExportProlog</h2>
            <hr />
            
            <p>builtinExportProlog is a shorter version of builtinProlog,
to be put into the _cgo_export.h file.
For historical reasons we can't use builtinProlog in _cgo_export.h,
because _cgo_export.h defines GoString as a struct while builtinProlog
defines it as a function. We don't change this to avoid unnecessarily
breaking existing code.
The test of GO_CGO_GOSTRING_TYPEDEF avoids a duplicate definition
error if a Go file with a cgo comment #include's the export header
generated by a different package.</p>
            
            <pre><code>builtinExportProlog</code></pre>
         </article>
         
         <article class="global" data-name="gccExportHeaderProlog">
            <h2>gccExportHeaderProlog</h2>
            <hr />
            
            <p>gccExportHeaderProlog is written to the exported header, after the
import "C" comment preamble but before the generated declarations
of exported functions. This permits the generated declarations to
use the type names that appear in goTypes, above.

The test of GO_CGO_GOSTRING_TYPEDEF avoids a duplicate definition
error if a Go file with a cgo comment #include's the export header
generated by a different package. Unfortunately GoString means two
different things: in this prolog it means a C name for the Go type,
while in the prolog written into the start of the C code generated
from a cgo-using Go file it means the C.GoString function. There is
no way to resolve this conflict, but it also doesn't make much
difference, as Go code never wants to refer to the latter meaning.</p>
            
            <pre><code>gccExportHeaderProlog</code></pre>
         </article>
         
         <article class="global" data-name="gccExportHeaderEpilog">
            <h2>gccExportHeaderEpilog</h2>
            <hr />
            
            <p>gccExportHeaderEpilog goes at the end of the generated header file.</p>
            
            <pre><code>gccExportHeaderEpilog</code></pre>
         </article>
         
         <article class="global" data-name="gccgoExportFileProlog">
            <h2>gccgoExportFileProlog</h2>
            <hr />
            
            <p>gccgoExportFileProlog is written to the _cgo_export.c file when
using gccgo.
We use weak declarations, and test the addresses, so that this code
works with older versions of gccgo.</p>
            
            <pre><code>gccgoExportFileProlog</code></pre>
         </article>
         
         <article class="global" data-name="defaultPkgConfig">
            <h2>defaultPkgConfig</h2>
            <hr />
            
            <pre><code>defaultPkgConfig</code></pre>
         </article>
         
         <article class="global" data-name="ctxProg">
            <h2>ctxProg</h2>
            <hr />
            
            <pre><code>ctxProg astContext</code></pre>
         </article>
         
         <article class="global" data-name="ctxEmbedType">
            <h2>ctxEmbedType</h2>
            <hr />
            
            <pre><code>ctxEmbedType</code></pre>
         </article>
         
         <article class="global" data-name="ctxType">
            <h2>ctxType</h2>
            <hr />
            
            <pre><code>ctxType</code></pre>
         </article>
         
         <article class="global" data-name="ctxStmt">
            <h2>ctxStmt</h2>
            <hr />
            
            <pre><code>ctxStmt</code></pre>
         </article>
         
         <article class="global" data-name="ctxExpr">
            <h2>ctxExpr</h2>
            <hr />
            
            <pre><code>ctxExpr</code></pre>
         </article>
         
         <article class="global" data-name="ctxField">
            <h2>ctxField</h2>
            <hr />
            
            <pre><code>ctxField</code></pre>
         </article>
         
         <article class="global" data-name="ctxParam">
            <h2>ctxParam</h2>
            <hr />
            
            <pre><code>ctxParam</code></pre>
         </article>
         
         <article class="global" data-name="ctxAssign2">
            <h2>ctxAssign2</h2>
            <hr />
            
            <pre><code>ctxAssign2</code></pre>
         </article>
         
         <article class="global" data-name="ctxSwitch">
            <h2>ctxSwitch</h2>
            <hr />
            
            <pre><code>ctxSwitch</code></pre>
         </article>
         
         <article class="global" data-name="ctxTypeSwitch">
            <h2>ctxTypeSwitch</h2>
            <hr />
            
            <pre><code>ctxTypeSwitch</code></pre>
         </article>
         
         <article class="global" data-name="ctxFile">
            <h2>ctxFile</h2>
            <hr />
            
            <pre><code>ctxFile</code></pre>
         </article>
         
         <article class="global" data-name="ctxDecl">
            <h2>ctxDecl</h2>
            <hr />
            
            <pre><code>ctxDecl</code></pre>
         </article>
         
         <article class="global" data-name="ctxSpec">
            <h2>ctxSpec</h2>
            <hr />
            
            <pre><code>ctxSpec</code></pre>
         </article>
         
         <article class="global" data-name="ctxDefer">
            <h2>ctxDefer</h2>
            <hr />
            
            <pre><code>ctxDefer</code></pre>
         </article>
         
         <article class="global" data-name="ctxCall">
            <h2>ctxCall</h2>
            <hr />
            
            <pre><code>ctxCall</code></pre>
         </article>
         
         <article class="global" data-name="ctxCall2">
            <h2>ctxCall2</h2>
            <hr />
            
            <pre><code>ctxCall2</code></pre>
         </article>
         
         <article class="global" data-name="ctxSelector">
            <h2>ctxSelector</h2>
            <hr />
            
            <pre><code>ctxSelector</code></pre>
         </article>
          
         <article class="struct" data-name="typeConv">
            <h2>type typeConv struct</h2>
            <hr />
            
            <p>A typeConv is a translator from dwarf types to Go types
with equivalent memory layout.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">m *ast.MapType
ptrs *ast.MapType
ptrKeys []dwarf.Type
getTypeIDs *ast.MapType
incompleteStructs *ast.MapType
bool ast.Expr
byte ast.Expr
int8 ast.Expr
int16 ast.Expr
int32 ast.Expr
int64 ast.Expr
uint8 ast.Expr
uint16 ast.Expr
uint32 ast.Expr
uint64 ast.Expr
uintptr ast.Expr
float32 ast.Expr
float64 ast.Expr
complex64 ast.Expr
complex128 ast.Expr
void ast.Expr
string ast.Expr
goVoid ast.Expr
goVoidPtr ast.Expr
ptrSize int64
intSize int64</code></pre>
         </article>
         
         <article class="struct" data-name="Package">
            <h2>type Package struct</h2>
            <hr />
            
            <p>A Package collects information about the package we're going to write.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">PackageName string
PackagePath string
PtrSize int64
IntSize int64
GccOptions []string
GccIsClang bool
LdFlags []string
Written *ast.MapType
Name *ast.MapType
ExpFunc []*ExpFunc
Decl []ast.Decl
GoFiles []string
GccFiles []string
Preamble string
typedefs *ast.MapType
typedefList []typedefInfo
noCallbacks *ast.MapType
noEscapes *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="typedefInfo">
            <h2>type typedefInfo struct</h2>
            <hr />
            
            <p>A typedefInfo is an element on Package.typedefList: a typedef name
and the position where it was required.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">typedef string
pos token.Pos</code></pre>
         </article>
         
         <article class="struct" data-name="File">
            <h2>type File struct</h2>
            <hr />
            
            <p>A File collects information about a single Go input file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">AST *ast.File
Comments []*ast.CommentGroup
Package string
Preamble string
Ref []*Ref
Calls []*Call
ExpFunc []*ExpFunc
Name *ast.MapType
NamePos *ast.MapType
NoCallbacks *ast.MapType
NoEscapes *ast.MapType
Edit *edit.Buffer</code></pre>
         </article>
         
         <article class="struct" data-name="Call">
            <h2>type Call struct</h2>
            <hr />
            
            <p>A Call refers to a call of a C.xxx function in the AST.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Call *ast.CallExpr
Deferred bool
Done bool</code></pre>
         </article>
         
         <article class="struct" data-name="Ref">
            <h2>type Ref struct</h2>
            <hr />
            
            <p>A Ref refers to an expression of the form C.xxx in the AST.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name *Name
Expr *ast.Expr
Context astContext
Done bool</code></pre>
         </article>
         
         <article class="struct" data-name="Name">
            <h2>type Name struct</h2>
            <hr />
            
            <p>A Name collects information about C.xxx.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Go string
Mangle string
C string
Define string
Kind string
Type *Type
FuncType *FuncType
AddError bool
Const string</code></pre>
         </article>
         
         <article class="struct" data-name="ExpFunc">
            <h2>type ExpFunc struct</h2>
            <hr />
            
            <p>An ExpFunc is an exported function, callable from C.
Such functions are identified in the Go input file
by doc comments containing the line //export ExpName</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Func *ast.FuncDecl
ExpName string
Doc string</code></pre>
         </article>
         
         <article class="struct" data-name="TypeRepr">
            <h2>type TypeRepr struct</h2>
            <hr />
            
            <p>A TypeRepr contains the string representation of a type.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Repr string
FormatArgs []*ast.InterfaceType</code></pre>
         </article>
         
         <article class="struct" data-name="Type">
            <h2>type Type struct</h2>
            <hr />
            
            <p>A Type collects information about a type in both the C and Go worlds.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Size int64
Align int64
C *TypeRepr
Go ast.Expr
EnumValues *ast.MapType
Typedef string
BadPointer bool</code></pre>
         </article>
         
         <article class="struct" data-name="FuncType">
            <h2>type FuncType struct</h2>
            <hr />
            
            <p>A FuncType collects information about a function type in both the C and Go worlds.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Params []*Type
Result *Type
Go *ast.FuncType</code></pre>
         </article>
          
         <article class="function" data-name="walkUnexpected">
            <h2>walkUnexpected</h2>
            <hr />
            
            <pre><code>func walkUnexpected(x *ast.InterfaceType, context astContext, visit func)</code></pre>
         </article>
         
         <article class="function" data-name="funcTypeTypeParams">
            <h2>funcTypeTypeParams</h2>
            <hr />
            
            <pre><code>func funcTypeTypeParams(n *ast.FuncType) *ast.FieldList</code></pre>
         </article>
         
         <article class="function" data-name="typeSpecTypeParams">
            <h2>typeSpecTypeParams</h2>
            <hr />
            
            <pre><code>func typeSpecTypeParams(n *ast.TypeSpec) *ast.FieldList</code></pre>
         </article>
         
         <article class="function" data-name="cname">
            <h2>cname</h2>
            <hr />
            
            <p>cname returns the C name to use for C.s.
The expansions are listed in nameToC and also
struct_foo becomes "struct foo", and similarly for
union and enum.</p>
            
            <pre><code>func cname(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="ProcessCgoDirectives">
            <h2>ProcessCgoDirectives</h2>
            <hr />
            
            <p>ProcessCgoDirectives processes the import C preamble:
 1. discards all #cgo CFLAGS, LDFLAGS, nocallback and noescape directives,
    so they don't make their way into _cgo_export.h.
 2. parse the nocallback and noescape directives.</p>
            
            <pre><code>func ProcessCgoDirectives()</code></pre>
         </article>
         
         <article class="function" data-name="addToFlag">
            <h2>addToFlag</h2>
            <hr />
            
            <p>addToFlag appends args to flag.</p>
            
            <pre><code>func addToFlag(flag string, args []string)</code></pre>
         </article>
         
         <article class="function" data-name="splitQuoted">
            <h2>splitQuoted</h2>
            <hr />
            
            <p>splitQuoted splits the string s around each instance of one or more consecutive
white space characters while taking into account quotes and escaping, and
returns an array of substrings of s or an empty list if s contains only white space.
Single quotes and double quotes are recognized to prevent splitting within the
quoted region, and are removed from the resulting substrings. If a quote in s
isn't closed err will be set and r will have the unclosed argument as the
last element. The backslash is used for escaping.

For example, the following string:

	`a b:"c d" 'e''f'  "g\""`

Would be parsed as:

	[]string{"a", "b:c d", "ef", `g"`}</p>
            
            <pre><code>func splitQuoted(s string) (r []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Translate">
            <h2>Translate</h2>
            <hr />
            
            <p>Translate rewrites f.AST, the original Go input, to remove
references to the imported package C, replacing them with
references to the equivalent Go types, functions, and variables.</p>
            
            <pre><code>func Translate(f *File)</code></pre>
         </article>
         
         <article class="function" data-name="loadDefines">
            <h2>loadDefines</h2>
            <hr />
            
            <p>loadDefines coerces gcc into spitting out the #defines in use
in the file f and saves relevant renamings in f.Name[name].Define.
Returns true if env:CC is Clang</p>
            
            <pre><code>func loadDefines(gccOptions []string) bool</code></pre>
         </article>
         
         <article class="function" data-name="guessKinds">
            <h2>guessKinds</h2>
            <hr />
            
            <p>guessKinds tricks gcc into revealing the kind of each
name xxx for the references C.xxx in the Go input.
The kind is either a constant, type, or variable.</p>
            
            <pre><code>func guessKinds(f *File) []*Name</code></pre>
         </article>
         
         <article class="function" data-name="loadDWARF">
            <h2>loadDWARF</h2>
            <hr />
            
            <p>loadDWARF parses the DWARF debug information generated
by gcc to learn the details of the constants, variables, and types
being referred to as C.xxx.</p>
            
            <pre><code>func loadDWARF(f *File, conv *typeConv, names []*Name)</code></pre>
         </article>
         
         <article class="function" data-name="recordTypedefs">
            <h2>recordTypedefs</h2>
            <hr />
            
            <p>recordTypedefs remembers in p.typedefs all the typedefs used in dtypes and its children.</p>
            
            <pre><code>func recordTypedefs(dtype dwarf.Type, pos token.Pos)</code></pre>
         </article>
         
         <article class="function" data-name="recordTypedefs1">
            <h2>recordTypedefs1</h2>
            <hr />
            
            <pre><code>func recordTypedefs1(dtype dwarf.Type, pos token.Pos, visited *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="prepareNames">
            <h2>prepareNames</h2>
            <hr />
            
            <p>prepareNames finalizes the Kind field of not-type names and sets
the mangled name of all names.</p>
            
            <pre><code>func prepareNames(f *File)</code></pre>
         </article>
         
         <article class="function" data-name="mangleName">
            <h2>mangleName</h2>
            <hr />
            
            <p>mangleName does name mangling to translate names
from the original Go source files to the names
used in the final Go files generated by cgo.</p>
            
            <pre><code>func mangleName(n *Name)</code></pre>
         </article>
         
         <article class="function" data-name="isMangledName">
            <h2>isMangledName</h2>
            <hr />
            
            <pre><code>func isMangledName(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="rewriteCalls">
            <h2>rewriteCalls</h2>
            <hr />
            
            <p>rewriteCalls rewrites all calls that pass pointers to check that
they follow the rules for passing pointers between Go and C.
This reports whether the package needs to import unsafe as _cgo_unsafe.</p>
            
            <pre><code>func rewriteCalls(f *File) bool</code></pre>
         </article>
         
         <article class="function" data-name="rewriteCall">
            <h2>rewriteCall</h2>
            <hr />
            
            <p>rewriteCall rewrites one call to add pointer checks.
If any pointer checks are required, we rewrite the call into a
function literal that calls _cgoCheckPointer for each pointer
argument and then calls the original function.
This returns the rewritten call and whether the package needs to
import unsafe as _cgo_unsafe.
If it returns the empty string, the call did not need to be rewritten.</p>
            
            <pre><code>func rewriteCall(f *File, call *Call) (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="needsPointerCheck">
            <h2>needsPointerCheck</h2>
            <hr />
            
            <p>needsPointerCheck reports whether the type t needs a pointer check.
This is true if t is a pointer and if the value to which it points
might contain a pointer.</p>
            
            <pre><code>func needsPointerCheck(f *File, t ast.Expr, arg ast.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="hasPointer">
            <h2>hasPointer</h2>
            <hr />
            
            <p>hasPointer is used by needsPointerCheck. If top is true it returns
whether t is or contains a pointer that might point to a pointer.
If top is false it reports whether t is or contains a pointer.
f may be nil.</p>
            
            <pre><code>func hasPointer(f *File, t ast.Expr, top bool) bool</code></pre>
         </article>
         
         <article class="function" data-name="mangle">
            <h2>mangle</h2>
            <hr />
            
            <p>mangle replaces references to C names in arg with the mangled names,
rewriting calls when it finds them.
It removes the corresponding references in f.Ref and f.Calls, so that we
don't try to do the replacement again in rewriteRef or rewriteCall.
If addPosition is true, add position info to the idents of C names in arg.</p>
            
            <pre><code>func mangle(f *File, arg *ast.Expr, addPosition bool) (ast.Expr, bool)</code></pre>
         </article>
         
         <article class="function" data-name="checkIndex">
            <h2>checkIndex</h2>
            <hr />
            
            <p>checkIndex checks whether arg has the form &a[i], possibly inside
type conversions. If so, then in the general case it writes

	_cgoIndexNN := a
	_cgoNN := &cgoIndexNN[i] // with type conversions, if any

to sb, and writes

	_cgoCheckPointer(_cgoNN, _cgoIndexNN)

to sbCheck, and returns true. If a is a simple variable or field reference,
it writes

	_cgoIndexNN := &a

and dereferences the uses of _cgoIndexNN. Taking the address avoids
making a copy of an array.

This tells _cgoCheckPointer to check the complete contents of the
slice or array being indexed, but no other part of the memory allocation.</p>
            
            <pre><code>func checkIndex(sb *bytes.Buffer, sbCheck *bytes.Buffer, arg ast.Expr, i int) bool</code></pre>
         </article>
         
         <article class="function" data-name="checkAddr">
            <h2>checkAddr</h2>
            <hr />
            
            <p>checkAddr checks whether arg has the form &x, possibly inside type
conversions. If so, it writes

	_cgoBaseNN := &x
	_cgoNN := _cgoBaseNN // with type conversions, if any

to sb, and writes

	_cgoCheckPointer(_cgoBaseNN, true)

to sbCheck, and returns true. This tells _cgoCheckPointer to check
just the contents of the pointer being passed, not any other part
of the memory allocation. This is run after checkIndex, which looks
for the special case of &a[i], which requires different checks.</p>
            
            <pre><code>func checkAddr(sb *bytes.Buffer, sbCheck *bytes.Buffer, arg ast.Expr, i int) bool</code></pre>
         </article>
         
         <article class="function" data-name="checkSlice">
            <h2>checkSlice</h2>
            <hr />
            
            <p>checkSlice checks whether arg has the form x[i:j], possibly inside
type conversions. If so, it writes

	_cgoSliceNN := x[i:j]
	_cgoNN := _cgoSliceNN // with type conversions, if any

to sb, and writes

	_cgoCheckPointer(_cgoSliceNN, true)

to sbCheck, and returns true. This tells _cgoCheckPointer to check
just the contents of the slice being passed, not any other part
of the memory allocation.</p>
            
            <pre><code>func checkSlice(sb *bytes.Buffer, sbCheck *bytes.Buffer, arg ast.Expr, i int) bool</code></pre>
         </article>
         
         <article class="function" data-name="checkUnsafeStringData">
            <h2>checkUnsafeStringData</h2>
            <hr />
            
            <p>checkUnsafeStringData checks for a call to unsafe.StringData.
The result of that call can't contain a pointer so there is
no need to call _cgoCheckPointer.</p>
            
            <pre><code>func checkUnsafeStringData(arg ast.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="isType">
            <h2>isType</h2>
            <hr />
            
            <p>isType reports whether the expression is definitely a type.
This is conservative--it returns false for an unknown identifier.</p>
            
            <pre><code>func isType(t ast.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="isUnsafeData">
            <h2>isUnsafeData</h2>
            <hr />
            
            <p>isUnsafeData reports whether the expression is unsafe.StringData
or unsafe.SliceData. We can ignore these when checking for pointers
because they don't change whether or not their argument contains
any Go pointers. If onlyStringData is true we only check for StringData.</p>
            
            <pre><code>func isUnsafeData(x ast.Expr, onlyStringData bool) bool</code></pre>
         </article>
         
         <article class="function" data-name="isVariable">
            <h2>isVariable</h2>
            <hr />
            
            <p>isVariable reports whether x is a variable, possibly with field references.</p>
            
            <pre><code>func isVariable(x ast.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="rewriteUnsafe">
            <h2>rewriteUnsafe</h2>
            <hr />
            
            <p>rewriteUnsafe returns a version of t with references to unsafe.Pointer
rewritten to use _cgo_unsafe.Pointer instead.</p>
            
            <pre><code>func rewriteUnsafe(t ast.Expr) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="rewriteRef">
            <h2>rewriteRef</h2>
            <hr />
            
            <p>rewriteRef rewrites all the C.xxx references in f.AST to refer to the
Go equivalents, now that we have figured out the meaning of all
the xxx. In *godefs mode, rewriteRef replaces the names
with full definitions instead of mangled names.</p>
            
            <pre><code>func rewriteRef(f *File)</code></pre>
         </article>
         
         <article class="function" data-name="rewriteName">
            <h2>rewriteName</h2>
            <hr />
            
            <p>rewriteName returns the expression used to rewrite a reference.
If addPosition is true, add position info in the ident name.</p>
            
            <pre><code>func rewriteName(f *File, r *Ref, addPosition bool) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="gofmtPos">
            <h2>gofmtPos</h2>
            <hr />
            
            <p>gofmtPos returns the gofmt-formatted string for an AST node,
with a comment setting the position before the node.</p>
            
            <pre><code>func gofmtPos(n ast.Expr, pos token.Pos) string</code></pre>
         </article>
         
         <article class="function" data-name="checkGCCBaseCmd">
            <h2>checkGCCBaseCmd</h2>
            <hr />
            
            <p>checkGCCBaseCmd returns the start of the compiler command line.
It uses $CC if set, or else $GCC, or else the compiler recorded
during the initial build as defaultCC.
defaultCC is defined in zdefaultcc.go, written by cmd/dist.

The compiler command line is split into arguments on whitespace. Quotes
are understood, so arguments may contain whitespace.

checkGCCBaseCmd confirms that the compiler exists in PATH, returning
an error if it does not.</p>
            
            <pre><code>func checkGCCBaseCmd() ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="gccMachine">
            <h2>gccMachine</h2>
            <hr />
            
            <p>gccMachine returns the gcc -m flag to use, either "-m32", "-m64" or "-marm".</p>
            
            <pre><code>func gccMachine() []string</code></pre>
         </article>
         
         <article class="function" data-name="gccTmp">
            <h2>gccTmp</h2>
            <hr />
            
            <pre><code>func gccTmp() string</code></pre>
         </article>
         
         <article class="function" data-name="gccCmd">
            <h2>gccCmd</h2>
            <hr />
            
            <p>gccCmd returns the gcc command line to use for compiling
the input.</p>
            
            <pre><code>func gccCmd() []string</code></pre>
         </article>
         
         <article class="function" data-name="gccDebug">
            <h2>gccDebug</h2>
            <hr />
            
            <p>gccDebug runs gcc -gdwarf-2 over the C program stdin and
returns the corresponding DWARF data and, if present, debug data block.</p>
            
            <pre><code>func gccDebug(stdin []byte, nnames int) (d *dwarf.Data, ints []int64, floats []float64, strs []string)</code></pre>
         </article>
         
         <article class="function" data-name="gccDefines">
            <h2>gccDefines</h2>
            <hr />
            
            <p>gccDefines runs gcc -E -dM -xc - over the C program stdin
and returns the corresponding standard output, which is the
#defines that gcc encountered while processing the input
and its included files.</p>
            
            <pre><code>func gccDefines(stdin []byte, gccOptions []string) string</code></pre>
         </article>
         
         <article class="function" data-name="gccErrors">
            <h2>gccErrors</h2>
            <hr />
            
            <p>gccErrors runs gcc over the C program stdin and returns
the errors that gcc prints. That is, this function expects
gcc to fail.</p>
            
            <pre><code>func gccErrors(stdin []byte, extraArgs ...string) string</code></pre>
         </article>
         
         <article class="function" data-name="runGcc">
            <h2>runGcc</h2>
            <hr />
            
            <p>runGcc runs the gcc command line args with stdin on standard input.
If the command exits with a non-zero exit status, runGcc prints
details about what was run and exits.
Otherwise runGcc returns the data written to standard output and standard error.
Note that for some of the uses we expect useful data back
on standard error, but for those uses gcc must still exit 0.</p>
            
            <pre><code>func runGcc(stdin []byte, args []string) (string, string)</code></pre>
         </article>
         
         <article class="function" data-name="Init">
            <h2>Init</h2>
            <hr />
            
            <pre><code>func Init(ptrSize int64, intSize int64)</code></pre>
         </article>
         
         <article class="function" data-name="base">
            <h2>base</h2>
            <hr />
            
            <p>base strips away qualifiers and typedefs to get the underlying type.</p>
            
            <pre><code>func base(dt dwarf.Type) dwarf.Type</code></pre>
         </article>
         
         <article class="function" data-name="unqual">
            <h2>unqual</h2>
            <hr />
            
            <p>unqual strips away qualifiers from a DWARF type.
In general we don't care about top-level qualifiers.</p>
            
            <pre><code>func unqual(dt dwarf.Type) dwarf.Type</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns the current type representation. Format arguments
are assembled within this method so that any changes in mutable
values are taken into account.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Empty">
            <h2>Empty</h2>
            <hr />
            
            <p>Empty reports whether the result of String would be "".</p>
            
            <pre><code>func Empty() bool</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <p>Set modifies the type representation.
If fargs are provided, repr is used as a format for fmt.Sprintf.
Otherwise, repr is used unprocessed as the type representation.</p>
            
            <pre><code>func Set(repr string, fargs ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="FinishType">
            <h2>FinishType</h2>
            <hr />
            
            <p>FinishType completes any outstanding type mapping work.
In particular, it resolves incomplete pointer types.</p>
            
            <pre><code>func FinishType(pos token.Pos)</code></pre>
         </article>
         
         <article class="function" data-name="Type">
            <h2>Type</h2>
            <hr />
            
            <p>Type returns a *Type with the same memory layout as
dtype when used as the type of a variable or a struct field.</p>
            
            <pre><code>func Type(dtype dwarf.Type, pos token.Pos) *Type</code></pre>
         </article>
         
         <article class="function" data-name="loadType">
            <h2>loadType</h2>
            <hr />
            
            <p>loadType recursively loads the requested dtype and its dependency graph.</p>
            
            <pre><code>func loadType(dtype dwarf.Type, pos token.Pos, parent string) *Type</code></pre>
         </article>
         
         <article class="function" data-name="isStructUnionClass">
            <h2>isStructUnionClass</h2>
            <hr />
            
            <p>isStructUnionClass reports whether the type described by the Go syntax x
is a struct, union, or class with a tag.</p>
            
            <pre><code>func isStructUnionClass(x ast.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="FuncArg">
            <h2>FuncArg</h2>
            <hr />
            
            <p>FuncArg returns a Go type with the same memory layout as
dtype when used as the type of a C function argument.</p>
            
            <pre><code>func FuncArg(dtype dwarf.Type, pos token.Pos) *Type</code></pre>
         </article>
         
         <article class="function" data-name="FuncType">
            <h2>FuncType</h2>
            <hr />
            
            <p>FuncType returns the Go type analogous to dtype.
There is no guarantee about matching memory layout.</p>
            
            <pre><code>func FuncType(dtype *dwarf.FuncType, pos token.Pos) *FuncType</code></pre>
         </article>
         
         <article class="function" data-name="Ident">
            <h2>Ident</h2>
            <hr />
            
            <p>Identifier</p>
            
            <pre><code>func Ident(s string) *ast.Ident</code></pre>
         </article>
         
         <article class="function" data-name="Opaque">
            <h2>Opaque</h2>
            <hr />
            
            <p>Opaque type of n bytes.</p>
            
            <pre><code>func Opaque(n int64) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="intExpr">
            <h2>intExpr</h2>
            <hr />
            
            <p>Expr for integer n.</p>
            
            <pre><code>func intExpr(n int64) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="pad">
            <h2>pad</h2>
            <hr />
            
            <p>Add padding of given size to fld.</p>
            
            <pre><code>func pad(fld []*ast.Field, sizes []int64, size int64) ([]*ast.Field, []int64)</code></pre>
         </article>
         
         <article class="function" data-name="Struct">
            <h2>Struct</h2>
            <hr />
            
            <p>Struct conversion: return Go and (gc) C syntax for type.</p>
            
            <pre><code>func Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.StructType, csyntax string, align int64)</code></pre>
         </article>
         
         <article class="function" data-name="dwarfHasPointer">
            <h2>dwarfHasPointer</h2>
            <hr />
            
            <p>dwarfHasPointer reports whether the DWARF type dt contains a pointer.</p>
            
            <pre><code>func dwarfHasPointer(dt dwarf.Type, pos token.Pos) bool</code></pre>
         </article>
         
         <article class="function" data-name="upper">
            <h2>upper</h2>
            <hr />
            
            <pre><code>func upper(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="godefsFields">
            <h2>godefsFields</h2>
            <hr />
            
            <p>godefsFields rewrites field names for use in Go or C definitions.
It strips leading common prefixes (like tv_ in tv_sec, tv_usec)
converts names to upper case, and rewrites _ into Pad_godefs_n,
so that all fields are exported.</p>
            
            <pre><code>func godefsFields(fld []*ast.Field)</code></pre>
         </article>
         
         <article class="function" data-name="fieldPrefix">
            <h2>fieldPrefix</h2>
            <hr />
            
            <p>fieldPrefix returns the prefix that should be removed from all the
field names when generating the C or Go code. For generated
C, we leave the names as is (tv_sec, tv_usec), since that's what
people are used to seeing in C.  For generated Go code, such as
package syscall's data structures, we drop a common prefix
(so sec, usec, which will get turned into Sec, Usec for exporting).</p>
            
            <pre><code>func fieldPrefix(fld []*ast.Field) string</code></pre>
         </article>
         
         <article class="function" data-name="anonymousStructTypedef">
            <h2>anonymousStructTypedef</h2>
            <hr />
            
            <p>anonymousStructTypedef reports whether dt is a C typedef for an anonymous
struct.</p>
            
            <pre><code>func anonymousStructTypedef(dt *dwarf.TypedefType) bool</code></pre>
         </article>
         
         <article class="function" data-name="badPointerTypedef">
            <h2>badPointerTypedef</h2>
            <hr />
            
            <p>badPointerTypedef reports whether dt is a C typedef that should not be
considered a pointer in Go. A typedef is bad if C code sometimes stores
non-pointers in this type.
TODO: Currently our best solution is to find these manually and list them as
they come up. A better solution is desired.
Note: DEPRECATED. There is now a better solution. Search for incomplete in this file.</p>
            
            <pre><code>func badPointerTypedef(dt *dwarf.TypedefType) bool</code></pre>
         </article>
         
         <article class="function" data-name="badVoidPointerTypedef">
            <h2>badVoidPointerTypedef</h2>
            <hr />
            
            <p>badVoidPointerTypedef is like badPointerTypeDef, but for "void *" typedefs that should be _cgopackage.Incomplete.</p>
            
            <pre><code>func badVoidPointerTypedef(dt *dwarf.TypedefType) bool</code></pre>
         </article>
         
         <article class="function" data-name="badStructPointerTypedef">
            <h2>badStructPointerTypedef</h2>
            <hr />
            
            <p>badStructPointerTypedef is like badVoidPointerTypedef but for structs.</p>
            
            <pre><code>func badStructPointerTypedef(name string, dt *dwarf.StructType) bool</code></pre>
         </article>
         
         <article class="function" data-name="baseBadPointerTypedef">
            <h2>baseBadPointerTypedef</h2>
            <hr />
            
            <p>baseBadPointerTypedef reports whether the base of a chain of typedefs is a bad typedef
as badPointerTypedef reports.</p>
            
            <pre><code>func baseBadPointerTypedef(dt *dwarf.TypedefType) bool</code></pre>
         </article>
         
         <article class="function" data-name="badCFType">
            <h2>badCFType</h2>
            <hr />
            
            <pre><code>func badCFType(dt *dwarf.TypedefType) bool</code></pre>
         </article>
         
         <article class="function" data-name="badJNI">
            <h2>badJNI</h2>
            <hr />
            
            <pre><code>func badJNI(dt *dwarf.TypedefType) bool</code></pre>
         </article>
         
         <article class="function" data-name="badEGLType">
            <h2>badEGLType</h2>
            <hr />
            
            <pre><code>func badEGLType(dt *dwarf.TypedefType) bool</code></pre>
         </article>
         
         <article class="function" data-name="offset">
            <h2>offset</h2>
            <hr />
            
            <pre><code>func offset(p token.Pos) int</code></pre>
         </article>
         
         <article class="function" data-name="nameKeys">
            <h2>nameKeys</h2>
            <hr />
            
            <pre><code>func nameKeys(m *ast.MapType) []string</code></pre>
         </article>
         
         <article class="function" data-name="Pos">
            <h2>Pos</h2>
            <hr />
            
            <pre><code>func Pos() token.Pos</code></pre>
         </article>
         
         <article class="function" data-name="IsVar">
            <h2>IsVar</h2>
            <hr />
            
            <p>IsVar reports whether Kind is either "var" or "fpvar"</p>
            
            <pre><code>func IsVar() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsConst">
            <h2>IsConst</h2>
            <hr />
            
            <p>IsConst reports whether Kind is either "iconst", "fconst" or "sconst"</p>
            
            <pre><code>func IsConst() bool</code></pre>
         </article>
         
         <article class="function" data-name="fuzzyMatch">
            <h2>fuzzyMatch</h2>
            <hr />
            
            <pre><code>func fuzzyMatch(t2 *Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="fuzzyMatch">
            <h2>fuzzyMatch</h2>
            <hr />
            
            <pre><code>func fuzzyMatch(t2 *FuncType) bool</code></pre>
         </article>
         
         <article class="function" data-name="usage">
            <h2>usage</h2>
            <hr />
            
            <pre><code>func usage()</code></pre>
         </article>
         
         <article class="function" data-name="main">
            <h2>main</h2>
            <hr />
            
            <pre><code>func main()</code></pre>
         </article>
         
         <article class="function" data-name="newPackage">
            <h2>newPackage</h2>
            <hr />
            
            <p>newPackage returns a new Package that will invoke
gcc with the additional arguments specified in args.</p>
            
            <pre><code>func newPackage(args []string) *Package</code></pre>
         </article>
         
         <article class="function" data-name="Record">
            <h2>Record</h2>
            <hr />
            
            <p>Record what needs to be recorded about f.</p>
            
            <pre><code>func Record(f *File)</code></pre>
         </article>
         
         <article class="function" data-name="incompleteTypedef">
            <h2>incompleteTypedef</h2>
            <hr />
            
            <p>incompleteTypedef reports whether t appears to be an incomplete
typedef definition.</p>
            
            <pre><code>func incompleteTypedef(t *Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="run">
            <h2>run</h2>
            <hr />
            
            <p>run runs the command argv, feeding in stdin on standard input.
It returns the output to standard output and standard error.
ok indicates whether the command exited successfully.</p>
            
            <pre><code>func run(stdin []byte, argv []string) (stdout []byte, stderr []byte, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="lineno">
            <h2>lineno</h2>
            <hr />
            
            <pre><code>func lineno(pos token.Pos) string</code></pre>
         </article>
         
         <article class="function" data-name="fatalf">
            <h2>fatalf</h2>
            <hr />
            
            <p>Die with an error message.</p>
            
            <pre><code>func fatalf(msg string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="error_">
            <h2>error_</h2>
            <hr />
            
            <pre><code>func error_(pos token.Pos, msg string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="creat">
            <h2>creat</h2>
            <hr />
            
            <pre><code>func creat(name string) *os.File</code></pre>
         </article>
         
         <article class="function" data-name="godefs">
            <h2>godefs</h2>
            <hr />
            
            <p>godefs returns the output for -godefs mode.</p>
            
            <pre><code>func godefs(f *File, args []string) string</code></pre>
         </article>
         
         <article class="function" data-name="gofmt">
            <h2>gofmt</h2>
            <hr />
            
            <p>gofmt returns the gofmt-formatted string for an AST node.</p>
            
            <pre><code>func gofmt(n *ast.InterfaceType) string</code></pre>
         </article>
         
         <article class="function" data-name="writeDefs">
            <h2>writeDefs</h2>
            <hr />
            
            <p>writeDefs creates output files to be compiled by gc and gcc.</p>
            
            <pre><code>func writeDefs()</code></pre>
         </article>
         
         <article class="function" data-name="elfImportedSymbols">
            <h2>elfImportedSymbols</h2>
            <hr />
            
            <p>elfImportedSymbols is like elf.File.ImportedSymbols, but it
includes weak symbols.

A bug in some versions of LLD (at least LLD 8) cause it to emit
several pthreads symbols as weak, but we need to import those. See
issue #31912 or https://bugs.llvm.org/show_bug.cgi?id=42442.

When doing external linking, we hand everything off to the external
linker, which will create its own dynamic symbol tables. For
internal linking, this may turn weak imports into strong imports,
which could cause dynamic linking to fail if a symbol really isn't
defined. However, the standard library depends on everything it
imports, and this is the primary use of dynamic symbol tables with
internal linking.</p>
            
            <pre><code>func elfImportedSymbols(f *elf.File) []elf.ImportedSymbol</code></pre>
         </article>
         
         <article class="function" data-name="dynimport">
            <h2>dynimport</h2>
            <hr />
            
            <pre><code>func dynimport(obj string)</code></pre>
         </article>
         
         <article class="function" data-name="checkImportSymName">
            <h2>checkImportSymName</h2>
            <hr />
            
            <p>checkImportSymName checks a symbol name we are going to emit as part
of a //go:cgo_import_dynamic pragma. These names come from object
files, so they may be corrupt. We are going to emit them unquoted,
so while they don't need to be valid symbol names (and in some cases,
involving symbol versions, they won't be) they must contain only
graphic characters and must not contain Go comments.</p>
            
            <pre><code>func checkImportSymName(s string)</code></pre>
         </article>
         
         <article class="function" data-name="structType">
            <h2>structType</h2>
            <hr />
            
            <p>Construct a gcc struct matching the gc argument frame.
Assumes that in gcc, char is 1 byte, short 2 bytes, int 4 bytes, long long 8 bytes.
These assumptions are checked by the gccProlog.
Also assumes that gc convention is to word-align the
input and output parameters.</p>
            
            <pre><code>func structType(n *Name) (string, int64)</code></pre>
         </article>
         
         <article class="function" data-name="writeDefsFunc">
            <h2>writeDefsFunc</h2>
            <hr />
            
            <pre><code>func writeDefsFunc(fgo2 io.Writer, n *Name, callsMalloc *bool)</code></pre>
         </article>
         
         <article class="function" data-name="writeOutput">
            <h2>writeOutput</h2>
            <hr />
            
            <p>writeOutput creates stubs for a specific source file to be compiled by gc</p>
            
            <pre><code>func writeOutput(f *File, srcfile string)</code></pre>
         </article>
         
         <article class="function" data-name="fixGo">
            <h2>fixGo</h2>
            <hr />
            
            <p>fixGo converts the internal Name.Go field into the name we should show
to users in error messages. There's only one for now: on input we rewrite
C.malloc into C._CMalloc, so change it back here.</p>
            
            <pre><code>func fixGo(name string) string</code></pre>
         </article>
         
         <article class="function" data-name="writeOutputFunc">
            <h2>writeOutputFunc</h2>
            <hr />
            
            <pre><code>func writeOutputFunc(fgcc *os.File, n *Name)</code></pre>
         </article>
         
         <article class="function" data-name="writeGccgoOutputFunc">
            <h2>writeGccgoOutputFunc</h2>
            <hr />
            
            <p>Write out a wrapper for a function when using gccgo. This is a
simple wrapper that just calls the real function. We only need a
wrapper to support static functions in the prologue--without a
wrapper, we can't refer to the function, since the reference is in
a different file.</p>
            
            <pre><code>func writeGccgoOutputFunc(fgcc *os.File, n *Name)</code></pre>
         </article>
         
         <article class="function" data-name="packedAttribute">
            <h2>packedAttribute</h2>
            <hr />
            
            <p>packedAttribute returns host compiler struct attribute that will be
used to match gc's struct layout. For example, on 386 Windows,
gcc wants to 8-align int64s, but gc does not.
Use __gcc_struct__ to work around https://gcc.gnu.org/PR52991 on x86,
and https://golang.org/issue/5603.</p>
            
            <pre><code>func packedAttribute() string</code></pre>
         </article>
         
         <article class="function" data-name="exportParamName">
            <h2>exportParamName</h2>
            <hr />
            
            <p>exportParamName returns the value of param as it should be
displayed in a c header file. If param contains any non-ASCII
characters, this function will return the character p followed by
the value of position; otherwise, this function will return the
value of param.</p>
            
            <pre><code>func exportParamName(param string, position int) string</code></pre>
         </article>
         
         <article class="function" data-name="writeExports">
            <h2>writeExports</h2>
            <hr />
            
            <p>Write out the various stubs we need to support functions exported
from Go so that they are callable from C.</p>
            
            <pre><code>func writeExports(fgo2 io.Writer, fm io.Writer, fgcc io.Writer, fgcch io.Writer)</code></pre>
         </article>
         
         <article class="function" data-name="writeGccgoExports">
            <h2>writeGccgoExports</h2>
            <hr />
            
            <p>Write out the C header allowing C code to call exported gccgo functions.</p>
            
            <pre><code>func writeGccgoExports(fgo2 io.Writer, fm io.Writer, fgcc io.Writer, fgcch io.Writer)</code></pre>
         </article>
         
         <article class="function" data-name="writeExportHeader">
            <h2>writeExportHeader</h2>
            <hr />
            
            <p>writeExportHeader writes out the start of the _cgo_export.h file.</p>
            
            <pre><code>func writeExportHeader(fgcch io.Writer)</code></pre>
         </article>
         
         <article class="function" data-name="gccgoToSymbol">
            <h2>gccgoToSymbol</h2>
            <hr />
            
            <p>gccgoToSymbol converts a name to a mangled symbol for gccgo.</p>
            
            <pre><code>func gccgoToSymbol(ppath string) string</code></pre>
         </article>
         
         <article class="function" data-name="gccgoSymbolPrefix">
            <h2>gccgoSymbolPrefix</h2>
            <hr />
            
            <p>Return the package prefix when using gccgo.</p>
            
            <pre><code>func gccgoSymbolPrefix() string</code></pre>
         </article>
         
         <article class="function" data-name="forFieldList">
            <h2>forFieldList</h2>
            <hr />
            
            <p>Call a function for each entry in an ast.FieldList, passing the
index into the list, the name if any, and the type.</p>
            
            <pre><code>func forFieldList(fl *ast.FieldList, fn func)</code></pre>
         </article>
         
         <article class="function" data-name="c">
            <h2>c</h2>
            <hr />
            
            <pre><code>func c(repr string, args ...*ast.InterfaceType) *TypeRepr</code></pre>
         </article>
         
         <article class="function" data-name="cgoType">
            <h2>cgoType</h2>
            <hr />
            
            <p>Map an ast type to a Type.</p>
            
            <pre><code>func cgoType(e ast.Expr) *Type</code></pre>
         </article>
         
         <article class="function" data-name="doCgoType">
            <h2>doCgoType</h2>
            <hr />
            
            <p>Map an ast type to a Type, avoiding cycles.</p>
            
            <pre><code>func doCgoType(e ast.Expr, m *ast.MapType) *Type</code></pre>
         </article>
         
         <article class="function" data-name="cPrologGccgo">
            <h2>cPrologGccgo</h2>
            <hr />
            
            <pre><code>func cPrologGccgo() string</code></pre>
         </article>
         
         <article class="function" data-name="gccExportHeaderProlog">
            <h2>gccExportHeaderProlog</h2>
            <hr />
            
            <pre><code>func gccExportHeaderProlog() string</code></pre>
         </article>
         
         <article class="function" data-name="defaultCC">
            <h2>defaultCC</h2>
            <hr />
            
            <pre><code>func defaultCC(goos string, goarch string) string</code></pre>
         </article>
         
         <article class="function" data-name="defaultCXX">
            <h2>defaultCXX</h2>
            <hr />
            
            <pre><code>func defaultCXX(goos string, goarch string) string</code></pre>
         </article>
         
         <article class="function" data-name="parse">
            <h2>parse</h2>
            <hr />
            
            <pre><code>func parse(name string, src []byte, flags parser.Mode) *ast.File</code></pre>
         </article>
         
         <article class="function" data-name="sourceLine">
            <h2>sourceLine</h2>
            <hr />
            
            <pre><code>func sourceLine(n ast.Node) int</code></pre>
         </article>
         
         <article class="function" data-name="ParseGo">
            <h2>ParseGo</h2>
            <hr />
            
            <p>ParseGo populates f with information learned from the Go source code
which was read from the named file. It gathers the C preamble
attached to the import "C" comment, a list of references to C.xxx,
a list of exported functions, and the actual AST, to be rewritten and
printed.</p>
            
            <pre><code>func ParseGo(abspath string, src []byte)</code></pre>
         </article>
         
         <article class="function" data-name="commentText">
            <h2>commentText</h2>
            <hr />
            
            <p>Like ast.CommentGroup's Text method but preserves
leading blank lines, so that line numbers line up.</p>
            
            <pre><code>func commentText(g *ast.CommentGroup) string</code></pre>
         </article>
         
         <article class="function" data-name="validateIdents">
            <h2>validateIdents</h2>
            <hr />
            
            <pre><code>func validateIdents(x *ast.InterfaceType, context astContext)</code></pre>
         </article>
         
         <article class="function" data-name="saveExprs">
            <h2>saveExprs</h2>
            <hr />
            
            <p>Save various references we are going to need later.</p>
            
            <pre><code>func saveExprs(x *ast.InterfaceType, context astContext)</code></pre>
         </article>
         
         <article class="function" data-name="saveRef">
            <h2>saveRef</h2>
            <hr />
            
            <p>Save references to C.xxx for later processing.</p>
            
            <pre><code>func saveRef(n *ast.Expr, context astContext)</code></pre>
         </article>
         
         <article class="function" data-name="saveCall">
            <h2>saveCall</h2>
            <hr />
            
            <p>Save calls to C.xxx for later processing.</p>
            
            <pre><code>func saveCall(call *ast.CallExpr, context astContext)</code></pre>
         </article>
         
         <article class="function" data-name="saveExport">
            <h2>saveExport</h2>
            <hr />
            
            <p>If a function should be exported add it to ExpFunc.</p>
            
            <pre><code>func saveExport(x *ast.InterfaceType, context astContext)</code></pre>
         </article>
         
         <article class="function" data-name="saveExport2">
            <h2>saveExport2</h2>
            <hr />
            
            <p>Make f.ExpFunc[i] point at the Func from this AST instead of the other one.</p>
            
            <pre><code>func saveExport2(x *ast.InterfaceType, context astContext)</code></pre>
         </article>
         
         <article class="function" data-name="walk">
            <h2>walk</h2>
            <hr />
            
            <p>walk walks the AST x, calling visit(f, x, context) for each node.</p>
            
            <pre><code>func walk(x *ast.InterfaceType, context astContext, visit func)</code></pre>
         </article>
         
         <article class="function" data-name="unparen">
            <h2>unparen</h2>
            <hr />
            
            <p>If x is of the form (T), unparen returns unparen(T), otherwise it returns x.</p>
            
            <pre><code>func unparen(x ast.Expr) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="walkUnexpected">
            <h2>walkUnexpected</h2>
            <hr />
            
            <pre><code>func walkUnexpected(x *ast.InterfaceType, context astContext, visit func)</code></pre>
         </article>
         
         <article class="function" data-name="funcTypeTypeParams">
            <h2>funcTypeTypeParams</h2>
            <hr />
            
            <pre><code>func funcTypeTypeParams(n *ast.FuncType) *ast.FieldList</code></pre>
         </article>
         
         <article class="function" data-name="typeSpecTypeParams">
            <h2>typeSpecTypeParams</h2>
            <hr />
            
            <pre><code>func typeSpecTypeParams(n *ast.TypeSpec) *ast.FieldList</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
