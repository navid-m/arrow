<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - fuzz</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>fuzz</code>
         </h1>
         <hr />
         
         <article class="global" data-name="coverageEnabled">
            <h2>coverageEnabled</h2>
            <hr />
            
            <pre><code>coverageEnabled</code></pre>
         </article>
         
         <article class="global" data-name="coverageSnapshot">
            <h2>coverageSnapshot</h2>
            <hr />
            
            <pre><code>coverageSnapshot</code></pre>
         </article>
         
         <article class="global" data-name="_counters">
            <h2>_counters</h2>
            <hr />
            
            <p>_counters and _ecounters mark the start and end, respectively, of where
the 8-bit coverage counters reside in memory. They're known to cmd/link,
which specially assigns their addresses for this purpose.</p>
            
            <pre><code>_counters []byte</code></pre>
         </article>
         
         <article class="global" data-name="_ecounters">
            <h2>_ecounters</h2>
            <hr />
            
            <p>_counters and _ecounters mark the start and end, respectively, of where
the 8-bit coverage counters reside in memory. They're known to cmd/link,
which specially assigns their addresses for this purpose.</p>
            
            <pre><code>_ecounters []byte</code></pre>
         </article>
         
         <article class="global" data-name="encVersion1">
            <h2>encVersion1</h2>
            <hr />
            
            <p>encVersion1 will be the first line of a file with version 1 encoding.</p>
            
            <pre><code>encVersion1</code></pre>
         </article>
         
         <article class="global" data-name="byteSliceMutators">
            <h2>byteSliceMutators</h2>
            <hr />
            
            <pre><code>byteSliceMutators</code></pre>
         </article>
         
         <article class="global" data-name="interesting8">
            <h2>interesting8</h2>
            <hr />
            
            <pre><code>interesting8</code></pre>
         </article>
         
         <article class="global" data-name="interesting16">
            <h2>interesting16</h2>
            <hr />
            
            <pre><code>interesting16</code></pre>
         </article>
         
         <article class="global" data-name="interesting32">
            <h2>interesting32</h2>
            <hr />
            
            <pre><code>interesting32</code></pre>
         </article>
         
         <article class="global" data-name="maxUint">
            <h2>maxUint</h2>
            <hr />
            
            <pre><code>maxUint</code></pre>
         </article>
         
         <article class="global" data-name="maxInt">
            <h2>maxInt</h2>
            <hr />
            
            <pre><code>maxInt</code></pre>
         </article>
         
         <article class="global" data-name="workerFuzzDuration">
            <h2>workerFuzzDuration</h2>
            <hr />
            
            <p>workerFuzzDuration is the amount of time a worker can spend testing random
variations of an input given by the coordinator.</p>
            
            <pre><code>workerFuzzDuration</code></pre>
         </article>
         
         <article class="global" data-name="workerTimeoutDuration">
            <h2>workerTimeoutDuration</h2>
            <hr />
            
            <p>workerTimeoutDuration is the amount of time a worker can go without
responding to the coordinator before being stopped.</p>
            
            <pre><code>workerTimeoutDuration</code></pre>
         </article>
         
         <article class="global" data-name="workerExitCode">
            <h2>workerExitCode</h2>
            <hr />
            
            <p>workerExitCode is used as an exit code by fuzz worker processes after an internal error.
This distinguishes internal errors from uncontrolled panics and other crashes.
Keep in sync with internal/fuzz.workerExitCode.</p>
            
            <pre><code>workerExitCode</code></pre>
         </article>
         
         <article class="global" data-name="workerSharedMemSize">
            <h2>workerSharedMemSize</h2>
            <hr />
            
            <p>workerSharedMemSize is the maximum size of the shared memory file used to
communicate with workers. This limits the size of fuzz inputs.</p>
            
            <pre><code>workerSharedMemSize</code></pre>
         </article>
         
         <article class="global" data-name="chainedMutations">
            <h2>chainedMutations</h2>
            <hr />
            
            <p>chainedMutations is how many mutations are applied before the worker
resets the input to its original state.
NOTE: this number was picked without much thought. It is low enough that
it seems to create a significant diversity in mutated inputs. We may want
to consider looking into this more closely once we have a proper performance
testing framework. Another option is to randomly pick the number of chained
mutations on each invocation of the workerServer.fuzz method (this appears to
be what libFuzzer does, although there seems to be no documentation which
explains why this choice was made.)</p>
            
            <pre><code>chainedMutations</code></pre>
         </article>
         
         <article class="global" data-name="errSharedMemClosed">
            <h2>errSharedMemClosed</h2>
            <hr />
            
            <p>errSharedMemClosed is returned by workerClient methods that cannot access
shared memory because it was closed and unmapped by another goroutine. That
can happen when worker.cleanup is called in the worker goroutine while a
workerClient.fuzz call runs concurrently.

This error should not be reported. It indicates the operation was
interrupted.</p>
            
            <pre><code>errSharedMemClosed</code></pre>
         </article>
         
         <article class="global" data-name="benchmarkWorkerFlag">
            <h2>benchmarkWorkerFlag</h2>
            <hr />
            
            <pre><code>benchmarkWorkerFlag</code></pre>
         </article>
         
         <article class="global" data-name="zeroVals">
            <h2>zeroVals</h2>
            <hr />
            
            <pre><code>zeroVals []any</code></pre>
         </article>
         
         <article class="global" data-name="debugInfo">
            <h2>debugInfo</h2>
            <hr />
            
            <pre><code>debugInfo</code></pre>
         </article>
         
         <article class="global" data-name="globalInc">
            <h2>globalInc</h2>
            <hr />
            
            <pre><code>globalInc atomic.Uint64</code></pre>
         </article>
         
         <article class="global" data-name="multiplier">
            <h2>multiplier</h2>
            <hr />
            
            <pre><code>multiplier uint64</code></pre>
         </article>
          
         <article class="struct" data-name="mutator">
            <h2>type mutator struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">r mutatorRand
scratch []byte</code></pre>
         </article>
         
         <article class="struct" data-name="queue">
            <h2>type queue struct</h2>
            <hr />
            
            <p>queue holds a growable sequence of inputs for fuzzing and minimization.

For now, this is a simple ring buffer
(https://en.wikipedia.org/wiki/Circular_buffer).

TODO(golang.org/issue/46224): use a prioritization algorithm based on input
size, previous duration, coverage, and any other metrics that seem useful.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">elems []any
head int
len int</code></pre>
         </article>
         
         <article class="struct" data-name="sharedMemSys">
            <h2>type sharedMemSys struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="worker">
            <h2>type worker struct</h2>
            <hr />
            
            <p>worker manages a worker process running a test binary. The worker object
exists only in the coordinator (the process started by 'go test -fuzz').
workerClient is used by the coordinator to send RPCs to the worker process,
which handles them with workerServer.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">dir string
binPath string
args []string
env []string
coordinator *coordinator
memMu *ast.ChanType
cmd *exec.Cmd
client *workerClient
waitErr error
interrupted bool
termC *ast.ChanType</code></pre>
         </article>
         
         <article class="struct" data-name="call">
            <h2>type call struct</h2>
            <hr />
            
            <p>call is serialized and sent from the coordinator on fuzz_in. It acts as
a minimalist RPC mechanism. Exactly one of its fields must be set to indicate
which method to call.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Ping *pingArgs
Fuzz *fuzzArgs
Minimize *minimizeArgs</code></pre>
         </article>
         
         <article class="struct" data-name="minimizeArgs">
            <h2>type minimizeArgs struct</h2>
            <hr />
            
            <p>minimizeArgs contains arguments to workerServer.minimize. The value to
minimize is already in shared memory.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Timeout time.Duration
Limit int64
KeepCoverage []byte
Index int</code></pre>
         </article>
         
         <article class="struct" data-name="minimizeResponse">
            <h2>type minimizeResponse struct</h2>
            <hr />
            
            <p>minimizeResponse contains results from workerServer.minimize.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">WroteToMem bool
Err string
CoverageData []byte
Duration time.Duration
Count int64</code></pre>
         </article>
         
         <article class="struct" data-name="fuzzArgs">
            <h2>type fuzzArgs struct</h2>
            <hr />
            
            <p>fuzzArgs contains arguments to workerServer.fuzz. The value to fuzz is
passed in shared memory.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Timeout time.Duration
Limit int64
Warmup bool
CoverageData []byte</code></pre>
         </article>
         
         <article class="struct" data-name="fuzzResponse">
            <h2>type fuzzResponse struct</h2>
            <hr />
            
            <p>fuzzResponse contains results from workerServer.fuzz.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">TotalDuration time.Duration
InterestingDuration time.Duration
Count int64
CoverageData []byte
Err string
InternalErr string</code></pre>
         </article>
         
         <article class="struct" data-name="pingArgs">
            <h2>type pingArgs struct</h2>
            <hr />
            
            <p>pingArgs contains arguments to workerServer.ping.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="pingResponse">
            <h2>type pingResponse struct</h2>
            <hr />
            
            <p>pingResponse contains results from workerServer.ping.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="workerComm">
            <h2>type workerComm struct</h2>
            <hr />
            
            <p>workerComm holds pipes and shared memory used for communication
between the coordinator process (client) and a worker process (server).
These values are unique to each worker; they are shared only with the
coordinator, not with other workers.

Access to shared memory is synchronized implicitly over the RPC protocol
implemented in workerServer and workerClient. During a call, the client
(worker) has exclusive access to shared memory; at other times, the server
(coordinator) has exclusive access.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">fuzzIn *os.File
fuzzOut *os.File
memMu *ast.ChanType</code></pre>
         </article>
         
         <article class="struct" data-name="workerServer">
            <h2>type workerServer struct</h2>
            <hr />
            
            <p>workerServer is a minimalist RPC server, run by fuzz worker processes.
It allows the coordinator process (using workerClient) to call methods in a
worker process. This system allows the coordinator to run multiple worker
processes in parallel and to collect inputs that caused crashes from shared
memory after a worker process terminates unexpectedly.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">workerComm
m *mutator
coverageMask []byte
fuzzFn func</code></pre>
         </article>
         
         <article class="struct" data-name="workerClient">
            <h2>type workerClient struct</h2>
            <hr />
            
            <p>workerClient is a minimalist RPC client. The coordinator process uses a
workerClient to call methods in each worker process (handled by
workerServer).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">workerComm
m *mutator
mu sync.Mutex</code></pre>
         </article>
         
         <article class="struct" data-name="contextReader">
            <h2>type contextReader struct</h2>
            <hr />
            
            <p>contextReader wraps a Reader with a Context. If the context is canceled
while the underlying reader is blocked, Read returns immediately.

This is useful for reading from a pipe. Closing a pipe file descriptor does
not unblock pending Reads on that file descriptor. All copies of the pipe's
other file descriptor (the write end) must be closed in all processes that
inherit it. This is difficult to do correctly in the situation we care about
(process group termination).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ctx context.Context
r io.Reader</code></pre>
         </article>
         
         <article class="struct" data-name="sharedMem">
            <h2>type sharedMem struct</h2>
            <hr />
            
            <p>sharedMem manages access to a region of virtual memory mapped from a file,
shared between multiple processes. The region includes space for a header and
a value of variable length.

When fuzzing, the coordinator creates a sharedMem from a temporary file for
each worker. This buffer is used to pass values to fuzz between processes.
Care must be taken to manage access to shared memory across processes;
sharedMem provides no synchronization on its own. See workerComm for an
explanation.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">f *os.File
region []byte
removeOnClose bool
sys sharedMemSys</code></pre>
         </article>
         
         <article class="struct" data-name="sharedMemHeader">
            <h2>type sharedMemHeader struct</h2>
            <hr />
            
            <p>sharedMemHeader stores metadata in shared memory.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">count int64
valueLen int
randState uint64
randInc uint64
rawInMem bool</code></pre>
         </article>
         
         <article class="struct" data-name="mockRand">
            <h2>type mockRand struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">values []int
counter int
b bool</code></pre>
         </article>
         
         <article class="struct" data-name="sharedMemSys">
            <h2>type sharedMemSys struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="CoordinateFuzzingOpts">
            <h2>type CoordinateFuzzingOpts struct</h2>
            <hr />
            
            <p>CoordinateFuzzingOpts is a set of arguments for CoordinateFuzzing.
The zero value is valid for each field unless specified otherwise.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Log io.Writer
Timeout time.Duration
Limit int64
MinimizeTimeout time.Duration
MinimizeLimit int64
Parallel int
Seed []CorpusEntry
Types []reflect.Type
CorpusDir string
CacheDir string</code></pre>
         </article>
         
         <article class="struct" data-name="crashError">
            <h2>type crashError struct</h2>
            <hr />
            
            <p>crashError wraps a crasher written to the seed corpus. It saves the name
of the file where the input causing the crasher was saved. The testing
framework uses this to report a command to re-run that specific input.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string
err error</code></pre>
         </article>
         
         <article class="struct" data-name="corpus">
            <h2>type corpus struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">entries []CorpusEntry
hashes *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="CorpusEntry">
            <h2>type CorpusEntry struct</h2>
            <hr />
            
            <p>CorpusEntry represents an individual input for fuzzing.

We must use an equivalent type in the testing and testing/internal/testdeps
packages, but testing can't import this package directly, and we don't want
to export this type from testing. Instead, we use the same struct type and
use a type alias (not a defined type) for convenience.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Parent string
Path string
Data []byte
Values []any
Generation int
IsSeed bool</code></pre>
         </article>
         
         <article class="struct" data-name="fuzzInput">
            <h2>type fuzzInput struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">entry CorpusEntry
timeout time.Duration
limit int64
warmup bool
coverageData []byte</code></pre>
         </article>
         
         <article class="struct" data-name="fuzzResult">
            <h2>type fuzzResult struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">entry CorpusEntry
crasherMsg string
canMinimize bool
coverageData []byte
limit int64
count int64
totalDuration time.Duration
entryDuration time.Duration</code></pre>
         </article>
         
         <article class="struct" data-name="fuzzMinimizeInput">
            <h2>type fuzzMinimizeInput struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">entry CorpusEntry
crasherMsg string
limit int64
timeout time.Duration
keepCoverage []byte</code></pre>
         </article>
         
         <article class="struct" data-name="coordinator">
            <h2>type coordinator struct</h2>
            <hr />
            
            <p>coordinator holds channels that workers can use to communicate with
the coordinator.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">opts CoordinateFuzzingOpts
startTime time.Time
inputC *ast.ChanType
minimizeC *ast.ChanType
resultC *ast.ChanType
count int64
countLastLog int64
timeLastLog time.Time
interestingCount int
warmupInputCount int
warmupInputLeft int
duration time.Duration
countWaiting int64
corpus corpus
minimizationAllowed bool
inputQueue queue
minimizeQueue queue
crashMinimizing *fuzzResult
coverageMask []byte</code></pre>
         </article>
         
         <article class="struct" data-name="MalformedCorpusError">
            <h2>type MalformedCorpusError struct</h2>
            <hr />
            
            <p>MalformedCorpusError is an error found while reading the corpus from the
filesystem. All of the errors are stored in the errs list. The testing
framework uses this to report malformed files in testdata.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">errs []error</code></pre>
         </article>
         
         <article class="struct" data-name="pcgRand">
            <h2>type pcgRand struct</h2>
            <hr />
            
            <p>pcgRand is a PRNG. It should not be copied or shared. No Rand methods are
concurrency safe.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">noCopy noCopy
state uint64
inc uint64</code></pre>
         </article>
         
         <article class="struct" data-name="noCopy">
            <h2>type noCopy struct</h2>
            <hr />
            
            <p>noCopy may be embedded into structs which must not be copied
after the first use.

See https://golang.org/issues/8005#issuecomment-190753527
for details.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="sharedMemSys">
            <h2>type sharedMemSys struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">mapObj syscall.Handle</code></pre>
         </article>
          
         <article class="function" data-name="ResetCoverage">
            <h2>ResetCoverage</h2>
            <hr />
            
            <p>ResetCoverage sets all of the counters for each edge of the instrumented
source code to 0.</p>
            
            <pre><code>func ResetCoverage()</code></pre>
         </article>
         
         <article class="function" data-name="SnapshotCoverage">
            <h2>SnapshotCoverage</h2>
            <hr />
            
            <p>SnapshotCoverage copies the current counter values into coverageSnapshot,
preserving them for later inspection. SnapshotCoverage also rounds each
counter down to the nearest power of two. This lets the coordinator store
multiple values for each counter by OR'ing them together.</p>
            
            <pre><code>func SnapshotCoverage()</code></pre>
         </article>
         
         <article class="function" data-name="diffCoverage">
            <h2>diffCoverage</h2>
            <hr />
            
            <p>diffCoverage returns a set of bits set in snapshot but not in base.
If there are no new bits set, diffCoverage returns nil.</p>
            
            <pre><code>func diffCoverage(base []byte, snapshot []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="countNewCoverageBits">
            <h2>countNewCoverageBits</h2>
            <hr />
            
            <p>countNewCoverageBits returns the number of bits set in snapshot that are not
set in base.</p>
            
            <pre><code>func countNewCoverageBits(base []byte, snapshot []byte) int</code></pre>
         </article>
         
         <article class="function" data-name="isCoverageSubset">
            <h2>isCoverageSubset</h2>
            <hr />
            
            <p>isCoverageSubset returns true if all the base coverage bits are set in
snapshot.</p>
            
            <pre><code>func isCoverageSubset(base []byte, snapshot []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="hasCoverageBit">
            <h2>hasCoverageBit</h2>
            <hr />
            
            <p>hasCoverageBit returns true if snapshot has at least one bit set that is
also set in base.</p>
            
            <pre><code>func hasCoverageBit(base []byte, snapshot []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="countBits">
            <h2>countBits</h2>
            <hr />
            
            <pre><code>func countBits(cov []byte) int</code></pre>
         </article>
         
         <article class="function" data-name="marshalCorpusFile">
            <h2>marshalCorpusFile</h2>
            <hr />
            
            <p>marshalCorpusFile encodes an arbitrary number of arguments into the file format for the
corpus.</p>
            
            <pre><code>func marshalCorpusFile(vals ...any) []byte</code></pre>
         </article>
         
         <article class="function" data-name="unmarshalCorpusFile">
            <h2>unmarshalCorpusFile</h2>
            <hr />
            
            <p>unmarshalCorpusFile decodes corpus bytes into their respective values.</p>
            
            <pre><code>func unmarshalCorpusFile(b []byte) ([]any, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseCorpusValue">
            <h2>parseCorpusValue</h2>
            <hr />
            
            <pre><code>func parseCorpusValue(line []byte) (any, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseInt">
            <h2>parseInt</h2>
            <hr />
            
            <p>parseInt returns an integer of value val and type typ.</p>
            
            <pre><code>func parseInt(val string, typ string) (any, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseUint">
            <h2>parseUint</h2>
            <hr />
            
            <p>parseUint returns an unsigned integer of value val and type typ.</p>
            
            <pre><code>func parseUint(val string, typ string) (any, error)</code></pre>
         </article>
         
         <article class="function" data-name="newMutator">
            <h2>newMutator</h2>
            <hr />
            
            <pre><code>func newMutator() *mutator</code></pre>
         </article>
         
         <article class="function" data-name="rand">
            <h2>rand</h2>
            <hr />
            
            <pre><code>func rand(n int) int</code></pre>
         </article>
         
         <article class="function" data-name="randByteOrder">
            <h2>randByteOrder</h2>
            <hr />
            
            <pre><code>func randByteOrder() binary.ByteOrder</code></pre>
         </article>
         
         <article class="function" data-name="chooseLen">
            <h2>chooseLen</h2>
            <hr />
            
            <p>chooseLen chooses length of range mutation in range [1,n]. It gives
preference to shorter ranges.</p>
            
            <pre><code>func chooseLen(n int) int</code></pre>
         </article>
         
         <article class="function" data-name="mutate">
            <h2>mutate</h2>
            <hr />
            
            <p>mutate performs several mutations on the provided values.</p>
            
            <pre><code>func mutate(vals []any, maxBytes int)</code></pre>
         </article>
         
         <article class="function" data-name="mutateInt">
            <h2>mutateInt</h2>
            <hr />
            
            <pre><code>func mutateInt(v int64, maxValue int64) int64</code></pre>
         </article>
         
         <article class="function" data-name="mutateUInt">
            <h2>mutateUInt</h2>
            <hr />
            
            <pre><code>func mutateUInt(v uint64, maxValue uint64) uint64</code></pre>
         </article>
         
         <article class="function" data-name="mutateFloat">
            <h2>mutateFloat</h2>
            <hr />
            
            <pre><code>func mutateFloat(v float64, maxValue float64) float64</code></pre>
         </article>
         
         <article class="function" data-name="mutateBytes">
            <h2>mutateBytes</h2>
            <hr />
            
            <pre><code>func mutateBytes(ptrB *[]byte)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="cap">
            <h2>cap</h2>
            <hr />
            
            <pre><code>func cap() int</code></pre>
         </article>
         
         <article class="function" data-name="grow">
            <h2>grow</h2>
            <hr />
            
            <pre><code>func grow()</code></pre>
         </article>
         
         <article class="function" data-name="enqueue">
            <h2>enqueue</h2>
            <hr />
            
            <pre><code>func enqueue(e any)</code></pre>
         </article>
         
         <article class="function" data-name="dequeue">
            <h2>dequeue</h2>
            <hr />
            
            <pre><code>func dequeue() (any, bool)</code></pre>
         </article>
         
         <article class="function" data-name="peek">
            <h2>peek</h2>
            <hr />
            
            <pre><code>func peek() (any, bool)</code></pre>
         </article>
         
         <article class="function" data-name="clear">
            <h2>clear</h2>
            <hr />
            
            <pre><code>func clear()</code></pre>
         </article>
         
         <article class="function" data-name="sharedMemMapFile">
            <h2>sharedMemMapFile</h2>
            <hr />
            
            <pre><code>func sharedMemMapFile(f *os.File, size int, removeOnClose bool) (*sharedMem, error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="setWorkerComm">
            <h2>setWorkerComm</h2>
            <hr />
            
            <pre><code>func setWorkerComm(cmd *exec.Cmd, comm workerComm)</code></pre>
         </article>
         
         <article class="function" data-name="getWorkerComm">
            <h2>getWorkerComm</h2>
            <hr />
            
            <pre><code>func getWorkerComm() (comm workerComm, err error)</code></pre>
         </article>
         
         <article class="function" data-name="isInterruptError">
            <h2>isInterruptError</h2>
            <hr />
            
            <pre><code>func isInterruptError(err error) bool</code></pre>
         </article>
         
         <article class="function" data-name="terminationSignal">
            <h2>terminationSignal</h2>
            <hr />
            
            <pre><code>func terminationSignal(err error) (os.Signal, bool)</code></pre>
         </article>
         
         <article class="function" data-name="isCrashSignal">
            <h2>isCrashSignal</h2>
            <hr />
            
            <pre><code>func isCrashSignal(signal os.Signal) bool</code></pre>
         </article>
         
         <article class="function" data-name="newWorker">
            <h2>newWorker</h2>
            <hr />
            
            <pre><code>func newWorker(c *coordinator, dir string, binPath string, args []string, env []string) (*worker, error)</code></pre>
         </article>
         
         <article class="function" data-name="cleanup">
            <h2>cleanup</h2>
            <hr />
            
            <p>cleanup releases persistent resources associated with the worker.</p>
            
            <pre><code>func cleanup() error</code></pre>
         </article>
         
         <article class="function" data-name="coordinate">
            <h2>coordinate</h2>
            <hr />
            
            <p>coordinate runs the test binary to perform fuzzing.

coordinate loops until ctx is canceled or a fatal error is encountered.
If a test process terminates unexpectedly while fuzzing, coordinate will
attempt to restart and continue unless the termination can be attributed
to an interruption (from a timer or the user).

While looping, coordinate receives inputs from the coordinator, passes
those inputs to the worker process, then passes the results back to
the coordinator.</p>
            
            <pre><code>func coordinate(ctx context.Context) error</code></pre>
         </article>
         
         <article class="function" data-name="minimize">
            <h2>minimize</h2>
            <hr />
            
            <p>minimize tells a worker process to attempt to find a smaller value that
either causes an error (if we started minimizing because we found an input
that causes an error) or preserves new coverage (if we started minimizing
because we found an input that expands coverage).</p>
            
            <pre><code>func minimize(ctx context.Context, input fuzzMinimizeInput) (min fuzzResult, err error)</code></pre>
         </article>
         
         <article class="function" data-name="isRunning">
            <h2>isRunning</h2>
            <hr />
            
            <pre><code>func isRunning() bool</code></pre>
         </article>
         
         <article class="function" data-name="startAndPing">
            <h2>startAndPing</h2>
            <hr />
            
            <p>startAndPing starts the worker process and sends it a message to make sure it
can communicate.

startAndPing returns an error if any part of this didn't work, including if
the context is expired or the worker process was interrupted before it
responded. Errors that happen after start but before the ping response
likely indicate that the worker did not call F.Fuzz or called F.Fail first.
We don't record crashers for these errors.</p>
            
            <pre><code>func startAndPing(ctx context.Context) error</code></pre>
         </article>
         
         <article class="function" data-name="start">
            <h2>start</h2>
            <hr />
            
            <p>start runs a new worker process.

If the process couldn't be started, start returns an error. Start won't
return later termination errors from the process if they occur.

If the process starts successfully, start returns nil. stop must be called
once later to clean up, even if the process terminates on its own.

When the process terminates, w.waitErr is set to the error (if any), and
w.termC is closed.</p>
            
            <pre><code>func start() err error</code></pre>
         </article>
         
         <article class="function" data-name="stop">
            <h2>stop</h2>
            <hr />
            
            <p>stop tells the worker process to exit by closing w.client, then blocks until
it terminates. If the worker doesn't terminate after a short time, stop
signals it with os.Interrupt (where supported), then os.Kill.

stop returns the error the process terminated with, if any (same as
w.waitErr).

stop must be called at least once after start returns successfully, even if
the worker process terminates unexpectedly.</p>
            
            <pre><code>func stop() error</code></pre>
         </article>
         
         <article class="function" data-name="RunFuzzWorker">
            <h2>RunFuzzWorker</h2>
            <hr />
            
            <p>RunFuzzWorker is called in a worker process to communicate with the
coordinator process in order to fuzz random inputs. RunFuzzWorker loops
until the coordinator tells it to stop.

fn is a wrapper on the fuzz function. It may return an error to indicate
a given input "crashed". The coordinator will also record a crasher if
the function times out or terminates the process.

RunFuzzWorker returns an error if it could not communicate with the
coordinator process.</p>
            
            <pre><code>func RunFuzzWorker(ctx context.Context, fn func) error</code></pre>
         </article>
         
         <article class="function" data-name="serve">
            <h2>serve</h2>
            <hr />
            
            <p>serve reads serialized RPC messages on fuzzIn. When serve receives a message,
it calls the corresponding method, then sends the serialized result back
on fuzzOut.

serve handles RPC calls synchronously; it will not attempt to read a message
until the previous call has finished.

serve returns errors that occurred when communicating over pipes. serve
does not return errors from method calls; those are passed through serialized
responses.</p>
            
            <pre><code>func serve(ctx context.Context) error</code></pre>
         </article>
         
         <article class="function" data-name="fuzz">
            <h2>fuzz</h2>
            <hr />
            
            <p>fuzz runs the test function on random variations of the input value in shared
memory for a limited duration or number of iterations.

fuzz returns early if it finds an input that crashes the fuzz function (with
fuzzResponse.Err set) or an input that expands coverage (with
fuzzResponse.InterestingDuration set).

fuzz does not modify the input in shared memory. Instead, it saves the
initial PRNG state in shared memory and increments a counter in shared
memory before each call to the test function. The caller may reconstruct
the crashing input with this information, since the PRNG is deterministic.</p>
            
            <pre><code>func fuzz(ctx context.Context, args fuzzArgs) resp fuzzResponse</code></pre>
         </article>
         
         <article class="function" data-name="minimize">
            <h2>minimize</h2>
            <hr />
            
            <pre><code>func minimize(ctx context.Context, args minimizeArgs) resp minimizeResponse</code></pre>
         </article>
         
         <article class="function" data-name="minimizeInput">
            <h2>minimizeInput</h2>
            <hr />
            
            <p>minimizeInput applies a series of minimizing transformations on the provided
vals, ensuring that each minimization still causes an error, or keeps
coverage, in fuzzFn. It uses the context to determine how long to run,
stopping once closed. It returns a bool indicating whether minimization was
successful and an error if one was found.</p>
            
            <pre><code>func minimizeInput(ctx context.Context, vals []any, mem *sharedMem, args minimizeArgs) (success bool, retErr error)</code></pre>
         </article>
         
         <article class="function" data-name="writeToMem">
            <h2>writeToMem</h2>
            <hr />
            
            <pre><code>func writeToMem(vals []any, mem *sharedMem)</code></pre>
         </article>
         
         <article class="function" data-name="ping">
            <h2>ping</h2>
            <hr />
            
            <p>ping does nothing. The coordinator calls this method to ensure the worker
has called F.Fuzz and can communicate.</p>
            
            <pre><code>func ping(ctx context.Context, args pingArgs) pingResponse</code></pre>
         </article>
         
         <article class="function" data-name="newWorkerClient">
            <h2>newWorkerClient</h2>
            <hr />
            
            <pre><code>func newWorkerClient(comm workerComm, m *mutator) *workerClient</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close shuts down the connection to the RPC server (the worker process) by
closing fuzz_in. Close drains fuzz_out (avoiding a SIGPIPE in the worker),
and closes it after the worker process closes the other end.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="minimize">
            <h2>minimize</h2>
            <hr />
            
            <p>minimize tells the worker to call the minimize method. See
workerServer.minimize.</p>
            
            <pre><code>func minimize(ctx context.Context, entryIn CorpusEntry, args minimizeArgs) (entryOut CorpusEntry, resp minimizeResponse, retErr error)</code></pre>
         </article>
         
         <article class="function" data-name="fuzz">
            <h2>fuzz</h2>
            <hr />
            
            <p>fuzz tells the worker to call the fuzz method. See workerServer.fuzz.</p>
            
            <pre><code>func fuzz(ctx context.Context, entryIn CorpusEntry, args fuzzArgs) (entryOut CorpusEntry, resp fuzzResponse, isInternalError bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="ping">
            <h2>ping</h2>
            <hr />
            
            <p>ping tells the worker to call the ping method. See workerServer.ping.</p>
            
            <pre><code>func ping(ctx context.Context) error</code></pre>
         </article>
         
         <article class="function" data-name="callLocked">
            <h2>callLocked</h2>
            <hr />
            
            <p>callLocked sends an RPC from the coordinator to the worker process and waits
for the response. The callLocked may be canceled with ctx.</p>
            
            <pre><code>func callLocked(ctx context.Context, c call, resp any) err error</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(b []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="sharedMemSize">
            <h2>sharedMemSize</h2>
            <hr />
            
            <p>sharedMemSize returns the size needed for a shared memory buffer that can
contain values of the given size.</p>
            
            <pre><code>func sharedMemSize(valueSize int) int</code></pre>
         </article>
         
         <article class="function" data-name="sharedMemTempFile">
            <h2>sharedMemTempFile</h2>
            <hr />
            
            <p>sharedMemTempFile creates a new temporary file of the given size, then maps
it into memory. The file will be removed when the Close method is called.</p>
            
            <pre><code>func sharedMemTempFile(size int) (m *sharedMem, err error)</code></pre>
         </article>
         
         <article class="function" data-name="header">
            <h2>header</h2>
            <hr />
            
            <p>header returns a pointer to metadata within the shared memory region.</p>
            
            <pre><code>func header() *sharedMemHeader</code></pre>
         </article>
         
         <article class="function" data-name="valueRef">
            <h2>valueRef</h2>
            <hr />
            
            <p>valueRef returns the value currently stored in shared memory. The returned
slice points to shared memory; it is not a copy.</p>
            
            <pre><code>func valueRef() []byte</code></pre>
         </article>
         
         <article class="function" data-name="valueCopy">
            <h2>valueCopy</h2>
            <hr />
            
            <p>valueCopy returns a copy of the value stored in shared memory.</p>
            
            <pre><code>func valueCopy() []byte</code></pre>
         </article>
         
         <article class="function" data-name="setValue">
            <h2>setValue</h2>
            <hr />
            
            <p>setValue copies the data in b into the shared memory buffer and sets
the length. len(b) must be less than or equal to the capacity of the buffer
(as returned by cap(m.value())).</p>
            
            <pre><code>func setValue(b []byte)</code></pre>
         </article>
         
         <article class="function" data-name="setValueLen">
            <h2>setValueLen</h2>
            <hr />
            
            <p>setValueLen sets the length of the shared memory buffer returned by valueRef
to n, which may be at most the cap of that slice.

Note that we can only store the length in the shared memory header. The full
slice header contains a pointer, which is likely only valid for one process,
since each process can map shared memory at a different virtual address.</p>
            
            <pre><code>func setValueLen(n int)</code></pre>
         </article>
         
         <article class="function" data-name="isMinimizable">
            <h2>isMinimizable</h2>
            <hr />
            
            <pre><code>func isMinimizable(t reflect.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="minimizeBytes">
            <h2>minimizeBytes</h2>
            <hr />
            
            <pre><code>func minimizeBytes(v []byte, try func, shouldStop func)</code></pre>
         </article>
         
         <article class="function" data-name="TestQueue">
            <h2>TestQueue</h2>
            <hr />
            
            <pre><code>func TestQueue(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="libfuzzerTraceCmp1">
            <h2>libfuzzerTraceCmp1</h2>
            <hr />
            
            <pre><code>func libfuzzerTraceCmp1(arg0 uint8, arg1 uint8, fakePC uint)</code></pre>
         </article>
         
         <article class="function" data-name="libfuzzerTraceCmp2">
            <h2>libfuzzerTraceCmp2</h2>
            <hr />
            
            <pre><code>func libfuzzerTraceCmp2(arg0 uint16, arg1 uint16, fakePC uint)</code></pre>
         </article>
         
         <article class="function" data-name="libfuzzerTraceCmp4">
            <h2>libfuzzerTraceCmp4</h2>
            <hr />
            
            <pre><code>func libfuzzerTraceCmp4(arg0 uint32, arg1 uint32, fakePC uint)</code></pre>
         </article>
         
         <article class="function" data-name="libfuzzerTraceCmp8">
            <h2>libfuzzerTraceCmp8</h2>
            <hr />
            
            <pre><code>func libfuzzerTraceCmp8(arg0 uint64, arg1 uint64, fakePC uint)</code></pre>
         </article>
         
         <article class="function" data-name="libfuzzerTraceConstCmp1">
            <h2>libfuzzerTraceConstCmp1</h2>
            <hr />
            
            <pre><code>func libfuzzerTraceConstCmp1(arg0 uint8, arg1 uint8, fakePC uint)</code></pre>
         </article>
         
         <article class="function" data-name="libfuzzerTraceConstCmp2">
            <h2>libfuzzerTraceConstCmp2</h2>
            <hr />
            
            <pre><code>func libfuzzerTraceConstCmp2(arg0 uint16, arg1 uint16, fakePC uint)</code></pre>
         </article>
         
         <article class="function" data-name="libfuzzerTraceConstCmp4">
            <h2>libfuzzerTraceConstCmp4</h2>
            <hr />
            
            <pre><code>func libfuzzerTraceConstCmp4(arg0 uint32, arg1 uint32, fakePC uint)</code></pre>
         </article>
         
         <article class="function" data-name="libfuzzerTraceConstCmp8">
            <h2>libfuzzerTraceConstCmp8</h2>
            <hr />
            
            <pre><code>func libfuzzerTraceConstCmp8(arg0 uint64, arg1 uint64, fakePC uint)</code></pre>
         </article>
         
         <article class="function" data-name="libfuzzerHookStrCmp">
            <h2>libfuzzerHookStrCmp</h2>
            <hr />
            
            <pre><code>func libfuzzerHookStrCmp(arg0 string, arg1 string, fakePC uint)</code></pre>
         </article>
         
         <article class="function" data-name="libfuzzerHookEqualFold">
            <h2>libfuzzerHookEqualFold</h2>
            <hr />
            
            <pre><code>func libfuzzerHookEqualFold(arg0 string, arg1 string, fakePC uint)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshalMarshal">
            <h2>TestUnmarshalMarshal</h2>
            <hr />
            
            <pre><code>func TestUnmarshalMarshal(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkMarshalCorpusFile">
            <h2>BenchmarkMarshalCorpusFile</h2>
            <hr />
            
            <p>BenchmarkMarshalCorpusFile measures the time it takes to serialize byte
slices of various sizes to a corpus file. The slice contains a repeating
sequence of bytes 0-255 to mix escaped and non-escaped characters.</p>
            
            <pre><code>func BenchmarkMarshalCorpusFile(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkUnmarshalCorpusFile">
            <h2>BenchmarkUnmarshalCorpusFile</h2>
            <hr />
            
            <p>BenchmarkUnmarshalCorpusfile measures the time it takes to deserialize
files encoding byte slices of various sizes. The slice contains a repeating
sequence of bytes 0-255 to mix escaped and non-escaped characters.</p>
            
            <pre><code>func BenchmarkUnmarshalCorpusFile(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="TestByteRoundTrip">
            <h2>TestByteRoundTrip</h2>
            <hr />
            
            <pre><code>func TestByteRoundTrip(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInt8RoundTrip">
            <h2>TestInt8RoundTrip</h2>
            <hr />
            
            <pre><code>func TestInt8RoundTrip(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="FuzzFloat64RoundTrip">
            <h2>FuzzFloat64RoundTrip</h2>
            <hr />
            
            <pre><code>func FuzzFloat64RoundTrip(f *testing.F)</code></pre>
         </article>
         
         <article class="function" data-name="FuzzRuneRoundTrip">
            <h2>FuzzRuneRoundTrip</h2>
            <hr />
            
            <pre><code>func FuzzRuneRoundTrip(f *testing.F)</code></pre>
         </article>
         
         <article class="function" data-name="FuzzStringRoundTrip">
            <h2>FuzzStringRoundTrip</h2>
            <hr />
            
            <pre><code>func FuzzStringRoundTrip(f *testing.F)</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceRemoveBytes">
            <h2>byteSliceRemoveBytes</h2>
            <hr />
            
            <p>byteSliceRemoveBytes removes a random chunk of bytes from b.</p>
            
            <pre><code>func byteSliceRemoveBytes(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceInsertRandomBytes">
            <h2>byteSliceInsertRandomBytes</h2>
            <hr />
            
            <p>byteSliceInsertRandomBytes inserts a chunk of random bytes into b at a random
position.</p>
            
            <pre><code>func byteSliceInsertRandomBytes(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceDuplicateBytes">
            <h2>byteSliceDuplicateBytes</h2>
            <hr />
            
            <p>byteSliceDuplicateBytes duplicates a chunk of bytes in b and inserts it into
a random position.</p>
            
            <pre><code>func byteSliceDuplicateBytes(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceOverwriteBytes">
            <h2>byteSliceOverwriteBytes</h2>
            <hr />
            
            <p>byteSliceOverwriteBytes overwrites a chunk of b with another chunk of b.</p>
            
            <pre><code>func byteSliceOverwriteBytes(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceBitFlip">
            <h2>byteSliceBitFlip</h2>
            <hr />
            
            <p>byteSliceBitFlip flips a random bit in a random byte in b.</p>
            
            <pre><code>func byteSliceBitFlip(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceXORByte">
            <h2>byteSliceXORByte</h2>
            <hr />
            
            <p>byteSliceXORByte XORs a random byte in b with a random value.</p>
            
            <pre><code>func byteSliceXORByte(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceSwapByte">
            <h2>byteSliceSwapByte</h2>
            <hr />
            
            <p>byteSliceSwapByte swaps two random bytes in b.</p>
            
            <pre><code>func byteSliceSwapByte(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceArithmeticUint8">
            <h2>byteSliceArithmeticUint8</h2>
            <hr />
            
            <p>byteSliceArithmeticUint8 adds/subtracts from a random byte in b.</p>
            
            <pre><code>func byteSliceArithmeticUint8(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceArithmeticUint16">
            <h2>byteSliceArithmeticUint16</h2>
            <hr />
            
            <p>byteSliceArithmeticUint16 adds/subtracts from a random uint16 in b.</p>
            
            <pre><code>func byteSliceArithmeticUint16(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceArithmeticUint32">
            <h2>byteSliceArithmeticUint32</h2>
            <hr />
            
            <p>byteSliceArithmeticUint32 adds/subtracts from a random uint32 in b.</p>
            
            <pre><code>func byteSliceArithmeticUint32(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceArithmeticUint64">
            <h2>byteSliceArithmeticUint64</h2>
            <hr />
            
            <p>byteSliceArithmeticUint64 adds/subtracts from a random uint64 in b.</p>
            
            <pre><code>func byteSliceArithmeticUint64(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceOverwriteInterestingUint8">
            <h2>byteSliceOverwriteInterestingUint8</h2>
            <hr />
            
            <p>byteSliceOverwriteInterestingUint8 overwrites a random byte in b with an interesting
value.</p>
            
            <pre><code>func byteSliceOverwriteInterestingUint8(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceOverwriteInterestingUint16">
            <h2>byteSliceOverwriteInterestingUint16</h2>
            <hr />
            
            <p>byteSliceOverwriteInterestingUint16 overwrites a random uint16 in b with an interesting
value.</p>
            
            <pre><code>func byteSliceOverwriteInterestingUint16(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceOverwriteInterestingUint32">
            <h2>byteSliceOverwriteInterestingUint32</h2>
            <hr />
            
            <p>byteSliceOverwriteInterestingUint32 overwrites a random uint16 in b with an interesting
value.</p>
            
            <pre><code>func byteSliceOverwriteInterestingUint32(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceInsertConstantBytes">
            <h2>byteSliceInsertConstantBytes</h2>
            <hr />
            
            <p>byteSliceInsertConstantBytes inserts a chunk of constant bytes into a random position in b.</p>
            
            <pre><code>func byteSliceInsertConstantBytes(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceOverwriteConstantBytes">
            <h2>byteSliceOverwriteConstantBytes</h2>
            <hr />
            
            <p>byteSliceOverwriteConstantBytes overwrites a chunk of b with constant bytes.</p>
            
            <pre><code>func byteSliceOverwriteConstantBytes(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceShuffleBytes">
            <h2>byteSliceShuffleBytes</h2>
            <hr />
            
            <p>byteSliceShuffleBytes shuffles a chunk of bytes in b.</p>
            
            <pre><code>func byteSliceShuffleBytes(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="byteSliceSwapBytes">
            <h2>byteSliceSwapBytes</h2>
            <hr />
            
            <p>byteSliceSwapBytes swaps two chunks of bytes in b.</p>
            
            <pre><code>func byteSliceSwapBytes(m *mutator, b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="uint32">
            <h2>uint32</h2>
            <hr />
            
            <pre><code>func uint32() uint32</code></pre>
         </article>
         
         <article class="function" data-name="intn">
            <h2>intn</h2>
            <hr />
            
            <pre><code>func intn(n int) int</code></pre>
         </article>
         
         <article class="function" data-name="uint32n">
            <h2>uint32n</h2>
            <hr />
            
            <pre><code>func uint32n(n uint32) uint32</code></pre>
         </article>
         
         <article class="function" data-name="bool">
            <h2>bool</h2>
            <hr />
            
            <pre><code>func bool() bool</code></pre>
         </article>
         
         <article class="function" data-name="save">
            <h2>save</h2>
            <hr />
            
            <pre><code>func save(*uint64, *uint64)</code></pre>
         </article>
         
         <article class="function" data-name="restore">
            <h2>restore</h2>
            <hr />
            
            <pre><code>func restore(uint64, uint64)</code></pre>
         </article>
         
         <article class="function" data-name="TestByteSliceMutators">
            <h2>TestByteSliceMutators</h2>
            <hr />
            
            <pre><code>func TestByteSliceMutators(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkByteSliceMutators">
            <h2>BenchmarkByteSliceMutators</h2>
            <hr />
            
            <pre><code>func BenchmarkByteSliceMutators(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="sharedMemMapFile">
            <h2>sharedMemMapFile</h2>
            <hr />
            
            <pre><code>func sharedMemMapFile(f *os.File, size int, removeOnClose bool) (*sharedMem, error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close unmaps the shared memory and closes the temporary file. If this
sharedMem was created with sharedMemTempFile, Close also removes the file.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="setWorkerComm">
            <h2>setWorkerComm</h2>
            <hr />
            
            <p>setWorkerComm configures communication channels on the cmd that will
run a worker process.</p>
            
            <pre><code>func setWorkerComm(cmd *exec.Cmd, comm workerComm)</code></pre>
         </article>
         
         <article class="function" data-name="getWorkerComm">
            <h2>getWorkerComm</h2>
            <hr />
            
            <p>getWorkerComm returns communication channels in the worker process.</p>
            
            <pre><code>func getWorkerComm() (comm workerComm, err error)</code></pre>
         </article>
         
         <article class="function" data-name="isInterruptError">
            <h2>isInterruptError</h2>
            <hr />
            
            <p>isInterruptError returns whether an error was returned by a process that
was terminated by an interrupt signal (SIGINT).</p>
            
            <pre><code>func isInterruptError(err error) bool</code></pre>
         </article>
         
         <article class="function" data-name="terminationSignal">
            <h2>terminationSignal</h2>
            <hr />
            
            <p>terminationSignal checks if err is an exec.ExitError with a signal status.
If it is, terminationSignal returns the signal and true.
If not, -1 and false.</p>
            
            <pre><code>func terminationSignal(err error) (os.Signal, bool)</code></pre>
         </article>
         
         <article class="function" data-name="isCrashSignal">
            <h2>isCrashSignal</h2>
            <hr />
            
            <p>isCrashSignal returns whether a signal was likely to have been caused by an
error in the program that received it, triggered by a fuzz input. For
example, SIGSEGV would be received after a nil pointer dereference.
Other signals like SIGKILL or SIGHUP are more likely to have been sent by
another process, and we shouldn't record a crasher if the worker process
receives one of these.

Note that Go installs its own signal handlers on startup, so some of these
signals may only be received if signal handlers are changed. For example,
SIGSEGV is normally transformed into a panic that causes the process to exit
with status 2 if not recovered, which we handle as a crash.</p>
            
            <pre><code>func isCrashSignal(signal os.Signal) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestMain">
            <h2>TestMain</h2>
            <hr />
            
            <pre><code>func TestMain(m *testing.M)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkWorkerFuzzOverhead">
            <h2>BenchmarkWorkerFuzzOverhead</h2>
            <hr />
            
            <pre><code>func BenchmarkWorkerFuzzOverhead(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkWorkerPing">
            <h2>BenchmarkWorkerPing</h2>
            <hr />
            
            <p>BenchmarkWorkerPing acts as the coordinator and measures the time it takes
a worker to respond to N pings. This is a rough measure of our RPC latency.</p>
            
            <pre><code>func BenchmarkWorkerPing(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkWorkerFuzz">
            <h2>BenchmarkWorkerFuzz</h2>
            <hr />
            
            <p>BenchmarkWorkerFuzz acts as the coordinator and measures the time it takes
a worker to mutate a given input and call a trivial fuzz function N times.</p>
            
            <pre><code>func BenchmarkWorkerFuzz(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="newWorkerForTest">
            <h2>newWorkerForTest</h2>
            <hr />
            
            <p>newWorkerForTest creates and starts a worker process for testing or
benchmarking. The worker process calls RunFuzzWorker, which responds to
RPC messages until it's stopped. The process is stopped and cleaned up
automatically when the test is done.</p>
            
            <pre><code>func newWorkerForTest(tb testing.TB) *worker</code></pre>
         </article>
         
         <article class="function" data-name="runBenchmarkWorker">
            <h2>runBenchmarkWorker</h2>
            <hr />
            
            <pre><code>func runBenchmarkWorker()</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkWorkerMinimize">
            <h2>BenchmarkWorkerMinimize</h2>
            <hr />
            
            <pre><code>func BenchmarkWorkerMinimize(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="coverage">
            <h2>coverage</h2>
            <hr />
            
            <p>coverage returns a []byte containing unique 8-bit counters for each edge of
the instrumented source code. This coverage data will only be generated if
`-d=libfuzzer` is set at build time. This can be used to understand the code
coverage of a test execution.</p>
            
            <pre><code>func coverage() []byte</code></pre>
         </article>
         
         <article class="function" data-name="coverage">
            <h2>coverage</h2>
            <hr />
            
            <p>coverage returns a []byte containing unique 8-bit counters for each edge of
the instrumented source code. This coverage data will only be generated if
`-d=libfuzzer` is set at build time. This can be used to understand the code
coverage of a test execution.</p>
            
            <pre><code>func coverage() []byte</code></pre>
         </article>
         
         <article class="function" data-name="CoordinateFuzzing">
            <h2>CoordinateFuzzing</h2>
            <hr />
            
            <p>CoordinateFuzzing creates several worker processes and communicates with
them to test random inputs that could trigger crashes and expose bugs.
The worker processes run the same binary in the same directory with the
same environment variables as the coordinator process. Workers also run
with the same arguments as the coordinator, except with the -test.fuzzworker
flag prepended to the argument list.

If a crash occurs, the function will return an error containing information
about the crash, which can be reported to the user.</p>
            
            <pre><code>func CoordinateFuzzing(ctx context.Context, opts CoordinateFuzzingOpts) err error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="CrashPath">
            <h2>CrashPath</h2>
            <hr />
            
            <pre><code>func CrashPath() string</code></pre>
         </article>
         
         <article class="function" data-name="addCorpusEntries">
            <h2>addCorpusEntries</h2>
            <hr />
            
            <p>addCorpusEntries adds entries to the corpus, and optionally writes the entries
to the cache directory. If an entry is already in the corpus it is skipped. If
all of the entries are unique, addCorpusEntries returns true and a nil error,
if at least one of the entries was a duplicate, it returns false and a nil error.</p>
            
            <pre><code>func addCorpusEntries(addToCache bool, entries ...CorpusEntry) (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="corpusEntryData">
            <h2>corpusEntryData</h2>
            <hr />
            
            <p>corpusEntryData returns the raw input bytes, either from the data struct
field, or from disk.</p>
            
            <pre><code>func corpusEntryData(ce CorpusEntry) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="newCoordinator">
            <h2>newCoordinator</h2>
            <hr />
            
            <pre><code>func newCoordinator(opts CoordinateFuzzingOpts) (*coordinator, error)</code></pre>
         </article>
         
         <article class="function" data-name="updateStats">
            <h2>updateStats</h2>
            <hr />
            
            <pre><code>func updateStats(result fuzzResult)</code></pre>
         </article>
         
         <article class="function" data-name="logStats">
            <h2>logStats</h2>
            <hr />
            
            <pre><code>func logStats()</code></pre>
         </article>
         
         <article class="function" data-name="peekInput">
            <h2>peekInput</h2>
            <hr />
            
            <p>peekInput returns the next value that should be sent to workers.
If the number of executions is limited, the returned value includes
a limit for one worker. If there are no executions left, peekInput returns
a zero value and false.

peekInput doesn't actually remove the input from the queue. The caller
must call sentInput after sending the input.

If the input queue is empty and the coverage/testing-only run has completed,
queue refills it from the corpus.</p>
            
            <pre><code>func peekInput() (fuzzInput, bool)</code></pre>
         </article>
         
         <article class="function" data-name="sentInput">
            <h2>sentInput</h2>
            <hr />
            
            <p>sentInput updates internal counters after an input is sent to c.inputC.</p>
            
            <pre><code>func sentInput(input fuzzInput)</code></pre>
         </article>
         
         <article class="function" data-name="refillInputQueue">
            <h2>refillInputQueue</h2>
            <hr />
            
            <p>refillInputQueue refills the input queue from the corpus after it becomes
empty.</p>
            
            <pre><code>func refillInputQueue()</code></pre>
         </article>
         
         <article class="function" data-name="queueForMinimization">
            <h2>queueForMinimization</h2>
            <hr />
            
            <p>queueForMinimization creates a fuzzMinimizeInput from result and adds it
to the minimization queue to be sent to workers.</p>
            
            <pre><code>func queueForMinimization(result fuzzResult, keepCoverage []byte)</code></pre>
         </article>
         
         <article class="function" data-name="peekMinimizeInput">
            <h2>peekMinimizeInput</h2>
            <hr />
            
            <p>peekMinimizeInput returns the next input that should be sent to workers for
minimization.</p>
            
            <pre><code>func peekMinimizeInput() (fuzzMinimizeInput, bool)</code></pre>
         </article>
         
         <article class="function" data-name="sentMinimizeInput">
            <h2>sentMinimizeInput</h2>
            <hr />
            
            <p>sentMinimizeInput removes an input from the minimization queue after it's
sent to minimizeC.</p>
            
            <pre><code>func sentMinimizeInput(input fuzzMinimizeInput)</code></pre>
         </article>
         
         <article class="function" data-name="warmupRun">
            <h2>warmupRun</h2>
            <hr />
            
            <p>warmupRun returns true while the coordinator is running inputs without
mutating them as a warmup before fuzzing. This could be to gather baseline
coverage data for entries in the corpus, or to test all of the seed corpus
for errors before fuzzing begins.

The coordinator doesn't store coverage data in the cache with each input
because that data would be invalid when counter offsets in the test binary
change.

When gathering coverage, the coordinator sends each entry to a worker to
gather coverage for that entry only, without fuzzing or minimizing. This
phase ends when all workers have finished, and the coordinator has a combined
coverage map.</p>
            
            <pre><code>func warmupRun() bool</code></pre>
         </article>
         
         <article class="function" data-name="updateCoverage">
            <h2>updateCoverage</h2>
            <hr />
            
            <p>updateCoverage sets bits in c.coverageMask that are set in newCoverage.
updateCoverage returns the number of newly set bits. See the comment on
coverageMask for the format.</p>
            
            <pre><code>func updateCoverage(newCoverage []byte) int</code></pre>
         </article>
         
         <article class="function" data-name="canMinimize">
            <h2>canMinimize</h2>
            <hr />
            
            <p>canMinimize returns whether the coordinator should attempt to find smaller
inputs that reproduce a crash or new coverage.</p>
            
            <pre><code>func canMinimize() bool</code></pre>
         </article>
         
         <article class="function" data-name="elapsed">
            <h2>elapsed</h2>
            <hr />
            
            <pre><code>func elapsed() time.Duration</code></pre>
         </article>
         
         <article class="function" data-name="readCache">
            <h2>readCache</h2>
            <hr />
            
            <p>readCache creates a combined corpus from seed values and values in the cache
(in GOCACHE/fuzz).

TODO(fuzzing): need a mechanism that can remove values that
aren't useful anymore, for example, because they have the wrong type.</p>
            
            <pre><code>func readCache() error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="ReadCorpus">
            <h2>ReadCorpus</h2>
            <hr />
            
            <p>ReadCorpus reads the corpus from the provided dir. The returned corpus
entries are guaranteed to match the given types. Any malformed files will
be saved in a MalformedCorpusError and returned, along with the most recent
error.</p>
            
            <pre><code>func ReadCorpus(dir string, types []reflect.Type) ([]CorpusEntry, error)</code></pre>
         </article>
         
         <article class="function" data-name="readCorpusData">
            <h2>readCorpusData</h2>
            <hr />
            
            <pre><code>func readCorpusData(data []byte, types []reflect.Type) ([]any, error)</code></pre>
         </article>
         
         <article class="function" data-name="CheckCorpus">
            <h2>CheckCorpus</h2>
            <hr />
            
            <p>CheckCorpus verifies that the types in vals match the expected types
provided.</p>
            
            <pre><code>func CheckCorpus(vals []any, types []reflect.Type) error</code></pre>
         </article>
         
         <article class="function" data-name="writeToCorpus">
            <h2>writeToCorpus</h2>
            <hr />
            
            <p>writeToCorpus atomically writes the given bytes to a new file in testdata. If
the directory does not exist, it will create one. If the file already exists,
writeToCorpus will not rewrite it. writeToCorpus sets entry.Path to the new
file that was just written or an error if it failed.</p>
            
            <pre><code>func writeToCorpus(entry *CorpusEntry, dir string) err error</code></pre>
         </article>
         
         <article class="function" data-name="testName">
            <h2>testName</h2>
            <hr />
            
            <pre><code>func testName(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="zeroValue">
            <h2>zeroValue</h2>
            <hr />
            
            <pre><code>func zeroValue(t reflect.Type) any</code></pre>
         </article>
         
         <article class="function" data-name="shouldPrintDebugInfo">
            <h2>shouldPrintDebugInfo</h2>
            <hr />
            
            <pre><code>func shouldPrintDebugInfo() bool</code></pre>
         </article>
         
         <article class="function" data-name="debugLogf">
            <h2>debugLogf</h2>
            <hr />
            
            <pre><code>func debugLogf(format string, args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="TestMinimizeInput">
            <h2>TestMinimizeInput</h2>
            <hr />
            
            <pre><code>func TestMinimizeInput(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMinimizeFlaky">
            <h2>TestMinimizeFlaky</h2>
            <hr />
            
            <p>TestMinimizeFlaky checks that if we're minimizing an interesting
input and a flaky failure occurs, that minimization was not indicated
to be successful, and the error isn't returned (since it's flaky).</p>
            
            <pre><code>func TestMinimizeFlaky(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkMutatorBytes">
            <h2>BenchmarkMutatorBytes</h2>
            <hr />
            
            <pre><code>func BenchmarkMutatorBytes(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkMutatorString">
            <h2>BenchmarkMutatorString</h2>
            <hr />
            
            <pre><code>func BenchmarkMutatorString(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkMutatorAllBasicTypes">
            <h2>BenchmarkMutatorAllBasicTypes</h2>
            <hr />
            
            <pre><code>func BenchmarkMutatorAllBasicTypes(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="TestStringImmutability">
            <h2>TestStringImmutability</h2>
            <hr />
            
            <pre><code>func TestStringImmutability(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="godebugSeed">
            <h2>godebugSeed</h2>
            <hr />
            
            <pre><code>func godebugSeed() *int</code></pre>
         </article>
         
         <article class="function" data-name="newPcgRand">
            <h2>newPcgRand</h2>
            <hr />
            
            <p>newPcgRand generates a new, seeded Rand, ready for use.</p>
            
            <pre><code>func newPcgRand() *pcgRand</code></pre>
         </article>
         
         <article class="function" data-name="step">
            <h2>step</h2>
            <hr />
            
            <pre><code>func step()</code></pre>
         </article>
         
         <article class="function" data-name="save">
            <h2>save</h2>
            <hr />
            
            <pre><code>func save(randState *uint64, randInc *uint64)</code></pre>
         </article>
         
         <article class="function" data-name="restore">
            <h2>restore</h2>
            <hr />
            
            <pre><code>func restore(randState uint64, randInc uint64)</code></pre>
         </article>
         
         <article class="function" data-name="uint32">
            <h2>uint32</h2>
            <hr />
            
            <p>uint32 returns a pseudo-random uint32.</p>
            
            <pre><code>func uint32() uint32</code></pre>
         </article>
         
         <article class="function" data-name="intn">
            <h2>intn</h2>
            <hr />
            
            <p>intn returns a pseudo-random number in [0, n).
n must fit in a uint32.</p>
            
            <pre><code>func intn(n int) int</code></pre>
         </article>
         
         <article class="function" data-name="uint32n">
            <h2>uint32n</h2>
            <hr />
            
            <p>uint32n returns a pseudo-random number in [0, n).

For implementation details, see:
https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction
https://lemire.me/blog/2016/06/30/fast-random-shuffling</p>
            
            <pre><code>func uint32n(n uint32) uint32</code></pre>
         </article>
         
         <article class="function" data-name="bool">
            <h2>bool</h2>
            <hr />
            
            <p>bool generates a random bool.</p>
            
            <pre><code>func bool() bool</code></pre>
         </article>
         
         <article class="function" data-name="Lock">
            <h2>Lock</h2>
            <hr />
            
            <p>Lock is a no-op used by -copylocks checker from `go vet`.</p>
            
            <pre><code>func Lock()</code></pre>
         </article>
         
         <article class="function" data-name="Unlock">
            <h2>Unlock</h2>
            <hr />
            
            <pre><code>func Unlock()</code></pre>
         </article>
         
         <article class="function" data-name="sharedMemMapFile">
            <h2>sharedMemMapFile</h2>
            <hr />
            
            <pre><code>func sharedMemMapFile(f *os.File, size int, removeOnClose bool) (mem *sharedMem, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close unmaps the shared memory and closes the temporary file. If this
sharedMem was created with sharedMemTempFile, Close also removes the file.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="setWorkerComm">
            <h2>setWorkerComm</h2>
            <hr />
            
            <p>setWorkerComm configures communication channels on the cmd that will
run a worker process.</p>
            
            <pre><code>func setWorkerComm(cmd *exec.Cmd, comm workerComm)</code></pre>
         </article>
         
         <article class="function" data-name="getWorkerComm">
            <h2>getWorkerComm</h2>
            <hr />
            
            <p>getWorkerComm returns communication channels in the worker process.</p>
            
            <pre><code>func getWorkerComm() (comm workerComm, err error)</code></pre>
         </article>
         
         <article class="function" data-name="isInterruptError">
            <h2>isInterruptError</h2>
            <hr />
            
            <pre><code>func isInterruptError(err error) bool</code></pre>
         </article>
         
         <article class="function" data-name="terminationSignal">
            <h2>terminationSignal</h2>
            <hr />
            
            <p>terminationSignal returns -1 and false because Windows doesn't have signals.</p>
            
            <pre><code>func terminationSignal(err error) (os.Signal, bool)</code></pre>
         </article>
         
         <article class="function" data-name="isCrashSignal">
            <h2>isCrashSignal</h2>
            <hr />
            
            <p>isCrashSignal is not implemented because Windows doesn't have signals.</p>
            
            <pre><code>func isCrashSignal(signal os.Signal) bool</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
