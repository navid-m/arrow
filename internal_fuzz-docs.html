<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - fuzz</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>fuzz</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"fmt"
"math/bits"
"fmt"
"os"
"os/exec"
"syscall"
"unsafe"
"bytes"
"context"
"crypto/sha256"
"errors"
"fmt"
"internal/godebug"
"io"
"math/bits"
"os"
"path/filepath"
"reflect"
"runtime"
"strings"
"time"
"bytes"
"fmt"
"os"
"unsafe"
"encoding/binary"
"fmt"
"math"
"unsafe"
_ "unsafe"
"bytes"
"context"
"crypto/sha256"
"encoding/json"
"errors"
"fmt"
"io"
"os"
"os/exec"
"reflect"
"runtime"
"sync"
"time"
"unsafe"
"reflect"
"math/bits"
"os"
"strconv"
"strings"
"sync/atomic"
"time"
"fmt"
"os"
"os/exec"
"syscall"
"os"
"os/exec"
"bytes"
"fmt"
"go/ast"
"go/parser"
"go/token"
"math"
"strconv"
"strings"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="_counters" data-name="_counters">
               <h3>
                  _counters 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_counters" class="anchor" title="Link to _counters">#</a>
               </h3>
               
                  <p class="doc-comment">_counters and _ecounters mark the start and end, respectively, of where
the 8-bit coverage counters reside in memory. They're known to cmd/link,
which specially assigns their addresses for this purpose.</p>
               
               <pre><code class="language-go">var _counters [0]byte</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_ecounters" data-name="_ecounters">
               <h3>
                  _ecounters 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_ecounters" class="anchor" title="Link to _ecounters">#</a>
               </h3>
               
                  <p class="doc-comment">_counters and _ecounters mark the start and end, respectively, of where
the 8-bit coverage counters reside in memory. They're known to cmd/link,
which specially assigns their addresses for this purpose.</p>
               
               <pre><code class="language-go">var _ecounters [0]byte</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="byteSliceMutators" data-name="byteSliceMutators">
               <h3>
                  byteSliceMutators 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#byteSliceMutators" class="anchor" title="Link to byteSliceMutators">#</a>
               </h3>
               
               <pre><code class="language-go">var byteSliceMutators = []byteSliceMutator{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="chainedMutations" data-name="chainedMutations">
               <h3>
                  chainedMutations 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#chainedMutations" class="anchor" title="Link to chainedMutations">#</a>
               </h3>
               
                  <p class="doc-comment">chainedMutations is how many mutations are applied before the worker
resets the input to its original state.
NOTE: this number was picked without much thought. It is low enough that
it seems to create a significant diversity in mutated inputs. We may want
to consider looking into this more closely once we have a proper performance
testing framework. Another option is to randomly pick the number of chained
mutations on each invocation of the workerServer.fuzz method (this appears to
be what libFuzzer does, although there seems to be no documentation which
explains why this choice was made.)</p>
               
               <pre><code class="language-go">const chainedMutations = 5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="coverageEnabled" data-name="coverageEnabled">
               <h3>
                  coverageEnabled 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#coverageEnabled" class="anchor" title="Link to coverageEnabled">#</a>
               </h3>
               
               <pre><code class="language-go">var coverageEnabled = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="coverageSnapshot" data-name="coverageSnapshot">
               <h3>
                  coverageSnapshot 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#coverageSnapshot" class="anchor" title="Link to coverageSnapshot">#</a>
               </h3>
               
               <pre><code class="language-go">var coverageSnapshot = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugInfo" data-name="debugInfo">
               <h3>
                  debugInfo 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#debugInfo" class="anchor" title="Link to debugInfo">#</a>
               </h3>
               
               <pre><code class="language-go">var debugInfo = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="encVersion1" data-name="encVersion1">
               <h3>
                  encVersion1 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#encVersion1" class="anchor" title="Link to encVersion1">#</a>
               </h3>
               
                  <p class="doc-comment">encVersion1 will be the first line of a file with version 1 encoding.</p>
               
               <pre><code class="language-go">var encVersion1 = "go test fuzz v1"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errSharedMemClosed" data-name="errSharedMemClosed">
               <h3>
                  errSharedMemClosed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errSharedMemClosed" class="anchor" title="Link to errSharedMemClosed">#</a>
               </h3>
               
                  <p class="doc-comment">errSharedMemClosed is returned by workerClient methods that cannot access
shared memory because it was closed and unmapped by another goroutine. That
can happen when worker.cleanup is called in the worker goroutine while a
workerClient.fuzz call runs concurrently.
This error should not be reported. It indicates the operation was
interrupted.</p>
               
               <pre><code class="language-go">var errSharedMemClosed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="globalInc" data-name="globalInc">
               <h3>
                  globalInc 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#globalInc" class="anchor" title="Link to globalInc">#</a>
               </h3>
               
               <pre><code class="language-go">var globalInc atomic.Uint64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="interesting16" data-name="interesting16">
               <h3>
                  interesting16 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#interesting16" class="anchor" title="Link to interesting16">#</a>
               </h3>
               
               <pre><code class="language-go">var interesting16 = []int16{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="interesting32" data-name="interesting32">
               <h3>
                  interesting32 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#interesting32" class="anchor" title="Link to interesting32">#</a>
               </h3>
               
               <pre><code class="language-go">var interesting32 = []int32{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="interesting8" data-name="interesting8">
               <h3>
                  interesting8 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#interesting8" class="anchor" title="Link to interesting8">#</a>
               </h3>
               
               <pre><code class="language-go">var interesting8 = []int8{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxInt" data-name="maxInt">
               <h3>
                  maxInt 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxInt" class="anchor" title="Link to maxInt">#</a>
               </h3>
               
               <pre><code class="language-go">const maxInt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxUint" data-name="maxUint">
               <h3>
                  maxUint 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxUint" class="anchor" title="Link to maxUint">#</a>
               </h3>
               
               <pre><code class="language-go">const maxUint = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="multiplier" data-name="multiplier">
               <h3>
                  multiplier 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#multiplier" class="anchor" title="Link to multiplier">#</a>
               </h3>
               
               <pre><code class="language-go">const multiplier uint64 = 6364136223846793005</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="workerExitCode" data-name="workerExitCode">
               <h3>
                  workerExitCode 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#workerExitCode" class="anchor" title="Link to workerExitCode">#</a>
               </h3>
               
                  <p class="doc-comment">workerExitCode is used as an exit code by fuzz worker processes after an internal error.
This distinguishes internal errors from uncontrolled panics and other crashes.
Keep in sync with internal/fuzz.workerExitCode.</p>
               
               <pre><code class="language-go">const workerExitCode = 70</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="workerFuzzDuration" data-name="workerFuzzDuration">
               <h3>
                  workerFuzzDuration 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#workerFuzzDuration" class="anchor" title="Link to workerFuzzDuration">#</a>
               </h3>
               
                  <p class="doc-comment">workerFuzzDuration is the amount of time a worker can spend testing random
variations of an input given by the coordinator.</p>
               
               <pre><code class="language-go">const workerFuzzDuration = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="workerSharedMemSize" data-name="workerSharedMemSize">
               <h3>
                  workerSharedMemSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#workerSharedMemSize" class="anchor" title="Link to workerSharedMemSize">#</a>
               </h3>
               
                  <p class="doc-comment">workerSharedMemSize is the maximum size of the shared memory file used to
communicate with workers. This limits the size of fuzz inputs.</p>
               
               <pre><code class="language-go">const workerSharedMemSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="workerTimeoutDuration" data-name="workerTimeoutDuration">
               <h3>
                  workerTimeoutDuration 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#workerTimeoutDuration" class="anchor" title="Link to workerTimeoutDuration">#</a>
               </h3>
               
                  <p class="doc-comment">workerTimeoutDuration is the amount of time a worker can go without
responding to the coordinator before being stopped.</p>
               
               <pre><code class="language-go">const workerTimeoutDuration = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="zeroVals" data-name="zeroVals">
               <h3>
                  zeroVals 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#zeroVals" class="anchor" title="Link to zeroVals">#</a>
               </h3>
               
               <pre><code class="language-go">var zeroVals []any = []any{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="byteSliceMutator" data-name="byteSliceMutator">
               <h3>
                  byteSliceMutator
                  <span class="badge type-badge">type</span>
                  <a href="#byteSliceMutator" class="anchor" title="Link to byteSliceMutator">#</a>
               </h3>
               
               <pre><code class="language-go">type byteSliceMutator func(*mutator, []byte) []byte</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="mutatorRand" data-name="mutatorRand">
               <h3>
                  mutatorRand
                  <span class="badge interface-badge">interface</span>
                  <a href="#mutatorRand" class="anchor" title="Link to mutatorRand">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type mutatorRand interface {
uint32() uint32
intn(int) int
uint32n(uint32) uint32
bool() bool
save(randState *uint64, randInc *uint64)
restore(randState uint64, randInc uint64)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="CoordinateFuzzingOpts" data-name="CoordinateFuzzingOpts">
               <h3>
                  CoordinateFuzzingOpts
                  <span class="badge">struct</span>
                  <a href="#CoordinateFuzzingOpts" class="anchor" title="Link to CoordinateFuzzingOpts">#</a>
               </h3>
               
               <p>CoordinateFuzzingOpts is a set of arguments for CoordinateFuzzing.
The zero value is valid for each field unless specified otherwise.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type CoordinateFuzzingOpts struct {
Log io.Writer
Timeout time.Duration
Limit int64
MinimizeTimeout time.Duration
MinimizeLimit int64
Parallel int
Seed []CorpusEntry
Types []reflect.Type
CorpusDir string
CacheDir string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="CorpusEntry" data-name="CorpusEntry">
               <h3>
                  CorpusEntry
                  <span class="badge">struct</span>
                  <a href="#CorpusEntry" class="anchor" title="Link to CorpusEntry">#</a>
               </h3>
               
               <p>CorpusEntry represents an individual input for fuzzing.
We must use an equivalent type in the testing and testing/internal/testdeps
packages, but testing can't import this package directly, and we don't want
to export this type from testing. Instead, we use the same struct type and
use a type alias (not a defined type) for convenience.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type CorpusEntry struct {
Parent string
Path string
Data []byte
Values []any
Generation int
IsSeed bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="MalformedCorpusError" data-name="MalformedCorpusError">
               <h3>
                  MalformedCorpusError
                  <span class="badge">struct</span>
                  <a href="#MalformedCorpusError" class="anchor" title="Link to MalformedCorpusError">#</a>
               </h3>
               
               <p>MalformedCorpusError is an error found while reading the corpus from the
filesystem. All of the errors are stored in the errs list. The testing
framework uses this to report malformed files in testdata.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type MalformedCorpusError struct {
errs []error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="call" data-name="call">
               <h3>
                  call
                  <span class="badge">struct</span>
                  <a href="#call" class="anchor" title="Link to call">#</a>
               </h3>
               
               <p>call is serialized and sent from the coordinator on fuzz_in. It acts as
a minimalist RPC mechanism. Exactly one of its fields must be set to indicate
which method to call.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type call struct {
Ping *pingArgs
Fuzz *fuzzArgs
Minimize *minimizeArgs
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="contextReader" data-name="contextReader">
               <h3>
                  contextReader
                  <span class="badge">struct</span>
                  <a href="#contextReader" class="anchor" title="Link to contextReader">#</a>
               </h3>
               
               <p>contextReader wraps a Reader with a Context. If the context is canceled
while the underlying reader is blocked, Read returns immediately.
This is useful for reading from a pipe. Closing a pipe file descriptor does
not unblock pending Reads on that file descriptor. All copies of the pipe's
other file descriptor (the write end) must be closed in all processes that
inherit it. This is difficult to do correctly in the situation we care about
(process group termination).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type contextReader struct {
ctx context.Context
r io.Reader
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="coordinator" data-name="coordinator">
               <h3>
                  coordinator
                  <span class="badge">struct</span>
                  <a href="#coordinator" class="anchor" title="Link to coordinator">#</a>
               </h3>
               
               <p>coordinator holds channels that workers can use to communicate with
the coordinator.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type coordinator struct {
opts CoordinateFuzzingOpts
startTime time.Time
inputC chan fuzzInput
minimizeC chan fuzzMinimizeInput
resultC chan fuzzResult
count int64
countLastLog int64
timeLastLog time.Time
interestingCount int
warmupInputCount int
warmupInputLeft int
duration time.Duration
countWaiting int64
corpus corpus
minimizationAllowed bool
inputQueue queue
minimizeQueue queue
crashMinimizing *fuzzResult
coverageMask []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="corpus" data-name="corpus">
               <h3>
                  corpus
                  <span class="badge">struct</span>
                  <a href="#corpus" class="anchor" title="Link to corpus">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type corpus struct {
entries []CorpusEntry
hashes map[[sha256.Size]byte]bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="crashError" data-name="crashError">
               <h3>
                  crashError
                  <span class="badge">struct</span>
                  <a href="#crashError" class="anchor" title="Link to crashError">#</a>
               </h3>
               
               <p>crashError wraps a crasher written to the seed corpus. It saves the name
of the file where the input causing the crasher was saved. The testing
framework uses this to report a command to re-run that specific input.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type crashError struct {
path string
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fuzzArgs" data-name="fuzzArgs">
               <h3>
                  fuzzArgs
                  <span class="badge">struct</span>
                  <a href="#fuzzArgs" class="anchor" title="Link to fuzzArgs">#</a>
               </h3>
               
               <p>fuzzArgs contains arguments to workerServer.fuzz. The value to fuzz is
passed in shared memory.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fuzzArgs struct {
Timeout time.Duration
Limit int64
Warmup bool
CoverageData []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fuzzInput" data-name="fuzzInput">
               <h3>
                  fuzzInput
                  <span class="badge">struct</span>
                  <a href="#fuzzInput" class="anchor" title="Link to fuzzInput">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fuzzInput struct {
entry CorpusEntry
timeout time.Duration
limit int64
warmup bool
coverageData []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fuzzMinimizeInput" data-name="fuzzMinimizeInput">
               <h3>
                  fuzzMinimizeInput
                  <span class="badge">struct</span>
                  <a href="#fuzzMinimizeInput" class="anchor" title="Link to fuzzMinimizeInput">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fuzzMinimizeInput struct {
entry CorpusEntry
crasherMsg string
limit int64
timeout time.Duration
keepCoverage []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fuzzResponse" data-name="fuzzResponse">
               <h3>
                  fuzzResponse
                  <span class="badge">struct</span>
                  <a href="#fuzzResponse" class="anchor" title="Link to fuzzResponse">#</a>
               </h3>
               
               <p>fuzzResponse contains results from workerServer.fuzz.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fuzzResponse struct {
TotalDuration time.Duration
InterestingDuration time.Duration
Count int64
CoverageData []byte
Err string
InternalErr string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fuzzResult" data-name="fuzzResult">
               <h3>
                  fuzzResult
                  <span class="badge">struct</span>
                  <a href="#fuzzResult" class="anchor" title="Link to fuzzResult">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fuzzResult struct {
entry CorpusEntry
crasherMsg string
canMinimize bool
coverageData []byte
limit int64
count int64
totalDuration time.Duration
entryDuration time.Duration
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="minimizeArgs" data-name="minimizeArgs">
               <h3>
                  minimizeArgs
                  <span class="badge">struct</span>
                  <a href="#minimizeArgs" class="anchor" title="Link to minimizeArgs">#</a>
               </h3>
               
               <p>minimizeArgs contains arguments to workerServer.minimize. The value to
minimize is already in shared memory.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type minimizeArgs struct {
Timeout time.Duration
Limit int64
KeepCoverage []byte
Index int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="minimizeResponse" data-name="minimizeResponse">
               <h3>
                  minimizeResponse
                  <span class="badge">struct</span>
                  <a href="#minimizeResponse" class="anchor" title="Link to minimizeResponse">#</a>
               </h3>
               
               <p>minimizeResponse contains results from workerServer.minimize.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type minimizeResponse struct {
WroteToMem bool
Err string
CoverageData []byte
Duration time.Duration
Count int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="mutator" data-name="mutator">
               <h3>
                  mutator
                  <span class="badge">struct</span>
                  <a href="#mutator" class="anchor" title="Link to mutator">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type mutator struct {
r mutatorRand
scratch []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="noCopy" data-name="noCopy">
               <h3>
                  noCopy
                  <span class="badge">struct</span>
                  <a href="#noCopy" class="anchor" title="Link to noCopy">#</a>
               </h3>
               
               <p>noCopy may be embedded into structs which must not be copied
after the first use.
See https://golang.org/issues/8005#issuecomment-190753527
for details.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type noCopy struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pcgRand" data-name="pcgRand">
               <h3>
                  pcgRand
                  <span class="badge">struct</span>
                  <a href="#pcgRand" class="anchor" title="Link to pcgRand">#</a>
               </h3>
               
               <p>pcgRand is a PRNG. It should not be copied or shared. No Rand methods are
concurrency safe.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type pcgRand struct {
noCopy noCopy
state uint64
inc uint64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pingArgs" data-name="pingArgs">
               <h3>
                  pingArgs
                  <span class="badge">struct</span>
                  <a href="#pingArgs" class="anchor" title="Link to pingArgs">#</a>
               </h3>
               
               <p>pingArgs contains arguments to workerServer.ping.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type pingArgs struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pingResponse" data-name="pingResponse">
               <h3>
                  pingResponse
                  <span class="badge">struct</span>
                  <a href="#pingResponse" class="anchor" title="Link to pingResponse">#</a>
               </h3>
               
               <p>pingResponse contains results from workerServer.ping.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type pingResponse struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="queue" data-name="queue">
               <h3>
                  queue
                  <span class="badge">struct</span>
                  <a href="#queue" class="anchor" title="Link to queue">#</a>
               </h3>
               
               <p>queue holds a growable sequence of inputs for fuzzing and minimization.
For now, this is a simple ring buffer
(https://en.wikipedia.org/wiki/Circular_buffer).
TODO(golang.org/issue/46224): use a prioritization algorithm based on input
size, previous duration, coverage, and any other metrics that seem useful.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type queue struct {
elems []any
head int
len int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sharedMem" data-name="sharedMem">
               <h3>
                  sharedMem
                  <span class="badge">struct</span>
                  <a href="#sharedMem" class="anchor" title="Link to sharedMem">#</a>
               </h3>
               
               <p>sharedMem manages access to a region of virtual memory mapped from a file,
shared between multiple processes. The region includes space for a header and
a value of variable length.
When fuzzing, the coordinator creates a sharedMem from a temporary file for
each worker. This buffer is used to pass values to fuzz between processes.
Care must be taken to manage access to shared memory across processes;
sharedMem provides no synchronization on its own. See workerComm for an
explanation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type sharedMem struct {
f *os.File
region []byte
removeOnClose bool
sys sharedMemSys
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sharedMemHeader" data-name="sharedMemHeader">
               <h3>
                  sharedMemHeader
                  <span class="badge">struct</span>
                  <a href="#sharedMemHeader" class="anchor" title="Link to sharedMemHeader">#</a>
               </h3>
               
               <p>sharedMemHeader stores metadata in shared memory.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type sharedMemHeader struct {
count int64
valueLen int
randState uint64
randInc uint64
rawInMem bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sharedMemSys" data-name="sharedMemSys">
               <h3>
                  sharedMemSys
                  <span class="badge">struct</span>
                  <a href="#sharedMemSys" class="anchor" title="Link to sharedMemSys">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type sharedMemSys struct {
mapObj syscall.Handle
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sharedMemSys" data-name="sharedMemSys">
               <h3>
                  sharedMemSys
                  <span class="badge">struct</span>
                  <a href="#sharedMemSys" class="anchor" title="Link to sharedMemSys">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type sharedMemSys struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sharedMemSys" data-name="sharedMemSys">
               <h3>
                  sharedMemSys
                  <span class="badge">struct</span>
                  <a href="#sharedMemSys" class="anchor" title="Link to sharedMemSys">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type sharedMemSys struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="worker" data-name="worker">
               <h3>
                  worker
                  <span class="badge">struct</span>
                  <a href="#worker" class="anchor" title="Link to worker">#</a>
               </h3>
               
               <p>worker manages a worker process running a test binary. The worker object
exists only in the coordinator (the process started by 'go test -fuzz').
workerClient is used by the coordinator to send RPCs to the worker process,
which handles them with workerServer.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type worker struct {
dir string
binPath string
args []string
env []string
coordinator *coordinator
memMu chan *sharedMem
cmd *exec.Cmd
client *workerClient
waitErr error
interrupted bool
termC chan struct{...}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="workerClient" data-name="workerClient">
               <h3>
                  workerClient
                  <span class="badge">struct</span>
                  <a href="#workerClient" class="anchor" title="Link to workerClient">#</a>
               </h3>
               
               <p>workerClient is a minimalist RPC client. The coordinator process uses a
workerClient to call methods in each worker process (handled by
workerServer).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type workerClient struct {
workerComm
m *mutator
mu sync.Mutex
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="workerComm" data-name="workerComm">
               <h3>
                  workerComm
                  <span class="badge">struct</span>
                  <a href="#workerComm" class="anchor" title="Link to workerComm">#</a>
               </h3>
               
               <p>workerComm holds pipes and shared memory used for communication
between the coordinator process (client) and a worker process (server).
These values are unique to each worker; they are shared only with the
coordinator, not with other workers.
Access to shared memory is synchronized implicitly over the RPC protocol
implemented in workerServer and workerClient. During a call, the client
(worker) has exclusive access to shared memory; at other times, the server
(coordinator) has exclusive access.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type workerComm struct {
fuzzIn *os.File
fuzzOut *os.File
memMu chan *sharedMem
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="workerServer" data-name="workerServer">
               <h3>
                  workerServer
                  <span class="badge">struct</span>
                  <a href="#workerServer" class="anchor" title="Link to workerServer">#</a>
               </h3>
               
               <p>workerServer is a minimalist RPC server, run by fuzz worker processes.
It allows the coordinator process (using workerClient) to call methods in a
worker process. This system allows the coordinator to run multiple worker
processes in parallel and to collect inputs that caused crashes from shared
memory after a worker process terminates unexpectedly.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type workerServer struct {
workerComm
m *mutator
coverageMask []byte
fuzzFn func(CorpusEntry) (time.Duration, error)
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="CheckCorpus" data-name="CheckCorpus">
               <h3>
                  CheckCorpus 
                  <span class="badge">function</span>
                  
                  <a href="#CheckCorpus" class="anchor" title="Link to CheckCorpus">#</a>
               </h3>
               
               <p>CheckCorpus verifies that the types in vals match the expected types
provided.</p>
               
               <pre><code class="language-go">func CheckCorpus(vals []any, types []reflect.Type) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close unmaps the shared memory and closes the temporary file. If this
sharedMem was created with sharedMemTempFile, Close also removes the file.</p>
               
               <pre><code class="language-go">func (m *sharedMem) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close unmaps the shared memory and closes the temporary file. If this
sharedMem was created with sharedMemTempFile, Close also removes the file.</p>
               
               <pre><code class="language-go">func (m *sharedMem) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *sharedMem) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close shuts down the connection to the RPC server (the worker process) by
closing fuzz_in. Close drains fuzz_out (avoiding a SIGPIPE in the worker),
and closes it after the worker process closes the other end.</p>
               
               <pre><code class="language-go">func (wc *workerClient) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CoordinateFuzzing" data-name="CoordinateFuzzing">
               <h3>
                  CoordinateFuzzing 
                  <span class="badge">function</span>
                  
                  <a href="#CoordinateFuzzing" class="anchor" title="Link to CoordinateFuzzing">#</a>
               </h3>
               
               <p>CoordinateFuzzing creates several worker processes and communicates with
them to test random inputs that could trigger crashes and expose bugs.
The worker processes run the same binary in the same directory with the
same environment variables as the coordinator process. Workers also run
with the same arguments as the coordinator, except with the -test.fuzzworker
flag prepended to the argument list.
If a crash occurs, the function will return an error containing information
about the crash, which can be reported to the user.</p>
               
               <pre><code class="language-go">func CoordinateFuzzing(ctx context.Context, opts CoordinateFuzzingOpts) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CrashPath" data-name="CrashPath">
               <h3>
                  CrashPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CrashPath" class="anchor" title="Link to CrashPath">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *crashError) CrashPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *MalformedCorpusError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *crashError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lock" data-name="Lock">
               <h3>
                  Lock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lock" class="anchor" title="Link to Lock">#</a>
               </h3>
               
               <p>Lock is a no-op used by -copylocks checker from `go vet`.</p>
               
               <pre><code class="language-go">func (*noCopy) Lock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code class="language-go">func (cr *contextReader) Read(b []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadCorpus" data-name="ReadCorpus">
               <h3>
                  ReadCorpus 
                  <span class="badge">function</span>
                  
                  <a href="#ReadCorpus" class="anchor" title="Link to ReadCorpus">#</a>
               </h3>
               
               <p>ReadCorpus reads the corpus from the provided dir. The returned corpus
entries are guaranteed to match the given types. Any malformed files will
be saved in a MalformedCorpusError and returned, along with the most recent
error.</p>
               
               <pre><code class="language-go">func ReadCorpus(dir string, types []reflect.Type) ([]CorpusEntry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ResetCoverage" data-name="ResetCoverage">
               <h3>
                  ResetCoverage 
                  <span class="badge">function</span>
                  
                  <a href="#ResetCoverage" class="anchor" title="Link to ResetCoverage">#</a>
               </h3>
               
               <p>ResetCoverage sets all of the counters for each edge of the instrumented
source code to 0.</p>
               
               <pre><code class="language-go">func ResetCoverage()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RunFuzzWorker" data-name="RunFuzzWorker">
               <h3>
                  RunFuzzWorker 
                  <span class="badge">function</span>
                  
                  <a href="#RunFuzzWorker" class="anchor" title="Link to RunFuzzWorker">#</a>
               </h3>
               
               <p>RunFuzzWorker is called in a worker process to communicate with the
coordinator process in order to fuzz random inputs. RunFuzzWorker loops
until the coordinator tells it to stop.
fn is a wrapper on the fuzz function. It may return an error to indicate
a given input "crashed". The coordinator will also record a crasher if
the function times out or terminates the process.
RunFuzzWorker returns an error if it could not communicate with the
coordinator process.</p>
               
               <pre><code class="language-go">func RunFuzzWorker(ctx context.Context, fn func(CorpusEntry) error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SnapshotCoverage" data-name="SnapshotCoverage">
               <h3>
                  SnapshotCoverage 
                  <span class="badge">function</span>
                  
                  <a href="#SnapshotCoverage" class="anchor" title="Link to SnapshotCoverage">#</a>
               </h3>
               
               <p>SnapshotCoverage copies the current counter values into coverageSnapshot,
preserving them for later inspection. SnapshotCoverage also rounds each
counter down to the nearest power of two. This lets the coordinator store
multiple values for each counter by OR'ing them together.</p>
               
               <pre><code class="language-go">func SnapshotCoverage()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unlock" data-name="Unlock">
               <h3>
                  Unlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unlock" class="anchor" title="Link to Unlock">#</a>
               </h3>
               
               <pre><code class="language-go">func (*noCopy) Unlock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *crashError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addCorpusEntries" data-name="addCorpusEntries">
               <h3>
                  addCorpusEntries 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addCorpusEntries" class="anchor" title="Link to addCorpusEntries">#</a>
               </h3>
               
               <p>addCorpusEntries adds entries to the corpus, and optionally writes the entries
to the cache directory. If an entry is already in the corpus it is skipped. If
all of the entries are unique, addCorpusEntries returns true and a nil error,
if at least one of the entries was a duplicate, it returns false and a nil error.</p>
               
               <pre><code class="language-go">func (c *coordinator) addCorpusEntries(addToCache bool, entries ...CorpusEntry) (bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bool" data-name="bool">
               <h3>
                  bool 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bool" class="anchor" title="Link to bool">#</a>
               </h3>
               
               <p>bool generates a random bool.</p>
               
               <pre><code class="language-go">func (r *pcgRand) bool() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceArithmeticUint16" data-name="byteSliceArithmeticUint16">
               <h3>
                  byteSliceArithmeticUint16 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceArithmeticUint16" class="anchor" title="Link to byteSliceArithmeticUint16">#</a>
               </h3>
               
               <p>byteSliceArithmeticUint16 adds/subtracts from a random uint16 in b.</p>
               
               <pre><code class="language-go">func byteSliceArithmeticUint16(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceArithmeticUint32" data-name="byteSliceArithmeticUint32">
               <h3>
                  byteSliceArithmeticUint32 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceArithmeticUint32" class="anchor" title="Link to byteSliceArithmeticUint32">#</a>
               </h3>
               
               <p>byteSliceArithmeticUint32 adds/subtracts from a random uint32 in b.</p>
               
               <pre><code class="language-go">func byteSliceArithmeticUint32(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceArithmeticUint64" data-name="byteSliceArithmeticUint64">
               <h3>
                  byteSliceArithmeticUint64 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceArithmeticUint64" class="anchor" title="Link to byteSliceArithmeticUint64">#</a>
               </h3>
               
               <p>byteSliceArithmeticUint64 adds/subtracts from a random uint64 in b.</p>
               
               <pre><code class="language-go">func byteSliceArithmeticUint64(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceArithmeticUint8" data-name="byteSliceArithmeticUint8">
               <h3>
                  byteSliceArithmeticUint8 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceArithmeticUint8" class="anchor" title="Link to byteSliceArithmeticUint8">#</a>
               </h3>
               
               <p>byteSliceArithmeticUint8 adds/subtracts from a random byte in b.</p>
               
               <pre><code class="language-go">func byteSliceArithmeticUint8(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceBitFlip" data-name="byteSliceBitFlip">
               <h3>
                  byteSliceBitFlip 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceBitFlip" class="anchor" title="Link to byteSliceBitFlip">#</a>
               </h3>
               
               <p>byteSliceBitFlip flips a random bit in a random byte in b.</p>
               
               <pre><code class="language-go">func byteSliceBitFlip(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceDuplicateBytes" data-name="byteSliceDuplicateBytes">
               <h3>
                  byteSliceDuplicateBytes 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceDuplicateBytes" class="anchor" title="Link to byteSliceDuplicateBytes">#</a>
               </h3>
               
               <p>byteSliceDuplicateBytes duplicates a chunk of bytes in b and inserts it into
a random position.</p>
               
               <pre><code class="language-go">func byteSliceDuplicateBytes(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceInsertConstantBytes" data-name="byteSliceInsertConstantBytes">
               <h3>
                  byteSliceInsertConstantBytes 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceInsertConstantBytes" class="anchor" title="Link to byteSliceInsertConstantBytes">#</a>
               </h3>
               
               <p>byteSliceInsertConstantBytes inserts a chunk of constant bytes into a random position in b.</p>
               
               <pre><code class="language-go">func byteSliceInsertConstantBytes(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceInsertRandomBytes" data-name="byteSliceInsertRandomBytes">
               <h3>
                  byteSliceInsertRandomBytes 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceInsertRandomBytes" class="anchor" title="Link to byteSliceInsertRandomBytes">#</a>
               </h3>
               
               <p>byteSliceInsertRandomBytes inserts a chunk of random bytes into b at a random
position.</p>
               
               <pre><code class="language-go">func byteSliceInsertRandomBytes(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceOverwriteBytes" data-name="byteSliceOverwriteBytes">
               <h3>
                  byteSliceOverwriteBytes 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceOverwriteBytes" class="anchor" title="Link to byteSliceOverwriteBytes">#</a>
               </h3>
               
               <p>byteSliceOverwriteBytes overwrites a chunk of b with another chunk of b.</p>
               
               <pre><code class="language-go">func byteSliceOverwriteBytes(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceOverwriteConstantBytes" data-name="byteSliceOverwriteConstantBytes">
               <h3>
                  byteSliceOverwriteConstantBytes 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceOverwriteConstantBytes" class="anchor" title="Link to byteSliceOverwriteConstantBytes">#</a>
               </h3>
               
               <p>byteSliceOverwriteConstantBytes overwrites a chunk of b with constant bytes.</p>
               
               <pre><code class="language-go">func byteSliceOverwriteConstantBytes(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceOverwriteInterestingUint16" data-name="byteSliceOverwriteInterestingUint16">
               <h3>
                  byteSliceOverwriteInterestingUint16 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceOverwriteInterestingUint16" class="anchor" title="Link to byteSliceOverwriteInterestingUint16">#</a>
               </h3>
               
               <p>byteSliceOverwriteInterestingUint16 overwrites a random uint16 in b with an interesting
value.</p>
               
               <pre><code class="language-go">func byteSliceOverwriteInterestingUint16(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceOverwriteInterestingUint32" data-name="byteSliceOverwriteInterestingUint32">
               <h3>
                  byteSliceOverwriteInterestingUint32 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceOverwriteInterestingUint32" class="anchor" title="Link to byteSliceOverwriteInterestingUint32">#</a>
               </h3>
               
               <p>byteSliceOverwriteInterestingUint32 overwrites a random uint16 in b with an interesting
value.</p>
               
               <pre><code class="language-go">func byteSliceOverwriteInterestingUint32(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceOverwriteInterestingUint8" data-name="byteSliceOverwriteInterestingUint8">
               <h3>
                  byteSliceOverwriteInterestingUint8 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceOverwriteInterestingUint8" class="anchor" title="Link to byteSliceOverwriteInterestingUint8">#</a>
               </h3>
               
               <p>byteSliceOverwriteInterestingUint8 overwrites a random byte in b with an interesting
value.</p>
               
               <pre><code class="language-go">func byteSliceOverwriteInterestingUint8(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceRemoveBytes" data-name="byteSliceRemoveBytes">
               <h3>
                  byteSliceRemoveBytes 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceRemoveBytes" class="anchor" title="Link to byteSliceRemoveBytes">#</a>
               </h3>
               
               <p>byteSliceRemoveBytes removes a random chunk of bytes from b.</p>
               
               <pre><code class="language-go">func byteSliceRemoveBytes(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceShuffleBytes" data-name="byteSliceShuffleBytes">
               <h3>
                  byteSliceShuffleBytes 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceShuffleBytes" class="anchor" title="Link to byteSliceShuffleBytes">#</a>
               </h3>
               
               <p>byteSliceShuffleBytes shuffles a chunk of bytes in b.</p>
               
               <pre><code class="language-go">func byteSliceShuffleBytes(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceSwapByte" data-name="byteSliceSwapByte">
               <h3>
                  byteSliceSwapByte 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceSwapByte" class="anchor" title="Link to byteSliceSwapByte">#</a>
               </h3>
               
               <p>byteSliceSwapByte swaps two random bytes in b.</p>
               
               <pre><code class="language-go">func byteSliceSwapByte(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceSwapBytes" data-name="byteSliceSwapBytes">
               <h3>
                  byteSliceSwapBytes 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceSwapBytes" class="anchor" title="Link to byteSliceSwapBytes">#</a>
               </h3>
               
               <p>byteSliceSwapBytes swaps two chunks of bytes in b.</p>
               
               <pre><code class="language-go">func byteSliceSwapBytes(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteSliceXORByte" data-name="byteSliceXORByte">
               <h3>
                  byteSliceXORByte 
                  <span class="badge">function</span>
                  
                  <a href="#byteSliceXORByte" class="anchor" title="Link to byteSliceXORByte">#</a>
               </h3>
               
               <p>byteSliceXORByte XORs a random byte in b with a random value.</p>
               
               <pre><code class="language-go">func byteSliceXORByte(m *mutator, b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="callLocked" data-name="callLocked">
               <h3>
                  callLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#callLocked" class="anchor" title="Link to callLocked">#</a>
               </h3>
               
               <p>callLocked sends an RPC from the coordinator to the worker process and waits
for the response. The callLocked may be canceled with ctx.</p>
               
               <pre><code class="language-go">func (wc *workerClient) callLocked(ctx context.Context, c call, resp any) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canMinimize" data-name="canMinimize">
               <h3>
                  canMinimize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#canMinimize" class="anchor" title="Link to canMinimize">#</a>
               </h3>
               
               <p>canMinimize returns whether the coordinator should attempt to find smaller
inputs that reproduce a crash or new coverage.</p>
               
               <pre><code class="language-go">func (c *coordinator) canMinimize() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cap" data-name="cap">
               <h3>
                  cap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cap" class="anchor" title="Link to cap">#</a>
               </h3>
               
               <pre><code class="language-go">func (q *queue) cap() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chooseLen" data-name="chooseLen">
               <h3>
                  chooseLen 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#chooseLen" class="anchor" title="Link to chooseLen">#</a>
               </h3>
               
               <p>chooseLen chooses length of range mutation in range [1,n]. It gives
preference to shorter ranges.</p>
               
               <pre><code class="language-go">func (m *mutator) chooseLen(n int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanup" data-name="cleanup">
               <h3>
                  cleanup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cleanup" class="anchor" title="Link to cleanup">#</a>
               </h3>
               
               <p>cleanup releases persistent resources associated with the worker.</p>
               
               <pre><code class="language-go">func (w *worker) cleanup() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clear" data-name="clear">
               <h3>
                  clear 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#clear" class="anchor" title="Link to clear">#</a>
               </h3>
               
               <pre><code class="language-go">func (q *queue) clear()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="coordinate" data-name="coordinate">
               <h3>
                  coordinate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#coordinate" class="anchor" title="Link to coordinate">#</a>
               </h3>
               
               <p>coordinate runs the test binary to perform fuzzing.
coordinate loops until ctx is canceled or a fatal error is encountered.
If a test process terminates unexpectedly while fuzzing, coordinate will
attempt to restart and continue unless the termination can be attributed
to an interruption (from a timer or the user).
While looping, coordinate receives inputs from the coordinator, passes
those inputs to the worker process, then passes the results back to
the coordinator.</p>
               
               <pre><code class="language-go">func (w *worker) coordinate(ctx context.Context) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="corpusEntryData" data-name="corpusEntryData">
               <h3>
                  corpusEntryData 
                  <span class="badge">function</span>
                  
                  <a href="#corpusEntryData" class="anchor" title="Link to corpusEntryData">#</a>
               </h3>
               
               <p>corpusEntryData returns the raw input bytes, either from the data struct
field, or from disk.</p>
               
               <pre><code class="language-go">func corpusEntryData(ce CorpusEntry) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="countBits" data-name="countBits">
               <h3>
                  countBits 
                  <span class="badge">function</span>
                  
                  <a href="#countBits" class="anchor" title="Link to countBits">#</a>
               </h3>
               
               <pre><code class="language-go">func countBits(cov []byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="countNewCoverageBits" data-name="countNewCoverageBits">
               <h3>
                  countNewCoverageBits 
                  <span class="badge">function</span>
                  
                  <a href="#countNewCoverageBits" class="anchor" title="Link to countNewCoverageBits">#</a>
               </h3>
               
               <p>countNewCoverageBits returns the number of bits set in snapshot that are not
set in base.</p>
               
               <pre><code class="language-go">func countNewCoverageBits(base []byte, snapshot []byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="coverage" data-name="coverage">
               <h3>
                  coverage 
                  <span class="badge">function</span>
                  
                  <a href="#coverage" class="anchor" title="Link to coverage">#</a>
               </h3>
               
               <p>coverage returns a []byte containing unique 8-bit counters for each edge of
the instrumented source code. This coverage data will only be generated if
`-d=libfuzzer` is set at build time. This can be used to understand the code
coverage of a test execution.</p>
               
               <pre><code class="language-go">func coverage() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="coverage" data-name="coverage">
               <h3>
                  coverage 
                  <span class="badge">function</span>
                  
                  <a href="#coverage" class="anchor" title="Link to coverage">#</a>
               </h3>
               
               <p>coverage returns a []byte containing unique 8-bit counters for each edge of
the instrumented source code. This coverage data will only be generated if
`-d=libfuzzer` is set at build time. This can be used to understand the code
coverage of a test execution.</p>
               
               <pre><code class="language-go">func coverage() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="debugLogf" data-name="debugLogf">
               <h3>
                  debugLogf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#debugLogf" class="anchor" title="Link to debugLogf">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *coordinator) debugLogf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dequeue" data-name="dequeue">
               <h3>
                  dequeue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dequeue" class="anchor" title="Link to dequeue">#</a>
               </h3>
               
               <pre><code class="language-go">func (q *queue) dequeue() (any, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="diffCoverage" data-name="diffCoverage">
               <h3>
                  diffCoverage 
                  <span class="badge">function</span>
                  
                  <a href="#diffCoverage" class="anchor" title="Link to diffCoverage">#</a>
               </h3>
               
               <p>diffCoverage returns a set of bits set in snapshot but not in base.
If there are no new bits set, diffCoverage returns nil.</p>
               
               <pre><code class="language-go">func diffCoverage(base []byte, snapshot []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="elapsed" data-name="elapsed">
               <h3>
                  elapsed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#elapsed" class="anchor" title="Link to elapsed">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *coordinator) elapsed() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="enqueue" data-name="enqueue">
               <h3>
                  enqueue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#enqueue" class="anchor" title="Link to enqueue">#</a>
               </h3>
               
               <pre><code class="language-go">func (q *queue) enqueue(e any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fuzz" data-name="fuzz">
               <h3>
                  fuzz 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fuzz" class="anchor" title="Link to fuzz">#</a>
               </h3>
               
               <p>fuzz runs the test function on random variations of the input value in shared
memory for a limited duration or number of iterations.
fuzz returns early if it finds an input that crashes the fuzz function (with
fuzzResponse.Err set) or an input that expands coverage (with
fuzzResponse.InterestingDuration set).
fuzz does not modify the input in shared memory. Instead, it saves the
initial PRNG state in shared memory and increments a counter in shared
memory before each call to the test function. The caller may reconstruct
the crashing input with this information, since the PRNG is deterministic.</p>
               
               <pre><code class="language-go">func (ws *workerServer) fuzz(ctx context.Context, args fuzzArgs) (resp fuzzResponse)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fuzz" data-name="fuzz">
               <h3>
                  fuzz 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fuzz" class="anchor" title="Link to fuzz">#</a>
               </h3>
               
               <p>fuzz tells the worker to call the fuzz method. See workerServer.fuzz.</p>
               
               <pre><code class="language-go">func (wc *workerClient) fuzz(ctx context.Context, entryIn CorpusEntry, args fuzzArgs) (entryOut CorpusEntry, resp fuzzResponse, isInternalError bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getWorkerComm" data-name="getWorkerComm">
               <h3>
                  getWorkerComm 
                  <span class="badge">function</span>
                  
                  <a href="#getWorkerComm" class="anchor" title="Link to getWorkerComm">#</a>
               </h3>
               
               <p>getWorkerComm returns communication channels in the worker process.</p>
               
               <pre><code class="language-go">func getWorkerComm() (comm workerComm, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getWorkerComm" data-name="getWorkerComm">
               <h3>
                  getWorkerComm 
                  <span class="badge">function</span>
                  
                  <a href="#getWorkerComm" class="anchor" title="Link to getWorkerComm">#</a>
               </h3>
               
               <p>getWorkerComm returns communication channels in the worker process.</p>
               
               <pre><code class="language-go">func getWorkerComm() (comm workerComm, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getWorkerComm" data-name="getWorkerComm">
               <h3>
                  getWorkerComm 
                  <span class="badge">function</span>
                  
                  <a href="#getWorkerComm" class="anchor" title="Link to getWorkerComm">#</a>
               </h3>
               
               <pre><code class="language-go">func getWorkerComm() (comm workerComm, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="godebugSeed" data-name="godebugSeed">
               <h3>
                  godebugSeed 
                  <span class="badge">function</span>
                  
                  <a href="#godebugSeed" class="anchor" title="Link to godebugSeed">#</a>
               </h3>
               
               <pre><code class="language-go">func godebugSeed() *int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="grow" data-name="grow">
               <h3>
                  grow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#grow" class="anchor" title="Link to grow">#</a>
               </h3>
               
               <pre><code class="language-go">func (q *queue) grow()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasCoverageBit" data-name="hasCoverageBit">
               <h3>
                  hasCoverageBit 
                  <span class="badge">function</span>
                  
                  <a href="#hasCoverageBit" class="anchor" title="Link to hasCoverageBit">#</a>
               </h3>
               
               <p>hasCoverageBit returns true if snapshot has at least one bit set that is
also set in base.</p>
               
               <pre><code class="language-go">func hasCoverageBit(base []byte, snapshot []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="header" data-name="header">
               <h3>
                  header 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#header" class="anchor" title="Link to header">#</a>
               </h3>
               
               <p>header returns a pointer to metadata within the shared memory region.</p>
               
               <pre><code class="language-go">func (m *sharedMem) header() *sharedMemHeader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="intn" data-name="intn">
               <h3>
                  intn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#intn" class="anchor" title="Link to intn">#</a>
               </h3>
               
               <p>intn returns a pseudo-random number in [0, n).
n must fit in a uint32.</p>
               
               <pre><code class="language-go">func (r *pcgRand) intn(n int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isCoverageSubset" data-name="isCoverageSubset">
               <h3>
                  isCoverageSubset 
                  <span class="badge">function</span>
                  
                  <a href="#isCoverageSubset" class="anchor" title="Link to isCoverageSubset">#</a>
               </h3>
               
               <p>isCoverageSubset returns true if all the base coverage bits are set in
snapshot.</p>
               
               <pre><code class="language-go">func isCoverageSubset(base []byte, snapshot []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isCrashSignal" data-name="isCrashSignal">
               <h3>
                  isCrashSignal 
                  <span class="badge">function</span>
                  
                  <a href="#isCrashSignal" class="anchor" title="Link to isCrashSignal">#</a>
               </h3>
               
               <p>isCrashSignal returns whether a signal was likely to have been caused by an
error in the program that received it, triggered by a fuzz input. For
example, SIGSEGV would be received after a nil pointer dereference.
Other signals like SIGKILL or SIGHUP are more likely to have been sent by
another process, and we shouldn't record a crasher if the worker process
receives one of these.
Note that Go installs its own signal handlers on startup, so some of these
signals may only be received if signal handlers are changed. For example,
SIGSEGV is normally transformed into a panic that causes the process to exit
with status 2 if not recovered, which we handle as a crash.</p>
               
               <pre><code class="language-go">func isCrashSignal(signal os.Signal) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isCrashSignal" data-name="isCrashSignal">
               <h3>
                  isCrashSignal 
                  <span class="badge">function</span>
                  
                  <a href="#isCrashSignal" class="anchor" title="Link to isCrashSignal">#</a>
               </h3>
               
               <pre><code class="language-go">func isCrashSignal(signal os.Signal) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isCrashSignal" data-name="isCrashSignal">
               <h3>
                  isCrashSignal 
                  <span class="badge">function</span>
                  
                  <a href="#isCrashSignal" class="anchor" title="Link to isCrashSignal">#</a>
               </h3>
               
               <p>isCrashSignal is not implemented because Windows doesn't have signals.</p>
               
               <pre><code class="language-go">func isCrashSignal(signal os.Signal) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isInterruptError" data-name="isInterruptError">
               <h3>
                  isInterruptError 
                  <span class="badge">function</span>
                  
                  <a href="#isInterruptError" class="anchor" title="Link to isInterruptError">#</a>
               </h3>
               
               <pre><code class="language-go">func isInterruptError(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isInterruptError" data-name="isInterruptError">
               <h3>
                  isInterruptError 
                  <span class="badge">function</span>
                  
                  <a href="#isInterruptError" class="anchor" title="Link to isInterruptError">#</a>
               </h3>
               
               <p>isInterruptError returns whether an error was returned by a process that
was terminated by an interrupt signal (SIGINT).</p>
               
               <pre><code class="language-go">func isInterruptError(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isInterruptError" data-name="isInterruptError">
               <h3>
                  isInterruptError 
                  <span class="badge">function</span>
                  
                  <a href="#isInterruptError" class="anchor" title="Link to isInterruptError">#</a>
               </h3>
               
               <pre><code class="language-go">func isInterruptError(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isMinimizable" data-name="isMinimizable">
               <h3>
                  isMinimizable 
                  <span class="badge">function</span>
                  
                  <a href="#isMinimizable" class="anchor" title="Link to isMinimizable">#</a>
               </h3>
               
               <pre><code class="language-go">func isMinimizable(t reflect.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isRunning" data-name="isRunning">
               <h3>
                  isRunning 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isRunning" class="anchor" title="Link to isRunning">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *worker) isRunning() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="libfuzzerHookEqualFold" data-name="libfuzzerHookEqualFold">
               <h3>
                  libfuzzerHookEqualFold 
                  <span class="badge">function</span>
                  
                  <a href="#libfuzzerHookEqualFold" class="anchor" title="Link to libfuzzerHookEqualFold">#</a>
               </h3>
               
               <pre><code class="language-go">func libfuzzerHookEqualFold(arg0 string, arg1 string, fakePC uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="libfuzzerHookStrCmp" data-name="libfuzzerHookStrCmp">
               <h3>
                  libfuzzerHookStrCmp 
                  <span class="badge">function</span>
                  
                  <a href="#libfuzzerHookStrCmp" class="anchor" title="Link to libfuzzerHookStrCmp">#</a>
               </h3>
               
               <pre><code class="language-go">func libfuzzerHookStrCmp(arg0 string, arg1 string, fakePC uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="libfuzzerTraceCmp1" data-name="libfuzzerTraceCmp1">
               <h3>
                  libfuzzerTraceCmp1 
                  <span class="badge">function</span>
                  
                  <a href="#libfuzzerTraceCmp1" class="anchor" title="Link to libfuzzerTraceCmp1">#</a>
               </h3>
               
               <pre><code class="language-go">func libfuzzerTraceCmp1(arg0 uint8, arg1 uint8, fakePC uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="libfuzzerTraceCmp2" data-name="libfuzzerTraceCmp2">
               <h3>
                  libfuzzerTraceCmp2 
                  <span class="badge">function</span>
                  
                  <a href="#libfuzzerTraceCmp2" class="anchor" title="Link to libfuzzerTraceCmp2">#</a>
               </h3>
               
               <pre><code class="language-go">func libfuzzerTraceCmp2(arg0 uint16, arg1 uint16, fakePC uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="libfuzzerTraceCmp4" data-name="libfuzzerTraceCmp4">
               <h3>
                  libfuzzerTraceCmp4 
                  <span class="badge">function</span>
                  
                  <a href="#libfuzzerTraceCmp4" class="anchor" title="Link to libfuzzerTraceCmp4">#</a>
               </h3>
               
               <pre><code class="language-go">func libfuzzerTraceCmp4(arg0 uint32, arg1 uint32, fakePC uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="libfuzzerTraceCmp8" data-name="libfuzzerTraceCmp8">
               <h3>
                  libfuzzerTraceCmp8 
                  <span class="badge">function</span>
                  
                  <a href="#libfuzzerTraceCmp8" class="anchor" title="Link to libfuzzerTraceCmp8">#</a>
               </h3>
               
               <pre><code class="language-go">func libfuzzerTraceCmp8(arg0 uint64, arg1 uint64, fakePC uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="libfuzzerTraceConstCmp1" data-name="libfuzzerTraceConstCmp1">
               <h3>
                  libfuzzerTraceConstCmp1 
                  <span class="badge">function</span>
                  
                  <a href="#libfuzzerTraceConstCmp1" class="anchor" title="Link to libfuzzerTraceConstCmp1">#</a>
               </h3>
               
               <pre><code class="language-go">func libfuzzerTraceConstCmp1(arg0 uint8, arg1 uint8, fakePC uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="libfuzzerTraceConstCmp2" data-name="libfuzzerTraceConstCmp2">
               <h3>
                  libfuzzerTraceConstCmp2 
                  <span class="badge">function</span>
                  
                  <a href="#libfuzzerTraceConstCmp2" class="anchor" title="Link to libfuzzerTraceConstCmp2">#</a>
               </h3>
               
               <pre><code class="language-go">func libfuzzerTraceConstCmp2(arg0 uint16, arg1 uint16, fakePC uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="libfuzzerTraceConstCmp4" data-name="libfuzzerTraceConstCmp4">
               <h3>
                  libfuzzerTraceConstCmp4 
                  <span class="badge">function</span>
                  
                  <a href="#libfuzzerTraceConstCmp4" class="anchor" title="Link to libfuzzerTraceConstCmp4">#</a>
               </h3>
               
               <pre><code class="language-go">func libfuzzerTraceConstCmp4(arg0 uint32, arg1 uint32, fakePC uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="libfuzzerTraceConstCmp8" data-name="libfuzzerTraceConstCmp8">
               <h3>
                  libfuzzerTraceConstCmp8 
                  <span class="badge">function</span>
                  
                  <a href="#libfuzzerTraceConstCmp8" class="anchor" title="Link to libfuzzerTraceConstCmp8">#</a>
               </h3>
               
               <pre><code class="language-go">func libfuzzerTraceConstCmp8(arg0 uint64, arg1 uint64, fakePC uint)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logStats" data-name="logStats">
               <h3>
                  logStats 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#logStats" class="anchor" title="Link to logStats">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *coordinator) logStats()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="marshalCorpusFile" data-name="marshalCorpusFile">
               <h3>
                  marshalCorpusFile 
                  <span class="badge">function</span>
                  
                  <a href="#marshalCorpusFile" class="anchor" title="Link to marshalCorpusFile">#</a>
               </h3>
               
               <p>marshalCorpusFile encodes an arbitrary number of arguments into the file format for the
corpus.</p>
               
               <pre><code class="language-go">func marshalCorpusFile(vals ...any) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="minimize" data-name="minimize">
               <h3>
                  minimize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#minimize" class="anchor" title="Link to minimize">#</a>
               </h3>
               
               <p>minimize tells the worker to call the minimize method. See
workerServer.minimize.</p>
               
               <pre><code class="language-go">func (wc *workerClient) minimize(ctx context.Context, entryIn CorpusEntry, args minimizeArgs) (entryOut CorpusEntry, resp minimizeResponse, retErr error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="minimize" data-name="minimize">
               <h3>
                  minimize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#minimize" class="anchor" title="Link to minimize">#</a>
               </h3>
               
               <p>minimize tells a worker process to attempt to find a smaller value that
either causes an error (if we started minimizing because we found an input
that causes an error) or preserves new coverage (if we started minimizing
because we found an input that expands coverage).</p>
               
               <pre><code class="language-go">func (w *worker) minimize(ctx context.Context, input fuzzMinimizeInput) (min fuzzResult, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="minimize" data-name="minimize">
               <h3>
                  minimize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#minimize" class="anchor" title="Link to minimize">#</a>
               </h3>
               
               <pre><code class="language-go">func (ws *workerServer) minimize(ctx context.Context, args minimizeArgs) (resp minimizeResponse)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="minimizeBytes" data-name="minimizeBytes">
               <h3>
                  minimizeBytes 
                  <span class="badge">function</span>
                  
                  <a href="#minimizeBytes" class="anchor" title="Link to minimizeBytes">#</a>
               </h3>
               
               <pre><code class="language-go">func minimizeBytes(v []byte, try func([]byte) bool, shouldStop func() bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="minimizeInput" data-name="minimizeInput">
               <h3>
                  minimizeInput 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#minimizeInput" class="anchor" title="Link to minimizeInput">#</a>
               </h3>
               
               <p>minimizeInput applies a series of minimizing transformations on the provided
vals, ensuring that each minimization still causes an error, or keeps
coverage, in fuzzFn. It uses the context to determine how long to run,
stopping once closed. It returns a bool indicating whether minimization was
successful and an error if one was found.</p>
               
               <pre><code class="language-go">func (ws *workerServer) minimizeInput(ctx context.Context, vals []any, mem *sharedMem, args minimizeArgs) (success bool, retErr error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mutate" data-name="mutate">
               <h3>
                  mutate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mutate" class="anchor" title="Link to mutate">#</a>
               </h3>
               
               <p>mutate performs several mutations on the provided values.</p>
               
               <pre><code class="language-go">func (m *mutator) mutate(vals []any, maxBytes int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mutateBytes" data-name="mutateBytes">
               <h3>
                  mutateBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mutateBytes" class="anchor" title="Link to mutateBytes">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *mutator) mutateBytes(ptrB *[]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mutateFloat" data-name="mutateFloat">
               <h3>
                  mutateFloat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mutateFloat" class="anchor" title="Link to mutateFloat">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *mutator) mutateFloat(v float64, maxValue float64) float64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mutateInt" data-name="mutateInt">
               <h3>
                  mutateInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mutateInt" class="anchor" title="Link to mutateInt">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *mutator) mutateInt(v int64, maxValue int64) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mutateUInt" data-name="mutateUInt">
               <h3>
                  mutateUInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mutateUInt" class="anchor" title="Link to mutateUInt">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *mutator) mutateUInt(v uint64, maxValue uint64) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newCoordinator" data-name="newCoordinator">
               <h3>
                  newCoordinator 
                  <span class="badge">function</span>
                  
                  <a href="#newCoordinator" class="anchor" title="Link to newCoordinator">#</a>
               </h3>
               
               <pre><code class="language-go">func newCoordinator(opts CoordinateFuzzingOpts) (*coordinator, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newMutator" data-name="newMutator">
               <h3>
                  newMutator 
                  <span class="badge">function</span>
                  
                  <a href="#newMutator" class="anchor" title="Link to newMutator">#</a>
               </h3>
               
               <pre><code class="language-go">func newMutator() *mutator</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newPcgRand" data-name="newPcgRand">
               <h3>
                  newPcgRand 
                  <span class="badge">function</span>
                  
                  <a href="#newPcgRand" class="anchor" title="Link to newPcgRand">#</a>
               </h3>
               
               <p>newPcgRand generates a new, seeded Rand, ready for use.</p>
               
               <pre><code class="language-go">func newPcgRand() *pcgRand</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newWorker" data-name="newWorker">
               <h3>
                  newWorker 
                  <span class="badge">function</span>
                  
                  <a href="#newWorker" class="anchor" title="Link to newWorker">#</a>
               </h3>
               
               <pre><code class="language-go">func newWorker(c *coordinator, dir string, binPath string, args []string, env []string) (*worker, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newWorkerClient" data-name="newWorkerClient">
               <h3>
                  newWorkerClient 
                  <span class="badge">function</span>
                  
                  <a href="#newWorkerClient" class="anchor" title="Link to newWorkerClient">#</a>
               </h3>
               
               <pre><code class="language-go">func newWorkerClient(comm workerComm, m *mutator) *workerClient</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseCorpusValue" data-name="parseCorpusValue">
               <h3>
                  parseCorpusValue 
                  <span class="badge">function</span>
                  
                  <a href="#parseCorpusValue" class="anchor" title="Link to parseCorpusValue">#</a>
               </h3>
               
               <pre><code class="language-go">func parseCorpusValue(line []byte) (any, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseInt" data-name="parseInt">
               <h3>
                  parseInt 
                  <span class="badge">function</span>
                  
                  <a href="#parseInt" class="anchor" title="Link to parseInt">#</a>
               </h3>
               
               <p>parseInt returns an integer of value val and type typ.</p>
               
               <pre><code class="language-go">func parseInt(val string, typ string) (any, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseUint" data-name="parseUint">
               <h3>
                  parseUint 
                  <span class="badge">function</span>
                  
                  <a href="#parseUint" class="anchor" title="Link to parseUint">#</a>
               </h3>
               
               <p>parseUint returns an unsigned integer of value val and type typ.</p>
               
               <pre><code class="language-go">func parseUint(val string, typ string) (any, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="peek" data-name="peek">
               <h3>
                  peek 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#peek" class="anchor" title="Link to peek">#</a>
               </h3>
               
               <pre><code class="language-go">func (q *queue) peek() (any, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="peekInput" data-name="peekInput">
               <h3>
                  peekInput 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#peekInput" class="anchor" title="Link to peekInput">#</a>
               </h3>
               
               <p>peekInput returns the next value that should be sent to workers.
If the number of executions is limited, the returned value includes
a limit for one worker. If there are no executions left, peekInput returns
a zero value and false.
peekInput doesn't actually remove the input from the queue. The caller
must call sentInput after sending the input.
If the input queue is empty and the coverage/testing-only run has completed,
queue refills it from the corpus.</p>
               
               <pre><code class="language-go">func (c *coordinator) peekInput() (fuzzInput, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="peekMinimizeInput" data-name="peekMinimizeInput">
               <h3>
                  peekMinimizeInput 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#peekMinimizeInput" class="anchor" title="Link to peekMinimizeInput">#</a>
               </h3>
               
               <p>peekMinimizeInput returns the next input that should be sent to workers for
minimization.</p>
               
               <pre><code class="language-go">func (c *coordinator) peekMinimizeInput() (fuzzMinimizeInput, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ping" data-name="ping">
               <h3>
                  ping 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ping" class="anchor" title="Link to ping">#</a>
               </h3>
               
               <p>ping does nothing. The coordinator calls this method to ensure the worker
has called F.Fuzz and can communicate.</p>
               
               <pre><code class="language-go">func (ws *workerServer) ping(ctx context.Context, args pingArgs) pingResponse</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ping" data-name="ping">
               <h3>
                  ping 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ping" class="anchor" title="Link to ping">#</a>
               </h3>
               
               <p>ping tells the worker to call the ping method. See workerServer.ping.</p>
               
               <pre><code class="language-go">func (wc *workerClient) ping(ctx context.Context) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="queueForMinimization" data-name="queueForMinimization">
               <h3>
                  queueForMinimization 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#queueForMinimization" class="anchor" title="Link to queueForMinimization">#</a>
               </h3>
               
               <p>queueForMinimization creates a fuzzMinimizeInput from result and adds it
to the minimization queue to be sent to workers.</p>
               
               <pre><code class="language-go">func (c *coordinator) queueForMinimization(result fuzzResult, keepCoverage []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rand" data-name="rand">
               <h3>
                  rand 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rand" class="anchor" title="Link to rand">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *mutator) rand(n int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="randByteOrder" data-name="randByteOrder">
               <h3>
                  randByteOrder 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#randByteOrder" class="anchor" title="Link to randByteOrder">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *mutator) randByteOrder() binary.ByteOrder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readCache" data-name="readCache">
               <h3>
                  readCache 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readCache" class="anchor" title="Link to readCache">#</a>
               </h3>
               
               <p>readCache creates a combined corpus from seed values and values in the cache
(in GOCACHE/fuzz).
TODO(fuzzing): need a mechanism that can remove values that
aren't useful anymore, for example, because they have the wrong type.</p>
               
               <pre><code class="language-go">func (c *coordinator) readCache() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readCorpusData" data-name="readCorpusData">
               <h3>
                  readCorpusData 
                  <span class="badge">function</span>
                  
                  <a href="#readCorpusData" class="anchor" title="Link to readCorpusData">#</a>
               </h3>
               
               <pre><code class="language-go">func readCorpusData(data []byte, types []reflect.Type) ([]any, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="refillInputQueue" data-name="refillInputQueue">
               <h3>
                  refillInputQueue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#refillInputQueue" class="anchor" title="Link to refillInputQueue">#</a>
               </h3>
               
               <p>refillInputQueue refills the input queue from the corpus after it becomes
empty.</p>
               
               <pre><code class="language-go">func (c *coordinator) refillInputQueue()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="restore" data-name="restore">
               <h3>
                  restore 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#restore" class="anchor" title="Link to restore">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *pcgRand) restore(randState uint64, randInc uint64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="save" data-name="save">
               <h3>
                  save 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#save" class="anchor" title="Link to save">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *pcgRand) save(randState *uint64, randInc *uint64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sentInput" data-name="sentInput">
               <h3>
                  sentInput 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sentInput" class="anchor" title="Link to sentInput">#</a>
               </h3>
               
               <p>sentInput updates internal counters after an input is sent to c.inputC.</p>
               
               <pre><code class="language-go">func (c *coordinator) sentInput(input fuzzInput)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sentMinimizeInput" data-name="sentMinimizeInput">
               <h3>
                  sentMinimizeInput 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sentMinimizeInput" class="anchor" title="Link to sentMinimizeInput">#</a>
               </h3>
               
               <p>sentMinimizeInput removes an input from the minimization queue after it's
sent to minimizeC.</p>
               
               <pre><code class="language-go">func (c *coordinator) sentMinimizeInput(input fuzzMinimizeInput)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="serve" data-name="serve">
               <h3>
                  serve 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#serve" class="anchor" title="Link to serve">#</a>
               </h3>
               
               <p>serve reads serialized RPC messages on fuzzIn. When serve receives a message,
it calls the corresponding method, then sends the serialized result back
on fuzzOut.
serve handles RPC calls synchronously; it will not attempt to read a message
until the previous call has finished.
serve returns errors that occurred when communicating over pipes. serve
does not return errors from method calls; those are passed through serialized
responses.</p>
               
               <pre><code class="language-go">func (ws *workerServer) serve(ctx context.Context) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setValue" data-name="setValue">
               <h3>
                  setValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setValue" class="anchor" title="Link to setValue">#</a>
               </h3>
               
               <p>setValue copies the data in b into the shared memory buffer and sets
the length. len(b) must be less than or equal to the capacity of the buffer
(as returned by cap(m.value())).</p>
               
               <pre><code class="language-go">func (m *sharedMem) setValue(b []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setValueLen" data-name="setValueLen">
               <h3>
                  setValueLen 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setValueLen" class="anchor" title="Link to setValueLen">#</a>
               </h3>
               
               <p>setValueLen sets the length of the shared memory buffer returned by valueRef
to n, which may be at most the cap of that slice.
Note that we can only store the length in the shared memory header. The full
slice header contains a pointer, which is likely only valid for one process,
since each process can map shared memory at a different virtual address.</p>
               
               <pre><code class="language-go">func (m *sharedMem) setValueLen(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setWorkerComm" data-name="setWorkerComm">
               <h3>
                  setWorkerComm 
                  <span class="badge">function</span>
                  
                  <a href="#setWorkerComm" class="anchor" title="Link to setWorkerComm">#</a>
               </h3>
               
               <p>setWorkerComm configures communication channels on the cmd that will
run a worker process.</p>
               
               <pre><code class="language-go">func setWorkerComm(cmd *exec.Cmd, comm workerComm)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setWorkerComm" data-name="setWorkerComm">
               <h3>
                  setWorkerComm 
                  <span class="badge">function</span>
                  
                  <a href="#setWorkerComm" class="anchor" title="Link to setWorkerComm">#</a>
               </h3>
               
               <pre><code class="language-go">func setWorkerComm(cmd *exec.Cmd, comm workerComm)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setWorkerComm" data-name="setWorkerComm">
               <h3>
                  setWorkerComm 
                  <span class="badge">function</span>
                  
                  <a href="#setWorkerComm" class="anchor" title="Link to setWorkerComm">#</a>
               </h3>
               
               <p>setWorkerComm configures communication channels on the cmd that will
run a worker process.</p>
               
               <pre><code class="language-go">func setWorkerComm(cmd *exec.Cmd, comm workerComm)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sharedMemMapFile" data-name="sharedMemMapFile">
               <h3>
                  sharedMemMapFile 
                  <span class="badge">function</span>
                  
                  <a href="#sharedMemMapFile" class="anchor" title="Link to sharedMemMapFile">#</a>
               </h3>
               
               <pre><code class="language-go">func sharedMemMapFile(f *os.File, size int, removeOnClose bool) (*sharedMem, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sharedMemMapFile" data-name="sharedMemMapFile">
               <h3>
                  sharedMemMapFile 
                  <span class="badge">function</span>
                  
                  <a href="#sharedMemMapFile" class="anchor" title="Link to sharedMemMapFile">#</a>
               </h3>
               
               <pre><code class="language-go">func sharedMemMapFile(f *os.File, size int, removeOnClose bool) (*sharedMem, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sharedMemMapFile" data-name="sharedMemMapFile">
               <h3>
                  sharedMemMapFile 
                  <span class="badge">function</span>
                  
                  <a href="#sharedMemMapFile" class="anchor" title="Link to sharedMemMapFile">#</a>
               </h3>
               
               <pre><code class="language-go">func sharedMemMapFile(f *os.File, size int, removeOnClose bool) (mem *sharedMem, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sharedMemSize" data-name="sharedMemSize">
               <h3>
                  sharedMemSize 
                  <span class="badge">function</span>
                  
                  <a href="#sharedMemSize" class="anchor" title="Link to sharedMemSize">#</a>
               </h3>
               
               <p>sharedMemSize returns the size needed for a shared memory buffer that can
contain values of the given size.</p>
               
               <pre><code class="language-go">func sharedMemSize(valueSize int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sharedMemTempFile" data-name="sharedMemTempFile">
               <h3>
                  sharedMemTempFile 
                  <span class="badge">function</span>
                  
                  <a href="#sharedMemTempFile" class="anchor" title="Link to sharedMemTempFile">#</a>
               </h3>
               
               <p>sharedMemTempFile creates a new temporary file of the given size, then maps
it into memory. The file will be removed when the Close method is called.</p>
               
               <pre><code class="language-go">func sharedMemTempFile(size int) (m *sharedMem, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldPrintDebugInfo" data-name="shouldPrintDebugInfo">
               <h3>
                  shouldPrintDebugInfo 
                  <span class="badge">function</span>
                  
                  <a href="#shouldPrintDebugInfo" class="anchor" title="Link to shouldPrintDebugInfo">#</a>
               </h3>
               
               <pre><code class="language-go">func shouldPrintDebugInfo() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="start" data-name="start">
               <h3>
                  start 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#start" class="anchor" title="Link to start">#</a>
               </h3>
               
               <p>start runs a new worker process.
If the process couldn't be started, start returns an error. Start won't
return later termination errors from the process if they occur.
If the process starts successfully, start returns nil. stop must be called
once later to clean up, even if the process terminates on its own.
When the process terminates, w.waitErr is set to the error (if any), and
w.termC is closed.</p>
               
               <pre><code class="language-go">func (w *worker) start() (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startAndPing" data-name="startAndPing">
               <h3>
                  startAndPing 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startAndPing" class="anchor" title="Link to startAndPing">#</a>
               </h3>
               
               <p>startAndPing starts the worker process and sends it a message to make sure it
can communicate.
startAndPing returns an error if any part of this didn't work, including if
the context is expired or the worker process was interrupted before it
responded. Errors that happen after start but before the ping response
likely indicate that the worker did not call F.Fuzz or called F.Fail first.
We don't record crashers for these errors.</p>
               
               <pre><code class="language-go">func (w *worker) startAndPing(ctx context.Context) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="step" data-name="step">
               <h3>
                  step 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#step" class="anchor" title="Link to step">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *pcgRand) step()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stop" data-name="stop">
               <h3>
                  stop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stop" class="anchor" title="Link to stop">#</a>
               </h3>
               
               <p>stop tells the worker process to exit by closing w.client, then blocks until
it terminates. If the worker doesn't terminate after a short time, stop
signals it with os.Interrupt (where supported), then os.Kill.
stop returns the error the process terminated with, if any (same as
w.waitErr).
stop must be called at least once after start returns successfully, even if
the worker process terminates unexpectedly.</p>
               
               <pre><code class="language-go">func (w *worker) stop() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="terminationSignal" data-name="terminationSignal">
               <h3>
                  terminationSignal 
                  <span class="badge">function</span>
                  
                  <a href="#terminationSignal" class="anchor" title="Link to terminationSignal">#</a>
               </h3>
               
               <p>terminationSignal returns -1 and false because Windows doesn't have signals.</p>
               
               <pre><code class="language-go">func terminationSignal(err error) (os.Signal, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="terminationSignal" data-name="terminationSignal">
               <h3>
                  terminationSignal 
                  <span class="badge">function</span>
                  
                  <a href="#terminationSignal" class="anchor" title="Link to terminationSignal">#</a>
               </h3>
               
               <p>terminationSignal checks if err is an exec.ExitError with a signal status.
If it is, terminationSignal returns the signal and true.
If not, -1 and false.</p>
               
               <pre><code class="language-go">func terminationSignal(err error) (os.Signal, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="terminationSignal" data-name="terminationSignal">
               <h3>
                  terminationSignal 
                  <span class="badge">function</span>
                  
                  <a href="#terminationSignal" class="anchor" title="Link to terminationSignal">#</a>
               </h3>
               
               <pre><code class="language-go">func terminationSignal(err error) (os.Signal, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="testName" data-name="testName">
               <h3>
                  testName 
                  <span class="badge">function</span>
                  
                  <a href="#testName" class="anchor" title="Link to testName">#</a>
               </h3>
               
               <pre><code class="language-go">func testName(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uint32" data-name="uint32">
               <h3>
                  uint32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uint32" class="anchor" title="Link to uint32">#</a>
               </h3>
               
               <p>uint32 returns a pseudo-random uint32.</p>
               
               <pre><code class="language-go">func (r *pcgRand) uint32() uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uint32n" data-name="uint32n">
               <h3>
                  uint32n 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uint32n" class="anchor" title="Link to uint32n">#</a>
               </h3>
               
               <p>uint32n returns a pseudo-random number in [0, n).
For implementation details, see:
https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction
https://lemire.me/blog/2016/06/30/fast-random-shuffling</p>
               
               <pre><code class="language-go">func (r *pcgRand) uint32n(n uint32) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unmarshalCorpusFile" data-name="unmarshalCorpusFile">
               <h3>
                  unmarshalCorpusFile 
                  <span class="badge">function</span>
                  
                  <a href="#unmarshalCorpusFile" class="anchor" title="Link to unmarshalCorpusFile">#</a>
               </h3>
               
               <p>unmarshalCorpusFile decodes corpus bytes into their respective values.</p>
               
               <pre><code class="language-go">func unmarshalCorpusFile(b []byte) ([]any, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateCoverage" data-name="updateCoverage">
               <h3>
                  updateCoverage 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#updateCoverage" class="anchor" title="Link to updateCoverage">#</a>
               </h3>
               
               <p>updateCoverage sets bits in c.coverageMask that are set in newCoverage.
updateCoverage returns the number of newly set bits. See the comment on
coverageMask for the format.</p>
               
               <pre><code class="language-go">func (c *coordinator) updateCoverage(newCoverage []byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateStats" data-name="updateStats">
               <h3>
                  updateStats 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#updateStats" class="anchor" title="Link to updateStats">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *coordinator) updateStats(result fuzzResult)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="valueCopy" data-name="valueCopy">
               <h3>
                  valueCopy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#valueCopy" class="anchor" title="Link to valueCopy">#</a>
               </h3>
               
               <p>valueCopy returns a copy of the value stored in shared memory.</p>
               
               <pre><code class="language-go">func (m *sharedMem) valueCopy() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="valueRef" data-name="valueRef">
               <h3>
                  valueRef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#valueRef" class="anchor" title="Link to valueRef">#</a>
               </h3>
               
               <p>valueRef returns the value currently stored in shared memory. The returned
slice points to shared memory; it is not a copy.</p>
               
               <pre><code class="language-go">func (m *sharedMem) valueRef() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="warmupRun" data-name="warmupRun">
               <h3>
                  warmupRun 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#warmupRun" class="anchor" title="Link to warmupRun">#</a>
               </h3>
               
               <p>warmupRun returns true while the coordinator is running inputs without
mutating them as a warmup before fuzzing. This could be to gather baseline
coverage data for entries in the corpus, or to test all of the seed corpus
for errors before fuzzing begins.
The coordinator doesn't store coverage data in the cache with each input
because that data would be invalid when counter offsets in the test binary
change.
When gathering coverage, the coordinator sends each entry to a worker to
gather coverage for that entry only, without fuzzing or minimizing. This
phase ends when all workers have finished, and the coordinator has a combined
coverage map.</p>
               
               <pre><code class="language-go">func (c *coordinator) warmupRun() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeToCorpus" data-name="writeToCorpus">
               <h3>
                  writeToCorpus 
                  <span class="badge">function</span>
                  
                  <a href="#writeToCorpus" class="anchor" title="Link to writeToCorpus">#</a>
               </h3>
               
               <p>writeToCorpus atomically writes the given bytes to a new file in testdata. If
the directory does not exist, it will create one. If the file already exists,
writeToCorpus will not rewrite it. writeToCorpus sets entry.Path to the new
file that was just written or an error if it failed.</p>
               
               <pre><code class="language-go">func writeToCorpus(entry *CorpusEntry, dir string) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeToMem" data-name="writeToMem">
               <h3>
                  writeToMem 
                  <span class="badge">function</span>
                  
                  <a href="#writeToMem" class="anchor" title="Link to writeToMem">#</a>
               </h3>
               
               <pre><code class="language-go">func writeToMem(vals []any, mem *sharedMem)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="zeroValue" data-name="zeroValue">
               <h3>
                  zeroValue 
                  <span class="badge">function</span>
                  
                  <a href="#zeroValue" class="anchor" title="Link to zeroValue">#</a>
               </h3>
               
               <pre><code class="language-go">func zeroValue(t reflect.Type) any</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>