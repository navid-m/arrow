<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - fmt</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>fmt</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"errors"
"io"
"math"
"os"
"reflect"
"strconv"
"sync"
"unicode/utf8"
"errors"
"slices"
"strconv"
"unicode/utf8"
"internal/fmtsort"
"io"
"os"
"reflect"
"strconv"
"sync"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="badIndexString">
               <h3>
                  badIndexString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const badIndexString = "(BADINDEX)"</code></pre>
            </article>
            
            <article class="global" data-name="badPrecString">
               <h3>
                  badPrecString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const badPrecString = "%!(BADPREC)"</code></pre>
            </article>
            
            <article class="global" data-name="badWidthString">
               <h3>
                  badWidthString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const badWidthString = "%!(BADWIDTH)"</code></pre>
            </article>
            
            <article class="global" data-name="binaryDigits">
               <h3>
                  binaryDigits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Numerical elements</p>
               
               <pre><code>const binaryDigits = "01"</code></pre>
            </article>
            
            <article class="global" data-name="commaSpaceString">
               <h3>
                  commaSpaceString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const commaSpaceString = ", "</code></pre>
            </article>
            
            <article class="global" data-name="decimalDigits">
               <h3>
                  decimalDigits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Numerical elements</p>
               
               <pre><code>const decimalDigits = "0123456789"</code></pre>
            </article>
            
            <article class="global" data-name="eof">
               <h3>
                  eof 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const eof = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="errBool">
               <h3>
                  errBool 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errBool = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errComplex">
               <h3>
                  errComplex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errComplex = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="exponent">
               <h3>
                  exponent 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Numerical elements</p>
               
               <pre><code>const exponent = "eEpP"</code></pre>
            </article>
            
            <article class="global" data-name="extraString">
               <h3>
                  extraString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const extraString = "%!(EXTRA "</code></pre>
            </article>
            
            <article class="global" data-name="floatVerbs">
               <h3>
                  floatVerbs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const floatVerbs = "beEfFgGv"</code></pre>
            </article>
            
            <article class="global" data-name="hexadecimalDigits">
               <h3>
                  hexadecimalDigits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Numerical elements</p>
               
               <pre><code>const hexadecimalDigits = "0123456789aAbBcCdDeEfF"</code></pre>
            </article>
            
            <article class="global" data-name="hugeWid">
               <h3>
                  hugeWid 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hugeWid = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="intBits">
               <h3>
                  intBits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const intBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="invReflectString">
               <h3>
                  invReflectString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const invReflectString = "<invalid reflect.Value>"</code></pre>
            </article>
            
            <article class="global" data-name="ldigits">
               <h3>
                  ldigits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ldigits = "0123456789abcdefx"</code></pre>
            </article>
            
            <article class="global" data-name="mapString">
               <h3>
                  mapString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const mapString = "map["</code></pre>
            </article>
            
            <article class="global" data-name="missingString">
               <h3>
                  missingString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const missingString = "(MISSING)"</code></pre>
            </article>
            
            <article class="global" data-name="nilAngleString">
               <h3>
                  nilAngleString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const nilAngleString = "<nil>"</code></pre>
            </article>
            
            <article class="global" data-name="nilParenString">
               <h3>
                  nilParenString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const nilParenString = "(nil)"</code></pre>
            </article>
            
            <article class="global" data-name="nilString">
               <h3>
                  nilString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const nilString = "nil"</code></pre>
            </article>
            
            <article class="global" data-name="noVerbString">
               <h3>
                  noVerbString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const noVerbString = "%!(NOVERB)"</code></pre>
            </article>
            
            <article class="global" data-name="octalDigits">
               <h3>
                  octalDigits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Numerical elements</p>
               
               <pre><code>const octalDigits = "01234567"</code></pre>
            </article>
            
            <article class="global" data-name="panicString">
               <h3>
                  panicString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const panicString = "(PANIC="</code></pre>
            </article>
            
            <article class="global" data-name="percentBangString">
               <h3>
                  percentBangString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const percentBangString = "%!"</code></pre>
            </article>
            
            <article class="global" data-name="period">
               <h3>
                  period 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Numerical elements</p>
               
               <pre><code>const period = "."</code></pre>
            </article>
            
            <article class="global" data-name="ppFree">
               <h3>
                  ppFree 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ppFree = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global" data-name="sign">
               <h3>
                  sign 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Numerical elements</p>
               
               <pre><code>const sign = "+-"</code></pre>
            </article>
            
            <article class="global" data-name="signed">
               <h3>
                  signed 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const signed = true</code></pre>
            </article>
            
            <article class="global" data-name="space">
               <h3>
                  space 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>space is a copy of the unicode.White_Space ranges,
to avoid depending on package unicode.</p>
               
               <pre><code>var space = [][2]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="ssFree">
               <h3>
                  ssFree 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ssFree = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global" data-name="udigits">
               <h3>
                  udigits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const udigits = "0123456789ABCDEFX"</code></pre>
            </article>
            
            <article class="global" data-name="uintptrBits">
               <h3>
                  uintptrBits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const uintptrBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="unsigned">
               <h3>
                  unsigned 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const unsigned = false</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="buffer">
               <h3>
                  buffer
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Use simple []byte instead of bytes.Buffer to avoid large dependency.</p>
               
               <pre><code>type buffer []byte</code></pre>
            </article>
            
            <article class="type" data-name="stringReader">
               <h3>
                  stringReader
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type stringReader string</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Formatter">
               <h3>
                  Formatter
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Formatter is implemented by any value that has a Format method.
The implementation controls how [State] and rune are interpreted,
and may call [Sprint] or [Fprint](f) etc. to generate its output.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Formatter interface {
Format(f State, verb rune)
}</code></pre>
            </article>
            
            <article class="interface" data-name="GoStringer">
               <h3>
                  GoStringer
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>GoStringer is implemented by any value that has a GoString method,
which defines the Go syntax for that value.
The GoString method is used to print values passed as an operand
to a %#v format.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type GoStringer interface {
GoString() string
}</code></pre>
            </article>
            
            <article class="interface" data-name="ScanState">
               <h3>
                  ScanState
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ScanState represents the scanner state passed to custom scanners.
Scanners may do rune-at-a-time scanning or ask the ScanState
to discover the next space-delimited token.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ScanState interface {
ReadRune() (r rune, size int, err error)
UnreadRune() error
SkipSpace()
Token(skipSpace bool, f func(rune) bool) (token []byte, err error)
Width() (wid int, ok bool)
Read(buf []byte) (n int, err error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="Scanner">
               <h3>
                  Scanner
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Scanner is implemented by any value that has a Scan method, which scans
the input for the representation of a value and stores the result in the
receiver, which must be a pointer to be useful. The Scan method is called
for any argument to [Scan], [Scanf], or [Scanln] that implements it.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Scanner interface {
Scan(state ScanState, verb rune) error
}</code></pre>
            </article>
            
            <article class="interface" data-name="State">
               <h3>
                  State
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>State represents the printer state passed to custom formatters.
It provides access to the [io.Writer] interface plus information about
the flags and options for the operand's format specifier.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type State interface {
Write(b []byte) (n int, err error)
Width() (wid int, ok bool)
Precision() (prec int, ok bool)
Flag(c int) bool
}</code></pre>
            </article>
            
            <article class="interface" data-name="Stringer">
               <h3>
                  Stringer
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Stringer is implemented by any value that has a String method,
which defines the “native” format for that value.
The String method is used to print values passed as an operand
to any format that accepts a string or to an unformatted printer
such as [Print].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Stringer interface {
String() string
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="fmt">
               <h3>
                  fmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>A fmt is the raw formatter used by Printf etc.
It prints into a buffer that must be set up separately.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fmt struct {
buf *buffer
fmtFlags
wid int
prec int
intbuf [68]byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="fmtFlags">
               <h3>
                  fmtFlags
                  <span class="badge">struct</span>
               </h3>
               
               <p>flags placed in a separate struct for easy clearing.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fmtFlags struct {
widPresent bool
precPresent bool
minus bool
plus bool
sharp bool
space bool
zero bool
plusV bool
sharpV bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="pp">
               <h3>
                  pp
                  <span class="badge">struct</span>
               </h3>
               
               <p>pp is used to store a printer's state and is reused with sync.Pool to avoid allocations.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pp struct {
buf buffer
arg any
value reflect.Value
fmt fmt
reordered bool
goodArgNum bool
panicking bool
erroring bool
wrapErrs bool
wrappedErrs []int
}</code></pre>
            </article>
            
            <article class="struct" data-name="readRune">
               <h3>
                  readRune
                  <span class="badge">struct</span>
               </h3>
               
               <p>readRune is a structure to enable reading UTF-8 encoded code points
from an io.Reader. It is used if the Reader given to the scanner does
not already implement io.RuneScanner.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type readRune struct {
reader io.Reader
buf [utf8.UTFMax]byte
pending int
pendBuf [utf8.UTFMax]byte
peekRune rune
}</code></pre>
            </article>
            
            <article class="struct" data-name="scanError">
               <h3>
                  scanError
                  <span class="badge">struct</span>
               </h3>
               
               <p>scanError represents an error generated by the scanning software.
It's used as a unique signature to identify such errors when recovering.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type scanError struct {
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="ss">
               <h3>
                  ss
                  <span class="badge">struct</span>
               </h3>
               
               <p>ss is the internal implementation of ScanState.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ss struct {
rs io.RuneScanner
buf buffer
count int
atEOF bool
ssave
}</code></pre>
            </article>
            
            <article class="struct" data-name="ssave">
               <h3>
                  ssave
                  <span class="badge">struct</span>
               </h3>
               
               <p>ssave holds the parts of ss that need to be
saved and restored on recursive scans.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ssave struct {
validSave bool
nlIsEnd bool
nlIsSpace bool
argLimit int
limit int
maxWid int
}</code></pre>
            </article>
            
            <article class="struct" data-name="wrapError">
               <h3>
                  wrapError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type wrapError struct {
msg string
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="wrapErrors">
               <h3>
                  wrapErrors
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type wrapErrors struct {
msg string
errs []error
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Append">
               <h3>
                  Append 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Append formats using the default formats for its operands, appends the result to
the byte slice, and returns the updated slice.</p>
               
               <pre><code>func Append(b []byte, a ...any) []byte</code></pre>
            </article>
            
            <article class="function" data-name="Appendf">
               <h3>
                  Appendf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Appendf formats according to a format specifier, appends the result to the byte
slice, and returns the updated slice.</p>
               
               <pre><code>func Appendf(b []byte, format string, a ...any) []byte</code></pre>
            </article>
            
            <article class="function" data-name="Appendln">
               <h3>
                  Appendln 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Appendln formats using the default formats for its operands, appends the result
to the byte slice, and returns the updated slice. Spaces are always added
between operands and a newline is appended.</p>
               
               <pre><code>func Appendln(b []byte, a ...any) []byte</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *wrapError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *wrapErrors) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Errorf">
               <h3>
                  Errorf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Errorf formats according to a format specifier and returns the string as a
value that satisfies error.
If the format specifier includes a %w verb with an error operand,
the returned error will implement an Unwrap method returning the operand.
If there is more than one %w verb, the returned error will implement an
Unwrap method returning a []error containing all the %w operands in the
order they appear in the arguments.
It is invalid to supply the %w verb with an operand that does not implement
the error interface. The %w verb is otherwise a synonym for %v.</p>
               
               <pre><code>func Errorf(format string, a ...any) error</code></pre>
            </article>
            
            <article class="function" data-name="Flag">
               <h3>
                  Flag 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) Flag(b int) bool</code></pre>
            </article>
            
            <article class="function" data-name="FormatString">
               <h3>
                  FormatString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FormatString returns a string representing the fully qualified formatting
directive captured by the [State], followed by the argument verb. ([State] does not
itself contain the verb.) The result has a leading percent sign followed by any
flags, the width, and the precision. Missing flags, width, and precision are
omitted. This function allows a [Formatter] to reconstruct the original
directive triggering the call to Format.</p>
               
               <pre><code>func FormatString(state State, verb rune) string</code></pre>
            </article>
            
            <article class="function" data-name="Fprint">
               <h3>
                  Fprint 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Fprint formats using the default formats for its operands and writes to w.
Spaces are added between operands when neither is a string.
It returns the number of bytes written and any write error encountered.</p>
               
               <pre><code>func Fprint(w io.Writer, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Fprintf">
               <h3>
                  Fprintf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Fprintf formats according to a format specifier and writes to w.
It returns the number of bytes written and any write error encountered.</p>
               
               <pre><code>func Fprintf(w io.Writer, format string, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Fprintln">
               <h3>
                  Fprintln 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Fprintln formats using the default formats for its operands and writes to w.
Spaces are always added between operands and a newline is appended.
It returns the number of bytes written and any write error encountered.</p>
               
               <pre><code>func Fprintln(w io.Writer, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Fscan">
               <h3>
                  Fscan 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Fscan scans text read from r, storing successive space-separated
values into successive arguments. Newlines count as space. It
returns the number of items successfully scanned. If that is less
than the number of arguments, err will report why.</p>
               
               <pre><code>func Fscan(r io.Reader, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Fscanf">
               <h3>
                  Fscanf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Fscanf scans text read from r, storing successive space-separated
values into successive arguments as determined by the format. It
returns the number of items successfully parsed.
Newlines in the input must match newlines in the format.</p>
               
               <pre><code>func Fscanf(r io.Reader, format string, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Fscanln">
               <h3>
                  Fscanln 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Fscanln is similar to [Fscan], but stops scanning at a newline and
after the final item there must be a newline or EOF.</p>
               
               <pre><code>func Fscanln(r io.Reader, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Precision">
               <h3>
                  Precision 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) Precision() (prec int, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Print">
               <h3>
                  Print 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Print formats using the default formats for its operands and writes to standard output.
Spaces are added between operands when neither is a string.
It returns the number of bytes written and any write error encountered.</p>
               
               <pre><code>func Print(a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Printf">
               <h3>
                  Printf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Printf formats according to a format specifier and writes to standard output.
It returns the number of bytes written and any write error encountered.</p>
               
               <pre><code>func Printf(format string, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Println">
               <h3>
                  Println 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Println formats using the default formats for its operands and writes to standard output.
Spaces are always added between operands and a newline is appended.
It returns the number of bytes written and any write error encountered.</p>
               
               <pre><code>func Println(a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>The Read method is only in ScanState so that ScanState
satisfies io.Reader. It will never be called when used as
intended, so there is no need to make it actually work.</p>
               
               <pre><code>func (s *ss) Read(buf []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *stringReader) Read(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadRune">
               <h3>
                  ReadRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *ss) ReadRune() (r rune, size int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadRune">
               <h3>
                  ReadRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadRune returns the next UTF-8 encoded code point from the
io.Reader inside r.</p>
               
               <pre><code>func (r *readRune) ReadRune() (rr rune, size int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Scan scans text read from standard input, storing successive
space-separated values into successive arguments. Newlines count
as space. It returns the number of items successfully scanned.
If that is less than the number of arguments, err will report why.</p>
               
               <pre><code>func Scan(a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Scanf">
               <h3>
                  Scanf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Scanf scans text read from standard input, storing successive
space-separated values into successive arguments as determined by
the format. It returns the number of items successfully scanned.
If that is less than the number of arguments, err will report why.
Newlines in the input must match newlines in the format.
The one exception: the verb %c always scans the next rune in the
input, even if it is a space (or tab etc.) or newline.</p>
               
               <pre><code>func Scanf(format string, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Scanln">
               <h3>
                  Scanln 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Scanln is similar to [Scan], but stops scanning at a newline and
after the final item there must be a newline or EOF.</p>
               
               <pre><code>func Scanln(a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="SkipSpace">
               <h3>
                  SkipSpace 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SkipSpace provides Scan methods the ability to skip space and newline
characters in keeping with the current scanning mode set by format strings
and [Scan]/[Scanln].</p>
               
               <pre><code>func (s *ss) SkipSpace()</code></pre>
            </article>
            
            <article class="function" data-name="Sprint">
               <h3>
                  Sprint 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Sprint formats using the default formats for its operands and returns the resulting string.
Spaces are added between operands when neither is a string.</p>
               
               <pre><code>func Sprint(a ...any) string</code></pre>
            </article>
            
            <article class="function" data-name="Sprintf">
               <h3>
                  Sprintf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Sprintf formats according to a format specifier and returns the resulting string.</p>
               
               <pre><code>func Sprintf(format string, a ...any) string</code></pre>
            </article>
            
            <article class="function" data-name="Sprintln">
               <h3>
                  Sprintln 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Sprintln formats using the default formats for its operands and returns the resulting string.
Spaces are always added between operands and a newline is appended.</p>
               
               <pre><code>func Sprintln(a ...any) string</code></pre>
            </article>
            
            <article class="function" data-name="Sscan">
               <h3>
                  Sscan 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Sscan scans the argument string, storing successive space-separated
values into successive arguments. Newlines count as space. It
returns the number of items successfully scanned. If that is less
than the number of arguments, err will report why.</p>
               
               <pre><code>func Sscan(str string, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Sscanf">
               <h3>
                  Sscanf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Sscanf scans the argument string, storing successive space-separated
values into successive arguments as determined by the format. It
returns the number of items successfully parsed.
Newlines in the input must match newlines in the format.</p>
               
               <pre><code>func Sscanf(str string, format string, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Sscanln">
               <h3>
                  Sscanln 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Sscanln is similar to [Sscan], but stops scanning at a newline and
after the final item there must be a newline or EOF.</p>
               
               <pre><code>func Sscanln(str string, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Token">
               <h3>
                  Token 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *ss) Token(skipSpace bool, f func(rune) bool) (tok []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="UnreadRune">
               <h3>
                  UnreadRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *readRune) UnreadRune() error</code></pre>
            </article>
            
            <article class="function" data-name="UnreadRune">
               <h3>
                  UnreadRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *ss) UnreadRune() error</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *wrapError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *wrapErrors) Unwrap() []error</code></pre>
            </article>
            
            <article class="function" data-name="Width">
               <h3>
                  Width 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) Width() (wid int, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Width">
               <h3>
                  Width 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *ss) Width() (wid int, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write implements [io.Writer] so we can call [Fprintf] on a pp (through [State]), for
recursive use in custom verbs.</p>
               
               <pre><code>func (p *pp) Write(b []byte) (ret int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteString implements [io.StringWriter] so that we can call [io.WriteString]
on a pp (through state), for efficiency.</p>
               
               <pre><code>func (p *pp) WriteString(s string) (ret int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="accept">
               <h3>
                  accept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>accept checks the next rune in the input. If it's a byte (sic) in the string, it puts it in the
buffer and returns true. Otherwise it return false.</p>
               
               <pre><code>func (s *ss) accept(ok string) bool</code></pre>
            </article>
            
            <article class="function" data-name="advance">
               <h3>
                  advance 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>advance determines whether the next characters in the input match
those of the format. It returns the number of bytes (sic) consumed
in the format. All runs of space characters in either input or
format behave as a single space. Newlines are special, though:
newlines in the format must match those in the input and vice versa.
This routine also handles the %% case. If the return value is zero,
either format starts with a % (with no following %) or the input
is empty. If it is negative, the input did not match the string.</p>
               
               <pre><code>func (s *ss) advance(format string) (i int)</code></pre>
            </article>
            
            <article class="function" data-name="argNumber">
               <h3>
                  argNumber 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>argNumber returns the next argument to evaluate, which is either the value of the passed-in
argNum or the value of the bracketed integer that begins format[i:]. It also returns
the new value of i, that is, the index of the next byte of the format to process.</p>
               
               <pre><code>func (p *pp) argNumber(argNum int, format string, i int, numArgs int) (newArgNum int, newi int, found bool)</code></pre>
            </article>
            
            <article class="function" data-name="badArgNum">
               <h3>
                  badArgNum 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) badArgNum(verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="badVerb">
               <h3>
                  badVerb 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) badVerb(verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="catchPanic">
               <h3>
                  catchPanic 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) catchPanic(arg any, verb rune, method string)</code></pre>
            </article>
            
            <article class="function" data-name="clearflags">
               <h3>
                  clearflags 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *fmt) clearflags()</code></pre>
            </article>
            
            <article class="function" data-name="complexTokens">
               <h3>
                  complexTokens 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>complexTokens returns the real and imaginary parts of the complex number starting here.
The number might be parenthesized and has the format (N+Ni) where N is a floating-point
number and there are no spaces within.</p>
               
               <pre><code>func (s *ss) complexTokens() (real string, imag string)</code></pre>
            </article>
            
            <article class="function" data-name="consume">
               <h3>
                  consume 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>consume reads the next rune in the input and reports whether it is in the ok string.
If accept is true, it puts the character into the input token.</p>
               
               <pre><code>func (s *ss) consume(ok string, accept bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="convertFloat">
               <h3>
                  convertFloat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>convertFloat converts the string to a float64value.</p>
               
               <pre><code>func (s *ss) convertFloat(str string, n int) float64</code></pre>
            </article>
            
            <article class="function" data-name="convertString">
               <h3>
                  convertString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>convertString returns the string represented by the next input characters.
The format of the input is determined by the verb.</p>
               
               <pre><code>func (s *ss) convertString(verb rune) (str string)</code></pre>
            </article>
            
            <article class="function" data-name="doPrint">
               <h3>
                  doPrint 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) doPrint(a []any)</code></pre>
            </article>
            
            <article class="function" data-name="doPrintf">
               <h3>
                  doPrintf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) doPrintf(format string, a []any)</code></pre>
            </article>
            
            <article class="function" data-name="doPrintln">
               <h3>
                  doPrintln 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>doPrintln is like doPrint but always adds a space between arguments
and a newline after the last argument.</p>
               
               <pre><code>func (p *pp) doPrintln(a []any)</code></pre>
            </article>
            
            <article class="function" data-name="doScan">
               <h3>
                  doScan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>doScan does the real work for scanning without a format string.</p>
               
               <pre><code>func (s *ss) doScan(a []any) (numProcessed int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="doScanf">
               <h3>
                  doScanf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>doScanf does the real work when scanning with a format string.
At the moment, it handles only pointers to basic types.</p>
               
               <pre><code>func (s *ss) doScanf(format string, a []any) (numProcessed int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="error">
               <h3>
                  error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *ss) error(err error)</code></pre>
            </article>
            
            <article class="function" data-name="errorHandler">
               <h3>
                  errorHandler 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>errorHandler turns local panics into error returns.</p>
               
               <pre><code>func errorHandler(errp *error)</code></pre>
            </article>
            
            <article class="function" data-name="errorString">
               <h3>
                  errorString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *ss) errorString(err string)</code></pre>
            </article>
            
            <article class="function" data-name="floatToken">
               <h3>
                  floatToken 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>floatToken returns the floating-point number starting here, no longer than swid
if the width is specified. It's not rigorous about syntax because it doesn't check that
we have at least some digits, but Atof will do that.</p>
               
               <pre><code>func (s *ss) floatToken() string</code></pre>
            </article>
            
            <article class="function" data-name="fmt0x64">
               <h3>
                  fmt0x64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmt0x64 formats a uint64 in hexadecimal and prefixes it with 0x or
not, as requested, by temporarily setting the sharp flag.</p>
               
               <pre><code>func (p *pp) fmt0x64(v uint64, leading0x bool)</code></pre>
            </article>
            
            <article class="function" data-name="fmtBool">
               <h3>
                  fmtBool 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) fmtBool(v bool, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="fmtBoolean">
               <h3>
                  fmtBoolean 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtBoolean formats a boolean.</p>
               
               <pre><code>func (f *fmt) fmtBoolean(v bool)</code></pre>
            </article>
            
            <article class="function" data-name="fmtBs">
               <h3>
                  fmtBs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtBs formats the byte slice b as if it was formatted as string with fmtS.</p>
               
               <pre><code>func (f *fmt) fmtBs(b []byte)</code></pre>
            </article>
            
            <article class="function" data-name="fmtBx">
               <h3>
                  fmtBx 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtBx formats a byte slice as a hexadecimal encoding of its bytes.</p>
               
               <pre><code>func (f *fmt) fmtBx(b []byte, digits string)</code></pre>
            </article>
            
            <article class="function" data-name="fmtBytes">
               <h3>
                  fmtBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) fmtBytes(v []byte, verb rune, typeString string)</code></pre>
            </article>
            
            <article class="function" data-name="fmtC">
               <h3>
                  fmtC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtC formats an integer as a Unicode character.
If the character is not valid Unicode, it will print '\ufffd'.</p>
               
               <pre><code>func (f *fmt) fmtC(c uint64)</code></pre>
            </article>
            
            <article class="function" data-name="fmtComplex">
               <h3>
                  fmtComplex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtComplex formats a complex number v with
r = real(v) and j = imag(v) as (r+ji) using
fmtFloat for r and j formatting.</p>
               
               <pre><code>func (p *pp) fmtComplex(v complex128, size int, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="fmtFloat">
               <h3>
                  fmtFloat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtFloat formats a float64. It assumes that verb is a valid format specifier
for strconv.AppendFloat and therefore fits into a byte.</p>
               
               <pre><code>func (f *fmt) fmtFloat(v float64, size int, verb rune, prec int)</code></pre>
            </article>
            
            <article class="function" data-name="fmtFloat">
               <h3>
                  fmtFloat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtFloat formats a float. The default precision for each verb
is specified as last argument in the call to fmt_float.</p>
               
               <pre><code>func (p *pp) fmtFloat(v float64, size int, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="fmtInteger">
               <h3>
                  fmtInteger 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtInteger formats signed and unsigned integers.</p>
               
               <pre><code>func (f *fmt) fmtInteger(u uint64, base int, isSigned bool, verb rune, digits string)</code></pre>
            </article>
            
            <article class="function" data-name="fmtInteger">
               <h3>
                  fmtInteger 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtInteger formats a signed or unsigned integer.</p>
               
               <pre><code>func (p *pp) fmtInteger(v uint64, isSigned bool, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="fmtPointer">
               <h3>
                  fmtPointer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) fmtPointer(value reflect.Value, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="fmtQ">
               <h3>
                  fmtQ 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtQ formats a string as a double-quoted, escaped Go string constant.
If f.sharp is set a raw (backquoted) string may be returned instead
if the string does not contain any control characters other than tab.</p>
               
               <pre><code>func (f *fmt) fmtQ(s string)</code></pre>
            </article>
            
            <article class="function" data-name="fmtQc">
               <h3>
                  fmtQc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtQc formats an integer as a single-quoted, escaped Go character constant.
If the character is not valid Unicode, it will print '\ufffd'.</p>
               
               <pre><code>func (f *fmt) fmtQc(c uint64)</code></pre>
            </article>
            
            <article class="function" data-name="fmtS">
               <h3>
                  fmtS 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtS formats a string.</p>
               
               <pre><code>func (f *fmt) fmtS(s string)</code></pre>
            </article>
            
            <article class="function" data-name="fmtSbx">
               <h3>
                  fmtSbx 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtSbx formats a string or byte slice as a hexadecimal encoding of its bytes.</p>
               
               <pre><code>func (f *fmt) fmtSbx(s string, b []byte, digits string)</code></pre>
            </article>
            
            <article class="function" data-name="fmtString">
               <h3>
                  fmtString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) fmtString(v string, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="fmtSx">
               <h3>
                  fmtSx 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtSx formats a string as a hexadecimal encoding of its bytes.</p>
               
               <pre><code>func (f *fmt) fmtSx(s string, digits string)</code></pre>
            </article>
            
            <article class="function" data-name="fmtUnicode">
               <h3>
                  fmtUnicode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtUnicode formats a uint64 as "U+0078" or with f.sharp set as "U+0078 'x'".</p>
               
               <pre><code>func (f *fmt) fmtUnicode(u uint64)</code></pre>
            </article>
            
            <article class="function" data-name="free">
               <h3>
                  free 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>free saves used ss structs in ssFree; avoid an allocation per invocation.</p>
               
               <pre><code>func (s *ss) free(old ssave)</code></pre>
            </article>
            
            <article class="function" data-name="free">
               <h3>
                  free 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>free saves used pp structs in ppFree; avoids an allocation per invocation.</p>
               
               <pre><code>func (p *pp) free()</code></pre>
            </article>
            
            <article class="function" data-name="getBase">
               <h3>
                  getBase 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>getBase returns the numeric base represented by the verb and its digit string.</p>
               
               <pre><code>func (s *ss) getBase(verb rune) (base int, digits string)</code></pre>
            </article>
            
            <article class="function" data-name="getField">
               <h3>
                  getField 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>getField gets the i'th field of the struct value.
If the field itself is a non-nil interface, return a value for
the thing inside the interface, not the interface itself.</p>
               
               <pre><code>func getField(v reflect.Value, i int) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="getRune">
               <h3>
                  getRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>The public method returns an error; this private one panics.
If getRune reaches EOF, the return value is EOF (-1).</p>
               
               <pre><code>func (s *ss) getRune() (r rune)</code></pre>
            </article>
            
            <article class="function" data-name="handleMethods">
               <h3>
                  handleMethods 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) handleMethods(verb rune) (handled bool)</code></pre>
            </article>
            
            <article class="function" data-name="hasX">
               <h3>
                  hasX 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func hasX(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="hexByte">
               <h3>
                  hexByte 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>hexByte returns the next hex-encoded (two-character) byte from the input.
It returns ok==false if the next bytes in the input do not encode a hex byte.
If the first byte is hex and the second is not, processing stops.</p>
               
               <pre><code>func (s *ss) hexByte() (b byte, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="hexDigit">
               <h3>
                  hexDigit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hexDigit returns the value of the hexadecimal digit.</p>
               
               <pre><code>func hexDigit(d rune) (int, bool)</code></pre>
            </article>
            
            <article class="function" data-name="hexString">
               <h3>
                  hexString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>hexString returns the space-delimited hexpair-encoded string.</p>
               
               <pre><code>func (s *ss) hexString() string</code></pre>
            </article>
            
            <article class="function" data-name="indexRune">
               <h3>
                  indexRune 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func indexRune(s string, r rune) int</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *fmt) init(buf *buffer)</code></pre>
            </article>
            
            <article class="function" data-name="intFromArg">
               <h3>
                  intFromArg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>intFromArg gets the argNumth element of a. On return, isInt reports whether the argument has integer type.</p>
               
               <pre><code>func intFromArg(a []any, argNum int) (num int, isInt bool, newArgNum int)</code></pre>
            </article>
            
            <article class="function" data-name="isSpace">
               <h3>
                  isSpace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isSpace(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="missingArg">
               <h3>
                  missingArg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) missingArg(verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="mustReadRune">
               <h3>
                  mustReadRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mustReadRune turns io.EOF into a panic(io.ErrUnexpectedEOF).
It is called in cases such as string scanning where an EOF is a
syntax error.</p>
               
               <pre><code>func (s *ss) mustReadRune() (r rune)</code></pre>
            </article>
            
            <article class="function" data-name="newPrinter">
               <h3>
                  newPrinter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newPrinter allocates a new pp struct or grabs a cached one.</p>
               
               <pre><code>func newPrinter() *pp</code></pre>
            </article>
            
            <article class="function" data-name="newScanState">
               <h3>
                  newScanState 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newScanState allocates a new ss struct or grab a cached one.</p>
               
               <pre><code>func newScanState(r io.Reader, nlIsSpace bool, nlIsEnd bool) (s *ss, old ssave)</code></pre>
            </article>
            
            <article class="function" data-name="notEOF">
               <h3>
                  notEOF 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *ss) notEOF()</code></pre>
            </article>
            
            <article class="function" data-name="notSpace">
               <h3>
                  notSpace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>notSpace is the default scanning function used in Token.</p>
               
               <pre><code>func notSpace(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="okVerb">
               <h3>
                  okVerb 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>okVerb verifies that the verb is present in the list, setting s.err appropriately if not.</p>
               
               <pre><code>func (s *ss) okVerb(verb rune, okVerbs string, typ string) bool</code></pre>
            </article>
            
            <article class="function" data-name="pad">
               <h3>
                  pad 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>pad appends b to f.buf, padded on left (!f.minus) or right (f.minus).</p>
               
               <pre><code>func (f *fmt) pad(b []byte)</code></pre>
            </article>
            
            <article class="function" data-name="padString">
               <h3>
                  padString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>padString appends s to f.buf, padded on left (!f.minus) or right (f.minus).</p>
               
               <pre><code>func (f *fmt) padString(s string)</code></pre>
            </article>
            
            <article class="function" data-name="parseArgNumber">
               <h3>
                  parseArgNumber 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseArgNumber returns the value of the bracketed number, minus 1
(explicit argument numbers are one-indexed but we want zero-indexed).
The opening bracket is known to be present at format[0].
The returned values are the index, the number of bytes to consume
up to the closing paren, if present, and whether the number parsed
ok. The bytes to consume will be 1 if no closing paren is present.</p>
               
               <pre><code>func parseArgNumber(format string) (index int, wid int, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="parsenum">
               <h3>
                  parsenum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parsenum converts ASCII to integer.  num is 0 (and isnum is false) if no number present.</p>
               
               <pre><code>func parsenum(s string, start int, end int) (num int, isnum bool, newi int)</code></pre>
            </article>
            
            <article class="function" data-name="peek">
               <h3>
                  peek 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>peek reports whether the next character is in the ok string, without consuming it.</p>
               
               <pre><code>func (s *ss) peek(ok string) bool</code></pre>
            </article>
            
            <article class="function" data-name="printArg">
               <h3>
                  printArg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) printArg(arg any, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="printValue">
               <h3>
                  printValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>printValue is similar to printArg but starts with a reflect value, not an interface{} value.
It does not handle 'p' and 'T' verbs because these should have been already handled by printArg.</p>
               
               <pre><code>func (p *pp) printValue(value reflect.Value, verb rune, depth int)</code></pre>
            </article>
            
            <article class="function" data-name="quotedString">
               <h3>
                  quotedString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>quotedString returns the double- or back-quoted string represented by the next input characters.</p>
               
               <pre><code>func (s *ss) quotedString() string</code></pre>
            </article>
            
            <article class="function" data-name="readByte">
               <h3>
                  readByte 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>readByte returns the next byte from the input, which may be
left over from a previous read if the UTF-8 was ill-formed.</p>
               
               <pre><code>func (r *readRune) readByte() (b byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="scanBasePrefix">
               <h3>
                  scanBasePrefix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>scanBasePrefix reports whether the integer begins with a base prefix
and returns the base, digit string, and whether a zero was found.
It is called only if the verb is %v.</p>
               
               <pre><code>func (s *ss) scanBasePrefix() (base int, digits string, zeroFound bool)</code></pre>
            </article>
            
            <article class="function" data-name="scanBool">
               <h3>
                  scanBool 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>scanBool returns the value of the boolean represented by the next token.</p>
               
               <pre><code>func (s *ss) scanBool(verb rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="scanComplex">
               <h3>
                  scanComplex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>scanComplex converts the next token to a complex128 value.
The atof argument is a type-specific reader for the underlying type.
If we're reading complex64, atof will parse float32s and convert them
to float64's to avoid reproducing this code for each complex type.</p>
               
               <pre><code>func (s *ss) scanComplex(verb rune, n int) complex128</code></pre>
            </article>
            
            <article class="function" data-name="scanInt">
               <h3>
                  scanInt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>scanInt returns the value of the integer represented by the next
token, checking for overflow. Any error is stored in s.err.</p>
               
               <pre><code>func (s *ss) scanInt(verb rune, bitSize int) int64</code></pre>
            </article>
            
            <article class="function" data-name="scanNumber">
               <h3>
                  scanNumber 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>scanNumber returns the numerical string with specified digits starting here.</p>
               
               <pre><code>func (s *ss) scanNumber(digits string, haveDigits bool) string</code></pre>
            </article>
            
            <article class="function" data-name="scanOne">
               <h3>
                  scanOne 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>scanOne scans a single value, deriving the scanner from the type of the argument.</p>
               
               <pre><code>func (s *ss) scanOne(verb rune, arg any)</code></pre>
            </article>
            
            <article class="function" data-name="scanPercent">
               <h3>
                  scanPercent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>scanPercent scans a literal percent character.</p>
               
               <pre><code>func (s *ss) scanPercent()</code></pre>
            </article>
            
            <article class="function" data-name="scanRune">
               <h3>
                  scanRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>scanRune returns the next rune value in the input.</p>
               
               <pre><code>func (s *ss) scanRune(bitSize int) int64</code></pre>
            </article>
            
            <article class="function" data-name="scanUint">
               <h3>
                  scanUint 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>scanUint returns the value of the unsigned integer represented
by the next token, checking for overflow. Any error is stored in s.err.</p>
               
               <pre><code>func (s *ss) scanUint(verb rune, bitSize int) uint64</code></pre>
            </article>
            
            <article class="function" data-name="token">
               <h3>
                  token 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>token returns the next space-delimited string from the input. It
skips white space. For Scanln, it stops at newlines. For Scan,
newlines are treated as spaces.</p>
               
               <pre><code>func (s *ss) token(skipSpace bool, f func(rune) bool) []byte</code></pre>
            </article>
            
            <article class="function" data-name="tooLarge">
               <h3>
                  tooLarge 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>tooLarge reports whether the magnitude of the integer is
too large to be used as a formatting width or precision.</p>
               
               <pre><code>func tooLarge(x int) bool</code></pre>
            </article>
            
            <article class="function" data-name="truncate">
               <h3>
                  truncate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>truncate truncates the byte slice b as a string of the specified precision, if present.</p>
               
               <pre><code>func (f *fmt) truncate(b []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="truncateString">
               <h3>
                  truncateString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>truncateString truncates the string s to the specified precision, if present.</p>
               
               <pre><code>func (f *fmt) truncateString(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="unknownType">
               <h3>
                  unknownType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pp) unknownType(v reflect.Value)</code></pre>
            </article>
            
            <article class="function" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *buffer) write(p []byte)</code></pre>
            </article>
            
            <article class="function" data-name="writeByte">
               <h3>
                  writeByte 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *buffer) writeByte(c byte)</code></pre>
            </article>
            
            <article class="function" data-name="writePadding">
               <h3>
                  writePadding 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writePadding generates n bytes of padding.</p>
               
               <pre><code>func (f *fmt) writePadding(n int)</code></pre>
            </article>
            
            <article class="function" data-name="writeRune">
               <h3>
                  writeRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *buffer) writeRune(r rune)</code></pre>
            </article>
            
            <article class="function" data-name="writeString">
               <h3>
                  writeString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *buffer) writeString(s string)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
