<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - fmt</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>fmt</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"errors"
"io"
"math"
"os"
"reflect"
"strconv"
"sync"
"unicode/utf8"
"errors"
"slices"
"strconv"
"unicode/utf8"
"internal/fmtsort"
"io"
"os"
"reflect"
"strconv"
"sync"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="badIndexString" data-name="badIndexString">
               <h3>
                  badIndexString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#badIndexString" class="anchor" title="Link to badIndexString">#</a>
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const badIndexString = "(BADINDEX)"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="badPrecString" data-name="badPrecString">
               <h3>
                  badPrecString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#badPrecString" class="anchor" title="Link to badPrecString">#</a>
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const badPrecString = "%!(BADPREC)"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="badWidthString" data-name="badWidthString">
               <h3>
                  badWidthString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#badWidthString" class="anchor" title="Link to badWidthString">#</a>
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const badWidthString = "%!(BADWIDTH)"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="binaryDigits" data-name="binaryDigits">
               <h3>
                  binaryDigits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#binaryDigits" class="anchor" title="Link to binaryDigits">#</a>
               </h3>
               
               <p>Numerical elements</p>
               
               <pre><code>const binaryDigits = "01"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="commaSpaceString" data-name="commaSpaceString">
               <h3>
                  commaSpaceString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#commaSpaceString" class="anchor" title="Link to commaSpaceString">#</a>
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const commaSpaceString = ", "</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="decimalDigits" data-name="decimalDigits">
               <h3>
                  decimalDigits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#decimalDigits" class="anchor" title="Link to decimalDigits">#</a>
               </h3>
               
               <p>Numerical elements</p>
               
               <pre><code>const decimalDigits = "0123456789"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="eof" data-name="eof">
               <h3>
                  eof 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#eof" class="anchor" title="Link to eof">#</a>
               </h3>
               
               <pre><code>const eof = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errBool" data-name="errBool">
               <h3>
                  errBool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errBool" class="anchor" title="Link to errBool">#</a>
               </h3>
               
               <pre><code>var errBool = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errComplex" data-name="errComplex">
               <h3>
                  errComplex 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errComplex" class="anchor" title="Link to errComplex">#</a>
               </h3>
               
               <pre><code>var errComplex = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exponent" data-name="exponent">
               <h3>
                  exponent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exponent" class="anchor" title="Link to exponent">#</a>
               </h3>
               
               <p>Numerical elements</p>
               
               <pre><code>const exponent = "eEpP"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="extraString" data-name="extraString">
               <h3>
                  extraString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#extraString" class="anchor" title="Link to extraString">#</a>
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const extraString = "%!(EXTRA "</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="floatVerbs" data-name="floatVerbs">
               <h3>
                  floatVerbs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#floatVerbs" class="anchor" title="Link to floatVerbs">#</a>
               </h3>
               
               <pre><code>const floatVerbs = "beEfFgGv"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hexadecimalDigits" data-name="hexadecimalDigits">
               <h3>
                  hexadecimalDigits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#hexadecimalDigits" class="anchor" title="Link to hexadecimalDigits">#</a>
               </h3>
               
               <p>Numerical elements</p>
               
               <pre><code>const hexadecimalDigits = "0123456789aAbBcCdDeEfF"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hugeWid" data-name="hugeWid">
               <h3>
                  hugeWid 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#hugeWid" class="anchor" title="Link to hugeWid">#</a>
               </h3>
               
               <pre><code>const hugeWid = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="intBits" data-name="intBits">
               <h3>
                  intBits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#intBits" class="anchor" title="Link to intBits">#</a>
               </h3>
               
               <pre><code>const intBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="invReflectString" data-name="invReflectString">
               <h3>
                  invReflectString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#invReflectString" class="anchor" title="Link to invReflectString">#</a>
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const invReflectString = "<invalid reflect.Value>"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ldigits" data-name="ldigits">
               <h3>
                  ldigits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ldigits" class="anchor" title="Link to ldigits">#</a>
               </h3>
               
               <pre><code>const ldigits = "0123456789abcdefx"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mapString" data-name="mapString">
               <h3>
                  mapString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#mapString" class="anchor" title="Link to mapString">#</a>
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const mapString = "map["</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="missingString" data-name="missingString">
               <h3>
                  missingString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#missingString" class="anchor" title="Link to missingString">#</a>
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const missingString = "(MISSING)"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nilAngleString" data-name="nilAngleString">
               <h3>
                  nilAngleString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#nilAngleString" class="anchor" title="Link to nilAngleString">#</a>
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const nilAngleString = "<nil>"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nilParenString" data-name="nilParenString">
               <h3>
                  nilParenString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#nilParenString" class="anchor" title="Link to nilParenString">#</a>
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const nilParenString = "(nil)"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nilString" data-name="nilString">
               <h3>
                  nilString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#nilString" class="anchor" title="Link to nilString">#</a>
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const nilString = "nil"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noVerbString" data-name="noVerbString">
               <h3>
                  noVerbString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#noVerbString" class="anchor" title="Link to noVerbString">#</a>
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const noVerbString = "%!(NOVERB)"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="octalDigits" data-name="octalDigits">
               <h3>
                  octalDigits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#octalDigits" class="anchor" title="Link to octalDigits">#</a>
               </h3>
               
               <p>Numerical elements</p>
               
               <pre><code>const octalDigits = "01234567"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="panicString" data-name="panicString">
               <h3>
                  panicString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#panicString" class="anchor" title="Link to panicString">#</a>
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const panicString = "(PANIC="</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="percentBangString" data-name="percentBangString">
               <h3>
                  percentBangString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#percentBangString" class="anchor" title="Link to percentBangString">#</a>
               </h3>
               
               <p>Strings for use with buffer.WriteString.
This is less overhead than using buffer.Write with byte arrays.</p>
               
               <pre><code>const percentBangString = "%!"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="period" data-name="period">
               <h3>
                  period 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#period" class="anchor" title="Link to period">#</a>
               </h3>
               
               <p>Numerical elements</p>
               
               <pre><code>const period = "."</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ppFree" data-name="ppFree">
               <h3>
                  ppFree 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ppFree" class="anchor" title="Link to ppFree">#</a>
               </h3>
               
               <pre><code>var ppFree = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sign" data-name="sign">
               <h3>
                  sign 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sign" class="anchor" title="Link to sign">#</a>
               </h3>
               
               <p>Numerical elements</p>
               
               <pre><code>const sign = "+-"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="signed" data-name="signed">
               <h3>
                  signed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#signed" class="anchor" title="Link to signed">#</a>
               </h3>
               
               <pre><code>const signed = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="space" data-name="space">
               <h3>
                  space 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#space" class="anchor" title="Link to space">#</a>
               </h3>
               
               <p>space is a copy of the unicode.White_Space ranges,
to avoid depending on package unicode.</p>
               
               <pre><code>var space = [][2]uint16{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ssFree" data-name="ssFree">
               <h3>
                  ssFree 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ssFree" class="anchor" title="Link to ssFree">#</a>
               </h3>
               
               <pre><code>var ssFree = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="udigits" data-name="udigits">
               <h3>
                  udigits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#udigits" class="anchor" title="Link to udigits">#</a>
               </h3>
               
               <pre><code>const udigits = "0123456789ABCDEFX"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="uintptrBits" data-name="uintptrBits">
               <h3>
                  uintptrBits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#uintptrBits" class="anchor" title="Link to uintptrBits">#</a>
               </h3>
               
               <pre><code>const uintptrBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unsigned" data-name="unsigned">
               <h3>
                  unsigned 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#unsigned" class="anchor" title="Link to unsigned">#</a>
               </h3>
               
               <pre><code>const unsigned = false</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="buffer" data-name="buffer">
               <h3>
                  buffer
                  <span class="badge type-badge">type</span>
                  <a href="#buffer" class="anchor" title="Link to buffer">#</a>
               </h3>
               
               <p>Use simple []byte instead of bytes.Buffer to avoid large dependency.</p>
               
               <pre><code>type buffer []byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="stringReader" data-name="stringReader">
               <h3>
                  stringReader
                  <span class="badge type-badge">type</span>
                  <a href="#stringReader" class="anchor" title="Link to stringReader">#</a>
               </h3>
               
               <pre><code>type stringReader string</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Formatter" data-name="Formatter">
               <h3>
                  Formatter
                  <span class="badge interface-badge">interface</span>
                  <a href="#Formatter" class="anchor" title="Link to Formatter">#</a>
               </h3>
               
               <p>Formatter is implemented by any value that has a Format method.
The implementation controls how [State] and rune are interpreted,
and may call [Sprint] or [Fprint](f) etc. to generate its output.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Formatter interface {
Format(f State, verb rune)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="GoStringer" data-name="GoStringer">
               <h3>
                  GoStringer
                  <span class="badge interface-badge">interface</span>
                  <a href="#GoStringer" class="anchor" title="Link to GoStringer">#</a>
               </h3>
               
               <p>GoStringer is implemented by any value that has a GoString method,
which defines the Go syntax for that value.
The GoString method is used to print values passed as an operand
to a %#v format.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type GoStringer interface {
GoString() string
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="ScanState" data-name="ScanState">
               <h3>
                  ScanState
                  <span class="badge interface-badge">interface</span>
                  <a href="#ScanState" class="anchor" title="Link to ScanState">#</a>
               </h3>
               
               <p>ScanState represents the scanner state passed to custom scanners.
Scanners may do rune-at-a-time scanning or ask the ScanState
to discover the next space-delimited token.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ScanState interface {
ReadRune() (r rune, size int, err error)
UnreadRune() error
SkipSpace()
Token(skipSpace bool, f func(rune) bool) (token []byte, err error)
Width() (wid int, ok bool)
Read(buf []byte) (n int, err error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Scanner" data-name="Scanner">
               <h3>
                  Scanner
                  <span class="badge interface-badge">interface</span>
                  <a href="#Scanner" class="anchor" title="Link to Scanner">#</a>
               </h3>
               
               <p>Scanner is implemented by any value that has a Scan method, which scans
the input for the representation of a value and stores the result in the
receiver, which must be a pointer to be useful. The Scan method is called
for any argument to [Scan], [Scanf], or [Scanln] that implements it.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Scanner interface {
Scan(state ScanState, verb rune) error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="State" data-name="State">
               <h3>
                  State
                  <span class="badge interface-badge">interface</span>
                  <a href="#State" class="anchor" title="Link to State">#</a>
               </h3>
               
               <p>State represents the printer state passed to custom formatters.
It provides access to the [io.Writer] interface plus information about
the flags and options for the operand's format specifier.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type State interface {
Write(b []byte) (n int, err error)
Width() (wid int, ok bool)
Precision() (prec int, ok bool)
Flag(c int) bool
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Stringer" data-name="Stringer">
               <h3>
                  Stringer
                  <span class="badge interface-badge">interface</span>
                  <a href="#Stringer" class="anchor" title="Link to Stringer">#</a>
               </h3>
               
               <p>Stringer is implemented by any value that has a String method,
which defines the “native” format for that value.
The String method is used to print values passed as an operand
to any format that accepts a string or to an unformatted printer
such as [Print].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Stringer interface {
String() string
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="fmt" data-name="fmt">
               <h3>
                  fmt
                  <span class="badge">struct</span>
                  <a href="#fmt" class="anchor" title="Link to fmt">#</a>
               </h3>
               
               <p>A fmt is the raw formatter used by Printf etc.
It prints into a buffer that must be set up separately.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fmt struct {
buf *buffer
fmtFlags
wid int
prec int
intbuf [68]byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fmtFlags" data-name="fmtFlags">
               <h3>
                  fmtFlags
                  <span class="badge">struct</span>
                  <a href="#fmtFlags" class="anchor" title="Link to fmtFlags">#</a>
               </h3>
               
               <p>flags placed in a separate struct for easy clearing.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fmtFlags struct {
widPresent bool
precPresent bool
minus bool
plus bool
sharp bool
space bool
zero bool
plusV bool
sharpV bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pp" data-name="pp">
               <h3>
                  pp
                  <span class="badge">struct</span>
                  <a href="#pp" class="anchor" title="Link to pp">#</a>
               </h3>
               
               <p>pp is used to store a printer's state and is reused with sync.Pool to avoid allocations.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pp struct {
buf buffer
arg any
value reflect.Value
fmt fmt
reordered bool
goodArgNum bool
panicking bool
erroring bool
wrapErrs bool
wrappedErrs []int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="readRune" data-name="readRune">
               <h3>
                  readRune
                  <span class="badge">struct</span>
                  <a href="#readRune" class="anchor" title="Link to readRune">#</a>
               </h3>
               
               <p>readRune is a structure to enable reading UTF-8 encoded code points
from an io.Reader. It is used if the Reader given to the scanner does
not already implement io.RuneScanner.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type readRune struct {
reader io.Reader
buf [utf8.UTFMax]byte
pending int
pendBuf [utf8.UTFMax]byte
peekRune rune
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="scanError" data-name="scanError">
               <h3>
                  scanError
                  <span class="badge">struct</span>
                  <a href="#scanError" class="anchor" title="Link to scanError">#</a>
               </h3>
               
               <p>scanError represents an error generated by the scanning software.
It's used as a unique signature to identify such errors when recovering.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type scanError struct {
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ss" data-name="ss">
               <h3>
                  ss
                  <span class="badge">struct</span>
                  <a href="#ss" class="anchor" title="Link to ss">#</a>
               </h3>
               
               <p>ss is the internal implementation of ScanState.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ss struct {
rs io.RuneScanner
buf buffer
count int
atEOF bool
ssave
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ssave" data-name="ssave">
               <h3>
                  ssave
                  <span class="badge">struct</span>
                  <a href="#ssave" class="anchor" title="Link to ssave">#</a>
               </h3>
               
               <p>ssave holds the parts of ss that need to be
saved and restored on recursive scans.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ssave struct {
validSave bool
nlIsEnd bool
nlIsSpace bool
argLimit int
limit int
maxWid int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="wrapError" data-name="wrapError">
               <h3>
                  wrapError
                  <span class="badge">struct</span>
                  <a href="#wrapError" class="anchor" title="Link to wrapError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type wrapError struct {
msg string
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="wrapErrors" data-name="wrapErrors">
               <h3>
                  wrapErrors
                  <span class="badge">struct</span>
                  <a href="#wrapErrors" class="anchor" title="Link to wrapErrors">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type wrapErrors struct {
msg string
errs []error
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Append" data-name="Append">
               <h3>
                  Append 
                  <span class="badge">function</span>
                  
                  <a href="#Append" class="anchor" title="Link to Append">#</a>
               </h3>
               
               <p>Append formats using the default formats for its operands, appends the result to
the byte slice, and returns the updated slice.</p>
               
               <pre><code>func Append(b []byte, a ...any) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Appendf" data-name="Appendf">
               <h3>
                  Appendf 
                  <span class="badge">function</span>
                  
                  <a href="#Appendf" class="anchor" title="Link to Appendf">#</a>
               </h3>
               
               <p>Appendf formats according to a format specifier, appends the result to the byte
slice, and returns the updated slice.</p>
               
               <pre><code>func Appendf(b []byte, format string, a ...any) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Appendln" data-name="Appendln">
               <h3>
                  Appendln 
                  <span class="badge">function</span>
                  
                  <a href="#Appendln" class="anchor" title="Link to Appendln">#</a>
               </h3>
               
               <p>Appendln formats using the default formats for its operands, appends the result
to the byte slice, and returns the updated slice. Spaces are always added
between operands and a newline is appended.</p>
               
               <pre><code>func Appendln(b []byte, a ...any) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *wrapError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *wrapErrors) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Errorf" data-name="Errorf">
               <h3>
                  Errorf 
                  <span class="badge">function</span>
                  
                  <a href="#Errorf" class="anchor" title="Link to Errorf">#</a>
               </h3>
               
               <p>Errorf formats according to a format specifier and returns the string as a
value that satisfies error.
If the format specifier includes a %w verb with an error operand,
the returned error will implement an Unwrap method returning the operand.
If there is more than one %w verb, the returned error will implement an
Unwrap method returning a []error containing all the %w operands in the
order they appear in the arguments.
It is invalid to supply the %w verb with an operand that does not implement
the error interface. The %w verb is otherwise a synonym for %v.</p>
               
               <pre><code>func Errorf(format string, a ...any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Flag" data-name="Flag">
               <h3>
                  Flag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Flag" class="anchor" title="Link to Flag">#</a>
               </h3>
               
               <pre><code>func (p *pp) Flag(b int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FormatString" data-name="FormatString">
               <h3>
                  FormatString 
                  <span class="badge">function</span>
                  
                  <a href="#FormatString" class="anchor" title="Link to FormatString">#</a>
               </h3>
               
               <p>FormatString returns a string representing the fully qualified formatting
directive captured by the [State], followed by the argument verb. ([State] does not
itself contain the verb.) The result has a leading percent sign followed by any
flags, the width, and the precision. Missing flags, width, and precision are
omitted. This function allows a [Formatter] to reconstruct the original
directive triggering the call to Format.</p>
               
               <pre><code>func FormatString(state State, verb rune) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fprint" data-name="Fprint">
               <h3>
                  Fprint 
                  <span class="badge">function</span>
                  
                  <a href="#Fprint" class="anchor" title="Link to Fprint">#</a>
               </h3>
               
               <p>Fprint formats using the default formats for its operands and writes to w.
Spaces are added between operands when neither is a string.
It returns the number of bytes written and any write error encountered.</p>
               
               <pre><code>func Fprint(w io.Writer, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fprintf" data-name="Fprintf">
               <h3>
                  Fprintf 
                  <span class="badge">function</span>
                  
                  <a href="#Fprintf" class="anchor" title="Link to Fprintf">#</a>
               </h3>
               
               <p>Fprintf formats according to a format specifier and writes to w.
It returns the number of bytes written and any write error encountered.</p>
               
               <pre><code>func Fprintf(w io.Writer, format string, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fprintln" data-name="Fprintln">
               <h3>
                  Fprintln 
                  <span class="badge">function</span>
                  
                  <a href="#Fprintln" class="anchor" title="Link to Fprintln">#</a>
               </h3>
               
               <p>Fprintln formats using the default formats for its operands and writes to w.
Spaces are always added between operands and a newline is appended.
It returns the number of bytes written and any write error encountered.</p>
               
               <pre><code>func Fprintln(w io.Writer, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fscan" data-name="Fscan">
               <h3>
                  Fscan 
                  <span class="badge">function</span>
                  
                  <a href="#Fscan" class="anchor" title="Link to Fscan">#</a>
               </h3>
               
               <p>Fscan scans text read from r, storing successive space-separated
values into successive arguments. Newlines count as space. It
returns the number of items successfully scanned. If that is less
than the number of arguments, err will report why.</p>
               
               <pre><code>func Fscan(r io.Reader, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fscanf" data-name="Fscanf">
               <h3>
                  Fscanf 
                  <span class="badge">function</span>
                  
                  <a href="#Fscanf" class="anchor" title="Link to Fscanf">#</a>
               </h3>
               
               <p>Fscanf scans text read from r, storing successive space-separated
values into successive arguments as determined by the format. It
returns the number of items successfully parsed.
Newlines in the input must match newlines in the format.</p>
               
               <pre><code>func Fscanf(r io.Reader, format string, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fscanln" data-name="Fscanln">
               <h3>
                  Fscanln 
                  <span class="badge">function</span>
                  
                  <a href="#Fscanln" class="anchor" title="Link to Fscanln">#</a>
               </h3>
               
               <p>Fscanln is similar to [Fscan], but stops scanning at a newline and
after the final item there must be a newline or EOF.</p>
               
               <pre><code>func Fscanln(r io.Reader, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Precision" data-name="Precision">
               <h3>
                  Precision 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Precision" class="anchor" title="Link to Precision">#</a>
               </h3>
               
               <pre><code>func (p *pp) Precision() (prec int, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Print" data-name="Print">
               <h3>
                  Print 
                  <span class="badge">function</span>
                  
                  <a href="#Print" class="anchor" title="Link to Print">#</a>
               </h3>
               
               <p>Print formats using the default formats for its operands and writes to standard output.
Spaces are added between operands when neither is a string.
It returns the number of bytes written and any write error encountered.</p>
               
               <pre><code>func Print(a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Printf" data-name="Printf">
               <h3>
                  Printf 
                  <span class="badge">function</span>
                  
                  <a href="#Printf" class="anchor" title="Link to Printf">#</a>
               </h3>
               
               <p>Printf formats according to a format specifier and writes to standard output.
It returns the number of bytes written and any write error encountered.</p>
               
               <pre><code>func Printf(format string, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Println" data-name="Println">
               <h3>
                  Println 
                  <span class="badge">function</span>
                  
                  <a href="#Println" class="anchor" title="Link to Println">#</a>
               </h3>
               
               <p>Println formats using the default formats for its operands and writes to standard output.
Spaces are always added between operands and a newline is appended.
It returns the number of bytes written and any write error encountered.</p>
               
               <pre><code>func Println(a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <p>The Read method is only in ScanState so that ScanState
satisfies io.Reader. It will never be called when used as
intended, so there is no need to make it actually work.</p>
               
               <pre><code>func (s *ss) Read(buf []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (r *stringReader) Read(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadRune" data-name="ReadRune">
               <h3>
                  ReadRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadRune" class="anchor" title="Link to ReadRune">#</a>
               </h3>
               
               <pre><code>func (s *ss) ReadRune() (r rune, size int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadRune" data-name="ReadRune">
               <h3>
                  ReadRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadRune" class="anchor" title="Link to ReadRune">#</a>
               </h3>
               
               <p>ReadRune returns the next UTF-8 encoded code point from the
io.Reader inside r.</p>
               
               <pre><code>func (r *readRune) ReadRune() (rr rune, size int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Scan" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge">function</span>
                  
                  <a href="#Scan" class="anchor" title="Link to Scan">#</a>
               </h3>
               
               <p>Scan scans text read from standard input, storing successive
space-separated values into successive arguments. Newlines count
as space. It returns the number of items successfully scanned.
If that is less than the number of arguments, err will report why.</p>
               
               <pre><code>func Scan(a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Scanf" data-name="Scanf">
               <h3>
                  Scanf 
                  <span class="badge">function</span>
                  
                  <a href="#Scanf" class="anchor" title="Link to Scanf">#</a>
               </h3>
               
               <p>Scanf scans text read from standard input, storing successive
space-separated values into successive arguments as determined by
the format. It returns the number of items successfully scanned.
If that is less than the number of arguments, err will report why.
Newlines in the input must match newlines in the format.
The one exception: the verb %c always scans the next rune in the
input, even if it is a space (or tab etc.) or newline.</p>
               
               <pre><code>func Scanf(format string, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Scanln" data-name="Scanln">
               <h3>
                  Scanln 
                  <span class="badge">function</span>
                  
                  <a href="#Scanln" class="anchor" title="Link to Scanln">#</a>
               </h3>
               
               <p>Scanln is similar to [Scan], but stops scanning at a newline and
after the final item there must be a newline or EOF.</p>
               
               <pre><code>func Scanln(a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SkipSpace" data-name="SkipSpace">
               <h3>
                  SkipSpace 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SkipSpace" class="anchor" title="Link to SkipSpace">#</a>
               </h3>
               
               <p>SkipSpace provides Scan methods the ability to skip space and newline
characters in keeping with the current scanning mode set by format strings
and [Scan]/[Scanln].</p>
               
               <pre><code>func (s *ss) SkipSpace()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sprint" data-name="Sprint">
               <h3>
                  Sprint 
                  <span class="badge">function</span>
                  
                  <a href="#Sprint" class="anchor" title="Link to Sprint">#</a>
               </h3>
               
               <p>Sprint formats using the default formats for its operands and returns the resulting string.
Spaces are added between operands when neither is a string.</p>
               
               <pre><code>func Sprint(a ...any) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sprintf" data-name="Sprintf">
               <h3>
                  Sprintf 
                  <span class="badge">function</span>
                  
                  <a href="#Sprintf" class="anchor" title="Link to Sprintf">#</a>
               </h3>
               
               <p>Sprintf formats according to a format specifier and returns the resulting string.</p>
               
               <pre><code>func Sprintf(format string, a ...any) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sprintln" data-name="Sprintln">
               <h3>
                  Sprintln 
                  <span class="badge">function</span>
                  
                  <a href="#Sprintln" class="anchor" title="Link to Sprintln">#</a>
               </h3>
               
               <p>Sprintln formats using the default formats for its operands and returns the resulting string.
Spaces are always added between operands and a newline is appended.</p>
               
               <pre><code>func Sprintln(a ...any) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sscan" data-name="Sscan">
               <h3>
                  Sscan 
                  <span class="badge">function</span>
                  
                  <a href="#Sscan" class="anchor" title="Link to Sscan">#</a>
               </h3>
               
               <p>Sscan scans the argument string, storing successive space-separated
values into successive arguments. Newlines count as space. It
returns the number of items successfully scanned. If that is less
than the number of arguments, err will report why.</p>
               
               <pre><code>func Sscan(str string, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sscanf" data-name="Sscanf">
               <h3>
                  Sscanf 
                  <span class="badge">function</span>
                  
                  <a href="#Sscanf" class="anchor" title="Link to Sscanf">#</a>
               </h3>
               
               <p>Sscanf scans the argument string, storing successive space-separated
values into successive arguments as determined by the format. It
returns the number of items successfully parsed.
Newlines in the input must match newlines in the format.</p>
               
               <pre><code>func Sscanf(str string, format string, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sscanln" data-name="Sscanln">
               <h3>
                  Sscanln 
                  <span class="badge">function</span>
                  
                  <a href="#Sscanln" class="anchor" title="Link to Sscanln">#</a>
               </h3>
               
               <p>Sscanln is similar to [Sscan], but stops scanning at a newline and
after the final item there must be a newline or EOF.</p>
               
               <pre><code>func Sscanln(str string, a ...any) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Token" data-name="Token">
               <h3>
                  Token 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Token" class="anchor" title="Link to Token">#</a>
               </h3>
               
               <pre><code>func (s *ss) Token(skipSpace bool, f func(rune) bool) (tok []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnreadRune" data-name="UnreadRune">
               <h3>
                  UnreadRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnreadRune" class="anchor" title="Link to UnreadRune">#</a>
               </h3>
               
               <pre><code>func (r *readRune) UnreadRune() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnreadRune" data-name="UnreadRune">
               <h3>
                  UnreadRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnreadRune" class="anchor" title="Link to UnreadRune">#</a>
               </h3>
               
               <pre><code>func (s *ss) UnreadRune() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code>func (e *wrapError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code>func (e *wrapErrors) Unwrap() []error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Width" data-name="Width">
               <h3>
                  Width 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Width" class="anchor" title="Link to Width">#</a>
               </h3>
               
               <pre><code>func (p *pp) Width() (wid int, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Width" data-name="Width">
               <h3>
                  Width 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Width" class="anchor" title="Link to Width">#</a>
               </h3>
               
               <pre><code>func (s *ss) Width() (wid int, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write implements [io.Writer] so we can call [Fprintf] on a pp (through [State]), for
recursive use in custom verbs.</p>
               
               <pre><code>func (p *pp) Write(b []byte) (ret int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteString" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteString" class="anchor" title="Link to WriteString">#</a>
               </h3>
               
               <p>WriteString implements [io.StringWriter] so that we can call [io.WriteString]
on a pp (through state), for efficiency.</p>
               
               <pre><code>func (p *pp) WriteString(s string) (ret int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="accept" data-name="accept">
               <h3>
                  accept 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#accept" class="anchor" title="Link to accept">#</a>
               </h3>
               
               <p>accept checks the next rune in the input. If it's a byte (sic) in the string, it puts it in the
buffer and returns true. Otherwise it return false.</p>
               
               <pre><code>func (s *ss) accept(ok string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="advance" data-name="advance">
               <h3>
                  advance 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#advance" class="anchor" title="Link to advance">#</a>
               </h3>
               
               <p>advance determines whether the next characters in the input match
those of the format. It returns the number of bytes (sic) consumed
in the format. All runs of space characters in either input or
format behave as a single space. Newlines are special, though:
newlines in the format must match those in the input and vice versa.
This routine also handles the %% case. If the return value is zero,
either format starts with a % (with no following %) or the input
is empty. If it is negative, the input did not match the string.</p>
               
               <pre><code>func (s *ss) advance(format string) (i int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="argNumber" data-name="argNumber">
               <h3>
                  argNumber 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#argNumber" class="anchor" title="Link to argNumber">#</a>
               </h3>
               
               <p>argNumber returns the next argument to evaluate, which is either the value of the passed-in
argNum or the value of the bracketed integer that begins format[i:]. It also returns
the new value of i, that is, the index of the next byte of the format to process.</p>
               
               <pre><code>func (p *pp) argNumber(argNum int, format string, i int, numArgs int) (newArgNum int, newi int, found bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badArgNum" data-name="badArgNum">
               <h3>
                  badArgNum 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#badArgNum" class="anchor" title="Link to badArgNum">#</a>
               </h3>
               
               <pre><code>func (p *pp) badArgNum(verb rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badVerb" data-name="badVerb">
               <h3>
                  badVerb 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#badVerb" class="anchor" title="Link to badVerb">#</a>
               </h3>
               
               <pre><code>func (p *pp) badVerb(verb rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="catchPanic" data-name="catchPanic">
               <h3>
                  catchPanic 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#catchPanic" class="anchor" title="Link to catchPanic">#</a>
               </h3>
               
               <pre><code>func (p *pp) catchPanic(arg any, verb rune, method string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clearflags" data-name="clearflags">
               <h3>
                  clearflags 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#clearflags" class="anchor" title="Link to clearflags">#</a>
               </h3>
               
               <pre><code>func (f *fmt) clearflags()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="complexTokens" data-name="complexTokens">
               <h3>
                  complexTokens 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#complexTokens" class="anchor" title="Link to complexTokens">#</a>
               </h3>
               
               <p>complexTokens returns the real and imaginary parts of the complex number starting here.
The number might be parenthesized and has the format (N+Ni) where N is a floating-point
number and there are no spaces within.</p>
               
               <pre><code>func (s *ss) complexTokens() (real string, imag string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="consume" data-name="consume">
               <h3>
                  consume 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#consume" class="anchor" title="Link to consume">#</a>
               </h3>
               
               <p>consume reads the next rune in the input and reports whether it is in the ok string.
If accept is true, it puts the character into the input token.</p>
               
               <pre><code>func (s *ss) consume(ok string, accept bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convertFloat" data-name="convertFloat">
               <h3>
                  convertFloat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#convertFloat" class="anchor" title="Link to convertFloat">#</a>
               </h3>
               
               <p>convertFloat converts the string to a float64value.</p>
               
               <pre><code>func (s *ss) convertFloat(str string, n int) float64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convertString" data-name="convertString">
               <h3>
                  convertString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#convertString" class="anchor" title="Link to convertString">#</a>
               </h3>
               
               <p>convertString returns the string represented by the next input characters.
The format of the input is determined by the verb.</p>
               
               <pre><code>func (s *ss) convertString(verb rune) (str string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doPrint" data-name="doPrint">
               <h3>
                  doPrint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doPrint" class="anchor" title="Link to doPrint">#</a>
               </h3>
               
               <pre><code>func (p *pp) doPrint(a []any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doPrintf" data-name="doPrintf">
               <h3>
                  doPrintf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doPrintf" class="anchor" title="Link to doPrintf">#</a>
               </h3>
               
               <pre><code>func (p *pp) doPrintf(format string, a []any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doPrintln" data-name="doPrintln">
               <h3>
                  doPrintln 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doPrintln" class="anchor" title="Link to doPrintln">#</a>
               </h3>
               
               <p>doPrintln is like doPrint but always adds a space between arguments
and a newline after the last argument.</p>
               
               <pre><code>func (p *pp) doPrintln(a []any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doScan" data-name="doScan">
               <h3>
                  doScan 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doScan" class="anchor" title="Link to doScan">#</a>
               </h3>
               
               <p>doScan does the real work for scanning without a format string.</p>
               
               <pre><code>func (s *ss) doScan(a []any) (numProcessed int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doScanf" data-name="doScanf">
               <h3>
                  doScanf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doScanf" class="anchor" title="Link to doScanf">#</a>
               </h3>
               
               <p>doScanf does the real work when scanning with a format string.
At the moment, it handles only pointers to basic types.</p>
               
               <pre><code>func (s *ss) doScanf(format string, a []any) (numProcessed int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="error" data-name="error">
               <h3>
                  error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#error" class="anchor" title="Link to error">#</a>
               </h3>
               
               <pre><code>func (s *ss) error(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errorHandler" data-name="errorHandler">
               <h3>
                  errorHandler 
                  <span class="badge">function</span>
                  
                  <a href="#errorHandler" class="anchor" title="Link to errorHandler">#</a>
               </h3>
               
               <p>errorHandler turns local panics into error returns.</p>
               
               <pre><code>func errorHandler(errp *error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errorString" data-name="errorString">
               <h3>
                  errorString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#errorString" class="anchor" title="Link to errorString">#</a>
               </h3>
               
               <pre><code>func (s *ss) errorString(err string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="floatToken" data-name="floatToken">
               <h3>
                  floatToken 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#floatToken" class="anchor" title="Link to floatToken">#</a>
               </h3>
               
               <p>floatToken returns the floating-point number starting here, no longer than swid
if the width is specified. It's not rigorous about syntax because it doesn't check that
we have at least some digits, but Atof will do that.</p>
               
               <pre><code>func (s *ss) floatToken() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmt0x64" data-name="fmt0x64">
               <h3>
                  fmt0x64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmt0x64" class="anchor" title="Link to fmt0x64">#</a>
               </h3>
               
               <p>fmt0x64 formats a uint64 in hexadecimal and prefixes it with 0x or
not, as requested, by temporarily setting the sharp flag.</p>
               
               <pre><code>func (p *pp) fmt0x64(v uint64, leading0x bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtBool" data-name="fmtBool">
               <h3>
                  fmtBool 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtBool" class="anchor" title="Link to fmtBool">#</a>
               </h3>
               
               <pre><code>func (p *pp) fmtBool(v bool, verb rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtBoolean" data-name="fmtBoolean">
               <h3>
                  fmtBoolean 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtBoolean" class="anchor" title="Link to fmtBoolean">#</a>
               </h3>
               
               <p>fmtBoolean formats a boolean.</p>
               
               <pre><code>func (f *fmt) fmtBoolean(v bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtBs" data-name="fmtBs">
               <h3>
                  fmtBs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtBs" class="anchor" title="Link to fmtBs">#</a>
               </h3>
               
               <p>fmtBs formats the byte slice b as if it was formatted as string with fmtS.</p>
               
               <pre><code>func (f *fmt) fmtBs(b []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtBx" data-name="fmtBx">
               <h3>
                  fmtBx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtBx" class="anchor" title="Link to fmtBx">#</a>
               </h3>
               
               <p>fmtBx formats a byte slice as a hexadecimal encoding of its bytes.</p>
               
               <pre><code>func (f *fmt) fmtBx(b []byte, digits string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtBytes" data-name="fmtBytes">
               <h3>
                  fmtBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtBytes" class="anchor" title="Link to fmtBytes">#</a>
               </h3>
               
               <pre><code>func (p *pp) fmtBytes(v []byte, verb rune, typeString string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtC" data-name="fmtC">
               <h3>
                  fmtC 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtC" class="anchor" title="Link to fmtC">#</a>
               </h3>
               
               <p>fmtC formats an integer as a Unicode character.
If the character is not valid Unicode, it will print '\ufffd'.</p>
               
               <pre><code>func (f *fmt) fmtC(c uint64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtComplex" data-name="fmtComplex">
               <h3>
                  fmtComplex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtComplex" class="anchor" title="Link to fmtComplex">#</a>
               </h3>
               
               <p>fmtComplex formats a complex number v with
r = real(v) and j = imag(v) as (r+ji) using
fmtFloat for r and j formatting.</p>
               
               <pre><code>func (p *pp) fmtComplex(v complex128, size int, verb rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtFloat" data-name="fmtFloat">
               <h3>
                  fmtFloat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtFloat" class="anchor" title="Link to fmtFloat">#</a>
               </h3>
               
               <p>fmtFloat formats a float64. It assumes that verb is a valid format specifier
for strconv.AppendFloat and therefore fits into a byte.</p>
               
               <pre><code>func (f *fmt) fmtFloat(v float64, size int, verb rune, prec int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtFloat" data-name="fmtFloat">
               <h3>
                  fmtFloat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtFloat" class="anchor" title="Link to fmtFloat">#</a>
               </h3>
               
               <p>fmtFloat formats a float. The default precision for each verb
is specified as last argument in the call to fmt_float.</p>
               
               <pre><code>func (p *pp) fmtFloat(v float64, size int, verb rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtInteger" data-name="fmtInteger">
               <h3>
                  fmtInteger 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtInteger" class="anchor" title="Link to fmtInteger">#</a>
               </h3>
               
               <p>fmtInteger formats signed and unsigned integers.</p>
               
               <pre><code>func (f *fmt) fmtInteger(u uint64, base int, isSigned bool, verb rune, digits string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtInteger" data-name="fmtInteger">
               <h3>
                  fmtInteger 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtInteger" class="anchor" title="Link to fmtInteger">#</a>
               </h3>
               
               <p>fmtInteger formats a signed or unsigned integer.</p>
               
               <pre><code>func (p *pp) fmtInteger(v uint64, isSigned bool, verb rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtPointer" data-name="fmtPointer">
               <h3>
                  fmtPointer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtPointer" class="anchor" title="Link to fmtPointer">#</a>
               </h3>
               
               <pre><code>func (p *pp) fmtPointer(value reflect.Value, verb rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtQ" data-name="fmtQ">
               <h3>
                  fmtQ 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtQ" class="anchor" title="Link to fmtQ">#</a>
               </h3>
               
               <p>fmtQ formats a string as a double-quoted, escaped Go string constant.
If f.sharp is set a raw (backquoted) string may be returned instead
if the string does not contain any control characters other than tab.</p>
               
               <pre><code>func (f *fmt) fmtQ(s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtQc" data-name="fmtQc">
               <h3>
                  fmtQc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtQc" class="anchor" title="Link to fmtQc">#</a>
               </h3>
               
               <p>fmtQc formats an integer as a single-quoted, escaped Go character constant.
If the character is not valid Unicode, it will print '\ufffd'.</p>
               
               <pre><code>func (f *fmt) fmtQc(c uint64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtS" data-name="fmtS">
               <h3>
                  fmtS 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtS" class="anchor" title="Link to fmtS">#</a>
               </h3>
               
               <p>fmtS formats a string.</p>
               
               <pre><code>func (f *fmt) fmtS(s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtSbx" data-name="fmtSbx">
               <h3>
                  fmtSbx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtSbx" class="anchor" title="Link to fmtSbx">#</a>
               </h3>
               
               <p>fmtSbx formats a string or byte slice as a hexadecimal encoding of its bytes.</p>
               
               <pre><code>func (f *fmt) fmtSbx(s string, b []byte, digits string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtString" data-name="fmtString">
               <h3>
                  fmtString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtString" class="anchor" title="Link to fmtString">#</a>
               </h3>
               
               <pre><code>func (p *pp) fmtString(v string, verb rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtSx" data-name="fmtSx">
               <h3>
                  fmtSx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtSx" class="anchor" title="Link to fmtSx">#</a>
               </h3>
               
               <p>fmtSx formats a string as a hexadecimal encoding of its bytes.</p>
               
               <pre><code>func (f *fmt) fmtSx(s string, digits string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtUnicode" data-name="fmtUnicode">
               <h3>
                  fmtUnicode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtUnicode" class="anchor" title="Link to fmtUnicode">#</a>
               </h3>
               
               <p>fmtUnicode formats a uint64 as "U+0078" or with f.sharp set as "U+0078 'x'".</p>
               
               <pre><code>func (f *fmt) fmtUnicode(u uint64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="free" data-name="free">
               <h3>
                  free 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#free" class="anchor" title="Link to free">#</a>
               </h3>
               
               <p>free saves used ss structs in ssFree; avoid an allocation per invocation.</p>
               
               <pre><code>func (s *ss) free(old ssave)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="free" data-name="free">
               <h3>
                  free 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#free" class="anchor" title="Link to free">#</a>
               </h3>
               
               <p>free saves used pp structs in ppFree; avoids an allocation per invocation.</p>
               
               <pre><code>func (p *pp) free()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getBase" data-name="getBase">
               <h3>
                  getBase 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getBase" class="anchor" title="Link to getBase">#</a>
               </h3>
               
               <p>getBase returns the numeric base represented by the verb and its digit string.</p>
               
               <pre><code>func (s *ss) getBase(verb rune) (base int, digits string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getField" data-name="getField">
               <h3>
                  getField 
                  <span class="badge">function</span>
                  
                  <a href="#getField" class="anchor" title="Link to getField">#</a>
               </h3>
               
               <p>getField gets the i'th field of the struct value.
If the field itself is a non-nil interface, return a value for
the thing inside the interface, not the interface itself.</p>
               
               <pre><code>func getField(v reflect.Value, i int) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getRune" data-name="getRune">
               <h3>
                  getRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getRune" class="anchor" title="Link to getRune">#</a>
               </h3>
               
               <p>The public method returns an error; this private one panics.
If getRune reaches EOF, the return value is EOF (-1).</p>
               
               <pre><code>func (s *ss) getRune() (r rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handleMethods" data-name="handleMethods">
               <h3>
                  handleMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handleMethods" class="anchor" title="Link to handleMethods">#</a>
               </h3>
               
               <pre><code>func (p *pp) handleMethods(verb rune) (handled bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasX" data-name="hasX">
               <h3>
                  hasX 
                  <span class="badge">function</span>
                  
                  <a href="#hasX" class="anchor" title="Link to hasX">#</a>
               </h3>
               
               <pre><code>func hasX(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hexByte" data-name="hexByte">
               <h3>
                  hexByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hexByte" class="anchor" title="Link to hexByte">#</a>
               </h3>
               
               <p>hexByte returns the next hex-encoded (two-character) byte from the input.
It returns ok==false if the next bytes in the input do not encode a hex byte.
If the first byte is hex and the second is not, processing stops.</p>
               
               <pre><code>func (s *ss) hexByte() (b byte, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hexDigit" data-name="hexDigit">
               <h3>
                  hexDigit 
                  <span class="badge">function</span>
                  
                  <a href="#hexDigit" class="anchor" title="Link to hexDigit">#</a>
               </h3>
               
               <p>hexDigit returns the value of the hexadecimal digit.</p>
               
               <pre><code>func hexDigit(d rune) (int, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hexString" data-name="hexString">
               <h3>
                  hexString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hexString" class="anchor" title="Link to hexString">#</a>
               </h3>
               
               <p>hexString returns the space-delimited hexpair-encoded string.</p>
               
               <pre><code>func (s *ss) hexString() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indexRune" data-name="indexRune">
               <h3>
                  indexRune 
                  <span class="badge">function</span>
                  
                  <a href="#indexRune" class="anchor" title="Link to indexRune">#</a>
               </h3>
               
               <pre><code>func indexRune(s string, r rune) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code>func (f *fmt) init(buf *buffer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="intFromArg" data-name="intFromArg">
               <h3>
                  intFromArg 
                  <span class="badge">function</span>
                  
                  <a href="#intFromArg" class="anchor" title="Link to intFromArg">#</a>
               </h3>
               
               <p>intFromArg gets the argNumth element of a. On return, isInt reports whether the argument has integer type.</p>
               
               <pre><code>func intFromArg(a []any, argNum int) (num int, isInt bool, newArgNum int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isSpace" data-name="isSpace">
               <h3>
                  isSpace 
                  <span class="badge">function</span>
                  
                  <a href="#isSpace" class="anchor" title="Link to isSpace">#</a>
               </h3>
               
               <pre><code>func isSpace(r rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="missingArg" data-name="missingArg">
               <h3>
                  missingArg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#missingArg" class="anchor" title="Link to missingArg">#</a>
               </h3>
               
               <pre><code>func (p *pp) missingArg(verb rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustReadRune" data-name="mustReadRune">
               <h3>
                  mustReadRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mustReadRune" class="anchor" title="Link to mustReadRune">#</a>
               </h3>
               
               <p>mustReadRune turns io.EOF into a panic(io.ErrUnexpectedEOF).
It is called in cases such as string scanning where an EOF is a
syntax error.</p>
               
               <pre><code>func (s *ss) mustReadRune() (r rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newPrinter" data-name="newPrinter">
               <h3>
                  newPrinter 
                  <span class="badge">function</span>
                  
                  <a href="#newPrinter" class="anchor" title="Link to newPrinter">#</a>
               </h3>
               
               <p>newPrinter allocates a new pp struct or grabs a cached one.</p>
               
               <pre><code>func newPrinter() *pp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newScanState" data-name="newScanState">
               <h3>
                  newScanState 
                  <span class="badge">function</span>
                  
                  <a href="#newScanState" class="anchor" title="Link to newScanState">#</a>
               </h3>
               
               <p>newScanState allocates a new ss struct or grab a cached one.</p>
               
               <pre><code>func newScanState(r io.Reader, nlIsSpace bool, nlIsEnd bool) (s *ss, old ssave)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="notEOF" data-name="notEOF">
               <h3>
                  notEOF 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#notEOF" class="anchor" title="Link to notEOF">#</a>
               </h3>
               
               <pre><code>func (s *ss) notEOF()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="notSpace" data-name="notSpace">
               <h3>
                  notSpace 
                  <span class="badge">function</span>
                  
                  <a href="#notSpace" class="anchor" title="Link to notSpace">#</a>
               </h3>
               
               <p>notSpace is the default scanning function used in Token.</p>
               
               <pre><code>func notSpace(r rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="okVerb" data-name="okVerb">
               <h3>
                  okVerb 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#okVerb" class="anchor" title="Link to okVerb">#</a>
               </h3>
               
               <p>okVerb verifies that the verb is present in the list, setting s.err appropriately if not.</p>
               
               <pre><code>func (s *ss) okVerb(verb rune, okVerbs string, typ string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pad" data-name="pad">
               <h3>
                  pad 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pad" class="anchor" title="Link to pad">#</a>
               </h3>
               
               <p>pad appends b to f.buf, padded on left (!f.minus) or right (f.minus).</p>
               
               <pre><code>func (f *fmt) pad(b []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="padString" data-name="padString">
               <h3>
                  padString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#padString" class="anchor" title="Link to padString">#</a>
               </h3>
               
               <p>padString appends s to f.buf, padded on left (!f.minus) or right (f.minus).</p>
               
               <pre><code>func (f *fmt) padString(s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseArgNumber" data-name="parseArgNumber">
               <h3>
                  parseArgNumber 
                  <span class="badge">function</span>
                  
                  <a href="#parseArgNumber" class="anchor" title="Link to parseArgNumber">#</a>
               </h3>
               
               <p>parseArgNumber returns the value of the bracketed number, minus 1
(explicit argument numbers are one-indexed but we want zero-indexed).
The opening bracket is known to be present at format[0].
The returned values are the index, the number of bytes to consume
up to the closing paren, if present, and whether the number parsed
ok. The bytes to consume will be 1 if no closing paren is present.</p>
               
               <pre><code>func parseArgNumber(format string) (index int, wid int, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsenum" data-name="parsenum">
               <h3>
                  parsenum 
                  <span class="badge">function</span>
                  
                  <a href="#parsenum" class="anchor" title="Link to parsenum">#</a>
               </h3>
               
               <p>parsenum converts ASCII to integer.  num is 0 (and isnum is false) if no number present.</p>
               
               <pre><code>func parsenum(s string, start int, end int) (num int, isnum bool, newi int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="peek" data-name="peek">
               <h3>
                  peek 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#peek" class="anchor" title="Link to peek">#</a>
               </h3>
               
               <p>peek reports whether the next character is in the ok string, without consuming it.</p>
               
               <pre><code>func (s *ss) peek(ok string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printArg" data-name="printArg">
               <h3>
                  printArg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#printArg" class="anchor" title="Link to printArg">#</a>
               </h3>
               
               <pre><code>func (p *pp) printArg(arg any, verb rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printValue" data-name="printValue">
               <h3>
                  printValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#printValue" class="anchor" title="Link to printValue">#</a>
               </h3>
               
               <p>printValue is similar to printArg but starts with a reflect value, not an interface{} value.
It does not handle 'p' and 'T' verbs because these should have been already handled by printArg.</p>
               
               <pre><code>func (p *pp) printValue(value reflect.Value, verb rune, depth int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="quotedString" data-name="quotedString">
               <h3>
                  quotedString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#quotedString" class="anchor" title="Link to quotedString">#</a>
               </h3>
               
               <p>quotedString returns the double- or back-quoted string represented by the next input characters.</p>
               
               <pre><code>func (s *ss) quotedString() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readByte" data-name="readByte">
               <h3>
                  readByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readByte" class="anchor" title="Link to readByte">#</a>
               </h3>
               
               <p>readByte returns the next byte from the input, which may be
left over from a previous read if the UTF-8 was ill-formed.</p>
               
               <pre><code>func (r *readRune) readByte() (b byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanBasePrefix" data-name="scanBasePrefix">
               <h3>
                  scanBasePrefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanBasePrefix" class="anchor" title="Link to scanBasePrefix">#</a>
               </h3>
               
               <p>scanBasePrefix reports whether the integer begins with a base prefix
and returns the base, digit string, and whether a zero was found.
It is called only if the verb is %v.</p>
               
               <pre><code>func (s *ss) scanBasePrefix() (base int, digits string, zeroFound bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanBool" data-name="scanBool">
               <h3>
                  scanBool 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanBool" class="anchor" title="Link to scanBool">#</a>
               </h3>
               
               <p>scanBool returns the value of the boolean represented by the next token.</p>
               
               <pre><code>func (s *ss) scanBool(verb rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanComplex" data-name="scanComplex">
               <h3>
                  scanComplex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanComplex" class="anchor" title="Link to scanComplex">#</a>
               </h3>
               
               <p>scanComplex converts the next token to a complex128 value.
The atof argument is a type-specific reader for the underlying type.
If we're reading complex64, atof will parse float32s and convert them
to float64's to avoid reproducing this code for each complex type.</p>
               
               <pre><code>func (s *ss) scanComplex(verb rune, n int) complex128</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanInt" data-name="scanInt">
               <h3>
                  scanInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanInt" class="anchor" title="Link to scanInt">#</a>
               </h3>
               
               <p>scanInt returns the value of the integer represented by the next
token, checking for overflow. Any error is stored in s.err.</p>
               
               <pre><code>func (s *ss) scanInt(verb rune, bitSize int) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanNumber" data-name="scanNumber">
               <h3>
                  scanNumber 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanNumber" class="anchor" title="Link to scanNumber">#</a>
               </h3>
               
               <p>scanNumber returns the numerical string with specified digits starting here.</p>
               
               <pre><code>func (s *ss) scanNumber(digits string, haveDigits bool) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanOne" data-name="scanOne">
               <h3>
                  scanOne 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanOne" class="anchor" title="Link to scanOne">#</a>
               </h3>
               
               <p>scanOne scans a single value, deriving the scanner from the type of the argument.</p>
               
               <pre><code>func (s *ss) scanOne(verb rune, arg any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanPercent" data-name="scanPercent">
               <h3>
                  scanPercent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanPercent" class="anchor" title="Link to scanPercent">#</a>
               </h3>
               
               <p>scanPercent scans a literal percent character.</p>
               
               <pre><code>func (s *ss) scanPercent()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanRune" data-name="scanRune">
               <h3>
                  scanRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanRune" class="anchor" title="Link to scanRune">#</a>
               </h3>
               
               <p>scanRune returns the next rune value in the input.</p>
               
               <pre><code>func (s *ss) scanRune(bitSize int) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanUint" data-name="scanUint">
               <h3>
                  scanUint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanUint" class="anchor" title="Link to scanUint">#</a>
               </h3>
               
               <p>scanUint returns the value of the unsigned integer represented
by the next token, checking for overflow. Any error is stored in s.err.</p>
               
               <pre><code>func (s *ss) scanUint(verb rune, bitSize int) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="token" data-name="token">
               <h3>
                  token 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#token" class="anchor" title="Link to token">#</a>
               </h3>
               
               <p>token returns the next space-delimited string from the input. It
skips white space. For Scanln, it stops at newlines. For Scan,
newlines are treated as spaces.</p>
               
               <pre><code>func (s *ss) token(skipSpace bool, f func(rune) bool) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tooLarge" data-name="tooLarge">
               <h3>
                  tooLarge 
                  <span class="badge">function</span>
                  
                  <a href="#tooLarge" class="anchor" title="Link to tooLarge">#</a>
               </h3>
               
               <p>tooLarge reports whether the magnitude of the integer is
too large to be used as a formatting width or precision.</p>
               
               <pre><code>func tooLarge(x int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="truncate" data-name="truncate">
               <h3>
                  truncate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#truncate" class="anchor" title="Link to truncate">#</a>
               </h3>
               
               <p>truncate truncates the byte slice b as a string of the specified precision, if present.</p>
               
               <pre><code>func (f *fmt) truncate(b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="truncateString" data-name="truncateString">
               <h3>
                  truncateString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#truncateString" class="anchor" title="Link to truncateString">#</a>
               </h3>
               
               <p>truncateString truncates the string s to the specified precision, if present.</p>
               
               <pre><code>func (f *fmt) truncateString(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unknownType" data-name="unknownType">
               <h3>
                  unknownType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unknownType" class="anchor" title="Link to unknownType">#</a>
               </h3>
               
               <pre><code>func (p *pp) unknownType(v reflect.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="write" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#write" class="anchor" title="Link to write">#</a>
               </h3>
               
               <pre><code>func (b *buffer) write(p []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeByte" data-name="writeByte">
               <h3>
                  writeByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeByte" class="anchor" title="Link to writeByte">#</a>
               </h3>
               
               <pre><code>func (b *buffer) writeByte(c byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writePadding" data-name="writePadding">
               <h3>
                  writePadding 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writePadding" class="anchor" title="Link to writePadding">#</a>
               </h3>
               
               <p>writePadding generates n bytes of padding.</p>
               
               <pre><code>func (f *fmt) writePadding(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeRune" data-name="writeRune">
               <h3>
                  writeRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeRune" class="anchor" title="Link to writeRune">#</a>
               </h3>
               
               <pre><code>func (b *buffer) writeRune(r rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeString" data-name="writeString">
               <h3>
                  writeString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeString" class="anchor" title="Link to writeString">#</a>
               </h3>
               
               <pre><code>func (b *buffer) writeString(s string)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>