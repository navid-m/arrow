<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - noder</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>noder</code>
         </h1>
         <hr />
         
         <article class="global" data-name="unOps">
            <h2>unOps</h2>
            <hr />
            
            <pre><code>unOps</code></pre>
         </article>
         
         <article class="global" data-name="binOps">
            <h2>binOps</h2>
            <hr />
            
            <pre><code>binOps</code></pre>
         </article>
         
         <article class="global" data-name="allowedStdPragmas">
            <h2>allowedStdPragmas</h2>
            <hr />
            
            <p>pragmas that are allowed in the std lib, but don't have
a syntax.Pragma value (see lex.go) associated with them.</p>
            
            <pre><code>allowedStdPragmas</code></pre>
         </article>
         
         <article class="global" data-name="renameinitgen">
            <h2>renameinitgen</h2>
            <hr />
            
            <p>A function named init is a special case.
It is called by the initialization before main is run.
To make it unique within a package and also uncallable,
the name, normally "pkg.init", is altered to "pkg.init.0".</p>
            
            <pre><code>renameinitgen int</code></pre>
         </article>
         
         <article class="global" data-name="objReader">
            <h2>objReader</h2>
            <hr />
            
            <p>objReader maps qualified identifiers (represented as *types.Sym) to
a pkgReader and corresponding index that can be used for reading
that object's definition.</p>
            
            <pre><code>objReader</code></pre>
         </article>
         
         <article class="global" data-name="bodyReader">
            <h2>bodyReader</h2>
            <hr />
            
            <p>bodyReader tracks where the serialized IR for a local or imported,
generic function's body can be found.</p>
            
            <pre><code>bodyReader</code></pre>
         </article>
         
         <article class="global" data-name="importBodyReader">
            <h2>importBodyReader</h2>
            <hr />
            
            <p>importBodyReader tracks where the serialized IR for an imported,
static (i.e., non-generic) function body can be read.</p>
            
            <pre><code>importBodyReader</code></pre>
         </article>
         
         <article class="global" data-name="todoDicts">
            <h2>todoDicts</h2>
            <hr />
            
            <p>todoDicts holds the list of dictionaries that still need their
runtime dictionary objects constructed.</p>
            
            <pre><code>todoDicts []func</code></pre>
         </article>
         
         <article class="global" data-name="todoBodies">
            <h2>todoBodies</h2>
            <hr />
            
            <p>todoBodies holds the list of function bodies that still need to be
constructed.</p>
            
            <pre><code>todoBodies []*ir.Func</code></pre>
         </article>
         
         <article class="global" data-name="inlgen">
            <h2>inlgen</h2>
            <hr />
            
            <pre><code>inlgen</code></pre>
         </article>
         
         <article class="global" data-name="needWrapperTypes">
            <h2>needWrapperTypes</h2>
            <hr />
            
            <p>needWrapperTypes lists types for which we may need to generate
method wrappers.</p>
            
            <pre><code>needWrapperTypes []*types.Type</code></pre>
         </article>
         
         <article class="global" data-name="haveWrapperTypes">
            <h2>haveWrapperTypes</h2>
            <hr />
            
            <p>haveWrapperTypes lists types for which we know we already have
method wrappers, because we found the type in an imported package.</p>
            
            <pre><code>haveWrapperTypes []*types.Type</code></pre>
         </article>
         
         <article class="global" data-name="needMethodValueWrappers">
            <h2>needMethodValueWrappers</h2>
            <hr />
            
            <p>needMethodValueWrappers lists methods for which we may need to
generate method value wrappers.</p>
            
            <pre><code>needMethodValueWrappers []methodValueWrapper</code></pre>
         </article>
         
         <article class="global" data-name="haveMethodValueWrappers">
            <h2>haveMethodValueWrappers</h2>
            <hr />
            
            <p>haveMethodValueWrappers lists methods for which we know we already
have method value wrappers, because we found it in an imported
package.</p>
            
            <pre><code>haveMethodValueWrappers []methodValueWrapper</code></pre>
         </article>
         
         <article class="global" data-name="dictParamName">
            <h2>dictParamName</h2>
            <hr />
            
            <p>dictParamName is the name of the synthetic dictionary parameter
added to shaped functions.

N.B., this variable name is known to Delve:
https://github.com/go-delve/delve/blob/cb91509630529e6055be845688fd21eb89ae8714/pkg/proc/eval.go#L28</p>
            
            <pre><code>dictParamName</code></pre>
         </article>
         
         <article class="global" data-name="basics">
            <h2>basics</h2>
            <hr />
            
            <pre><code>basics</code></pre>
         </article>
         
         <article class="global" data-name="dirs">
            <h2>dirs</h2>
            <hr />
            
            <pre><code>dirs</code></pre>
         </article>
         
         <article class="global" data-name="stmtEnd">
            <h2>stmtEnd</h2>
            <hr />
            
            <pre><code>stmtEnd codeStmt</code></pre>
         </article>
         
         <article class="global" data-name="stmtLabel">
            <h2>stmtLabel</h2>
            <hr />
            
            <pre><code>stmtLabel</code></pre>
         </article>
         
         <article class="global" data-name="stmtBlock">
            <h2>stmtBlock</h2>
            <hr />
            
            <pre><code>stmtBlock</code></pre>
         </article>
         
         <article class="global" data-name="stmtExpr">
            <h2>stmtExpr</h2>
            <hr />
            
            <pre><code>stmtExpr</code></pre>
         </article>
         
         <article class="global" data-name="stmtSend">
            <h2>stmtSend</h2>
            <hr />
            
            <pre><code>stmtSend</code></pre>
         </article>
         
         <article class="global" data-name="stmtAssign">
            <h2>stmtAssign</h2>
            <hr />
            
            <pre><code>stmtAssign</code></pre>
         </article>
         
         <article class="global" data-name="stmtAssignOp">
            <h2>stmtAssignOp</h2>
            <hr />
            
            <pre><code>stmtAssignOp</code></pre>
         </article>
         
         <article class="global" data-name="stmtIncDec">
            <h2>stmtIncDec</h2>
            <hr />
            
            <pre><code>stmtIncDec</code></pre>
         </article>
         
         <article class="global" data-name="stmtBranch">
            <h2>stmtBranch</h2>
            <hr />
            
            <pre><code>stmtBranch</code></pre>
         </article>
         
         <article class="global" data-name="stmtCall">
            <h2>stmtCall</h2>
            <hr />
            
            <pre><code>stmtCall</code></pre>
         </article>
         
         <article class="global" data-name="stmtReturn">
            <h2>stmtReturn</h2>
            <hr />
            
            <pre><code>stmtReturn</code></pre>
         </article>
         
         <article class="global" data-name="stmtIf">
            <h2>stmtIf</h2>
            <hr />
            
            <pre><code>stmtIf</code></pre>
         </article>
         
         <article class="global" data-name="stmtFor">
            <h2>stmtFor</h2>
            <hr />
            
            <pre><code>stmtFor</code></pre>
         </article>
         
         <article class="global" data-name="stmtSwitch">
            <h2>stmtSwitch</h2>
            <hr />
            
            <pre><code>stmtSwitch</code></pre>
         </article>
         
         <article class="global" data-name="stmtSelect">
            <h2>stmtSelect</h2>
            <hr />
            
            <pre><code>stmtSelect</code></pre>
         </article>
         
         <article class="global" data-name="exprConst">
            <h2>exprConst</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprConst codeExpr</code></pre>
         </article>
         
         <article class="global" data-name="exprLocal">
            <h2>exprLocal</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprLocal</code></pre>
         </article>
         
         <article class="global" data-name="exprGlobal">
            <h2>exprGlobal</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprGlobal</code></pre>
         </article>
         
         <article class="global" data-name="exprCompLit">
            <h2>exprCompLit</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprCompLit</code></pre>
         </article>
         
         <article class="global" data-name="exprFuncLit">
            <h2>exprFuncLit</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprFuncLit</code></pre>
         </article>
         
         <article class="global" data-name="exprFieldVal">
            <h2>exprFieldVal</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprFieldVal</code></pre>
         </article>
         
         <article class="global" data-name="exprMethodVal">
            <h2>exprMethodVal</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprMethodVal</code></pre>
         </article>
         
         <article class="global" data-name="exprMethodExpr">
            <h2>exprMethodExpr</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprMethodExpr</code></pre>
         </article>
         
         <article class="global" data-name="exprIndex">
            <h2>exprIndex</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprIndex</code></pre>
         </article>
         
         <article class="global" data-name="exprSlice">
            <h2>exprSlice</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprSlice</code></pre>
         </article>
         
         <article class="global" data-name="exprAssert">
            <h2>exprAssert</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprAssert</code></pre>
         </article>
         
         <article class="global" data-name="exprUnaryOp">
            <h2>exprUnaryOp</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprUnaryOp</code></pre>
         </article>
         
         <article class="global" data-name="exprBinaryOp">
            <h2>exprBinaryOp</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprBinaryOp</code></pre>
         </article>
         
         <article class="global" data-name="exprCall">
            <h2>exprCall</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprCall</code></pre>
         </article>
         
         <article class="global" data-name="exprConvert">
            <h2>exprConvert</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprConvert</code></pre>
         </article>
         
         <article class="global" data-name="exprNew">
            <h2>exprNew</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprNew</code></pre>
         </article>
         
         <article class="global" data-name="exprMake">
            <h2>exprMake</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprMake</code></pre>
         </article>
         
         <article class="global" data-name="exprSizeof">
            <h2>exprSizeof</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprSizeof</code></pre>
         </article>
         
         <article class="global" data-name="exprAlignof">
            <h2>exprAlignof</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprAlignof</code></pre>
         </article>
         
         <article class="global" data-name="exprOffsetof">
            <h2>exprOffsetof</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprOffsetof</code></pre>
         </article>
         
         <article class="global" data-name="exprZero">
            <h2>exprZero</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprZero</code></pre>
         </article>
         
         <article class="global" data-name="exprFuncInst">
            <h2>exprFuncInst</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprFuncInst</code></pre>
         </article>
         
         <article class="global" data-name="exprRecv">
            <h2>exprRecv</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprRecv</code></pre>
         </article>
         
         <article class="global" data-name="exprReshape">
            <h2>exprReshape</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprReshape</code></pre>
         </article>
         
         <article class="global" data-name="exprRuntimeBuiltin">
            <h2>exprRuntimeBuiltin</h2>
            <hr />
            
            <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
            
            <pre><code>exprRuntimeBuiltin</code></pre>
         </article>
         
         <article class="global" data-name="assignBlank">
            <h2>assignBlank</h2>
            <hr />
            
            <pre><code>assignBlank codeAssign</code></pre>
         </article>
         
         <article class="global" data-name="assignDef">
            <h2>assignDef</h2>
            <hr />
            
            <pre><code>assignDef</code></pre>
         </article>
         
         <article class="global" data-name="assignExpr">
            <h2>assignExpr</h2>
            <hr />
            
            <pre><code>assignExpr</code></pre>
         </article>
         
         <article class="global" data-name="declEnd">
            <h2>declEnd</h2>
            <hr />
            
            <pre><code>declEnd codeDecl</code></pre>
         </article>
         
         <article class="global" data-name="declFunc">
            <h2>declFunc</h2>
            <hr />
            
            <pre><code>declFunc</code></pre>
         </article>
         
         <article class="global" data-name="declMethod">
            <h2>declMethod</h2>
            <hr />
            
            <pre><code>declMethod</code></pre>
         </article>
         
         <article class="global" data-name="declVar">
            <h2>declVar</h2>
            <hr />
            
            <pre><code>declVar</code></pre>
         </article>
         
         <article class="global" data-name="declOther">
            <h2>declOther</h2>
            <hr />
            
            <pre><code>declOther</code></pre>
         </article>
         
         <article class="global" data-name="funcPragmas">
            <h2>funcPragmas</h2>
            <hr />
            
            <pre><code>funcPragmas</code></pre>
         </article>
         
         <article class="global" data-name="localPkgReader">
            <h2>localPkgReader</h2>
            <hr />
            
            <p>localPkgReader holds the package reader used for reading the local
package. It exists so the unified IR linker can refer back to it
later.</p>
            
            <pre><code>localPkgReader *pkgReader</code></pre>
         </article>
         
         <article class="global" data-name="versionErrorRx">
            <h2>versionErrorRx</h2>
            <hr />
            
            <pre><code>versionErrorRx</code></pre>
         </article>
         
         <article class="global" data-name="anyTypeName">
            <h2>anyTypeName</h2>
            <hr />
            
            <pre><code>anyTypeName</code></pre>
         </article>
         
         <article class="global" data-name="comparableTypeName">
            <h2>comparableTypeName</h2>
            <hr />
            
            <pre><code>comparableTypeName</code></pre>
         </article>
         
         <article class="global" data-name="runeTypeName">
            <h2>runeTypeName</h2>
            <hr />
            
            <pre><code>runeTypeName</code></pre>
         </article>
          
         <article class="struct" data-name="noder">
            <h2>type noder struct</h2>
            <hr />
            
            <p>noder transforms package syntax's AST into a Node tree.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">file *syntax.File
linknames []linkname
pragcgobuf [][]string
err *ast.ChanType</code></pre>
         </article>
         
         <article class="struct" data-name="linkname">
            <h2>type linkname struct</h2>
            <hr />
            
            <p>linkname records a //go:linkname directive.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pos syntax.Pos
local string
remote string</code></pre>
         </article>
         
         <article class="struct" data-name="pragmas">
            <h2>type pragmas struct</h2>
            <hr />
            
            <p>*pragmas is the value stored in a syntax.pragmas during parsing.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Flag ir.PragmaFlag
Pos []pragmaPos
Embeds []pragmaEmbed
WasmImport *WasmImport
WasmExport *WasmExport</code></pre>
         </article>
         
         <article class="struct" data-name="WasmImport">
            <h2>type WasmImport struct</h2>
            <hr />
            
            <p>WasmImport stores metadata associated with the //go:wasmimport pragma</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Pos syntax.Pos
Module string
Name string</code></pre>
         </article>
         
         <article class="struct" data-name="WasmExport">
            <h2>type WasmExport struct</h2>
            <hr />
            
            <p>WasmExport stores metadata associated with the //go:wasmexport pragma</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Pos syntax.Pos
Name string</code></pre>
         </article>
         
         <article class="struct" data-name="pragmaPos">
            <h2>type pragmaPos struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Flag ir.PragmaFlag
Pos syntax.Pos</code></pre>
         </article>
         
         <article class="struct" data-name="pragmaEmbed">
            <h2>type pragmaEmbed struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Pos syntax.Pos
Patterns []string</code></pre>
         </article>
         
         <article class="struct" data-name="pkgReader">
            <h2>type pkgReader struct</h2>
            <hr />
            
            <p>A pkgReader reads Unified IR export data.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pkgbits.PkgDecoder
posBases []*src.PosBase
pkgs []*types.Pkg
typs []*types.Type
newindex []index</code></pre>
         </article>
         
         <article class="struct" data-name="pkgReaderIndex">
            <h2>type pkgReaderIndex struct</h2>
            <hr />
            
            <p>A pkgReaderIndex compactly identifies an index (and its
corresponding dictionary) within a package's export data.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pr *pkgReader
idx index
dict *readerDict
methodSym *types.Sym
synthetic func</code></pre>
         </article>
         
         <article class="struct" data-name="reader">
            <h2>type reader struct</h2>
            <hr />
            
            <p>A reader provides APIs for reading an individual element.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pkgbits.Decoder
p *pkgReader
dict *readerDict
curfn *ir.Func
locals []*ir.Name
closureVars []*ir.Name
funarghack bool
methodSym *types.Sym
dictParam *ir.Name
synthetic func
scopeVars []int
marker dwarfgen.ScopeMarker
lastCloseScopePos src.XPos
inlCaller *ir.Func
inlCall *ir.CallExpr
inlFunc *ir.Func
inlTreeIndex int
inlPosBases *ast.MapType
suppressInlPos int
delayResults bool
retlabel *types.Sym</code></pre>
         </article>
         
         <article class="struct" data-name="readerDict">
            <h2>type readerDict struct</h2>
            <hr />
            
            <p>A readerDict represents an instantiated "compile-time dictionary,"
used for resolving any derived types needed for instantiating a
generic object.

A compile-time dictionary can either be "shaped" or "non-shaped."
Shaped compile-time dictionaries are only used for instantiating
shaped type definitions and function bodies, while non-shaped
compile-time dictionaries are used for instantiating runtime
dictionaries.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">shaped bool
baseSym *types.Sym
shapedObj *ir.Name
targs []*types.Type
implicits int
derived []derivedInfo
derivedTypes []*types.Type
typeParamMethodExprs []readerMethodExprInfo
subdicts []objInfo
rtypes []typeInfo
itabs []itabInfo</code></pre>
         </article>
         
         <article class="struct" data-name="readerMethodExprInfo">
            <h2>type readerMethodExprInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">typeParamIdx int
method *types.Sym</code></pre>
         </article>
         
         <article class="struct" data-name="methodValueWrapper">
            <h2>type methodValueWrapper struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">rcvr *types.Type
method *types.Field</code></pre>
         </article>
         
         <article class="struct" data-name="linker">
            <h2>type linker struct</h2>
            <hr />
            
            <p>A linker combines a package's stub export data with any referenced
elements from imported packages into a single, self-contained
export data file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pw pkgbits.PkgEncoder
pkgs *ast.MapType
decls *ast.MapType
bodies *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="posMap">
            <h2>type posMap struct</h2>
            <hr />
            
            <p>A posMap handles mapping from syntax.Pos to src.XPos.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">bases *ast.MapType
cache *ast.StructType</code></pre>
         </article>
         
         <article class="struct" data-name="cycleFinder">
            <h2>type cycleFinder struct</h2>
            <hr />
            
            <p>A cycleFinder detects anonymous interface cycles (go.dev/issue/56103).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">cyclic *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="pkgWriter">
            <h2>type pkgWriter struct</h2>
            <hr />
            
            <p>A pkgWriter constructs Unified IR export data from the results of
running the types2 type checker on a Go compilation unit.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pkgbits.PkgEncoder
m posMap
curpkg *types2.Package
info *types2.Info
rangeFuncBodyClosures *ast.MapType
posBasesIdx *ast.MapType
pkgsIdx *ast.MapType
typsIdx *ast.MapType
objsIdx *ast.MapType
funDecls *ast.MapType
typDecls *ast.MapType
linknames *ast.MapType
cgoPragmas [][]string</code></pre>
         </article>
         
         <article class="struct" data-name="writer">
            <h2>type writer struct</h2>
            <hr />
            
            <p>A writer provides APIs for writing out an individual element.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">p *pkgWriter
pkgbits.Encoder
sig *types2.Signature
localsIdx *ast.MapType
closureVars []posVar
closureVarsIdx *ast.MapType
dict *writerDict
derived bool</code></pre>
         </article>
         
         <article class="struct" data-name="writerDict">
            <h2>type writerDict struct</h2>
            <hr />
            
            <p>A writerDict tracks types and objects that are used by a declaration.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">implicits []*types2.TypeParam
derived []derivedInfo
derivedIdx *ast.MapType
typeParamMethodExprs []writerMethodExprInfo
subdicts []objInfo
rtypes []typeInfo
itabs []itabInfo</code></pre>
         </article>
         
         <article class="struct" data-name="itabInfo">
            <h2>type itabInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">typ typeInfo
iface typeInfo</code></pre>
         </article>
         
         <article class="struct" data-name="derivedInfo">
            <h2>type derivedInfo struct</h2>
            <hr />
            
            <p>A derivedInfo represents a reference to an encoded generic Go type.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">idx index</code></pre>
         </article>
         
         <article class="struct" data-name="typeInfo">
            <h2>type typeInfo struct</h2>
            <hr />
            
            <p>A typeInfo represents a reference to an encoded Go type.

If derived is true, then the typeInfo represents a generic Go type
that contains type parameters. In this case, idx is an index into
the readerDict.derived{,Types} arrays.

Otherwise, the typeInfo represents a non-generic Go type, and idx
is an index into the reader.typs array instead.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">idx index
derived bool</code></pre>
         </article>
         
         <article class="struct" data-name="objInfo">
            <h2>type objInfo struct</h2>
            <hr />
            
            <p>An objInfo represents a reference to an encoded, instantiated (if
applicable) Go object.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">idx index
explicits []typeInfo</code></pre>
         </article>
         
         <article class="struct" data-name="selectorInfo">
            <h2>type selectorInfo struct</h2>
            <hr />
            
            <p>A selectorInfo represents a reference to an encoded field or method
name (i.e., objects that can only be accessed using selector
expressions).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pkgIdx index
nameIdx index</code></pre>
         </article>
         
         <article class="struct" data-name="writerMethodExprInfo">
            <h2>type writerMethodExprInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">typeParamIdx int
methodInfo selectorInfo</code></pre>
         </article>
         
         <article class="struct" data-name="posVar">
            <h2>type posVar struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pos syntax.Pos
var_ *types2.Var</code></pre>
         </article>
         
         <article class="struct" data-name="typeDeclGen">
            <h2>type typeDeclGen struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">*syntax.TypeDecl
gen int
implicits []*types2.TypeParam</code></pre>
         </article>
         
         <article class="struct" data-name="fileImports">
            <h2>type fileImports struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">importedEmbed bool
importedUnsafe bool</code></pre>
         </article>
         
         <article class="struct" data-name="declCollector">
            <h2>type declCollector struct</h2>
            <hr />
            
            <p>declCollector is a visitor type that collects compiler-needed
information about declarations that types2 doesn't track.

Notably, it maps declared types and functions back to their
declaration statement, keeps track of implicit type parameters, and
assigns unique type "generation" numbers to local defined types.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pw *pkgWriter
typegen *int
file *fileImports
withinFunc bool
implicits []*types2.TypeParam</code></pre>
         </article>
         
         <article class="struct" data-name="gcimports">
            <h2>type gcimports struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">ctxt *types2.Context
packages *ast.MapType</code></pre>
         </article>
          
         <article class="function" data-name="LoadPackage">
            <h2>LoadPackage</h2>
            <hr />
            
            <pre><code>func LoadPackage(filenames []string)</code></pre>
         </article>
         
         <article class="function" data-name="trimFilename">
            <h2>trimFilename</h2>
            <hr />
            
            <p>trimFilename returns the "trimmed" filename of b, which is the
absolute filename after applying -trimpath processing. This
filename form is suitable for use in object files and export data.

If b's filename has already been trimmed (i.e., because it was read
in from an imported package's export data), then the filename is
returned unchanged.</p>
            
            <pre><code>func trimFilename(b *syntax.PosBase) string</code></pre>
         </article>
         
         <article class="function" data-name="error">
            <h2>error</h2>
            <hr />
            
            <p>error is called concurrently if files are parsed concurrently.</p>
            
            <pre><code>func error(err error)</code></pre>
         </article>
         
         <article class="function" data-name="checkUnusedDuringParse">
            <h2>checkUnusedDuringParse</h2>
            <hr />
            
            <pre><code>func checkUnusedDuringParse(pragma *pragmas)</code></pre>
         </article>
         
         <article class="function" data-name="pragma">
            <h2>pragma</h2>
            <hr />
            
            <p>pragma is called concurrently if files are parsed concurrently.</p>
            
            <pre><code>func pragma(pos syntax.Pos, blankLine bool, text string, old syntax.Pragma) syntax.Pragma</code></pre>
         </article>
         
         <article class="function" data-name="isCgoGeneratedFile">
            <h2>isCgoGeneratedFile</h2>
            <hr />
            
            <p>isCgoGeneratedFile reports whether pos is in a file
generated by cgo, which is to say a file with name
beginning with "_cgo_". Such files are allowed to
contain cgo directives, and for security reasons
(primarily misuse of linker flags), other files are not.
See golang.org/issue/23672.
Note that cmd/go ignores files whose names start with underscore,
so the only _cgo_ files we will see from cmd/go are generated by cgo.
It's easy to bypass this check by calling the compiler directly;
we only protect against uses by cmd/go.</p>
            
            <pre><code>func isCgoGeneratedFile(pos syntax.Pos) bool</code></pre>
         </article>
         
         <article class="function" data-name="safeArg">
            <h2>safeArg</h2>
            <hr />
            
            <p>safeArg reports whether arg is a "safe" command-line argument,
meaning that when it appears in a command-line, it probably
doesn't have some special meaning other than its own name.
This is copied from SafeArg in cmd/go/internal/load/pkg.go.</p>
            
            <pre><code>func safeArg(name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="parseGoEmbed">
            <h2>parseGoEmbed</h2>
            <hr />
            
            <p>parseGoEmbed parses the text following "//go:embed" to extract the glob patterns.
It accepts unquoted space-separated patterns as well as double-quoted and back-quoted Go strings.
go/build/read.go also processes these strings and contains similar logic.</p>
            
            <pre><code>func parseGoEmbed(args string) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="Renameinit">
            <h2>Renameinit</h2>
            <hr />
            
            <pre><code>func Renameinit() *types.Sym</code></pre>
         </article>
         
         <article class="function" data-name="checkEmbed">
            <h2>checkEmbed</h2>
            <hr />
            
            <pre><code>func checkEmbed(decl *syntax.VarDecl, haveEmbed bool, withinFunc bool) error</code></pre>
         </article>
         
         <article class="function" data-name="newPkgReader">
            <h2>newPkgReader</h2>
            <hr />
            
            <pre><code>func newPkgReader(pr pkgbits.PkgDecoder) *pkgReader</code></pre>
         </article>
         
         <article class="function" data-name="asReader">
            <h2>asReader</h2>
            <hr />
            
            <pre><code>func asReader(k pkgbits.RelocKind, marker pkgbits.SyncMarker) *reader</code></pre>
         </article>
         
         <article class="function" data-name="newReader">
            <h2>newReader</h2>
            <hr />
            
            <pre><code>func newReader(k pkgbits.RelocKind, idx index, marker pkgbits.SyncMarker) *reader</code></pre>
         </article>
         
         <article class="function" data-name="setType">
            <h2>setType</h2>
            <hr />
            
            <pre><code>func setType(n ir.Node, typ *types.Type)</code></pre>
         </article>
         
         <article class="function" data-name="setValue">
            <h2>setValue</h2>
            <hr />
            
            <pre><code>func setValue(name *ir.Name, val constant.Value)</code></pre>
         </article>
         
         <article class="function" data-name="pos">
            <h2>pos</h2>
            <hr />
            
            <p>pos reads a position from the bitstream.</p>
            
            <pre><code>func pos() src.XPos</code></pre>
         </article>
         
         <article class="function" data-name="origPos">
            <h2>origPos</h2>
            <hr />
            
            <p>origPos reads a position from the bitstream, and returns both the
original raw position and an inlining-adjusted position.</p>
            
            <pre><code>func origPos() (origPos src.XPos, inlPos src.XPos)</code></pre>
         </article>
         
         <article class="function" data-name="pos0">
            <h2>pos0</h2>
            <hr />
            
            <pre><code>func pos0() src.Pos</code></pre>
         </article>
         
         <article class="function" data-name="posBase">
            <h2>posBase</h2>
            <hr />
            
            <p>posBase reads a position base from the bitstream.</p>
            
            <pre><code>func posBase() *src.PosBase</code></pre>
         </article>
         
         <article class="function" data-name="posBaseIdx">
            <h2>posBaseIdx</h2>
            <hr />
            
            <p>posBaseIdx returns the specified position base, reading it first if
needed.</p>
            
            <pre><code>func posBaseIdx(idx index) *src.PosBase</code></pre>
         </article>
         
         <article class="function" data-name="inlPosBase">
            <h2>inlPosBase</h2>
            <hr />
            
            <p>inlPosBase returns the inlining-adjusted src.PosBase corresponding
to oldBase, which must be a non-inlined position. When not
inlining, this is just oldBase.</p>
            
            <pre><code>func inlPosBase(oldBase *src.PosBase) *src.PosBase</code></pre>
         </article>
         
         <article class="function" data-name="inlPos">
            <h2>inlPos</h2>
            <hr />
            
            <p>inlPos returns the inlining-adjusted src.XPos corresponding to
xpos, which must be a non-inlined position. When not inlining, this
is just xpos.</p>
            
            <pre><code>func inlPos(xpos src.XPos) src.XPos</code></pre>
         </article>
         
         <article class="function" data-name="pkg">
            <h2>pkg</h2>
            <hr />
            
            <p>pkg reads a package reference from the bitstream.</p>
            
            <pre><code>func pkg() *types.Pkg</code></pre>
         </article>
         
         <article class="function" data-name="pkgIdx">
            <h2>pkgIdx</h2>
            <hr />
            
            <p>pkgIdx returns the specified package from the export data, reading
it first if needed.</p>
            
            <pre><code>func pkgIdx(idx index) *types.Pkg</code></pre>
         </article>
         
         <article class="function" data-name="doPkg">
            <h2>doPkg</h2>
            <hr />
            
            <p>doPkg reads a package definition from the bitstream.</p>
            
            <pre><code>func doPkg() *types.Pkg</code></pre>
         </article>
         
         <article class="function" data-name="typ">
            <h2>typ</h2>
            <hr />
            
            <pre><code>func typ() *types.Type</code></pre>
         </article>
         
         <article class="function" data-name="typWrapped">
            <h2>typWrapped</h2>
            <hr />
            
            <p>typWrapped is like typ, but allows suppressing generation of
unnecessary wrappers as a compile-time optimization.</p>
            
            <pre><code>func typWrapped(wrapped bool) *types.Type</code></pre>
         </article>
         
         <article class="function" data-name="typInfo">
            <h2>typInfo</h2>
            <hr />
            
            <pre><code>func typInfo() typeInfo</code></pre>
         </article>
         
         <article class="function" data-name="typListIdx">
            <h2>typListIdx</h2>
            <hr />
            
            <p>typListIdx returns a list of the specified types, resolving derived
types within the given dictionary.</p>
            
            <pre><code>func typListIdx(infos []typeInfo, dict *readerDict) []*types.Type</code></pre>
         </article>
         
         <article class="function" data-name="typIdx">
            <h2>typIdx</h2>
            <hr />
            
            <p>typIdx returns the specified type. If info specifies a derived
type, it's resolved within the given dictionary. If wrapped is
true, then method wrappers will be generated, if appropriate.</p>
            
            <pre><code>func typIdx(info typeInfo, dict *readerDict, wrapped bool) *types.Type</code></pre>
         </article>
         
         <article class="function" data-name="doTyp">
            <h2>doTyp</h2>
            <hr />
            
            <pre><code>func doTyp() *types.Type</code></pre>
         </article>
         
         <article class="function" data-name="unionType">
            <h2>unionType</h2>
            <hr />
            
            <pre><code>func unionType() *types.Type</code></pre>
         </article>
         
         <article class="function" data-name="interfaceType">
            <h2>interfaceType</h2>
            <hr />
            
            <pre><code>func interfaceType() *types.Type</code></pre>
         </article>
         
         <article class="function" data-name="structType">
            <h2>structType</h2>
            <hr />
            
            <pre><code>func structType() *types.Type</code></pre>
         </article>
         
         <article class="function" data-name="signature">
            <h2>signature</h2>
            <hr />
            
            <pre><code>func signature(recv *types.Field) *types.Type</code></pre>
         </article>
         
         <article class="function" data-name="params">
            <h2>params</h2>
            <hr />
            
            <pre><code>func params() []*types.Field</code></pre>
         </article>
         
         <article class="function" data-name="param">
            <h2>param</h2>
            <hr />
            
            <pre><code>func param() *types.Field</code></pre>
         </article>
         
         <article class="function" data-name="obj">
            <h2>obj</h2>
            <hr />
            
            <p>obj reads an instantiated object reference from the bitstream.</p>
            
            <pre><code>func obj() ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="objInfo">
            <h2>objInfo</h2>
            <hr />
            
            <p>objInfo reads an instantiated object reference from the bitstream
and returns the encoded reference to it, without instantiating it.</p>
            
            <pre><code>func objInfo() objInfo</code></pre>
         </article>
         
         <article class="function" data-name="objInstIdx">
            <h2>objInstIdx</h2>
            <hr />
            
            <p>objInstIdx returns the encoded, instantiated object. If shaped is
true, then the shaped variant of the object is returned instead.</p>
            
            <pre><code>func objInstIdx(info objInfo, dict *readerDict, shaped bool) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="objIdx">
            <h2>objIdx</h2>
            <hr />
            
            <p>objIdx returns the specified object, instantiated with the given
type arguments, if any.
If shaped is true, then the shaped variant of the object is returned
instead.</p>
            
            <pre><code>func objIdx(idx index, implicits []*types.Type, explicits []*types.Type, shaped bool) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="objIdxMayFail">
            <h2>objIdxMayFail</h2>
            <hr />
            
            <p>objIdxMayFail is equivalent to objIdx, but returns an error rather than
failing the build if this object requires type arguments and the incorrect
number of type arguments were passed.

Other sources of internal failure (such as duplicate definitions) still fail
the build.</p>
            
            <pre><code>func objIdxMayFail(idx index, implicits []*types.Type, explicits []*types.Type, shaped bool) (ir.Node, error)</code></pre>
         </article>
         
         <article class="function" data-name="mangle">
            <h2>mangle</h2>
            <hr />
            
            <pre><code>func mangle(sym *types.Sym) *types.Sym</code></pre>
         </article>
         
         <article class="function" data-name="shapify">
            <h2>shapify</h2>
            <hr />
            
            <p>shapify returns the shape type for targ.

If basic is true, then the type argument is used to instantiate a
type parameter whose constraint is a basic interface.</p>
            
            <pre><code>func shapify(targ *types.Type, basic bool) *types.Type</code></pre>
         </article>
         
         <article class="function" data-name="objDictIdx">
            <h2>objDictIdx</h2>
            <hr />
            
            <p>objDictIdx reads and returns the specified object dictionary.</p>
            
            <pre><code>func objDictIdx(sym *types.Sym, idx index, implicits []*types.Type, explicits []*types.Type, shaped bool) (*readerDict, error)</code></pre>
         </article>
         
         <article class="function" data-name="typeParamNames">
            <h2>typeParamNames</h2>
            <hr />
            
            <pre><code>func typeParamNames()</code></pre>
         </article>
         
         <article class="function" data-name="method">
            <h2>method</h2>
            <hr />
            
            <pre><code>func method(rext *reader) *types.Field</code></pre>
         </article>
         
         <article class="function" data-name="qualifiedIdent">
            <h2>qualifiedIdent</h2>
            <hr />
            
            <pre><code>func qualifiedIdent() (pkg *types.Pkg, sym *types.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="localIdent">
            <h2>localIdent</h2>
            <hr />
            
            <pre><code>func localIdent() *types.Sym</code></pre>
         </article>
         
         <article class="function" data-name="selector">
            <h2>selector</h2>
            <hr />
            
            <pre><code>func selector() *types.Sym</code></pre>
         </article>
         
         <article class="function" data-name="hasTypeParams">
            <h2>hasTypeParams</h2>
            <hr />
            
            <pre><code>func hasTypeParams() bool</code></pre>
         </article>
         
         <article class="function" data-name="hasTypeParams">
            <h2>hasTypeParams</h2>
            <hr />
            
            <pre><code>func hasTypeParams() bool</code></pre>
         </article>
         
         <article class="function" data-name="funcExt">
            <h2>funcExt</h2>
            <hr />
            
            <pre><code>func funcExt(name *ir.Name, method *types.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="typeExt">
            <h2>typeExt</h2>
            <hr />
            
            <pre><code>func typeExt(name *ir.Name)</code></pre>
         </article>
         
         <article class="function" data-name="varExt">
            <h2>varExt</h2>
            <hr />
            
            <pre><code>func varExt(name *ir.Name)</code></pre>
         </article>
         
         <article class="function" data-name="linkname">
            <h2>linkname</h2>
            <hr />
            
            <pre><code>func linkname(name *ir.Name)</code></pre>
         </article>
         
         <article class="function" data-name="pragmaFlag">
            <h2>pragmaFlag</h2>
            <hr />
            
            <pre><code>func pragmaFlag() ir.PragmaFlag</code></pre>
         </article>
         
         <article class="function" data-name="bodyReaderFor">
            <h2>bodyReaderFor</h2>
            <hr />
            
            <p>bodyReaderFor returns the pkgReaderIndex for reading fn's
serialized IR, and whether one was found.</p>
            
            <pre><code>func bodyReaderFor(fn *ir.Func) (pri pkgReaderIndex, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="addBody">
            <h2>addBody</h2>
            <hr />
            
            <p>addBody reads a function body reference from the element bitstream,
and associates it with fn.</p>
            
            <pre><code>func addBody(fn *ir.Func, method *types.Sym)</code></pre>
         </article>
         
         <article class="function" data-name="funcBody">
            <h2>funcBody</h2>
            <hr />
            
            <pre><code>func funcBody(fn *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="funcBody">
            <h2>funcBody</h2>
            <hr />
            
            <p>funcBody reads a function body definition from the element
bitstream, and populates fn with it.</p>
            
            <pre><code>func funcBody(fn *ir.Func)</code></pre>
         </article>
         
         <article class="function" data-name="syntheticBody">
            <h2>syntheticBody</h2>
            <hr />
            
            <p>syntheticBody adds a synthetic body to r.curfn if appropriate, and
reports whether it did.</p>
            
            <pre><code>func syntheticBody(pos src.XPos) bool</code></pre>
         </article>
         
         <article class="function" data-name="callShaped">
            <h2>callShaped</h2>
            <hr />
            
            <p>callShaped emits a tail call to r.shapedFn, passing along the
arguments to the current function.</p>
            
            <pre><code>func callShaped(pos src.XPos)</code></pre>
         </article>
         
         <article class="function" data-name="syntheticArgs">
            <h2>syntheticArgs</h2>
            <hr />
            
            <p>syntheticArgs returns the recvs and params arguments passed to the
current function.</p>
            
            <pre><code>func syntheticArgs() ir.Nodes</code></pre>
         </article>
         
         <article class="function" data-name="syntheticTailCall">
            <h2>syntheticTailCall</h2>
            <hr />
            
            <p>syntheticTailCall emits a tail call to fn, passing the given
arguments list.</p>
            
            <pre><code>func syntheticTailCall(pos src.XPos, fn ir.Node, args ir.Nodes)</code></pre>
         </article>
         
         <article class="function" data-name="dictNameOf">
            <h2>dictNameOf</h2>
            <hr />
            
            <p>dictNameOf returns the runtime dictionary corresponding to dict.</p>
            
            <pre><code>func dictNameOf(dict *readerDict) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="typeParamMethodExprsOffset">
            <h2>typeParamMethodExprsOffset</h2>
            <hr />
            
            <p>typeParamMethodExprsOffset returns the offset of the runtime
dictionary's type parameter method expressions section, in words.</p>
            
            <pre><code>func typeParamMethodExprsOffset() int</code></pre>
         </article>
         
         <article class="function" data-name="subdictsOffset">
            <h2>subdictsOffset</h2>
            <hr />
            
            <p>subdictsOffset returns the offset of the runtime dictionary's
subdictionary section, in words.</p>
            
            <pre><code>func subdictsOffset() int</code></pre>
         </article>
         
         <article class="function" data-name="rtypesOffset">
            <h2>rtypesOffset</h2>
            <hr />
            
            <p>rtypesOffset returns the offset of the runtime dictionary's rtypes
section, in words.</p>
            
            <pre><code>func rtypesOffset() int</code></pre>
         </article>
         
         <article class="function" data-name="itabsOffset">
            <h2>itabsOffset</h2>
            <hr />
            
            <p>itabsOffset returns the offset of the runtime dictionary's itabs
section, in words.</p>
            
            <pre><code>func itabsOffset() int</code></pre>
         </article>
         
         <article class="function" data-name="numWords">
            <h2>numWords</h2>
            <hr />
            
            <p>numWords returns the total number of words that comprise dict's
runtime dictionary variable.</p>
            
            <pre><code>func numWords() int64</code></pre>
         </article>
         
         <article class="function" data-name="varType">
            <h2>varType</h2>
            <hr />
            
            <p>varType returns the type of dict's runtime dictionary variable.</p>
            
            <pre><code>func varType() *types.Type</code></pre>
         </article>
         
         <article class="function" data-name="declareParams">
            <h2>declareParams</h2>
            <hr />
            
            <pre><code>func declareParams()</code></pre>
         </article>
         
         <article class="function" data-name="addLocal">
            <h2>addLocal</h2>
            <hr />
            
            <pre><code>func addLocal(name *ir.Name)</code></pre>
         </article>
         
         <article class="function" data-name="useLocal">
            <h2>useLocal</h2>
            <hr />
            
            <pre><code>func useLocal() *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="openScope">
            <h2>openScope</h2>
            <hr />
            
            <pre><code>func openScope()</code></pre>
         </article>
         
         <article class="function" data-name="closeScope">
            <h2>closeScope</h2>
            <hr />
            
            <pre><code>func closeScope()</code></pre>
         </article>
         
         <article class="function" data-name="closeAnotherScope">
            <h2>closeAnotherScope</h2>
            <hr />
            
            <p>closeAnotherScope is like closeScope, but it reuses the same mark
position as the last closeScope call. This is useful for "for" and
"if" statements, as their implicit blocks always end at the same
position as an explicit block.</p>
            
            <pre><code>func closeAnotherScope()</code></pre>
         </article>
         
         <article class="function" data-name="stmt">
            <h2>stmt</h2>
            <hr />
            
            <pre><code>func stmt() ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="block">
            <h2>block</h2>
            <hr />
            
            <pre><code>func block(stmts []ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="stmts">
            <h2>stmts</h2>
            <hr />
            
            <pre><code>func stmts() ir.Nodes</code></pre>
         </article>
         
         <article class="function" data-name="stmt1">
            <h2>stmt1</h2>
            <hr />
            
            <pre><code>func stmt1(tag codeStmt, out *ir.Nodes) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="assignList">
            <h2>assignList</h2>
            <hr />
            
            <pre><code>func assignList() ([]*ir.Name, []ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="assign">
            <h2>assign</h2>
            <hr />
            
            <p>assign returns an assignee expression. It also reports whether the
returned expression is a newly declared variable.</p>
            
            <pre><code>func assign() (ir.Node, bool)</code></pre>
         </article>
         
         <article class="function" data-name="blockStmt">
            <h2>blockStmt</h2>
            <hr />
            
            <pre><code>func blockStmt() []ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="forStmt">
            <h2>forStmt</h2>
            <hr />
            
            <pre><code>func forStmt(label *types.Sym) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="ifStmt">
            <h2>ifStmt</h2>
            <hr />
            
            <pre><code>func ifStmt() ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="selectStmt">
            <h2>selectStmt</h2>
            <hr />
            
            <pre><code>func selectStmt(label *types.Sym) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="switchStmt">
            <h2>switchStmt</h2>
            <hr />
            
            <pre><code>func switchStmt(label *types.Sym) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="label">
            <h2>label</h2>
            <hr />
            
            <pre><code>func label() *types.Sym</code></pre>
         </article>
         
         <article class="function" data-name="optLabel">
            <h2>optLabel</h2>
            <hr />
            
            <pre><code>func optLabel() *types.Sym</code></pre>
         </article>
         
         <article class="function" data-name="initDefn">
            <h2>initDefn</h2>
            <hr />
            
            <p>initDefn marks the given names as declared by defn and populates
its Init field with ODCL nodes. It then reports whether any names
were so declared, which can be used to initialize defn.Def.</p>
            
            <pre><code>func initDefn(defn ir.InitNode, names []*ir.Name) bool</code></pre>
         </article>
         
         <article class="function" data-name="expr">
            <h2>expr</h2>
            <hr />
            
            <p>expr reads and returns a typechecked expression.</p>
            
            <pre><code>func expr() res ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="funcInst">
            <h2>funcInst</h2>
            <hr />
            
            <p>funcInst reads an instantiated function reference, and returns
three (possibly nil) expressions related to it:

baseFn is always non-nil: it's either a function of the appropriate
type already, or it has an extra dictionary parameter as the first
parameter.

If dictPtr is non-nil, then it's a dictionary argument that must be
passed as the first argument to baseFn.

If wrapperFn is non-nil, then it's either the same as baseFn (if
dictPtr is nil), or it's semantically equivalent to currying baseFn
to pass dictPtr. (wrapperFn is nil when dictPtr is an expression
that needs to be computed dynamically.)

For callers that are creating a call to the returned function, it's
best to emit a call to baseFn, and include dictPtr in the arguments
list as appropriate.

For callers that want to return the function without invoking it,
they may return wrapperFn if it's non-nil; but otherwise, they need
to create their own wrapper.</p>
            
            <pre><code>func funcInst(pos src.XPos) (wrapperFn ir.Node, baseFn ir.Node, dictPtr ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="objDictName">
            <h2>objDictName</h2>
            <hr />
            
            <pre><code>func objDictName(idx index, implicits []*types.Type, explicits []*types.Type) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="curry">
            <h2>curry</h2>
            <hr />
            
            <p>curry returns a function literal that calls fun with arg0 and
(optionally) arg1, accepting additional arguments to the function
literal as necessary to satisfy fun's signature.

If nilCheck is true and arg0 is an interface value, then it's
checked to be non-nil as an initial step at the point of evaluating
the function literal itself.</p>
            
            <pre><code>func curry(origPos src.XPos, ifaceHack bool, fun ir.Node, arg0 ir.Node, arg1 ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="methodExprWrap">
            <h2>methodExprWrap</h2>
            <hr />
            
            <p>methodExprWrap returns a function literal that changes method's
first parameter's type to recv, and uses implicits/deref/addr to
select the appropriate receiver parameter to pass to method.</p>
            
            <pre><code>func methodExprWrap(origPos src.XPos, recv *types.Type, implicits []int, deref bool, addr bool, method ir.Node, dictPtr ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="syntheticClosure">
            <h2>syntheticClosure</h2>
            <hr />
            
            <p>syntheticClosure constructs a synthetic function literal for
currying dictionary arguments. origPos is the position used for the
closure, which must be a non-inlined position. typ is the function
literal's signature type.

captures is a list of expressions that need to be evaluated at the
point of function literal evaluation and captured by the function
literal. If ifaceHack is true and captures[1] is an interface type,
it's checked to be non-nil after evaluation.

addBody is a callback function to populate the function body. The
list of captured values passed back has the captured variables for
use within the function literal, corresponding to the expressions
in captures.</p>
            
            <pre><code>func syntheticClosure(origPos src.XPos, typ *types.Type, ifaceHack bool, captures ir.Nodes, addBody func) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="syntheticSig">
            <h2>syntheticSig</h2>
            <hr />
            
            <p>syntheticSig duplicates and returns the params and results lists
for sig, but renaming anonymous parameters so they can be assigned
ir.Names.</p>
            
            <pre><code>func syntheticSig(sig *types.Type) (params []*types.Field, results []*types.Field)</code></pre>
         </article>
         
         <article class="function" data-name="optExpr">
            <h2>optExpr</h2>
            <hr />
            
            <pre><code>func optExpr() ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="methodExpr">
            <h2>methodExpr</h2>
            <hr />
            
            <p>methodExpr reads a method expression reference, and returns three
(possibly nil) expressions related to it:

baseFn is always non-nil: it's either a function of the appropriate
type already, or it has an extra dictionary parameter as the second
parameter (i.e., immediately after the promoted receiver
parameter).

If dictPtr is non-nil, then it's a dictionary argument that must be
passed as the second argument to baseFn.

If wrapperFn is non-nil, then it's either the same as baseFn (if
dictPtr is nil), or it's semantically equivalent to currying baseFn
to pass dictPtr. (wrapperFn is nil when dictPtr is an expression
that needs to be computed dynamically.)

For callers that are creating a call to the returned method, it's
best to emit a call to baseFn, and include dictPtr in the arguments
list as appropriate.

For callers that want to return a method expression without
invoking it, they may return wrapperFn if it's non-nil; but
otherwise, they need to create their own wrapper.</p>
            
            <pre><code>func methodExpr() (wrapperFn ir.Node, baseFn ir.Node, dictPtr ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="shapedMethodExpr">
            <h2>shapedMethodExpr</h2>
            <hr />
            
            <p>shapedMethodExpr returns the specified method on the given shaped
type.</p>
            
            <pre><code>func shapedMethodExpr(pos src.XPos, obj *ir.Name, sym *types.Sym) *ir.SelectorExpr</code></pre>
         </article>
         
         <article class="function" data-name="multiExpr">
            <h2>multiExpr</h2>
            <hr />
            
            <pre><code>func multiExpr() []ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="temp">
            <h2>temp</h2>
            <hr />
            
            <p>temp returns a new autotemp of the specified type.</p>
            
            <pre><code>func temp(pos src.XPos, typ *types.Type) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="tempCopy">
            <h2>tempCopy</h2>
            <hr />
            
            <p>tempCopy declares and returns a new autotemp initialized to the
value of expr.</p>
            
            <pre><code>func tempCopy(pos src.XPos, expr ir.Node, init *ir.Nodes) *ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="compLit">
            <h2>compLit</h2>
            <hr />
            
            <pre><code>func compLit() ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="funcLit">
            <h2>funcLit</h2>
            <hr />
            
            <pre><code>func funcLit() ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="inlClosureFunc">
            <h2>inlClosureFunc</h2>
            <hr />
            
            <p>inlClosureFunc constructs a new closure function, but correctly
handles inlining.</p>
            
            <pre><code>func inlClosureFunc(origPos src.XPos, sig *types.Type, why ir.Op) *ir.Func</code></pre>
         </article>
         
         <article class="function" data-name="exprList">
            <h2>exprList</h2>
            <hr />
            
            <pre><code>func exprList() []ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="exprs">
            <h2>exprs</h2>
            <hr />
            
            <pre><code>func exprs() []ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="dictWord">
            <h2>dictWord</h2>
            <hr />
            
            <p>dictWord returns an expression to return the specified
uintptr-typed word from the dictionary parameter.</p>
            
            <pre><code>func dictWord(pos src.XPos, idx int) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="rttiWord">
            <h2>rttiWord</h2>
            <hr />
            
            <p>rttiWord is like dictWord, but converts it to *byte (the type used
internally to represent *runtime._type and *runtime.itab).</p>
            
            <pre><code>func rttiWord(pos src.XPos, idx int) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="rtype">
            <h2>rtype</h2>
            <hr />
            
            <p>rtype reads a type reference from the element bitstream, and
returns an expression of type *runtime._type representing that
type.</p>
            
            <pre><code>func rtype(pos src.XPos) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="rtype0">
            <h2>rtype0</h2>
            <hr />
            
            <pre><code>func rtype0(pos src.XPos) (typ *types.Type, rtype ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="varDictIndex">
            <h2>varDictIndex</h2>
            <hr />
            
            <p>varDictIndex populates name.DictIndex if name is a derived type.</p>
            
            <pre><code>func varDictIndex(name *ir.Name)</code></pre>
         </article>
         
         <article class="function" data-name="itab">
            <h2>itab</h2>
            <hr />
            
            <p>itab returns a (typ, iface) pair of types.

typRType and ifaceRType are expressions that evaluate to the
*runtime._type for typ and iface, respectively.

If typ is a concrete type and iface is a non-empty interface type,
then itab is an expression that evaluates to the *runtime.itab for
the pair. Otherwise, itab is nil.</p>
            
            <pre><code>func itab(pos src.XPos) (typ *types.Type, typRType ir.Node, iface *types.Type, ifaceRType ir.Node, itab ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="convRTTI">
            <h2>convRTTI</h2>
            <hr />
            
            <p>convRTTI returns expressions appropriate for populating an
ir.ConvExpr's TypeWord and SrcRType fields, respectively.</p>
            
            <pre><code>func convRTTI(pos src.XPos) (typeWord ir.Node, srcRType ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="exprType">
            <h2>exprType</h2>
            <hr />
            
            <pre><code>func exprType() ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="op">
            <h2>op</h2>
            <hr />
            
            <pre><code>func op() ir.Op</code></pre>
         </article>
         
         <article class="function" data-name="pkgInit">
            <h2>pkgInit</h2>
            <hr />
            
            <pre><code>func pkgInit(self *types.Pkg, target *ir.Package)</code></pre>
         </article>
         
         <article class="function" data-name="pkgInitOrder">
            <h2>pkgInitOrder</h2>
            <hr />
            
            <p>pkgInitOrder creates a synthetic init function to handle any
package-scope initialization statements.</p>
            
            <pre><code>func pkgInitOrder(target *ir.Package)</code></pre>
         </article>
         
         <article class="function" data-name="pkgDecls">
            <h2>pkgDecls</h2>
            <hr />
            
            <pre><code>func pkgDecls(target *ir.Package)</code></pre>
         </article>
         
         <article class="function" data-name="pkgObjs">
            <h2>pkgObjs</h2>
            <hr />
            
            <pre><code>func pkgObjs(target *ir.Package) []*ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="unifiedHaveInlineBody">
            <h2>unifiedHaveInlineBody</h2>
            <hr />
            
            <p>unifiedHaveInlineBody reports whether we have the function body for
fn, so we can inline it.</p>
            
            <pre><code>func unifiedHaveInlineBody(fn *ir.Func) bool</code></pre>
         </article>
         
         <article class="function" data-name="unifiedInlineCall">
            <h2>unifiedInlineCall</h2>
            <hr />
            
            <p>unifiedInlineCall implements inline.NewInline by re-reading the function
body from its Unified IR export data.</p>
            
            <pre><code>func unifiedInlineCall(callerfn *ir.Func, call *ir.CallExpr, fn *ir.Func, inlIndex int) *ir.InlinedCallExpr</code></pre>
         </article>
         
         <article class="function" data-name="inlReturn">
            <h2>inlReturn</h2>
            <hr />
            
            <p>inlReturn returns a statement that can substitute for the given
return statement when inlining.</p>
            
            <pre><code>func inlReturn(ret *ir.ReturnStmt, retvars []*ir.Name) *ir.BlockStmt</code></pre>
         </article>
         
         <article class="function" data-name="expandInline">
            <h2>expandInline</h2>
            <hr />
            
            <p>expandInline reads in an extra copy of IR to populate
fn.Inl.Dcl.</p>
            
            <pre><code>func expandInline(fn *ir.Func, pri pkgReaderIndex)</code></pre>
         </article>
         
         <article class="function" data-name="usedLocals">
            <h2>usedLocals</h2>
            <hr />
            
            <p>usedLocals returns a set of local variables that are used within body.</p>
            
            <pre><code>func usedLocals(body []ir.Node) ir.NameSet</code></pre>
         </article>
         
         <article class="function" data-name="needWrapper">
            <h2>needWrapper</h2>
            <hr />
            
            <p>needWrapper records that wrapper methods may be needed at link
time.</p>
            
            <pre><code>func needWrapper(typ *types.Type)</code></pre>
         </article>
         
         <article class="function" data-name="importedDef">
            <h2>importedDef</h2>
            <hr />
            
            <p>importedDef reports whether r is reading from an imported and
non-generic element.

If a type was found in an imported package, then we can assume that
package (or one of its transitive dependencies) already generated
method wrappers for it.

Exception: If we're instantiating an imported generic type or
function, we might be instantiating it with type arguments not
previously seen before.

TODO(mdempsky): Distinguish when a generic function or type was
instantiated in an imported package so that we can add types to
haveWrapperTypes instead.</p>
            
            <pre><code>func importedDef() bool</code></pre>
         </article>
         
         <article class="function" data-name="MakeWrappers">
            <h2>MakeWrappers</h2>
            <hr />
            
            <p>MakeWrappers constructs all wrapper methods needed for the target
compilation unit.</p>
            
            <pre><code>func MakeWrappers(target *ir.Package)</code></pre>
         </article>
         
         <article class="function" data-name="wrapType">
            <h2>wrapType</h2>
            <hr />
            
            <pre><code>func wrapType(typ *types.Type, target *ir.Package, seen *ast.MapType, needed bool)</code></pre>
         </article>
         
         <article class="function" data-name="methodWrapper">
            <h2>methodWrapper</h2>
            <hr />
            
            <pre><code>func methodWrapper(derefs int, tbase *types.Type, method *types.Field, target *ir.Package)</code></pre>
         </article>
         
         <article class="function" data-name="wrapMethodValue">
            <h2>wrapMethodValue</h2>
            <hr />
            
            <pre><code>func wrapMethodValue(recvType *types.Type, method *types.Field, target *ir.Package, needed bool)</code></pre>
         </article>
         
         <article class="function" data-name="newWrapperFunc">
            <h2>newWrapperFunc</h2>
            <hr />
            
            <pre><code>func newWrapperFunc(pos src.XPos, sym *types.Sym, wrapper *types.Type, method *types.Field) *ir.Func</code></pre>
         </article>
         
         <article class="function" data-name="finishWrapperFunc">
            <h2>finishWrapperFunc</h2>
            <hr />
            
            <pre><code>func finishWrapperFunc(fn *ir.Func, target *ir.Package)</code></pre>
         </article>
         
         <article class="function" data-name="newWrapperType">
            <h2>newWrapperType</h2>
            <hr />
            
            <p>newWrapperType returns a copy of the given signature type, but with
the receiver parameter type substituted with recvType.
If recvType is nil, newWrapperType returns a signature
without a receiver parameter.</p>
            
            <pre><code>func newWrapperType(recvType *types.Type, method *types.Field) *types.Type</code></pre>
         </article>
         
         <article class="function" data-name="addTailCall">
            <h2>addTailCall</h2>
            <hr />
            
            <pre><code>func addTailCall(pos src.XPos, fn *ir.Func, recv ir.Node, method *types.Field)</code></pre>
         </article>
         
         <article class="function" data-name="setBasePos">
            <h2>setBasePos</h2>
            <hr />
            
            <pre><code>func setBasePos(pos src.XPos)</code></pre>
         </article>
         
         <article class="function" data-name="shapeSig">
            <h2>shapeSig</h2>
            <hr />
            
            <p>shapeSig returns a copy of fn's signature, except adding a
dictionary parameter and promoting the receiver parameter (if any)
to a normal parameter.

The parameter types.Fields are all copied too, so their Nname
fields can be initialized for use by the shape function.</p>
            
            <pre><code>func shapeSig(fn *ir.Func, dict *readerDict) *types.Type</code></pre>
         </article>
         
         <article class="function" data-name="deref2">
            <h2>deref2</h2>
            <hr />
            
            <p>deref2 does a single deref of types2 type t, if it is a pointer type.</p>
            
            <pre><code>func deref2(t types2.Type) types2.Type</code></pre>
         </article>
         
         <article class="function" data-name="Marker">
            <h2>Marker</h2>
            <hr />
            
            <pre><code>func Marker() pkgbits.SyncMarker</code></pre>
         </article>
         
         <article class="function" data-name="Value">
            <h2>Value</h2>
            <hr />
            
            <pre><code>func Value() int</code></pre>
         </article>
         
         <article class="function" data-name="Marker">
            <h2>Marker</h2>
            <hr />
            
            <pre><code>func Marker() pkgbits.SyncMarker</code></pre>
         </article>
         
         <article class="function" data-name="Value">
            <h2>Value</h2>
            <hr />
            
            <pre><code>func Value() int</code></pre>
         </article>
         
         <article class="function" data-name="Marker">
            <h2>Marker</h2>
            <hr />
            
            <pre><code>func Marker() pkgbits.SyncMarker</code></pre>
         </article>
         
         <article class="function" data-name="Value">
            <h2>Value</h2>
            <hr />
            
            <pre><code>func Value() int</code></pre>
         </article>
         
         <article class="function" data-name="Marker">
            <h2>Marker</h2>
            <hr />
            
            <pre><code>func Marker() pkgbits.SyncMarker</code></pre>
         </article>
         
         <article class="function" data-name="Value">
            <h2>Value</h2>
            <hr />
            
            <pre><code>func Value() int</code></pre>
         </article>
         
         <article class="function" data-name="isSpace">
            <h2>isSpace</h2>
            <hr />
            
            <pre><code>func isSpace(c rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="isQuoted">
            <h2>isQuoted</h2>
            <hr />
            
            <pre><code>func isQuoted(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="pragmaFlag">
            <h2>pragmaFlag</h2>
            <hr />
            
            <pre><code>func pragmaFlag(verb string) ir.PragmaFlag</code></pre>
         </article>
         
         <article class="function" data-name="pragcgo">
            <h2>pragcgo</h2>
            <hr />
            
            <p>pragcgo is called concurrently if files are parsed concurrently.</p>
            
            <pre><code>func pragcgo(pos syntax.Pos, text string)</code></pre>
         </article>
         
         <article class="function" data-name="pragmaFields">
            <h2>pragmaFields</h2>
            <hr />
            
            <p>pragmaFields is similar to strings.FieldsFunc(s, isSpace)
but does not split when inside double quoted regions and always
splits before the start and after the end of a double quoted region.
pragmaFields does not recognize escaped quotes. If a quote in s is not
closed the part after the opening quote will not be returned as a field.</p>
            
            <pre><code>func pragmaFields(s string) []string</code></pre>
         </article>
         
         <article class="function" data-name="relocAll">
            <h2>relocAll</h2>
            <hr />
            
            <p>relocAll ensures that all elements specified by pr and relocs are
copied into the output export data file, and returns the
corresponding indices in the output.</p>
            
            <pre><code>func relocAll(pr *pkgReader, relocs []pkgbits.RelocEnt) []pkgbits.RelocEnt</code></pre>
         </article>
         
         <article class="function" data-name="relocIdx">
            <h2>relocIdx</h2>
            <hr />
            
            <p>relocIdx ensures a single element is copied into the output export
data file, and returns the corresponding index in the output.</p>
            
            <pre><code>func relocIdx(pr *pkgReader, k pkgbits.RelocKind, idx index) index</code></pre>
         </article>
         
         <article class="function" data-name="relocString">
            <h2>relocString</h2>
            <hr />
            
            <p>relocString copies the specified string from pr into the output
export data file, deduplicating it against other strings.</p>
            
            <pre><code>func relocString(pr *pkgReader, idx index) index</code></pre>
         </article>
         
         <article class="function" data-name="relocPkg">
            <h2>relocPkg</h2>
            <hr />
            
            <p>relocPkg copies the specified package from pr into the output
export data file, rewriting its import path to match how it was
imported.

TODO(mdempsky): Since CL 391014, we already have the compilation
unit's import path, so there should be no need to rewrite packages
anymore.</p>
            
            <pre><code>func relocPkg(pr *pkgReader, idx index) index</code></pre>
         </article>
         
         <article class="function" data-name="relocObj">
            <h2>relocObj</h2>
            <hr />
            
            <p>relocObj copies the specified object from pr into the output export
data file, rewriting its compiler-private extension data (e.g.,
adding inlining cost and escape analysis results for functions).</p>
            
            <pre><code>func relocObj(pr *pkgReader, idx index) index</code></pre>
         </article>
         
         <article class="function" data-name="exportBody">
            <h2>exportBody</h2>
            <hr />
            
            <p>exportBody exports the given function or method's body, if
appropriate. local indicates whether it's a local function or
method available on a locally declared type. (Due to cross-package
type aliases, a method may be imported, but still available on a
locally declared type.)</p>
            
            <pre><code>func exportBody(obj *ir.Name, local bool)</code></pre>
         </article>
         
         <article class="function" data-name="relocCommon">
            <h2>relocCommon</h2>
            <hr />
            
            <p>relocCommon copies the specified element from pr into w,
recursively relocating any referenced elements as well.</p>
            
            <pre><code>func relocCommon(pr *pkgReader, w *pkgbits.Encoder, k pkgbits.RelocKind, idx index)</code></pre>
         </article>
         
         <article class="function" data-name="pragmaFlag">
            <h2>pragmaFlag</h2>
            <hr />
            
            <pre><code>func pragmaFlag(w *pkgbits.Encoder, pragma ir.PragmaFlag)</code></pre>
         </article>
         
         <article class="function" data-name="relocFuncExt">
            <h2>relocFuncExt</h2>
            <hr />
            
            <pre><code>func relocFuncExt(w *pkgbits.Encoder, name *ir.Name)</code></pre>
         </article>
         
         <article class="function" data-name="relocTypeExt">
            <h2>relocTypeExt</h2>
            <hr />
            
            <pre><code>func relocTypeExt(w *pkgbits.Encoder, name *ir.Name)</code></pre>
         </article>
         
         <article class="function" data-name="relocVarExt">
            <h2>relocVarExt</h2>
            <hr />
            
            <pre><code>func relocVarExt(w *pkgbits.Encoder, name *ir.Name)</code></pre>
         </article>
         
         <article class="function" data-name="linkname">
            <h2>linkname</h2>
            <hr />
            
            <pre><code>func linkname(w *pkgbits.Encoder, name *ir.Name)</code></pre>
         </article>
         
         <article class="function" data-name="lsymIdx">
            <h2>lsymIdx</h2>
            <hr />
            
            <pre><code>func lsymIdx(w *pkgbits.Encoder, linkname string, lsym *obj.LSym) bool</code></pre>
         </article>
         
         <article class="function" data-name="eq">
            <h2>eq</h2>
            <hr />
            
            <pre><code>func eq(a []string, b []string) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestPragmaFields">
            <h2>TestPragmaFields</h2>
            <hr />
            
            <pre><code>func TestPragmaFields(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPragcgo">
            <h2>TestPragcgo</h2>
            <hr />
            
            <pre><code>func TestPragcgo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="pos">
            <h2>pos</h2>
            <hr />
            
            <pre><code>func pos(p poser) src.XPos</code></pre>
         </article>
         
         <article class="function" data-name="end">
            <h2>end</h2>
            <hr />
            
            <pre><code>func end(p ender) src.XPos</code></pre>
         </article>
         
         <article class="function" data-name="makeXPos">
            <h2>makeXPos</h2>
            <hr />
            
            <pre><code>func makeXPos(pos syntax.Pos) src.XPos</code></pre>
         </article>
         
         <article class="function" data-name="makeSrcPosBase">
            <h2>makeSrcPosBase</h2>
            <hr />
            
            <p>makeSrcPosBase translates from a *syntax.PosBase to a *src.PosBase.</p>
            
            <pre><code>func makeSrcPosBase(b0 *syntax.PosBase) *src.PosBase</code></pre>
         </article>
         
         <article class="function" data-name="typeExprEndPos">
            <h2>typeExprEndPos</h2>
            <hr />
            
            <p>typeExprEndPos returns the position that noder would leave base.Pos
after parsing the given type expression.

Deprecated: This function exists to emulate position semantics from
Go 1.17, necessary for compatibility with the backend DWARF
generation logic that assigns variables to their appropriate scope.</p>
            
            <pre><code>func typeExprEndPos(expr0 syntax.Expr) syntax.Pos</code></pre>
         </article>
         
         <article class="function" data-name="lastFieldType">
            <h2>lastFieldType</h2>
            <hr />
            
            <pre><code>func lastFieldType(fields []*syntax.Field) syntax.Expr</code></pre>
         </article>
         
         <article class="function" data-name="LookupFunc">
            <h2>LookupFunc</h2>
            <hr />
            
            <p>LookupFunc returns the ir.Func for an arbitrary full symbol name if
that function exists in the set of available export data.

This allows lookup of arbitrary functions and methods that aren't otherwise
referenced by the local package and thus haven't been read yet.

TODO(prattmic): Does not handle instantiation of generic types. Currently
profiles don't contain the original type arguments, so we won't be able to
create the runtime dictionaries.

TODO(prattmic): Hit rate of this function is usually fairly low, and errors
are only used when debug logging is enabled. Consider constructing cheaper
errors by default.</p>
            
            <pre><code>func LookupFunc(fullName string) (*ir.Func, error)</code></pre>
         </article>
         
         <article class="function" data-name="PostLookupCleanup">
            <h2>PostLookupCleanup</h2>
            <hr />
            
            <p>PostLookupCleanup performs cleanup operations needed
after a series of calls to LookupFunc, specifically invoking
readBodies to post-process any funcs on the "todoBodies" list
that were added as a result of the lookup operations.</p>
            
            <pre><code>func PostLookupCleanup()</code></pre>
         </article>
         
         <article class="function" data-name="lookupFunction">
            <h2>lookupFunction</h2>
            <hr />
            
            <pre><code>func lookupFunction(pkg *types.Pkg, symName string) (*ir.Func, error)</code></pre>
         </article>
         
         <article class="function" data-name="lookupMethod">
            <h2>lookupMethod</h2>
            <hr />
            
            <pre><code>func lookupMethod(pkg *types.Pkg, symName string) (*ir.Func, error)</code></pre>
         </article>
         
         <article class="function" data-name="unified">
            <h2>unified</h2>
            <hr />
            
            <p>unified constructs the local package's Internal Representation (IR)
from its syntax tree (AST).

The pipeline contains 2 steps:

 1. Generate the export data "stub".

 2. Generate the IR from the export data above.

The package data "stub" at step (1) contains everything from the local package,
but nothing that has been imported. When we're actually writing out export data
to the output files (see writeNewExport), we run the "linker", which:

  - Updates compiler extensions data (e.g. inlining cost, escape analysis results).

  - Handles re-exporting any transitive dependencies.

  - Prunes out any unnecessary details (e.g. non-inlineable functions, because any
    downstream importers only care about inlinable functions).

The source files are typechecked twice: once before writing the export data
using types2, and again after reading the export data using gc/typecheck.
The duplication of work will go away once we only use the types2 type checker,
removing the gc/typecheck step. For now, it is kept because:

  - It reduces the engineering costs in maintaining a fork of typecheck
    (e.g. no need to backport fixes like CL 327651).

  - It makes it easier to pass toolstash -cmp.

  - Historically, we would always re-run the typechecker after importing a package,
    even though we know the imported data is valid. It's not ideal, but it's
    not causing any problems either.

  - gc/typecheck is still in charge of some transformations, such as rewriting
    multi-valued function calls or transforming ir.OINDEX to ir.OINDEXMAP.

Using the syntax tree with types2, which has a complete representation of generics,
the unified IR has the full typed AST needed for introspection during step (1).
In other words, we have all the necessary information to build the generic IR form
(see writer.captureVars for an example).</p>
            
            <pre><code>func unified(m posMap, noders []*noder)</code></pre>
         </article>
         
         <article class="function" data-name="readBodies">
            <h2>readBodies</h2>
            <hr />
            
            <p>readBodies iteratively expands all pending dictionaries and
function bodies.

If duringInlining is true, then the inline.InlineDecls is called as
necessary on instantiations of imported generic functions, so their
inlining costs can be computed.</p>
            
            <pre><code>func readBodies(target *ir.Package, duringInlining bool)</code></pre>
         </article>
         
         <article class="function" data-name="writePkgStub">
            <h2>writePkgStub</h2>
            <hr />
            
            <p>writePkgStub type checks the given parsed source files,
writes an export data package stub representing them,
and returns the result.</p>
            
            <pre><code>func writePkgStub(m posMap, noders []*noder) string</code></pre>
         </article>
         
         <article class="function" data-name="freePackage">
            <h2>freePackage</h2>
            <hr />
            
            <p>freePackage ensures the given package is garbage collected.</p>
            
            <pre><code>func freePackage(pkg *types2.Package)</code></pre>
         </article>
         
         <article class="function" data-name="readPackage">
            <h2>readPackage</h2>
            <hr />
            
            <p>readPackage reads package export data from pr to populate
importpkg.

localStub indicates whether pr is reading the stub export data for
the local package, as opposed to relocated export data for an
import.</p>
            
            <pre><code>func readPackage(pr *pkgReader, importpkg *types.Pkg, localStub bool)</code></pre>
         </article>
         
         <article class="function" data-name="writeUnifiedExport">
            <h2>writeUnifiedExport</h2>
            <hr />
            
            <p>writeUnifiedExport writes to `out` the finalized, self-contained
Unified IR export data file for the current compilation unit.</p>
            
            <pre><code>func writeUnifiedExport(out io.Writer)</code></pre>
         </article>
         
         <article class="function" data-name="WriteExports">
            <h2>WriteExports</h2>
            <hr />
            
            <pre><code>func WriteExports(out *bio.Writer)</code></pre>
         </article>
         
         <article class="function" data-name="Implicit">
            <h2>Implicit</h2>
            <hr />
            
            <p>Implicit returns n after marking it as Implicit.</p>
            
            <pre><code>func Implicit(n ImplicitNode) ImplicitNode</code></pre>
         </article>
         
         <article class="function" data-name="typed">
            <h2>typed</h2>
            <hr />
            
            <p>typed returns n after setting its type to typ.</p>
            
            <pre><code>func typed(typ *types.Type, n ir.Node) ir.Node</code></pre>
         </article>
         
         <article class="function" data-name="FixValue">
            <h2>FixValue</h2>
            <hr />
            
            <p>FixValue returns val after converting and truncating it as
appropriate for typ.</p>
            
            <pre><code>func FixValue(typ *types.Type, val constant.Value) constant.Value</code></pre>
         </article>
         
         <article class="function" data-name="Addr">
            <h2>Addr</h2>
            <hr />
            
            <pre><code>func Addr(pos src.XPos, x ir.Node) *ir.AddrExpr</code></pre>
         </article>
         
         <article class="function" data-name="Deref">
            <h2>Deref</h2>
            <hr />
            
            <pre><code>func Deref(pos src.XPos, typ *types.Type, x ir.Node) *ir.StarExpr</code></pre>
         </article>
         
         <article class="function" data-name="idealType">
            <h2>idealType</h2>
            <hr />
            
            <pre><code>func idealType(tv syntax.TypeAndValue) types2.Type</code></pre>
         </article>
         
         <article class="function" data-name="isTypeParam">
            <h2>isTypeParam</h2>
            <hr />
            
            <pre><code>func isTypeParam(t types2.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="isNotInHeap">
            <h2>isNotInHeap</h2>
            <hr />
            
            <p>isNotInHeap reports whether typ is or contains an element of type
internal/runtime/sys.NotInHeap.</p>
            
            <pre><code>func isNotInHeap(typ types2.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="checkFiles">
            <h2>checkFiles</h2>
            <hr />
            
            <p>checkFiles configures and runs the types2 checker on the given
parsed source files and then returns the result.
The map result value indicates which closures are generated from the bodies of range function loops.</p>
            
            <pre><code>func checkFiles(m posMap, noders []*noder) (*types2.Package, *types2.Info, *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="hasCycle">
            <h2>hasCycle</h2>
            <hr />
            
            <p>hasCycle reports whether typ is part of an anonymous interface cycle.</p>
            
            <pre><code>func hasCycle(typ *types2.Interface) bool</code></pre>
         </article>
         
         <article class="function" data-name="visit">
            <h2>visit</h2>
            <hr />
            
            <p>visit recursively walks typ0 to check any referenced interface types.</p>
            
            <pre><code>func visit(typ0 types2.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="assert">
            <h2>assert</h2>
            <hr />
            
            <pre><code>func assert(p bool)</code></pre>
         </article>
         
         <article class="function" data-name="newPkgWriter">
            <h2>newPkgWriter</h2>
            <hr />
            
            <p>newPkgWriter returns an initialized pkgWriter for the specified
package.</p>
            
            <pre><code>func newPkgWriter(m posMap, pkg *types2.Package, info *types2.Info, otherInfo *ast.MapType) *pkgWriter</code></pre>
         </article>
         
         <article class="function" data-name="errorf">
            <h2>errorf</h2>
            <hr />
            
            <p>errorf reports a user error about thing p.</p>
            
            <pre><code>func errorf(p poser, msg string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="fatalf">
            <h2>fatalf</h2>
            <hr />
            
            <p>fatalf reports an internal compiler error about thing p.</p>
            
            <pre><code>func fatalf(p poser, msg string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="unexpected">
            <h2>unexpected</h2>
            <hr />
            
            <p>unexpected reports a fatal error about a thing of unexpected
dynamic type.</p>
            
            <pre><code>func unexpected(what string, p poser)</code></pre>
         </article>
         
         <article class="function" data-name="typeAndValue">
            <h2>typeAndValue</h2>
            <hr />
            
            <pre><code>func typeAndValue(x syntax.Expr) syntax.TypeAndValue</code></pre>
         </article>
         
         <article class="function" data-name="maybeTypeAndValue">
            <h2>maybeTypeAndValue</h2>
            <hr />
            
            <pre><code>func maybeTypeAndValue(x syntax.Expr) (syntax.TypeAndValue, bool)</code></pre>
         </article>
         
         <article class="function" data-name="typeOf">
            <h2>typeOf</h2>
            <hr />
            
            <p>typeOf returns the Type of the given value expression.</p>
            
            <pre><code>func typeOf(expr syntax.Expr) types2.Type</code></pre>
         </article>
         
         <article class="function" data-name="typeParamIndex">
            <h2>typeParamIndex</h2>
            <hr />
            
            <p>typeParamIndex returns the index of the given type parameter within
the dictionary. This may differ from typ.Index() when there are
implicit type parameters due to defined types declared within a
generic function or method.</p>
            
            <pre><code>func typeParamIndex(typ *types2.TypeParam) int</code></pre>
         </article>
         
         <article class="function" data-name="anyDerived">
            <h2>anyDerived</h2>
            <hr />
            
            <p>anyDerived reports whether any of info's explicit type arguments
are derived types.</p>
            
            <pre><code>func anyDerived() bool</code></pre>
         </article>
         
         <article class="function" data-name="equals">
            <h2>equals</h2>
            <hr />
            
            <p>equals reports whether info and other represent the same Go object
(i.e., same base object and identical type arguments, if any).</p>
            
            <pre><code>func equals(other objInfo) bool</code></pre>
         </article>
         
         <article class="function" data-name="typeParamMethodExprIdx">
            <h2>typeParamMethodExprIdx</h2>
            <hr />
            
            <p>typeParamMethodExprIdx returns the index where the given encoded
method expression function pointer appears within this dictionary's
type parameters method expressions section, adding it if necessary.</p>
            
            <pre><code>func typeParamMethodExprIdx(typeParamIdx int, methodInfo selectorInfo) int</code></pre>
         </article>
         
         <article class="function" data-name="subdictIdx">
            <h2>subdictIdx</h2>
            <hr />
            
            <p>subdictIdx returns the index where the given encoded object's
runtime dictionary appears within this dictionary's subdictionary
section, adding it if necessary.</p>
            
            <pre><code>func subdictIdx(newInfo objInfo) int</code></pre>
         </article>
         
         <article class="function" data-name="rtypeIdx">
            <h2>rtypeIdx</h2>
            <hr />
            
            <p>rtypeIdx returns the index where the given encoded type's
*runtime._type value appears within this dictionary's rtypes
section, adding it if necessary.</p>
            
            <pre><code>func rtypeIdx(newInfo typeInfo) int</code></pre>
         </article>
         
         <article class="function" data-name="itabIdx">
            <h2>itabIdx</h2>
            <hr />
            
            <p>itabIdx returns the index where the given encoded type pair's
*runtime.itab value appears within this dictionary's itabs section,
adding it if necessary.</p>
            
            <pre><code>func itabIdx(typInfo typeInfo, ifaceInfo typeInfo) int</code></pre>
         </article>
         
         <article class="function" data-name="newWriter">
            <h2>newWriter</h2>
            <hr />
            
            <pre><code>func newWriter(k pkgbits.RelocKind, marker pkgbits.SyncMarker) *writer</code></pre>
         </article>
         
         <article class="function" data-name="pos">
            <h2>pos</h2>
            <hr />
            
            <p>pos writes the position of p into the element bitstream.</p>
            
            <pre><code>func pos(p poser)</code></pre>
         </article>
         
         <article class="function" data-name="posBase">
            <h2>posBase</h2>
            <hr />
            
            <p>posBase writes a reference to the given PosBase into the element
bitstream.</p>
            
            <pre><code>func posBase(b *syntax.PosBase)</code></pre>
         </article>
         
         <article class="function" data-name="posBaseIdx">
            <h2>posBaseIdx</h2>
            <hr />
            
            <p>posBaseIdx returns the index for the given PosBase.</p>
            
            <pre><code>func posBaseIdx(b *syntax.PosBase) index</code></pre>
         </article>
         
         <article class="function" data-name="pkg">
            <h2>pkg</h2>
            <hr />
            
            <p>pkg writes a use of the given Package into the element bitstream.</p>
            
            <pre><code>func pkg(pkg *types2.Package)</code></pre>
         </article>
         
         <article class="function" data-name="pkgRef">
            <h2>pkgRef</h2>
            <hr />
            
            <pre><code>func pkgRef(idx index)</code></pre>
         </article>
         
         <article class="function" data-name="pkgIdx">
            <h2>pkgIdx</h2>
            <hr />
            
            <p>pkgIdx returns the index for the given package, adding it to the
package export data if needed.</p>
            
            <pre><code>func pkgIdx(pkg *types2.Package) index</code></pre>
         </article>
         
         <article class="function" data-name="typ">
            <h2>typ</h2>
            <hr />
            
            <p>typ writes a use of the given type into the bitstream.</p>
            
            <pre><code>func typ(typ types2.Type)</code></pre>
         </article>
         
         <article class="function" data-name="typInfo">
            <h2>typInfo</h2>
            <hr />
            
            <p>typInfo writes a use of the given type (specified as a typeInfo
instead) into the bitstream.</p>
            
            <pre><code>func typInfo(info typeInfo)</code></pre>
         </article>
         
         <article class="function" data-name="typIdx">
            <h2>typIdx</h2>
            <hr />
            
            <p>typIdx returns the index where the export data description of type
can be read back in. If no such index exists yet, it's created.

typIdx also reports whether typ is a derived type; that is, whether
its identity depends on type parameters.</p>
            
            <pre><code>func typIdx(typ types2.Type, dict *writerDict) typeInfo</code></pre>
         </article>
         
         <article class="function" data-name="namedType">
            <h2>namedType</h2>
            <hr />
            
            <p>namedType writes a use of the given named type into the bitstream.</p>
            
            <pre><code>func namedType(obj *types2.TypeName, targs *types2.TypeList)</code></pre>
         </article>
         
         <article class="function" data-name="structType">
            <h2>structType</h2>
            <hr />
            
            <pre><code>func structType(typ *types2.Struct)</code></pre>
         </article>
         
         <article class="function" data-name="unionType">
            <h2>unionType</h2>
            <hr />
            
            <pre><code>func unionType(typ *types2.Union)</code></pre>
         </article>
         
         <article class="function" data-name="interfaceType">
            <h2>interfaceType</h2>
            <hr />
            
            <pre><code>func interfaceType(typ *types2.Interface)</code></pre>
         </article>
         
         <article class="function" data-name="signature">
            <h2>signature</h2>
            <hr />
            
            <pre><code>func signature(sig *types2.Signature)</code></pre>
         </article>
         
         <article class="function" data-name="params">
            <h2>params</h2>
            <hr />
            
            <pre><code>func params(typ *types2.Tuple)</code></pre>
         </article>
         
         <article class="function" data-name="param">
            <h2>param</h2>
            <hr />
            
            <pre><code>func param(param *types2.Var)</code></pre>
         </article>
         
         <article class="function" data-name="obj">
            <h2>obj</h2>
            <hr />
            
            <p>obj writes a use of the given object into the bitstream.

If obj is a generic object, then explicits are the explicit type
arguments used to instantiate it (i.e., used to substitute the
object's own declared type parameters).</p>
            
            <pre><code>func obj(obj types2.Object, explicits *types2.TypeList)</code></pre>
         </article>
         
         <article class="function" data-name="objInfo">
            <h2>objInfo</h2>
            <hr />
            
            <p>objInfo writes a use of the given encoded object into the
bitstream.</p>
            
            <pre><code>func objInfo(info objInfo)</code></pre>
         </article>
         
         <article class="function" data-name="objInstIdx">
            <h2>objInstIdx</h2>
            <hr />
            
            <p>objInstIdx returns the indices for an object and a corresponding
list of type arguments used to instantiate it, adding them to the
export data as needed.</p>
            
            <pre><code>func objInstIdx(obj types2.Object, explicits *types2.TypeList, dict *writerDict) objInfo</code></pre>
         </article>
         
         <article class="function" data-name="objIdx">
            <h2>objIdx</h2>
            <hr />
            
            <p>objIdx returns the index for the given Object, adding it to the
export data as needed.</p>
            
            <pre><code>func objIdx(obj types2.Object) index</code></pre>
         </article>
         
         <article class="function" data-name="doObj">
            <h2>doObj</h2>
            <hr />
            
            <p>doObj writes the RelocObj definition for obj to w, and the
RelocObjExt definition to wext.</p>
            
            <pre><code>func doObj(wext *writer, obj types2.Object) pkgbits.CodeObj</code></pre>
         </article>
         
         <article class="function" data-name="objDict">
            <h2>objDict</h2>
            <hr />
            
            <p>objDict writes the dictionary needed for reading the given object.</p>
            
            <pre><code>func objDict(obj types2.Object, dict *writerDict)</code></pre>
         </article>
         
         <article class="function" data-name="typeParamNames">
            <h2>typeParamNames</h2>
            <hr />
            
            <pre><code>func typeParamNames(tparams *types2.TypeParamList)</code></pre>
         </article>
         
         <article class="function" data-name="method">
            <h2>method</h2>
            <hr />
            
            <pre><code>func method(wext *writer, meth *types2.Func)</code></pre>
         </article>
         
         <article class="function" data-name="qualifiedIdent">
            <h2>qualifiedIdent</h2>
            <hr />
            
            <p>qualifiedIdent writes out the name of an object declared at package
scope. (For now, it's also used to refer to local defined types.)</p>
            
            <pre><code>func qualifiedIdent(obj types2.Object)</code></pre>
         </article>
         
         <article class="function" data-name="localIdent">
            <h2>localIdent</h2>
            <hr />
            
            <p>localIdent writes the name of a locally declared object (i.e.,
objects that can only be accessed by non-qualified name, within the
context of a particular function).</p>
            
            <pre><code>func localIdent(obj types2.Object)</code></pre>
         </article>
         
         <article class="function" data-name="selector">
            <h2>selector</h2>
            <hr />
            
            <p>selector writes the name of a field or method (i.e., objects that
can only be accessed using selector expressions).</p>
            
            <pre><code>func selector(obj types2.Object)</code></pre>
         </article>
         
         <article class="function" data-name="selectorInfo">
            <h2>selectorInfo</h2>
            <hr />
            
            <pre><code>func selectorInfo(info selectorInfo)</code></pre>
         </article>
         
         <article class="function" data-name="selectorIdx">
            <h2>selectorIdx</h2>
            <hr />
            
            <pre><code>func selectorIdx(obj types2.Object) selectorInfo</code></pre>
         </article>
         
         <article class="function" data-name="funcExt">
            <h2>funcExt</h2>
            <hr />
            
            <pre><code>func funcExt(obj *types2.Func)</code></pre>
         </article>
         
         <article class="function" data-name="typeExt">
            <h2>typeExt</h2>
            <hr />
            
            <pre><code>func typeExt(obj *types2.TypeName)</code></pre>
         </article>
         
         <article class="function" data-name="varExt">
            <h2>varExt</h2>
            <hr />
            
            <pre><code>func varExt(obj *types2.Var)</code></pre>
         </article>
         
         <article class="function" data-name="linkname">
            <h2>linkname</h2>
            <hr />
            
            <pre><code>func linkname(obj types2.Object)</code></pre>
         </article>
         
         <article class="function" data-name="pragmaFlag">
            <h2>pragmaFlag</h2>
            <hr />
            
            <pre><code>func pragmaFlag(p ir.PragmaFlag)</code></pre>
         </article>
         
         <article class="function" data-name="bodyIdx">
            <h2>bodyIdx</h2>
            <hr />
            
            <p>bodyIdx returns the index for the given function body (specified by
block), adding it to the export data</p>
            
            <pre><code>func bodyIdx(sig *types2.Signature, block *syntax.BlockStmt, dict *writerDict) (idx index, closureVars []posVar)</code></pre>
         </article>
         
         <article class="function" data-name="declareParams">
            <h2>declareParams</h2>
            <hr />
            
            <pre><code>func declareParams(sig *types2.Signature)</code></pre>
         </article>
         
         <article class="function" data-name="addLocal">
            <h2>addLocal</h2>
            <hr />
            
            <p>addLocal records the declaration of a new local variable.</p>
            
            <pre><code>func addLocal(obj *types2.Var)</code></pre>
         </article>
         
         <article class="function" data-name="useLocal">
            <h2>useLocal</h2>
            <hr />
            
            <p>useLocal writes a reference to the given local or free variable
into the bitstream.</p>
            
            <pre><code>func useLocal(pos syntax.Pos, obj *types2.Var)</code></pre>
         </article>
         
         <article class="function" data-name="openScope">
            <h2>openScope</h2>
            <hr />
            
            <pre><code>func openScope(pos syntax.Pos)</code></pre>
         </article>
         
         <article class="function" data-name="closeScope">
            <h2>closeScope</h2>
            <hr />
            
            <pre><code>func closeScope(pos syntax.Pos)</code></pre>
         </article>
         
         <article class="function" data-name="closeAnotherScope">
            <h2>closeAnotherScope</h2>
            <hr />
            
            <pre><code>func closeAnotherScope()</code></pre>
         </article>
         
         <article class="function" data-name="stmt">
            <h2>stmt</h2>
            <hr />
            
            <p>stmt writes the given statement into the function body bitstream.</p>
            
            <pre><code>func stmt(stmt syntax.Stmt)</code></pre>
         </article>
         
         <article class="function" data-name="stmts">
            <h2>stmts</h2>
            <hr />
            
            <pre><code>func stmts(stmts []syntax.Stmt)</code></pre>
         </article>
         
         <article class="function" data-name="stmt1">
            <h2>stmt1</h2>
            <hr />
            
            <pre><code>func stmt1(stmt syntax.Stmt)</code></pre>
         </article>
         
         <article class="function" data-name="assignList">
            <h2>assignList</h2>
            <hr />
            
            <pre><code>func assignList(expr syntax.Expr)</code></pre>
         </article>
         
         <article class="function" data-name="assign">
            <h2>assign</h2>
            <hr />
            
            <pre><code>func assign(expr syntax.Expr)</code></pre>
         </article>
         
         <article class="function" data-name="declStmt">
            <h2>declStmt</h2>
            <hr />
            
            <pre><code>func declStmt(decl syntax.Decl)</code></pre>
         </article>
         
         <article class="function" data-name="assignStmt">
            <h2>assignStmt</h2>
            <hr />
            
            <p>assignStmt writes out an assignment for "lhs = rhs".</p>
            
            <pre><code>func assignStmt(pos poser, lhs0 syntax.Expr, rhs0 syntax.Expr)</code></pre>
         </article>
         
         <article class="function" data-name="blockStmt">
            <h2>blockStmt</h2>
            <hr />
            
            <pre><code>func blockStmt(stmt *syntax.BlockStmt)</code></pre>
         </article>
         
         <article class="function" data-name="forStmt">
            <h2>forStmt</h2>
            <hr />
            
            <pre><code>func forStmt(stmt *syntax.ForStmt)</code></pre>
         </article>
         
         <article class="function" data-name="distinctVars">
            <h2>distinctVars</h2>
            <hr />
            
            <pre><code>func distinctVars(stmt *syntax.ForStmt) bool</code></pre>
         </article>
         
         <article class="function" data-name="ifStmt">
            <h2>ifStmt</h2>
            <hr />
            
            <pre><code>func ifStmt(stmt *syntax.IfStmt)</code></pre>
         </article>
         
         <article class="function" data-name="selectStmt">
            <h2>selectStmt</h2>
            <hr />
            
            <pre><code>func selectStmt(stmt *syntax.SelectStmt)</code></pre>
         </article>
         
         <article class="function" data-name="switchStmt">
            <h2>switchStmt</h2>
            <hr />
            
            <pre><code>func switchStmt(stmt *syntax.SwitchStmt)</code></pre>
         </article>
         
         <article class="function" data-name="label">
            <h2>label</h2>
            <hr />
            
            <pre><code>func label(label *syntax.Name)</code></pre>
         </article>
         
         <article class="function" data-name="optLabel">
            <h2>optLabel</h2>
            <hr />
            
            <pre><code>func optLabel(label *syntax.Name)</code></pre>
         </article>
         
         <article class="function" data-name="expr">
            <h2>expr</h2>
            <hr />
            
            <p>expr writes the given expression into the function body bitstream.</p>
            
            <pre><code>func expr(expr syntax.Expr)</code></pre>
         </article>
         
         <article class="function" data-name="sliceElem">
            <h2>sliceElem</h2>
            <hr />
            
            <pre><code>func sliceElem(typ types2.Type) types2.Type</code></pre>
         </article>
         
         <article class="function" data-name="optExpr">
            <h2>optExpr</h2>
            <hr />
            
            <pre><code>func optExpr(expr syntax.Expr)</code></pre>
         </article>
         
         <article class="function" data-name="recvExpr">
            <h2>recvExpr</h2>
            <hr />
            
            <p>recvExpr writes out expr.X, but handles any implicit addressing,
dereferencing, and field selections appropriate for the method
selection.</p>
            
            <pre><code>func recvExpr(expr *syntax.SelectorExpr, sel *types2.Selection) types2.Type</code></pre>
         </article>
         
         <article class="function" data-name="funcInst">
            <h2>funcInst</h2>
            <hr />
            
            <p>funcInst writes a reference to an instantiated function.</p>
            
            <pre><code>func funcInst(obj *types2.Func, targs *types2.TypeList)</code></pre>
         </article>
         
         <article class="function" data-name="methodExpr">
            <h2>methodExpr</h2>
            <hr />
            
            <p>methodExpr writes out a reference to the method selected by
expr. sel should be the corresponding types2.Selection, and recv
the type produced after any implicit addressing, dereferencing, and
field selection. (Note: recv might differ from sel.Obj()'s receiver
parameter in the case of interface types, and is needed for
handling type parameter methods.)</p>
            
            <pre><code>func methodExpr(expr *syntax.SelectorExpr, recv types2.Type, sel *types2.Selection)</code></pre>
         </article>
         
         <article class="function" data-name="multiExpr">
            <h2>multiExpr</h2>
            <hr />
            
            <p>multiExpr writes a sequence of expressions, where the i'th value is
implicitly converted to dstType(i). It also handles when exprs is a
single, multi-valued expression (e.g., the multi-valued argument in
an f(g()) call, or the RHS operand in a comma-ok assignment).</p>
            
            <pre><code>func multiExpr(pos poser, dstType func, exprs []syntax.Expr)</code></pre>
         </article>
         
         <article class="function" data-name="implicitConvExpr">
            <h2>implicitConvExpr</h2>
            <hr />
            
            <p>implicitConvExpr is like expr, but if dst is non-nil and different
from expr's type, then an implicit conversion operation is inserted
at expr's position.</p>
            
            <pre><code>func implicitConvExpr(dst types2.Type, expr syntax.Expr)</code></pre>
         </article>
         
         <article class="function" data-name="convertExpr">
            <h2>convertExpr</h2>
            <hr />
            
            <pre><code>func convertExpr(dst types2.Type, expr syntax.Expr, implicit bool)</code></pre>
         </article>
         
         <article class="function" data-name="compLit">
            <h2>compLit</h2>
            <hr />
            
            <pre><code>func compLit(lit *syntax.CompositeLit)</code></pre>
         </article>
         
         <article class="function" data-name="funcLit">
            <h2>funcLit</h2>
            <hr />
            
            <pre><code>func funcLit(expr *syntax.FuncLit)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="exprList">
            <h2>exprList</h2>
            <hr />
            
            <pre><code>func exprList(expr syntax.Expr)</code></pre>
         </article>
         
         <article class="function" data-name="exprs">
            <h2>exprs</h2>
            <hr />
            
            <pre><code>func exprs(exprs []syntax.Expr)</code></pre>
         </article>
         
         <article class="function" data-name="rtype">
            <h2>rtype</h2>
            <hr />
            
            <p>rtype writes information so that the reader can construct an
expression of type *runtime._type representing typ.</p>
            
            <pre><code>func rtype(typ types2.Type)</code></pre>
         </article>
         
         <article class="function" data-name="rtypeInfo">
            <h2>rtypeInfo</h2>
            <hr />
            
            <pre><code>func rtypeInfo(info typeInfo)</code></pre>
         </article>
         
         <article class="function" data-name="varDictIndex">
            <h2>varDictIndex</h2>
            <hr />
            
            <p>varDictIndex writes out information for populating DictIndex for
the ir.Name that will represent obj.</p>
            
            <pre><code>func varDictIndex(obj *types2.Var)</code></pre>
         </article>
         
         <article class="function" data-name="isUntyped">
            <h2>isUntyped</h2>
            <hr />
            
            <p>isUntyped reports whether typ is an untyped type.</p>
            
            <pre><code>func isUntyped(typ types2.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="isTuple">
            <h2>isTuple</h2>
            <hr />
            
            <p>isTuple reports whether typ is a tuple type.</p>
            
            <pre><code>func isTuple(typ types2.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="itab">
            <h2>itab</h2>
            <hr />
            
            <pre><code>func itab(typ types2.Type, iface types2.Type)</code></pre>
         </article>
         
         <article class="function" data-name="convRTTI">
            <h2>convRTTI</h2>
            <hr />
            
            <p>convRTTI writes information so that the reader can construct
expressions for converting from src to dst.</p>
            
            <pre><code>func convRTTI(src types2.Type, dst types2.Type)</code></pre>
         </article>
         
         <article class="function" data-name="exprType">
            <h2>exprType</h2>
            <hr />
            
            <pre><code>func exprType(iface types2.Type, typ syntax.Expr)</code></pre>
         </article>
         
         <article class="function" data-name="isInterface">
            <h2>isInterface</h2>
            <hr />
            
            <p>isInterface reports whether typ is known to be an interface type.
If typ is a type parameter, then isInterface reports an internal
compiler error instead.</p>
            
            <pre><code>func isInterface(typ types2.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="op">
            <h2>op</h2>
            <hr />
            
            <p>op writes an Op into the bitstream.</p>
            
            <pre><code>func op(op ir.Op)</code></pre>
         </article>
         
         <article class="function" data-name="withTParams">
            <h2>withTParams</h2>
            <hr />
            
            <pre><code>func withTParams(obj types2.Object) *declCollector</code></pre>
         </article>
         
         <article class="function" data-name="Visit">
            <h2>Visit</h2>
            <hr />
            
            <pre><code>func Visit(n syntax.Node) syntax.Visitor</code></pre>
         </article>
         
         <article class="function" data-name="collectDecls">
            <h2>collectDecls</h2>
            <hr />
            
            <pre><code>func collectDecls(noders []*noder)</code></pre>
         </article>
         
         <article class="function" data-name="checkPragmas">
            <h2>checkPragmas</h2>
            <hr />
            
            <pre><code>func checkPragmas(p syntax.Pragma, allowed ir.PragmaFlag, embedOK bool)</code></pre>
         </article>
         
         <article class="function" data-name="pkgInit">
            <h2>pkgInit</h2>
            <hr />
            
            <pre><code>func pkgInit(noders []*noder)</code></pre>
         </article>
         
         <article class="function" data-name="pkgInitOrder">
            <h2>pkgInitOrder</h2>
            <hr />
            
            <pre><code>func pkgInitOrder()</code></pre>
         </article>
         
         <article class="function" data-name="pkgDecl">
            <h2>pkgDecl</h2>
            <hr />
            
            <pre><code>func pkgDecl(decl syntax.Decl)</code></pre>
         </article>
         
         <article class="function" data-name="pkgObjs">
            <h2>pkgObjs</h2>
            <hr />
            
            <pre><code>func pkgObjs(names ...*syntax.Name)</code></pre>
         </article>
         
         <article class="function" data-name="staticBool">
            <h2>staticBool</h2>
            <hr />
            
            <p>staticBool analyzes a boolean expression and reports whether it's
always true (positive result), always false (negative result), or
unknown (zero).

It also simplifies the expression while preserving semantics, if
possible.</p>
            
            <pre><code>func staticBool(ep *syntax.Expr) int</code></pre>
         </article>
         
         <article class="function" data-name="hasImplicitTypeParams">
            <h2>hasImplicitTypeParams</h2>
            <hr />
            
            <p>hasImplicitTypeParams reports whether obj is a defined type with
implicit type parameters (e.g., declared within a generic function
or method).</p>
            
            <pre><code>func hasImplicitTypeParams(obj *types2.TypeName) bool</code></pre>
         </article>
         
         <article class="function" data-name="isDefinedType">
            <h2>isDefinedType</h2>
            <hr />
            
            <p>isDefinedType reports whether obj is a defined type.</p>
            
            <pre><code>func isDefinedType(obj types2.Object) bool</code></pre>
         </article>
         
         <article class="function" data-name="isGlobal">
            <h2>isGlobal</h2>
            <hr />
            
            <p>isGlobal reports whether obj was declared at package scope.

Caveat: blank objects are not declared.</p>
            
            <pre><code>func isGlobal(obj types2.Object) bool</code></pre>
         </article>
         
         <article class="function" data-name="lookupObj">
            <h2>lookupObj</h2>
            <hr />
            
            <p>lookupObj returns the object that expr refers to, if any. If expr
is an explicit instantiation of a generic object, then the instance
object is returned as well.</p>
            
            <pre><code>func lookupObj(p *pkgWriter, expr syntax.Expr) (obj types2.Object, inst types2.Instance)</code></pre>
         </article>
         
         <article class="function" data-name="isPkgQual">
            <h2>isPkgQual</h2>
            <hr />
            
            <p>isPkgQual reports whether the given selector expression is a
package-qualified identifier.</p>
            
            <pre><code>func isPkgQual(info *types2.Info, sel *syntax.SelectorExpr) bool</code></pre>
         </article>
         
         <article class="function" data-name="isNil">
            <h2>isNil</h2>
            <hr />
            
            <p>isNil reports whether expr is a (possibly parenthesized) reference
to the predeclared nil value.</p>
            
            <pre><code>func isNil(p *pkgWriter, expr syntax.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="isBuiltin">
            <h2>isBuiltin</h2>
            <hr />
            
            <p>isBuiltin reports whether expr is a (possibly parenthesized)
referenced to the specified built-in function.</p>
            
            <pre><code>func isBuiltin(expr syntax.Expr, builtin string) bool</code></pre>
         </article>
         
         <article class="function" data-name="recvBase">
            <h2>recvBase</h2>
            <hr />
            
            <p>recvBase returns the base type for the given receiver parameter.</p>
            
            <pre><code>func recvBase(recv *types2.Var) *types2.Named</code></pre>
         </article>
         
         <article class="function" data-name="namesAsExpr">
            <h2>namesAsExpr</h2>
            <hr />
            
            <p>namesAsExpr returns a list of names as a syntax.Expr.</p>
            
            <pre><code>func namesAsExpr(names []*syntax.Name) syntax.Expr</code></pre>
         </article>
         
         <article class="function" data-name="fieldIndex">
            <h2>fieldIndex</h2>
            <hr />
            
            <p>fieldIndex returns the index of the struct field named by key.</p>
            
            <pre><code>func fieldIndex(info *types2.Info, str *types2.Struct, key *syntax.Name) int</code></pre>
         </article>
         
         <article class="function" data-name="objTypeParams">
            <h2>objTypeParams</h2>
            <hr />
            
            <p>objTypeParams returns the type parameters on the given object.</p>
            
            <pre><code>func objTypeParams(obj types2.Object) *types2.TypeParamList</code></pre>
         </article>
         
         <article class="function" data-name="splitNamed">
            <h2>splitNamed</h2>
            <hr />
            
            <p>splitNamed decomposes a use of a defined type into its original
type definition and the type arguments used to instantiate it.</p>
            
            <pre><code>func splitNamed(typ *types2.Named) (*types2.TypeName, *types2.TypeList)</code></pre>
         </article>
         
         <article class="function" data-name="splitAlias">
            <h2>splitAlias</h2>
            <hr />
            
            <p>splitAlias is like splitNamed, but for an alias type.</p>
            
            <pre><code>func splitAlias(typ *types2.Alias) (*types2.TypeName, *types2.TypeList)</code></pre>
         </article>
         
         <article class="function" data-name="asPragmaFlag">
            <h2>asPragmaFlag</h2>
            <hr />
            
            <pre><code>func asPragmaFlag(p syntax.Pragma) ir.PragmaFlag</code></pre>
         </article>
         
         <article class="function" data-name="asWasmImport">
            <h2>asWasmImport</h2>
            <hr />
            
            <pre><code>func asWasmImport(p syntax.Pragma) *WasmImport</code></pre>
         </article>
         
         <article class="function" data-name="asWasmExport">
            <h2>asWasmExport</h2>
            <hr />
            
            <pre><code>func asWasmExport(p syntax.Pragma) *WasmExport</code></pre>
         </article>
         
         <article class="function" data-name="isPtrTo">
            <h2>isPtrTo</h2>
            <hr />
            
            <p>isPtrTo reports whether from is the type *to.</p>
            
            <pre><code>func isPtrTo(from types2.Type, to types2.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="hasFallthrough">
            <h2>hasFallthrough</h2>
            <hr />
            
            <p>hasFallthrough reports whether stmts ends in a fallthrough
statement.</p>
            
            <pre><code>func hasFallthrough(stmts []syntax.Stmt) bool</code></pre>
         </article>
         
         <article class="function" data-name="lastNonEmptyStmt">
            <h2>lastNonEmptyStmt</h2>
            <hr />
            
            <p>lastNonEmptyStmt returns the last non-empty statement in list, if
any.</p>
            
            <pre><code>func lastNonEmptyStmt(stmts []syntax.Stmt) syntax.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="terminates">
            <h2>terminates</h2>
            <hr />
            
            <p>terminates reports whether stmt terminates normal control flow
(i.e., does not merely advance to the following statement).</p>
            
            <pre><code>func terminates(stmt syntax.Stmt) bool</code></pre>
         </article>
         
         <article class="function" data-name="Import">
            <h2>Import</h2>
            <hr />
            
            <pre><code>func Import(path string) (*types2.Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="ImportFrom">
            <h2>ImportFrom</h2>
            <hr />
            
            <pre><code>func ImportFrom(path string, srcDir string, mode types2.ImportMode) (*types2.Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="isDriveLetter">
            <h2>isDriveLetter</h2>
            <hr />
            
            <pre><code>func isDriveLetter(b byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="islocalname">
            <h2>islocalname</h2>
            <hr />
            
            <p>is this path a local name? begins with ./ or ../ or /</p>
            
            <pre><code>func islocalname(name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="openPackage">
            <h2>openPackage</h2>
            <hr />
            
            <pre><code>func openPackage(path string) (*os.File, error)</code></pre>
         </article>
         
         <article class="function" data-name="resolveImportPath">
            <h2>resolveImportPath</h2>
            <hr />
            
            <p>resolveImportPath resolves an import path as it appears in a Go
source file to the package's full path.</p>
            
            <pre><code>func resolveImportPath(path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="readImportFile">
            <h2>readImportFile</h2>
            <hr />
            
            <p>readImportFile reads the import file for the given package path and
returns its types.Pkg representation. If packages is non-nil, the
types2.Package representation is also returned.</p>
            
            <pre><code>func readImportFile(path string, target *ir.Package, env *types2.Context, packages *ast.MapType) (pkg1 *types.Pkg, pkg2 *types2.Package, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readExportData">
            <h2>readExportData</h2>
            <hr />
            
            <p>readExportData returns the contents of GC-created unified export data.</p>
            
            <pre><code>func readExportData(f *os.File) (data string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="addFingerprint">
            <h2>addFingerprint</h2>
            <hr />
            
            <p>addFingerprint reads the linker fingerprint included at the end of
the exportdata.</p>
            
            <pre><code>func addFingerprint(path string, data string) error</code></pre>
         </article>
         
         <article class="function" data-name="checkImportPath">
            <h2>checkImportPath</h2>
            <hr />
            
            <pre><code>func checkImportPath(path string, allowSpace bool) error</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
