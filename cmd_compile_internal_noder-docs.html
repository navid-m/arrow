<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - noder</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>noder</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"cmd/compile/internal/types"
"cmd/compile/internal/types2"
"errors"
"fmt"
"internal/buildcfg"
"internal/exportdata"
"internal/pkgbits"
"os"
pathpkg "path"
"runtime"
"strings"
"unicode"
"unicode/utf8"
"cmd/compile/internal/base"
"cmd/compile/internal/importer"
"cmd/compile/internal/ir"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/compile/internal/types2"
"cmd/internal/bio"
"cmd/internal/goobj"
"cmd/internal/objabi"
"fmt"
"internal/buildcfg"
"strings"
"cmd/compile/internal/ir"
"cmd/compile/internal/syntax"
"errors"
"fmt"
"internal/buildcfg"
"os"
"path/filepath"
"runtime"
"strconv"
"strings"
"unicode"
"unicode/utf8"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/syntax"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/objabi"
"cmd/compile/internal/base"
"cmd/compile/internal/syntax"
"cmd/internal/src"
"fmt"
"cmd/compile/internal/syntax"
"encoding/hex"
"fmt"
"go/constant"
"internal/buildcfg"
"internal/pkgbits"
"path/filepath"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/dwarfgen"
"cmd/compile/internal/inline"
"cmd/compile/internal/inline/interleaved"
"cmd/compile/internal/ir"
"cmd/compile/internal/objw"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/staticinit"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/hash"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
"cmp"
"fmt"
"internal/buildcfg"
"internal/pkgbits"
"internal/types/errors"
"io"
"runtime"
"slices"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/inline"
"cmd/compile/internal/ir"
"cmd/compile/internal/pgoir"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/compile/internal/types2"
"cmd/internal/src"
"fmt"
"go/constant"
"go/token"
"go/version"
"internal/buildcfg"
"internal/pkgbits"
"os"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/syntax"
"cmd/compile/internal/types"
"cmd/compile/internal/types2"
"internal/pkgbits"
"bytes"
"fmt"
"io"
"cmd/compile/internal/base"
"cmd/internal/bio"
"go/constant"
"cmd/compile/internal/ir"
"cmd/compile/internal/syntax"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/compile/internal/types2"
"cmd/internal/src"
"fmt"
"internal/buildcfg"
"internal/types/errors"
"regexp"
"sort"
"cmd/compile/internal/base"
"cmd/compile/internal/rangefunc"
"cmd/compile/internal/syntax"
"cmd/compile/internal/types2"
"cmd/internal/src"
"internal/buildcfg"
"internal/pkgbits"
"io"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/reflectdata"
"cmd/compile/internal/types"
"cmd/internal/goobj"
"cmd/internal/obj"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="allowedStdPragmas" data-name="allowedStdPragmas">
               <h3>
                  allowedStdPragmas 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#allowedStdPragmas" class="anchor" title="Link to allowedStdPragmas">#</a>
               </h3>
               
               <p>pragmas that are allowed in the std lib, but don't have
a syntax.Pragma value (see lex.go) associated with them.</p>
               
               <pre><code>var allowedStdPragmas = map[string]bool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="anyTypeName" data-name="anyTypeName">
               <h3>
                  anyTypeName 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#anyTypeName" class="anchor" title="Link to anyTypeName">#</a>
               </h3>
               
               <pre><code>var anyTypeName = *ast.TypeAssertExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="assignBlank" data-name="assignBlank">
               <h3>
                  assignBlank 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#assignBlank" class="anchor" title="Link to assignBlank">#</a>
               </h3>
               
               <pre><code>const assignBlank codeAssign = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="assignDef" data-name="assignDef">
               <h3>
                  assignDef 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#assignDef" class="anchor" title="Link to assignDef">#</a>
               </h3>
               
               <pre><code>const assignDef</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="assignExpr" data-name="assignExpr">
               <h3>
                  assignExpr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#assignExpr" class="anchor" title="Link to assignExpr">#</a>
               </h3>
               
               <pre><code>const assignExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="basics" data-name="basics">
               <h3>
                  basics 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#basics" class="anchor" title="Link to basics">#</a>
               </h3>
               
               <pre><code>var basics = [...]**types.Type{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="binOps" data-name="binOps">
               <h3>
                  binOps 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#binOps" class="anchor" title="Link to binOps">#</a>
               </h3>
               
               <pre><code>var binOps = [...]ir.Op{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bodyReader" data-name="bodyReader">
               <h3>
                  bodyReader 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bodyReader" class="anchor" title="Link to bodyReader">#</a>
               </h3>
               
               <p>bodyReader tracks where the serialized IR for a local or imported,
generic function's body can be found.</p>
               
               <pre><code>var bodyReader = map[*ir.Func]pkgReaderIndex{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="comparableTypeName" data-name="comparableTypeName">
               <h3>
                  comparableTypeName 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#comparableTypeName" class="anchor" title="Link to comparableTypeName">#</a>
               </h3>
               
               <pre><code>var comparableTypeName = *ast.TypeAssertExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="declEnd" data-name="declEnd">
               <h3>
                  declEnd 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#declEnd" class="anchor" title="Link to declEnd">#</a>
               </h3>
               
               <pre><code>const declEnd codeDecl = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="declFunc" data-name="declFunc">
               <h3>
                  declFunc 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#declFunc" class="anchor" title="Link to declFunc">#</a>
               </h3>
               
               <pre><code>const declFunc</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="declMethod" data-name="declMethod">
               <h3>
                  declMethod 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#declMethod" class="anchor" title="Link to declMethod">#</a>
               </h3>
               
               <pre><code>const declMethod</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="declOther" data-name="declOther">
               <h3>
                  declOther 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#declOther" class="anchor" title="Link to declOther">#</a>
               </h3>
               
               <pre><code>const declOther</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="declVar" data-name="declVar">
               <h3>
                  declVar 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#declVar" class="anchor" title="Link to declVar">#</a>
               </h3>
               
               <pre><code>const declVar</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dictParamName" data-name="dictParamName">
               <h3>
                  dictParamName 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#dictParamName" class="anchor" title="Link to dictParamName">#</a>
               </h3>
               
               <p>dictParamName is the name of the synthetic dictionary parameter
added to shaped functions.
N.B., this variable name is known to Delve:
https://github.com/go-delve/delve/blob/cb91509630529e6055be845688fd21eb89ae8714/pkg/proc/eval.go#L28</p>
               
               <pre><code>const dictParamName = typecheck.LocalDictName</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dirs" data-name="dirs">
               <h3>
                  dirs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dirs" class="anchor" title="Link to dirs">#</a>
               </h3>
               
               <pre><code>var dirs = [...]types.ChanDir{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprAlignof" data-name="exprAlignof">
               <h3>
                  exprAlignof 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprAlignof" class="anchor" title="Link to exprAlignof">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprAlignof</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprAssert" data-name="exprAssert">
               <h3>
                  exprAssert 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprAssert" class="anchor" title="Link to exprAssert">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprAssert</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprBinaryOp" data-name="exprBinaryOp">
               <h3>
                  exprBinaryOp 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprBinaryOp" class="anchor" title="Link to exprBinaryOp">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprBinaryOp</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprCall" data-name="exprCall">
               <h3>
                  exprCall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprCall" class="anchor" title="Link to exprCall">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprCall</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprCompLit" data-name="exprCompLit">
               <h3>
                  exprCompLit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprCompLit" class="anchor" title="Link to exprCompLit">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprCompLit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprConst" data-name="exprConst">
               <h3>
                  exprConst 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprConst" class="anchor" title="Link to exprConst">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprConst codeExpr = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprConvert" data-name="exprConvert">
               <h3>
                  exprConvert 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprConvert" class="anchor" title="Link to exprConvert">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprConvert</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprFieldVal" data-name="exprFieldVal">
               <h3>
                  exprFieldVal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprFieldVal" class="anchor" title="Link to exprFieldVal">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprFieldVal</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprFuncInst" data-name="exprFuncInst">
               <h3>
                  exprFuncInst 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprFuncInst" class="anchor" title="Link to exprFuncInst">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprFuncInst</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprFuncLit" data-name="exprFuncLit">
               <h3>
                  exprFuncLit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprFuncLit" class="anchor" title="Link to exprFuncLit">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprFuncLit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprGlobal" data-name="exprGlobal">
               <h3>
                  exprGlobal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprGlobal" class="anchor" title="Link to exprGlobal">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprGlobal</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprIndex" data-name="exprIndex">
               <h3>
                  exprIndex 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprIndex" class="anchor" title="Link to exprIndex">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprIndex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprLocal" data-name="exprLocal">
               <h3>
                  exprLocal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprLocal" class="anchor" title="Link to exprLocal">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprLocal</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprMake" data-name="exprMake">
               <h3>
                  exprMake 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprMake" class="anchor" title="Link to exprMake">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprMake</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprMethodExpr" data-name="exprMethodExpr">
               <h3>
                  exprMethodExpr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprMethodExpr" class="anchor" title="Link to exprMethodExpr">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprMethodExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprMethodVal" data-name="exprMethodVal">
               <h3>
                  exprMethodVal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprMethodVal" class="anchor" title="Link to exprMethodVal">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprMethodVal</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprNew" data-name="exprNew">
               <h3>
                  exprNew 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprNew" class="anchor" title="Link to exprNew">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprNew</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprOffsetof" data-name="exprOffsetof">
               <h3>
                  exprOffsetof 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprOffsetof" class="anchor" title="Link to exprOffsetof">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprOffsetof</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprRecv" data-name="exprRecv">
               <h3>
                  exprRecv 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprRecv" class="anchor" title="Link to exprRecv">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprRecv</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprReshape" data-name="exprReshape">
               <h3>
                  exprReshape 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprReshape" class="anchor" title="Link to exprReshape">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprReshape</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprRuntimeBuiltin" data-name="exprRuntimeBuiltin">
               <h3>
                  exprRuntimeBuiltin 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprRuntimeBuiltin" class="anchor" title="Link to exprRuntimeBuiltin">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprRuntimeBuiltin</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprSizeof" data-name="exprSizeof">
               <h3>
                  exprSizeof 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprSizeof" class="anchor" title="Link to exprSizeof">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprSizeof</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprSlice" data-name="exprSlice">
               <h3>
                  exprSlice 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprSlice" class="anchor" title="Link to exprSlice">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprSlice</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprUnaryOp" data-name="exprUnaryOp">
               <h3>
                  exprUnaryOp 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprUnaryOp" class="anchor" title="Link to exprUnaryOp">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprUnaryOp</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="exprZero" data-name="exprZero">
               <h3>
                  exprZero 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#exprZero" class="anchor" title="Link to exprZero">#</a>
               </h3>
               
               <p>TODO(mdempsky): Split expr into addr, for lvalues.</p>
               
               <pre><code>const exprZero</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="funcPragmas" data-name="funcPragmas">
               <h3>
                  funcPragmas 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#funcPragmas" class="anchor" title="Link to funcPragmas">#</a>
               </h3>
               
               <pre><code>const funcPragmas = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="haveMethodValueWrappers" data-name="haveMethodValueWrappers">
               <h3>
                  haveMethodValueWrappers 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#haveMethodValueWrappers" class="anchor" title="Link to haveMethodValueWrappers">#</a>
               </h3>
               
               <p>haveMethodValueWrappers lists methods for which we know we already
have method value wrappers, because we found it in an imported
package.</p>
               
               <pre><code>var haveMethodValueWrappers []methodValueWrapper</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="haveWrapperTypes" data-name="haveWrapperTypes">
               <h3>
                  haveWrapperTypes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#haveWrapperTypes" class="anchor" title="Link to haveWrapperTypes">#</a>
               </h3>
               
               <p>haveWrapperTypes lists types for which we know we already have
method wrappers, because we found the type in an imported package.</p>
               
               <pre><code>var haveWrapperTypes []*types.Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="importBodyReader" data-name="importBodyReader">
               <h3>
                  importBodyReader 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#importBodyReader" class="anchor" title="Link to importBodyReader">#</a>
               </h3>
               
               <p>importBodyReader tracks where the serialized IR for an imported,
static (i.e., non-generic) function body can be read.</p>
               
               <pre><code>var importBodyReader = map[*types.Sym]pkgReaderIndex{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inlgen" data-name="inlgen">
               <h3>
                  inlgen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#inlgen" class="anchor" title="Link to inlgen">#</a>
               </h3>
               
               <pre><code>var inlgen = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="localPkgReader" data-name="localPkgReader">
               <h3>
                  localPkgReader 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#localPkgReader" class="anchor" title="Link to localPkgReader">#</a>
               </h3>
               
               <p>localPkgReader holds the package reader used for reading the local
package. It exists so the unified IR linker can refer back to it
later.</p>
               
               <pre><code>var localPkgReader *pkgReader</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="needMethodValueWrappers" data-name="needMethodValueWrappers">
               <h3>
                  needMethodValueWrappers 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#needMethodValueWrappers" class="anchor" title="Link to needMethodValueWrappers">#</a>
               </h3>
               
               <p>needMethodValueWrappers lists methods for which we may need to
generate method value wrappers.</p>
               
               <pre><code>var needMethodValueWrappers []methodValueWrapper</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="needWrapperTypes" data-name="needWrapperTypes">
               <h3>
                  needWrapperTypes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#needWrapperTypes" class="anchor" title="Link to needWrapperTypes">#</a>
               </h3>
               
               <p>needWrapperTypes lists types for which we may need to generate
method wrappers.</p>
               
               <pre><code>var needWrapperTypes []*types.Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="objReader" data-name="objReader">
               <h3>
                  objReader 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#objReader" class="anchor" title="Link to objReader">#</a>
               </h3>
               
               <p>objReader maps qualified identifiers (represented as *types.Sym) to
a pkgReader and corresponding index that can be used for reading
that object's definition.</p>
               
               <pre><code>var objReader = map[*types.Sym]pkgReaderIndex{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="renameinitgen" data-name="renameinitgen">
               <h3>
                  renameinitgen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#renameinitgen" class="anchor" title="Link to renameinitgen">#</a>
               </h3>
               
               <p>A function named init is a special case.
It is called by the initialization before main is run.
To make it unique within a package and also uncallable,
the name, normally "pkg.init", is altered to "pkg.init.0".</p>
               
               <pre><code>var renameinitgen int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="runeTypeName" data-name="runeTypeName">
               <h3>
                  runeTypeName 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#runeTypeName" class="anchor" title="Link to runeTypeName">#</a>
               </h3>
               
               <pre><code>var runeTypeName = *ast.TypeAssertExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stmtAssign" data-name="stmtAssign">
               <h3>
                  stmtAssign 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stmtAssign" class="anchor" title="Link to stmtAssign">#</a>
               </h3>
               
               <pre><code>const stmtAssign</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stmtAssignOp" data-name="stmtAssignOp">
               <h3>
                  stmtAssignOp 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stmtAssignOp" class="anchor" title="Link to stmtAssignOp">#</a>
               </h3>
               
               <pre><code>const stmtAssignOp</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stmtBlock" data-name="stmtBlock">
               <h3>
                  stmtBlock 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stmtBlock" class="anchor" title="Link to stmtBlock">#</a>
               </h3>
               
               <pre><code>const stmtBlock</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stmtBranch" data-name="stmtBranch">
               <h3>
                  stmtBranch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stmtBranch" class="anchor" title="Link to stmtBranch">#</a>
               </h3>
               
               <pre><code>const stmtBranch</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stmtCall" data-name="stmtCall">
               <h3>
                  stmtCall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stmtCall" class="anchor" title="Link to stmtCall">#</a>
               </h3>
               
               <pre><code>const stmtCall</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stmtEnd" data-name="stmtEnd">
               <h3>
                  stmtEnd 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stmtEnd" class="anchor" title="Link to stmtEnd">#</a>
               </h3>
               
               <pre><code>const stmtEnd codeStmt = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stmtExpr" data-name="stmtExpr">
               <h3>
                  stmtExpr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stmtExpr" class="anchor" title="Link to stmtExpr">#</a>
               </h3>
               
               <pre><code>const stmtExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stmtFor" data-name="stmtFor">
               <h3>
                  stmtFor 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stmtFor" class="anchor" title="Link to stmtFor">#</a>
               </h3>
               
               <pre><code>const stmtFor</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stmtIf" data-name="stmtIf">
               <h3>
                  stmtIf 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stmtIf" class="anchor" title="Link to stmtIf">#</a>
               </h3>
               
               <pre><code>const stmtIf</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stmtIncDec" data-name="stmtIncDec">
               <h3>
                  stmtIncDec 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stmtIncDec" class="anchor" title="Link to stmtIncDec">#</a>
               </h3>
               
               <pre><code>const stmtIncDec</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stmtLabel" data-name="stmtLabel">
               <h3>
                  stmtLabel 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stmtLabel" class="anchor" title="Link to stmtLabel">#</a>
               </h3>
               
               <pre><code>const stmtLabel</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stmtReturn" data-name="stmtReturn">
               <h3>
                  stmtReturn 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stmtReturn" class="anchor" title="Link to stmtReturn">#</a>
               </h3>
               
               <pre><code>const stmtReturn</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stmtSelect" data-name="stmtSelect">
               <h3>
                  stmtSelect 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stmtSelect" class="anchor" title="Link to stmtSelect">#</a>
               </h3>
               
               <pre><code>const stmtSelect</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stmtSend" data-name="stmtSend">
               <h3>
                  stmtSend 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stmtSend" class="anchor" title="Link to stmtSend">#</a>
               </h3>
               
               <pre><code>const stmtSend</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stmtSwitch" data-name="stmtSwitch">
               <h3>
                  stmtSwitch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stmtSwitch" class="anchor" title="Link to stmtSwitch">#</a>
               </h3>
               
               <pre><code>const stmtSwitch</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="todoBodies" data-name="todoBodies">
               <h3>
                  todoBodies 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#todoBodies" class="anchor" title="Link to todoBodies">#</a>
               </h3>
               
               <p>todoBodies holds the list of function bodies that still need to be
constructed.</p>
               
               <pre><code>var todoBodies []*ir.Func</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="todoDicts" data-name="todoDicts">
               <h3>
                  todoDicts 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#todoDicts" class="anchor" title="Link to todoDicts">#</a>
               </h3>
               
               <p>todoDicts holds the list of dictionaries that still need their
runtime dictionary objects constructed.</p>
               
               <pre><code>var todoDicts []func()</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unOps" data-name="unOps">
               <h3>
                  unOps 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#unOps" class="anchor" title="Link to unOps">#</a>
               </h3>
               
               <pre><code>var unOps = [...]ir.Op{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="versionErrorRx" data-name="versionErrorRx">
               <h3>
                  versionErrorRx 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#versionErrorRx" class="anchor" title="Link to versionErrorRx">#</a>
               </h3>
               
               <pre><code>var versionErrorRx = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="codeAssign" data-name="codeAssign">
               <h3>
                  codeAssign
                  <span class="badge type-badge">type</span>
                  <a href="#codeAssign" class="anchor" title="Link to codeAssign">#</a>
               </h3>
               
               <pre><code>type codeAssign int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="codeDecl" data-name="codeDecl">
               <h3>
                  codeDecl
                  <span class="badge type-badge">type</span>
                  <a href="#codeDecl" class="anchor" title="Link to codeDecl">#</a>
               </h3>
               
               <p>A codeDecl distinguishes among declaration encodings.</p>
               
               <pre><code>type codeDecl int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="codeExpr" data-name="codeExpr">
               <h3>
                  codeExpr
                  <span class="badge type-badge">type</span>
                  <a href="#codeExpr" class="anchor" title="Link to codeExpr">#</a>
               </h3>
               
               <p>A codeExpr distinguishes among expression encodings.</p>
               
               <pre><code>type codeExpr int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="codeStmt" data-name="codeStmt">
               <h3>
                  codeStmt
                  <span class="badge type-badge">type</span>
                  <a href="#codeStmt" class="anchor" title="Link to codeStmt">#</a>
               </h3>
               
               <p>A codeStmt distinguishes among statement encodings.</p>
               
               <pre><code>type codeStmt int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="index" data-name="index">
               <h3>
                  index
                  <span class="badge type-badge">type</span>
                  <a href="#index" class="anchor" title="Link to index">#</a>
               </h3>
               
               <pre><code>type index pkgbits.Index</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="ImplicitNode" data-name="ImplicitNode">
               <h3>
                  ImplicitNode
                  <span class="badge interface-badge">interface</span>
                  <a href="#ImplicitNode" class="anchor" title="Link to ImplicitNode">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ImplicitNode interface {
ir.Node
SetImplicit(x bool)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="ender" data-name="ender">
               <h3>
                  ender
                  <span class="badge interface-badge">interface</span>
                  <a href="#ender" class="anchor" title="Link to ender">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ender interface {
End() syntax.Pos
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="poser" data-name="poser">
               <h3>
                  poser
                  <span class="badge interface-badge">interface</span>
                  <a href="#poser" class="anchor" title="Link to poser">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type poser interface {
Pos() syntax.Pos
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="WasmExport" data-name="WasmExport">
               <h3>
                  WasmExport
                  <span class="badge">struct</span>
                  <a href="#WasmExport" class="anchor" title="Link to WasmExport">#</a>
               </h3>
               
               <p>WasmExport stores metadata associated with the //go:wasmexport pragma</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type WasmExport struct {
Pos syntax.Pos
Name string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="WasmImport" data-name="WasmImport">
               <h3>
                  WasmImport
                  <span class="badge">struct</span>
                  <a href="#WasmImport" class="anchor" title="Link to WasmImport">#</a>
               </h3>
               
               <p>WasmImport stores metadata associated with the //go:wasmimport pragma</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type WasmImport struct {
Pos syntax.Pos
Module string
Name string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cycleFinder" data-name="cycleFinder">
               <h3>
                  cycleFinder
                  <span class="badge">struct</span>
                  <a href="#cycleFinder" class="anchor" title="Link to cycleFinder">#</a>
               </h3>
               
               <p>A cycleFinder detects anonymous interface cycles (go.dev/issue/56103).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type cycleFinder struct {
cyclic map[*types2.Interface]bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="declCollector" data-name="declCollector">
               <h3>
                  declCollector
                  <span class="badge">struct</span>
                  <a href="#declCollector" class="anchor" title="Link to declCollector">#</a>
               </h3>
               
               <p>declCollector is a visitor type that collects compiler-needed
information about declarations that types2 doesn't track.
Notably, it maps declared types and functions back to their
declaration statement, keeps track of implicit type parameters, and
assigns unique type "generation" numbers to local defined types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type declCollector struct {
pw *pkgWriter
typegen *int
file *fileImports
withinFunc bool
implicits []*types2.TypeParam
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="derivedInfo" data-name="derivedInfo">
               <h3>
                  derivedInfo
                  <span class="badge">struct</span>
                  <a href="#derivedInfo" class="anchor" title="Link to derivedInfo">#</a>
               </h3>
               
               <p>A derivedInfo represents a reference to an encoded generic Go type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type derivedInfo struct {
idx index
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fileImports" data-name="fileImports">
               <h3>
                  fileImports
                  <span class="badge">struct</span>
                  <a href="#fileImports" class="anchor" title="Link to fileImports">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileImports struct {
importedEmbed bool
importedUnsafe bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="gcimports" data-name="gcimports">
               <h3>
                  gcimports
                  <span class="badge">struct</span>
                  <a href="#gcimports" class="anchor" title="Link to gcimports">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gcimports struct {
ctxt *types2.Context
packages map[string]*types2.Package
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="itabInfo" data-name="itabInfo">
               <h3>
                  itabInfo
                  <span class="badge">struct</span>
                  <a href="#itabInfo" class="anchor" title="Link to itabInfo">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type itabInfo struct {
typ typeInfo
iface typeInfo
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="linker" data-name="linker">
               <h3>
                  linker
                  <span class="badge">struct</span>
                  <a href="#linker" class="anchor" title="Link to linker">#</a>
               </h3>
               
               <p>A linker combines a package's stub export data with any referenced
elements from imported packages into a single, self-contained
export data file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type linker struct {
pw pkgbits.PkgEncoder
pkgs map[string]index
decls map[*types.Sym]index
bodies map[*types.Sym]index
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="linkname" data-name="linkname">
               <h3>
                  linkname
                  <span class="badge">struct</span>
                  <a href="#linkname" class="anchor" title="Link to linkname">#</a>
               </h3>
               
               <p>linkname records a //go:linkname directive.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type linkname struct {
pos syntax.Pos
local string
remote string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="methodValueWrapper" data-name="methodValueWrapper">
               <h3>
                  methodValueWrapper
                  <span class="badge">struct</span>
                  <a href="#methodValueWrapper" class="anchor" title="Link to methodValueWrapper">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type methodValueWrapper struct {
rcvr *types.Type
method *types.Field
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="noder" data-name="noder">
               <h3>
                  noder
                  <span class="badge">struct</span>
                  <a href="#noder" class="anchor" title="Link to noder">#</a>
               </h3>
               
               <p>noder transforms package syntax's AST into a Node tree.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type noder struct {
file *syntax.File
linknames []linkname
pragcgobuf [][]string
err chan syntax.Error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="objInfo" data-name="objInfo">
               <h3>
                  objInfo
                  <span class="badge">struct</span>
                  <a href="#objInfo" class="anchor" title="Link to objInfo">#</a>
               </h3>
               
               <p>An objInfo represents a reference to an encoded, instantiated (if
applicable) Go object.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type objInfo struct {
idx index
explicits []typeInfo
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pkgReader" data-name="pkgReader">
               <h3>
                  pkgReader
                  <span class="badge">struct</span>
                  <a href="#pkgReader" class="anchor" title="Link to pkgReader">#</a>
               </h3>
               
               <p>A pkgReader reads Unified IR export data.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pkgReader struct {
pkgbits.PkgDecoder
posBases []*src.PosBase
pkgs []*types.Pkg
typs []*types.Type
newindex []index
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pkgReaderIndex" data-name="pkgReaderIndex">
               <h3>
                  pkgReaderIndex
                  <span class="badge">struct</span>
                  <a href="#pkgReaderIndex" class="anchor" title="Link to pkgReaderIndex">#</a>
               </h3>
               
               <p>A pkgReaderIndex compactly identifies an index (and its
corresponding dictionary) within a package's export data.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pkgReaderIndex struct {
pr *pkgReader
idx index
dict *readerDict
methodSym *types.Sym
synthetic func(pos src.XPos, r *reader)
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pkgWriter" data-name="pkgWriter">
               <h3>
                  pkgWriter
                  <span class="badge">struct</span>
                  <a href="#pkgWriter" class="anchor" title="Link to pkgWriter">#</a>
               </h3>
               
               <p>A pkgWriter constructs Unified IR export data from the results of
running the types2 type checker on a Go compilation unit.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pkgWriter struct {
pkgbits.PkgEncoder
m posMap
curpkg *types2.Package
info *types2.Info
rangeFuncBodyClosures map[*syntax.FuncLit]bool
posBasesIdx map[*syntax.PosBase]index
pkgsIdx map[*types2.Package]index
typsIdx map[types2.Type]index
objsIdx map[types2.Object]index
funDecls map[*types2.Func]*syntax.FuncDecl
typDecls map[*types2.TypeName]typeDeclGen
linknames map[types2.Object]string
cgoPragmas [][]string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="posMap" data-name="posMap">
               <h3>
                  posMap
                  <span class="badge">struct</span>
                  <a href="#posMap" class="anchor" title="Link to posMap">#</a>
               </h3>
               
               <p>A posMap handles mapping from syntax.Pos to src.XPos.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type posMap struct {
bases map[*syntax.PosBase]*src.PosBase
cache struct{...}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="posVar" data-name="posVar">
               <h3>
                  posVar
                  <span class="badge">struct</span>
                  <a href="#posVar" class="anchor" title="Link to posVar">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type posVar struct {
pos syntax.Pos
var_ *types2.Var
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pragmaEmbed" data-name="pragmaEmbed">
               <h3>
                  pragmaEmbed
                  <span class="badge">struct</span>
                  <a href="#pragmaEmbed" class="anchor" title="Link to pragmaEmbed">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pragmaEmbed struct {
Pos syntax.Pos
Patterns []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pragmaPos" data-name="pragmaPos">
               <h3>
                  pragmaPos
                  <span class="badge">struct</span>
                  <a href="#pragmaPos" class="anchor" title="Link to pragmaPos">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pragmaPos struct {
Flag ir.PragmaFlag
Pos syntax.Pos
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pragmas" data-name="pragmas">
               <h3>
                  pragmas
                  <span class="badge">struct</span>
                  <a href="#pragmas" class="anchor" title="Link to pragmas">#</a>
               </h3>
               
               <p>*pragmas is the value stored in a syntax.pragmas during parsing.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pragmas struct {
Flag ir.PragmaFlag
Pos []pragmaPos
Embeds []pragmaEmbed
WasmImport *WasmImport
WasmExport *WasmExport
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="reader" data-name="reader">
               <h3>
                  reader
                  <span class="badge">struct</span>
                  <a href="#reader" class="anchor" title="Link to reader">#</a>
               </h3>
               
               <p>A reader provides APIs for reading an individual element.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type reader struct {
pkgbits.Decoder
p *pkgReader
dict *readerDict
curfn *ir.Func
locals []*ir.Name
closureVars []*ir.Name
funarghack bool
methodSym *types.Sym
dictParam *ir.Name
synthetic func(pos src.XPos, r *reader)
scopeVars []int
marker dwarfgen.ScopeMarker
lastCloseScopePos src.XPos
inlCaller *ir.Func
inlCall *ir.CallExpr
inlFunc *ir.Func
inlTreeIndex int
inlPosBases map[*src.PosBase]*src.PosBase
suppressInlPos int
delayResults bool
retlabel *types.Sym
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="readerDict" data-name="readerDict">
               <h3>
                  readerDict
                  <span class="badge">struct</span>
                  <a href="#readerDict" class="anchor" title="Link to readerDict">#</a>
               </h3>
               
               <p>A readerDict represents an instantiated "compile-time dictionary,"
used for resolving any derived types needed for instantiating a
generic object.
A compile-time dictionary can either be "shaped" or "non-shaped."
Shaped compile-time dictionaries are only used for instantiating
shaped type definitions and function bodies, while non-shaped
compile-time dictionaries are used for instantiating runtime
dictionaries.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type readerDict struct {
shaped bool
baseSym *types.Sym
shapedObj *ir.Name
targs []*types.Type
implicits int
derived []derivedInfo
derivedTypes []*types.Type
typeParamMethodExprs []readerMethodExprInfo
subdicts []objInfo
rtypes []typeInfo
itabs []itabInfo
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="readerMethodExprInfo" data-name="readerMethodExprInfo">
               <h3>
                  readerMethodExprInfo
                  <span class="badge">struct</span>
                  <a href="#readerMethodExprInfo" class="anchor" title="Link to readerMethodExprInfo">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type readerMethodExprInfo struct {
typeParamIdx int
method *types.Sym
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="selectorInfo" data-name="selectorInfo">
               <h3>
                  selectorInfo
                  <span class="badge">struct</span>
                  <a href="#selectorInfo" class="anchor" title="Link to selectorInfo">#</a>
               </h3>
               
               <p>A selectorInfo represents a reference to an encoded field or method
name (i.e., objects that can only be accessed using selector
expressions).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type selectorInfo struct {
pkgIdx index
nameIdx index
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="typeDeclGen" data-name="typeDeclGen">
               <h3>
                  typeDeclGen
                  <span class="badge">struct</span>
                  <a href="#typeDeclGen" class="anchor" title="Link to typeDeclGen">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type typeDeclGen struct {
*syntax.TypeDecl
gen int
implicits []*types2.TypeParam
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="typeInfo" data-name="typeInfo">
               <h3>
                  typeInfo
                  <span class="badge">struct</span>
                  <a href="#typeInfo" class="anchor" title="Link to typeInfo">#</a>
               </h3>
               
               <p>A typeInfo represents a reference to an encoded Go type.
If derived is true, then the typeInfo represents a generic Go type
that contains type parameters. In this case, idx is an index into
the readerDict.derived{,Types} arrays.
Otherwise, the typeInfo represents a non-generic Go type, and idx
is an index into the reader.typs array instead.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type typeInfo struct {
idx index
derived bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="writer" data-name="writer">
               <h3>
                  writer
                  <span class="badge">struct</span>
                  <a href="#writer" class="anchor" title="Link to writer">#</a>
               </h3>
               
               <p>A writer provides APIs for writing out an individual element.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type writer struct {
p *pkgWriter
pkgbits.Encoder
sig *types2.Signature
localsIdx map[*types2.Var]int
closureVars []posVar
closureVarsIdx map[*types2.Var]int
dict *writerDict
derived bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="writerDict" data-name="writerDict">
               <h3>
                  writerDict
                  <span class="badge">struct</span>
                  <a href="#writerDict" class="anchor" title="Link to writerDict">#</a>
               </h3>
               
               <p>A writerDict tracks types and objects that are used by a declaration.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type writerDict struct {
implicits []*types2.TypeParam
derived []derivedInfo
derivedIdx map[types2.Type]index
typeParamMethodExprs []writerMethodExprInfo
subdicts []objInfo
rtypes []typeInfo
itabs []itabInfo
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="writerMethodExprInfo" data-name="writerMethodExprInfo">
               <h3>
                  writerMethodExprInfo
                  <span class="badge">struct</span>
                  <a href="#writerMethodExprInfo" class="anchor" title="Link to writerMethodExprInfo">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type writerMethodExprInfo struct {
typeParamIdx int
methodInfo selectorInfo
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Addr" data-name="Addr">
               <h3>
                  Addr 
                  <span class="badge">function</span>
                  
                  <a href="#Addr" class="anchor" title="Link to Addr">#</a>
               </h3>
               
               <pre><code>func Addr(pos src.XPos, x ir.Node) *ir.AddrExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Deref" data-name="Deref">
               <h3>
                  Deref 
                  <span class="badge">function</span>
                  
                  <a href="#Deref" class="anchor" title="Link to Deref">#</a>
               </h3>
               
               <pre><code>func Deref(pos src.XPos, typ *types.Type, x ir.Node) *ir.StarExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FixValue" data-name="FixValue">
               <h3>
                  FixValue 
                  <span class="badge">function</span>
                  
                  <a href="#FixValue" class="anchor" title="Link to FixValue">#</a>
               </h3>
               
               <p>FixValue returns val after converting and truncating it as
appropriate for typ.</p>
               
               <pre><code>func FixValue(typ *types.Type, val constant.Value) constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Implicit" data-name="Implicit">
               <h3>
                  Implicit 
                  <span class="badge">function</span>
                  
                  <a href="#Implicit" class="anchor" title="Link to Implicit">#</a>
               </h3>
               
               <p>Implicit returns n after marking it as Implicit.</p>
               
               <pre><code>func Implicit(n ImplicitNode) ImplicitNode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Import" data-name="Import">
               <h3>
                  Import 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Import" class="anchor" title="Link to Import">#</a>
               </h3>
               
               <pre><code>func (m *gcimports) Import(path string) (*types2.Package, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportFrom" data-name="ImportFrom">
               <h3>
                  ImportFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportFrom" class="anchor" title="Link to ImportFrom">#</a>
               </h3>
               
               <pre><code>func (m *gcimports) ImportFrom(path string, srcDir string, mode types2.ImportMode) (*types2.Package, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LoadPackage" data-name="LoadPackage">
               <h3>
                  LoadPackage 
                  <span class="badge">function</span>
                  
                  <a href="#LoadPackage" class="anchor" title="Link to LoadPackage">#</a>
               </h3>
               
               <pre><code>func LoadPackage(filenames []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupFunc" data-name="LookupFunc">
               <h3>
                  LookupFunc 
                  <span class="badge">function</span>
                  
                  <a href="#LookupFunc" class="anchor" title="Link to LookupFunc">#</a>
               </h3>
               
               <p>LookupFunc returns the ir.Func for an arbitrary full symbol name if
that function exists in the set of available export data.
This allows lookup of arbitrary functions and methods that aren't otherwise
referenced by the local package and thus haven't been read yet.
TODO(prattmic): Does not handle instantiation of generic types. Currently
profiles don't contain the original type arguments, so we won't be able to
create the runtime dictionaries.
TODO(prattmic): Hit rate of this function is usually fairly low, and errors
are only used when debug logging is enabled. Consider constructing cheaper
errors by default.</p>
               
               <pre><code>func LookupFunc(fullName string) (*ir.Func, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MakeWrappers" data-name="MakeWrappers">
               <h3>
                  MakeWrappers 
                  <span class="badge">function</span>
                  
                  <a href="#MakeWrappers" class="anchor" title="Link to MakeWrappers">#</a>
               </h3>
               
               <p>MakeWrappers constructs all wrapper methods needed for the target
compilation unit.</p>
               
               <pre><code>func MakeWrappers(target *ir.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Marker" data-name="Marker">
               <h3>
                  Marker 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Marker" class="anchor" title="Link to Marker">#</a>
               </h3>
               
               <pre><code>func (c codeAssign) Marker() pkgbits.SyncMarker</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Marker" data-name="Marker">
               <h3>
                  Marker 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Marker" class="anchor" title="Link to Marker">#</a>
               </h3>
               
               <pre><code>func (c codeExpr) Marker() pkgbits.SyncMarker</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Marker" data-name="Marker">
               <h3>
                  Marker 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Marker" class="anchor" title="Link to Marker">#</a>
               </h3>
               
               <pre><code>func (c codeStmt) Marker() pkgbits.SyncMarker</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Marker" data-name="Marker">
               <h3>
                  Marker 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Marker" class="anchor" title="Link to Marker">#</a>
               </h3>
               
               <pre><code>func (c codeDecl) Marker() pkgbits.SyncMarker</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PostLookupCleanup" data-name="PostLookupCleanup">
               <h3>
                  PostLookupCleanup 
                  <span class="badge">function</span>
                  
                  <a href="#PostLookupCleanup" class="anchor" title="Link to PostLookupCleanup">#</a>
               </h3>
               
               <p>PostLookupCleanup performs cleanup operations needed
after a series of calls to LookupFunc, specifically invoking
readBodies to post-process any funcs on the "todoBodies" list
that were added as a result of the lookup operations.</p>
               
               <pre><code>func PostLookupCleanup()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Renameinit" data-name="Renameinit">
               <h3>
                  Renameinit 
                  <span class="badge">function</span>
                  
                  <a href="#Renameinit" class="anchor" title="Link to Renameinit">#</a>
               </h3>
               
               <pre><code>func Renameinit() *types.Sym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (p posVar) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Value" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Value" class="anchor" title="Link to Value">#</a>
               </h3>
               
               <pre><code>func (c codeStmt) Value() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Value" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Value" class="anchor" title="Link to Value">#</a>
               </h3>
               
               <pre><code>func (c codeAssign) Value() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Value" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Value" class="anchor" title="Link to Value">#</a>
               </h3>
               
               <pre><code>func (c codeExpr) Value() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Value" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Value" class="anchor" title="Link to Value">#</a>
               </h3>
               
               <pre><code>func (c codeDecl) Value() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Visit" data-name="Visit">
               <h3>
                  Visit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Visit" class="anchor" title="Link to Visit">#</a>
               </h3>
               
               <pre><code>func (c *declCollector) Visit(n syntax.Node) syntax.Visitor</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteExports" data-name="WriteExports">
               <h3>
                  WriteExports 
                  <span class="badge">function</span>
                  
                  <a href="#WriteExports" class="anchor" title="Link to WriteExports">#</a>
               </h3>
               
               <pre><code>func WriteExports(out *bio.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addBody" data-name="addBody">
               <h3>
                  addBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addBody" class="anchor" title="Link to addBody">#</a>
               </h3>
               
               <p>addBody reads a function body reference from the element bitstream,
and associates it with fn.</p>
               
               <pre><code>func (r *reader) addBody(fn *ir.Func, method *types.Sym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addFingerprint" data-name="addFingerprint">
               <h3>
                  addFingerprint 
                  <span class="badge">function</span>
                  
                  <a href="#addFingerprint" class="anchor" title="Link to addFingerprint">#</a>
               </h3>
               
               <p>addFingerprint reads the linker fingerprint included at the end of
the exportdata.</p>
               
               <pre><code>func addFingerprint(path string, data string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addLocal" data-name="addLocal">
               <h3>
                  addLocal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addLocal" class="anchor" title="Link to addLocal">#</a>
               </h3>
               
               <pre><code>func (r *reader) addLocal(name *ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addLocal" data-name="addLocal">
               <h3>
                  addLocal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addLocal" class="anchor" title="Link to addLocal">#</a>
               </h3>
               
               <p>addLocal records the declaration of a new local variable.</p>
               
               <pre><code>func (w *writer) addLocal(obj *types2.Var)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addTailCall" data-name="addTailCall">
               <h3>
                  addTailCall 
                  <span class="badge">function</span>
                  
                  <a href="#addTailCall" class="anchor" title="Link to addTailCall">#</a>
               </h3>
               
               <pre><code>func addTailCall(pos src.XPos, fn *ir.Func, recv ir.Node, method *types.Field)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="anyDerived" data-name="anyDerived">
               <h3>
                  anyDerived 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#anyDerived" class="anchor" title="Link to anyDerived">#</a>
               </h3>
               
               <p>anyDerived reports whether any of info's explicit type arguments
are derived types.</p>
               
               <pre><code>func (info objInfo) anyDerived() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="asPragmaFlag" data-name="asPragmaFlag">
               <h3>
                  asPragmaFlag 
                  <span class="badge">function</span>
                  
                  <a href="#asPragmaFlag" class="anchor" title="Link to asPragmaFlag">#</a>
               </h3>
               
               <pre><code>func asPragmaFlag(p syntax.Pragma) ir.PragmaFlag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="asReader" data-name="asReader">
               <h3>
                  asReader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#asReader" class="anchor" title="Link to asReader">#</a>
               </h3>
               
               <pre><code>func (pri pkgReaderIndex) asReader(k pkgbits.RelocKind, marker pkgbits.SyncMarker) *reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="asWasmExport" data-name="asWasmExport">
               <h3>
                  asWasmExport 
                  <span class="badge">function</span>
                  
                  <a href="#asWasmExport" class="anchor" title="Link to asWasmExport">#</a>
               </h3>
               
               <pre><code>func asWasmExport(p syntax.Pragma) *WasmExport</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="asWasmImport" data-name="asWasmImport">
               <h3>
                  asWasmImport 
                  <span class="badge">function</span>
                  
                  <a href="#asWasmImport" class="anchor" title="Link to asWasmImport">#</a>
               </h3>
               
               <pre><code>func asWasmImport(p syntax.Pragma) *WasmImport</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assert" data-name="assert">
               <h3>
                  assert 
                  <span class="badge">function</span>
                  
                  <a href="#assert" class="anchor" title="Link to assert">#</a>
               </h3>
               
               <pre><code>func assert(p bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assign" data-name="assign">
               <h3>
                  assign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assign" class="anchor" title="Link to assign">#</a>
               </h3>
               
               <pre><code>func (w *writer) assign(expr syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assign" data-name="assign">
               <h3>
                  assign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assign" class="anchor" title="Link to assign">#</a>
               </h3>
               
               <p>assign returns an assignee expression. It also reports whether the
returned expression is a newly declared variable.</p>
               
               <pre><code>func (r *reader) assign() (ir.Node, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignList" data-name="assignList">
               <h3>
                  assignList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignList" class="anchor" title="Link to assignList">#</a>
               </h3>
               
               <pre><code>func (r *reader) assignList() ([]*ir.Name, []ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignList" data-name="assignList">
               <h3>
                  assignList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignList" class="anchor" title="Link to assignList">#</a>
               </h3>
               
               <pre><code>func (w *writer) assignList(expr syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignStmt" data-name="assignStmt">
               <h3>
                  assignStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignStmt" class="anchor" title="Link to assignStmt">#</a>
               </h3>
               
               <p>assignStmt writes out an assignment for "lhs = rhs".</p>
               
               <pre><code>func (w *writer) assignStmt(pos poser, lhs0 syntax.Expr, rhs0 syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="block" data-name="block">
               <h3>
                  block 
                  <span class="badge">function</span>
                  
                  <a href="#block" class="anchor" title="Link to block">#</a>
               </h3>
               
               <pre><code>func block(stmts []ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="blockStmt" data-name="blockStmt">
               <h3>
                  blockStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#blockStmt" class="anchor" title="Link to blockStmt">#</a>
               </h3>
               
               <pre><code>func (w *writer) blockStmt(stmt *syntax.BlockStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="blockStmt" data-name="blockStmt">
               <h3>
                  blockStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#blockStmt" class="anchor" title="Link to blockStmt">#</a>
               </h3>
               
               <pre><code>func (r *reader) blockStmt() []ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bodyIdx" data-name="bodyIdx">
               <h3>
                  bodyIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bodyIdx" class="anchor" title="Link to bodyIdx">#</a>
               </h3>
               
               <p>bodyIdx returns the index for the given function body (specified by
block), adding it to the export data</p>
               
               <pre><code>func (pw *pkgWriter) bodyIdx(sig *types2.Signature, block *syntax.BlockStmt, dict *writerDict) (idx index, closureVars []posVar)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bodyReaderFor" data-name="bodyReaderFor">
               <h3>
                  bodyReaderFor 
                  <span class="badge">function</span>
                  
                  <a href="#bodyReaderFor" class="anchor" title="Link to bodyReaderFor">#</a>
               </h3>
               
               <p>bodyReaderFor returns the pkgReaderIndex for reading fn's
serialized IR, and whether one was found.</p>
               
               <pre><code>func bodyReaderFor(fn *ir.Func) (pri pkgReaderIndex, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="callShaped" data-name="callShaped">
               <h3>
                  callShaped 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#callShaped" class="anchor" title="Link to callShaped">#</a>
               </h3>
               
               <p>callShaped emits a tail call to r.shapedFn, passing along the
arguments to the current function.</p>
               
               <pre><code>func (r *reader) callShaped(pos src.XPos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkEmbed" data-name="checkEmbed">
               <h3>
                  checkEmbed 
                  <span class="badge">function</span>
                  
                  <a href="#checkEmbed" class="anchor" title="Link to checkEmbed">#</a>
               </h3>
               
               <pre><code>func checkEmbed(decl *syntax.VarDecl, haveEmbed bool, withinFunc bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkFiles" data-name="checkFiles">
               <h3>
                  checkFiles 
                  <span class="badge">function</span>
                  
                  <a href="#checkFiles" class="anchor" title="Link to checkFiles">#</a>
               </h3>
               
               <p>checkFiles configures and runs the types2 checker on the given
parsed source files and then returns the result.
The map result value indicates which closures are generated from the bodies of range function loops.</p>
               
               <pre><code>func checkFiles(m posMap, noders []*noder) (*types2.Package, *types2.Info, map[*syntax.FuncLit]bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkImportPath" data-name="checkImportPath">
               <h3>
                  checkImportPath 
                  <span class="badge">function</span>
                  
                  <a href="#checkImportPath" class="anchor" title="Link to checkImportPath">#</a>
               </h3>
               
               <pre><code>func checkImportPath(path string, allowSpace bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPragmas" data-name="checkPragmas">
               <h3>
                  checkPragmas 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkPragmas" class="anchor" title="Link to checkPragmas">#</a>
               </h3>
               
               <pre><code>func (pw *pkgWriter) checkPragmas(p syntax.Pragma, allowed ir.PragmaFlag, embedOK bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkUnusedDuringParse" data-name="checkUnusedDuringParse">
               <h3>
                  checkUnusedDuringParse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkUnusedDuringParse" class="anchor" title="Link to checkUnusedDuringParse">#</a>
               </h3>
               
               <pre><code>func (p *noder) checkUnusedDuringParse(pragma *pragmas)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeAnotherScope" data-name="closeAnotherScope">
               <h3>
                  closeAnotherScope 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeAnotherScope" class="anchor" title="Link to closeAnotherScope">#</a>
               </h3>
               
               <p>closeAnotherScope is like closeScope, but it reuses the same mark
position as the last closeScope call. This is useful for "for" and
"if" statements, as their implicit blocks always end at the same
position as an explicit block.</p>
               
               <pre><code>func (r *reader) closeAnotherScope()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeAnotherScope" data-name="closeAnotherScope">
               <h3>
                  closeAnotherScope 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeAnotherScope" class="anchor" title="Link to closeAnotherScope">#</a>
               </h3>
               
               <pre><code>func (w *writer) closeAnotherScope()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeScope" data-name="closeScope">
               <h3>
                  closeScope 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeScope" class="anchor" title="Link to closeScope">#</a>
               </h3>
               
               <pre><code>func (r *reader) closeScope()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeScope" data-name="closeScope">
               <h3>
                  closeScope 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeScope" class="anchor" title="Link to closeScope">#</a>
               </h3>
               
               <pre><code>func (w *writer) closeScope(pos syntax.Pos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="collectDecls" data-name="collectDecls">
               <h3>
                  collectDecls 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#collectDecls" class="anchor" title="Link to collectDecls">#</a>
               </h3>
               
               <pre><code>func (pw *pkgWriter) collectDecls(noders []*noder)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compLit" data-name="compLit">
               <h3>
                  compLit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#compLit" class="anchor" title="Link to compLit">#</a>
               </h3>
               
               <pre><code>func (w *writer) compLit(lit *syntax.CompositeLit)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compLit" data-name="compLit">
               <h3>
                  compLit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#compLit" class="anchor" title="Link to compLit">#</a>
               </h3>
               
               <pre><code>func (r *reader) compLit() ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convRTTI" data-name="convRTTI">
               <h3>
                  convRTTI 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#convRTTI" class="anchor" title="Link to convRTTI">#</a>
               </h3>
               
               <p>convRTTI writes information so that the reader can construct
expressions for converting from src to dst.</p>
               
               <pre><code>func (w *writer) convRTTI(src types2.Type, dst types2.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convRTTI" data-name="convRTTI">
               <h3>
                  convRTTI 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#convRTTI" class="anchor" title="Link to convRTTI">#</a>
               </h3>
               
               <p>convRTTI returns expressions appropriate for populating an
ir.ConvExpr's TypeWord and SrcRType fields, respectively.</p>
               
               <pre><code>func (r *reader) convRTTI(pos src.XPos) (typeWord ir.Node, srcRType ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convertExpr" data-name="convertExpr">
               <h3>
                  convertExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#convertExpr" class="anchor" title="Link to convertExpr">#</a>
               </h3>
               
               <pre><code>func (w *writer) convertExpr(dst types2.Type, expr syntax.Expr, implicit bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="curry" data-name="curry">
               <h3>
                  curry 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#curry" class="anchor" title="Link to curry">#</a>
               </h3>
               
               <p>curry returns a function literal that calls fun with arg0 and
(optionally) arg1, accepting additional arguments to the function
literal as necessary to satisfy fun's signature.
If nilCheck is true and arg0 is an interface value, then it's
checked to be non-nil as an initial step at the point of evaluating
the function literal itself.</p>
               
               <pre><code>func (r *reader) curry(origPos src.XPos, ifaceHack bool, fun ir.Node, arg0 ir.Node, arg1 ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="declStmt" data-name="declStmt">
               <h3>
                  declStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#declStmt" class="anchor" title="Link to declStmt">#</a>
               </h3>
               
               <pre><code>func (w *writer) declStmt(decl syntax.Decl)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="declareParams" data-name="declareParams">
               <h3>
                  declareParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#declareParams" class="anchor" title="Link to declareParams">#</a>
               </h3>
               
               <pre><code>func (r *reader) declareParams()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="declareParams" data-name="declareParams">
               <h3>
                  declareParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#declareParams" class="anchor" title="Link to declareParams">#</a>
               </h3>
               
               <pre><code>func (w *writer) declareParams(sig *types2.Signature)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="deref2" data-name="deref2">
               <h3>
                  deref2 
                  <span class="badge">function</span>
                  
                  <a href="#deref2" class="anchor" title="Link to deref2">#</a>
               </h3>
               
               <p>deref2 does a single deref of types2 type t, if it is a pointer type.</p>
               
               <pre><code>func deref2(t types2.Type) types2.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dictNameOf" data-name="dictNameOf">
               <h3>
                  dictNameOf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dictNameOf" class="anchor" title="Link to dictNameOf">#</a>
               </h3>
               
               <p>dictNameOf returns the runtime dictionary corresponding to dict.</p>
               
               <pre><code>func (pr *pkgReader) dictNameOf(dict *readerDict) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dictWord" data-name="dictWord">
               <h3>
                  dictWord 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dictWord" class="anchor" title="Link to dictWord">#</a>
               </h3>
               
               <p>dictWord returns an expression to return the specified
uintptr-typed word from the dictionary parameter.</p>
               
               <pre><code>func (r *reader) dictWord(pos src.XPos, idx int) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="distinctVars" data-name="distinctVars">
               <h3>
                  distinctVars 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#distinctVars" class="anchor" title="Link to distinctVars">#</a>
               </h3>
               
               <pre><code>func (w *writer) distinctVars(stmt *syntax.ForStmt) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doObj" data-name="doObj">
               <h3>
                  doObj 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doObj" class="anchor" title="Link to doObj">#</a>
               </h3>
               
               <p>doObj writes the RelocObj definition for obj to w, and the
RelocObjExt definition to wext.</p>
               
               <pre><code>func (w *writer) doObj(wext *writer, obj types2.Object) pkgbits.CodeObj</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doPkg" data-name="doPkg">
               <h3>
                  doPkg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doPkg" class="anchor" title="Link to doPkg">#</a>
               </h3>
               
               <p>doPkg reads a package definition from the bitstream.</p>
               
               <pre><code>func (r *reader) doPkg() *types.Pkg</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doTyp" data-name="doTyp">
               <h3>
                  doTyp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doTyp" class="anchor" title="Link to doTyp">#</a>
               </h3>
               
               <pre><code>func (r *reader) doTyp() *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="end" data-name="end">
               <h3>
                  end 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#end" class="anchor" title="Link to end">#</a>
               </h3>
               
               <pre><code>func (m *posMap) end(p ender) src.XPos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="equals" data-name="equals">
               <h3>
                  equals 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#equals" class="anchor" title="Link to equals">#</a>
               </h3>
               
               <p>equals reports whether info and other represent the same Go object
(i.e., same base object and identical type arguments, if any).</p>
               
               <pre><code>func (info objInfo) equals(other objInfo) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="error" data-name="error">
               <h3>
                  error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#error" class="anchor" title="Link to error">#</a>
               </h3>
               
               <p>error is called concurrently if files are parsed concurrently.</p>
               
               <pre><code>func (p *noder) error(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errorf" data-name="errorf">
               <h3>
                  errorf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#errorf" class="anchor" title="Link to errorf">#</a>
               </h3>
               
               <p>errorf reports a user error about thing p.</p>
               
               <pre><code>func (pw *pkgWriter) errorf(p poser, msg string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expandInline" data-name="expandInline">
               <h3>
                  expandInline 
                  <span class="badge">function</span>
                  
                  <a href="#expandInline" class="anchor" title="Link to expandInline">#</a>
               </h3>
               
               <p>expandInline reads in an extra copy of IR to populate
fn.Inl.Dcl.</p>
               
               <pre><code>func expandInline(fn *ir.Func, pri pkgReaderIndex)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exportBody" data-name="exportBody">
               <h3>
                  exportBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exportBody" class="anchor" title="Link to exportBody">#</a>
               </h3>
               
               <p>exportBody exports the given function or method's body, if
appropriate. local indicates whether it's a local function or
method available on a locally declared type. (Due to cross-package
type aliases, a method may be imported, but still available on a
locally declared type.)</p>
               
               <pre><code>func (l *linker) exportBody(obj *ir.Name, local bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expr" data-name="expr">
               <h3>
                  expr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expr" class="anchor" title="Link to expr">#</a>
               </h3>
               
               <p>expr writes the given expression into the function body bitstream.</p>
               
               <pre><code>func (w *writer) expr(expr syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expr" data-name="expr">
               <h3>
                  expr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expr" class="anchor" title="Link to expr">#</a>
               </h3>
               
               <p>expr reads and returns a typechecked expression.</p>
               
               <pre><code>func (r *reader) expr() (res ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprList" data-name="exprList">
               <h3>
                  exprList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprList" class="anchor" title="Link to exprList">#</a>
               </h3>
               
               <pre><code>func (w *writer) exprList(expr syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprList" data-name="exprList">
               <h3>
                  exprList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprList" class="anchor" title="Link to exprList">#</a>
               </h3>
               
               <pre><code>func (r *reader) exprList() []ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprType" data-name="exprType">
               <h3>
                  exprType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprType" class="anchor" title="Link to exprType">#</a>
               </h3>
               
               <pre><code>func (w *writer) exprType(iface types2.Type, typ syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprType" data-name="exprType">
               <h3>
                  exprType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprType" class="anchor" title="Link to exprType">#</a>
               </h3>
               
               <pre><code>func (r *reader) exprType() ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprs" data-name="exprs">
               <h3>
                  exprs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprs" class="anchor" title="Link to exprs">#</a>
               </h3>
               
               <pre><code>func (w *writer) exprs(exprs []syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprs" data-name="exprs">
               <h3>
                  exprs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprs" class="anchor" title="Link to exprs">#</a>
               </h3>
               
               <pre><code>func (r *reader) exprs() []ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fatalf" data-name="fatalf">
               <h3>
                  fatalf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fatalf" class="anchor" title="Link to fatalf">#</a>
               </h3>
               
               <p>fatalf reports an internal compiler error about thing p.</p>
               
               <pre><code>func (pw *pkgWriter) fatalf(p poser, msg string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fieldIndex" data-name="fieldIndex">
               <h3>
                  fieldIndex 
                  <span class="badge">function</span>
                  
                  <a href="#fieldIndex" class="anchor" title="Link to fieldIndex">#</a>
               </h3>
               
               <p>fieldIndex returns the index of the struct field named by key.</p>
               
               <pre><code>func fieldIndex(info *types2.Info, str *types2.Struct, key *syntax.Name) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="finishWrapperFunc" data-name="finishWrapperFunc">
               <h3>
                  finishWrapperFunc 
                  <span class="badge">function</span>
                  
                  <a href="#finishWrapperFunc" class="anchor" title="Link to finishWrapperFunc">#</a>
               </h3>
               
               <pre><code>func finishWrapperFunc(fn *ir.Func, target *ir.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="forStmt" data-name="forStmt">
               <h3>
                  forStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#forStmt" class="anchor" title="Link to forStmt">#</a>
               </h3>
               
               <pre><code>func (r *reader) forStmt(label *types.Sym) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="forStmt" data-name="forStmt">
               <h3>
                  forStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#forStmt" class="anchor" title="Link to forStmt">#</a>
               </h3>
               
               <pre><code>func (w *writer) forStmt(stmt *syntax.ForStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="freePackage" data-name="freePackage">
               <h3>
                  freePackage 
                  <span class="badge">function</span>
                  
                  <a href="#freePackage" class="anchor" title="Link to freePackage">#</a>
               </h3>
               
               <p>freePackage ensures the given package is garbage collected.</p>
               
               <pre><code>func freePackage(pkg *types2.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcBody" data-name="funcBody">
               <h3>
                  funcBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcBody" class="anchor" title="Link to funcBody">#</a>
               </h3>
               
               <p>funcBody reads a function body definition from the element
bitstream, and populates fn with it.</p>
               
               <pre><code>func (r *reader) funcBody(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcBody" data-name="funcBody">
               <h3>
                  funcBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcBody" class="anchor" title="Link to funcBody">#</a>
               </h3>
               
               <pre><code>func (pri pkgReaderIndex) funcBody(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcExt" data-name="funcExt">
               <h3>
                  funcExt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcExt" class="anchor" title="Link to funcExt">#</a>
               </h3>
               
               <pre><code>func (r *reader) funcExt(name *ir.Name, method *types.Sym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcExt" data-name="funcExt">
               <h3>
                  funcExt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcExt" class="anchor" title="Link to funcExt">#</a>
               </h3>
               
               <pre><code>func (w *writer) funcExt(obj *types2.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcInst" data-name="funcInst">
               <h3>
                  funcInst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcInst" class="anchor" title="Link to funcInst">#</a>
               </h3>
               
               <p>funcInst reads an instantiated function reference, and returns
three (possibly nil) expressions related to it:
baseFn is always non-nil: it's either a function of the appropriate
type already, or it has an extra dictionary parameter as the first
parameter.
If dictPtr is non-nil, then it's a dictionary argument that must be
passed as the first argument to baseFn.
If wrapperFn is non-nil, then it's either the same as baseFn (if
dictPtr is nil), or it's semantically equivalent to currying baseFn
to pass dictPtr. (wrapperFn is nil when dictPtr is an expression
that needs to be computed dynamically.)
For callers that are creating a call to the returned function, it's
best to emit a call to baseFn, and include dictPtr in the arguments
list as appropriate.
For callers that want to return the function without invoking it,
they may return wrapperFn if it's non-nil; but otherwise, they need
to create their own wrapper.</p>
               
               <pre><code>func (r *reader) funcInst(pos src.XPos) (wrapperFn ir.Node, baseFn ir.Node, dictPtr ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcInst" data-name="funcInst">
               <h3>
                  funcInst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcInst" class="anchor" title="Link to funcInst">#</a>
               </h3>
               
               <p>funcInst writes a reference to an instantiated function.</p>
               
               <pre><code>func (w *writer) funcInst(obj *types2.Func, targs *types2.TypeList)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcLit" data-name="funcLit">
               <h3>
                  funcLit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcLit" class="anchor" title="Link to funcLit">#</a>
               </h3>
               
               <pre><code>func (w *writer) funcLit(expr *syntax.FuncLit)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcLit" data-name="funcLit">
               <h3>
                  funcLit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcLit" class="anchor" title="Link to funcLit">#</a>
               </h3>
               
               <pre><code>func (r *reader) funcLit() ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasCycle" data-name="hasCycle">
               <h3>
                  hasCycle 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasCycle" class="anchor" title="Link to hasCycle">#</a>
               </h3>
               
               <p>hasCycle reports whether typ is part of an anonymous interface cycle.</p>
               
               <pre><code>func (f *cycleFinder) hasCycle(typ *types2.Interface) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasFallthrough" data-name="hasFallthrough">
               <h3>
                  hasFallthrough 
                  <span class="badge">function</span>
                  
                  <a href="#hasFallthrough" class="anchor" title="Link to hasFallthrough">#</a>
               </h3>
               
               <p>hasFallthrough reports whether stmts ends in a fallthrough
statement.</p>
               
               <pre><code>func hasFallthrough(stmts []syntax.Stmt) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasImplicitTypeParams" data-name="hasImplicitTypeParams">
               <h3>
                  hasImplicitTypeParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasImplicitTypeParams" class="anchor" title="Link to hasImplicitTypeParams">#</a>
               </h3>
               
               <p>hasImplicitTypeParams reports whether obj is a defined type with
implicit type parameters (e.g., declared within a generic function
or method).</p>
               
               <pre><code>func (pw *pkgWriter) hasImplicitTypeParams(obj *types2.TypeName) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasTypeParams" data-name="hasTypeParams">
               <h3>
                  hasTypeParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasTypeParams" class="anchor" title="Link to hasTypeParams">#</a>
               </h3>
               
               <pre><code>func (dict *readerDict) hasTypeParams() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasTypeParams" data-name="hasTypeParams">
               <h3>
                  hasTypeParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasTypeParams" class="anchor" title="Link to hasTypeParams">#</a>
               </h3>
               
               <pre><code>func (r *reader) hasTypeParams() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="idealType" data-name="idealType">
               <h3>
                  idealType 
                  <span class="badge">function</span>
                  
                  <a href="#idealType" class="anchor" title="Link to idealType">#</a>
               </h3>
               
               <pre><code>func idealType(tv syntax.TypeAndValue) types2.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ifStmt" data-name="ifStmt">
               <h3>
                  ifStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ifStmt" class="anchor" title="Link to ifStmt">#</a>
               </h3>
               
               <pre><code>func (r *reader) ifStmt() ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ifStmt" data-name="ifStmt">
               <h3>
                  ifStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ifStmt" class="anchor" title="Link to ifStmt">#</a>
               </h3>
               
               <pre><code>func (w *writer) ifStmt(stmt *syntax.IfStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="implicitConvExpr" data-name="implicitConvExpr">
               <h3>
                  implicitConvExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#implicitConvExpr" class="anchor" title="Link to implicitConvExpr">#</a>
               </h3>
               
               <p>implicitConvExpr is like expr, but if dst is non-nil and different
from expr's type, then an implicit conversion operation is inserted
at expr's position.</p>
               
               <pre><code>func (w *writer) implicitConvExpr(dst types2.Type, expr syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="importedDef" data-name="importedDef">
               <h3>
                  importedDef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#importedDef" class="anchor" title="Link to importedDef">#</a>
               </h3>
               
               <p>importedDef reports whether r is reading from an imported and
non-generic element.
If a type was found in an imported package, then we can assume that
package (or one of its transitive dependencies) already generated
method wrappers for it.
Exception: If we're instantiating an imported generic type or
function, we might be instantiating it with type arguments not
previously seen before.
TODO(mdempsky): Distinguish when a generic function or type was
instantiated in an imported package so that we can add types to
haveWrapperTypes instead.</p>
               
               <pre><code>func (r *reader) importedDef() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initDefn" data-name="initDefn">
               <h3>
                  initDefn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initDefn" class="anchor" title="Link to initDefn">#</a>
               </h3>
               
               <p>initDefn marks the given names as declared by defn and populates
its Init field with ODCL nodes. It then reports whether any names
were so declared, which can be used to initialize defn.Def.</p>
               
               <pre><code>func (r *reader) initDefn(defn ir.InitNode, names []*ir.Name) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inlClosureFunc" data-name="inlClosureFunc">
               <h3>
                  inlClosureFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#inlClosureFunc" class="anchor" title="Link to inlClosureFunc">#</a>
               </h3>
               
               <p>inlClosureFunc constructs a new closure function, but correctly
handles inlining.</p>
               
               <pre><code>func (r *reader) inlClosureFunc(origPos src.XPos, sig *types.Type, why ir.Op) *ir.Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inlPos" data-name="inlPos">
               <h3>
                  inlPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#inlPos" class="anchor" title="Link to inlPos">#</a>
               </h3>
               
               <p>inlPos returns the inlining-adjusted src.XPos corresponding to
xpos, which must be a non-inlined position. When not inlining, this
is just xpos.</p>
               
               <pre><code>func (r *reader) inlPos(xpos src.XPos) src.XPos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inlPosBase" data-name="inlPosBase">
               <h3>
                  inlPosBase 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#inlPosBase" class="anchor" title="Link to inlPosBase">#</a>
               </h3>
               
               <p>inlPosBase returns the inlining-adjusted src.PosBase corresponding
to oldBase, which must be a non-inlined position. When not
inlining, this is just oldBase.</p>
               
               <pre><code>func (r *reader) inlPosBase(oldBase *src.PosBase) *src.PosBase</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inlReturn" data-name="inlReturn">
               <h3>
                  inlReturn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#inlReturn" class="anchor" title="Link to inlReturn">#</a>
               </h3>
               
               <p>inlReturn returns a statement that can substitute for the given
return statement when inlining.</p>
               
               <pre><code>func (r *reader) inlReturn(ret *ir.ReturnStmt, retvars []*ir.Name) *ir.BlockStmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="interfaceType" data-name="interfaceType">
               <h3>
                  interfaceType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#interfaceType" class="anchor" title="Link to interfaceType">#</a>
               </h3>
               
               <pre><code>func (w *writer) interfaceType(typ *types2.Interface)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="interfaceType" data-name="interfaceType">
               <h3>
                  interfaceType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#interfaceType" class="anchor" title="Link to interfaceType">#</a>
               </h3>
               
               <pre><code>func (r *reader) interfaceType() *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isBuiltin" data-name="isBuiltin">
               <h3>
                  isBuiltin 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isBuiltin" class="anchor" title="Link to isBuiltin">#</a>
               </h3>
               
               <p>isBuiltin reports whether expr is a (possibly parenthesized)
referenced to the specified built-in function.</p>
               
               <pre><code>func (pw *pkgWriter) isBuiltin(expr syntax.Expr, builtin string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isCgoGeneratedFile" data-name="isCgoGeneratedFile">
               <h3>
                  isCgoGeneratedFile 
                  <span class="badge">function</span>
                  
                  <a href="#isCgoGeneratedFile" class="anchor" title="Link to isCgoGeneratedFile">#</a>
               </h3>
               
               <p>isCgoGeneratedFile reports whether pos is in a file
generated by cgo, which is to say a file with name
beginning with "_cgo_". Such files are allowed to
contain cgo directives, and for security reasons
(primarily misuse of linker flags), other files are not.
See golang.org/issue/23672.
Note that cmd/go ignores files whose names start with underscore,
so the only _cgo_ files we will see from cmd/go are generated by cgo.
It's easy to bypass this check by calling the compiler directly;
we only protect against uses by cmd/go.</p>
               
               <pre><code>func isCgoGeneratedFile(pos syntax.Pos) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDefinedType" data-name="isDefinedType">
               <h3>
                  isDefinedType 
                  <span class="badge">function</span>
                  
                  <a href="#isDefinedType" class="anchor" title="Link to isDefinedType">#</a>
               </h3>
               
               <p>isDefinedType reports whether obj is a defined type.</p>
               
               <pre><code>func isDefinedType(obj types2.Object) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDriveLetter" data-name="isDriveLetter">
               <h3>
                  isDriveLetter 
                  <span class="badge">function</span>
                  
                  <a href="#isDriveLetter" class="anchor" title="Link to isDriveLetter">#</a>
               </h3>
               
               <pre><code>func isDriveLetter(b byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isGlobal" data-name="isGlobal">
               <h3>
                  isGlobal 
                  <span class="badge">function</span>
                  
                  <a href="#isGlobal" class="anchor" title="Link to isGlobal">#</a>
               </h3>
               
               <p>isGlobal reports whether obj was declared at package scope.
Caveat: blank objects are not declared.</p>
               
               <pre><code>func isGlobal(obj types2.Object) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isInterface" data-name="isInterface">
               <h3>
                  isInterface 
                  <span class="badge">function</span>
                  
                  <a href="#isInterface" class="anchor" title="Link to isInterface">#</a>
               </h3>
               
               <p>isInterface reports whether typ is known to be an interface type.
If typ is a type parameter, then isInterface reports an internal
compiler error instead.</p>
               
               <pre><code>func isInterface(typ types2.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNil" data-name="isNil">
               <h3>
                  isNil 
                  <span class="badge">function</span>
                  
                  <a href="#isNil" class="anchor" title="Link to isNil">#</a>
               </h3>
               
               <p>isNil reports whether expr is a (possibly parenthesized) reference
to the predeclared nil value.</p>
               
               <pre><code>func isNil(p *pkgWriter, expr syntax.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNotInHeap" data-name="isNotInHeap">
               <h3>
                  isNotInHeap 
                  <span class="badge">function</span>
                  
                  <a href="#isNotInHeap" class="anchor" title="Link to isNotInHeap">#</a>
               </h3>
               
               <p>isNotInHeap reports whether typ is or contains an element of type
internal/runtime/sys.NotInHeap.</p>
               
               <pre><code>func isNotInHeap(typ types2.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isPkgQual" data-name="isPkgQual">
               <h3>
                  isPkgQual 
                  <span class="badge">function</span>
                  
                  <a href="#isPkgQual" class="anchor" title="Link to isPkgQual">#</a>
               </h3>
               
               <p>isPkgQual reports whether the given selector expression is a
package-qualified identifier.</p>
               
               <pre><code>func isPkgQual(info *types2.Info, sel *syntax.SelectorExpr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isPtrTo" data-name="isPtrTo">
               <h3>
                  isPtrTo 
                  <span class="badge">function</span>
                  
                  <a href="#isPtrTo" class="anchor" title="Link to isPtrTo">#</a>
               </h3>
               
               <p>isPtrTo reports whether from is the type *to.</p>
               
               <pre><code>func isPtrTo(from types2.Type, to types2.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isQuoted" data-name="isQuoted">
               <h3>
                  isQuoted 
                  <span class="badge">function</span>
                  
                  <a href="#isQuoted" class="anchor" title="Link to isQuoted">#</a>
               </h3>
               
               <pre><code>func isQuoted(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isSpace" data-name="isSpace">
               <h3>
                  isSpace 
                  <span class="badge">function</span>
                  
                  <a href="#isSpace" class="anchor" title="Link to isSpace">#</a>
               </h3>
               
               <pre><code>func isSpace(c rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTuple" data-name="isTuple">
               <h3>
                  isTuple 
                  <span class="badge">function</span>
                  
                  <a href="#isTuple" class="anchor" title="Link to isTuple">#</a>
               </h3>
               
               <p>isTuple reports whether typ is a tuple type.</p>
               
               <pre><code>func isTuple(typ types2.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTypeParam" data-name="isTypeParam">
               <h3>
                  isTypeParam 
                  <span class="badge">function</span>
                  
                  <a href="#isTypeParam" class="anchor" title="Link to isTypeParam">#</a>
               </h3>
               
               <pre><code>func isTypeParam(t types2.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isUntyped" data-name="isUntyped">
               <h3>
                  isUntyped 
                  <span class="badge">function</span>
                  
                  <a href="#isUntyped" class="anchor" title="Link to isUntyped">#</a>
               </h3>
               
               <p>isUntyped reports whether typ is an untyped type.</p>
               
               <pre><code>func isUntyped(typ types2.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="islocalname" data-name="islocalname">
               <h3>
                  islocalname 
                  <span class="badge">function</span>
                  
                  <a href="#islocalname" class="anchor" title="Link to islocalname">#</a>
               </h3>
               
               <p>is this path a local name? begins with ./ or ../ or /</p>
               
               <pre><code>func islocalname(name string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="itab" data-name="itab">
               <h3>
                  itab 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#itab" class="anchor" title="Link to itab">#</a>
               </h3>
               
               <pre><code>func (w *writer) itab(typ types2.Type, iface types2.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="itab" data-name="itab">
               <h3>
                  itab 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#itab" class="anchor" title="Link to itab">#</a>
               </h3>
               
               <p>itab returns a (typ, iface) pair of types.
typRType and ifaceRType are expressions that evaluate to the
*runtime._type for typ and iface, respectively.
If typ is a concrete type and iface is a non-empty interface type,
then itab is an expression that evaluates to the *runtime.itab for
the pair. Otherwise, itab is nil.</p>
               
               <pre><code>func (r *reader) itab(pos src.XPos) (typ *types.Type, typRType ir.Node, iface *types.Type, ifaceRType ir.Node, itab ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="itabIdx" data-name="itabIdx">
               <h3>
                  itabIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#itabIdx" class="anchor" title="Link to itabIdx">#</a>
               </h3>
               
               <p>itabIdx returns the index where the given encoded type pair's
*runtime.itab value appears within this dictionary's itabs section,
adding it if necessary.</p>
               
               <pre><code>func (dict *writerDict) itabIdx(typInfo typeInfo, ifaceInfo typeInfo) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="itabsOffset" data-name="itabsOffset">
               <h3>
                  itabsOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#itabsOffset" class="anchor" title="Link to itabsOffset">#</a>
               </h3>
               
               <p>itabsOffset returns the offset of the runtime dictionary's itabs
section, in words.</p>
               
               <pre><code>func (dict *readerDict) itabsOffset() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="label" data-name="label">
               <h3>
                  label 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#label" class="anchor" title="Link to label">#</a>
               </h3>
               
               <pre><code>func (r *reader) label() *types.Sym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="label" data-name="label">
               <h3>
                  label 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#label" class="anchor" title="Link to label">#</a>
               </h3>
               
               <pre><code>func (w *writer) label(label *syntax.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lastFieldType" data-name="lastFieldType">
               <h3>
                  lastFieldType 
                  <span class="badge">function</span>
                  
                  <a href="#lastFieldType" class="anchor" title="Link to lastFieldType">#</a>
               </h3>
               
               <pre><code>func lastFieldType(fields []*syntax.Field) syntax.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lastNonEmptyStmt" data-name="lastNonEmptyStmt">
               <h3>
                  lastNonEmptyStmt 
                  <span class="badge">function</span>
                  
                  <a href="#lastNonEmptyStmt" class="anchor" title="Link to lastNonEmptyStmt">#</a>
               </h3>
               
               <p>lastNonEmptyStmt returns the last non-empty statement in list, if
any.</p>
               
               <pre><code>func lastNonEmptyStmt(stmts []syntax.Stmt) syntax.Stmt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linkname" data-name="linkname">
               <h3>
                  linkname 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#linkname" class="anchor" title="Link to linkname">#</a>
               </h3>
               
               <pre><code>func (w *writer) linkname(obj types2.Object)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linkname" data-name="linkname">
               <h3>
                  linkname 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#linkname" class="anchor" title="Link to linkname">#</a>
               </h3>
               
               <pre><code>func (r *reader) linkname(name *ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linkname" data-name="linkname">
               <h3>
                  linkname 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#linkname" class="anchor" title="Link to linkname">#</a>
               </h3>
               
               <pre><code>func (l *linker) linkname(w *pkgbits.Encoder, name *ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="localIdent" data-name="localIdent">
               <h3>
                  localIdent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#localIdent" class="anchor" title="Link to localIdent">#</a>
               </h3>
               
               <pre><code>func (r *reader) localIdent() *types.Sym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="localIdent" data-name="localIdent">
               <h3>
                  localIdent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#localIdent" class="anchor" title="Link to localIdent">#</a>
               </h3>
               
               <p>localIdent writes the name of a locally declared object (i.e.,
objects that can only be accessed by non-qualified name, within the
context of a particular function).</p>
               
               <pre><code>func (w *writer) localIdent(obj types2.Object)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupFunction" data-name="lookupFunction">
               <h3>
                  lookupFunction 
                  <span class="badge">function</span>
                  
                  <a href="#lookupFunction" class="anchor" title="Link to lookupFunction">#</a>
               </h3>
               
               <pre><code>func lookupFunction(pkg *types.Pkg, symName string) (*ir.Func, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupMethod" data-name="lookupMethod">
               <h3>
                  lookupMethod 
                  <span class="badge">function</span>
                  
                  <a href="#lookupMethod" class="anchor" title="Link to lookupMethod">#</a>
               </h3>
               
               <pre><code>func lookupMethod(pkg *types.Pkg, symName string) (*ir.Func, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupObj" data-name="lookupObj">
               <h3>
                  lookupObj 
                  <span class="badge">function</span>
                  
                  <a href="#lookupObj" class="anchor" title="Link to lookupObj">#</a>
               </h3>
               
               <p>lookupObj returns the object that expr refers to, if any. If expr
is an explicit instantiation of a generic object, then the instance
object is returned as well.</p>
               
               <pre><code>func lookupObj(p *pkgWriter, expr syntax.Expr) (obj types2.Object, inst types2.Instance)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lsymIdx" data-name="lsymIdx">
               <h3>
                  lsymIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lsymIdx" class="anchor" title="Link to lsymIdx">#</a>
               </h3>
               
               <pre><code>func (l *linker) lsymIdx(w *pkgbits.Encoder, linkname string, lsym *obj.LSym) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeSrcPosBase" data-name="makeSrcPosBase">
               <h3>
                  makeSrcPosBase 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#makeSrcPosBase" class="anchor" title="Link to makeSrcPosBase">#</a>
               </h3>
               
               <p>makeSrcPosBase translates from a *syntax.PosBase to a *src.PosBase.</p>
               
               <pre><code>func (m *posMap) makeSrcPosBase(b0 *syntax.PosBase) *src.PosBase</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeXPos" data-name="makeXPos">
               <h3>
                  makeXPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#makeXPos" class="anchor" title="Link to makeXPos">#</a>
               </h3>
               
               <pre><code>func (m *posMap) makeXPos(pos syntax.Pos) src.XPos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mangle" data-name="mangle">
               <h3>
                  mangle 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mangle" class="anchor" title="Link to mangle">#</a>
               </h3>
               
               <pre><code>func (dict *readerDict) mangle(sym *types.Sym) *types.Sym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maybeTypeAndValue" data-name="maybeTypeAndValue">
               <h3>
                  maybeTypeAndValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maybeTypeAndValue" class="anchor" title="Link to maybeTypeAndValue">#</a>
               </h3>
               
               <pre><code>func (pw *pkgWriter) maybeTypeAndValue(x syntax.Expr) (syntax.TypeAndValue, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="method" data-name="method">
               <h3>
                  method 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#method" class="anchor" title="Link to method">#</a>
               </h3>
               
               <pre><code>func (w *writer) method(wext *writer, meth *types2.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="method" data-name="method">
               <h3>
                  method 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#method" class="anchor" title="Link to method">#</a>
               </h3>
               
               <pre><code>func (r *reader) method(rext *reader) *types.Field</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="methodExpr" data-name="methodExpr">
               <h3>
                  methodExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#methodExpr" class="anchor" title="Link to methodExpr">#</a>
               </h3>
               
               <p>methodExpr writes out a reference to the method selected by
expr. sel should be the corresponding types2.Selection, and recv
the type produced after any implicit addressing, dereferencing, and
field selection. (Note: recv might differ from sel.Obj()'s receiver
parameter in the case of interface types, and is needed for
handling type parameter methods.)</p>
               
               <pre><code>func (w *writer) methodExpr(expr *syntax.SelectorExpr, recv types2.Type, sel *types2.Selection)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="methodExpr" data-name="methodExpr">
               <h3>
                  methodExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#methodExpr" class="anchor" title="Link to methodExpr">#</a>
               </h3>
               
               <p>methodExpr reads a method expression reference, and returns three
(possibly nil) expressions related to it:
baseFn is always non-nil: it's either a function of the appropriate
type already, or it has an extra dictionary parameter as the second
parameter (i.e., immediately after the promoted receiver
parameter).
If dictPtr is non-nil, then it's a dictionary argument that must be
passed as the second argument to baseFn.
If wrapperFn is non-nil, then it's either the same as baseFn (if
dictPtr is nil), or it's semantically equivalent to currying baseFn
to pass dictPtr. (wrapperFn is nil when dictPtr is an expression
that needs to be computed dynamically.)
For callers that are creating a call to the returned method, it's
best to emit a call to baseFn, and include dictPtr in the arguments
list as appropriate.
For callers that want to return a method expression without
invoking it, they may return wrapperFn if it's non-nil; but
otherwise, they need to create their own wrapper.</p>
               
               <pre><code>func (r *reader) methodExpr() (wrapperFn ir.Node, baseFn ir.Node, dictPtr ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="methodExprWrap" data-name="methodExprWrap">
               <h3>
                  methodExprWrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#methodExprWrap" class="anchor" title="Link to methodExprWrap">#</a>
               </h3>
               
               <p>methodExprWrap returns a function literal that changes method's
first parameter's type to recv, and uses implicits/deref/addr to
select the appropriate receiver parameter to pass to method.</p>
               
               <pre><code>func (r *reader) methodExprWrap(origPos src.XPos, recv *types.Type, implicits []int, deref bool, addr bool, method ir.Node, dictPtr ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="methodWrapper" data-name="methodWrapper">
               <h3>
                  methodWrapper 
                  <span class="badge">function</span>
                  
                  <a href="#methodWrapper" class="anchor" title="Link to methodWrapper">#</a>
               </h3>
               
               <pre><code>func methodWrapper(derefs int, tbase *types.Type, method *types.Field, target *ir.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="multiExpr" data-name="multiExpr">
               <h3>
                  multiExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#multiExpr" class="anchor" title="Link to multiExpr">#</a>
               </h3>
               
               <p>multiExpr writes a sequence of expressions, where the i'th value is
implicitly converted to dstType(i). It also handles when exprs is a
single, multi-valued expression (e.g., the multi-valued argument in
an f(g()) call, or the RHS operand in a comma-ok assignment).</p>
               
               <pre><code>func (w *writer) multiExpr(pos poser, dstType func(int) types2.Type, exprs []syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="multiExpr" data-name="multiExpr">
               <h3>
                  multiExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#multiExpr" class="anchor" title="Link to multiExpr">#</a>
               </h3>
               
               <pre><code>func (r *reader) multiExpr() []ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="namedType" data-name="namedType">
               <h3>
                  namedType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#namedType" class="anchor" title="Link to namedType">#</a>
               </h3>
               
               <p>namedType writes a use of the given named type into the bitstream.</p>
               
               <pre><code>func (w *writer) namedType(obj *types2.TypeName, targs *types2.TypeList)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="namesAsExpr" data-name="namesAsExpr">
               <h3>
                  namesAsExpr 
                  <span class="badge">function</span>
                  
                  <a href="#namesAsExpr" class="anchor" title="Link to namesAsExpr">#</a>
               </h3>
               
               <p>namesAsExpr returns a list of names as a syntax.Expr.</p>
               
               <pre><code>func namesAsExpr(names []*syntax.Name) syntax.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="needWrapper" data-name="needWrapper">
               <h3>
                  needWrapper 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#needWrapper" class="anchor" title="Link to needWrapper">#</a>
               </h3>
               
               <p>needWrapper records that wrapper methods may be needed at link
time.</p>
               
               <pre><code>func (r *reader) needWrapper(typ *types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newPkgReader" data-name="newPkgReader">
               <h3>
                  newPkgReader 
                  <span class="badge">function</span>
                  
                  <a href="#newPkgReader" class="anchor" title="Link to newPkgReader">#</a>
               </h3>
               
               <pre><code>func newPkgReader(pr pkgbits.PkgDecoder) *pkgReader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newPkgWriter" data-name="newPkgWriter">
               <h3>
                  newPkgWriter 
                  <span class="badge">function</span>
                  
                  <a href="#newPkgWriter" class="anchor" title="Link to newPkgWriter">#</a>
               </h3>
               
               <p>newPkgWriter returns an initialized pkgWriter for the specified
package.</p>
               
               <pre><code>func newPkgWriter(m posMap, pkg *types2.Package, info *types2.Info, otherInfo map[*syntax.FuncLit]bool) *pkgWriter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newReader" data-name="newReader">
               <h3>
                  newReader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newReader" class="anchor" title="Link to newReader">#</a>
               </h3>
               
               <pre><code>func (pr *pkgReader) newReader(k pkgbits.RelocKind, idx index, marker pkgbits.SyncMarker) *reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newWrapperFunc" data-name="newWrapperFunc">
               <h3>
                  newWrapperFunc 
                  <span class="badge">function</span>
                  
                  <a href="#newWrapperFunc" class="anchor" title="Link to newWrapperFunc">#</a>
               </h3>
               
               <pre><code>func newWrapperFunc(pos src.XPos, sym *types.Sym, wrapper *types.Type, method *types.Field) *ir.Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newWrapperType" data-name="newWrapperType">
               <h3>
                  newWrapperType 
                  <span class="badge">function</span>
                  
                  <a href="#newWrapperType" class="anchor" title="Link to newWrapperType">#</a>
               </h3>
               
               <p>newWrapperType returns a copy of the given signature type, but with
the receiver parameter type substituted with recvType.
If recvType is nil, newWrapperType returns a signature
without a receiver parameter.</p>
               
               <pre><code>func newWrapperType(recvType *types.Type, method *types.Field) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newWriter" data-name="newWriter">
               <h3>
                  newWriter 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newWriter" class="anchor" title="Link to newWriter">#</a>
               </h3>
               
               <pre><code>func (pw *pkgWriter) newWriter(k pkgbits.RelocKind, marker pkgbits.SyncMarker) *writer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="numWords" data-name="numWords">
               <h3>
                  numWords 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#numWords" class="anchor" title="Link to numWords">#</a>
               </h3>
               
               <p>numWords returns the total number of words that comprise dict's
runtime dictionary variable.</p>
               
               <pre><code>func (dict *readerDict) numWords() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="obj" data-name="obj">
               <h3>
                  obj 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#obj" class="anchor" title="Link to obj">#</a>
               </h3>
               
               <p>obj reads an instantiated object reference from the bitstream.</p>
               
               <pre><code>func (r *reader) obj() ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="obj" data-name="obj">
               <h3>
                  obj 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#obj" class="anchor" title="Link to obj">#</a>
               </h3>
               
               <p>obj writes a use of the given object into the bitstream.
If obj is a generic object, then explicits are the explicit type
arguments used to instantiate it (i.e., used to substitute the
object's own declared type parameters).</p>
               
               <pre><code>func (w *writer) obj(obj types2.Object, explicits *types2.TypeList)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="objDict" data-name="objDict">
               <h3>
                  objDict 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#objDict" class="anchor" title="Link to objDict">#</a>
               </h3>
               
               <p>objDict writes the dictionary needed for reading the given object.</p>
               
               <pre><code>func (w *writer) objDict(obj types2.Object, dict *writerDict)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="objDictIdx" data-name="objDictIdx">
               <h3>
                  objDictIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#objDictIdx" class="anchor" title="Link to objDictIdx">#</a>
               </h3>
               
               <p>objDictIdx reads and returns the specified object dictionary.</p>
               
               <pre><code>func (pr *pkgReader) objDictIdx(sym *types.Sym, idx index, implicits []*types.Type, explicits []*types.Type, shaped bool) (*readerDict, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="objDictName" data-name="objDictName">
               <h3>
                  objDictName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#objDictName" class="anchor" title="Link to objDictName">#</a>
               </h3>
               
               <pre><code>func (pr *pkgReader) objDictName(idx index, implicits []*types.Type, explicits []*types.Type) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="objIdx" data-name="objIdx">
               <h3>
                  objIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#objIdx" class="anchor" title="Link to objIdx">#</a>
               </h3>
               
               <p>objIdx returns the specified object, instantiated with the given
type arguments, if any.
If shaped is true, then the shaped variant of the object is returned
instead.</p>
               
               <pre><code>func (pr *pkgReader) objIdx(idx index, implicits []*types.Type, explicits []*types.Type, shaped bool) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="objIdx" data-name="objIdx">
               <h3>
                  objIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#objIdx" class="anchor" title="Link to objIdx">#</a>
               </h3>
               
               <p>objIdx returns the index for the given Object, adding it to the
export data as needed.</p>
               
               <pre><code>func (pw *pkgWriter) objIdx(obj types2.Object) index</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="objIdxMayFail" data-name="objIdxMayFail">
               <h3>
                  objIdxMayFail 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#objIdxMayFail" class="anchor" title="Link to objIdxMayFail">#</a>
               </h3>
               
               <p>objIdxMayFail is equivalent to objIdx, but returns an error rather than
failing the build if this object requires type arguments and the incorrect
number of type arguments were passed.
Other sources of internal failure (such as duplicate definitions) still fail
the build.</p>
               
               <pre><code>func (pr *pkgReader) objIdxMayFail(idx index, implicits []*types.Type, explicits []*types.Type, shaped bool) (ir.Node, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="objInfo" data-name="objInfo">
               <h3>
                  objInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#objInfo" class="anchor" title="Link to objInfo">#</a>
               </h3>
               
               <p>objInfo writes a use of the given encoded object into the
bitstream.</p>
               
               <pre><code>func (w *writer) objInfo(info objInfo)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="objInfo" data-name="objInfo">
               <h3>
                  objInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#objInfo" class="anchor" title="Link to objInfo">#</a>
               </h3>
               
               <p>objInfo reads an instantiated object reference from the bitstream
and returns the encoded reference to it, without instantiating it.</p>
               
               <pre><code>func (r *reader) objInfo() objInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="objInstIdx" data-name="objInstIdx">
               <h3>
                  objInstIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#objInstIdx" class="anchor" title="Link to objInstIdx">#</a>
               </h3>
               
               <p>objInstIdx returns the encoded, instantiated object. If shaped is
true, then the shaped variant of the object is returned instead.</p>
               
               <pre><code>func (pr *pkgReader) objInstIdx(info objInfo, dict *readerDict, shaped bool) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="objInstIdx" data-name="objInstIdx">
               <h3>
                  objInstIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#objInstIdx" class="anchor" title="Link to objInstIdx">#</a>
               </h3>
               
               <p>objInstIdx returns the indices for an object and a corresponding
list of type arguments used to instantiate it, adding them to the
export data as needed.</p>
               
               <pre><code>func (pw *pkgWriter) objInstIdx(obj types2.Object, explicits *types2.TypeList, dict *writerDict) objInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="objTypeParams" data-name="objTypeParams">
               <h3>
                  objTypeParams 
                  <span class="badge">function</span>
                  
                  <a href="#objTypeParams" class="anchor" title="Link to objTypeParams">#</a>
               </h3>
               
               <p>objTypeParams returns the type parameters on the given object.</p>
               
               <pre><code>func objTypeParams(obj types2.Object) *types2.TypeParamList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="op" data-name="op">
               <h3>
                  op 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#op" class="anchor" title="Link to op">#</a>
               </h3>
               
               <p>op writes an Op into the bitstream.</p>
               
               <pre><code>func (w *writer) op(op ir.Op)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="op" data-name="op">
               <h3>
                  op 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#op" class="anchor" title="Link to op">#</a>
               </h3>
               
               <pre><code>func (r *reader) op() ir.Op</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openPackage" data-name="openPackage">
               <h3>
                  openPackage 
                  <span class="badge">function</span>
                  
                  <a href="#openPackage" class="anchor" title="Link to openPackage">#</a>
               </h3>
               
               <pre><code>func openPackage(path string) (*os.File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openScope" data-name="openScope">
               <h3>
                  openScope 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#openScope" class="anchor" title="Link to openScope">#</a>
               </h3>
               
               <pre><code>func (r *reader) openScope()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openScope" data-name="openScope">
               <h3>
                  openScope 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#openScope" class="anchor" title="Link to openScope">#</a>
               </h3>
               
               <pre><code>func (w *writer) openScope(pos syntax.Pos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="optExpr" data-name="optExpr">
               <h3>
                  optExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#optExpr" class="anchor" title="Link to optExpr">#</a>
               </h3>
               
               <pre><code>func (r *reader) optExpr() ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="optExpr" data-name="optExpr">
               <h3>
                  optExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#optExpr" class="anchor" title="Link to optExpr">#</a>
               </h3>
               
               <pre><code>func (w *writer) optExpr(expr syntax.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="optLabel" data-name="optLabel">
               <h3>
                  optLabel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#optLabel" class="anchor" title="Link to optLabel">#</a>
               </h3>
               
               <pre><code>func (w *writer) optLabel(label *syntax.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="optLabel" data-name="optLabel">
               <h3>
                  optLabel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#optLabel" class="anchor" title="Link to optLabel">#</a>
               </h3>
               
               <pre><code>func (r *reader) optLabel() *types.Sym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="origPos" data-name="origPos">
               <h3>
                  origPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#origPos" class="anchor" title="Link to origPos">#</a>
               </h3>
               
               <p>origPos reads a position from the bitstream, and returns both the
original raw position and an inlining-adjusted position.</p>
               
               <pre><code>func (r *reader) origPos() (origPos src.XPos, inlPos src.XPos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="param" data-name="param">
               <h3>
                  param 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#param" class="anchor" title="Link to param">#</a>
               </h3>
               
               <pre><code>func (w *writer) param(param *types2.Var)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="param" data-name="param">
               <h3>
                  param 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#param" class="anchor" title="Link to param">#</a>
               </h3>
               
               <pre><code>func (r *reader) param() *types.Field</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="params" data-name="params">
               <h3>
                  params 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#params" class="anchor" title="Link to params">#</a>
               </h3>
               
               <pre><code>func (w *writer) params(typ *types2.Tuple)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="params" data-name="params">
               <h3>
                  params 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#params" class="anchor" title="Link to params">#</a>
               </h3>
               
               <pre><code>func (r *reader) params() []*types.Field</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseGoEmbed" data-name="parseGoEmbed">
               <h3>
                  parseGoEmbed 
                  <span class="badge">function</span>
                  
                  <a href="#parseGoEmbed" class="anchor" title="Link to parseGoEmbed">#</a>
               </h3>
               
               <p>parseGoEmbed parses the text following "//go:embed" to extract the glob patterns.
It accepts unquoted space-separated patterns as well as double-quoted and back-quoted Go strings.
go/build/read.go also processes these strings and contains similar logic.</p>
               
               <pre><code>func parseGoEmbed(args string) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkg" data-name="pkg">
               <h3>
                  pkg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkg" class="anchor" title="Link to pkg">#</a>
               </h3>
               
               <p>pkg reads a package reference from the bitstream.</p>
               
               <pre><code>func (r *reader) pkg() *types.Pkg</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkg" data-name="pkg">
               <h3>
                  pkg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkg" class="anchor" title="Link to pkg">#</a>
               </h3>
               
               <p>pkg writes a use of the given Package into the element bitstream.</p>
               
               <pre><code>func (w *writer) pkg(pkg *types2.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgDecl" data-name="pkgDecl">
               <h3>
                  pkgDecl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkgDecl" class="anchor" title="Link to pkgDecl">#</a>
               </h3>
               
               <pre><code>func (w *writer) pkgDecl(decl syntax.Decl)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgDecls" data-name="pkgDecls">
               <h3>
                  pkgDecls 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkgDecls" class="anchor" title="Link to pkgDecls">#</a>
               </h3>
               
               <pre><code>func (r *reader) pkgDecls(target *ir.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgIdx" data-name="pkgIdx">
               <h3>
                  pkgIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkgIdx" class="anchor" title="Link to pkgIdx">#</a>
               </h3>
               
               <p>pkgIdx returns the index for the given package, adding it to the
package export data if needed.</p>
               
               <pre><code>func (pw *pkgWriter) pkgIdx(pkg *types2.Package) index</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgIdx" data-name="pkgIdx">
               <h3>
                  pkgIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkgIdx" class="anchor" title="Link to pkgIdx">#</a>
               </h3>
               
               <p>pkgIdx returns the specified package from the export data, reading
it first if needed.</p>
               
               <pre><code>func (pr *pkgReader) pkgIdx(idx index) *types.Pkg</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgInit" data-name="pkgInit">
               <h3>
                  pkgInit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkgInit" class="anchor" title="Link to pkgInit">#</a>
               </h3>
               
               <pre><code>func (w *writer) pkgInit(noders []*noder)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgInit" data-name="pkgInit">
               <h3>
                  pkgInit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkgInit" class="anchor" title="Link to pkgInit">#</a>
               </h3>
               
               <pre><code>func (r *reader) pkgInit(self *types.Pkg, target *ir.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgInitOrder" data-name="pkgInitOrder">
               <h3>
                  pkgInitOrder 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkgInitOrder" class="anchor" title="Link to pkgInitOrder">#</a>
               </h3>
               
               <pre><code>func (w *writer) pkgInitOrder()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgInitOrder" data-name="pkgInitOrder">
               <h3>
                  pkgInitOrder 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkgInitOrder" class="anchor" title="Link to pkgInitOrder">#</a>
               </h3>
               
               <p>pkgInitOrder creates a synthetic init function to handle any
package-scope initialization statements.</p>
               
               <pre><code>func (r *reader) pkgInitOrder(target *ir.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgObjs" data-name="pkgObjs">
               <h3>
                  pkgObjs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkgObjs" class="anchor" title="Link to pkgObjs">#</a>
               </h3>
               
               <pre><code>func (w *writer) pkgObjs(names ...*syntax.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgObjs" data-name="pkgObjs">
               <h3>
                  pkgObjs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkgObjs" class="anchor" title="Link to pkgObjs">#</a>
               </h3>
               
               <pre><code>func (r *reader) pkgObjs(target *ir.Package) []*ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgRef" data-name="pkgRef">
               <h3>
                  pkgRef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkgRef" class="anchor" title="Link to pkgRef">#</a>
               </h3>
               
               <pre><code>func (w *writer) pkgRef(idx index)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pos" data-name="pos">
               <h3>
                  pos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pos" class="anchor" title="Link to pos">#</a>
               </h3>
               
               <p>pos writes the position of p into the element bitstream.</p>
               
               <pre><code>func (w *writer) pos(p poser)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pos" data-name="pos">
               <h3>
                  pos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pos" class="anchor" title="Link to pos">#</a>
               </h3>
               
               <pre><code>func (m *posMap) pos(p poser) src.XPos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pos" data-name="pos">
               <h3>
                  pos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pos" class="anchor" title="Link to pos">#</a>
               </h3>
               
               <p>pos reads a position from the bitstream.</p>
               
               <pre><code>func (r *reader) pos() src.XPos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pos0" data-name="pos0">
               <h3>
                  pos0 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pos0" class="anchor" title="Link to pos0">#</a>
               </h3>
               
               <pre><code>func (r *reader) pos0() src.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="posBase" data-name="posBase">
               <h3>
                  posBase 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#posBase" class="anchor" title="Link to posBase">#</a>
               </h3>
               
               <p>posBase reads a position base from the bitstream.</p>
               
               <pre><code>func (r *reader) posBase() *src.PosBase</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="posBase" data-name="posBase">
               <h3>
                  posBase 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#posBase" class="anchor" title="Link to posBase">#</a>
               </h3>
               
               <p>posBase writes a reference to the given PosBase into the element
bitstream.</p>
               
               <pre><code>func (w *writer) posBase(b *syntax.PosBase)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="posBaseIdx" data-name="posBaseIdx">
               <h3>
                  posBaseIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#posBaseIdx" class="anchor" title="Link to posBaseIdx">#</a>
               </h3>
               
               <p>posBaseIdx returns the index for the given PosBase.</p>
               
               <pre><code>func (pw *pkgWriter) posBaseIdx(b *syntax.PosBase) index</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="posBaseIdx" data-name="posBaseIdx">
               <h3>
                  posBaseIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#posBaseIdx" class="anchor" title="Link to posBaseIdx">#</a>
               </h3>
               
               <p>posBaseIdx returns the specified position base, reading it first if
needed.</p>
               
               <pre><code>func (pr *pkgReader) posBaseIdx(idx index) *src.PosBase</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pragcgo" data-name="pragcgo">
               <h3>
                  pragcgo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pragcgo" class="anchor" title="Link to pragcgo">#</a>
               </h3>
               
               <p>pragcgo is called concurrently if files are parsed concurrently.</p>
               
               <pre><code>func (p *noder) pragcgo(pos syntax.Pos, text string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pragma" data-name="pragma">
               <h3>
                  pragma 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pragma" class="anchor" title="Link to pragma">#</a>
               </h3>
               
               <p>pragma is called concurrently if files are parsed concurrently.</p>
               
               <pre><code>func (p *noder) pragma(pos syntax.Pos, blankLine bool, text string, old syntax.Pragma) syntax.Pragma</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pragmaFields" data-name="pragmaFields">
               <h3>
                  pragmaFields 
                  <span class="badge">function</span>
                  
                  <a href="#pragmaFields" class="anchor" title="Link to pragmaFields">#</a>
               </h3>
               
               <p>pragmaFields is similar to strings.FieldsFunc(s, isSpace)
but does not split when inside double quoted regions and always
splits before the start and after the end of a double quoted region.
pragmaFields does not recognize escaped quotes. If a quote in s is not
closed the part after the opening quote will not be returned as a field.</p>
               
               <pre><code>func pragmaFields(s string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pragmaFlag" data-name="pragmaFlag">
               <h3>
                  pragmaFlag 
                  <span class="badge">function</span>
                  
                  <a href="#pragmaFlag" class="anchor" title="Link to pragmaFlag">#</a>
               </h3>
               
               <pre><code>func pragmaFlag(verb string) ir.PragmaFlag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pragmaFlag" data-name="pragmaFlag">
               <h3>
                  pragmaFlag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pragmaFlag" class="anchor" title="Link to pragmaFlag">#</a>
               </h3>
               
               <pre><code>func (w *writer) pragmaFlag(p ir.PragmaFlag)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pragmaFlag" data-name="pragmaFlag">
               <h3>
                  pragmaFlag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pragmaFlag" class="anchor" title="Link to pragmaFlag">#</a>
               </h3>
               
               <pre><code>func (r *reader) pragmaFlag() ir.PragmaFlag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pragmaFlag" data-name="pragmaFlag">
               <h3>
                  pragmaFlag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pragmaFlag" class="anchor" title="Link to pragmaFlag">#</a>
               </h3>
               
               <pre><code>func (l *linker) pragmaFlag(w *pkgbits.Encoder, pragma ir.PragmaFlag)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="qualifiedIdent" data-name="qualifiedIdent">
               <h3>
                  qualifiedIdent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#qualifiedIdent" class="anchor" title="Link to qualifiedIdent">#</a>
               </h3>
               
               <p>qualifiedIdent writes out the name of an object declared at package
scope. (For now, it's also used to refer to local defined types.)</p>
               
               <pre><code>func (w *writer) qualifiedIdent(obj types2.Object)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="qualifiedIdent" data-name="qualifiedIdent">
               <h3>
                  qualifiedIdent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#qualifiedIdent" class="anchor" title="Link to qualifiedIdent">#</a>
               </h3>
               
               <pre><code>func (r *reader) qualifiedIdent() (pkg *types.Pkg, sym *types.Sym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readBodies" data-name="readBodies">
               <h3>
                  readBodies 
                  <span class="badge">function</span>
                  
                  <a href="#readBodies" class="anchor" title="Link to readBodies">#</a>
               </h3>
               
               <p>readBodies iteratively expands all pending dictionaries and
function bodies.
If duringInlining is true, then the inline.InlineDecls is called as
necessary on instantiations of imported generic functions, so their
inlining costs can be computed.</p>
               
               <pre><code>func readBodies(target *ir.Package, duringInlining bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readExportData" data-name="readExportData">
               <h3>
                  readExportData 
                  <span class="badge">function</span>
                  
                  <a href="#readExportData" class="anchor" title="Link to readExportData">#</a>
               </h3>
               
               <p>readExportData returns the contents of GC-created unified export data.</p>
               
               <pre><code>func readExportData(f *os.File) (data string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readImportFile" data-name="readImportFile">
               <h3>
                  readImportFile 
                  <span class="badge">function</span>
                  
                  <a href="#readImportFile" class="anchor" title="Link to readImportFile">#</a>
               </h3>
               
               <p>readImportFile reads the import file for the given package path and
returns its types.Pkg representation. If packages is non-nil, the
types2.Package representation is also returned.</p>
               
               <pre><code>func readImportFile(path string, target *ir.Package, env *types2.Context, packages map[string]*types2.Package) (pkg1 *types.Pkg, pkg2 *types2.Package, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readPackage" data-name="readPackage">
               <h3>
                  readPackage 
                  <span class="badge">function</span>
                  
                  <a href="#readPackage" class="anchor" title="Link to readPackage">#</a>
               </h3>
               
               <p>readPackage reads package export data from pr to populate
importpkg.
localStub indicates whether pr is reading the stub export data for
the local package, as opposed to relocated export data for an
import.</p>
               
               <pre><code>func readPackage(pr *pkgReader, importpkg *types.Pkg, localStub bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recvBase" data-name="recvBase">
               <h3>
                  recvBase 
                  <span class="badge">function</span>
                  
                  <a href="#recvBase" class="anchor" title="Link to recvBase">#</a>
               </h3>
               
               <p>recvBase returns the base type for the given receiver parameter.</p>
               
               <pre><code>func recvBase(recv *types2.Var) *types2.Named</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recvExpr" data-name="recvExpr">
               <h3>
                  recvExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recvExpr" class="anchor" title="Link to recvExpr">#</a>
               </h3>
               
               <p>recvExpr writes out expr.X, but handles any implicit addressing,
dereferencing, and field selections appropriate for the method
selection.</p>
               
               <pre><code>func (w *writer) recvExpr(expr *syntax.SelectorExpr, sel *types2.Selection) types2.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="relocAll" data-name="relocAll">
               <h3>
                  relocAll 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#relocAll" class="anchor" title="Link to relocAll">#</a>
               </h3>
               
               <p>relocAll ensures that all elements specified by pr and relocs are
copied into the output export data file, and returns the
corresponding indices in the output.</p>
               
               <pre><code>func (l *linker) relocAll(pr *pkgReader, relocs []pkgbits.RelocEnt) []pkgbits.RelocEnt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="relocCommon" data-name="relocCommon">
               <h3>
                  relocCommon 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#relocCommon" class="anchor" title="Link to relocCommon">#</a>
               </h3>
               
               <p>relocCommon copies the specified element from pr into w,
recursively relocating any referenced elements as well.</p>
               
               <pre><code>func (l *linker) relocCommon(pr *pkgReader, w *pkgbits.Encoder, k pkgbits.RelocKind, idx index)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="relocFuncExt" data-name="relocFuncExt">
               <h3>
                  relocFuncExt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#relocFuncExt" class="anchor" title="Link to relocFuncExt">#</a>
               </h3>
               
               <pre><code>func (l *linker) relocFuncExt(w *pkgbits.Encoder, name *ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="relocIdx" data-name="relocIdx">
               <h3>
                  relocIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#relocIdx" class="anchor" title="Link to relocIdx">#</a>
               </h3>
               
               <p>relocIdx ensures a single element is copied into the output export
data file, and returns the corresponding index in the output.</p>
               
               <pre><code>func (l *linker) relocIdx(pr *pkgReader, k pkgbits.RelocKind, idx index) index</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="relocObj" data-name="relocObj">
               <h3>
                  relocObj 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#relocObj" class="anchor" title="Link to relocObj">#</a>
               </h3>
               
               <p>relocObj copies the specified object from pr into the output export
data file, rewriting its compiler-private extension data (e.g.,
adding inlining cost and escape analysis results for functions).</p>
               
               <pre><code>func (l *linker) relocObj(pr *pkgReader, idx index) index</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="relocPkg" data-name="relocPkg">
               <h3>
                  relocPkg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#relocPkg" class="anchor" title="Link to relocPkg">#</a>
               </h3>
               
               <p>relocPkg copies the specified package from pr into the output
export data file, rewriting its import path to match how it was
imported.
TODO(mdempsky): Since CL 391014, we already have the compilation
unit's import path, so there should be no need to rewrite packages
anymore.</p>
               
               <pre><code>func (l *linker) relocPkg(pr *pkgReader, idx index) index</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="relocString" data-name="relocString">
               <h3>
                  relocString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#relocString" class="anchor" title="Link to relocString">#</a>
               </h3>
               
               <p>relocString copies the specified string from pr into the output
export data file, deduplicating it against other strings.</p>
               
               <pre><code>func (l *linker) relocString(pr *pkgReader, idx index) index</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="relocTypeExt" data-name="relocTypeExt">
               <h3>
                  relocTypeExt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#relocTypeExt" class="anchor" title="Link to relocTypeExt">#</a>
               </h3>
               
               <pre><code>func (l *linker) relocTypeExt(w *pkgbits.Encoder, name *ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="relocVarExt" data-name="relocVarExt">
               <h3>
                  relocVarExt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#relocVarExt" class="anchor" title="Link to relocVarExt">#</a>
               </h3>
               
               <pre><code>func (l *linker) relocVarExt(w *pkgbits.Encoder, name *ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveImportPath" data-name="resolveImportPath">
               <h3>
                  resolveImportPath 
                  <span class="badge">function</span>
                  
                  <a href="#resolveImportPath" class="anchor" title="Link to resolveImportPath">#</a>
               </h3>
               
               <p>resolveImportPath resolves an import path as it appears in a Go
source file to the package's full path.</p>
               
               <pre><code>func resolveImportPath(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rttiWord" data-name="rttiWord">
               <h3>
                  rttiWord 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rttiWord" class="anchor" title="Link to rttiWord">#</a>
               </h3>
               
               <p>rttiWord is like dictWord, but converts it to *byte (the type used
internally to represent *runtime._type and *runtime.itab).</p>
               
               <pre><code>func (r *reader) rttiWord(pos src.XPos, idx int) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rtype" data-name="rtype">
               <h3>
                  rtype 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rtype" class="anchor" title="Link to rtype">#</a>
               </h3>
               
               <p>rtype reads a type reference from the element bitstream, and
returns an expression of type *runtime._type representing that
type.</p>
               
               <pre><code>func (r *reader) rtype(pos src.XPos) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rtype" data-name="rtype">
               <h3>
                  rtype 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rtype" class="anchor" title="Link to rtype">#</a>
               </h3>
               
               <p>rtype writes information so that the reader can construct an
expression of type *runtime._type representing typ.</p>
               
               <pre><code>func (w *writer) rtype(typ types2.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rtype0" data-name="rtype0">
               <h3>
                  rtype0 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rtype0" class="anchor" title="Link to rtype0">#</a>
               </h3>
               
               <pre><code>func (r *reader) rtype0(pos src.XPos) (typ *types.Type, rtype ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rtypeIdx" data-name="rtypeIdx">
               <h3>
                  rtypeIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rtypeIdx" class="anchor" title="Link to rtypeIdx">#</a>
               </h3>
               
               <p>rtypeIdx returns the index where the given encoded type's
*runtime._type value appears within this dictionary's rtypes
section, adding it if necessary.</p>
               
               <pre><code>func (dict *writerDict) rtypeIdx(newInfo typeInfo) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rtypeInfo" data-name="rtypeInfo">
               <h3>
                  rtypeInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rtypeInfo" class="anchor" title="Link to rtypeInfo">#</a>
               </h3>
               
               <pre><code>func (w *writer) rtypeInfo(info typeInfo)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rtypesOffset" data-name="rtypesOffset">
               <h3>
                  rtypesOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rtypesOffset" class="anchor" title="Link to rtypesOffset">#</a>
               </h3>
               
               <p>rtypesOffset returns the offset of the runtime dictionary's rtypes
section, in words.</p>
               
               <pre><code>func (dict *readerDict) rtypesOffset() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="safeArg" data-name="safeArg">
               <h3>
                  safeArg 
                  <span class="badge">function</span>
                  
                  <a href="#safeArg" class="anchor" title="Link to safeArg">#</a>
               </h3>
               
               <p>safeArg reports whether arg is a "safe" command-line argument,
meaning that when it appears in a command-line, it probably
doesn't have some special meaning other than its own name.
This is copied from SafeArg in cmd/go/internal/load/pkg.go.</p>
               
               <pre><code>func safeArg(name string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="selectStmt" data-name="selectStmt">
               <h3>
                  selectStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#selectStmt" class="anchor" title="Link to selectStmt">#</a>
               </h3>
               
               <pre><code>func (r *reader) selectStmt(label *types.Sym) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="selectStmt" data-name="selectStmt">
               <h3>
                  selectStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#selectStmt" class="anchor" title="Link to selectStmt">#</a>
               </h3>
               
               <pre><code>func (w *writer) selectStmt(stmt *syntax.SelectStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="selector" data-name="selector">
               <h3>
                  selector 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#selector" class="anchor" title="Link to selector">#</a>
               </h3>
               
               <pre><code>func (r *reader) selector() *types.Sym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="selector" data-name="selector">
               <h3>
                  selector 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#selector" class="anchor" title="Link to selector">#</a>
               </h3>
               
               <p>selector writes the name of a field or method (i.e., objects that
can only be accessed using selector expressions).</p>
               
               <pre><code>func (w *writer) selector(obj types2.Object)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="selectorIdx" data-name="selectorIdx">
               <h3>
                  selectorIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#selectorIdx" class="anchor" title="Link to selectorIdx">#</a>
               </h3>
               
               <pre><code>func (pw *pkgWriter) selectorIdx(obj types2.Object) selectorInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="selectorInfo" data-name="selectorInfo">
               <h3>
                  selectorInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#selectorInfo" class="anchor" title="Link to selectorInfo">#</a>
               </h3>
               
               <pre><code>func (w *writer) selectorInfo(info selectorInfo)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setBasePos" data-name="setBasePos">
               <h3>
                  setBasePos 
                  <span class="badge">function</span>
                  
                  <a href="#setBasePos" class="anchor" title="Link to setBasePos">#</a>
               </h3>
               
               <pre><code>func setBasePos(pos src.XPos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setType" data-name="setType">
               <h3>
                  setType 
                  <span class="badge">function</span>
                  
                  <a href="#setType" class="anchor" title="Link to setType">#</a>
               </h3>
               
               <pre><code>func setType(n ir.Node, typ *types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setValue" data-name="setValue">
               <h3>
                  setValue 
                  <span class="badge">function</span>
                  
                  <a href="#setValue" class="anchor" title="Link to setValue">#</a>
               </h3>
               
               <pre><code>func setValue(name *ir.Name, val constant.Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shapeSig" data-name="shapeSig">
               <h3>
                  shapeSig 
                  <span class="badge">function</span>
                  
                  <a href="#shapeSig" class="anchor" title="Link to shapeSig">#</a>
               </h3>
               
               <p>shapeSig returns a copy of fn's signature, except adding a
dictionary parameter and promoting the receiver parameter (if any)
to a normal parameter.
The parameter types.Fields are all copied too, so their Nname
fields can be initialized for use by the shape function.</p>
               
               <pre><code>func shapeSig(fn *ir.Func, dict *readerDict) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shapedMethodExpr" data-name="shapedMethodExpr">
               <h3>
                  shapedMethodExpr 
                  <span class="badge">function</span>
                  
                  <a href="#shapedMethodExpr" class="anchor" title="Link to shapedMethodExpr">#</a>
               </h3>
               
               <p>shapedMethodExpr returns the specified method on the given shaped
type.</p>
               
               <pre><code>func shapedMethodExpr(pos src.XPos, obj *ir.Name, sym *types.Sym) *ir.SelectorExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shapify" data-name="shapify">
               <h3>
                  shapify 
                  <span class="badge">function</span>
                  
                  <a href="#shapify" class="anchor" title="Link to shapify">#</a>
               </h3>
               
               <p>shapify returns the shape type for targ.
If basic is true, then the type argument is used to instantiate a
type parameter whose constraint is a basic interface.</p>
               
               <pre><code>func shapify(targ *types.Type, basic bool) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="signature" data-name="signature">
               <h3>
                  signature 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#signature" class="anchor" title="Link to signature">#</a>
               </h3>
               
               <pre><code>func (w *writer) signature(sig *types2.Signature)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="signature" data-name="signature">
               <h3>
                  signature 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#signature" class="anchor" title="Link to signature">#</a>
               </h3>
               
               <pre><code>func (r *reader) signature(recv *types.Field) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sliceElem" data-name="sliceElem">
               <h3>
                  sliceElem 
                  <span class="badge">function</span>
                  
                  <a href="#sliceElem" class="anchor" title="Link to sliceElem">#</a>
               </h3>
               
               <pre><code>func sliceElem(typ types2.Type) types2.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitAlias" data-name="splitAlias">
               <h3>
                  splitAlias 
                  <span class="badge">function</span>
                  
                  <a href="#splitAlias" class="anchor" title="Link to splitAlias">#</a>
               </h3>
               
               <p>splitAlias is like splitNamed, but for an alias type.</p>
               
               <pre><code>func splitAlias(typ *types2.Alias) (*types2.TypeName, *types2.TypeList)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitNamed" data-name="splitNamed">
               <h3>
                  splitNamed 
                  <span class="badge">function</span>
                  
                  <a href="#splitNamed" class="anchor" title="Link to splitNamed">#</a>
               </h3>
               
               <p>splitNamed decomposes a use of a defined type into its original
type definition and the type arguments used to instantiate it.</p>
               
               <pre><code>func splitNamed(typ *types2.Named) (*types2.TypeName, *types2.TypeList)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="staticBool" data-name="staticBool">
               <h3>
                  staticBool 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#staticBool" class="anchor" title="Link to staticBool">#</a>
               </h3>
               
               <p>staticBool analyzes a boolean expression and reports whether it's
always true (positive result), always false (negative result), or
unknown (zero).
It also simplifies the expression while preserving semantics, if
possible.</p>
               
               <pre><code>func (pw *pkgWriter) staticBool(ep *syntax.Expr) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmt" data-name="stmt">
               <h3>
                  stmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmt" class="anchor" title="Link to stmt">#</a>
               </h3>
               
               <p>stmt writes the given statement into the function body bitstream.</p>
               
               <pre><code>func (w *writer) stmt(stmt syntax.Stmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmt" data-name="stmt">
               <h3>
                  stmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmt" class="anchor" title="Link to stmt">#</a>
               </h3>
               
               <pre><code>func (r *reader) stmt() ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmt1" data-name="stmt1">
               <h3>
                  stmt1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmt1" class="anchor" title="Link to stmt1">#</a>
               </h3>
               
               <pre><code>func (w *writer) stmt1(stmt syntax.Stmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmt1" data-name="stmt1">
               <h3>
                  stmt1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmt1" class="anchor" title="Link to stmt1">#</a>
               </h3>
               
               <pre><code>func (r *reader) stmt1(tag codeStmt, out *ir.Nodes) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmts" data-name="stmts">
               <h3>
                  stmts 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmts" class="anchor" title="Link to stmts">#</a>
               </h3>
               
               <pre><code>func (r *reader) stmts() ir.Nodes</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmts" data-name="stmts">
               <h3>
                  stmts 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmts" class="anchor" title="Link to stmts">#</a>
               </h3>
               
               <pre><code>func (w *writer) stmts(stmts []syntax.Stmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="structType" data-name="structType">
               <h3>
                  structType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#structType" class="anchor" title="Link to structType">#</a>
               </h3>
               
               <pre><code>func (r *reader) structType() *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="structType" data-name="structType">
               <h3>
                  structType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#structType" class="anchor" title="Link to structType">#</a>
               </h3>
               
               <pre><code>func (w *writer) structType(typ *types2.Struct)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subdictIdx" data-name="subdictIdx">
               <h3>
                  subdictIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#subdictIdx" class="anchor" title="Link to subdictIdx">#</a>
               </h3>
               
               <p>subdictIdx returns the index where the given encoded object's
runtime dictionary appears within this dictionary's subdictionary
section, adding it if necessary.</p>
               
               <pre><code>func (dict *writerDict) subdictIdx(newInfo objInfo) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subdictsOffset" data-name="subdictsOffset">
               <h3>
                  subdictsOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#subdictsOffset" class="anchor" title="Link to subdictsOffset">#</a>
               </h3>
               
               <p>subdictsOffset returns the offset of the runtime dictionary's
subdictionary section, in words.</p>
               
               <pre><code>func (dict *readerDict) subdictsOffset() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="switchStmt" data-name="switchStmt">
               <h3>
                  switchStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#switchStmt" class="anchor" title="Link to switchStmt">#</a>
               </h3>
               
               <pre><code>func (w *writer) switchStmt(stmt *syntax.SwitchStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="switchStmt" data-name="switchStmt">
               <h3>
                  switchStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#switchStmt" class="anchor" title="Link to switchStmt">#</a>
               </h3>
               
               <pre><code>func (r *reader) switchStmt(label *types.Sym) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="syntheticArgs" data-name="syntheticArgs">
               <h3>
                  syntheticArgs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#syntheticArgs" class="anchor" title="Link to syntheticArgs">#</a>
               </h3>
               
               <p>syntheticArgs returns the recvs and params arguments passed to the
current function.</p>
               
               <pre><code>func (r *reader) syntheticArgs() ir.Nodes</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="syntheticBody" data-name="syntheticBody">
               <h3>
                  syntheticBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#syntheticBody" class="anchor" title="Link to syntheticBody">#</a>
               </h3>
               
               <p>syntheticBody adds a synthetic body to r.curfn if appropriate, and
reports whether it did.</p>
               
               <pre><code>func (r *reader) syntheticBody(pos src.XPos) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="syntheticClosure" data-name="syntheticClosure">
               <h3>
                  syntheticClosure 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#syntheticClosure" class="anchor" title="Link to syntheticClosure">#</a>
               </h3>
               
               <p>syntheticClosure constructs a synthetic function literal for
currying dictionary arguments. origPos is the position used for the
closure, which must be a non-inlined position. typ is the function
literal's signature type.
captures is a list of expressions that need to be evaluated at the
point of function literal evaluation and captured by the function
literal. If ifaceHack is true and captures[1] is an interface type,
it's checked to be non-nil after evaluation.
addBody is a callback function to populate the function body. The
list of captured values passed back has the captured variables for
use within the function literal, corresponding to the expressions
in captures.</p>
               
               <pre><code>func (r *reader) syntheticClosure(origPos src.XPos, typ *types.Type, ifaceHack bool, captures ir.Nodes, addBody func(pos src.XPos, r *reader, captured []ir.Node)) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="syntheticSig" data-name="syntheticSig">
               <h3>
                  syntheticSig 
                  <span class="badge">function</span>
                  
                  <a href="#syntheticSig" class="anchor" title="Link to syntheticSig">#</a>
               </h3>
               
               <p>syntheticSig duplicates and returns the params and results lists
for sig, but renaming anonymous parameters so they can be assigned
ir.Names.</p>
               
               <pre><code>func syntheticSig(sig *types.Type) (params []*types.Field, results []*types.Field)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="syntheticTailCall" data-name="syntheticTailCall">
               <h3>
                  syntheticTailCall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#syntheticTailCall" class="anchor" title="Link to syntheticTailCall">#</a>
               </h3>
               
               <p>syntheticTailCall emits a tail call to fn, passing the given
arguments list.</p>
               
               <pre><code>func (r *reader) syntheticTailCall(pos src.XPos, fn ir.Node, args ir.Nodes)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="temp" data-name="temp">
               <h3>
                  temp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#temp" class="anchor" title="Link to temp">#</a>
               </h3>
               
               <p>temp returns a new autotemp of the specified type.</p>
               
               <pre><code>func (r *reader) temp(pos src.XPos, typ *types.Type) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tempCopy" data-name="tempCopy">
               <h3>
                  tempCopy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tempCopy" class="anchor" title="Link to tempCopy">#</a>
               </h3>
               
               <p>tempCopy declares and returns a new autotemp initialized to the
value of expr.</p>
               
               <pre><code>func (r *reader) tempCopy(pos src.XPos, expr ir.Node, init *ir.Nodes) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="terminates" data-name="terminates">
               <h3>
                  terminates 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#terminates" class="anchor" title="Link to terminates">#</a>
               </h3>
               
               <p>terminates reports whether stmt terminates normal control flow
(i.e., does not merely advance to the following statement).</p>
               
               <pre><code>func (pw *pkgWriter) terminates(stmt syntax.Stmt) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimFilename" data-name="trimFilename">
               <h3>
                  trimFilename 
                  <span class="badge">function</span>
                  
                  <a href="#trimFilename" class="anchor" title="Link to trimFilename">#</a>
               </h3>
               
               <p>trimFilename returns the "trimmed" filename of b, which is the
absolute filename after applying -trimpath processing. This
filename form is suitable for use in object files and export data.
If b's filename has already been trimmed (i.e., because it was read
in from an imported package's export data), then the filename is
returned unchanged.</p>
               
               <pre><code>func trimFilename(b *syntax.PosBase) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typ" data-name="typ">
               <h3>
                  typ 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typ" class="anchor" title="Link to typ">#</a>
               </h3>
               
               <p>typ writes a use of the given type into the bitstream.</p>
               
               <pre><code>func (w *writer) typ(typ types2.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typ" data-name="typ">
               <h3>
                  typ 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typ" class="anchor" title="Link to typ">#</a>
               </h3>
               
               <pre><code>func (r *reader) typ() *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typIdx" data-name="typIdx">
               <h3>
                  typIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typIdx" class="anchor" title="Link to typIdx">#</a>
               </h3>
               
               <p>typIdx returns the specified type. If info specifies a derived
type, it's resolved within the given dictionary. If wrapped is
true, then method wrappers will be generated, if appropriate.</p>
               
               <pre><code>func (pr *pkgReader) typIdx(info typeInfo, dict *readerDict, wrapped bool) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typIdx" data-name="typIdx">
               <h3>
                  typIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typIdx" class="anchor" title="Link to typIdx">#</a>
               </h3>
               
               <p>typIdx returns the index where the export data description of type
can be read back in. If no such index exists yet, it's created.
typIdx also reports whether typ is a derived type; that is, whether
its identity depends on type parameters.</p>
               
               <pre><code>func (pw *pkgWriter) typIdx(typ types2.Type, dict *writerDict) typeInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typInfo" data-name="typInfo">
               <h3>
                  typInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typInfo" class="anchor" title="Link to typInfo">#</a>
               </h3>
               
               <pre><code>func (r *reader) typInfo() typeInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typInfo" data-name="typInfo">
               <h3>
                  typInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typInfo" class="anchor" title="Link to typInfo">#</a>
               </h3>
               
               <p>typInfo writes a use of the given type (specified as a typeInfo
instead) into the bitstream.</p>
               
               <pre><code>func (w *writer) typInfo(info typeInfo)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typListIdx" data-name="typListIdx">
               <h3>
                  typListIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typListIdx" class="anchor" title="Link to typListIdx">#</a>
               </h3>
               
               <p>typListIdx returns a list of the specified types, resolving derived
types within the given dictionary.</p>
               
               <pre><code>func (pr *pkgReader) typListIdx(infos []typeInfo, dict *readerDict) []*types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typWrapped" data-name="typWrapped">
               <h3>
                  typWrapped 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typWrapped" class="anchor" title="Link to typWrapped">#</a>
               </h3>
               
               <p>typWrapped is like typ, but allows suppressing generation of
unnecessary wrappers as a compile-time optimization.</p>
               
               <pre><code>func (r *reader) typWrapped(wrapped bool) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeAndValue" data-name="typeAndValue">
               <h3>
                  typeAndValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeAndValue" class="anchor" title="Link to typeAndValue">#</a>
               </h3>
               
               <pre><code>func (pw *pkgWriter) typeAndValue(x syntax.Expr) syntax.TypeAndValue</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeExprEndPos" data-name="typeExprEndPos">
               <h3>
                  typeExprEndPos 
                  <span class="badge">function</span>
                  
                  <a href="#typeExprEndPos" class="anchor" title="Link to typeExprEndPos">#</a>
               </h3>
               
               <p>typeExprEndPos returns the position that noder would leave base.Pos
after parsing the given type expression.
Deprecated: This function exists to emulate position semantics from
Go 1.17, necessary for compatibility with the backend DWARF
generation logic that assigns variables to their appropriate scope.</p>
               
               <pre><code>func typeExprEndPos(expr0 syntax.Expr) syntax.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeExt" data-name="typeExt">
               <h3>
                  typeExt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeExt" class="anchor" title="Link to typeExt">#</a>
               </h3>
               
               <pre><code>func (w *writer) typeExt(obj *types2.TypeName)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeExt" data-name="typeExt">
               <h3>
                  typeExt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeExt" class="anchor" title="Link to typeExt">#</a>
               </h3>
               
               <pre><code>func (r *reader) typeExt(name *ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeOf" data-name="typeOf">
               <h3>
                  typeOf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeOf" class="anchor" title="Link to typeOf">#</a>
               </h3>
               
               <p>typeOf returns the Type of the given value expression.</p>
               
               <pre><code>func (pw *pkgWriter) typeOf(expr syntax.Expr) types2.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeParamIndex" data-name="typeParamIndex">
               <h3>
                  typeParamIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeParamIndex" class="anchor" title="Link to typeParamIndex">#</a>
               </h3>
               
               <p>typeParamIndex returns the index of the given type parameter within
the dictionary. This may differ from typ.Index() when there are
implicit type parameters due to defined types declared within a
generic function or method.</p>
               
               <pre><code>func (dict *writerDict) typeParamIndex(typ *types2.TypeParam) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeParamMethodExprIdx" data-name="typeParamMethodExprIdx">
               <h3>
                  typeParamMethodExprIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeParamMethodExprIdx" class="anchor" title="Link to typeParamMethodExprIdx">#</a>
               </h3>
               
               <p>typeParamMethodExprIdx returns the index where the given encoded
method expression function pointer appears within this dictionary's
type parameters method expressions section, adding it if necessary.</p>
               
               <pre><code>func (dict *writerDict) typeParamMethodExprIdx(typeParamIdx int, methodInfo selectorInfo) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeParamMethodExprsOffset" data-name="typeParamMethodExprsOffset">
               <h3>
                  typeParamMethodExprsOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeParamMethodExprsOffset" class="anchor" title="Link to typeParamMethodExprsOffset">#</a>
               </h3>
               
               <p>typeParamMethodExprsOffset returns the offset of the runtime
dictionary's type parameter method expressions section, in words.</p>
               
               <pre><code>func (dict *readerDict) typeParamMethodExprsOffset() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeParamNames" data-name="typeParamNames">
               <h3>
                  typeParamNames 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeParamNames" class="anchor" title="Link to typeParamNames">#</a>
               </h3>
               
               <pre><code>func (r *reader) typeParamNames()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeParamNames" data-name="typeParamNames">
               <h3>
                  typeParamNames 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeParamNames" class="anchor" title="Link to typeParamNames">#</a>
               </h3>
               
               <pre><code>func (w *writer) typeParamNames(tparams *types2.TypeParamList)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typed" data-name="typed">
               <h3>
                  typed 
                  <span class="badge">function</span>
                  
                  <a href="#typed" class="anchor" title="Link to typed">#</a>
               </h3>
               
               <p>typed returns n after setting its type to typ.</p>
               
               <pre><code>func typed(typ *types.Type, n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unexpected" data-name="unexpected">
               <h3>
                  unexpected 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unexpected" class="anchor" title="Link to unexpected">#</a>
               </h3>
               
               <p>unexpected reports a fatal error about a thing of unexpected
dynamic type.</p>
               
               <pre><code>func (pw *pkgWriter) unexpected(what string, p poser)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unified" data-name="unified">
               <h3>
                  unified 
                  <span class="badge">function</span>
                  
                  <a href="#unified" class="anchor" title="Link to unified">#</a>
               </h3>
               
               <p>unified constructs the local package's Internal Representation (IR)
from its syntax tree (AST).
The pipeline contains 2 steps:
1. Generate the export data "stub".
2. Generate the IR from the export data above.
The package data "stub" at step (1) contains everything from the local package,
but nothing that has been imported. When we're actually writing out export data
to the output files (see writeNewExport), we run the "linker", which:
- Updates compiler extensions data (e.g. inlining cost, escape analysis results).
- Handles re-exporting any transitive dependencies.
- Prunes out any unnecessary details (e.g. non-inlineable functions, because any
downstream importers only care about inlinable functions).
The source files are typechecked twice: once before writing the export data
using types2, and again after reading the export data using gc/typecheck.
The duplication of work will go away once we only use the types2 type checker,
removing the gc/typecheck step. For now, it is kept because:
- It reduces the engineering costs in maintaining a fork of typecheck
(e.g. no need to backport fixes like CL 327651).
- It makes it easier to pass toolstash -cmp.
- Historically, we would always re-run the typechecker after importing a package,
even though we know the imported data is valid. It's not ideal, but it's
not causing any problems either.
- gc/typecheck is still in charge of some transformations, such as rewriting
multi-valued function calls or transforming ir.OINDEX to ir.OINDEXMAP.
Using the syntax tree with types2, which has a complete representation of generics,
the unified IR has the full typed AST needed for introspection during step (1).
In other words, we have all the necessary information to build the generic IR form
(see writer.captureVars for an example).</p>
               
               <pre><code>func unified(m posMap, noders []*noder)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unifiedHaveInlineBody" data-name="unifiedHaveInlineBody">
               <h3>
                  unifiedHaveInlineBody 
                  <span class="badge">function</span>
                  
                  <a href="#unifiedHaveInlineBody" class="anchor" title="Link to unifiedHaveInlineBody">#</a>
               </h3>
               
               <p>unifiedHaveInlineBody reports whether we have the function body for
fn, so we can inline it.</p>
               
               <pre><code>func unifiedHaveInlineBody(fn *ir.Func) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unifiedInlineCall" data-name="unifiedInlineCall">
               <h3>
                  unifiedInlineCall 
                  <span class="badge">function</span>
                  
                  <a href="#unifiedInlineCall" class="anchor" title="Link to unifiedInlineCall">#</a>
               </h3>
               
               <p>unifiedInlineCall implements inline.NewInline by re-reading the function
body from its Unified IR export data.</p>
               
               <pre><code>func unifiedInlineCall(callerfn *ir.Func, call *ir.CallExpr, fn *ir.Func, inlIndex int) *ir.InlinedCallExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unionType" data-name="unionType">
               <h3>
                  unionType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unionType" class="anchor" title="Link to unionType">#</a>
               </h3>
               
               <pre><code>func (w *writer) unionType(typ *types2.Union)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unionType" data-name="unionType">
               <h3>
                  unionType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unionType" class="anchor" title="Link to unionType">#</a>
               </h3>
               
               <pre><code>func (r *reader) unionType() *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="useLocal" data-name="useLocal">
               <h3>
                  useLocal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#useLocal" class="anchor" title="Link to useLocal">#</a>
               </h3>
               
               <p>useLocal writes a reference to the given local or free variable
into the bitstream.</p>
               
               <pre><code>func (w *writer) useLocal(pos syntax.Pos, obj *types2.Var)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="useLocal" data-name="useLocal">
               <h3>
                  useLocal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#useLocal" class="anchor" title="Link to useLocal">#</a>
               </h3>
               
               <pre><code>func (r *reader) useLocal() *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="usedLocals" data-name="usedLocals">
               <h3>
                  usedLocals 
                  <span class="badge">function</span>
                  
                  <a href="#usedLocals" class="anchor" title="Link to usedLocals">#</a>
               </h3>
               
               <p>usedLocals returns a set of local variables that are used within body.</p>
               
               <pre><code>func usedLocals(body []ir.Node) ir.NameSet</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="varDictIndex" data-name="varDictIndex">
               <h3>
                  varDictIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#varDictIndex" class="anchor" title="Link to varDictIndex">#</a>
               </h3>
               
               <p>varDictIndex writes out information for populating DictIndex for
the ir.Name that will represent obj.</p>
               
               <pre><code>func (w *writer) varDictIndex(obj *types2.Var)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="varDictIndex" data-name="varDictIndex">
               <h3>
                  varDictIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#varDictIndex" class="anchor" title="Link to varDictIndex">#</a>
               </h3>
               
               <p>varDictIndex populates name.DictIndex if name is a derived type.</p>
               
               <pre><code>func (r *reader) varDictIndex(name *ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="varExt" data-name="varExt">
               <h3>
                  varExt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#varExt" class="anchor" title="Link to varExt">#</a>
               </h3>
               
               <pre><code>func (r *reader) varExt(name *ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="varExt" data-name="varExt">
               <h3>
                  varExt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#varExt" class="anchor" title="Link to varExt">#</a>
               </h3>
               
               <pre><code>func (w *writer) varExt(obj *types2.Var)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="varType" data-name="varType">
               <h3>
                  varType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#varType" class="anchor" title="Link to varType">#</a>
               </h3>
               
               <p>varType returns the type of dict's runtime dictionary variable.</p>
               
               <pre><code>func (dict *readerDict) varType() *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="visit" data-name="visit">
               <h3>
                  visit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#visit" class="anchor" title="Link to visit">#</a>
               </h3>
               
               <p>visit recursively walks typ0 to check any referenced interface types.</p>
               
               <pre><code>func (f *cycleFinder) visit(typ0 types2.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="withTParams" data-name="withTParams">
               <h3>
                  withTParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#withTParams" class="anchor" title="Link to withTParams">#</a>
               </h3>
               
               <pre><code>func (c *declCollector) withTParams(obj types2.Object) *declCollector</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wrapMethodValue" data-name="wrapMethodValue">
               <h3>
                  wrapMethodValue 
                  <span class="badge">function</span>
                  
                  <a href="#wrapMethodValue" class="anchor" title="Link to wrapMethodValue">#</a>
               </h3>
               
               <pre><code>func wrapMethodValue(recvType *types.Type, method *types.Field, target *ir.Package, needed bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wrapType" data-name="wrapType">
               <h3>
                  wrapType 
                  <span class="badge">function</span>
                  
                  <a href="#wrapType" class="anchor" title="Link to wrapType">#</a>
               </h3>
               
               <pre><code>func wrapType(typ *types.Type, target *ir.Package, seen map[string]*types.Type, needed bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writePkgStub" data-name="writePkgStub">
               <h3>
                  writePkgStub 
                  <span class="badge">function</span>
                  
                  <a href="#writePkgStub" class="anchor" title="Link to writePkgStub">#</a>
               </h3>
               
               <p>writePkgStub type checks the given parsed source files,
writes an export data package stub representing them,
and returns the result.</p>
               
               <pre><code>func writePkgStub(m posMap, noders []*noder) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeUnifiedExport" data-name="writeUnifiedExport">
               <h3>
                  writeUnifiedExport 
                  <span class="badge">function</span>
                  
                  <a href="#writeUnifiedExport" class="anchor" title="Link to writeUnifiedExport">#</a>
               </h3>
               
               <p>writeUnifiedExport writes to `out` the finalized, self-contained
Unified IR export data file for the current compilation unit.</p>
               
               <pre><code>func writeUnifiedExport(out io.Writer)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>