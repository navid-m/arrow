<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - typecheck</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="cmd_compile_internal_typecheck__builtin-docs.html">_builtin</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>typecheck</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/internal/obj"
"fmt"
"go/constant"
"go/token"
"math"
"math/big"
"unicode"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"fmt"
"sync"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/internal/src"
"fmt"
"slices"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/src"
"fmt"
"go/constant"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/internal/src"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/internal/src"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/internal/src"
"fmt"
"go/constant"
"go/token"
"strings"
"go/constant"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/internal/src"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/internal/src"
"internal/types/errors"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/internal/src"
"fmt"
"go/constant"
"go/token"
"internal/types/errors"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/internal/src"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="HaveInlineBody" data-name="HaveInlineBody">
               <h3>
                  HaveInlineBody 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#HaveInlineBody" class="anchor" title="Link to HaveInlineBody">#</a>
               </h3>
               
               <p>HaveInlineBody reports whether we have fn's inline body available
for inlining.
It's a function literal so that it can be overridden for
GOEXPERIMENT=unified.</p>
               
               <pre><code>var HaveInlineBody = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="LocalDictName" data-name="LocalDictName">
               <h3>
                  LocalDictName 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#LocalDictName" class="anchor" title="Link to LocalDictName">#</a>
               </h3>
               
               <p>The name used for dictionary parameters or local variables.</p>
               
               <pre><code>const LocalDictName = ".dict"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Target" data-name="Target">
               <h3>
                  Target 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Target" class="anchor" title="Link to Target">#</a>
               </h3>
               
               <p>Target is the package being compiled.</p>
               
               <pre><code>var Target *ir.Package</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_typekind" data-name="_typekind">
               <h3>
                  _typekind 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_typekind" class="anchor" title="Link to _typekind">#</a>
               </h3>
               
               <pre><code>var _typekind = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="autotmpnames" data-name="autotmpnames">
               <h3>
                  autotmpnames 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#autotmpnames" class="anchor" title="Link to autotmpnames">#</a>
               </h3>
               
               <pre><code>var autotmpnames []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="autotmpnamesmu" data-name="autotmpnamesmu">
               <h3>
                  autotmpnamesmu 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#autotmpnamesmu" class="anchor" title="Link to autotmpnamesmu">#</a>
               </h3>
               
               <pre><code>var autotmpnamesmu sync.Mutex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="blankMarker" data-name="blankMarker">
               <h3>
                  blankMarker 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#blankMarker" class="anchor" title="Link to blankMarker">#</a>
               </h3>
               
               <pre><code>const blankMarker = "$"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="builtinFuncs" data-name="builtinFuncs">
               <h3>
                  builtinFuncs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#builtinFuncs" class="anchor" title="Link to builtinFuncs">#</a>
               </h3>
               
               <pre><code>var builtinFuncs = [...]struct{...}{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="constTag" data-name="constTag">
               <h3>
                  constTag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#constTag" class="anchor" title="Link to constTag">#</a>
               </h3>
               
               <p>Tags. Must be < 0.</p>
               
               <pre><code>const constTag</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="coverageDecls" data-name="coverageDecls">
               <h3>
                  coverageDecls 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#coverageDecls" class="anchor" title="Link to coverageDecls">#</a>
               </h3>
               
               <pre><code>var coverageDecls = [...]struct{...}{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxAssign" data-name="ctxAssign">
               <h3>
                  ctxAssign 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxAssign" class="anchor" title="Link to ctxAssign">#</a>
               </h3>
               
               <pre><code>const ctxAssign</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxCallee" data-name="ctxCallee">
               <h3>
                  ctxCallee 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxCallee" class="anchor" title="Link to ctxCallee">#</a>
               </h3>
               
               <pre><code>const ctxCallee</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxExpr" data-name="ctxExpr">
               <h3>
                  ctxExpr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxExpr" class="anchor" title="Link to ctxExpr">#</a>
               </h3>
               
               <pre><code>const ctxExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxMultiOK" data-name="ctxMultiOK">
               <h3>
                  ctxMultiOK 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxMultiOK" class="anchor" title="Link to ctxMultiOK">#</a>
               </h3>
               
               <pre><code>const ctxMultiOK</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxStmt" data-name="ctxStmt">
               <h3>
                  ctxStmt 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxStmt" class="anchor" title="Link to ctxStmt">#</a>
               </h3>
               
               <pre><code>const ctxStmt = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctxType" data-name="ctxType">
               <h3>
                  ctxType 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctxType" class="anchor" title="Link to ctxType">#</a>
               </h3>
               
               <pre><code>const ctxType</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dotlist" data-name="dotlist">
               <h3>
                  dotlist 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dotlist" class="anchor" title="Link to dotlist">#</a>
               </h3>
               
               <p>dotlist is used by adddot1 to record the path of embedded fields
used to access a target field or method.
Must be non-nil so that dotpath returns a non-nil slice even if d is zero.</p>
               
               <pre><code>var dotlist = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="endTag" data-name="endTag">
               <h3>
                  endTag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#endTag" class="anchor" title="Link to endTag">#</a>
               </h3>
               
               <p>Tags. Must be < 0.</p>
               
               <pre><code>const endTag</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="funcStack" data-name="funcStack">
               <h3>
                  funcStack 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#funcStack" class="anchor" title="Link to funcStack">#</a>
               </h3>
               
               <pre><code>var funcStack []*ir.Func</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="funcTag" data-name="funcTag">
               <h3>
                  funcTag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#funcTag" class="anchor" title="Link to funcTag">#</a>
               </h3>
               
               <p>Tags. Must be < 0.</p>
               
               <pre><code>const funcTag</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="okfor" data-name="okfor">
               <h3>
                  okfor 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#okfor" class="anchor" title="Link to okfor">#</a>
               </h3>
               
               <pre><code>var okfor [ir.OEND][]bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="okforadd" data-name="okforadd">
               <h3>
                  okforadd 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#okforadd" class="anchor" title="Link to okforadd">#</a>
               </h3>
               
               <pre><code>var okforadd [types.NTYPE]bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="okforand" data-name="okforand">
               <h3>
                  okforand 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#okforand" class="anchor" title="Link to okforand">#</a>
               </h3>
               
               <pre><code>var okforand [types.NTYPE]bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="okforarith" data-name="okforarith">
               <h3>
                  okforarith 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#okforarith" class="anchor" title="Link to okforarith">#</a>
               </h3>
               
               <pre><code>var okforarith [types.NTYPE]bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="okforbool" data-name="okforbool">
               <h3>
                  okforbool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#okforbool" class="anchor" title="Link to okforbool">#</a>
               </h3>
               
               <pre><code>var okforbool [types.NTYPE]bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="okforcap" data-name="okforcap">
               <h3>
                  okforcap 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#okforcap" class="anchor" title="Link to okforcap">#</a>
               </h3>
               
               <pre><code>var okforcap [types.NTYPE]bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="okforeq" data-name="okforeq">
               <h3>
                  okforeq 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#okforeq" class="anchor" title="Link to okforeq">#</a>
               </h3>
               
               <pre><code>var okforeq [types.NTYPE]bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="okforlen" data-name="okforlen">
               <h3>
                  okforlen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#okforlen" class="anchor" title="Link to okforlen">#</a>
               </h3>
               
               <pre><code>var okforlen [types.NTYPE]bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="okfornone" data-name="okfornone">
               <h3>
                  okfornone 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#okfornone" class="anchor" title="Link to okfornone">#</a>
               </h3>
               
               <pre><code>var okfornone [types.NTYPE]bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="packageTag" data-name="packageTag">
               <h3>
                  packageTag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#packageTag" class="anchor" title="Link to packageTag">#</a>
               </h3>
               
               <p>Objects</p>
               
               <pre><code>const packageTag = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="runtimeDecls" data-name="runtimeDecls">
               <h3>
                  runtimeDecls 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#runtimeDecls" class="anchor" title="Link to runtimeDecls">#</a>
               </h3>
               
               <pre><code>var runtimeDecls = [...]struct{...}{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="slist" data-name="slist">
               <h3>
                  slist 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#slist" class="anchor" title="Link to slist">#</a>
               </h3>
               
               <pre><code>var slist []symlink</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="traceIndent" data-name="traceIndent">
               <h3>
                  traceIndent 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#traceIndent" class="anchor" title="Link to traceIndent">#</a>
               </h3>
               
               <pre><code>var traceIndent []byte</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="typeSymIdx" data-name="typeSymIdx">
               <h3>
                  typeSymIdx 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#typeSymIdx" class="anchor" title="Link to typeSymIdx">#</a>
               </h3>
               
               <p>Map imported type T to the index of type descriptor symbols of T and *T,
so we can use index to reference the symbol.
TODO(mdempsky): Store this information directly in the Type's Name.</p>
               
               <pre><code>var typeSymIdx = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="typeTag" data-name="typeTag">
               <h3>
                  typeTag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#typeTag" class="anchor" title="Link to typeTag">#</a>
               </h3>
               
               <p>Tags. Must be < 0.</p>
               
               <pre><code>const typeTag</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unsafeFuncs" data-name="unsafeFuncs">
               <h3>
                  unsafeFuncs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#unsafeFuncs" class="anchor" title="Link to unsafeFuncs">#</a>
               </h3>
               
               <pre><code>var unsafeFuncs = [...]struct{...}{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="varTag" data-name="varTag">
               <h3>
                  varTag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#varTag" class="anchor" title="Link to varTag">#</a>
               </h3>
               
               <p>Tags. Must be < 0.</p>
               
               <pre><code>const varTag</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="ClosureStructIter" data-name="ClosureStructIter">
               <h3>
                  ClosureStructIter
                  <span class="badge">struct</span>
                  <a href="#ClosureStructIter" class="anchor" title="Link to ClosureStructIter">#</a>
               </h3>
               
               <p>ClosureStructIter iterates through a slice of closure variables returning
their type and offset in the closure struct.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ClosureStructIter struct {
closureVars []*ir.Name
offset int64
next int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dlist" data-name="dlist">
               <h3>
                  dlist
                  <span class="badge">struct</span>
                  <a href="#dlist" class="anchor" title="Link to dlist">#</a>
               </h3>
               
               <p>A dlist stores a pointer to a TFIELD Type embedded within
a TSTRUCT or TINTER Type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dlist struct {
field *types.Field
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="symlink" data-name="symlink">
               <h3>
                  symlink
                  <span class="badge">struct</span>
                  <a href="#symlink" class="anchor" title="Link to symlink">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type symlink struct {
field *types.Field
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="typeSet" data-name="typeSet">
               <h3>
                  typeSet
                  <span class="badge">struct</span>
                  <a href="#typeSet" class="anchor" title="Link to typeSet">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type typeSet struct {
m map[string]src.XPos
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AddImplicitDots" data-name="AddImplicitDots">
               <h3>
                  AddImplicitDots 
                  <span class="badge">function</span>
                  
                  <a href="#AddImplicitDots" class="anchor" title="Link to AddImplicitDots">#</a>
               </h3>
               
               <p>AddImplicitDots finds missing fields in obj.field that
will give the shortest unique addressing and
modifies the tree with missing field names.</p>
               
               <pre><code>func AddImplicitDots(n *ir.SelectorExpr) *ir.SelectorExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AssertFixedCall" data-name="AssertFixedCall">
               <h3>
                  AssertFixedCall 
                  <span class="badge">function</span>
                  
                  <a href="#AssertFixedCall" class="anchor" title="Link to AssertFixedCall">#</a>
               </h3>
               
               <pre><code>func AssertFixedCall(call *ir.CallExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AssignConv" data-name="AssignConv">
               <h3>
                  AssignConv 
                  <span class="badge">function</span>
                  
                  <a href="#AssignConv" class="anchor" title="Link to AssignConv">#</a>
               </h3>
               
               <pre><code>func AssignConv(n ir.Node, t *types.Type, context string) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AssignExpr" data-name="AssignExpr">
               <h3>
                  AssignExpr 
                  <span class="badge">function</span>
                  
                  <a href="#AssignExpr" class="anchor" title="Link to AssignExpr">#</a>
               </h3>
               
               <pre><code>func AssignExpr(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AutoLabel" data-name="AutoLabel">
               <h3>
                  AutoLabel 
                  <span class="badge">function</span>
                  
                  <a href="#AutoLabel" class="anchor" title="Link to AutoLabel">#</a>
               </h3>
               
               <p>AutoLabel generates a new Name node for use with
an automatically generated label.
prefix is a short mnemonic (e.g. ".s" for switch)
to help with debugging.
It should begin with "." to avoid conflicts with
user labels.</p>
               
               <pre><code>func AutoLabel(prefix string) *types.Sym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BaseTypeIndex" data-name="BaseTypeIndex">
               <h3>
                  BaseTypeIndex 
                  <span class="badge">function</span>
                  
                  <a href="#BaseTypeIndex" class="anchor" title="Link to BaseTypeIndex">#</a>
               </h3>
               
               <pre><code>func BaseTypeIndex(t *types.Type) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CalcMethods" data-name="CalcMethods">
               <h3>
                  CalcMethods 
                  <span class="badge">function</span>
                  
                  <a href="#CalcMethods" class="anchor" title="Link to CalcMethods">#</a>
               </h3>
               
               <p>CalcMethods calculates all the methods (including embedding) of a non-interface
type t.</p>
               
               <pre><code>func CalcMethods(t *types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Call" data-name="Call">
               <h3>
                  Call 
                  <span class="badge">function</span>
                  
                  <a href="#Call" class="anchor" title="Link to Call">#</a>
               </h3>
               
               <pre><code>func Call(pos src.XPos, callee ir.Node, args []ir.Node, dots bool) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Callee" data-name="Callee">
               <h3>
                  Callee 
                  <span class="badge">function</span>
                  
                  <a href="#Callee" class="anchor" title="Link to Callee">#</a>
               </h3>
               
               <pre><code>func Callee(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckFuncStack" data-name="CheckFuncStack">
               <h3>
                  CheckFuncStack 
                  <span class="badge">function</span>
                  
                  <a href="#CheckFuncStack" class="anchor" title="Link to CheckFuncStack">#</a>
               </h3>
               
               <pre><code>func CheckFuncStack()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ClosureType" data-name="ClosureType">
               <h3>
                  ClosureType 
                  <span class="badge">function</span>
                  
                  <a href="#ClosureType" class="anchor" title="Link to ClosureType">#</a>
               </h3>
               
               <p>ClosureType returns the struct type used to hold all the information
needed in the closure for clo (clo must be a OCLOSURE node).
The address of a variable of the returned type can be cast to a func.</p>
               
               <pre><code>func ClosureType(clo *ir.ClosureExpr) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Conv" data-name="Conv">
               <h3>
                  Conv 
                  <span class="badge">function</span>
                  
                  <a href="#Conv" class="anchor" title="Link to Conv">#</a>
               </h3>
               
               <pre><code>func Conv(n ir.Node, t *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ConvNop" data-name="ConvNop">
               <h3>
                  ConvNop 
                  <span class="badge">function</span>
                  
                  <a href="#ConvNop" class="anchor" title="Link to ConvNop">#</a>
               </h3>
               
               <p>ConvNop converts node n to type t using the OCONVNOP op
and typechecks the result with ctxExpr.</p>
               
               <pre><code>func ConvNop(n ir.Node, t *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ConvertVal" data-name="ConvertVal">
               <h3>
                  ConvertVal 
                  <span class="badge">function</span>
                  
                  <a href="#ConvertVal" class="anchor" title="Link to ConvertVal">#</a>
               </h3>
               
               <p>ConvertVal converts v into a representation appropriate for t. If
no such representation exists, it returns constant.MakeUnknown()
instead.
If explicit is true, then conversions from integer to string are
also allowed.</p>
               
               <pre><code>func ConvertVal(v constant.Value, t *types.Type, explicit bool) constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DeclFunc" data-name="DeclFunc">
               <h3>
                  DeclFunc 
                  <span class="badge">function</span>
                  
                  <a href="#DeclFunc" class="anchor" title="Link to DeclFunc">#</a>
               </h3>
               
               <p>DeclFunc declares the parameters for fn and adds it to
Target.Funcs.
Before returning, it sets CurFunc to fn. When the caller is done
constructing fn, it must call FinishFuncBody to restore CurFunc.</p>
               
               <pre><code>func DeclFunc(fn *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DefaultLit" data-name="DefaultLit">
               <h3>
                  DefaultLit 
                  <span class="badge">function</span>
                  
                  <a href="#DefaultLit" class="anchor" title="Link to DefaultLit">#</a>
               </h3>
               
               <pre><code>func DefaultLit(n ir.Node, t *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DotField" data-name="DotField">
               <h3>
                  DotField 
                  <span class="badge">function</span>
                  
                  <a href="#DotField" class="anchor" title="Link to DotField">#</a>
               </h3>
               
               <p>DotField returns a field selector expression that selects the
index'th field of the given expression, which must be of struct or
pointer-to-struct type.</p>
               
               <pre><code>func DotField(pos src.XPos, x ir.Node, index int) *ir.SelectorExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Expr" data-name="Expr">
               <h3>
                  Expr 
                  <span class="badge">function</span>
                  
                  <a href="#Expr" class="anchor" title="Link to Expr">#</a>
               </h3>
               
               <pre><code>func Expr(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Exprs" data-name="Exprs">
               <h3>
                  Exprs 
                  <span class="badge">function</span>
                  
                  <a href="#Exprs" class="anchor" title="Link to Exprs">#</a>
               </h3>
               
               <pre><code>func Exprs(exprs []ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FinishFuncBody" data-name="FinishFuncBody">
               <h3>
                  FinishFuncBody 
                  <span class="badge">function</span>
                  
                  <a href="#FinishFuncBody" class="anchor" title="Link to FinishFuncBody">#</a>
               </h3>
               
               <p>FinishFuncBody restores ir.CurFunc to its state before the last
call to DeclFunc.</p>
               
               <pre><code>func FinishFuncBody()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FixMethodCall" data-name="FixMethodCall">
               <h3>
                  FixMethodCall 
                  <span class="badge">function</span>
                  
                  <a href="#FixMethodCall" class="anchor" title="Link to FixMethodCall">#</a>
               </h3>
               
               <p>FixMethodCall rewrites a method call t.M(...) into a function call T.M(t, ...).</p>
               
               <pre><code>func FixMethodCall(call *ir.CallExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FixVariadicCall" data-name="FixVariadicCall">
               <h3>
                  FixVariadicCall 
                  <span class="badge">function</span>
                  
                  <a href="#FixVariadicCall" class="anchor" title="Link to FixVariadicCall">#</a>
               </h3>
               
               <p>FixVariadicCall rewrites calls to variadic functions to use an
explicit ... argument if one is not already present.</p>
               
               <pre><code>func FixVariadicCall(call *ir.CallExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Implements" data-name="Implements">
               <h3>
                  Implements 
                  <span class="badge">function</span>
                  
                  <a href="#Implements" class="anchor" title="Link to Implements">#</a>
               </h3>
               
               <p>Implements reports whether t implements the interface iface. t can be
an interface, a type parameter, or a concrete type.</p>
               
               <pre><code>func Implements(t *types.Type, iface *types.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImplementsExplain" data-name="ImplementsExplain">
               <h3>
                  ImplementsExplain 
                  <span class="badge">function</span>
                  
                  <a href="#ImplementsExplain" class="anchor" title="Link to ImplementsExplain">#</a>
               </h3>
               
               <p>ImplementsExplain reports whether t implements the interface iface. t can be
an interface, a type parameter, or a concrete type. If t does not implement
iface, a non-empty string is returned explaining why.</p>
               
               <pre><code>func ImplementsExplain(t *types.Type, iface *types.Type) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IndexConst" data-name="IndexConst">
               <h3>
                  IndexConst 
                  <span class="badge">function</span>
                  
                  <a href="#IndexConst" class="anchor" title="Link to IndexConst">#</a>
               </h3>
               
               <p>IndexConst returns the index value of constant Node n.</p>
               
               <pre><code>func IndexConst(n ir.Node) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitCoverage" data-name="InitCoverage">
               <h3>
                  InitCoverage 
                  <span class="badge">function</span>
                  
                  <a href="#InitCoverage" class="anchor" title="Link to InitCoverage">#</a>
               </h3>
               
               <p>InitCoverage loads the definitions for routines called
by code coverage instrumentation (similar to InitRuntime above).</p>
               
               <pre><code>func InitCoverage()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitRuntime" data-name="InitRuntime">
               <h3>
                  InitRuntime 
                  <span class="badge">function</span>
                  
                  <a href="#InitRuntime" class="anchor" title="Link to InitRuntime">#</a>
               </h3>
               
               <p>InitRuntime loads the definitions for the low-level runtime functions,
so that the compiler can generate calls to them,
but does not make them visible to user code.</p>
               
               <pre><code>func InitRuntime()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitUniverse" data-name="InitUniverse">
               <h3>
                  InitUniverse 
                  <span class="badge">function</span>
                  
                  <a href="#InitUniverse" class="anchor" title="Link to InitUniverse">#</a>
               </h3>
               
               <p>InitUniverse initializes the universe block.</p>
               
               <pre><code>func InitUniverse()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LinksymAddr" data-name="LinksymAddr">
               <h3>
                  LinksymAddr 
                  <span class="badge">function</span>
                  
                  <a href="#LinksymAddr" class="anchor" title="Link to LinksymAddr">#</a>
               </h3>
               
               <p>LinksymAddr returns a new expression that evaluates to the address
of lsym. typ specifies the type of the addressed memory.</p>
               
               <pre><code>func LinksymAddr(pos src.XPos, lsym *obj.LSym, typ *types.Type) *ir.AddrExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lookdot" data-name="Lookdot">
               <h3>
                  Lookdot 
                  <span class="badge">function</span>
                  
                  <a href="#Lookdot" class="anchor" title="Link to Lookdot">#</a>
               </h3>
               
               <p>Lookdot looks up field or method n.Sel in the type t and returns the matching
field. It transforms the op of node n to ODOTINTER or ODOTMETH, if appropriate.
It also may add a StarExpr node to n.X as needed for access to non-pointer
methods. If dostrcmp is 0, it matches the field/method with the exact symbol
as n.Sel (appropriate for exported fields). If dostrcmp is 1, it matches by name
exactly. If dostrcmp is 2, it matches names with case folding.</p>
               
               <pre><code>func Lookdot(n *ir.SelectorExpr, t *types.Type, dostrcmp int) *types.Field</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lookdot1" data-name="Lookdot1">
               <h3>
                  Lookdot1 
                  <span class="badge">function</span>
                  
                  <a href="#Lookdot1" class="anchor" title="Link to Lookdot1">#</a>
               </h3>
               
               <p>Lookdot1 looks up the specified method s in the list fs of methods, returning
the matching field or nil. If dostrcmp is 0, it matches the symbols. If
dostrcmp is 1, it matches by name exactly. If dostrcmp is 2, it matches names
with case folding.</p>
               
               <pre><code>func Lookdot1(errnode ir.Node, s *types.Sym, t *types.Type, fs []*types.Field, dostrcmp int) *types.Field</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lookup" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge">function</span>
                  
                  <a href="#Lookup" class="anchor" title="Link to Lookup">#</a>
               </h3>
               
               <pre><code>func Lookup(name string) *types.Sym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupCoverage" data-name="LookupCoverage">
               <h3>
                  LookupCoverage 
                  <span class="badge">function</span>
                  
                  <a href="#LookupCoverage" class="anchor" title="Link to LookupCoverage">#</a>
               </h3>
               
               <p>LookupCoverage looks up the Go function 'name' in package
runtime/coverage. This function must follow the internal calling
convention.</p>
               
               <pre><code>func LookupCoverage(name string) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupNum" data-name="LookupNum">
               <h3>
                  LookupNum 
                  <span class="badge">function</span>
                  
                  <a href="#LookupNum" class="anchor" title="Link to LookupNum">#</a>
               </h3>
               
               <p>LookupNum returns types.LocalPkg.LookupNum(prefix, n).</p>
               
               <pre><code>func LookupNum(prefix string, n int) *types.Sym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupRuntime" data-name="LookupRuntime">
               <h3>
                  LookupRuntime 
                  <span class="badge">function</span>
                  
                  <a href="#LookupRuntime" class="anchor" title="Link to LookupRuntime">#</a>
               </h3>
               
               <p>LookupRuntime returns a function or variable declared in
_builtin/runtime.go. If types_ is non-empty, successive occurrences
of the "any" placeholder type will be substituted.</p>
               
               <pre><code>func LookupRuntime(name string, types_ ...*types.Type) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupRuntimeABI" data-name="LookupRuntimeABI">
               <h3>
                  LookupRuntimeABI 
                  <span class="badge">function</span>
                  
                  <a href="#LookupRuntimeABI" class="anchor" title="Link to LookupRuntimeABI">#</a>
               </h3>
               
               <p>LookupRuntimeABI looks up a name in package runtime using the given ABI.</p>
               
               <pre><code>func LookupRuntimeABI(name string, abi obj.ABI) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupRuntimeFunc" data-name="LookupRuntimeFunc">
               <h3>
                  LookupRuntimeFunc 
                  <span class="badge">function</span>
                  
                  <a href="#LookupRuntimeFunc" class="anchor" title="Link to LookupRuntimeFunc">#</a>
               </h3>
               
               <p>LookupRuntimeFunc looks up Go function name in package runtime. This function
must follow the internal calling convention.</p>
               
               <pre><code>func LookupRuntimeFunc(name string) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupRuntimeVar" data-name="LookupRuntimeVar">
               <h3>
                  LookupRuntimeVar 
                  <span class="badge">function</span>
                  
                  <a href="#LookupRuntimeVar" class="anchor" title="Link to LookupRuntimeVar">#</a>
               </h3>
               
               <p>LookupRuntimeVar looks up a variable (or assembly function) name in package
runtime. If this is a function, it may have a special calling
convention.</p>
               
               <pre><code>func LookupRuntimeVar(name string) *obj.LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MakeDotArgs" data-name="MakeDotArgs">
               <h3>
                  MakeDotArgs 
                  <span class="badge">function</span>
                  
                  <a href="#MakeDotArgs" class="anchor" title="Link to MakeDotArgs">#</a>
               </h3>
               
               <p>MakeDotArgs package all the arguments that match a ... T parameter into a []T.</p>
               
               <pre><code>func MakeDotArgs(pos src.XPos, typ *types.Type, args []ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MethodValueType" data-name="MethodValueType">
               <h3>
                  MethodValueType 
                  <span class="badge">function</span>
                  
                  <a href="#MethodValueType" class="anchor" title="Link to MethodValueType">#</a>
               </h3>
               
               <p>MethodValueType returns the struct type used to hold all the information
needed in the closure for a OMETHVALUE node. The address of a variable of
the returned type can be cast to a func.</p>
               
               <pre><code>func MethodValueType(n *ir.SelectorExpr) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewClosureStructIter" data-name="NewClosureStructIter">
               <h3>
                  NewClosureStructIter 
                  <span class="badge">function</span>
                  
                  <a href="#NewClosureStructIter" class="anchor" title="Link to NewClosureStructIter">#</a>
               </h3>
               
               <p>NewClosureStructIter creates a new ClosureStructIter for closureVars.</p>
               
               <pre><code>func NewClosureStructIter(closureVars []*ir.Name) *ClosureStructIter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewFuncParams" data-name="NewFuncParams">
               <h3>
                  NewFuncParams 
                  <span class="badge">function</span>
                  
                  <a href="#NewFuncParams" class="anchor" title="Link to NewFuncParams">#</a>
               </h3>
               
               <p>Given funarg struct list, return list of fn args.</p>
               
               <pre><code>func NewFuncParams(origs []*types.Field) []*types.Field</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewMethodExpr" data-name="NewMethodExpr">
               <h3>
                  NewMethodExpr 
                  <span class="badge">function</span>
                  
                  <a href="#NewMethodExpr" class="anchor" title="Link to NewMethodExpr">#</a>
               </h3>
               
               <p>NewMethodExpr returns an OMETHEXPR node representing method
expression "recv.sym".</p>
               
               <pre><code>func NewMethodExpr(pos src.XPos, recv *types.Type, sym *types.Sym) *ir.SelectorExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewMethodType" data-name="NewMethodType">
               <h3>
                  NewMethodType 
                  <span class="badge">function</span>
                  
                  <a href="#NewMethodType" class="anchor" title="Link to NewMethodType">#</a>
               </h3>
               
               <p>f is method type, with receiver.
return function type, receiver as first argument (or not).</p>
               
               <pre><code>func NewMethodType(sig *types.Type, recv *types.Type) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Next" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Next" class="anchor" title="Link to Next">#</a>
               </h3>
               
               <p>Next returns the next name, type and offset of the next closure variable.
A nil name is returned after the last closure variable.</p>
               
               <pre><code>func (iter *ClosureStructIter) Next() (n *ir.Name, typ *types.Type, offset int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NodAddr" data-name="NodAddr">
               <h3>
                  NodAddr 
                  <span class="badge">function</span>
                  
                  <a href="#NodAddr" class="anchor" title="Link to NodAddr">#</a>
               </h3>
               
               <p>NodAddr returns a node representing &n at base.Pos.</p>
               
               <pre><code>func NodAddr(n ir.Node) *ir.AddrExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NodAddrAt" data-name="NodAddrAt">
               <h3>
                  NodAddrAt 
                  <span class="badge">function</span>
                  
                  <a href="#NodAddrAt" class="anchor" title="Link to NodAddrAt">#</a>
               </h3>
               
               <p>NodAddrAt returns a node representing &n at position pos.</p>
               
               <pre><code>func NodAddrAt(pos src.XPos, n ir.Node) *ir.AddrExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NodNil" data-name="NodNil">
               <h3>
                  NodNil 
                  <span class="badge">function</span>
                  
                  <a href="#NodNil" class="anchor" title="Link to NodNil">#</a>
               </h3>
               
               <pre><code>func NodNil() ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RangeExprType" data-name="RangeExprType">
               <h3>
                  RangeExprType 
                  <span class="badge">function</span>
                  
                  <a href="#RangeExprType" class="anchor" title="Link to RangeExprType">#</a>
               </h3>
               
               <pre><code>func RangeExprType(t *types.Type) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RewriteMultiValueCall" data-name="RewriteMultiValueCall">
               <h3>
                  RewriteMultiValueCall 
                  <span class="badge">function</span>
                  
                  <a href="#RewriteMultiValueCall" class="anchor" title="Link to RewriteMultiValueCall">#</a>
               </h3>
               
               <p>RewriteMultiValueCall rewrites multi-valued f() to use temporaries,
so the backend wouldn't need to worry about tuple-valued expressions.</p>
               
               <pre><code>func RewriteMultiValueCall(n ir.InitNode, call ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RewriteNonNameCall" data-name="RewriteNonNameCall">
               <h3>
                  RewriteNonNameCall 
                  <span class="badge">function</span>
                  
                  <a href="#RewriteNonNameCall" class="anchor" title="Link to RewriteNonNameCall">#</a>
               </h3>
               
               <p>RewriteNonNameCall replaces non-Name call expressions with temps,
rewriting f()(...) to t0 := f(); t0(...).</p>
               
               <pre><code>func RewriteNonNameCall(n *ir.CallExpr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBaseTypeIndex" data-name="SetBaseTypeIndex">
               <h3>
                  SetBaseTypeIndex 
                  <span class="badge">function</span>
                  
                  <a href="#SetBaseTypeIndex" class="anchor" title="Link to SetBaseTypeIndex">#</a>
               </h3>
               
               <pre><code>func SetBaseTypeIndex(t *types.Type, i int64, pi int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stmt" data-name="Stmt">
               <h3>
                  Stmt 
                  <span class="badge">function</span>
                  
                  <a href="#Stmt" class="anchor" title="Link to Stmt">#</a>
               </h3>
               
               <pre><code>func Stmt(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stmts" data-name="Stmts">
               <h3>
                  Stmts 
                  <span class="badge">function</span>
                  
                  <a href="#Stmts" class="anchor" title="Link to Stmts">#</a>
               </h3>
               
               <pre><code>func Stmts(stmts []ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TempAt" data-name="TempAt">
               <h3>
                  TempAt 
                  <span class="badge">function</span>
                  
                  <a href="#TempAt" class="anchor" title="Link to TempAt">#</a>
               </h3>
               
               <p>make a new Node off the books.</p>
               
               <pre><code>func TempAt(pos src.XPos, curfn *ir.Func, typ *types.Type) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TparamName" data-name="TparamName">
               <h3>
                  TparamName 
                  <span class="badge">function</span>
                  
                  <a href="#TparamName" class="anchor" title="Link to TparamName">#</a>
               </h3>
               
               <p>TparamName returns the real name of a type parameter, after stripping its
qualifying prefix and reverting blank-name encoding. See TparamExportName
for details.</p>
               
               <pre><code>func TparamName(exportName string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="XDotField" data-name="XDotField">
               <h3>
                  XDotField 
                  <span class="badge">function</span>
                  
                  <a href="#XDotField" class="anchor" title="Link to XDotField">#</a>
               </h3>
               
               <p>XDotField returns an expression representing the field selection
x.sym. If any implicit field selection are necessary, those are
inserted too.</p>
               
               <pre><code>func XDotField(pos src.XPos, x ir.Node, sym *types.Sym) *ir.SelectorExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="XDotMethod" data-name="XDotMethod">
               <h3>
                  XDotMethod 
                  <span class="badge">function</span>
                  
                  <a href="#XDotMethod" class="anchor" title="Link to XDotMethod">#</a>
               </h3>
               
               <p>XDotMethod returns an expression representing the method value
x.sym (i.e., x is a value, not a type). If any implicit field
selection are necessary, those are inserted too.
If callee is true, the result is an ODOTMETH/ODOTINTER, otherwise
an OMETHVALUE.</p>
               
               <pre><code>func XDotMethod(pos src.XPos, x ir.Node, sym *types.Sym, callee bool) *ir.SelectorExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <pre><code>func (s *typeSet) add(pos src.XPos, typ *types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="adddot1" data-name="adddot1">
               <h3>
                  adddot1 
                  <span class="badge">function</span>
                  
                  <a href="#adddot1" class="anchor" title="Link to adddot1">#</a>
               </h3>
               
               <p>adddot1 returns the number of fields or methods named s at depth d in Type t.
If exactly one exists, it will be returned in *save (if save is not nil),
and dotlist will contain the path of embedded fields traversed to find it,
in reverse order. If none exist, more will indicate whether t contains any
embedded fields at depth d, so callers can decide whether to retry at
a greater depth.</p>
               
               <pre><code>func adddot1(s *types.Sym, t *types.Type, d int, save **types.Field, ignorecase bool) (c int, more bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assign" data-name="assign">
               <h3>
                  assign 
                  <span class="badge">function</span>
                  
                  <a href="#assign" class="anchor" title="Link to assign">#</a>
               </h3>
               
               <pre><code>func assign(stmt ir.Node, lhs []ir.Node, rhs []ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignOp" data-name="assignOp">
               <h3>
                  assignOp 
                  <span class="badge">function</span>
                  
                  <a href="#assignOp" class="anchor" title="Link to assignOp">#</a>
               </h3>
               
               <p>Is type src assignment compatible to type dst?
If so, return op code to use in conversion.
If not, return OXXX. In this case, the string return parameter may
hold a reason why. In all other cases, it'll be the empty string.</p>
               
               <pre><code>func assignOp(src *types.Type, dst *types.Type) (ir.Op, string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignconvfn" data-name="assignconvfn">
               <h3>
                  assignconvfn 
                  <span class="badge">function</span>
                  
                  <a href="#assignconvfn" class="anchor" title="Link to assignconvfn">#</a>
               </h3>
               
               <p>Convert node n for assignment to type t.</p>
               
               <pre><code>func assignconvfn(n ir.Node, t *types.Type, context func() string) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="autotmpname" data-name="autotmpname">
               <h3>
                  autotmpname 
                  <span class="badge">function</span>
                  
                  <a href="#autotmpname" class="anchor" title="Link to autotmpname">#</a>
               </h3>
               
               <p>autotmpname returns the name for an autotmp variable numbered n.</p>
               
               <pre><code>func autotmpname(n int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="callOrChan" data-name="callOrChan">
               <h3>
                  callOrChan 
                  <span class="badge">function</span>
                  
                  <a href="#callOrChan" class="anchor" title="Link to callOrChan">#</a>
               </h3>
               
               <p>callOrChan reports whether n is a call or channel operation.</p>
               
               <pre><code>func callOrChan(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkassign" data-name="checkassign">
               <h3>
                  checkassign 
                  <span class="badge">function</span>
                  
                  <a href="#checkassign" class="anchor" title="Link to checkassign">#</a>
               </h3>
               
               <pre><code>func checkassign(n ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkassignto" data-name="checkassignto">
               <h3>
                  checkassignto 
                  <span class="badge">function</span>
                  
                  <a href="#checkassignto" class="anchor" title="Link to checkassignto">#</a>
               </h3>
               
               <pre><code>func checkassignto(src *types.Type, dst ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checklvalue" data-name="checklvalue">
               <h3>
                  checklvalue 
                  <span class="badge">function</span>
                  
                  <a href="#checklvalue" class="anchor" title="Link to checklvalue">#</a>
               </h3>
               
               <pre><code>func checklvalue(n ir.Node, verb string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkmake" data-name="checkmake">
               <h3>
                  checkmake 
                  <span class="badge">function</span>
                  
                  <a href="#checkmake" class="anchor" title="Link to checkmake">#</a>
               </h3>
               
               <pre><code>func checkmake(t *types.Type, arg string, np *ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checksliceindex" data-name="checksliceindex">
               <h3>
                  checksliceindex 
                  <span class="badge">function</span>
                  
                  <a href="#checksliceindex" class="anchor" title="Link to checksliceindex">#</a>
               </h3>
               
               <pre><code>func checksliceindex(r ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkunsafesliceorstring" data-name="checkunsafesliceorstring">
               <h3>
                  checkunsafesliceorstring 
                  <span class="badge">function</span>
                  
                  <a href="#checkunsafesliceorstring" class="anchor" title="Link to checkunsafesliceorstring">#</a>
               </h3>
               
               <p>checkunsafesliceorstring is like checkmake but for unsafe.{Slice,String}.</p>
               
               <pre><code>func checkunsafesliceorstring(op ir.Op, np *ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convertOp" data-name="convertOp">
               <h3>
                  convertOp 
                  <span class="badge">function</span>
                  
                  <a href="#convertOp" class="anchor" title="Link to convertOp">#</a>
               </h3>
               
               <p>Can we convert a value of type src to a value of type dst?
If so, return op code to use in conversion (maybe OCONVNOP).
If not, return OXXX. In this case, the string return parameter may
hold a reason why. In all other cases, it'll be the empty string.
srcConstant indicates whether the value of type src is a constant.</p>
               
               <pre><code>func convertOp(srcConstant bool, src *types.Type, dst *types.Type) (ir.Op, string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convlit" data-name="convlit">
               <h3>
                  convlit 
                  <span class="badge">function</span>
                  
                  <a href="#convlit" class="anchor" title="Link to convlit">#</a>
               </h3>
               
               <p>TODO(mdempsky): Replace these with better APIs.</p>
               
               <pre><code>func convlit(n ir.Node, t *types.Type) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convlit1" data-name="convlit1">
               <h3>
                  convlit1 
                  <span class="badge">function</span>
                  
                  <a href="#convlit1" class="anchor" title="Link to convlit1">#</a>
               </h3>
               
               <p>convlit1 converts an untyped expression n to type t. If n already
has a type, convlit1 has no effect.
For explicit conversions, t must be non-nil, and integer-to-string
conversions are allowed.
For implicit conversions (e.g., assignments), t may be nil; if so,
n is converted to its default type.
If there's an error converting n to t, context is used in the error
message.</p>
               
               <pre><code>func convlit1(n ir.Node, t *types.Type, explicit bool, context func() string) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="coverageTypes" data-name="coverageTypes">
               <h3>
                  coverageTypes 
                  <span class="badge">function</span>
                  
                  <a href="#coverageTypes" class="anchor" title="Link to coverageTypes">#</a>
               </h3>
               
               <pre><code>func coverageTypes() []*types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defaultType" data-name="defaultType">
               <h3>
                  defaultType 
                  <span class="badge">function</span>
                  
                  <a href="#defaultType" class="anchor" title="Link to defaultType">#</a>
               </h3>
               
               <pre><code>func defaultType(t *types.Type) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defaultlit2" data-name="defaultlit2">
               <h3>
                  defaultlit2 
                  <span class="badge">function</span>
                  
                  <a href="#defaultlit2" class="anchor" title="Link to defaultlit2">#</a>
               </h3>
               
               <p>DefaultLit on both nodes simultaneously;
if they're both ideal going in they better
get the same type going out.
force means must assign concrete (non-ideal) type.
The results of defaultlit2 MUST be assigned back to l and r, e.g.
n.Left, n.Right = defaultlit2(n.Left, n.Right, force)</p>
               
               <pre><code>func defaultlit2(l ir.Node, r ir.Node, force bool) (ir.Node, ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="derefall" data-name="derefall">
               <h3>
                  derefall 
                  <span class="badge">function</span>
                  
                  <a href="#derefall" class="anchor" title="Link to derefall">#</a>
               </h3>
               
               <pre><code>func derefall(t *types.Type) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dot" data-name="dot">
               <h3>
                  dot 
                  <span class="badge">function</span>
                  
                  <a href="#dot" class="anchor" title="Link to dot">#</a>
               </h3>
               
               <pre><code>func dot(pos src.XPos, typ *types.Type, op ir.Op, x ir.Node, selection *types.Field) *ir.SelectorExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dotpath" data-name="dotpath">
               <h3>
                  dotpath 
                  <span class="badge">function</span>
                  
                  <a href="#dotpath" class="anchor" title="Link to dotpath">#</a>
               </h3>
               
               <p>dotpath computes the unique shortest explicit selector path to fully qualify
a selection expression x.f, where x is of type t and f is the symbol s.
If no such path exists, dotpath returns nil.
If there are multiple shortest paths to the same depth, ambig is true.</p>
               
               <pre><code>func dotpath(s *types.Sym, t *types.Type, save **types.Field, ignorecase bool) (path []dlist, ambig bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expand0" data-name="expand0">
               <h3>
                  expand0 
                  <span class="badge">function</span>
                  
                  <a href="#expand0" class="anchor" title="Link to expand0">#</a>
               </h3>
               
               <pre><code>func expand0(t *types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expand1" data-name="expand1">
               <h3>
                  expand1 
                  <span class="badge">function</span>
                  
                  <a href="#expand1" class="anchor" title="Link to expand1">#</a>
               </h3>
               
               <pre><code>func expand1(t *types.Type, top bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fielddup" data-name="fielddup">
               <h3>
                  fielddup 
                  <span class="badge">function</span>
                  
                  <a href="#fielddup" class="anchor" title="Link to fielddup">#</a>
               </h3>
               
               <p>type check composite.</p>
               
               <pre><code>func fielddup(name string, hash map[string]bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasddd" data-name="hasddd">
               <h3>
                  hasddd 
                  <span class="badge">function</span>
                  
                  <a href="#hasddd" class="anchor" title="Link to hasddd">#</a>
               </h3>
               
               <pre><code>func hasddd(params []*types.Field) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ifacelookdot" data-name="ifacelookdot">
               <h3>
                  ifacelookdot 
                  <span class="badge">function</span>
                  
                  <a href="#ifacelookdot" class="anchor" title="Link to ifacelookdot">#</a>
               </h3>
               
               <pre><code>func ifacelookdot(s *types.Sym, t *types.Type, ignorecase bool) *types.Field</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="implements" data-name="implements">
               <h3>
                  implements 
                  <span class="badge">function</span>
                  
                  <a href="#implements" class="anchor" title="Link to implements">#</a>
               </h3>
               
               <p>implements reports whether t implements the interface iface. t can be
an interface, a type parameter, or a concrete type. If implements returns
false, it stores a method of iface that is not implemented in *m. If the
method name matches but the type is wrong, it additionally stores the type
of the method (on t) in *samename.</p>
               
               <pre><code>func implements(t *types.Type, iface *types.Type, m **types.Field, samename **types.Field, ptr *int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="implicitstar" data-name="implicitstar">
               <h3>
                  implicitstar 
                  <span class="badge">function</span>
                  
                  <a href="#implicitstar" class="anchor" title="Link to implicitstar">#</a>
               </h3>
               
               <p>The result of implicitstar MUST be assigned back to n, e.g.
n.Left = implicitstar(n.Left)</p>
               
               <pre><code>func implicitstar(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="importfunc" data-name="importfunc">
               <h3>
                  importfunc 
                  <span class="badge">function</span>
                  
                  <a href="#importfunc" class="anchor" title="Link to importfunc">#</a>
               </h3>
               
               <p>importfunc declares symbol s as an imported function with type t.</p>
               
               <pre><code>func importfunc(s *types.Sym, t *types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="importsym" data-name="importsym">
               <h3>
                  importsym 
                  <span class="badge">function</span>
                  
                  <a href="#importsym" class="anchor" title="Link to importsym">#</a>
               </h3>
               
               <pre><code>func importsym(name *ir.Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="importvar" data-name="importvar">
               <h3>
                  importvar 
                  <span class="badge">function</span>
                  
                  <a href="#importvar" class="anchor" title="Link to importvar">#</a>
               </h3>
               
               <p>importvar declares symbol s as an imported variable with type t.</p>
               
               <pre><code>func importvar(s *types.Sym, t *types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indexlit" data-name="indexlit">
               <h3>
                  indexlit 
                  <span class="badge">function</span>
                  
                  <a href="#indexlit" class="anchor" title="Link to indexlit">#</a>
               </h3>
               
               <p>indexlit implements typechecking of untyped values as
array/slice indexes. It is almost equivalent to DefaultLit
but also accepts untyped numeric values representable as
value of type int (see also checkmake for comparison).
The result of indexlit MUST be assigned back to n, e.g.
n.Left = indexlit(n.Left)</p>
               
               <pre><code>func indexlit(n ir.Node) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isptrto" data-name="isptrto">
               <h3>
                  isptrto 
                  <span class="badge">function</span>
                  
                  <a href="#isptrto" class="anchor" title="Link to isptrto">#</a>
               </h3>
               
               <pre><code>func isptrto(t *types.Type, et types.Kind) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookdot0" data-name="lookdot0">
               <h3>
                  lookdot0 
                  <span class="badge">function</span>
                  
                  <a href="#lookdot0" class="anchor" title="Link to lookdot0">#</a>
               </h3>
               
               <p>lookdot0 returns the number of fields or methods named s associated
with Type t. If exactly one exists, it will be returned in *save
(if save is not nil).</p>
               
               <pre><code>func lookdot0(s *types.Sym, t *types.Type, save **types.Field, ignorecase bool) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeComplex" data-name="makeComplex">
               <h3>
                  makeComplex 
                  <span class="badge">function</span>
                  
                  <a href="#makeComplex" class="anchor" title="Link to makeComplex">#</a>
               </h3>
               
               <pre><code>func makeComplex(real constant.Value, imag constant.Value) constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeFloat64" data-name="makeFloat64">
               <h3>
                  makeFloat64 
                  <span class="badge">function</span>
                  
                  <a href="#makeFloat64" class="anchor" title="Link to makeFloat64">#</a>
               </h3>
               
               <pre><code>func makeFloat64(f float64) constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mixUntyped" data-name="mixUntyped">
               <h3>
                  mixUntyped 
                  <span class="badge">function</span>
                  
                  <a href="#mixUntyped" class="anchor" title="Link to mixUntyped">#</a>
               </h3>
               
               <pre><code>func mixUntyped(t1 *types.Type, t2 *types.Type) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="needOneArg" data-name="needOneArg">
               <h3>
                  needOneArg 
                  <span class="badge">function</span>
                  
                  <a href="#needOneArg" class="anchor" title="Link to needOneArg">#</a>
               </h3>
               
               <pre><code>func needOneArg(n *ir.CallExpr, f string, args ...interface{}) (ir.Node, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="needTwoArgs" data-name="needTwoArgs">
               <h3>
                  needTwoArgs 
                  <span class="badge">function</span>
                  
                  <a href="#needTwoArgs" class="anchor" title="Link to needTwoArgs">#</a>
               </h3>
               
               <pre><code>func needTwoArgs(n *ir.CallExpr) (ir.Node, ir.Node, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newSig" data-name="newSig">
               <h3>
                  newSig 
                  <span class="badge">function</span>
                  
                  <a href="#newSig" class="anchor" title="Link to newSig">#</a>
               </h3>
               
               <p>Not inlining this function removes a significant chunk of init code.
go:noinline</p>
               
               <pre><code>func newSig(params []*types.Field, results []*types.Field) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nokeys" data-name="nokeys">
               <h3>
                  nokeys 
                  <span class="badge">function</span>
                  
                  <a href="#nokeys" class="anchor" title="Link to nokeys">#</a>
               </h3>
               
               <pre><code>func nokeys(l ir.Nodes) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nonexported" data-name="nonexported">
               <h3>
                  nonexported 
                  <span class="badge">function</span>
                  
                  <a href="#nonexported" class="anchor" title="Link to nonexported">#</a>
               </h3>
               
               <p>nonexported reports whether sym is an unexported field.</p>
               
               <pre><code>func nonexported(sym *types.Sym) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="normalizeGoDeferCall" data-name="normalizeGoDeferCall">
               <h3>
                  normalizeGoDeferCall 
                  <span class="badge">function</span>
                  
                  <a href="#normalizeGoDeferCall" class="anchor" title="Link to normalizeGoDeferCall">#</a>
               </h3>
               
               <p>normalizeGoDeferCall normalizes call into a normal function call
with no arguments and no results, suitable for use in an OGO/ODEFER
statement.
For example, it normalizes:
f(x, y)
into:
x1, y1 := x, y          // added to init
func() { f(x1, y1) }()  // result</p>
               
               <pre><code>func normalizeGoDeferCall(pos src.XPos, op ir.Op, call ir.Node, init *ir.Nodes) *ir.CallExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="operandType" data-name="operandType">
               <h3>
                  operandType 
                  <span class="badge">function</span>
                  
                  <a href="#operandType" class="anchor" title="Link to operandType">#</a>
               </h3>
               
               <pre><code>func operandType(op ir.Op, t *types.Type) *types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="params" data-name="params">
               <h3>
                  params 
                  <span class="badge">function</span>
                  
                  <a href="#params" class="anchor" title="Link to params">#</a>
               </h3>
               
               <pre><code>func params(tlist ...*types.Type) []*types.Field</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="plural" data-name="plural">
               <h3>
                  plural 
                  <span class="badge">function</span>
                  
                  <a href="#plural" class="anchor" title="Link to plural">#</a>
               </h3>
               
               <pre><code>func plural(n int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="roundFloat" data-name="roundFloat">
               <h3>
                  roundFloat 
                  <span class="badge">function</span>
                  
                  <a href="#roundFloat" class="anchor" title="Link to roundFloat">#</a>
               </h3>
               
               <pre><code>func roundFloat(v constant.Value, sz int64) constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtimeTypes" data-name="runtimeTypes">
               <h3>
                  runtimeTypes 
                  <span class="badge">function</span>
                  
                  <a href="#runtimeTypes" class="anchor" title="Link to runtimeTypes">#</a>
               </h3>
               
               <pre><code>func runtimeTypes() []*types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stringtoruneslit" data-name="stringtoruneslit">
               <h3>
                  stringtoruneslit 
                  <span class="badge">function</span>
                  
                  <a href="#stringtoruneslit" class="anchor" title="Link to stringtoruneslit">#</a>
               </h3>
               
               <p>The result of stringtoruneslit MUST be assigned back to n, e.g.
n.Left = stringtoruneslit(n.Left)</p>
               
               <pre><code>func stringtoruneslit(n *ir.ConvExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="substArgTypes" data-name="substArgTypes">
               <h3>
                  substArgTypes 
                  <span class="badge">function</span>
                  
                  <a href="#substArgTypes" class="anchor" title="Link to substArgTypes">#</a>
               </h3>
               
               <p>SubstArgTypes substitutes the given list of types for
successive occurrences of the "any" placeholder in the
type syntax expression n.Type.</p>
               
               <pre><code>func substArgTypes(old *ir.Name, types_ ...*types.Type) *ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcAppend" data-name="tcAppend">
               <h3>
                  tcAppend 
                  <span class="badge">function</span>
                  
                  <a href="#tcAppend" class="anchor" title="Link to tcAppend">#</a>
               </h3>
               
               <p>tcAppend typechecks an OAPPEND node.</p>
               
               <pre><code>func tcAppend(n *ir.CallExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcArith" data-name="tcArith">
               <h3>
                  tcArith 
                  <span class="badge">function</span>
                  
                  <a href="#tcArith" class="anchor" title="Link to tcArith">#</a>
               </h3>
               
               <p>tcArith typechecks operands of a binary arithmetic expression.
The result of tcArith MUST be assigned back to original operands,
t is the type of the expression, and should be set by the caller. e.g:
n.X, n.Y, t = tcArith(n, op, n.X, n.Y)
n.SetType(t)</p>
               
               <pre><code>func tcArith(n ir.Node, op ir.Op, l ir.Node, r ir.Node) (ir.Node, ir.Node, *types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcAssign" data-name="tcAssign">
               <h3>
                  tcAssign 
                  <span class="badge">function</span>
                  
                  <a href="#tcAssign" class="anchor" title="Link to tcAssign">#</a>
               </h3>
               
               <p>type check assignment.
if this assignment is the definition of a var on the left side,
fill in the var's type.</p>
               
               <pre><code>func tcAssign(n *ir.AssignStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcAssignList" data-name="tcAssignList">
               <h3>
                  tcAssignList 
                  <span class="badge">function</span>
                  
                  <a href="#tcAssignList" class="anchor" title="Link to tcAssignList">#</a>
               </h3>
               
               <pre><code>func tcAssignList(n *ir.AssignListStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcCall" data-name="tcCall">
               <h3>
                  tcCall 
                  <span class="badge">function</span>
                  
                  <a href="#tcCall" class="anchor" title="Link to tcCall">#</a>
               </h3>
               
               <p>tcCall typechecks an OCALL node.</p>
               
               <pre><code>func tcCall(n *ir.CallExpr, top int) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcCheckNil" data-name="tcCheckNil">
               <h3>
                  tcCheckNil 
                  <span class="badge">function</span>
                  
                  <a href="#tcCheckNil" class="anchor" title="Link to tcCheckNil">#</a>
               </h3>
               
               <p>tcCheckNil typechecks an OCHECKNIL node.</p>
               
               <pre><code>func tcCheckNil(n *ir.UnaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcClear" data-name="tcClear">
               <h3>
                  tcClear 
                  <span class="badge">function</span>
                  
                  <a href="#tcClear" class="anchor" title="Link to tcClear">#</a>
               </h3>
               
               <p>tcClear typechecks an OCLEAR node.</p>
               
               <pre><code>func tcClear(n *ir.UnaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcClose" data-name="tcClose">
               <h3>
                  tcClose 
                  <span class="badge">function</span>
                  
                  <a href="#tcClose" class="anchor" title="Link to tcClose">#</a>
               </h3>
               
               <p>tcClose typechecks an OCLOSE node.</p>
               
               <pre><code>func tcClose(n *ir.UnaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcCompLit" data-name="tcCompLit">
               <h3>
                  tcCompLit 
                  <span class="badge">function</span>
                  
                  <a href="#tcCompLit" class="anchor" title="Link to tcCompLit">#</a>
               </h3>
               
               <p>The result of tcCompLit MUST be assigned back to n, e.g.
n.Left = tcCompLit(n.Left)</p>
               
               <pre><code>func tcCompLit(n *ir.CompLitExpr) (res ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcComplex" data-name="tcComplex">
               <h3>
                  tcComplex 
                  <span class="badge">function</span>
                  
                  <a href="#tcComplex" class="anchor" title="Link to tcComplex">#</a>
               </h3>
               
               <p>tcComplex typechecks an OCOMPLEX node.</p>
               
               <pre><code>func tcComplex(n *ir.BinaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcConv" data-name="tcConv">
               <h3>
                  tcConv 
                  <span class="badge">function</span>
                  
                  <a href="#tcConv" class="anchor" title="Link to tcConv">#</a>
               </h3>
               
               <p>tcConv typechecks an OCONV node.</p>
               
               <pre><code>func tcConv(n *ir.ConvExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcCopy" data-name="tcCopy">
               <h3>
                  tcCopy 
                  <span class="badge">function</span>
                  
                  <a href="#tcCopy" class="anchor" title="Link to tcCopy">#</a>
               </h3>
               
               <p>tcCopy typechecks an OCOPY node.</p>
               
               <pre><code>func tcCopy(n *ir.BinaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcDelete" data-name="tcDelete">
               <h3>
                  tcDelete 
                  <span class="badge">function</span>
                  
                  <a href="#tcDelete" class="anchor" title="Link to tcDelete">#</a>
               </h3>
               
               <p>tcDelete typechecks an ODELETE node.</p>
               
               <pre><code>func tcDelete(n *ir.CallExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcDot" data-name="tcDot">
               <h3>
                  tcDot 
                  <span class="badge">function</span>
                  
                  <a href="#tcDot" class="anchor" title="Link to tcDot">#</a>
               </h3>
               
               <p>tcDot typechecks an OXDOT or ODOT node.</p>
               
               <pre><code>func tcDot(n *ir.SelectorExpr, top int) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcDotType" data-name="tcDotType">
               <h3>
                  tcDotType 
                  <span class="badge">function</span>
                  
                  <a href="#tcDotType" class="anchor" title="Link to tcDotType">#</a>
               </h3>
               
               <p>tcDotType typechecks an ODOTTYPE node.</p>
               
               <pre><code>func tcDotType(n *ir.TypeAssertExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcFor" data-name="tcFor">
               <h3>
                  tcFor 
                  <span class="badge">function</span>
                  
                  <a href="#tcFor" class="anchor" title="Link to tcFor">#</a>
               </h3>
               
               <p>tcFor typechecks an OFOR node.</p>
               
               <pre><code>func tcFor(n *ir.ForStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcFunc" data-name="tcFunc">
               <h3>
                  tcFunc 
                  <span class="badge">function</span>
                  
                  <a href="#tcFunc" class="anchor" title="Link to tcFunc">#</a>
               </h3>
               
               <p>type check function definition
To be called by typecheck, not directly.
(Call typecheck.Func instead.)</p>
               
               <pre><code>func tcFunc(n *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcGoDefer" data-name="tcGoDefer">
               <h3>
                  tcGoDefer 
                  <span class="badge">function</span>
                  
                  <a href="#tcGoDefer" class="anchor" title="Link to tcGoDefer">#</a>
               </h3>
               
               <p>tcGoDefer typechecks (normalizes) an OGO/ODEFER statement.</p>
               
               <pre><code>func tcGoDefer(n *ir.GoDeferStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcITab" data-name="tcITab">
               <h3>
                  tcITab 
                  <span class="badge">function</span>
                  
                  <a href="#tcITab" class="anchor" title="Link to tcITab">#</a>
               </h3>
               
               <p>tcITab typechecks an OITAB node.</p>
               
               <pre><code>func tcITab(n *ir.UnaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcIf" data-name="tcIf">
               <h3>
                  tcIf 
                  <span class="badge">function</span>
                  
                  <a href="#tcIf" class="anchor" title="Link to tcIf">#</a>
               </h3>
               
               <p>tcIf typechecks an OIF node.</p>
               
               <pre><code>func tcIf(n *ir.IfStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcIndex" data-name="tcIndex">
               <h3>
                  tcIndex 
                  <span class="badge">function</span>
                  
                  <a href="#tcIndex" class="anchor" title="Link to tcIndex">#</a>
               </h3>
               
               <p>tcIndex typechecks an OINDEX node.</p>
               
               <pre><code>func tcIndex(n *ir.IndexExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcLenCap" data-name="tcLenCap">
               <h3>
                  tcLenCap 
                  <span class="badge">function</span>
                  
                  <a href="#tcLenCap" class="anchor" title="Link to tcLenCap">#</a>
               </h3>
               
               <p>tcLenCap typechecks an OLEN or OCAP node.</p>
               
               <pre><code>func tcLenCap(n *ir.UnaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcMake" data-name="tcMake">
               <h3>
                  tcMake 
                  <span class="badge">function</span>
                  
                  <a href="#tcMake" class="anchor" title="Link to tcMake">#</a>
               </h3>
               
               <p>tcMake typechecks an OMAKE node.</p>
               
               <pre><code>func tcMake(n *ir.CallExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcMakeSliceCopy" data-name="tcMakeSliceCopy">
               <h3>
                  tcMakeSliceCopy 
                  <span class="badge">function</span>
                  
                  <a href="#tcMakeSliceCopy" class="anchor" title="Link to tcMakeSliceCopy">#</a>
               </h3>
               
               <p>tcMakeSliceCopy typechecks an OMAKESLICECOPY node.</p>
               
               <pre><code>func tcMakeSliceCopy(n *ir.MakeExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcMinMax" data-name="tcMinMax">
               <h3>
                  tcMinMax 
                  <span class="badge">function</span>
                  
                  <a href="#tcMinMax" class="anchor" title="Link to tcMinMax">#</a>
               </h3>
               
               <p>tcMinMax typechecks an OMIN or OMAX node.</p>
               
               <pre><code>func tcMinMax(n *ir.CallExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcNew" data-name="tcNew">
               <h3>
                  tcNew 
                  <span class="badge">function</span>
                  
                  <a href="#tcNew" class="anchor" title="Link to tcNew">#</a>
               </h3>
               
               <p>tcNew typechecks an ONEW node.</p>
               
               <pre><code>func tcNew(n *ir.UnaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcPanic" data-name="tcPanic">
               <h3>
                  tcPanic 
                  <span class="badge">function</span>
                  
                  <a href="#tcPanic" class="anchor" title="Link to tcPanic">#</a>
               </h3>
               
               <p>tcPanic typechecks an OPANIC node.</p>
               
               <pre><code>func tcPanic(n *ir.UnaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcPrint" data-name="tcPrint">
               <h3>
                  tcPrint 
                  <span class="badge">function</span>
                  
                  <a href="#tcPrint" class="anchor" title="Link to tcPrint">#</a>
               </h3>
               
               <p>tcPrint typechecks an OPRINT or OPRINTN node.</p>
               
               <pre><code>func tcPrint(n *ir.CallExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcRange" data-name="tcRange">
               <h3>
                  tcRange 
                  <span class="badge">function</span>
                  
                  <a href="#tcRange" class="anchor" title="Link to tcRange">#</a>
               </h3>
               
               <p>range</p>
               
               <pre><code>func tcRange(n *ir.RangeStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcRealImag" data-name="tcRealImag">
               <h3>
                  tcRealImag 
                  <span class="badge">function</span>
                  
                  <a href="#tcRealImag" class="anchor" title="Link to tcRealImag">#</a>
               </h3>
               
               <p>tcRealImag typechecks an OREAL or OIMAG node.</p>
               
               <pre><code>func tcRealImag(n *ir.UnaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcRecover" data-name="tcRecover">
               <h3>
                  tcRecover 
                  <span class="badge">function</span>
                  
                  <a href="#tcRecover" class="anchor" title="Link to tcRecover">#</a>
               </h3>
               
               <p>tcRecover typechecks an ORECOVER node.</p>
               
               <pre><code>func tcRecover(n *ir.CallExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcRecv" data-name="tcRecv">
               <h3>
                  tcRecv 
                  <span class="badge">function</span>
                  
                  <a href="#tcRecv" class="anchor" title="Link to tcRecv">#</a>
               </h3>
               
               <p>tcRecv typechecks an ORECV node.</p>
               
               <pre><code>func tcRecv(n *ir.UnaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcReturn" data-name="tcReturn">
               <h3>
                  tcReturn 
                  <span class="badge">function</span>
                  
                  <a href="#tcReturn" class="anchor" title="Link to tcReturn">#</a>
               </h3>
               
               <p>tcReturn typechecks an ORETURN node.</p>
               
               <pre><code>func tcReturn(n *ir.ReturnStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcSPtr" data-name="tcSPtr">
               <h3>
                  tcSPtr 
                  <span class="badge">function</span>
                  
                  <a href="#tcSPtr" class="anchor" title="Link to tcSPtr">#</a>
               </h3>
               
               <p>tcSPtr typechecks an OSPTR node.</p>
               
               <pre><code>func tcSPtr(n *ir.UnaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcSelect" data-name="tcSelect">
               <h3>
                  tcSelect 
                  <span class="badge">function</span>
                  
                  <a href="#tcSelect" class="anchor" title="Link to tcSelect">#</a>
               </h3>
               
               <p>select</p>
               
               <pre><code>func tcSelect(sel *ir.SelectStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcSend" data-name="tcSend">
               <h3>
                  tcSend 
                  <span class="badge">function</span>
                  
                  <a href="#tcSend" class="anchor" title="Link to tcSend">#</a>
               </h3>
               
               <p>tcSend typechecks an OSEND node.</p>
               
               <pre><code>func tcSend(n *ir.SendStmt) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcShift" data-name="tcShift">
               <h3>
                  tcShift 
                  <span class="badge">function</span>
                  
                  <a href="#tcShift" class="anchor" title="Link to tcShift">#</a>
               </h3>
               
               <pre><code>func tcShift(n ir.Node, l ir.Node, r ir.Node) (ir.Node, ir.Node, *types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcSlice" data-name="tcSlice">
               <h3>
                  tcSlice 
                  <span class="badge">function</span>
                  
                  <a href="#tcSlice" class="anchor" title="Link to tcSlice">#</a>
               </h3>
               
               <p>tcSlice typechecks an OSLICE or OSLICE3 node.</p>
               
               <pre><code>func tcSlice(n *ir.SliceExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcSliceHeader" data-name="tcSliceHeader">
               <h3>
                  tcSliceHeader 
                  <span class="badge">function</span>
                  
                  <a href="#tcSliceHeader" class="anchor" title="Link to tcSliceHeader">#</a>
               </h3>
               
               <p>tcSliceHeader typechecks an OSLICEHEADER node.</p>
               
               <pre><code>func tcSliceHeader(n *ir.SliceHeaderExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcStar" data-name="tcStar">
               <h3>
                  tcStar 
                  <span class="badge">function</span>
                  
                  <a href="#tcStar" class="anchor" title="Link to tcStar">#</a>
               </h3>
               
               <p>tcStar typechecks an ODEREF node, which may be an expression or a type.</p>
               
               <pre><code>func tcStar(n *ir.StarExpr, top int) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcStringHeader" data-name="tcStringHeader">
               <h3>
                  tcStringHeader 
                  <span class="badge">function</span>
                  
                  <a href="#tcStringHeader" class="anchor" title="Link to tcStringHeader">#</a>
               </h3>
               
               <p>tcStringHeader typechecks an OSTRINGHEADER node.</p>
               
               <pre><code>func tcStringHeader(n *ir.StringHeaderExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcStructLitKey" data-name="tcStructLitKey">
               <h3>
                  tcStructLitKey 
                  <span class="badge">function</span>
                  
                  <a href="#tcStructLitKey" class="anchor" title="Link to tcStructLitKey">#</a>
               </h3>
               
               <p>tcStructLitKey typechecks an OKEY node that appeared within a
struct literal.</p>
               
               <pre><code>func tcStructLitKey(typ *types.Type, kv *ir.KeyExpr) *ir.StructKeyExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcSwitch" data-name="tcSwitch">
               <h3>
                  tcSwitch 
                  <span class="badge">function</span>
                  
                  <a href="#tcSwitch" class="anchor" title="Link to tcSwitch">#</a>
               </h3>
               
               <p>tcSwitch typechecks a switch statement.</p>
               
               <pre><code>func tcSwitch(n *ir.SwitchStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcSwitchExpr" data-name="tcSwitchExpr">
               <h3>
                  tcSwitchExpr 
                  <span class="badge">function</span>
                  
                  <a href="#tcSwitchExpr" class="anchor" title="Link to tcSwitchExpr">#</a>
               </h3>
               
               <pre><code>func tcSwitchExpr(n *ir.SwitchStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcSwitchType" data-name="tcSwitchType">
               <h3>
                  tcSwitchType 
                  <span class="badge">function</span>
                  
                  <a href="#tcSwitchType" class="anchor" title="Link to tcSwitchType">#</a>
               </h3>
               
               <pre><code>func tcSwitchType(n *ir.SwitchStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcUnaryArith" data-name="tcUnaryArith">
               <h3>
                  tcUnaryArith 
                  <span class="badge">function</span>
                  
                  <a href="#tcUnaryArith" class="anchor" title="Link to tcUnaryArith">#</a>
               </h3>
               
               <p>tcUnaryArith typechecks a unary arithmetic expression.</p>
               
               <pre><code>func tcUnaryArith(n *ir.UnaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcUnsafeAdd" data-name="tcUnsafeAdd">
               <h3>
                  tcUnsafeAdd 
                  <span class="badge">function</span>
                  
                  <a href="#tcUnsafeAdd" class="anchor" title="Link to tcUnsafeAdd">#</a>
               </h3>
               
               <p>tcUnsafeAdd typechecks an OUNSAFEADD node.</p>
               
               <pre><code>func tcUnsafeAdd(n *ir.BinaryExpr) *ir.BinaryExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcUnsafeData" data-name="tcUnsafeData">
               <h3>
                  tcUnsafeData 
                  <span class="badge">function</span>
                  
                  <a href="#tcUnsafeData" class="anchor" title="Link to tcUnsafeData">#</a>
               </h3>
               
               <p>tcUnsafeData typechecks an OUNSAFESLICEDATA or OUNSAFESTRINGDATA node.</p>
               
               <pre><code>func tcUnsafeData(n *ir.UnaryExpr) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcUnsafeSlice" data-name="tcUnsafeSlice">
               <h3>
                  tcUnsafeSlice 
                  <span class="badge">function</span>
                  
                  <a href="#tcUnsafeSlice" class="anchor" title="Link to tcUnsafeSlice">#</a>
               </h3>
               
               <p>tcUnsafeSlice typechecks an OUNSAFESLICE node.</p>
               
               <pre><code>func tcUnsafeSlice(n *ir.BinaryExpr) *ir.BinaryExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tcUnsafeString" data-name="tcUnsafeString">
               <h3>
                  tcUnsafeString 
                  <span class="badge">function</span>
                  
                  <a href="#tcUnsafeString" class="anchor" title="Link to tcUnsafeString">#</a>
               </h3>
               
               <p>tcUnsafeString typechecks an OUNSAFESTRING node.</p>
               
               <pre><code>func tcUnsafeString(n *ir.BinaryExpr) *ir.BinaryExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tocplx" data-name="tocplx">
               <h3>
                  tocplx 
                  <span class="badge">function</span>
                  
                  <a href="#tocplx" class="anchor" title="Link to tocplx">#</a>
               </h3>
               
               <pre><code>func tocplx(v constant.Value) constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toflt" data-name="toflt">
               <h3>
                  toflt 
                  <span class="badge">function</span>
                  
                  <a href="#toflt" class="anchor" title="Link to toflt">#</a>
               </h3>
               
               <pre><code>func toflt(v constant.Value) constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toint" data-name="toint">
               <h3>
                  toint 
                  <span class="badge">function</span>
                  
                  <a href="#toint" class="anchor" title="Link to toint">#</a>
               </h3>
               
               <pre><code>func toint(v constant.Value) constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tostr" data-name="tostr">
               <h3>
                  tostr 
                  <span class="badge">function</span>
                  
                  <a href="#tostr" class="anchor" title="Link to tostr">#</a>
               </h3>
               
               <pre><code>func tostr(v constant.Value) constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tracePrint" data-name="tracePrint">
               <h3>
                  tracePrint 
                  <span class="badge">function</span>
                  
                  <a href="#tracePrint" class="anchor" title="Link to tracePrint">#</a>
               </h3>
               
               <pre><code>func tracePrint(title string, n ir.Node) (func(np *ir.Node))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trunccmplxlit" data-name="trunccmplxlit">
               <h3>
                  trunccmplxlit 
                  <span class="badge">function</span>
                  
                  <a href="#trunccmplxlit" class="anchor" title="Link to trunccmplxlit">#</a>
               </h3>
               
               <p>truncate Real and Imag parts of Mpcplx to 32-bit or 64-bit
precision, according to type; return truncated value. In case of
overflow, calls Errorf but does not truncate the input value.</p>
               
               <pre><code>func trunccmplxlit(v constant.Value, t *types.Type) constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="truncfltlit" data-name="truncfltlit">
               <h3>
                  truncfltlit 
                  <span class="badge">function</span>
                  
                  <a href="#truncfltlit" class="anchor" title="Link to truncfltlit">#</a>
               </h3>
               
               <p>truncate float literal fv to 32-bit or 64-bit precision
according to type; return truncated value.</p>
               
               <pre><code>func truncfltlit(v constant.Value, t *types.Type) constant.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typecheck" data-name="typecheck">
               <h3>
                  typecheck 
                  <span class="badge">function</span>
                  
                  <a href="#typecheck" class="anchor" title="Link to typecheck">#</a>
               </h3>
               
               <p>typecheck type checks node n.
The result of typecheck MUST be assigned back to n, e.g.
n.Left = typecheck(n.Left, top)</p>
               
               <pre><code>func typecheck(n ir.Node, top int) (res ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typecheck1" data-name="typecheck1">
               <h3>
                  typecheck1 
                  <span class="badge">function</span>
                  
                  <a href="#typecheck1" class="anchor" title="Link to typecheck1">#</a>
               </h3>
               
               <p>typecheck1 should ONLY be called from typecheck.</p>
               
               <pre><code>func typecheck1(n ir.Node, top int) ir.Node</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typecheckargs" data-name="typecheckargs">
               <h3>
                  typecheckargs 
                  <span class="badge">function</span>
                  
                  <a href="#typecheckargs" class="anchor" title="Link to typecheckargs">#</a>
               </h3>
               
               <pre><code>func typecheckargs(n ir.InitNode)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typecheckarraylit" data-name="typecheckarraylit">
               <h3>
                  typecheckarraylit 
                  <span class="badge">function</span>
                  
                  <a href="#typecheckarraylit" class="anchor" title="Link to typecheckarraylit">#</a>
               </h3>
               
               <p>typecheckarraylit type-checks a sequence of slice/array literal elements.</p>
               
               <pre><code>func typecheckarraylit(elemType *types.Type, bound int64, elts []ir.Node, ctx string) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typecheckaste" data-name="typecheckaste">
               <h3>
                  typecheckaste 
                  <span class="badge">function</span>
                  
                  <a href="#typecheckaste" class="anchor" title="Link to typecheckaste">#</a>
               </h3>
               
               <p>typecheck assignment: type list = expression list</p>
               
               <pre><code>func typecheckaste(op ir.Op, call ir.Node, isddd bool, params []*types.Field, nl ir.Nodes, desc func() string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typecheckrangeExpr" data-name="typecheckrangeExpr">
               <h3>
                  typecheckrangeExpr 
                  <span class="badge">function</span>
                  
                  <a href="#typecheckrangeExpr" class="anchor" title="Link to typecheckrangeExpr">#</a>
               </h3>
               
               <pre><code>func typecheckrangeExpr(n *ir.RangeStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typecheckslice" data-name="typecheckslice">
               <h3>
                  typecheckslice 
                  <span class="badge">function</span>
                  
                  <a href="#typecheckslice" class="anchor" title="Link to typecheckslice">#</a>
               </h3>
               
               <pre><code>func typecheckslice(l []ir.Node, top int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typekind" data-name="typekind">
               <h3>
                  typekind 
                  <span class="badge">function</span>
                  
                  <a href="#typekind" class="anchor" title="Link to typekind">#</a>
               </h3>
               
               <pre><code>func typekind(t *types.Type) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="visible" data-name="visible">
               <h3>
                  visible 
                  <span class="badge">function</span>
                  
                  <a href="#visible" class="anchor" title="Link to visible">#</a>
               </h3>
               
               <p>visible reports whether sym is exported or locally defined.</p>
               
               <pre><code>func visible(sym *types.Sym) bool</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>