<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - io</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="io_fs-docs.html">fs</a>
         <br />
         
         <a href="io_ioutil-docs.html">ioutil</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>io</code>
         </h1>
         <hr />
         
         <article class="global" data-name="ErrClosedPipe">
            <h2>ErrClosedPipe</h2>
            <hr />
            
            <p>ErrClosedPipe is the error used for read or write operations on a closed pipe.</p>
            
            <pre><code>ErrClosedPipe</code></pre>
         </article>
         
         <article class="global" data-name="ErrInvalidWrite">
            <h2>ErrInvalidWrite</h2>
            <hr />
            
            <p>exported for test</p>
            
            <pre><code>ErrInvalidWrite</code></pre>
         </article>
         
         <article class="global" data-name="ErrWhence">
            <h2>ErrWhence</h2>
            <hr />
            
            <pre><code>ErrWhence</code></pre>
         </article>
         
         <article class="global" data-name="ErrOffset">
            <h2>ErrOffset</h2>
            <hr />
            
            <pre><code>ErrOffset</code></pre>
         </article>
         
         <article class="global" data-name="SeekStart">
            <h2>SeekStart</h2>
            <hr />
            
            <p>Seek whence values.</p>
            
            <pre><code>SeekStart</code></pre>
         </article>
         
         <article class="global" data-name="SeekCurrent">
            <h2>SeekCurrent</h2>
            <hr />
            
            <p>Seek whence values.</p>
            
            <pre><code>SeekCurrent</code></pre>
         </article>
         
         <article class="global" data-name="SeekEnd">
            <h2>SeekEnd</h2>
            <hr />
            
            <p>Seek whence values.</p>
            
            <pre><code>SeekEnd</code></pre>
         </article>
         
         <article class="global" data-name="ErrShortWrite">
            <h2>ErrShortWrite</h2>
            <hr />
            
            <p>ErrShortWrite means that a write accepted fewer bytes than requested
but failed to return an explicit error.</p>
            
            <pre><code>ErrShortWrite</code></pre>
         </article>
         
         <article class="global" data-name="errInvalidWrite">
            <h2>errInvalidWrite</h2>
            <hr />
            
            <p>errInvalidWrite means that a write returned an impossible count.</p>
            
            <pre><code>errInvalidWrite</code></pre>
         </article>
         
         <article class="global" data-name="ErrShortBuffer">
            <h2>ErrShortBuffer</h2>
            <hr />
            
            <p>ErrShortBuffer means that a read required a longer buffer than was provided.</p>
            
            <pre><code>ErrShortBuffer</code></pre>
         </article>
         
         <article class="global" data-name="EOF">
            <h2>EOF</h2>
            <hr />
            
            <p>EOF is the error returned by Read when no more input is available.
(Read must return EOF itself, not an error wrapping EOF,
because callers will test for EOF using ==.)
Functions should return EOF only to signal a graceful end of input.
If the EOF occurs unexpectedly in a structured data stream,
the appropriate error is either [ErrUnexpectedEOF] or some other error
giving more detail.</p>
            
            <pre><code>EOF</code></pre>
         </article>
         
         <article class="global" data-name="ErrUnexpectedEOF">
            <h2>ErrUnexpectedEOF</h2>
            <hr />
            
            <p>ErrUnexpectedEOF means that EOF was encountered in the
middle of reading a fixed-size block or data structure.</p>
            
            <pre><code>ErrUnexpectedEOF</code></pre>
         </article>
         
         <article class="global" data-name="ErrNoProgress">
            <h2>ErrNoProgress</h2>
            <hr />
            
            <p>ErrNoProgress is returned by some clients of a [Reader] when
many calls to Read have failed to return any data or error,
usually the sign of a broken [Reader] implementation.</p>
            
            <pre><code>ErrNoProgress</code></pre>
         </article>
         
         <article class="global" data-name="errWhence">
            <h2>errWhence</h2>
            <hr />
            
            <pre><code>errWhence</code></pre>
         </article>
         
         <article class="global" data-name="errOffset">
            <h2>errOffset</h2>
            <hr />
            
            <pre><code>errOffset</code></pre>
         </article>
         
         <article class="global" data-name="Discard">
            <h2>Discard</h2>
            <hr />
            
            <p>Discard is a [Writer] on which all Write calls succeed
without doing anything.</p>
            
            <pre><code>Discard Writer</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <p>discard implements ReaderFrom as an optimization so Copy to
io.Discard can avoid doing unnecessary work.</p>
            
            <pre><code>_ ReaderFrom</code></pre>
         </article>
         
         <article class="global" data-name="blackHolePool">
            <h2>blackHolePool</h2>
            <hr />
            
            <pre><code>blackHolePool</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ WriterTo</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ StringWriter</code></pre>
         </article>
          
         <article class="struct" data-name="onceError">
            <h2>type onceError struct</h2>
            <hr />
            
            <p>onceError is an object that will only store an error once.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">sync.Mutex
err error</code></pre>
         </article>
         
         <article class="struct" data-name="pipe">
            <h2>type pipe struct</h2>
            <hr />
            
            <p>A pipe is the shared pipe structure underlying PipeReader and PipeWriter.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">wrMu sync.Mutex
wrCh *ast.ChanType
rdCh *ast.ChanType
once sync.Once
done *ast.ChanType
rerr onceError
werr onceError</code></pre>
         </article>
         
         <article class="struct" data-name="PipeReader">
            <h2>type PipeReader struct</h2>
            <hr />
            
            <p>A PipeReader is the read half of a pipe.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pipe</code></pre>
         </article>
         
         <article class="struct" data-name="PipeWriter">
            <h2>type PipeWriter struct</h2>
            <hr />
            
            <p>A PipeWriter is the write half of a pipe.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">r PipeReader</code></pre>
         </article>
         
         <article class="struct" data-name="LimitedReader">
            <h2>type LimitedReader struct</h2>
            <hr />
            
            <p>A LimitedReader reads from R but limits the amount of
data returned to just N bytes. Each call to Read
updates N to reflect the new amount remaining.
Read returns EOF when N <= 0 or when the underlying R returns EOF.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">R Reader
N int64</code></pre>
         </article>
         
         <article class="struct" data-name="SectionReader">
            <h2>type SectionReader struct</h2>
            <hr />
            
            <p>SectionReader implements Read, Seek, and ReadAt on a section
of an underlying [ReaderAt].</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">r ReaderAt
base int64
off int64
limit int64
n int64</code></pre>
         </article>
         
         <article class="struct" data-name="OffsetWriter">
            <h2>type OffsetWriter struct</h2>
            <hr />
            
            <p>An OffsetWriter maps writes at offset base to offset base+off in the underlying writer.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">w WriterAt
base int64
off int64</code></pre>
         </article>
         
         <article class="struct" data-name="teeReader">
            <h2>type teeReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">r Reader
w Writer</code></pre>
         </article>
         
         <article class="struct" data-name="discard">
            <h2>type discard struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="nopCloser">
            <h2>type nopCloser struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Reader</code></pre>
         </article>
         
         <article class="struct" data-name="nopCloserWriterTo">
            <h2>type nopCloserWriterTo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Reader</code></pre>
         </article>
         
         <article class="struct" data-name="eofReader">
            <h2>type eofReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="multiReader">
            <h2>type multiReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">readers []Reader</code></pre>
         </article>
         
         <article class="struct" data-name="multiWriter">
            <h2>type multiWriter struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">writers []Writer</code></pre>
         </article>
          
         <article class="function" data-name="Store">
            <h2>Store</h2>
            <hr />
            
            <pre><code>func Store(err error)</code></pre>
         </article>
         
         <article class="function" data-name="Load">
            <h2>Load</h2>
            <hr />
            
            <pre><code>func Load() error</code></pre>
         </article>
         
         <article class="function" data-name="read">
            <h2>read</h2>
            <hr />
            
            <pre><code>func read(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="closeRead">
            <h2>closeRead</h2>
            <hr />
            
            <pre><code>func closeRead(err error) error</code></pre>
         </article>
         
         <article class="function" data-name="write">
            <h2>write</h2>
            <hr />
            
            <pre><code>func write(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="closeWrite">
            <h2>closeWrite</h2>
            <hr />
            
            <pre><code>func closeWrite(err error) error</code></pre>
         </article>
         
         <article class="function" data-name="readCloseError">
            <h2>readCloseError</h2>
            <hr />
            
            <p>readCloseError is considered internal to the pipe type.</p>
            
            <pre><code>func readCloseError() error</code></pre>
         </article>
         
         <article class="function" data-name="writeCloseError">
            <h2>writeCloseError</h2>
            <hr />
            
            <p>writeCloseError is considered internal to the pipe type.</p>
            
            <pre><code>func writeCloseError() error</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <p>Read implements the standard Read interface:
it reads data from the pipe, blocking until a writer
arrives or the write end is closed.
If the write end is closed with an error, that error is
returned as err; otherwise err is EOF.</p>
            
            <pre><code>func Read(data []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close closes the reader; subsequent writes to the
write half of the pipe will return the error [ErrClosedPipe].</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="CloseWithError">
            <h2>CloseWithError</h2>
            <hr />
            
            <p>CloseWithError closes the reader; subsequent writes
to the write half of the pipe will return the error err.

CloseWithError never overwrites the previous error if it exists
and always returns nil.</p>
            
            <pre><code>func CloseWithError(err error) error</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write implements the standard Write interface:
it writes data to the pipe, blocking until one or more readers
have consumed all the data or the read end is closed.
If the read end is closed with an error, that err is
returned as err; otherwise err is [ErrClosedPipe].</p>
            
            <pre><code>func Write(data []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close closes the writer; subsequent reads from the
read half of the pipe will return no bytes and EOF.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="CloseWithError">
            <h2>CloseWithError</h2>
            <hr />
            
            <p>CloseWithError closes the writer; subsequent reads from the
read half of the pipe will return no bytes and the error err,
or EOF if err is nil.

CloseWithError never overwrites the previous error if it exists
and always returns nil.</p>
            
            <pre><code>func CloseWithError(err error) error</code></pre>
         </article>
         
         <article class="function" data-name="Pipe">
            <h2>Pipe</h2>
            <hr />
            
            <p>Pipe creates a synchronous in-memory pipe.
It can be used to connect code expecting an [io.Reader]
with code expecting an [io.Writer].

Reads and Writes on the pipe are matched one to one
except when multiple Reads are needed to consume a single Write.
That is, each Write to the [PipeWriter] blocks until it has satisfied
one or more Reads from the [PipeReader] that fully consume
the written data.
The data is copied directly from the Write to the corresponding
Read (or Reads); there is no internal buffering.

It is safe to call Read and Write in parallel with each other or with Close.
Parallel calls to Read and parallel calls to Write are also safe:
the individual calls will be gated sequentially.</p>
            
            <pre><code>func Pipe() (*PipeReader, *PipeWriter)</code></pre>
         </article>
         
         <article class="function" data-name="WriteString">
            <h2>WriteString</h2>
            <hr />
            
            <p>WriteString writes the contents of the string s to w, which accepts a slice of bytes.
If w implements [StringWriter], [StringWriter.WriteString] is invoked directly.
Otherwise, [Writer.Write] is called exactly once.</p>
            
            <pre><code>func WriteString(w Writer, s string) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadAtLeast">
            <h2>ReadAtLeast</h2>
            <hr />
            
            <p>ReadAtLeast reads from r into buf until it has read at least min bytes.
It returns the number of bytes copied and an error if fewer bytes were read.
The error is EOF only if no bytes were read.
If an EOF happens after reading fewer than min bytes,
ReadAtLeast returns [ErrUnexpectedEOF].
If min is greater than the length of buf, ReadAtLeast returns [ErrShortBuffer].
On return, n >= min if and only if err == nil.
If r returns an error having read at least min bytes, the error is dropped.</p>
            
            <pre><code>func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadFull">
            <h2>ReadFull</h2>
            <hr />
            
            <p>ReadFull reads exactly len(buf) bytes from r into buf.
It returns the number of bytes copied and an error if fewer bytes were read.
The error is EOF only if no bytes were read.
If an EOF happens after reading some but not all the bytes,
ReadFull returns [ErrUnexpectedEOF].
On return, n == len(buf) if and only if err == nil.
If r returns an error having read at least len(buf) bytes, the error is dropped.</p>
            
            <pre><code>func ReadFull(r Reader, buf []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="CopyN">
            <h2>CopyN</h2>
            <hr />
            
            <p>CopyN copies n bytes (or until an error) from src to dst.
It returns the number of bytes copied and the earliest
error encountered while copying.
On return, written == n if and only if err == nil.

If dst implements [ReaderFrom], the copy is implemented using it.</p>
            
            <pre><code>func CopyN(dst Writer, src Reader, n int64) (written int64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <p>Copy copies from src to dst until either EOF is reached
on src or an error occurs. It returns the number of bytes
copied and the first error encountered while copying, if any.

A successful Copy returns err == nil, not err == EOF.
Because Copy is defined to read from src until EOF, it does
not treat an EOF from Read as an error to be reported.

If src implements [WriterTo],
the copy is implemented by calling src.WriteTo(dst).
Otherwise, if dst implements [ReaderFrom],
the copy is implemented by calling dst.ReadFrom(src).</p>
            
            <pre><code>func Copy(dst Writer, src Reader) (written int64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="CopyBuffer">
            <h2>CopyBuffer</h2>
            <hr />
            
            <p>CopyBuffer is identical to Copy except that it stages through the
provided buffer (if one is required) rather than allocating a
temporary one. If buf is nil, one is allocated; otherwise if it has
zero length, CopyBuffer panics.

If either src implements [WriterTo] or dst implements [ReaderFrom],
buf will not be used to perform the copy.</p>
            
            <pre><code>func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="copyBuffer">
            <h2>copyBuffer</h2>
            <hr />
            
            <p>copyBuffer is the actual implementation of Copy and CopyBuffer.
if buf is nil, one is allocated.</p>
            
            <pre><code>func copyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="LimitReader">
            <h2>LimitReader</h2>
            <hr />
            
            <p>LimitReader returns a Reader that reads from r
but stops with EOF after n bytes.
The underlying implementation is a *LimitedReader.</p>
            
            <pre><code>func LimitReader(r Reader, n int64) Reader</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="NewSectionReader">
            <h2>NewSectionReader</h2>
            <hr />
            
            <p>NewSectionReader returns a [SectionReader] that reads from r
starting at offset off and stops with EOF after n bytes.</p>
            
            <pre><code>func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Seek">
            <h2>Seek</h2>
            <hr />
            
            <pre><code>func Seek(offset int64, whence int) (int64, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadAt">
            <h2>ReadAt</h2>
            <hr />
            
            <pre><code>func ReadAt(p []byte, off int64) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Size">
            <h2>Size</h2>
            <hr />
            
            <p>Size returns the size of the section in bytes.</p>
            
            <pre><code>func Size() int64</code></pre>
         </article>
         
         <article class="function" data-name="Outer">
            <h2>Outer</h2>
            <hr />
            
            <p>Outer returns the underlying [ReaderAt] and offsets for the section.

The returned values are the same that were passed to [NewSectionReader]
when the [SectionReader] was created.</p>
            
            <pre><code>func Outer() (r ReaderAt, off int64, n int64)</code></pre>
         </article>
         
         <article class="function" data-name="NewOffsetWriter">
            <h2>NewOffsetWriter</h2>
            <hr />
            
            <p>NewOffsetWriter returns an [OffsetWriter] that writes to w
starting at offset off.</p>
            
            <pre><code>func NewOffsetWriter(w WriterAt, off int64) *OffsetWriter</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteAt">
            <h2>WriteAt</h2>
            <hr />
            
            <pre><code>func WriteAt(p []byte, off int64) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Seek">
            <h2>Seek</h2>
            <hr />
            
            <pre><code>func Seek(offset int64, whence int) (int64, error)</code></pre>
         </article>
         
         <article class="function" data-name="TeeReader">
            <h2>TeeReader</h2>
            <hr />
            
            <p>TeeReader returns a [Reader] that writes to w what it reads from r.
All reads from r performed through it are matched with
corresponding writes to w. There is no internal buffering -
the write must complete before the read completes.
Any error encountered while writing is reported as a read error.</p>
            
            <pre><code>func TeeReader(r Reader, w Writer) Reader</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteString">
            <h2>WriteString</h2>
            <hr />
            
            <pre><code>func WriteString(s string) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadFrom">
            <h2>ReadFrom</h2>
            <hr />
            
            <pre><code>func ReadFrom(r Reader) (n int64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="NopCloser">
            <h2>NopCloser</h2>
            <hr />
            
            <p>NopCloser returns a [ReadCloser] with a no-op Close method wrapping
the provided [Reader] r.
If r implements [WriterTo], the returned [ReadCloser] will implement [WriterTo]
by forwarding calls to r.</p>
            
            <pre><code>func NopCloser(r Reader) ReadCloser</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="WriteTo">
            <h2>WriteTo</h2>
            <hr />
            
            <pre><code>func WriteTo(w Writer) (n int64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadAll">
            <h2>ReadAll</h2>
            <hr />
            
            <p>ReadAll reads from r until an error or EOF and returns the data it read.
A successful call returns err == nil, not err == EOF. Because ReadAll is
defined to read from src until EOF, it does not treat an EOF from Read
as an error to be reported.</p>
            
            <pre><code>func ReadAll(r Reader) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read([]byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteTo">
            <h2>WriteTo</h2>
            <hr />
            
            <pre><code>func WriteTo(w Writer) (sum int64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="writeToWithBuffer">
            <h2>writeToWithBuffer</h2>
            <hr />
            
            <pre><code>func writeToWithBuffer(w Writer, buf []byte) (sum int64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="MultiReader">
            <h2>MultiReader</h2>
            <hr />
            
            <p>MultiReader returns a Reader that's the logical concatenation of
the provided input readers. They're read sequentially. Once all
inputs have returned EOF, Read will return EOF.  If any of the readers
return a non-nil, non-EOF error, Read will return that error.</p>
            
            <pre><code>func MultiReader(readers ...Reader) Reader</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteString">
            <h2>WriteString</h2>
            <hr />
            
            <pre><code>func WriteString(s string) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="MultiWriter">
            <h2>MultiWriter</h2>
            <hr />
            
            <p>MultiWriter creates a writer that duplicates its writes to all the
provided writers, similar to the Unix tee(1) command.

Each write is written to each listed writer, one at a time.
If a listed writer returns an error, that overall write operation
stops and returns the error; it does not continue down the list.</p>
            
            <pre><code>func MultiWriter(writers ...Writer) Writer</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
