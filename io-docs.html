<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - io</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="io_fs-docs.html">fs</a></li>
               
               <li><a href="io_ioutil-docs.html">ioutil</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                 
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>io</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"errors"
"sync"
"errors"
"sync"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="Discard">
               <h3>
                  Discard 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Discard is a [Writer] on which all Write calls succeed
without doing anything.</p>
               
               <pre><code>var Discard Writer = discard{...}</code></pre>
            </article>
            
            <article class="global" data-name="EOF">
               <h3>
                  EOF 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>EOF is the error returned by Read when no more input is available.
(Read must return EOF itself, not an error wrapping EOF,
because callers will test for EOF using ==.)
Functions should return EOF only to signal a graceful end of input.
If the EOF occurs unexpectedly in a structured data stream,
the appropriate error is either [ErrUnexpectedEOF] or some other error
giving more detail.</p>
               
               <pre><code>var EOF = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrClosedPipe">
               <h3>
                  ErrClosedPipe 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrClosedPipe is the error used for read or write operations on a closed pipe.</p>
               
               <pre><code>var ErrClosedPipe = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrNoProgress">
               <h3>
                  ErrNoProgress 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrNoProgress is returned by some clients of a [Reader] when
many calls to Read have failed to return any data or error,
usually the sign of a broken [Reader] implementation.</p>
               
               <pre><code>var ErrNoProgress = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrShortBuffer">
               <h3>
                  ErrShortBuffer 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrShortBuffer means that a read required a longer buffer than was provided.</p>
               
               <pre><code>var ErrShortBuffer = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrShortWrite">
               <h3>
                  ErrShortWrite 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrShortWrite means that a write accepted fewer bytes than requested
but failed to return an explicit error.</p>
               
               <pre><code>var ErrShortWrite = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrUnexpectedEOF">
               <h3>
                  ErrUnexpectedEOF 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrUnexpectedEOF means that EOF was encountered in the
middle of reading a fixed-size block or data structure.</p>
               
               <pre><code>var ErrUnexpectedEOF = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="SeekCurrent">
               <h3>
                  SeekCurrent 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Seek whence values.</p>
               
               <pre><code>const SeekCurrent = 1</code></pre>
            </article>
            
            <article class="global" data-name="SeekEnd">
               <h3>
                  SeekEnd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Seek whence values.</p>
               
               <pre><code>const SeekEnd = 2</code></pre>
            </article>
            
            <article class="global" data-name="SeekStart">
               <h3>
                  SeekStart 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Seek whence values.</p>
               
               <pre><code>const SeekStart = 0</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>discard implements ReaderFrom as an optimization so Copy to
io.Discard can avoid doing unnecessary work.</p>
               
               <pre><code>var _ ReaderFrom = discard{...}</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ WriterTo = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ StringWriter = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="blackHolePool">
               <h3>
                  blackHolePool 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var blackHolePool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global" data-name="errInvalidWrite">
               <h3>
                  errInvalidWrite 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>errInvalidWrite means that a write returned an impossible count.</p>
               
               <pre><code>var errInvalidWrite = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errOffset">
               <h3>
                  errOffset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errOffset = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errWhence">
               <h3>
                  errWhence 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errWhence = *ast.CallExpr</code></pre>
            </article>
            
         </section>
           
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="ByteReader">
               <h3>
                  ByteReader
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ByteReader is the interface that wraps the ReadByte method.
ReadByte reads and returns the next byte from the input or
any error encountered. If ReadByte returns an error, no input
byte was consumed, and the returned byte value is undefined.
ReadByte provides an efficient interface for byte-at-time
processing. A [Reader] that does not implement  ByteReader
can be wrapped using bufio.NewReader to add this method.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ByteReader interface {
ReadByte() (byte, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="ByteScanner">
               <h3>
                  ByteScanner
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ByteScanner is the interface that adds the UnreadByte method to the
basic ReadByte method.
UnreadByte causes the next call to ReadByte to return the last byte read.
If the last operation was not a successful call to ReadByte, UnreadByte may
return an error, unread the last byte read (or the byte prior to the
last-unread byte), or (in implementations that support the [Seeker] interface)
seek to one byte before the current offset.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ByteScanner interface {
ByteReader
UnreadByte() error
}</code></pre>
            </article>
            
            <article class="interface" data-name="ByteWriter">
               <h3>
                  ByteWriter
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ByteWriter is the interface that wraps the WriteByte method.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ByteWriter interface {
WriteByte(c byte) error
}</code></pre>
            </article>
            
            <article class="interface" data-name="Closer">
               <h3>
                  Closer
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Closer is the interface that wraps the basic Close method.
The behavior of Close after the first call is undefined.
Specific implementations may document their own behavior.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Closer interface {
Close() error
}</code></pre>
            </article>
            
            <article class="interface" data-name="ReadCloser">
               <h3>
                  ReadCloser
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ReadCloser is the interface that groups the basic Read and Close methods.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ReadCloser interface {
Reader
Closer
}</code></pre>
            </article>
            
            <article class="interface" data-name="ReadSeekCloser">
               <h3>
                  ReadSeekCloser
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ReadSeekCloser is the interface that groups the basic Read, Seek and Close
methods.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ReadSeekCloser interface {
Reader
Seeker
Closer
}</code></pre>
            </article>
            
            <article class="interface" data-name="ReadSeeker">
               <h3>
                  ReadSeeker
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ReadSeeker is the interface that groups the basic Read and Seek methods.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ReadSeeker interface {
Reader
Seeker
}</code></pre>
            </article>
            
            <article class="interface" data-name="ReadWriteCloser">
               <h3>
                  ReadWriteCloser
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ReadWriteCloser interface {
Reader
Writer
Closer
}</code></pre>
            </article>
            
            <article class="interface" data-name="ReadWriteSeeker">
               <h3>
                  ReadWriteSeeker
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ReadWriteSeeker interface {
Reader
Writer
Seeker
}</code></pre>
            </article>
            
            <article class="interface" data-name="ReadWriter">
               <h3>
                  ReadWriter
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ReadWriter is the interface that groups the basic Read and Write methods.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ReadWriter interface {
Reader
Writer
}</code></pre>
            </article>
            
            <article class="interface" data-name="Reader">
               <h3>
                  Reader
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Reader is the interface that wraps the basic Read method.
Read reads up to len(p) bytes into p. It returns the number of bytes
read (0 <= n <= len(p)) and any error encountered. Even if Read
returns n < len(p), it may use all of p as scratch space during the call.
If some data is available but not len(p) bytes, Read conventionally
returns what is available instead of waiting for more.
When Read encounters an error or end-of-file condition after
successfully reading n > 0 bytes, it returns the number of
bytes read. It may return the (non-nil) error from the same call
or return the error (and n == 0) from a subsequent call.
An instance of this general case is that a Reader returning
a non-zero number of bytes at the end of the input stream may
return either err == EOF or err == nil. The next Read should
return 0, EOF.
Callers should always process the n > 0 bytes returned before
considering the error err. Doing so correctly handles I/O errors
that happen after reading some bytes and also both of the
allowed EOF behaviors.
If len(p) == 0, Read should always return n == 0. It may return a
non-nil error if some error condition is known, such as EOF.
Implementations of Read are discouraged from returning a
zero byte count with a nil error, except when len(p) == 0.
Callers should treat a return of 0 and nil as indicating that
nothing happened; in particular it does not indicate EOF.
Implementations must not retain p.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Reader interface {
Read(p []byte) (n int, err error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="ReaderAt">
               <h3>
                  ReaderAt
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ReaderAt is the interface that wraps the basic ReadAt method.
ReadAt reads len(p) bytes into p starting at offset off in the
underlying input source. It returns the number of bytes
read (0 <= n <= len(p)) and any error encountered.
When ReadAt returns n < len(p), it returns a non-nil error
explaining why more bytes were not returned. In this respect,
ReadAt is stricter than Read.
Even if ReadAt returns n < len(p), it may use all of p as scratch
space during the call. If some data is available but not len(p) bytes,
ReadAt blocks until either all the data is available or an error occurs.
In this respect ReadAt is different from Read.
If the n = len(p) bytes returned by ReadAt are at the end of the
input source, ReadAt may return either err == EOF or err == nil.
If ReadAt is reading from an input source with a seek offset,
ReadAt should not affect nor be affected by the underlying
seek offset.
Clients of ReadAt can execute parallel ReadAt calls on the
same input source.
Implementations must not retain p.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ReaderAt interface {
ReadAt(p []byte, off int64) (n int, err error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="ReaderFrom">
               <h3>
                  ReaderFrom
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ReaderFrom is the interface that wraps the ReadFrom method.
ReadFrom reads data from r until EOF or error.
The return value n is the number of bytes read.
Any error except EOF encountered during the read is also returned.
The [Copy] function uses [ReaderFrom] if available.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ReaderFrom interface {
ReadFrom(r Reader) (n int64, err error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="RuneReader">
               <h3>
                  RuneReader
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>RuneReader is the interface that wraps the ReadRune method.
ReadRune reads a single encoded Unicode character
and returns the rune and its size in bytes. If no character is
available, err will be set.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type RuneReader interface {
ReadRune() (r rune, size int, err error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="RuneScanner">
               <h3>
                  RuneScanner
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>RuneScanner is the interface that adds the UnreadRune method to the
basic ReadRune method.
UnreadRune causes the next call to ReadRune to return the last rune read.
If the last operation was not a successful call to ReadRune, UnreadRune may
return an error, unread the last rune read (or the rune prior to the
last-unread rune), or (in implementations that support the [Seeker] interface)
seek to the start of the rune before the current offset.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type RuneScanner interface {
RuneReader
UnreadRune() error
}</code></pre>
            </article>
            
            <article class="interface" data-name="Seeker">
               <h3>
                  Seeker
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Seeker is the interface that wraps the basic Seek method.
Seek sets the offset for the next Read or Write to offset,
interpreted according to whence:
[SeekStart] means relative to the start of the file,
[SeekCurrent] means relative to the current offset, and
[SeekEnd] means relative to the end
(for example, offset = -2 specifies the penultimate byte of the file).
Seek returns the new offset relative to the start of the
file or an error, if any.
Seeking to an offset before the start of the file is an error.
Seeking to any positive offset may be allowed, but if the new offset exceeds
the size of the underlying object the behavior of subsequent I/O operations
is implementation-dependent.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Seeker interface {
Seek(offset int64, whence int) (int64, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="StringWriter">
               <h3>
                  StringWriter
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>StringWriter is the interface that wraps the WriteString method.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type StringWriter interface {
WriteString(s string) (n int, err error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="WriteCloser">
               <h3>
                  WriteCloser
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>WriteCloser is the interface that groups the basic Write and Close methods.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type WriteCloser interface {
Writer
Closer
}</code></pre>
            </article>
            
            <article class="interface" data-name="WriteSeeker">
               <h3>
                  WriteSeeker
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>WriteSeeker is the interface that groups the basic Write and Seek methods.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type WriteSeeker interface {
Writer
Seeker
}</code></pre>
            </article>
            
            <article class="interface" data-name="Writer">
               <h3>
                  Writer
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Writer is the interface that wraps the basic Write method.
Write writes len(p) bytes from p to the underlying data stream.
It returns the number of bytes written from p (0 <= n <= len(p))
and any error encountered that caused the write to stop early.
Write must return a non-nil error if it returns n < len(p).
Write must not modify the slice data, even temporarily.
Implementations must not retain p.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Writer interface {
Write(p []byte) (n int, err error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="WriterAt">
               <h3>
                  WriterAt
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>WriterAt is the interface that wraps the basic WriteAt method.
WriteAt writes len(p) bytes from p to the underlying data stream
at offset off. It returns the number of bytes written from p (0 <= n <= len(p))
and any error encountered that caused the write to stop early.
WriteAt must return a non-nil error if it returns n < len(p).
If WriteAt is writing to a destination with a seek offset,
WriteAt should not affect nor be affected by the underlying
seek offset.
Clients of WriteAt can execute parallel WriteAt calls on the same
destination if the ranges do not overlap.
Implementations must not retain p.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type WriterAt interface {
WriteAt(p []byte, off int64) (n int, err error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="WriterTo">
               <h3>
                  WriterTo
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>WriterTo is the interface that wraps the WriteTo method.
WriteTo writes data to w until there's no more data to write or
when an error occurs. The return value n is the number of bytes
written. Any error encountered during the write is also returned.
The Copy function uses WriterTo if available.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type WriterTo interface {
WriteTo(w Writer) (n int64, err error)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="LimitedReader">
               <h3>
                  LimitedReader
                  <span class="badge">struct</span>
               </h3>
               
               <p>A LimitedReader reads from R but limits the amount of
data returned to just N bytes. Each call to Read
updates N to reflect the new amount remaining.
Read returns EOF when N <= 0 or when the underlying R returns EOF.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type LimitedReader struct {
R Reader
N int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="OffsetWriter">
               <h3>
                  OffsetWriter
                  <span class="badge">struct</span>
               </h3>
               
               <p>An OffsetWriter maps writes at offset base to offset base+off in the underlying writer.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type OffsetWriter struct {
w WriterAt
base int64
off int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="PipeReader">
               <h3>
                  PipeReader
                  <span class="badge">struct</span>
               </h3>
               
               <p>A PipeReader is the read half of a pipe.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type PipeReader struct {
pipe
}</code></pre>
            </article>
            
            <article class="struct" data-name="PipeWriter">
               <h3>
                  PipeWriter
                  <span class="badge">struct</span>
               </h3>
               
               <p>A PipeWriter is the write half of a pipe.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type PipeWriter struct {
r PipeReader
}</code></pre>
            </article>
            
            <article class="struct" data-name="SectionReader">
               <h3>
                  SectionReader
                  <span class="badge">struct</span>
               </h3>
               
               <p>SectionReader implements Read, Seek, and ReadAt on a section
of an underlying [ReaderAt].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SectionReader struct {
r ReaderAt
base int64
off int64
limit int64
n int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="discard">
               <h3>
                  discard
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type discard struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="eofReader">
               <h3>
                  eofReader
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type eofReader struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="multiReader">
               <h3>
                  multiReader
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type multiReader struct {
readers []Reader
}</code></pre>
            </article>
            
            <article class="struct" data-name="multiWriter">
               <h3>
                  multiWriter
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type multiWriter struct {
writers []Writer
}</code></pre>
            </article>
            
            <article class="struct" data-name="nopCloser">
               <h3>
                  nopCloser
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nopCloser struct {
Reader
}</code></pre>
            </article>
            
            <article class="struct" data-name="nopCloserWriterTo">
               <h3>
                  nopCloserWriterTo
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nopCloserWriterTo struct {
Reader
}</code></pre>
            </article>
            
            <article class="struct" data-name="onceError">
               <h3>
                  onceError
                  <span class="badge">struct</span>
               </h3>
               
               <p>onceError is an object that will only store an error once.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type onceError struct {
sync.Mutex
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="pipe">
               <h3>
                  pipe
                  <span class="badge">struct</span>
               </h3>
               
               <p>A pipe is the shared pipe structure underlying PipeReader and PipeWriter.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pipe struct {
wrMu sync.Mutex
wrCh chan []byte
rdCh chan int
once sync.Once
done chan struct{...}
rerr onceError
werr onceError
}</code></pre>
            </article>
            
            <article class="struct" data-name="teeReader">
               <h3>
                  teeReader
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type teeReader struct {
r Reader
w Writer
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close closes the reader; subsequent writes to the
write half of the pipe will return the error [ErrClosedPipe].</p>
               
               <pre><code>func (r *PipeReader) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close closes the writer; subsequent reads from the
read half of the pipe will return no bytes and EOF.</p>
               
               <pre><code>func (w *PipeWriter) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (nopCloser) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (nopCloserWriterTo) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="CloseWithError">
               <h3>
                  CloseWithError 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CloseWithError closes the writer; subsequent reads from the
read half of the pipe will return no bytes and the error err,
or EOF if err is nil.
CloseWithError never overwrites the previous error if it exists
and always returns nil.</p>
               
               <pre><code>func (w *PipeWriter) CloseWithError(err error) error</code></pre>
            </article>
            
            <article class="function" data-name="CloseWithError">
               <h3>
                  CloseWithError 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CloseWithError closes the reader; subsequent writes
to the write half of the pipe will return the error err.
CloseWithError never overwrites the previous error if it exists
and always returns nil.</p>
               
               <pre><code>func (r *PipeReader) CloseWithError(err error) error</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Copy copies from src to dst until either EOF is reached
on src or an error occurs. It returns the number of bytes
copied and the first error encountered while copying, if any.
A successful Copy returns err == nil, not err == EOF.
Because Copy is defined to read from src until EOF, it does
not treat an EOF from Read as an error to be reported.
If src implements [WriterTo],
the copy is implemented by calling src.WriteTo(dst).
Otherwise, if dst implements [ReaderFrom],
the copy is implemented by calling dst.ReadFrom(src).</p>
               
               <pre><code>func Copy(dst Writer, src Reader) (written int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="CopyBuffer">
               <h3>
                  CopyBuffer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CopyBuffer is identical to Copy except that it stages through the
provided buffer (if one is required) rather than allocating a
temporary one. If buf is nil, one is allocated; otherwise if it has
zero length, CopyBuffer panics.
If either src implements [WriterTo] or dst implements [ReaderFrom],
buf will not be used to perform the copy.</p>
               
               <pre><code>func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="CopyN">
               <h3>
                  CopyN 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CopyN copies n bytes (or until an error) from src to dst.
It returns the number of bytes copied and the earliest
error encountered while copying.
On return, written == n if and only if err == nil.
If dst implements [ReaderFrom], the copy is implemented using it.</p>
               
               <pre><code>func CopyN(dst Writer, src Reader, n int64) (written int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="LimitReader">
               <h3>
                  LimitReader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LimitReader returns a Reader that reads from r
but stops with EOF after n bytes.
The underlying implementation is a *LimitedReader.</p>
               
               <pre><code>func LimitReader(r Reader, n int64) Reader</code></pre>
            </article>
            
            <article class="function" data-name="Load">
               <h3>
                  Load 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *onceError) Load() error</code></pre>
            </article>
            
            <article class="function" data-name="MultiReader">
               <h3>
                  MultiReader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MultiReader returns a Reader that's the logical concatenation of
the provided input readers. They're read sequentially. Once all
inputs have returned EOF, Read will return EOF.  If any of the readers
return a non-nil, non-EOF error, Read will return that error.</p>
               
               <pre><code>func MultiReader(readers ...Reader) Reader</code></pre>
            </article>
            
            <article class="function" data-name="MultiWriter">
               <h3>
                  MultiWriter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MultiWriter creates a writer that duplicates its writes to all the
provided writers, similar to the Unix tee(1) command.
Each write is written to each listed writer, one at a time.
If a listed writer returns an error, that overall write operation
stops and returns the error; it does not continue down the list.</p>
               
               <pre><code>func MultiWriter(writers ...Writer) Writer</code></pre>
            </article>
            
            <article class="function" data-name="NewOffsetWriter">
               <h3>
                  NewOffsetWriter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewOffsetWriter returns an [OffsetWriter] that writes to w
starting at offset off.</p>
               
               <pre><code>func NewOffsetWriter(w WriterAt, off int64) *OffsetWriter</code></pre>
            </article>
            
            <article class="function" data-name="NewSectionReader">
               <h3>
                  NewSectionReader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewSectionReader returns a [SectionReader] that reads from r
starting at offset off and stops with EOF after n bytes.</p>
               
               <pre><code>func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader</code></pre>
            </article>
            
            <article class="function" data-name="NopCloser">
               <h3>
                  NopCloser 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NopCloser returns a [ReadCloser] with a no-op Close method wrapping
the provided [Reader] r.
If r implements [WriterTo], the returned [ReadCloser] will implement [WriterTo]
by forwarding calls to r.</p>
               
               <pre><code>func NopCloser(r Reader) ReadCloser</code></pre>
            </article>
            
            <article class="function" data-name="Outer">
               <h3>
                  Outer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Outer returns the underlying [ReaderAt] and offsets for the section.
The returned values are the same that were passed to [NewSectionReader]
when the [SectionReader] was created.</p>
               
               <pre><code>func (s *SectionReader) Outer() (r ReaderAt, off int64, n int64)</code></pre>
            </article>
            
            <article class="function" data-name="Pipe">
               <h3>
                  Pipe 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Pipe creates a synchronous in-memory pipe.
It can be used to connect code expecting an [io.Reader]
with code expecting an [io.Writer].
Reads and Writes on the pipe are matched one to one
except when multiple Reads are needed to consume a single Write.
That is, each Write to the [PipeWriter] blocks until it has satisfied
one or more Reads from the [PipeReader] that fully consume
the written data.
The data is copied directly from the Write to the corresponding
Read (or Reads); there is no internal buffering.
It is safe to call Read and Write in parallel with each other or with Close.
Parallel calls to Read and parallel calls to Write are also safe:
the individual calls will be gated sequentially.</p>
               
               <pre><code>func Pipe() (*PipeReader, *PipeWriter)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (eofReader) Read([]byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mr *multiReader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *teeReader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Read implements the standard Read interface:
it reads data from the pipe, blocking until a writer
arrives or the write end is closed.
If the write end is closed with an error, that error is
returned as err; otherwise err is EOF.</p>
               
               <pre><code>func (r *PipeReader) Read(data []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *SectionReader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *LimitedReader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadAll">
               <h3>
                  ReadAll 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ReadAll reads from r until an error or EOF and returns the data it read.
A successful call returns err == nil, not err == EOF. Because ReadAll is
defined to read from src until EOF, it does not treat an EOF from Read
as an error to be reported.</p>
               
               <pre><code>func ReadAll(r Reader) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadAt">
               <h3>
                  ReadAt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadAtLeast">
               <h3>
                  ReadAtLeast 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ReadAtLeast reads from r into buf until it has read at least min bytes.
It returns the number of bytes copied and an error if fewer bytes were read.
The error is EOF only if no bytes were read.
If an EOF happens after reading fewer than min bytes,
ReadAtLeast returns [ErrUnexpectedEOF].
If min is greater than the length of buf, ReadAtLeast returns [ErrShortBuffer].
On return, n >= min if and only if err == nil.
If r returns an error having read at least min bytes, the error is dropped.</p>
               
               <pre><code>func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (discard) ReadFrom(r Reader) (n int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadFull">
               <h3>
                  ReadFull 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ReadFull reads exactly len(buf) bytes from r into buf.
It returns the number of bytes copied and an error if fewer bytes were read.
The error is EOF only if no bytes were read.
If an EOF happens after reading some but not all the bytes,
ReadFull returns [ErrUnexpectedEOF].
On return, n == len(buf) if and only if err == nil.
If r returns an error having read at least len(buf) bytes, the error is dropped.</p>
               
               <pre><code>func ReadFull(r Reader, buf []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Seek">
               <h3>
                  Seek 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *SectionReader) Seek(offset int64, whence int) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="Seek">
               <h3>
                  Seek 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *OffsetWriter) Seek(offset int64, whence int) (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Size returns the size of the section in bytes.</p>
               
               <pre><code>func (s *SectionReader) Size() int64</code></pre>
            </article>
            
            <article class="function" data-name="Store">
               <h3>
                  Store 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *onceError) Store(err error)</code></pre>
            </article>
            
            <article class="function" data-name="TeeReader">
               <h3>
                  TeeReader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TeeReader returns a [Reader] that writes to w what it reads from r.
All reads from r performed through it are matched with
corresponding writes to w. There is no internal buffering -
the write must complete before the read completes.
Any error encountered while writing is reported as a read error.</p>
               
               <pre><code>func TeeReader(r Reader, w Writer) Reader</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *multiWriter) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (discard) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write implements the standard Write interface:
it writes data to the pipe, blocking until one or more readers
have consumed all the data or the read end is closed.
If the read end is closed with an error, that err is
returned as err; otherwise err is [ErrClosedPipe].</p>
               
               <pre><code>func (w *PipeWriter) Write(data []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *OffsetWriter) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteAt">
               <h3>
                  WriteAt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *OffsetWriter) WriteAt(p []byte, off int64) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *multiWriter) WriteString(s string) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (discard) WriteString(s string) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WriteString writes the contents of the string s to w, which accepts a slice of bytes.
If w implements [StringWriter], [StringWriter.WriteString] is invoked directly.
Otherwise, [Writer.Write] is called exactly once.</p>
               
               <pre><code>func WriteString(w Writer, s string) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c nopCloserWriterTo) WriteTo(w Writer) (n int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mr *multiReader) WriteTo(w Writer) (sum int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="closeRead">
               <h3>
                  closeRead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pipe) closeRead(err error) error</code></pre>
            </article>
            
            <article class="function" data-name="closeWrite">
               <h3>
                  closeWrite 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pipe) closeWrite(err error) error</code></pre>
            </article>
            
            <article class="function" data-name="copyBuffer">
               <h3>
                  copyBuffer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>copyBuffer is the actual implementation of Copy and CopyBuffer.
if buf is nil, one is allocated.</p>
               
               <pre><code>func copyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="read">
               <h3>
                  read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pipe) read(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readCloseError">
               <h3>
                  readCloseError 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>readCloseError is considered internal to the pipe type.</p>
               
               <pre><code>func (p *pipe) readCloseError() error</code></pre>
            </article>
            
            <article class="function" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pipe) write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeCloseError">
               <h3>
                  writeCloseError 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeCloseError is considered internal to the pipe type.</p>
               
               <pre><code>func (p *pipe) writeCloseError() error</code></pre>
            </article>
            
            <article class="function" data-name="writeToWithBuffer">
               <h3>
                  writeToWithBuffer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mr *multiReader) writeToWithBuffer(w Writer, buf []byte) (sum int64, err error)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
