<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - slogtest</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>slogtest</code>
         </h1>
         <hr />
         
         <article class="global" data-name="cases">
            <h2>cases</h2>
            <hr />
            
            <pre><code>cases</code></pre>
         </article>
          
         <article class="struct" data-name="testCase">
            <h2>type testCase struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
explanation string
f func
mod func
checks []check</code></pre>
         </article>
         
         <article class="struct" data-name="wrapper">
            <h2>type wrapper struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">slog.Handler
mod func</code></pre>
         </article>
         
         <article class="struct" data-name="replace">
            <h2>type replace struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">v any</code></pre>
         </article>
          
         <article class="function" data-name="TestHandler">
            <h2>TestHandler</h2>
            <hr />
            
            <p>TestHandler tests a [slog.Handler].
If TestHandler finds any misbehaviors, it returns an error for each,
combined into a single error with [errors.Join].

TestHandler installs the given Handler in a [slog.Logger] and
makes several calls to the Logger's output methods.
The Handler should be enabled for levels Info and above.

The results function is invoked after all such calls.
It should return a slice of map[string]any, one for each call to a Logger output method.
The keys and values of the map should correspond to the keys and values of the Handler's
output. Each group in the output should be represented as its own nested map[string]any.
The standard keys [slog.TimeKey], [slog.LevelKey] and [slog.MessageKey] should be used.

If the Handler outputs JSON, then calling [encoding/json.Unmarshal] with a `map[string]any`
will create the right data structure.

If a Handler intentionally drops an attribute that is checked by a test,
then the results function should check for its absence and add it to the map it returns.</p>
            
            <pre><code>func TestHandler(h slog.Handler, results func) error</code></pre>
         </article>
         
         <article class="function" data-name="Run">
            <h2>Run</h2>
            <hr />
            
            <p>Run exercises a [slog.Handler] on the same test cases as [TestHandler], but
runs each case in a subtest. For each test case, it first calls newHandler to
get an instance of the handler under test, then runs the test case, then
calls result to get the result. If the test case fails, it calls t.Error.</p>
            
            <pre><code>func Run(t *testing.T, newHandler func, result func)</code></pre>
         </article>
         
         <article class="function" data-name="hasKey">
            <h2>hasKey</h2>
            <hr />
            
            <pre><code>func hasKey(key string) check</code></pre>
         </article>
         
         <article class="function" data-name="missingKey">
            <h2>missingKey</h2>
            <hr />
            
            <pre><code>func missingKey(key string) check</code></pre>
         </article>
         
         <article class="function" data-name="hasAttr">
            <h2>hasAttr</h2>
            <hr />
            
            <pre><code>func hasAttr(key string, wantVal any) check</code></pre>
         </article>
         
         <article class="function" data-name="inGroup">
            <h2>inGroup</h2>
            <hr />
            
            <pre><code>func inGroup(name string, c check) check</code></pre>
         </article>
         
         <article class="function" data-name="Handle">
            <h2>Handle</h2>
            <hr />
            
            <pre><code>func Handle(ctx context.Context, r slog.Record) error</code></pre>
         </article>
         
         <article class="function" data-name="withSource">
            <h2>withSource</h2>
            <hr />
            
            <pre><code>func withSource(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="LogValue">
            <h2>LogValue</h2>
            <hr />
            
            <pre><code>func LogValue() slog.Value</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
