<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>vcs - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>vcs</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"encoding/xml"
"fmt"
"io"
"strings"
"bytes"
"errors"
"fmt"
"internal/godebug"
"internal/lazyregexp"
"internal/singleflight"
"io/fs"
"log"
urlpkg "net/url"
"os"
"os/exec"
"path/filepath"
"regexp"
"strconv"
"strings"
"sync"
"time"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/search"
"cmd/go/internal/str"
"cmd/go/internal/web"
"cmd/internal/pathcache"
"golang.org/x/mod/module"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="IgnoreMod" data-name="IgnoreMod">
               <h3>
                  IgnoreMod 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IgnoreMod" class="anchor" title="Link to IgnoreMod">#</a>
               </h3>
               
               <pre><code class="language-go">const IgnoreMod ModuleMode = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PreferMod" data-name="PreferMod">
               <h3>
                  PreferMod 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PreferMod" class="anchor" title="Link to PreferMod">#</a>
               </h3>
               
               <pre><code class="language-go">const PreferMod</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="VCSTestHosts" data-name="VCSTestHosts">
               <h3>
                  VCSTestHosts 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#VCSTestHosts" class="anchor" title="Link to VCSTestHosts">#</a>
               </h3>
               
                  <p class="doc-comment">VCSTestHosts is the set of hosts supported by the vcs-test server.</p>
               
               <pre><code class="language-go">var VCSTestHosts []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="VCSTestIsLocalHost" data-name="VCSTestIsLocalHost">
               <h3>
                  VCSTestIsLocalHost 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#VCSTestIsLocalHost" class="anchor" title="Link to VCSTestIsLocalHost">#</a>
               </h3>
               
                  <p class="doc-comment">VCSTestIsLocalHost reports whether the given URL refers to a local
(loopback) host, such as "localhost" or "127.0.0.1:8080".</p>
               
               <pre><code class="language-go">var VCSTestIsLocalHost func(*urlpkg.URL) bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="VCSTestRepoURL" data-name="VCSTestRepoURL">
               <h3>
                  VCSTestRepoURL 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#VCSTestRepoURL" class="anchor" title="Link to VCSTestRepoURL">#</a>
               </h3>
               
                  <p class="doc-comment">VCSTestRepoURL is the URL of the HTTP server that serves the repos for
vcs-test.golang.org.
In tests, this is set to the URL of an httptest.Server hosting a
cmd/go/internal/vcweb.Server.</p>
               
               <pre><code class="language-go">var VCSTestRepoURL string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="allowmultiplevcs" data-name="allowmultiplevcs">
               <h3>
                  allowmultiplevcs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#allowmultiplevcs" class="anchor" title="Link to allowmultiplevcs">#</a>
               </h3>
               
               <pre><code class="language-go">var allowmultiplevcs = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultGOVCS" data-name="defaultGOVCS">
               <h3>
                  defaultGOVCS 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#defaultGOVCS" class="anchor" title="Link to defaultGOVCS">#</a>
               </h3>
               
                  <p class="doc-comment">defaultGOVCS is the default setting for GOVCS.
Setting GOVCS adds entries ahead of these but does not remove them.
(They are appended to the parsed GOVCS setting.)
The rationale behind allowing only Git and Mercurial is that
these two systems have had the most attention to issues
of being run as clients of untrusted servers. In contrast,
Bazaar, Fossil, and Subversion have primarily been used
in trusted, authenticated environments and are not as well
scrutinized as attack surfaces.
See golang.org/issue/41730 for details.</p>
               
               <pre><code class="language-go">var defaultGOVCS = govcsConfig{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultSecureScheme" data-name="defaultSecureScheme">
               <h3>
                  defaultSecureScheme 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#defaultSecureScheme" class="anchor" title="Link to defaultSecureScheme">#</a>
               </h3>
               
               <pre><code class="language-go">var defaultSecureScheme = map[string]bool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errFossilInfo" data-name="errFossilInfo">
               <h3>
                  errFossilInfo 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errFossilInfo" class="anchor" title="Link to errFossilInfo">#</a>
               </h3>
               
               <pre><code class="language-go">var errFossilInfo = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errUnknownSite" data-name="errUnknownSite">
               <h3>
                  errUnknownSite 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errUnknownSite" class="anchor" title="Link to errUnknownSite">#</a>
               </h3>
               
               <pre><code class="language-go">var errUnknownSite = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fetchCache" data-name="fetchCache">
               <h3>
                  fetchCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#fetchCache" class="anchor" title="Link to fetchCache">#</a>
               </h3>
               
               <pre><code class="language-go">var fetchCache = map[string]fetchResult{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fetchCacheMu" data-name="fetchCacheMu">
               <h3>
                  fetchCacheMu 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#fetchCacheMu" class="anchor" title="Link to fetchCacheMu">#</a>
               </h3>
               
               <pre><code class="language-go">var fetchCacheMu sync.Mutex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fetchGroup" data-name="fetchGroup">
               <h3>
                  fetchGroup 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#fetchGroup" class="anchor" title="Link to fetchGroup">#</a>
               </h3>
               
               <pre><code class="language-go">var fetchGroup singleflight.Group</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fossilRepoName" data-name="fossilRepoName">
               <h3>
                  fossilRepoName 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#fossilRepoName" class="anchor" title="Link to fossilRepoName">#</a>
               </h3>
               
                  <p class="doc-comment">fossilRepoName is the name go get associates with a fossil repository. In the
real world the file can be named anything.</p>
               
               <pre><code class="language-go">const fossilRepoName = ".fossil"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="govcs" data-name="govcs">
               <h3>
                  govcs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#govcs" class="anchor" title="Link to govcs">#</a>
               </h3>
               
               <pre><code class="language-go">var govcs govcsConfig</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="govcsErr" data-name="govcsErr">
               <h3>
                  govcsErr 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#govcsErr" class="anchor" title="Link to govcsErr">#</a>
               </h3>
               
               <pre><code class="language-go">var govcsErr error</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="govcsOnce" data-name="govcsOnce">
               <h3>
                  govcsOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#govcsOnce" class="anchor" title="Link to govcsOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var govcsOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="scpSyntaxRe" data-name="scpSyntaxRe">
               <h3>
                  scpSyntaxRe 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#scpSyntaxRe" class="anchor" title="Link to scpSyntaxRe">#</a>
               </h3>
               
                  <p class="doc-comment">scpSyntaxRe matches the SCP-like addresses used by Git to access
repositories by SSH.</p>
               
               <pre><code class="language-go">var scpSyntaxRe = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vcsBzr" data-name="vcsBzr">
               <h3>
                  vcsBzr 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vcsBzr" class="anchor" title="Link to vcsBzr">#</a>
               </h3>
               
                  <p class="doc-comment">vcsBzr describes how to use Bazaar.</p>
               
               <pre><code class="language-go">var vcsBzr = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vcsFossil" data-name="vcsFossil">
               <h3>
                  vcsFossil 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vcsFossil" class="anchor" title="Link to vcsFossil">#</a>
               </h3>
               
                  <p class="doc-comment">vcsFossil describes how to use Fossil (fossil-scm.org)</p>
               
               <pre><code class="language-go">var vcsFossil = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vcsGit" data-name="vcsGit">
               <h3>
                  vcsGit 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vcsGit" class="anchor" title="Link to vcsGit">#</a>
               </h3>
               
                  <p class="doc-comment">vcsGit describes how to use Git.</p>
               
               <pre><code class="language-go">var vcsGit = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vcsHg" data-name="vcsHg">
               <h3>
                  vcsHg 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vcsHg" class="anchor" title="Link to vcsHg">#</a>
               </h3>
               
                  <p class="doc-comment">vcsHg describes how to use Mercurial.</p>
               
               <pre><code class="language-go">var vcsHg = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vcsList" data-name="vcsList">
               <h3>
                  vcsList 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vcsList" class="anchor" title="Link to vcsList">#</a>
               </h3>
               
                  <p class="doc-comment">vcsList lists the known version control systems</p>
               
               <pre><code class="language-go">var vcsList = []*Cmd{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vcsMod" data-name="vcsMod">
               <h3>
                  vcsMod 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vcsMod" class="anchor" title="Link to vcsMod">#</a>
               </h3>
               
                  <p class="doc-comment">vcsMod is a stub for the "mod" scheme. It's returned by
repoRootForImportPathDynamic, but is otherwise not treated as a VCS command.</p>
               
               <pre><code class="language-go">var vcsMod = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vcsPaths" data-name="vcsPaths">
               <h3>
                  vcsPaths 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vcsPaths" class="anchor" title="Link to vcsPaths">#</a>
               </h3>
               
                  <p class="doc-comment">vcsPaths defines the meaning of import paths referring to
commonly-used VCS hosting sites (github.com/user/dir)
and import paths referring to a fully-qualified importPath
containing a VCS type (foo.com/repo.git/dir)</p>
               
               <pre><code class="language-go">var vcsPaths = []*vcsPath{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vcsPathsAfterDynamic" data-name="vcsPathsAfterDynamic">
               <h3>
                  vcsPathsAfterDynamic 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vcsPathsAfterDynamic" class="anchor" title="Link to vcsPathsAfterDynamic">#</a>
               </h3>
               
                  <p class="doc-comment">vcsPathsAfterDynamic gives additional vcsPaths entries
to try after the dynamic HTML check.
This gives those sites a chance to introduce <meta> tags
as part of a graceful transition away from the hard-coded logic.</p>
               
               <pre><code class="language-go">var vcsPathsAfterDynamic = []*vcsPath{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vcsSvn" data-name="vcsSvn">
               <h3>
                  vcsSvn 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vcsSvn" class="anchor" title="Link to vcsSvn">#</a>
               </h3>
               
                  <p class="doc-comment">vcsSvn describes how to use Subversion.</p>
               
               <pre><code class="language-go">var vcsSvn = *ast.UnaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="ModuleMode" data-name="ModuleMode">
               <h3>
                  ModuleMode
                  <span class="badge type-badge">type</span>
                  <a href="#ModuleMode" class="anchor" title="Link to ModuleMode">#</a>
               </h3>
               
               <p>ModuleMode specifies whether to prefer modules when looking up code sources.</p>
               
               <pre><code class="language-go">type ModuleMode int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="govcsConfig" data-name="govcsConfig">
               <h3>
                  govcsConfig
                  <span class="badge type-badge">type</span>
                  <a href="#govcsConfig" class="anchor" title="Link to govcsConfig">#</a>
               </h3>
               
               <p>A govcsConfig is a full GOVCS configuration.</p>
               
               <pre><code class="language-go">type govcsConfig []govcsRule</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Cmd" data-name="Cmd">
               <h3>
                  Cmd
                  <span class="badge">struct</span>
                  <a href="#Cmd" class="anchor" title="Link to Cmd">#</a>
               </h3>
               
               <p>A Cmd describes how to use a version control system
like Mercurial, Git, or Subversion.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Cmd struct {
Name string
Cmd string
Env []string
RootNames []rootName
CreateCmd []string
DownloadCmd []string
TagCmd []tagCmd
TagLookupCmd []tagCmd
TagSyncCmd []string
TagSyncDefault []string
Scheme []string
PingCmd string
RemoteRepo func(v *Cmd, rootDir string) (remoteRepo string, err error)
ResolveRepo func(v *Cmd, rootDir string, remoteRepo string) (realRepo string, err error)
Status func(v *Cmd, rootDir string) (Status, error)
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ImportMismatchError" data-name="ImportMismatchError">
               <h3>
                  ImportMismatchError
                  <span class="badge">struct</span>
                  <a href="#ImportMismatchError" class="anchor" title="Link to ImportMismatchError">#</a>
               </h3>
               
               <p>An ImportMismatchError is returned where metaImport/s are present
but none match our import path.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ImportMismatchError struct {
importPath string
mismatches []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="RepoRoot" data-name="RepoRoot">
               <h3>
                  RepoRoot
                  <span class="badge">struct</span>
                  <a href="#RepoRoot" class="anchor" title="Link to RepoRoot">#</a>
               </h3>
               
               <p>RepoRoot describes the repository root for a tree of source code.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type RepoRoot struct {
Repo string
Root string
IsCustom bool
VCS *Cmd
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Status" data-name="Status">
               <h3>
                  Status
                  <span class="badge">struct</span>
                  <a href="#Status" class="anchor" title="Link to Status">#</a>
               </h3>
               
               <p>Status is the current state of a local repository.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Status struct {
Revision string
CommitTime time.Time
Uncommitted bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fetchResult" data-name="fetchResult">
               <h3>
                  fetchResult
                  <span class="badge">struct</span>
                  <a href="#fetchResult" class="anchor" title="Link to fetchResult">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fetchResult struct {
url *urlpkg.URL
imports []metaImport
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="govcsRule" data-name="govcsRule">
               <h3>
                  govcsRule
                  <span class="badge">struct</span>
                  <a href="#govcsRule" class="anchor" title="Link to govcsRule">#</a>
               </h3>
               
               <p>A govcsRule is a single GOVCS rule like private:hg|svn.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type govcsRule struct {
pattern string
allowed []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="importError" data-name="importError">
               <h3>
                  importError
                  <span class="badge">struct</span>
                  <a href="#importError" class="anchor" title="Link to importError">#</a>
               </h3>
               
               <p>importError is a copy of load.importError, made to avoid a dependency cycle
on cmd/go/internal/load. It just needs to satisfy load.ImportPathError.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type importError struct {
importPath string
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="metaImport" data-name="metaImport">
               <h3>
                  metaImport
                  <span class="badge">struct</span>
                  <a href="#metaImport" class="anchor" title="Link to metaImport">#</a>
               </h3>
               
               <p>metaImport represents the parsed <meta name="go-import"
content="prefix vcs reporoot" /> tags from HTML files.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type metaImport struct {
Prefix string
VCS string
RepoRoot string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="rootName" data-name="rootName">
               <h3>
                  rootName
                  <span class="badge">struct</span>
                  <a href="#rootName" class="anchor" title="Link to rootName">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type rootName struct {
filename string
isDir bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="tagCmd" data-name="tagCmd">
               <h3>
                  tagCmd
                  <span class="badge">struct</span>
                  <a href="#tagCmd" class="anchor" title="Link to tagCmd">#</a>
               </h3>
               
               <p>A tagCmd describes a command to list available tags
that can be passed to tagSyncCmd.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type tagCmd struct {
cmd string
pattern string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="vcsNotFoundError" data-name="vcsNotFoundError">
               <h3>
                  vcsNotFoundError
                  <span class="badge">struct</span>
                  <a href="#vcsNotFoundError" class="anchor" title="Link to vcsNotFoundError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type vcsNotFoundError struct {
dir string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="vcsPath" data-name="vcsPath">
               <h3>
                  vcsPath
                  <span class="badge">struct</span>
                  <a href="#vcsPath" class="anchor" title="Link to vcsPath">#</a>
               </h3>
               
               <p>A vcsPath describes how to convert an import path into a
version control system and repository name.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type vcsPath struct {
pathPrefix string
regexp *lazyregexp.Regexp
repo string
vcs string
check func(match map[string]string) error
schemelessRepo bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Create" data-name="Create">
               <h3>
                  Create 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Create" class="anchor" title="Link to Create">#</a>
               </h3>
               
               <p>Create creates a new copy of repo in dir.
The parent of dir must exist; dir must not.</p>
               
               <pre><code class="language-go">func (v *Cmd) Create(dir string, repo string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Download" data-name="Download">
               <h3>
                  Download 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Download" class="anchor" title="Link to Download">#</a>
               </h3>
               
               <p>Download downloads any new changes for the repo in dir.</p>
               
               <pre><code class="language-go">func (v *Cmd) Download(dir string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *vcsNotFoundError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *importError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (m ImportMismatchError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FromDir" data-name="FromDir">
               <h3>
                  FromDir 
                  <span class="badge">function</span>
                  
                  <a href="#FromDir" class="anchor" title="Link to FromDir">#</a>
               </h3>
               
               <p>FromDir inspects dir and its parents to determine the
version control system and code repository to use.
If no repository is found, FromDir returns an error
equivalent to os.ErrNotExist.</p>
               
               <pre><code class="language-go">func FromDir(dir string, srcRoot string) (repoDir string, vcsCmd *Cmd, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportPath" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportPath" class="anchor" title="Link to ImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *importError) ImportPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Is" data-name="Is">
               <h3>
                  Is 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Is" class="anchor" title="Link to Is">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *vcsNotFoundError) Is(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsSecure" data-name="IsSecure">
               <h3>
                  IsSecure 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsSecure" class="anchor" title="Link to IsSecure">#</a>
               </h3>
               
               <pre><code class="language-go">func (v *Cmd) IsSecure(repo string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Ping" data-name="Ping">
               <h3>
                  Ping 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Ping" class="anchor" title="Link to Ping">#</a>
               </h3>
               
               <p>Ping pings to determine scheme to use.</p>
               
               <pre><code class="language-go">func (v *Cmd) Ping(scheme string, repo string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RepoRootForImportPath" data-name="RepoRootForImportPath">
               <h3>
                  RepoRootForImportPath 
                  <span class="badge">function</span>
                  
                  <a href="#RepoRootForImportPath" class="anchor" title="Link to RepoRootForImportPath">#</a>
               </h3>
               
               <p>RepoRootForImportPath analyzes importPath to determine the
version control system, and code repository to use.</p>
               
               <pre><code class="language-go">func RepoRootForImportPath(importPath string, mod ModuleMode, security web.SecurityMode) (*RepoRoot, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (v *Cmd) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TagSync" data-name="TagSync">
               <h3>
                  TagSync 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TagSync" class="anchor" title="Link to TagSync">#</a>
               </h3>
               
               <p>TagSync syncs the repo in dir to the named tag,
which either is a tag returned by tags or is v.tagDefault.</p>
               
               <pre><code class="language-go">func (v *Cmd) TagSync(dir string, tag string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Tags" data-name="Tags">
               <h3>
                  Tags 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Tags" class="anchor" title="Link to Tags">#</a>
               </h3>
               
               <p>Tags returns the list of available tags for the repo in dir.</p>
               
               <pre><code class="language-go">func (v *Cmd) Tags(dir string) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *importError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allow" data-name="allow">
               <h3>
                  allow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#allow" class="anchor" title="Link to allow">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *govcsConfig) allow(path string, private bool, vcs string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="attrValue" data-name="attrValue">
               <h3>
                  attrValue 
                  <span class="badge">function</span>
                  
                  <a href="#attrValue" class="anchor" title="Link to attrValue">#</a>
               </h3>
               
               <p>attrValue returns the attribute value for the case-insensitive key
`name`, or the empty string if nothing is found.</p>
               
               <pre><code class="language-go">func attrValue(attrs []xml.Attr, name string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bzrRemoteRepo" data-name="bzrRemoteRepo">
               <h3>
                  bzrRemoteRepo 
                  <span class="badge">function</span>
                  
                  <a href="#bzrRemoteRepo" class="anchor" title="Link to bzrRemoteRepo">#</a>
               </h3>
               
               <pre><code class="language-go">func bzrRemoteRepo(vcsBzr *Cmd, rootDir string) (remoteRepo string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bzrResolveRepo" data-name="bzrResolveRepo">
               <h3>
                  bzrResolveRepo 
                  <span class="badge">function</span>
                  
                  <a href="#bzrResolveRepo" class="anchor" title="Link to bzrResolveRepo">#</a>
               </h3>
               
               <pre><code class="language-go">func bzrResolveRepo(vcsBzr *Cmd, rootDir string, remoteRepo string) (realRepo string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bzrStatus" data-name="bzrStatus">
               <h3>
                  bzrStatus 
                  <span class="badge">function</span>
                  
                  <a href="#bzrStatus" class="anchor" title="Link to bzrStatus">#</a>
               </h3>
               
               <pre><code class="language-go">func bzrStatus(vcsBzr *Cmd, rootDir string) (Status, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="charsetReader" data-name="charsetReader">
               <h3>
                  charsetReader 
                  <span class="badge">function</span>
                  
                  <a href="#charsetReader" class="anchor" title="Link to charsetReader">#</a>
               </h3>
               
               <p>charsetReader returns a reader that converts from the given charset to UTF-8.
Currently it only supports UTF-8 and ASCII. Otherwise, it returns a meaningful
error which is printed by go get, so the user can find why the package
wasn't downloaded if the encoding is not supported. Note that, in
order to reduce potential errors, ASCII is treated as UTF-8 (i.e. characters
greater than 0x7f are not rejected).</p>
               
               <pre><code class="language-go">func charsetReader(charset string, input io.Reader) (io.Reader, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkGOVCS" data-name="checkGOVCS">
               <h3>
                  checkGOVCS 
                  <span class="badge">function</span>
                  
                  <a href="#checkGOVCS" class="anchor" title="Link to checkGOVCS">#</a>
               </h3>
               
               <p>checkGOVCS checks whether the policy defined by the environment variable
GOVCS allows the given vcs command to be used with the given repository
root path. Note that root may not be a real package or module path; it's
the same as the root path in the go-import meta tag.</p>
               
               <pre><code class="language-go">func checkGOVCS(vcs *Cmd, root string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expand" data-name="expand">
               <h3>
                  expand 
                  <span class="badge">function</span>
                  
                  <a href="#expand" class="anchor" title="Link to expand">#</a>
               </h3>
               
               <p>expand rewrites s to replace {k} with match[k] for each key k in match.</p>
               
               <pre><code class="language-go">func expand(match map[string]string, s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fossilRemoteRepo" data-name="fossilRemoteRepo">
               <h3>
                  fossilRemoteRepo 
                  <span class="badge">function</span>
                  
                  <a href="#fossilRemoteRepo" class="anchor" title="Link to fossilRemoteRepo">#</a>
               </h3>
               
               <pre><code class="language-go">func fossilRemoteRepo(vcsFossil *Cmd, rootDir string) (remoteRepo string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fossilStatus" data-name="fossilStatus">
               <h3>
                  fossilStatus 
                  <span class="badge">function</span>
                  
                  <a href="#fossilStatus" class="anchor" title="Link to fossilStatus">#</a>
               </h3>
               
               <pre><code class="language-go">func fossilStatus(vcsFossil *Cmd, rootDir string) (Status, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gitRemoteRepo" data-name="gitRemoteRepo">
               <h3>
                  gitRemoteRepo 
                  <span class="badge">function</span>
                  
                  <a href="#gitRemoteRepo" class="anchor" title="Link to gitRemoteRepo">#</a>
               </h3>
               
               <pre><code class="language-go">func gitRemoteRepo(vcsGit *Cmd, rootDir string) (remoteRepo string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gitStatus" data-name="gitStatus">
               <h3>
                  gitStatus 
                  <span class="badge">function</span>
                  
                  <a href="#gitStatus" class="anchor" title="Link to gitStatus">#</a>
               </h3>
               
               <pre><code class="language-go">func gitStatus(vcsGit *Cmd, rootDir string) (Status, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hgRemoteRepo" data-name="hgRemoteRepo">
               <h3>
                  hgRemoteRepo 
                  <span class="badge">function</span>
                  
                  <a href="#hgRemoteRepo" class="anchor" title="Link to hgRemoteRepo">#</a>
               </h3>
               
               <pre><code class="language-go">func hgRemoteRepo(vcsHg *Cmd, rootDir string) (remoteRepo string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hgStatus" data-name="hgStatus">
               <h3>
                  hgStatus 
                  <span class="badge">function</span>
                  
                  <a href="#hgStatus" class="anchor" title="Link to hgStatus">#</a>
               </h3>
               
               <pre><code class="language-go">func hgStatus(vcsHg *Cmd, rootDir string) (Status, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="httpPrefix" data-name="httpPrefix">
               <h3>
                  httpPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#httpPrefix" class="anchor" title="Link to httpPrefix">#</a>
               </h3>
               
               <pre><code class="language-go">func httpPrefix(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="importErrorf" data-name="importErrorf">
               <h3>
                  importErrorf 
                  <span class="badge">function</span>
                  
                  <a href="#importErrorf" class="anchor" title="Link to importErrorf">#</a>
               </h3>
               
               <pre><code class="language-go">func importErrorf(path string, format string, args ...any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="interceptVCSTest" data-name="interceptVCSTest">
               <h3>
                  interceptVCSTest 
                  <span class="badge">function</span>
                  
                  <a href="#interceptVCSTest" class="anchor" title="Link to interceptVCSTest">#</a>
               </h3>
               
               <pre><code class="language-go">func interceptVCSTest(repo string, vcs *Cmd, security web.SecurityMode) (repoURL string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isSecureScheme" data-name="isSecureScheme">
               <h3>
                  isSecureScheme 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isSecureScheme" class="anchor" title="Link to isSecureScheme">#</a>
               </h3>
               
               <pre><code class="language-go">func (v *Cmd) isSecureScheme(scheme string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isVCSRoot" data-name="isVCSRoot">
               <h3>
                  isVCSRoot 
                  <span class="badge">function</span>
                  
                  <a href="#isVCSRoot" class="anchor" title="Link to isVCSRoot">#</a>
               </h3>
               
               <p>isVCSRoot identifies a VCS root by checking whether the directory contains
any of the listed root names.</p>
               
               <pre><code class="language-go">func isVCSRoot(dir string, rootNames []rootName) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="launchpadVCS" data-name="launchpadVCS">
               <h3>
                  launchpadVCS 
                  <span class="badge">function</span>
                  
                  <a href="#launchpadVCS" class="anchor" title="Link to launchpadVCS">#</a>
               </h3>
               
               <p>launchpadVCS solves the ambiguity for "lp.net/project/foo". In this case,
"foo" could be a series name registered in Launchpad with its own branch,
and it could also be the name of a directory within the main project
branch one level up.</p>
               
               <pre><code class="language-go">func launchpadVCS(match map[string]string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchGoImport" data-name="matchGoImport">
               <h3>
                  matchGoImport 
                  <span class="badge">function</span>
                  
                  <a href="#matchGoImport" class="anchor" title="Link to matchGoImport">#</a>
               </h3>
               
               <p>matchGoImport returns the metaImport from imports matching importPath.
An error is returned if there are multiple matches.
An ImportMismatchError is returned if none match.</p>
               
               <pre><code class="language-go">func matchGoImport(imports []metaImport, importPath string) (metaImport, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="metaImportsForPrefix" data-name="metaImportsForPrefix">
               <h3>
                  metaImportsForPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#metaImportsForPrefix" class="anchor" title="Link to metaImportsForPrefix">#</a>
               </h3>
               
               <p>metaImportsForPrefix takes a package's root import path as declared in a <meta> tag
and returns its HTML discovery URL and the parsed metaImport lines
found on the page.
The importPath is of the form "golang.org/x/tools".
It is an error if no imports are found.
url will still be valid if err != nil.
The returned url will be of the form "https://golang.org/x/tools?go-get=1"</p>
               
               <pre><code class="language-go">func metaImportsForPrefix(importPrefix string, mod ModuleMode, security web.SecurityMode) (*urlpkg.URL, []metaImport, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="noVCSSuffix" data-name="noVCSSuffix">
               <h3>
                  noVCSSuffix 
                  <span class="badge">function</span>
                  
                  <a href="#noVCSSuffix" class="anchor" title="Link to noVCSSuffix">#</a>
               </h3>
               
               <p>noVCSSuffix checks that the repository name does not
end in .foo for any version control system foo.
The usual culprit is ".git".</p>
               
               <pre><code class="language-go">func noVCSSuffix(match map[string]string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseGOVCS" data-name="parseGOVCS">
               <h3>
                  parseGOVCS 
                  <span class="badge">function</span>
                  
                  <a href="#parseGOVCS" class="anchor" title="Link to parseGOVCS">#</a>
               </h3>
               
               <pre><code class="language-go">func parseGOVCS(s string) (govcsConfig, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseMetaGoImports" data-name="parseMetaGoImports">
               <h3>
                  parseMetaGoImports 
                  <span class="badge">function</span>
                  
                  <a href="#parseMetaGoImports" class="anchor" title="Link to parseMetaGoImports">#</a>
               </h3>
               
               <p>parseMetaGoImports returns meta imports from the HTML in r.
Parsing ends at the end of the <head> section or the beginning of the <body>.</p>
               
               <pre><code class="language-go">func parseMetaGoImports(r io.Reader, mod ModuleMode) ([]metaImport, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseRevTime" data-name="parseRevTime">
               <h3>
                  parseRevTime 
                  <span class="badge">function</span>
                  
                  <a href="#parseRevTime" class="anchor" title="Link to parseRevTime">#</a>
               </h3>
               
               <p>parseRevTime parses commit details in "revision:seconds" format.</p>
               
               <pre><code class="language-go">func parseRevTime(out []byte) (string, time.Time, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="repoRootForImportDynamic" data-name="repoRootForImportDynamic">
               <h3>
                  repoRootForImportDynamic 
                  <span class="badge">function</span>
                  
                  <a href="#repoRootForImportDynamic" class="anchor" title="Link to repoRootForImportDynamic">#</a>
               </h3>
               
               <p>repoRootForImportDynamic finds a *RepoRoot for a custom domain that's not
statically known by repoRootFromVCSPaths.
This handles custom import paths like "name.tld/pkg/foo" or just "name.tld".</p>
               
               <pre><code class="language-go">func repoRootForImportDynamic(importPath string, mod ModuleMode, security web.SecurityMode) (*RepoRoot, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="repoRootFromVCSPaths" data-name="repoRootFromVCSPaths">
               <h3>
                  repoRootFromVCSPaths 
                  <span class="badge">function</span>
                  
                  <a href="#repoRootFromVCSPaths" class="anchor" title="Link to repoRootFromVCSPaths">#</a>
               </h3>
               
               <p>repoRootFromVCSPaths attempts to map importPath to a repoRoot
using the mappings defined in vcsPaths.</p>
               
               <pre><code class="language-go">func repoRootFromVCSPaths(importPath string, security web.SecurityMode, vcsPaths []*vcsPath) (*RepoRoot, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="run" data-name="run">
               <h3>
                  run 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#run" class="anchor" title="Link to run">#</a>
               </h3>
               
               <p>run runs the command line cmd in the given directory.
keyval is a list of key, value pairs. run expands
instances of {key} in cmd into value, but only after
splitting cmd into individual arguments.
If an error occurs, run prints the command line and the
command's combined stdout+stderr to standard error.
Otherwise run discards the command's output.</p>
               
               <pre><code class="language-go">func (v *Cmd) run(dir string, cmd string, keyval ...string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="run1" data-name="run1">
               <h3>
                  run1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#run1" class="anchor" title="Link to run1">#</a>
               </h3>
               
               <p>run1 is the generalized implementation of run and runOutput.</p>
               
               <pre><code class="language-go">func (v *Cmd) run1(dir string, cmdline string, keyval []string, verbose bool) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runOutput" data-name="runOutput">
               <h3>
                  runOutput 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#runOutput" class="anchor" title="Link to runOutput">#</a>
               </h3>
               
               <p>runOutput is like run but returns the output of the command.</p>
               
               <pre><code class="language-go">func (v *Cmd) runOutput(dir string, cmd string, keyval ...string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runOutputVerboseOnly" data-name="runOutputVerboseOnly">
               <h3>
                  runOutputVerboseOnly 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#runOutputVerboseOnly" class="anchor" title="Link to runOutputVerboseOnly">#</a>
               </h3>
               
               <p>runOutputVerboseOnly is like runOutput but only generates error output to
standard error in verbose mode.</p>
               
               <pre><code class="language-go">func (v *Cmd) runOutputVerboseOnly(dir string, cmd string, keyval ...string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runVerboseOnly" data-name="runVerboseOnly">
               <h3>
                  runVerboseOnly 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#runVerboseOnly" class="anchor" title="Link to runVerboseOnly">#</a>
               </h3>
               
               <p>runVerboseOnly is like run but only generates error output to standard error in verbose mode.</p>
               
               <pre><code class="language-go">func (v *Cmd) runVerboseOnly(dir string, cmd string, keyval ...string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="svnRemoteRepo" data-name="svnRemoteRepo">
               <h3>
                  svnRemoteRepo 
                  <span class="badge">function</span>
                  
                  <a href="#svnRemoteRepo" class="anchor" title="Link to svnRemoteRepo">#</a>
               </h3>
               
               <pre><code class="language-go">func svnRemoteRepo(vcsSvn *Cmd, rootDir string) (remoteRepo string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="urlForImportPath" data-name="urlForImportPath">
               <h3>
                  urlForImportPath 
                  <span class="badge">function</span>
                  
                  <a href="#urlForImportPath" class="anchor" title="Link to urlForImportPath">#</a>
               </h3>
               
               <p>urlForImportPath returns a partially-populated URL for the given Go import path.
The URL leaves the Scheme field blank so that web.Get will try any scheme
allowed by the selected security mode.</p>
               
               <pre><code class="language-go">func urlForImportPath(importPath string) (*urlpkg.URL, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validateRepoRoot" data-name="validateRepoRoot">
               <h3>
                  validateRepoRoot 
                  <span class="badge">function</span>
                  
                  <a href="#validateRepoRoot" class="anchor" title="Link to validateRepoRoot">#</a>
               </h3>
               
               <p>validateRepoRoot returns an error if repoRoot does not seem to be
a valid URL with scheme.</p>
               
               <pre><code class="language-go">func validateRepoRoot(repoRoot string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="vcsByCmd" data-name="vcsByCmd">
               <h3>
                  vcsByCmd 
                  <span class="badge">function</span>
                  
                  <a href="#vcsByCmd" class="anchor" title="Link to vcsByCmd">#</a>
               </h3>
               
               <p>vcsByCmd returns the version control system for the given
command name (hg, git, svn, bzr).</p>
               
               <pre><code class="language-go">func vcsByCmd(cmd string) *Cmd</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>