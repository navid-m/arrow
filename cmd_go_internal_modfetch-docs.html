<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - modfetch</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="cmd_go_internal_modfetch_codehost-docs.html">codehost</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                 
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>modfetch</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"golang.org/x/mod/module"
"archive/zip"
"bytes"
"context"
"crypto/sha256"
"encoding/base64"
"errors"
"fmt"
"io"
"io/fs"
"os"
"path/filepath"
"sort"
"strings"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/lockedfile"
"cmd/go/internal/str"
"cmd/go/internal/trace"
"cmd/internal/par"
"cmd/internal/robustio"
"golang.org/x/mod/module"
"golang.org/x/mod/sumdb/dirhash"
modzip "golang.org/x/mod/zip"
"context"
"encoding/json"
"errors"
"fmt"
"io"
"io/fs"
"net/url"
"path"
pathpkg "path"
"path/filepath"
"strings"
"sync"
"time"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/modfetch/codehost"
"cmd/go/internal/web"
"golang.org/x/mod/module"
"golang.org/x/mod/semver"
"context"
"fmt"
"io"
"io/fs"
"os"
"strconv"
"time"
"cmd/go/internal/cfg"
"cmd/go/internal/modfetch/codehost"
"cmd/go/internal/vcs"
web "cmd/go/internal/web"
"cmd/internal/par"
"golang.org/x/mod/module"
"context"
"fmt"
"io"
"sort"
"strings"
"cmd/go/internal/gover"
"cmd/go/internal/modfetch/codehost"
"bytes"
"context"
"encoding/json"
"errors"
"fmt"
"io"
"io/fs"
"math/rand"
"os"
"path/filepath"
"strconv"
"strings"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/gover"
"cmd/go/internal/lockedfile"
"cmd/go/internal/modfetch/codehost"
"cmd/internal/par"
"cmd/internal/robustio"
"cmd/internal/telemetry/counter"
"golang.org/x/mod/module"
"golang.org/x/mod/semver"
"archive/zip"
"bytes"
"context"
"errors"
"fmt"
"io"
"io/fs"
"os"
"path"
"path/filepath"
"sort"
"strings"
"time"
"cmd/go/internal/gover"
"cmd/go/internal/modfetch/codehost"
"golang.org/x/mod/modfile"
"golang.org/x/mod/module"
"golang.org/x/mod/semver"
modzip "golang.org/x/mod/zip"
"bytes"
"errors"
"fmt"
"io"
"io/fs"
"net/url"
"os"
"path/filepath"
"strings"
"sync"
"time"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/lockedfile"
"cmd/go/internal/web"
"golang.org/x/mod/module"
"golang.org/x/mod/sumdb"
"golang.org/x/mod/sumdb/note"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="ErrGoSumDirty">
               <h3>
                  ErrGoSumDirty 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ErrGoSumDirty = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrToolchain">
               <h3>
                  ErrToolchain 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ErrToolchain = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="GoSumFile">
               <h3>
                  GoSumFile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var GoSumFile string</code></pre>
            </article>
            
            <article class="global" data-name="HelpGoproxy">
               <h3>
                  HelpGoproxy 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var HelpGoproxy = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="HelpModuleAuth">
               <h3>
                  HelpModuleAuth 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var HelpModuleAuth = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="HelpPrivate">
               <h3>
                  HelpPrivate 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var HelpPrivate = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="WorkspaceGoSumFiles">
               <h3>
                  WorkspaceGoSumFiles 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var WorkspaceGoSumFiles []string</code></pre>
            </article>
            
            <article class="global" data-name="counterErrorsGOMODCACHEEntryRelative">
               <h3>
                  counterErrorsGOMODCACHEEntryRelative 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var counterErrorsGOMODCACHEEntryRelative = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="db">
               <h3>
                  db 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var db *sumdb.Client</code></pre>
            </article>
            
            <article class="global" data-name="dbErr">
               <h3>
                  dbErr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var dbErr error</code></pre>
            </article>
            
            <article class="global" data-name="dbName">
               <h3>
                  dbName 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var dbName string</code></pre>
            </article>
            
            <article class="global" data-name="dbOnce">
               <h3>
                  dbOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var dbOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="downloadCache">
               <h3>
                  downloadCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var downloadCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global" data-name="downloadZipCache">
               <h3>
                  downloadZipCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var downloadZipCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global" data-name="emptyGoModHash">
               <h3>
                  emptyGoModHash 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>emptyGoModHash is the hash of a 1-file tree containing a 0-length go.mod.
A bug caused us to write these into go.sum files for non-modules.
We detect and remove them.</p>
               
               <pre><code>const emptyGoModHash = "h1:G7mAYYxgmS0lVkHyy2hEOLQCFB0DlQFTMLWggykrydY="</code></pre>
            </article>
            
            <article class="global" data-name="errLookupDisabled">
               <h3>
                  errLookupDisabled 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errLookupDisabled error = lookupDisabledError{...}</code></pre>
            </article>
            
            <article class="global" data-name="errNoproxy">
               <h3>
                  errNoproxy 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errNoproxy error = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errNotCached">
               <h3>
                  errNotCached 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errNotCached = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errProxyOff">
               <h3>
                  errProxyOff 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errProxyOff = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errProxyReuse">
               <h3>
                  errProxyReuse 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errProxyReuse = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errUseProxy">
               <h3>
                  errUseProxy 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errUseProxy error = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="goSum">
               <h3>
                  goSum 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var goSum struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="goSumMismatch">
               <h3>
                  goSumMismatch 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const goSumMismatch = `

SECURITY ERROR
This download does NOT match an earlier download recorded in go.sum.
The bits may have been replaced on the origin server, or an attacker may
have intercepted the download attempt.

For more information, see 'go help module-auth'.
`</code></pre>
            </article>
            
            <article class="global" data-name="hashVersionMismatch">
               <h3>
                  hashVersionMismatch 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hashVersionMismatch = `

SECURITY WARNING
This download is listed in go.sum, but using an unknown hash algorithm.
The download cannot be verified.

For more information, see 'go help module-auth'.

`</code></pre>
            </article>
            
            <article class="global" data-name="knownGOSUMDB">
               <h3>
                  knownGOSUMDB 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var knownGOSUMDB = map[string]string{...}</code></pre>
            </article>
            
            <article class="global" data-name="lookupCache">
               <h3>
                  lookupCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var lookupCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global" data-name="lookupLocalCache">
               <h3>
                  lookupLocalCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var lookupLocalCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global" data-name="oldVgoPrefix">
               <h3>
                  oldVgoPrefix 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>oldVgoPrefix is the prefix in the old auto-generated cached go.mod files.
We stopped trying to auto-generate the go.mod files. Now we use a trivial
go.mod with only a module line, and we've dropped the version prefix
entirely. If we see a version prefix, that means we're looking at an old copy
and should ignore it.</p>
               
               <pre><code>var oldVgoPrefix = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="proxyOnce">
               <h3>
                  proxyOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var proxyOnce struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="statCacheErr">
               <h3>
                  statCacheErr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var statCacheErr error</code></pre>
            </article>
            
            <article class="global" data-name="statCacheOnce">
               <h3>
                  statCacheOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var statCacheOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="sumdbMismatch">
               <h3>
                  sumdbMismatch 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sumdbMismatch = `

SECURITY ERROR
This download does NOT match the one reported by the checksum server.
The bits may have been replaced on the origin server, or an attacker may
have intercepted the download attempt.

For more information, see 'go help module-auth'.
`</code></pre>
            </article>
            
            <article class="global" data-name="traceRepo">
               <h3>
                  traceRepo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const traceRepo = false</code></pre>
            </article>
            
         </section>
           
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Repo">
               <h3>
                  Repo
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A Repo represents a repository storing all versions of a single module.
It must be safe for simultaneous use by multiple goroutines.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Repo interface {
ModulePath() string
CheckReuse(ctx context.Context, old *codehost.Origin) error
Versions(ctx context.Context, prefix string) (*Versions, error)
Stat(ctx context.Context, rev string) (*RevInfo, error)
Latest(ctx context.Context) (*RevInfo, error)
GoMod(ctx context.Context, version string) (data []byte, err error)
Zip(ctx context.Context, dst io.Writer, version string) error
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="DownloadDirPartialError">
               <h3>
                  DownloadDirPartialError
                  <span class="badge">struct</span>
               </h3>
               
               <p>DownloadDirPartialError is returned by DownloadDir if a module directory
exists but was not completely populated.
DownloadDirPartialError is equivalent to fs.ErrNotExist.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type DownloadDirPartialError struct {
Dir string
Err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="RevInfo">
               <h3>
                  RevInfo
                  <span class="badge">struct</span>
               </h3>
               
               <p>A RevInfo describes a single revision in a module repository.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type RevInfo struct {
Version string
Time time.Time
Name string `json:"-"`
Short string `json:"-"`
Origin *codehost.Origin `json:",omitempty"`
}</code></pre>
            </article>
            
            <article class="struct" data-name="Versions">
               <h3>
                  Versions
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Versions describes the available versions in a module repository.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Versions struct {
Origin *codehost.Origin `json:",omitempty"`
List []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="cachedInfo">
               <h3>
                  cachedInfo
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type cachedInfo struct {
info *RevInfo
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="cachingRepo">
               <h3>
                  cachingRepo
                  <span class="badge">struct</span>
               </h3>
               
               <p>A cachingRepo is a cache around an underlying Repo,
avoiding redundant calls to ModulePath, Versions, Stat, Latest, and GoMod (but not CheckReuse or Zip).
It is also safe for simultaneous use by multiple goroutines
(so that it can be returned from Lookup multiple times).
It serializes calls to the underlying Repo.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type cachingRepo struct {
path string
versionsCache *ast.IndexListExpr
statCache *ast.IndexListExpr
latestCache *ast.IndexListExpr
gomodCache *ast.IndexListExpr
once sync.Once
initRepo func(context.Context) (Repo, error)
r Repo
}</code></pre>
            </article>
            
            <article class="struct" data-name="codeRepo">
               <h3>
                  codeRepo
                  <span class="badge">struct</span>
               </h3>
               
               <p>A codeRepo implements modfetch.Repo using an underlying codehost.Repo.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type codeRepo struct {
modPath string
code codehost.Repo
codeRoot string
codeDir string
pathMajor string
pathPrefix string
pseudoMajor string
}</code></pre>
            </article>
            
            <article class="struct" data-name="dataFile">
               <h3>
                  dataFile
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dataFile struct {
name string
data []byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="dataFileInfo">
               <h3>
                  dataFileInfo
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dataFileInfo struct {
f dataFile
}</code></pre>
            </article>
            
            <article class="struct" data-name="dbClient">
               <h3>
                  dbClient
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dbClient struct {
key string
name string
direct *url.URL
once sync.Once
base *url.URL
baseErr error
}</code></pre>
            </article>
            
            <article class="struct" data-name="errRepo">
               <h3>
                  errRepo
                  <span class="badge">struct</span>
               </h3>
               
               <p>errRepo is a Repo that returns the same error for all operations.
It is useful in conjunction with caching, since cache hits will not attempt
the prohibited operations.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type errRepo struct {
modulePath string
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="loggingRepo">
               <h3>
                  loggingRepo
                  <span class="badge">struct</span>
               </h3>
               
               <p>A loggingRepo is a wrapper around an underlying Repo
that prints a log message at the start and end of each call.
It can be inserted when debugging.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type loggingRepo struct {
r Repo
}</code></pre>
            </article>
            
            <article class="struct" data-name="lookupCacheKey">
               <h3>
                  lookupCacheKey
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type lookupCacheKey struct {
proxy string
path string
}</code></pre>
            </article>
            
            <article class="struct" data-name="lookupDisabledError">
               <h3>
                  lookupDisabledError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type lookupDisabledError struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="modSum">
               <h3>
                  modSum
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type modSum struct {
mod module.Version
sum string
}</code></pre>
            </article>
            
            <article class="struct" data-name="modSumStatus">
               <h3>
                  modSumStatus
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type modSumStatus struct {
used bool
dirty bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="notExistError">
               <h3>
                  notExistError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A notExistError is like fs.ErrNotExist, but with a custom message</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type notExistError struct {
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="proxyRepo">
               <h3>
                  proxyRepo
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type proxyRepo struct {
url *url.URL
path string
redactedBase string
listLatestOnce sync.Once
listLatest *RevInfo
listLatestErr error
}</code></pre>
            </article>
            
            <article class="struct" data-name="proxySpec">
               <h3>
                  proxySpec
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type proxySpec struct {
url string
fallBackOnError bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="toolchainRepo">
               <h3>
                  toolchainRepo
                  <span class="badge">struct</span>
               </h3>
               
               <p>A toolchainRepo is a synthesized repository reporting Go toolchain versions.
It has path "go" or "toolchain". The "go" repo reports versions like "1.2".
The "toolchain" repo reports versions like "go1.2".
Note that the repo ONLY reports versions. It does not actually support
downloading of the actual toolchains. Instead, that is done using
the regular repo code with "golang.org/toolchain".
The naming conflict is unfortunate: "golang.org/toolchain"
should perhaps have been "go.dev/dl", but it's too late.
For clarity, this file refers to golang.org/toolchain as the "DL" repo,
the one you can actually download.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type toolchainRepo struct {
path string
repo Repo
}</code></pre>
            </article>
            
            <article class="struct" data-name="zipFile">
               <h3>
                  zipFile
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type zipFile struct {
name string
f *zip.File
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="CachePath">
               <h3>
                  CachePath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func CachePath(ctx context.Context, m module.Version, suffix string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *cachingRepo) CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *loggingRepo) CheckReuse(ctx context.Context, old *codehost.Origin) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r errRepo) CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *toolchainRepo) CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *codeRepo) CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *proxyRepo) CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function" data-name="Download">
               <h3>
                  Download 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Download downloads the specific module version to the
local download cache and returns the name of the directory
corresponding to the root of the module's file tree.</p>
               
               <pre><code>func Download(ctx context.Context, mod module.Version) (dir string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="DownloadDir">
               <h3>
                  DownloadDir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DownloadDir returns the directory to which m should have been downloaded.
An error will be returned if the module path or version cannot be escaped.
An error satisfying errors.Is(err, fs.ErrNotExist) will be returned
along with the directory if the directory does not exist or if the directory
is not completely populated.</p>
               
               <pre><code>func DownloadDir(ctx context.Context, m module.Version) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="DownloadZip">
               <h3>
                  DownloadZip 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DownloadZip downloads the specific module version to the
local zip cache and returns the name of the zip file.</p>
               
               <pre><code>func DownloadZip(ctx context.Context, mod module.Version) (zipfile string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *DownloadDirPartialError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (lookupDisabledError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e notExistError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="GoMod">
               <h3>
                  GoMod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *proxyRepo) GoMod(ctx context.Context, version string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="GoMod">
               <h3>
                  GoMod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *loggingRepo) GoMod(ctx context.Context, version string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="GoMod">
               <h3>
                  GoMod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *toolchainRepo) GoMod(ctx context.Context, version string) (data []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="GoMod">
               <h3>
                  GoMod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *codeRepo) GoMod(ctx context.Context, version string) (data []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="GoMod">
               <h3>
                  GoMod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *cachingRepo) GoMod(ctx context.Context, version string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="GoMod">
               <h3>
                  GoMod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>GoMod is like Lookup(ctx, path).GoMod(rev) but avoids the
repository path resolution in Lookup if the result is
already cached on local disk.</p>
               
               <pre><code>func GoMod(ctx context.Context, path string, rev string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="GoMod">
               <h3>
                  GoMod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r errRepo) GoMod(ctx context.Context, version string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="GoModFile">
               <h3>
                  GoModFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>GoModFile is like GoMod but returns the name of the file containing
the cached information.</p>
               
               <pre><code>func GoModFile(ctx context.Context, path string, version string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="GoModSum">
               <h3>
                  GoModSum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>GoModSum returns the go.sum entry for the module version's go.mod file.
(That is, it returns the entry listed in go.sum as "path version/go.mod".)</p>
               
               <pre><code>func GoModSum(ctx context.Context, path string, version string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="HaveSum">
               <h3>
                  HaveSum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>HaveSum returns true if the go.sum file contains an entry for mod.
The entry's hash must be generated with a known hash algorithm.
mod.Version may have a "/go.mod" suffix to distinguish sums for
.mod and .zip files.</p>
               
               <pre><code>func HaveSum(mod module.Version) bool</code></pre>
            </article>
            
            <article class="function" data-name="InfoFile">
               <h3>
                  InfoFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>InfoFile is like Lookup(ctx, path).Stat(version) but also returns the name of the file
containing the cached information.</p>
               
               <pre><code>func InfoFile(ctx context.Context, path string, version string) (*RevInfo, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="Is">
               <h3>
                  Is 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (notExistError) Is(target error) bool</code></pre>
            </article>
            
            <article class="function" data-name="Is">
               <h3>
                  Is 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *DownloadDirPartialError) Is(err error) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsDir">
               <h3>
                  IsDir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi dataFileInfo) IsDir() bool</code></pre>
            </article>
            
            <article class="function" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r errRepo) Latest(ctx context.Context) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *toolchainRepo) Latest(ctx context.Context) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *proxyRepo) Latest(ctx context.Context) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *loggingRepo) Latest(ctx context.Context) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *codeRepo) Latest(ctx context.Context) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *cachingRepo) Latest(ctx context.Context) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="LegacyGoMod">
               <h3>
                  LegacyGoMod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LegacyGoMod generates a fake go.mod file for a module that doesn't have one.
The go.mod file contains a module directive and nothing else: no go version,
no requirements.
We used to try to build a go.mod reflecting pre-existing
package management metadata files, but the conversion
was inherently imperfect (because those files don't have
exactly the same semantics as go.mod) and, when done
for dependencies in the middle of a build, impossible to
correct. So we stopped.</p>
               
               <pre><code>func LegacyGoMod(modPath string) []byte</code></pre>
            </article>
            
            <article class="function" data-name="Log">
               <h3>
                  Log 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*dbClient) Log(msg string)</code></pre>
            </article>
            
            <article class="function" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Lookup returns the module with the given module path,
fetched through the given proxy.
The distinguished proxy "direct" indicates that the path should be fetched
from its origin, and "noproxy" indicates that the patch should be fetched
directly only if GONOPROXY matches the given path.
For the distinguished proxy "off", Lookup always returns a Repo that returns
a non-nil error for every method call.
A successful return does not guarantee that the module
has any defined versions.</p>
               
               <pre><code>func Lookup(ctx context.Context, proxy string, path string) Repo</code></pre>
            </article>
            
            <article class="function" data-name="LookupLocal">
               <h3>
                  LookupLocal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LookupLocal will only use local VCS information to fetch the Repo.</p>
               
               <pre><code>func LookupLocal(ctx context.Context, path string) Repo</code></pre>
            </article>
            
            <article class="function" data-name="Lstat">
               <h3>
                  Lstat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f dataFile) Lstat() (fs.FileInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Lstat">
               <h3>
                  Lstat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f zipFile) Lstat() (fs.FileInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="ModTime">
               <h3>
                  ModTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi dataFileInfo) ModTime() time.Time</code></pre>
            </article>
            
            <article class="function" data-name="Mode">
               <h3>
                  Mode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi dataFileInfo) Mode() fs.FileMode</code></pre>
            </article>
            
            <article class="function" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *toolchainRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *loggingRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *cachingRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *proxyRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r errRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *codeRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi dataFileInfo) Name() string</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f zipFile) Open() (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f dataFile) Open() (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function" data-name="Path">
               <h3>
                  Path 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f zipFile) Path() string</code></pre>
            </article>
            
            <article class="function" data-name="Path">
               <h3>
                  Path 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f dataFile) Path() string</code></pre>
            </article>
            
            <article class="function" data-name="ReadCache">
               <h3>
                  ReadCache 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadCache reads cached lookups or tiles from
GOPATH/pkg/mod/cache/download/sumdb,
which will be deleted by "go clean -modcache".</p>
               
               <pre><code>func (*dbClient) ReadCache(file string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadConfig">
               <h3>
                  ReadConfig 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadConfig reads the key from c.key
and otherwise reads the config (a latest tree head) from GOPATH/pkg/sumdb/<file>.</p>
               
               <pre><code>func (c *dbClient) ReadConfig(file string) (data []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadRemote">
               <h3>
                  ReadRemote 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *dbClient) ReadRemote(path string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="RecordedSum">
               <h3>
                  RecordedSum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RecordedSum returns the sum if the go.sum file contains an entry for mod.
The boolean reports true if an entry was found or
false if no entry found or two conflicting sums are found.
The entry's hash must be generated with a known hash algorithm.
mod.Version may have a "/go.mod" suffix to distinguish sums for
.mod and .zip files.</p>
               
               <pre><code>func RecordedSum(mod module.Version) (sum string, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="RemoveAll">
               <h3>
                  RemoveAll 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RemoveAll removes a directory written by Download or Unzip, first applying
any permission changes needed to do so.</p>
               
               <pre><code>func RemoveAll(dir string) error</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Reset resets globals in the modfetch package, so previous loads don't affect
contents of go.sum files.</p>
               
               <pre><code>func Reset()</code></pre>
            </article>
            
            <article class="function" data-name="SecurityError">
               <h3>
                  SecurityError 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*dbClient) SecurityError(msg string)</code></pre>
            </article>
            
            <article class="function" data-name="SideLock">
               <h3>
                  SideLock 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SideLock locks a file within the module cache that previously guarded
edits to files outside the cache, such as go.sum and go.mod files in the
user's working directory.
If err is nil, the caller MUST eventually call the unlock function.</p>
               
               <pre><code>func SideLock(ctx context.Context) (unlock func(), err error)</code></pre>
            </article>
            
            <article class="function" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi dataFileInfo) Size() int64</code></pre>
            </article>
            
            <article class="function" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *codeRepo) Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *cachingRepo) Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *loggingRepo) Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *proxyRepo) Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r errRepo) Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *toolchainRepo) Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi dataFileInfo) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Sum">
               <h3>
                  Sum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Sum returns the checksum for the downloaded copy of the given module,
if present in the download cache.</p>
               
               <pre><code>func Sum(ctx context.Context, mod module.Version) string</code></pre>
            </article>
            
            <article class="function" data-name="Sys">
               <h3>
                  Sys 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi dataFileInfo) Sys() any</code></pre>
            </article>
            
            <article class="function" data-name="TidyGoSum">
               <h3>
                  TidyGoSum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TidyGoSum returns a tidy version of the go.sum file.
A missing go.sum file is treated as if empty.</p>
               
               <pre><code>func TidyGoSum(keep map[module.Version]bool) (before []byte, after []byte)</code></pre>
            </article>
            
            <article class="function" data-name="TrimGoSum">
               <h3>
                  TrimGoSum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TrimGoSum trims go.sum to contain only the modules needed for reproducible
builds.
keep is used to check whether a sum should be retained in go.mod. It should
have entries for both module content sums and go.mod sums (version ends
with "/go.mod").</p>
               
               <pre><code>func TrimGoSum(keep map[module.Version]bool)</code></pre>
            </article>
            
            <article class="function" data-name="TryProxies">
               <h3>
                  TryProxies 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TryProxies iterates f over each configured proxy (including "noproxy" and
"direct" if applicable) until f returns no error or until f returns an
error that is not equivalent to fs.ErrNotExist on a proxy configured
not to fall back on errors.
TryProxies then returns that final error.
If GOPROXY is set to "off", TryProxies invokes f once with the argument
"off".</p>
               
               <pre><code>func TryProxies(f func(proxy string) error) error</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e notExistError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="Unzip">
               <h3>
                  Unzip 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Unzip is like Download but is given the explicit zip file to use,
rather than downloading it. This is used for the GOFIPS140 zip files,
which ship in the Go distribution itself.</p>
               
               <pre><code>func Unzip(ctx context.Context, mod module.Version, zipfile string) (dir string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *toolchainRepo) Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
            </article>
            
            <article class="function" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *loggingRepo) Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
            </article>
            
            <article class="function" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *codeRepo) Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
            </article>
            
            <article class="function" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r errRepo) Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
            </article>
            
            <article class="function" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *cachingRepo) Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
            </article>
            
            <article class="function" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *proxyRepo) Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteCache">
               <h3>
                  WriteCache 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteCache updates cached lookups or tiles.</p>
               
               <pre><code>func (*dbClient) WriteCache(file string, data []byte)</code></pre>
            </article>
            
            <article class="function" data-name="WriteConfig">
               <h3>
                  WriteConfig 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteConfig rewrites the latest tree head.</p>
               
               <pre><code>func (*dbClient) WriteConfig(file string, old []byte, new []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="WriteGoSum">
               <h3>
                  WriteGoSum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WriteGoSum writes the go.sum file if it needs to be updated.
keep is used to check whether a newly added sum should be saved in go.sum.
It should have entries for both module content sums and go.mod sums
(version ends with "/go.mod"). Existing sums will be preserved unless they
have been marked for deletion with TrimGoSum.</p>
               
               <pre><code>func WriteGoSum(ctx context.Context, keep map[module.Version]bool, readonly bool) error</code></pre>
            </article>
            
            <article class="function" data-name="Zip">
               <h3>
                  Zip 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *cachingRepo) Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
            </article>
            
            <article class="function" data-name="Zip">
               <h3>
                  Zip 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *loggingRepo) Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
            </article>
            
            <article class="function" data-name="Zip">
               <h3>
                  Zip 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *toolchainRepo) Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
            </article>
            
            <article class="function" data-name="Zip">
               <h3>
                  Zip 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *codeRepo) Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
            </article>
            
            <article class="function" data-name="Zip">
               <h3>
                  Zip 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *proxyRepo) Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
            </article>
            
            <article class="function" data-name="Zip">
               <h3>
                  Zip 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r errRepo) Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
            </article>
            
            <article class="function" data-name="addModSumLocked">
               <h3>
                  addModSumLocked 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addModSumLocked adds the pair mod,h to go.sum.
goSum.mu must be locked.</p>
               
               <pre><code>func addModSumLocked(mod module.Version, h string)</code></pre>
            </article>
            
            <article class="function" data-name="appendIncompatibleVersions">
               <h3>
                  appendIncompatibleVersions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>appendIncompatibleVersions appends "+incompatible" versions to list if
appropriate, returning the final list.
The incompatible list contains candidate versions without the '+incompatible'
prefix.
Both list and incompatible must be sorted in semantic order.</p>
               
               <pre><code>func (r *codeRepo) appendIncompatibleVersions(ctx context.Context, origin *codehost.Origin, list []string, incompatible []string) (*Versions, error)</code></pre>
            </article>
            
            <article class="function" data-name="cacheDir">
               <h3>
                  cacheDir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cacheDir(ctx context.Context, path string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="canReplaceMismatchedVersionDueToBug">
               <h3>
                  canReplaceMismatchedVersionDueToBug 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>canReplaceMismatchedVersionDueToBug reports whether versions of r
could replace versions of mpath with otherwise-mismatched major versions
due to a historical bug in the Go command (golang.org/issue/34254).</p>
               
               <pre><code>func (r *codeRepo) canReplaceMismatchedVersionDueToBug(mpath string) bool</code></pre>
            </article>
            
            <article class="function" data-name="checkCacheDir">
               <h3>
                  checkCacheDir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkCacheDir checks if the directory specified by GOMODCACHE exists. An
error is returned if it does not.</p>
               
               <pre><code>func checkCacheDir(ctx context.Context) error</code></pre>
            </article>
            
            <article class="function" data-name="checkGoMod">
               <h3>
                  checkGoMod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkGoMod checks the given module's go.mod checksum;
data is the go.mod content.</p>
               
               <pre><code>func checkGoMod(path string, version string, data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="checkMod">
               <h3>
                  checkMod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkMod checks the given module's checksum and Go version.</p>
               
               <pre><code>func checkMod(ctx context.Context, mod module.Version)</code></pre>
            </article>
            
            <article class="function" data-name="checkModSum">
               <h3>
                  checkModSum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkModSum checks that the recorded checksum for mod is h.
mod.Version may have the additional suffix "/go.mod" to request the checksum
for the module's go.mod file only.</p>
               
               <pre><code>func checkModSum(mod module.Version, h string) error</code></pre>
            </article>
            
            <article class="function" data-name="checkSumDB">
               <h3>
                  checkSumDB 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkSumDB checks the mod, h pair against the Go checksum database.
It calls base.Fatalf if the hash is to be rejected.</p>
               
               <pre><code>func checkSumDB(mod module.Version, h string) error</code></pre>
            </article>
            
            <article class="function" data-name="convert">
               <h3>
                  convert 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>convert converts a version as reported by the code host to a version as
interpreted by the module system.
If statVers is a valid module version, it is used for the Version field.
Otherwise, the Version is derived from the passed-in info and recent tags.</p>
               
               <pre><code>func (r *codeRepo) convert(ctx context.Context, info *codehost.RevInfo, statVers string) (revInfo *RevInfo, err error)</code></pre>
            </article>
            
            <article class="function" data-name="dbDial">
               <h3>
                  dbDial 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dbDial() (dbName string, db *sumdb.Client, err error)</code></pre>
            </article>
            
            <article class="function" data-name="dlToGo">
               <h3>
                  dlToGo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dlToGo converts a DL module version like "v0.0.1-go1.2.linux-amd64" to a Go version like "1.2".</p>
               
               <pre><code>func dlToGo(v string) (string, bool)</code></pre>
            </article>
            
            <article class="function" data-name="download">
               <h3>
                  download 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func download(ctx context.Context, mod module.Version) (dir string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="downloadZip">
               <h3>
                  downloadZip 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func downloadZip(ctx context.Context, mod module.Version, zipfile string) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="findDir">
               <h3>
                  findDir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>findDir locates the directory within the repo containing the module.
If r.pathMajor is non-empty, this can be either r.codeDir or — if a go.mod
file exists — r.codeDir/r.pathMajor[1:].</p>
               
               <pre><code>func (r *codeRepo) findDir(ctx context.Context, version string) (rev string, dir string, gomod []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="getBody">
               <h3>
                  getBody 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *proxyRepo) getBody(ctx context.Context, path string) (r io.ReadCloser, redactedURL string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="getBytes">
               <h3>
                  getBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *proxyRepo) getBytes(ctx context.Context, path string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="goModSum">
               <h3>
                  goModSum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>goModSum returns the checksum for the go.mod contents.</p>
               
               <pre><code>func goModSum(data []byte) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="goToDL">
               <h3>
                  goToDL 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>goToDL converts a Go version like "1.2" to a DL module version like "v0.0.1-go1.2.linux-amd64".</p>
               
               <pre><code>func goToDL(v string, goos string, goarch string) string</code></pre>
            </article>
            
            <article class="function" data-name="hasPathPrefix">
               <h3>
                  hasPathPrefix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hasPathPrefix reports whether the path s begins with the
elements in prefix.</p>
               
               <pre><code>func hasPathPrefix(s string, prefix string) bool</code></pre>
            </article>
            
            <article class="function" data-name="hashZip">
               <h3>
                  hashZip 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hashZip reads the zip file opened in f, then writes the hash to ziphashfile,
overwriting that file if it exists.
If the hash does not match go.sum (or the sumdb if enabled), hashZip returns
an error and does not write ziphashfile.</p>
               
               <pre><code>func hashZip(mod module.Version, zipfile string, ziphashfile string) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="haveModSumLocked">
               <h3>
                  haveModSumLocked 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>haveModSumLocked reports whether the pair mod,h is already listed in go.sum.
If it finds a conflicting pair instead, it calls base.Fatalf.
goSum.mu must be locked.</p>
               
               <pre><code>func haveModSumLocked(mod module.Version, h string) bool</code></pre>
            </article>
            
            <article class="function" data-name="initBase">
               <h3>
                  initBase 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>initBase determines the base URL for connecting to the database.
Determining the URL requires sending network traffic to proxies,
so this work is delayed until we need to download something from
the database. If everything we need is in the local cache and
c.ReadRemote is never called, we will never do this work.</p>
               
               <pre><code>func (c *dbClient) initBase()</code></pre>
            </article>
            
            <article class="function" data-name="initGoSum">
               <h3>
                  initGoSum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>initGoSum initializes the go.sum data.
The boolean it returns reports whether the
use of go.sum is now enabled.
The goSum lock must be held.</p>
               
               <pre><code>func initGoSum() (bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="isMajor">
               <h3>
                  isMajor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isMajor reports whether the versions allowed for mpath are compatible with
the major version(s) implied by pathMajor, or false if mpath has an invalid
version suffix.</p>
               
               <pre><code>func isMajor(mpath string, pathMajor string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isValidSum">
               <h3>
                  isValidSum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isValidSum returns true if data is the valid contents of a zip hash file.
Certain critical files are written to disk by first truncating
then writing the actual bytes, so that if the write fails
the corrupt file should contain at least one of the null
bytes written by the truncate operation.</p>
               
               <pre><code>func isValidSum(data []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="latest">
               <h3>
                  latest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *proxyRepo) latest(ctx context.Context) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="latestFromList">
               <h3>
                  latestFromList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *proxyRepo) latestFromList(ctx context.Context, allLine []string) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="lockVersion">
               <h3>
                  lockVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lockVersion locks a file within the module cache that guards the downloading
and extraction of the zipfile for the given module version.</p>
               
               <pre><code>func lockVersion(ctx context.Context, mod module.Version) (unlock func(), err error)</code></pre>
            </article>
            
            <article class="function" data-name="logCall">
               <h3>
                  logCall 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>logCall prints a log message using format and args and then
also returns a function that will print the same message again,
along with the elapsed time.
Typical usage is:
defer logCall("hello %s", arg)()
Note the final ().</p>
               
               <pre><code>func logCall(format string, args ...any) func()</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lookup returns the module with the given module path.</p>
               
               <pre><code>func lookup(ctx context.Context, proxy string, path string) (r Repo, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupCodeRepo">
               <h3>
                  lookupCodeRepo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func lookupCodeRepo(ctx context.Context, rr *vcs.RepoRoot, local bool) (codehost.Repo, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupDirect">
               <h3>
                  lookupDirect 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func lookupDirect(ctx context.Context, path string) (Repo, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupSumDB">
               <h3>
                  lookupSumDB 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lookupSumDB returns the Go checksum database's go.sum lines for the given module,
along with the name of the database.</p>
               
               <pre><code>func lookupSumDB(mod module.Version) (dbname string, lines []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupSumDB">
               <h3>
                  lookupSumDB 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func lookupSumDB(mod module.Version) (string, []string, error)</code></pre>
            </article>
            
            <article class="function" data-name="makeDirsReadOnly">
               <h3>
                  makeDirsReadOnly 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeDirsReadOnly makes a best-effort attempt to remove write permissions for dir
and its transitive contents.</p>
               
               <pre><code>func makeDirsReadOnly(dir string)</code></pre>
            </article>
            
            <article class="function" data-name="modPrefix">
               <h3>
                  modPrefix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *codeRepo) modPrefix(rev string) string</code></pre>
            </article>
            
            <article class="function" data-name="newCachingRepo">
               <h3>
                  newCachingRepo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newCachingRepo(ctx context.Context, path string, initRepo func(context.Context) (Repo, error)) *cachingRepo</code></pre>
            </article>
            
            <article class="function" data-name="newCodeRepo">
               <h3>
                  newCodeRepo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newCodeRepo returns a Repo that reads the source code for the module with the
given path, from the repo stored in code, with the root of the repo
containing the path given by codeRoot.</p>
               
               <pre><code>func newCodeRepo(code codehost.Repo, codeRoot string, path string) (Repo, error)</code></pre>
            </article>
            
            <article class="function" data-name="newLoggingRepo">
               <h3>
                  newLoggingRepo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newLoggingRepo(r Repo) *loggingRepo</code></pre>
            </article>
            
            <article class="function" data-name="newProxyRepo">
               <h3>
                  newProxyRepo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newProxyRepo(baseURL string, path string) (Repo, error)</code></pre>
            </article>
            
            <article class="function" data-name="notExistErrorf">
               <h3>
                  notExistErrorf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func notExistErrorf(format string, args ...any) error</code></pre>
            </article>
            
            <article class="function" data-name="pathEscape">
               <h3>
                  pathEscape 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>pathEscape escapes s so it can be used in a path.
That is, it escapes things like ? and # (which really shouldn't appear anyway).
It does not escape / to %2F: our REST API is designed so that / can be left as is.</p>
               
               <pre><code>func pathEscape(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="proxyList">
               <h3>
                  proxyList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func proxyList() ([]proxySpec, error)</code></pre>
            </article>
            
            <article class="function" data-name="readDiskCache">
               <h3>
                  readDiskCache 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readDiskCache is the generic "read from a cache file" implementation.
It takes the revision and an identifying suffix for the kind of data being cached.
It returns the name of the cache file and the content of the file.
If the read fails, the caller can use
writeDiskCache(file, data) to write a new cache entry.</p>
               
               <pre><code>func readDiskCache(ctx context.Context, path string, rev string, suffix string) (file string, data []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readDiskGoMod">
               <h3>
                  readDiskGoMod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readDiskGoMod reads a cached go.mod file from disk,
returning the name of the cache file and the result.
If the read fails, the caller can use
writeDiskGoMod(file, data) to write a new cache entry.</p>
               
               <pre><code>func readDiskGoMod(ctx context.Context, path string, rev string) (file string, data []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readDiskStat">
               <h3>
                  readDiskStat 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readDiskStat reads a cached stat result from disk,
returning the name of the cache file and the result.
If the read fails, the caller can use
writeDiskStat(file, info) to write a new cache entry.</p>
               
               <pre><code>func readDiskStat(ctx context.Context, path string, rev string) (file string, info *RevInfo, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readDiskStatByHash">
               <h3>
                  readDiskStatByHash 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readDiskStatByHash is a fallback for readDiskStat for the case
where rev is a commit hash instead of a proper semantic version.
In that case, we look for a cached pseudo-version that matches
the commit hash. If we find one, we use it.
This matters most for converting legacy package management
configs, when we are often looking up commits by full hash.
Without this check we'd be doing network I/O to the remote repo
just to find out about a commit we already know about
(and have cached under its pseudo-version).</p>
               
               <pre><code>func readDiskStatByHash(ctx context.Context, path string, rev string) (file string, info *RevInfo, err error)</code></pre>
            </article>
            
            <article class="function" data-name="readGoSum">
               <h3>
                  readGoSum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readGoSum parses data, which is the content of file,
and adds it to goSum.m. The goSum lock must be held.</p>
               
               <pre><code>func readGoSum(dst map[module.Version][]string, file string, data []byte)</code></pre>
            </article>
            
            <article class="function" data-name="readGoSumFile">
               <h3>
                  readGoSumFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func readGoSumFile(dst map[module.Version][]string, file string) (bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="repo">
               <h3>
                  repo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *cachingRepo) repo(ctx context.Context) Repo</code></pre>
            </article>
            
            <article class="function" data-name="retractedVersions">
               <h3>
                  retractedVersions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *codeRepo) retractedVersions(ctx context.Context) (func(string) bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="revToRev">
               <h3>
                  revToRev 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *codeRepo) revToRev(rev string) string</code></pre>
            </article>
            
            <article class="function" data-name="rewriteVersionList">
               <h3>
                  rewriteVersionList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>rewriteVersionList rewrites the version list in dir
after a new *.mod file has been written.</p>
               
               <pre><code>func rewriteVersionList(ctx context.Context, dir string) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="sumInWorkspaceModulesLocked">
               <h3>
                  sumInWorkspaceModulesLocked 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sumInWorkspaceModulesLocked(m module.Version) bool</code></pre>
            </article>
            
            <article class="function" data-name="tempFile">
               <h3>
                  tempFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>tempFile creates a new temporary file with given permission bits.</p>
               
               <pre><code>func tempFile(ctx context.Context, dir string, prefix string, perm fs.FileMode) (f *os.File, err error)</code></pre>
            </article>
            
            <article class="function" data-name="tidyGoSum">
               <h3>
                  tidyGoSum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>tidyGoSum returns a tidy version of the go.sum file.
The goSum lock must be held.</p>
               
               <pre><code>func tidyGoSum(data []byte, keep map[module.Version]bool) []byte</code></pre>
            </article>
            
            <article class="function" data-name="unzip">
               <h3>
                  unzip 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func unzip(ctx context.Context, mod module.Version, zipfile string) (dir string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="useSumDB">
               <h3>
                  useSumDB 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>useSumDB reports whether to use the Go checksum database for the given module.</p>
               
               <pre><code>func useSumDB(mod module.Version) bool</code></pre>
            </article>
            
            <article class="function" data-name="useSumDB">
               <h3>
                  useSumDB 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func useSumDB(mod module.Version) bool</code></pre>
            </article>
            
            <article class="function" data-name="validatePseudoVersion">
               <h3>
                  validatePseudoVersion 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>validatePseudoVersion checks that version has a major version compatible with
r.modPath and encodes a base version and commit metadata that agrees with
info.
Note that verifying a nontrivial base version in particular may be somewhat
expensive: in order to do so, r.code.DescendsFrom will need to fetch at least
enough of the commit history to find a path between version and its base.
Fortunately, many pseudo-versions — such as those for untagged repositories —
have trivial bases!</p>
               
               <pre><code>func (r *codeRepo) validatePseudoVersion(ctx context.Context, info *codehost.RevInfo, version string) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="versionError">
               <h3>
                  versionError 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>versionError returns err wrapped in a ModuleError for p.path.</p>
               
               <pre><code>func (p *proxyRepo) versionError(version string, err error) error</code></pre>
            </article>
            
            <article class="function" data-name="versionToRev">
               <h3>
                  versionToRev 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *codeRepo) versionToRev(version string) (rev string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeDiskCache">
               <h3>
                  writeDiskCache 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>writeDiskCache is the generic "write to a cache file" implementation.
The file must have been returned by a previous call to readDiskCache.</p>
               
               <pre><code>func writeDiskCache(ctx context.Context, file string, data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="writeDiskGoMod">
               <h3>
                  writeDiskGoMod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>writeDiskGoMod writes a go.mod cache entry.
The file name must have been returned by a previous call to readDiskGoMod.</p>
               
               <pre><code>func writeDiskGoMod(ctx context.Context, file string, text []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="writeDiskStat">
               <h3>
                  writeDiskStat 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>writeDiskStat writes a stat result cache entry.
The file name must have been returned by a previous call to readDiskStat.</p>
               
               <pre><code>func writeDiskStat(ctx context.Context, file string, info *RevInfo) error</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
