<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>modfetch - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="cmd_go_internal_modfetch_codehost-codehost-docs.html">codehost</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                 
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>modfetch</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"archive/zip"
"bytes"
"context"
"errors"
"fmt"
"io"
"io/fs"
"os"
"path"
"path/filepath"
"sort"
"strings"
"time"
"cmd/go/internal/gover"
"cmd/go/internal/modfetch/codehost"
"golang.org/x/mod/modfile"
"golang.org/x/mod/module"
"golang.org/x/mod/semver"
modzip "golang.org/x/mod/zip"
"bytes"
"errors"
"fmt"
"io"
"io/fs"
"net/url"
"os"
"path/filepath"
"strings"
"sync"
"time"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/lockedfile"
"cmd/go/internal/web"
"golang.org/x/mod/module"
"golang.org/x/mod/sumdb"
"golang.org/x/mod/sumdb/note"
"context"
"fmt"
"io"
"sort"
"strings"
"cmd/go/internal/gover"
"cmd/go/internal/modfetch/codehost"
"golang.org/x/mod/module"
"bytes"
"context"
"encoding/json"
"errors"
"fmt"
"io"
"io/fs"
"math/rand"
"os"
"path/filepath"
"strconv"
"strings"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/gover"
"cmd/go/internal/lockedfile"
"cmd/go/internal/modfetch/codehost"
"cmd/internal/par"
"cmd/internal/robustio"
"cmd/internal/telemetry/counter"
"golang.org/x/mod/module"
"golang.org/x/mod/semver"
"archive/zip"
"bytes"
"context"
"crypto/sha256"
"encoding/base64"
"errors"
"fmt"
"io"
"io/fs"
"os"
"path/filepath"
"sort"
"strings"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/lockedfile"
"cmd/go/internal/str"
"cmd/go/internal/trace"
"cmd/internal/par"
"cmd/internal/robustio"
"golang.org/x/mod/module"
"golang.org/x/mod/sumdb/dirhash"
modzip "golang.org/x/mod/zip"
"context"
"encoding/json"
"errors"
"fmt"
"io"
"io/fs"
"net/url"
"path"
pathpkg "path"
"path/filepath"
"strings"
"sync"
"time"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/modfetch/codehost"
"cmd/go/internal/web"
"golang.org/x/mod/module"
"golang.org/x/mod/semver"
"context"
"fmt"
"io"
"io/fs"
"os"
"strconv"
"time"
"cmd/go/internal/cfg"
"cmd/go/internal/modfetch/codehost"
"cmd/go/internal/vcs"
web "cmd/go/internal/web"
"cmd/internal/par"
"golang.org/x/mod/module"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ErrGoSumDirty" data-name="ErrGoSumDirty">
               <h3>
                  ErrGoSumDirty 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrGoSumDirty" class="anchor" title="Link to ErrGoSumDirty">#</a>
               </h3>
               
               <pre><code class="language-go">var ErrGoSumDirty = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrToolchain" data-name="ErrToolchain">
               <h3>
                  ErrToolchain 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrToolchain" class="anchor" title="Link to ErrToolchain">#</a>
               </h3>
               
               <pre><code class="language-go">var ErrToolchain = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="GoSumFile" data-name="GoSumFile">
               <h3>
                  GoSumFile 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#GoSumFile" class="anchor" title="Link to GoSumFile">#</a>
               </h3>
               
               <pre><code class="language-go">var GoSumFile string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="HelpGoproxy" data-name="HelpGoproxy">
               <h3>
                  HelpGoproxy 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#HelpGoproxy" class="anchor" title="Link to HelpGoproxy">#</a>
               </h3>
               
               <pre><code class="language-go">var HelpGoproxy = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="HelpModuleAuth" data-name="HelpModuleAuth">
               <h3>
                  HelpModuleAuth 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#HelpModuleAuth" class="anchor" title="Link to HelpModuleAuth">#</a>
               </h3>
               
               <pre><code class="language-go">var HelpModuleAuth = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="HelpPrivate" data-name="HelpPrivate">
               <h3>
                  HelpPrivate 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#HelpPrivate" class="anchor" title="Link to HelpPrivate">#</a>
               </h3>
               
               <pre><code class="language-go">var HelpPrivate = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="WorkspaceGoSumFiles" data-name="WorkspaceGoSumFiles">
               <h3>
                  WorkspaceGoSumFiles 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#WorkspaceGoSumFiles" class="anchor" title="Link to WorkspaceGoSumFiles">#</a>
               </h3>
               
               <pre><code class="language-go">var WorkspaceGoSumFiles []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="counterErrorsGOMODCACHEEntryRelative" data-name="counterErrorsGOMODCACHEEntryRelative">
               <h3>
                  counterErrorsGOMODCACHEEntryRelative 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#counterErrorsGOMODCACHEEntryRelative" class="anchor" title="Link to counterErrorsGOMODCACHEEntryRelative">#</a>
               </h3>
               
               <pre><code class="language-go">var counterErrorsGOMODCACHEEntryRelative = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="db" data-name="db">
               <h3>
                  db 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#db" class="anchor" title="Link to db">#</a>
               </h3>
               
               <pre><code class="language-go">var db *sumdb.Client</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dbErr" data-name="dbErr">
               <h3>
                  dbErr 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dbErr" class="anchor" title="Link to dbErr">#</a>
               </h3>
               
               <pre><code class="language-go">var dbErr error</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dbName" data-name="dbName">
               <h3>
                  dbName 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dbName" class="anchor" title="Link to dbName">#</a>
               </h3>
               
               <pre><code class="language-go">var dbName string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dbOnce" data-name="dbOnce">
               <h3>
                  dbOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dbOnce" class="anchor" title="Link to dbOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var dbOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="downloadCache" data-name="downloadCache">
               <h3>
                  downloadCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#downloadCache" class="anchor" title="Link to downloadCache">#</a>
               </h3>
               
               <pre><code class="language-go">var downloadCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="downloadZipCache" data-name="downloadZipCache">
               <h3>
                  downloadZipCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#downloadZipCache" class="anchor" title="Link to downloadZipCache">#</a>
               </h3>
               
               <pre><code class="language-go">var downloadZipCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="emptyGoModHash" data-name="emptyGoModHash">
               <h3>
                  emptyGoModHash 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#emptyGoModHash" class="anchor" title="Link to emptyGoModHash">#</a>
               </h3>
               
                  <p class="doc-comment">emptyGoModHash is the hash of a 1-file tree containing a 0-length go.mod.
A bug caused us to write these into go.sum files for non-modules.
We detect and remove them.</p>
               
               <pre><code class="language-go">const emptyGoModHash = "h1:G7mAYYxgmS0lVkHyy2hEOLQCFB0DlQFTMLWggykrydY="</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errLookupDisabled" data-name="errLookupDisabled">
               <h3>
                  errLookupDisabled 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errLookupDisabled" class="anchor" title="Link to errLookupDisabled">#</a>
               </h3>
               
               <pre><code class="language-go">var errLookupDisabled error = lookupDisabledError{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNoproxy" data-name="errNoproxy">
               <h3>
                  errNoproxy 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNoproxy" class="anchor" title="Link to errNoproxy">#</a>
               </h3>
               
               <pre><code class="language-go">var errNoproxy error = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNotCached" data-name="errNotCached">
               <h3>
                  errNotCached 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNotCached" class="anchor" title="Link to errNotCached">#</a>
               </h3>
               
               <pre><code class="language-go">var errNotCached = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errProxyOff" data-name="errProxyOff">
               <h3>
                  errProxyOff 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errProxyOff" class="anchor" title="Link to errProxyOff">#</a>
               </h3>
               
               <pre><code class="language-go">var errProxyOff = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errProxyReuse" data-name="errProxyReuse">
               <h3>
                  errProxyReuse 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errProxyReuse" class="anchor" title="Link to errProxyReuse">#</a>
               </h3>
               
               <pre><code class="language-go">var errProxyReuse = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errUseProxy" data-name="errUseProxy">
               <h3>
                  errUseProxy 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errUseProxy" class="anchor" title="Link to errUseProxy">#</a>
               </h3>
               
               <pre><code class="language-go">var errUseProxy error = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goSum" data-name="goSum">
               <h3>
                  goSum 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#goSum" class="anchor" title="Link to goSum">#</a>
               </h3>
               
               <pre><code class="language-go">var goSum struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goSumMismatch" data-name="goSumMismatch">
               <h3>
                  goSumMismatch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#goSumMismatch" class="anchor" title="Link to goSumMismatch">#</a>
               </h3>
               
               <pre><code class="language-go">const goSumMismatch = `

SECURITY ERROR
This download does NOT match an earlier download recorded in go.sum.
The bits may have been replaced on the origin server, or an attacker may
have intercepted the download attempt.

For more information, see 'go help module-auth'.
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hashVersionMismatch" data-name="hashVersionMismatch">
               <h3>
                  hashVersionMismatch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#hashVersionMismatch" class="anchor" title="Link to hashVersionMismatch">#</a>
               </h3>
               
               <pre><code class="language-go">const hashVersionMismatch = `

SECURITY WARNING
This download is listed in go.sum, but using an unknown hash algorithm.
The download cannot be verified.

For more information, see 'go help module-auth'.

`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="knownGOSUMDB" data-name="knownGOSUMDB">
               <h3>
                  knownGOSUMDB 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#knownGOSUMDB" class="anchor" title="Link to knownGOSUMDB">#</a>
               </h3>
               
               <pre><code class="language-go">var knownGOSUMDB = map[string]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="lookupCache" data-name="lookupCache">
               <h3>
                  lookupCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#lookupCache" class="anchor" title="Link to lookupCache">#</a>
               </h3>
               
               <pre><code class="language-go">var lookupCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="lookupLocalCache" data-name="lookupLocalCache">
               <h3>
                  lookupLocalCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#lookupLocalCache" class="anchor" title="Link to lookupLocalCache">#</a>
               </h3>
               
               <pre><code class="language-go">var lookupLocalCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="oldVgoPrefix" data-name="oldVgoPrefix">
               <h3>
                  oldVgoPrefix 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#oldVgoPrefix" class="anchor" title="Link to oldVgoPrefix">#</a>
               </h3>
               
                  <p class="doc-comment">oldVgoPrefix is the prefix in the old auto-generated cached go.mod files.
We stopped trying to auto-generate the go.mod files. Now we use a trivial
go.mod with only a module line, and we've dropped the version prefix
entirely. If we see a version prefix, that means we're looking at an old copy
and should ignore it.</p>
               
               <pre><code class="language-go">var oldVgoPrefix = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="proxyOnce" data-name="proxyOnce">
               <h3>
                  proxyOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#proxyOnce" class="anchor" title="Link to proxyOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var proxyOnce struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="statCacheErr" data-name="statCacheErr">
               <h3>
                  statCacheErr 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#statCacheErr" class="anchor" title="Link to statCacheErr">#</a>
               </h3>
               
               <pre><code class="language-go">var statCacheErr error</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="statCacheOnce" data-name="statCacheOnce">
               <h3>
                  statCacheOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#statCacheOnce" class="anchor" title="Link to statCacheOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var statCacheOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sumdbMismatch" data-name="sumdbMismatch">
               <h3>
                  sumdbMismatch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sumdbMismatch" class="anchor" title="Link to sumdbMismatch">#</a>
               </h3>
               
               <pre><code class="language-go">const sumdbMismatch = `

SECURITY ERROR
This download does NOT match the one reported by the checksum server.
The bits may have been replaced on the origin server, or an attacker may
have intercepted the download attempt.

For more information, see 'go help module-auth'.
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="traceRepo" data-name="traceRepo">
               <h3>
                  traceRepo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#traceRepo" class="anchor" title="Link to traceRepo">#</a>
               </h3>
               
               <pre><code class="language-go">const traceRepo = false</code></pre>
            </article>
            
         </section>
           
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Repo" data-name="Repo">
               <h3>
                  Repo
                  <span class="badge interface-badge">interface</span>
                  <a href="#Repo" class="anchor" title="Link to Repo">#</a>
               </h3>
               
               <p>A Repo represents a repository storing all versions of a single module.
It must be safe for simultaneous use by multiple goroutines.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Repo interface {
ModulePath() string
CheckReuse(ctx context.Context, old *codehost.Origin) error
Versions(ctx context.Context, prefix string) (*Versions, error)
Stat(ctx context.Context, rev string) (*RevInfo, error)
Latest(ctx context.Context) (*RevInfo, error)
GoMod(ctx context.Context, version string) (data []byte, err error)
Zip(ctx context.Context, dst io.Writer, version string) error
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="DownloadDirPartialError" data-name="DownloadDirPartialError">
               <h3>
                  DownloadDirPartialError
                  <span class="badge">struct</span>
                  <a href="#DownloadDirPartialError" class="anchor" title="Link to DownloadDirPartialError">#</a>
               </h3>
               
               <p>DownloadDirPartialError is returned by DownloadDir if a module directory
exists but was not completely populated.
DownloadDirPartialError is equivalent to fs.ErrNotExist.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type DownloadDirPartialError struct {
Dir string
Err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="RevInfo" data-name="RevInfo">
               <h3>
                  RevInfo
                  <span class="badge">struct</span>
                  <a href="#RevInfo" class="anchor" title="Link to RevInfo">#</a>
               </h3>
               
               <p>A RevInfo describes a single revision in a module repository.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type RevInfo struct {
Version string
Time time.Time
Name string `json:"-"`
Short string `json:"-"`
Origin *codehost.Origin `json:",omitempty"`
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Versions" data-name="Versions">
               <h3>
                  Versions
                  <span class="badge">struct</span>
                  <a href="#Versions" class="anchor" title="Link to Versions">#</a>
               </h3>
               
               <p>A Versions describes the available versions in a module repository.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Versions struct {
Origin *codehost.Origin `json:",omitempty"`
List []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cachedInfo" data-name="cachedInfo">
               <h3>
                  cachedInfo
                  <span class="badge">struct</span>
                  <a href="#cachedInfo" class="anchor" title="Link to cachedInfo">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type cachedInfo struct {
info *RevInfo
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cachingRepo" data-name="cachingRepo">
               <h3>
                  cachingRepo
                  <span class="badge">struct</span>
                  <a href="#cachingRepo" class="anchor" title="Link to cachingRepo">#</a>
               </h3>
               
               <p>A cachingRepo is a cache around an underlying Repo,
avoiding redundant calls to ModulePath, Versions, Stat, Latest, and GoMod (but not CheckReuse or Zip).
It is also safe for simultaneous use by multiple goroutines
(so that it can be returned from Lookup multiple times).
It serializes calls to the underlying Repo.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type cachingRepo struct {
path string
versionsCache *ast.IndexListExpr
statCache *ast.IndexListExpr
latestCache *ast.IndexListExpr
gomodCache *ast.IndexListExpr
once sync.Once
initRepo func(context.Context) (Repo, error)
r Repo
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="codeRepo" data-name="codeRepo">
               <h3>
                  codeRepo
                  <span class="badge">struct</span>
                  <a href="#codeRepo" class="anchor" title="Link to codeRepo">#</a>
               </h3>
               
               <p>A codeRepo implements modfetch.Repo using an underlying codehost.Repo.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type codeRepo struct {
modPath string
code codehost.Repo
codeRoot string
codeDir string
pathMajor string
pathPrefix string
pseudoMajor string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dataFile" data-name="dataFile">
               <h3>
                  dataFile
                  <span class="badge">struct</span>
                  <a href="#dataFile" class="anchor" title="Link to dataFile">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type dataFile struct {
name string
data []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dataFileInfo" data-name="dataFileInfo">
               <h3>
                  dataFileInfo
                  <span class="badge">struct</span>
                  <a href="#dataFileInfo" class="anchor" title="Link to dataFileInfo">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type dataFileInfo struct {
f dataFile
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dbClient" data-name="dbClient">
               <h3>
                  dbClient
                  <span class="badge">struct</span>
                  <a href="#dbClient" class="anchor" title="Link to dbClient">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type dbClient struct {
key string
name string
direct *url.URL
once sync.Once
base *url.URL
baseErr error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="errRepo" data-name="errRepo">
               <h3>
                  errRepo
                  <span class="badge">struct</span>
                  <a href="#errRepo" class="anchor" title="Link to errRepo">#</a>
               </h3>
               
               <p>errRepo is a Repo that returns the same error for all operations.
It is useful in conjunction with caching, since cache hits will not attempt
the prohibited operations.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type errRepo struct {
modulePath string
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="loggingRepo" data-name="loggingRepo">
               <h3>
                  loggingRepo
                  <span class="badge">struct</span>
                  <a href="#loggingRepo" class="anchor" title="Link to loggingRepo">#</a>
               </h3>
               
               <p>A loggingRepo is a wrapper around an underlying Repo
that prints a log message at the start and end of each call.
It can be inserted when debugging.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type loggingRepo struct {
r Repo
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="lookupCacheKey" data-name="lookupCacheKey">
               <h3>
                  lookupCacheKey
                  <span class="badge">struct</span>
                  <a href="#lookupCacheKey" class="anchor" title="Link to lookupCacheKey">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type lookupCacheKey struct {
proxy string
path string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="lookupDisabledError" data-name="lookupDisabledError">
               <h3>
                  lookupDisabledError
                  <span class="badge">struct</span>
                  <a href="#lookupDisabledError" class="anchor" title="Link to lookupDisabledError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type lookupDisabledError struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="modSum" data-name="modSum">
               <h3>
                  modSum
                  <span class="badge">struct</span>
                  <a href="#modSum" class="anchor" title="Link to modSum">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type modSum struct {
mod module.Version
sum string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="modSumStatus" data-name="modSumStatus">
               <h3>
                  modSumStatus
                  <span class="badge">struct</span>
                  <a href="#modSumStatus" class="anchor" title="Link to modSumStatus">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type modSumStatus struct {
used bool
dirty bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="notExistError" data-name="notExistError">
               <h3>
                  notExistError
                  <span class="badge">struct</span>
                  <a href="#notExistError" class="anchor" title="Link to notExistError">#</a>
               </h3>
               
               <p>A notExistError is like fs.ErrNotExist, but with a custom message</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type notExistError struct {
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="proxyRepo" data-name="proxyRepo">
               <h3>
                  proxyRepo
                  <span class="badge">struct</span>
                  <a href="#proxyRepo" class="anchor" title="Link to proxyRepo">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type proxyRepo struct {
url *url.URL
path string
redactedBase string
listLatestOnce sync.Once
listLatest *RevInfo
listLatestErr error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="proxySpec" data-name="proxySpec">
               <h3>
                  proxySpec
                  <span class="badge">struct</span>
                  <a href="#proxySpec" class="anchor" title="Link to proxySpec">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type proxySpec struct {
url string
fallBackOnError bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="toolchainRepo" data-name="toolchainRepo">
               <h3>
                  toolchainRepo
                  <span class="badge">struct</span>
                  <a href="#toolchainRepo" class="anchor" title="Link to toolchainRepo">#</a>
               </h3>
               
               <p>A toolchainRepo is a synthesized repository reporting Go toolchain versions.
It has path "go" or "toolchain". The "go" repo reports versions like "1.2".
The "toolchain" repo reports versions like "go1.2".
Note that the repo ONLY reports versions. It does not actually support
downloading of the actual toolchains. Instead, that is done using
the regular repo code with "golang.org/toolchain".
The naming conflict is unfortunate: "golang.org/toolchain"
should perhaps have been "go.dev/dl", but it's too late.
For clarity, this file refers to golang.org/toolchain as the "DL" repo,
the one you can actually download.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type toolchainRepo struct {
path string
repo Repo
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="zipFile" data-name="zipFile">
               <h3>
                  zipFile
                  <span class="badge">struct</span>
                  <a href="#zipFile" class="anchor" title="Link to zipFile">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type zipFile struct {
name string
f *zip.File
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="CachePath" data-name="CachePath">
               <h3>
                  CachePath 
                  <span class="badge">function</span>
                  
                  <a href="#CachePath" class="anchor" title="Link to CachePath">#</a>
               </h3>
               
               <pre><code class="language-go">func CachePath(ctx context.Context, m module.Version, suffix string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckReuse" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CheckReuse" class="anchor" title="Link to CheckReuse">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *cachingRepo) CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckReuse" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CheckReuse" class="anchor" title="Link to CheckReuse">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *codeRepo) CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckReuse" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CheckReuse" class="anchor" title="Link to CheckReuse">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *proxyRepo) CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckReuse" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CheckReuse" class="anchor" title="Link to CheckReuse">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *toolchainRepo) CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckReuse" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CheckReuse" class="anchor" title="Link to CheckReuse">#</a>
               </h3>
               
               <pre><code class="language-go">func (r errRepo) CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckReuse" data-name="CheckReuse">
               <h3>
                  CheckReuse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CheckReuse" class="anchor" title="Link to CheckReuse">#</a>
               </h3>
               
               <pre><code class="language-go">func (l *loggingRepo) CheckReuse(ctx context.Context, old *codehost.Origin) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Download" data-name="Download">
               <h3>
                  Download 
                  <span class="badge">function</span>
                  
                  <a href="#Download" class="anchor" title="Link to Download">#</a>
               </h3>
               
               <p>Download downloads the specific module version to the
local download cache and returns the name of the directory
corresponding to the root of the module's file tree.</p>
               
               <pre><code class="language-go">func Download(ctx context.Context, mod module.Version) (dir string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DownloadDir" data-name="DownloadDir">
               <h3>
                  DownloadDir 
                  <span class="badge">function</span>
                  
                  <a href="#DownloadDir" class="anchor" title="Link to DownloadDir">#</a>
               </h3>
               
               <p>DownloadDir returns the directory to which m should have been downloaded.
An error will be returned if the module path or version cannot be escaped.
An error satisfying errors.Is(err, fs.ErrNotExist) will be returned
along with the directory if the directory does not exist or if the directory
is not completely populated.</p>
               
               <pre><code class="language-go">func DownloadDir(ctx context.Context, m module.Version) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DownloadZip" data-name="DownloadZip">
               <h3>
                  DownloadZip 
                  <span class="badge">function</span>
                  
                  <a href="#DownloadZip" class="anchor" title="Link to DownloadZip">#</a>
               </h3>
               
               <p>DownloadZip downloads the specific module version to the
local zip cache and returns the name of the zip file.</p>
               
               <pre><code class="language-go">func DownloadZip(ctx context.Context, mod module.Version) (zipfile string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *DownloadDirPartialError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e notExistError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (lookupDisabledError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoMod" data-name="GoMod">
               <h3>
                  GoMod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoMod" class="anchor" title="Link to GoMod">#</a>
               </h3>
               
               <pre><code class="language-go">func (l *loggingRepo) GoMod(ctx context.Context, version string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoMod" data-name="GoMod">
               <h3>
                  GoMod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoMod" class="anchor" title="Link to GoMod">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *codeRepo) GoMod(ctx context.Context, version string) (data []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoMod" data-name="GoMod">
               <h3>
                  GoMod 
                  <span class="badge">function</span>
                  
                  <a href="#GoMod" class="anchor" title="Link to GoMod">#</a>
               </h3>
               
               <p>GoMod is like Lookup(ctx, path).GoMod(rev) but avoids the
repository path resolution in Lookup if the result is
already cached on local disk.</p>
               
               <pre><code class="language-go">func GoMod(ctx context.Context, path string, rev string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoMod" data-name="GoMod">
               <h3>
                  GoMod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoMod" class="anchor" title="Link to GoMod">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *cachingRepo) GoMod(ctx context.Context, version string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoMod" data-name="GoMod">
               <h3>
                  GoMod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoMod" class="anchor" title="Link to GoMod">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *proxyRepo) GoMod(ctx context.Context, version string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoMod" data-name="GoMod">
               <h3>
                  GoMod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoMod" class="anchor" title="Link to GoMod">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *toolchainRepo) GoMod(ctx context.Context, version string) (data []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoMod" data-name="GoMod">
               <h3>
                  GoMod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoMod" class="anchor" title="Link to GoMod">#</a>
               </h3>
               
               <pre><code class="language-go">func (r errRepo) GoMod(ctx context.Context, version string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoModFile" data-name="GoModFile">
               <h3>
                  GoModFile 
                  <span class="badge">function</span>
                  
                  <a href="#GoModFile" class="anchor" title="Link to GoModFile">#</a>
               </h3>
               
               <p>GoModFile is like GoMod but returns the name of the file containing
the cached information.</p>
               
               <pre><code class="language-go">func GoModFile(ctx context.Context, path string, version string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoModSum" data-name="GoModSum">
               <h3>
                  GoModSum 
                  <span class="badge">function</span>
                  
                  <a href="#GoModSum" class="anchor" title="Link to GoModSum">#</a>
               </h3>
               
               <p>GoModSum returns the go.sum entry for the module version's go.mod file.
(That is, it returns the entry listed in go.sum as "path version/go.mod".)</p>
               
               <pre><code class="language-go">func GoModSum(ctx context.Context, path string, version string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HaveSum" data-name="HaveSum">
               <h3>
                  HaveSum 
                  <span class="badge">function</span>
                  
                  <a href="#HaveSum" class="anchor" title="Link to HaveSum">#</a>
               </h3>
               
               <p>HaveSum returns true if the go.sum file contains an entry for mod.
The entry's hash must be generated with a known hash algorithm.
mod.Version may have a "/go.mod" suffix to distinguish sums for
.mod and .zip files.</p>
               
               <pre><code class="language-go">func HaveSum(mod module.Version) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InfoFile" data-name="InfoFile">
               <h3>
                  InfoFile 
                  <span class="badge">function</span>
                  
                  <a href="#InfoFile" class="anchor" title="Link to InfoFile">#</a>
               </h3>
               
               <p>InfoFile is like Lookup(ctx, path).Stat(version) but also returns the name of the file
containing the cached information.</p>
               
               <pre><code class="language-go">func InfoFile(ctx context.Context, path string, version string) (*RevInfo, string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Is" data-name="Is">
               <h3>
                  Is 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Is" class="anchor" title="Link to Is">#</a>
               </h3>
               
               <pre><code class="language-go">func (notExistError) Is(target error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Is" data-name="Is">
               <h3>
                  Is 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Is" class="anchor" title="Link to Is">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *DownloadDirPartialError) Is(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsDir" data-name="IsDir">
               <h3>
                  IsDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsDir" class="anchor" title="Link to IsDir">#</a>
               </h3>
               
               <pre><code class="language-go">func (fi dataFileInfo) IsDir() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Latest" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Latest" class="anchor" title="Link to Latest">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *toolchainRepo) Latest(ctx context.Context) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Latest" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Latest" class="anchor" title="Link to Latest">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *cachingRepo) Latest(ctx context.Context) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Latest" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Latest" class="anchor" title="Link to Latest">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *proxyRepo) Latest(ctx context.Context) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Latest" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Latest" class="anchor" title="Link to Latest">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *codeRepo) Latest(ctx context.Context) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Latest" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Latest" class="anchor" title="Link to Latest">#</a>
               </h3>
               
               <pre><code class="language-go">func (r errRepo) Latest(ctx context.Context) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Latest" data-name="Latest">
               <h3>
                  Latest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Latest" class="anchor" title="Link to Latest">#</a>
               </h3>
               
               <pre><code class="language-go">func (l *loggingRepo) Latest(ctx context.Context) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LegacyGoMod" data-name="LegacyGoMod">
               <h3>
                  LegacyGoMod 
                  <span class="badge">function</span>
                  
                  <a href="#LegacyGoMod" class="anchor" title="Link to LegacyGoMod">#</a>
               </h3>
               
               <p>LegacyGoMod generates a fake go.mod file for a module that doesn't have one.
The go.mod file contains a module directive and nothing else: no go version,
no requirements.
We used to try to build a go.mod reflecting pre-existing
package management metadata files, but the conversion
was inherently imperfect (because those files don't have
exactly the same semantics as go.mod) and, when done
for dependencies in the middle of a build, impossible to
correct. So we stopped.</p>
               
               <pre><code class="language-go">func LegacyGoMod(modPath string) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Log" data-name="Log">
               <h3>
                  Log 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Log" class="anchor" title="Link to Log">#</a>
               </h3>
               
               <pre><code class="language-go">func (*dbClient) Log(msg string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lookup" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge">function</span>
                  
                  <a href="#Lookup" class="anchor" title="Link to Lookup">#</a>
               </h3>
               
               <p>Lookup returns the module with the given module path,
fetched through the given proxy.
The distinguished proxy "direct" indicates that the path should be fetched
from its origin, and "noproxy" indicates that the patch should be fetched
directly only if GONOPROXY matches the given path.
For the distinguished proxy "off", Lookup always returns a Repo that returns
a non-nil error for every method call.
A successful return does not guarantee that the module
has any defined versions.</p>
               
               <pre><code class="language-go">func Lookup(ctx context.Context, proxy string, path string) Repo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupLocal" data-name="LookupLocal">
               <h3>
                  LookupLocal 
                  <span class="badge">function</span>
                  
                  <a href="#LookupLocal" class="anchor" title="Link to LookupLocal">#</a>
               </h3>
               
               <p>LookupLocal will only use local VCS information to fetch the Repo.</p>
               
               <pre><code class="language-go">func LookupLocal(ctx context.Context, path string) Repo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lstat" data-name="Lstat">
               <h3>
                  Lstat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lstat" class="anchor" title="Link to Lstat">#</a>
               </h3>
               
               <pre><code class="language-go">func (f zipFile) Lstat() (fs.FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lstat" data-name="Lstat">
               <h3>
                  Lstat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lstat" class="anchor" title="Link to Lstat">#</a>
               </h3>
               
               <pre><code class="language-go">func (f dataFile) Lstat() (fs.FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModTime" data-name="ModTime">
               <h3>
                  ModTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModTime" class="anchor" title="Link to ModTime">#</a>
               </h3>
               
               <pre><code class="language-go">func (fi dataFileInfo) ModTime() time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mode" data-name="Mode">
               <h3>
                  Mode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mode" class="anchor" title="Link to Mode">#</a>
               </h3>
               
               <pre><code class="language-go">func (fi dataFileInfo) Mode() fs.FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModulePath" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModulePath" class="anchor" title="Link to ModulePath">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *cachingRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModulePath" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModulePath" class="anchor" title="Link to ModulePath">#</a>
               </h3>
               
               <pre><code class="language-go">func (l *loggingRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModulePath" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModulePath" class="anchor" title="Link to ModulePath">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *toolchainRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModulePath" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModulePath" class="anchor" title="Link to ModulePath">#</a>
               </h3>
               
               <pre><code class="language-go">func (r errRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModulePath" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModulePath" class="anchor" title="Link to ModulePath">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *proxyRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModulePath" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModulePath" class="anchor" title="Link to ModulePath">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *codeRepo) ModulePath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <pre><code class="language-go">func (fi dataFileInfo) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <pre><code class="language-go">func (f dataFile) Open() (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <pre><code class="language-go">func (f zipFile) Open() (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Path" data-name="Path">
               <h3>
                  Path 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Path" class="anchor" title="Link to Path">#</a>
               </h3>
               
               <pre><code class="language-go">func (f zipFile) Path() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Path" data-name="Path">
               <h3>
                  Path 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Path" class="anchor" title="Link to Path">#</a>
               </h3>
               
               <pre><code class="language-go">func (f dataFile) Path() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadCache" data-name="ReadCache">
               <h3>
                  ReadCache 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadCache" class="anchor" title="Link to ReadCache">#</a>
               </h3>
               
               <p>ReadCache reads cached lookups or tiles from
GOPATH/pkg/mod/cache/download/sumdb,
which will be deleted by "go clean -modcache".</p>
               
               <pre><code class="language-go">func (*dbClient) ReadCache(file string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadConfig" data-name="ReadConfig">
               <h3>
                  ReadConfig 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadConfig" class="anchor" title="Link to ReadConfig">#</a>
               </h3>
               
               <p>ReadConfig reads the key from c.key
and otherwise reads the config (a latest tree head) from GOPATH/pkg/sumdb/<file>.</p>
               
               <pre><code class="language-go">func (c *dbClient) ReadConfig(file string) (data []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadRemote" data-name="ReadRemote">
               <h3>
                  ReadRemote 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadRemote" class="anchor" title="Link to ReadRemote">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *dbClient) ReadRemote(path string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RecordedSum" data-name="RecordedSum">
               <h3>
                  RecordedSum 
                  <span class="badge">function</span>
                  
                  <a href="#RecordedSum" class="anchor" title="Link to RecordedSum">#</a>
               </h3>
               
               <p>RecordedSum returns the sum if the go.sum file contains an entry for mod.
The boolean reports true if an entry was found or
false if no entry found or two conflicting sums are found.
The entry's hash must be generated with a known hash algorithm.
mod.Version may have a "/go.mod" suffix to distinguish sums for
.mod and .zip files.</p>
               
               <pre><code class="language-go">func RecordedSum(mod module.Version) (sum string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RemoveAll" data-name="RemoveAll">
               <h3>
                  RemoveAll 
                  <span class="badge">function</span>
                  
                  <a href="#RemoveAll" class="anchor" title="Link to RemoveAll">#</a>
               </h3>
               
               <p>RemoveAll removes a directory written by Download or Unzip, first applying
any permission changes needed to do so.</p>
               
               <pre><code class="language-go">func RemoveAll(dir string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge">function</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset resets globals in the modfetch package, so previous loads don't affect
contents of go.sum files.</p>
               
               <pre><code class="language-go">func Reset()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SecurityError" data-name="SecurityError">
               <h3>
                  SecurityError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SecurityError" class="anchor" title="Link to SecurityError">#</a>
               </h3>
               
               <pre><code class="language-go">func (*dbClient) SecurityError(msg string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SideLock" data-name="SideLock">
               <h3>
                  SideLock 
                  <span class="badge">function</span>
                  
                  <a href="#SideLock" class="anchor" title="Link to SideLock">#</a>
               </h3>
               
               <p>SideLock locks a file within the module cache that previously guarded
edits to files outside the cache, such as go.sum and go.mod files in the
user's working directory.
If err is nil, the caller MUST eventually call the unlock function.</p>
               
               <pre><code class="language-go">func SideLock(ctx context.Context) (unlock func(), err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <pre><code class="language-go">func (fi dataFileInfo) Size() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *toolchainRepo) Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <pre><code class="language-go">func (r errRepo) Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *proxyRepo) Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *cachingRepo) Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <pre><code class="language-go">func (l *loggingRepo) Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *codeRepo) Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (fi dataFileInfo) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sum" data-name="Sum">
               <h3>
                  Sum 
                  <span class="badge">function</span>
                  
                  <a href="#Sum" class="anchor" title="Link to Sum">#</a>
               </h3>
               
               <p>Sum returns the checksum for the downloaded copy of the given module,
if present in the download cache.</p>
               
               <pre><code class="language-go">func Sum(ctx context.Context, mod module.Version) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sys" data-name="Sys">
               <h3>
                  Sys 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sys" class="anchor" title="Link to Sys">#</a>
               </h3>
               
               <pre><code class="language-go">func (fi dataFileInfo) Sys() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TidyGoSum" data-name="TidyGoSum">
               <h3>
                  TidyGoSum 
                  <span class="badge">function</span>
                  
                  <a href="#TidyGoSum" class="anchor" title="Link to TidyGoSum">#</a>
               </h3>
               
               <p>TidyGoSum returns a tidy version of the go.sum file.
A missing go.sum file is treated as if empty.</p>
               
               <pre><code class="language-go">func TidyGoSum(keep map[module.Version]bool) (before []byte, after []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrimGoSum" data-name="TrimGoSum">
               <h3>
                  TrimGoSum 
                  <span class="badge">function</span>
                  
                  <a href="#TrimGoSum" class="anchor" title="Link to TrimGoSum">#</a>
               </h3>
               
               <p>TrimGoSum trims go.sum to contain only the modules needed for reproducible
builds.
keep is used to check whether a sum should be retained in go.mod. It should
have entries for both module content sums and go.mod sums (version ends
with "/go.mod").</p>
               
               <pre><code class="language-go">func TrimGoSum(keep map[module.Version]bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TryProxies" data-name="TryProxies">
               <h3>
                  TryProxies 
                  <span class="badge">function</span>
                  
                  <a href="#TryProxies" class="anchor" title="Link to TryProxies">#</a>
               </h3>
               
               <p>TryProxies iterates f over each configured proxy (including "noproxy" and
"direct" if applicable) until f returns no error or until f returns an
error that is not equivalent to fs.ErrNotExist on a proxy configured
not to fall back on errors.
TryProxies then returns that final error.
If GOPROXY is set to "off", TryProxies invokes f once with the argument
"off".</p>
               
               <pre><code class="language-go">func TryProxies(f func(proxy string) error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (e notExistError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unzip" data-name="Unzip">
               <h3>
                  Unzip 
                  <span class="badge">function</span>
                  
                  <a href="#Unzip" class="anchor" title="Link to Unzip">#</a>
               </h3>
               
               <p>Unzip is like Download but is given the explicit zip file to use,
rather than downloading it. This is used for the GOFIPS140 zip files,
which ship in the Go distribution itself.</p>
               
               <pre><code class="language-go">func Unzip(ctx context.Context, mod module.Version, zipfile string) (dir string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Versions" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Versions" class="anchor" title="Link to Versions">#</a>
               </h3>
               
               <pre><code class="language-go">func (r errRepo) Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Versions" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Versions" class="anchor" title="Link to Versions">#</a>
               </h3>
               
               <pre><code class="language-go">func (l *loggingRepo) Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Versions" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Versions" class="anchor" title="Link to Versions">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *cachingRepo) Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Versions" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Versions" class="anchor" title="Link to Versions">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *codeRepo) Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Versions" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Versions" class="anchor" title="Link to Versions">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *toolchainRepo) Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Versions" data-name="Versions">
               <h3>
                  Versions 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Versions" class="anchor" title="Link to Versions">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *proxyRepo) Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteCache" data-name="WriteCache">
               <h3>
                  WriteCache 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteCache" class="anchor" title="Link to WriteCache">#</a>
               </h3>
               
               <p>WriteCache updates cached lookups or tiles.</p>
               
               <pre><code class="language-go">func (*dbClient) WriteCache(file string, data []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteConfig" data-name="WriteConfig">
               <h3>
                  WriteConfig 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteConfig" class="anchor" title="Link to WriteConfig">#</a>
               </h3>
               
               <p>WriteConfig rewrites the latest tree head.</p>
               
               <pre><code class="language-go">func (*dbClient) WriteConfig(file string, old []byte, new []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteGoSum" data-name="WriteGoSum">
               <h3>
                  WriteGoSum 
                  <span class="badge">function</span>
                  
                  <a href="#WriteGoSum" class="anchor" title="Link to WriteGoSum">#</a>
               </h3>
               
               <p>WriteGoSum writes the go.sum file if it needs to be updated.
keep is used to check whether a newly added sum should be saved in go.sum.
It should have entries for both module content sums and go.mod sums
(version ends with "/go.mod"). Existing sums will be preserved unless they
have been marked for deletion with TrimGoSum.</p>
               
               <pre><code class="language-go">func WriteGoSum(ctx context.Context, keep map[module.Version]bool, readonly bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Zip" data-name="Zip">
               <h3>
                  Zip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Zip" class="anchor" title="Link to Zip">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *cachingRepo) Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Zip" data-name="Zip">
               <h3>
                  Zip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Zip" class="anchor" title="Link to Zip">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *proxyRepo) Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Zip" data-name="Zip">
               <h3>
                  Zip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Zip" class="anchor" title="Link to Zip">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *codeRepo) Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Zip" data-name="Zip">
               <h3>
                  Zip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Zip" class="anchor" title="Link to Zip">#</a>
               </h3>
               
               <pre><code class="language-go">func (l *loggingRepo) Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Zip" data-name="Zip">
               <h3>
                  Zip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Zip" class="anchor" title="Link to Zip">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *toolchainRepo) Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Zip" data-name="Zip">
               <h3>
                  Zip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Zip" class="anchor" title="Link to Zip">#</a>
               </h3>
               
               <pre><code class="language-go">func (r errRepo) Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addModSumLocked" data-name="addModSumLocked">
               <h3>
                  addModSumLocked 
                  <span class="badge">function</span>
                  
                  <a href="#addModSumLocked" class="anchor" title="Link to addModSumLocked">#</a>
               </h3>
               
               <p>addModSumLocked adds the pair mod,h to go.sum.
goSum.mu must be locked.</p>
               
               <pre><code class="language-go">func addModSumLocked(mod module.Version, h string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendIncompatibleVersions" data-name="appendIncompatibleVersions">
               <h3>
                  appendIncompatibleVersions 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#appendIncompatibleVersions" class="anchor" title="Link to appendIncompatibleVersions">#</a>
               </h3>
               
               <p>appendIncompatibleVersions appends "+incompatible" versions to list if
appropriate, returning the final list.
The incompatible list contains candidate versions without the '+incompatible'
prefix.
Both list and incompatible must be sorted in semantic order.</p>
               
               <pre><code class="language-go">func (r *codeRepo) appendIncompatibleVersions(ctx context.Context, origin *codehost.Origin, list []string, incompatible []string) (*Versions, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cacheDir" data-name="cacheDir">
               <h3>
                  cacheDir 
                  <span class="badge">function</span>
                  
                  <a href="#cacheDir" class="anchor" title="Link to cacheDir">#</a>
               </h3>
               
               <pre><code class="language-go">func cacheDir(ctx context.Context, path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canReplaceMismatchedVersionDueToBug" data-name="canReplaceMismatchedVersionDueToBug">
               <h3>
                  canReplaceMismatchedVersionDueToBug 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#canReplaceMismatchedVersionDueToBug" class="anchor" title="Link to canReplaceMismatchedVersionDueToBug">#</a>
               </h3>
               
               <p>canReplaceMismatchedVersionDueToBug reports whether versions of r
could replace versions of mpath with otherwise-mismatched major versions
due to a historical bug in the Go command (golang.org/issue/34254).</p>
               
               <pre><code class="language-go">func (r *codeRepo) canReplaceMismatchedVersionDueToBug(mpath string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkCacheDir" data-name="checkCacheDir">
               <h3>
                  checkCacheDir 
                  <span class="badge">function</span>
                  
                  <a href="#checkCacheDir" class="anchor" title="Link to checkCacheDir">#</a>
               </h3>
               
               <p>checkCacheDir checks if the directory specified by GOMODCACHE exists. An
error is returned if it does not.</p>
               
               <pre><code class="language-go">func checkCacheDir(ctx context.Context) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkGoMod" data-name="checkGoMod">
               <h3>
                  checkGoMod 
                  <span class="badge">function</span>
                  
                  <a href="#checkGoMod" class="anchor" title="Link to checkGoMod">#</a>
               </h3>
               
               <p>checkGoMod checks the given module's go.mod checksum;
data is the go.mod content.</p>
               
               <pre><code class="language-go">func checkGoMod(path string, version string, data []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkMod" data-name="checkMod">
               <h3>
                  checkMod 
                  <span class="badge">function</span>
                  
                  <a href="#checkMod" class="anchor" title="Link to checkMod">#</a>
               </h3>
               
               <p>checkMod checks the given module's checksum and Go version.</p>
               
               <pre><code class="language-go">func checkMod(ctx context.Context, mod module.Version)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkModSum" data-name="checkModSum">
               <h3>
                  checkModSum 
                  <span class="badge">function</span>
                  
                  <a href="#checkModSum" class="anchor" title="Link to checkModSum">#</a>
               </h3>
               
               <p>checkModSum checks that the recorded checksum for mod is h.
mod.Version may have the additional suffix "/go.mod" to request the checksum
for the module's go.mod file only.</p>
               
               <pre><code class="language-go">func checkModSum(mod module.Version, h string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkSumDB" data-name="checkSumDB">
               <h3>
                  checkSumDB 
                  <span class="badge">function</span>
                  
                  <a href="#checkSumDB" class="anchor" title="Link to checkSumDB">#</a>
               </h3>
               
               <p>checkSumDB checks the mod, h pair against the Go checksum database.
It calls base.Fatalf if the hash is to be rejected.</p>
               
               <pre><code class="language-go">func checkSumDB(mod module.Version, h string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convert" data-name="convert">
               <h3>
                  convert 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#convert" class="anchor" title="Link to convert">#</a>
               </h3>
               
               <p>convert converts a version as reported by the code host to a version as
interpreted by the module system.
If statVers is a valid module version, it is used for the Version field.
Otherwise, the Version is derived from the passed-in info and recent tags.</p>
               
               <pre><code class="language-go">func (r *codeRepo) convert(ctx context.Context, info *codehost.RevInfo, statVers string) (revInfo *RevInfo, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dbDial" data-name="dbDial">
               <h3>
                  dbDial 
                  <span class="badge">function</span>
                  
                  <a href="#dbDial" class="anchor" title="Link to dbDial">#</a>
               </h3>
               
               <pre><code class="language-go">func dbDial() (dbName string, db *sumdb.Client, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dlToGo" data-name="dlToGo">
               <h3>
                  dlToGo 
                  <span class="badge">function</span>
                  
                  <a href="#dlToGo" class="anchor" title="Link to dlToGo">#</a>
               </h3>
               
               <p>dlToGo converts a DL module version like "v0.0.1-go1.2.linux-amd64" to a Go version like "1.2".</p>
               
               <pre><code class="language-go">func dlToGo(v string) (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="download" data-name="download">
               <h3>
                  download 
                  <span class="badge">function</span>
                  
                  <a href="#download" class="anchor" title="Link to download">#</a>
               </h3>
               
               <pre><code class="language-go">func download(ctx context.Context, mod module.Version) (dir string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="downloadZip" data-name="downloadZip">
               <h3>
                  downloadZip 
                  <span class="badge">function</span>
                  
                  <a href="#downloadZip" class="anchor" title="Link to downloadZip">#</a>
               </h3>
               
               <pre><code class="language-go">func downloadZip(ctx context.Context, mod module.Version, zipfile string) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findDir" data-name="findDir">
               <h3>
                  findDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findDir" class="anchor" title="Link to findDir">#</a>
               </h3>
               
               <p>findDir locates the directory within the repo containing the module.
If r.pathMajor is non-empty, this can be either r.codeDir or — if a go.mod
file exists — r.codeDir/r.pathMajor[1:].</p>
               
               <pre><code class="language-go">func (r *codeRepo) findDir(ctx context.Context, version string) (rev string, dir string, gomod []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getBody" data-name="getBody">
               <h3>
                  getBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getBody" class="anchor" title="Link to getBody">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *proxyRepo) getBody(ctx context.Context, path string) (r io.ReadCloser, redactedURL string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getBytes" data-name="getBytes">
               <h3>
                  getBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getBytes" class="anchor" title="Link to getBytes">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *proxyRepo) getBytes(ctx context.Context, path string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goModSum" data-name="goModSum">
               <h3>
                  goModSum 
                  <span class="badge">function</span>
                  
                  <a href="#goModSum" class="anchor" title="Link to goModSum">#</a>
               </h3>
               
               <p>goModSum returns the checksum for the go.mod contents.</p>
               
               <pre><code class="language-go">func goModSum(data []byte) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goToDL" data-name="goToDL">
               <h3>
                  goToDL 
                  <span class="badge">function</span>
                  
                  <a href="#goToDL" class="anchor" title="Link to goToDL">#</a>
               </h3>
               
               <p>goToDL converts a Go version like "1.2" to a DL module version like "v0.0.1-go1.2.linux-amd64".</p>
               
               <pre><code class="language-go">func goToDL(v string, goos string, goarch string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasPathPrefix" data-name="hasPathPrefix">
               <h3>
                  hasPathPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#hasPathPrefix" class="anchor" title="Link to hasPathPrefix">#</a>
               </h3>
               
               <p>hasPathPrefix reports whether the path s begins with the
elements in prefix.</p>
               
               <pre><code class="language-go">func hasPathPrefix(s string, prefix string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashZip" data-name="hashZip">
               <h3>
                  hashZip 
                  <span class="badge">function</span>
                  
                  <a href="#hashZip" class="anchor" title="Link to hashZip">#</a>
               </h3>
               
               <p>hashZip reads the zip file opened in f, then writes the hash to ziphashfile,
overwriting that file if it exists.
If the hash does not match go.sum (or the sumdb if enabled), hashZip returns
an error and does not write ziphashfile.</p>
               
               <pre><code class="language-go">func hashZip(mod module.Version, zipfile string, ziphashfile string) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="haveModSumLocked" data-name="haveModSumLocked">
               <h3>
                  haveModSumLocked 
                  <span class="badge">function</span>
                  
                  <a href="#haveModSumLocked" class="anchor" title="Link to haveModSumLocked">#</a>
               </h3>
               
               <p>haveModSumLocked reports whether the pair mod,h is already listed in go.sum.
If it finds a conflicting pair instead, it calls base.Fatalf.
goSum.mu must be locked.</p>
               
               <pre><code class="language-go">func haveModSumLocked(mod module.Version, h string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initBase" data-name="initBase">
               <h3>
                  initBase 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initBase" class="anchor" title="Link to initBase">#</a>
               </h3>
               
               <p>initBase determines the base URL for connecting to the database.
Determining the URL requires sending network traffic to proxies,
so this work is delayed until we need to download something from
the database. If everything we need is in the local cache and
c.ReadRemote is never called, we will never do this work.</p>
               
               <pre><code class="language-go">func (c *dbClient) initBase()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initGoSum" data-name="initGoSum">
               <h3>
                  initGoSum 
                  <span class="badge">function</span>
                  
                  <a href="#initGoSum" class="anchor" title="Link to initGoSum">#</a>
               </h3>
               
               <p>initGoSum initializes the go.sum data.
The boolean it returns reports whether the
use of go.sum is now enabled.
The goSum lock must be held.</p>
               
               <pre><code class="language-go">func initGoSum() (bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isMajor" data-name="isMajor">
               <h3>
                  isMajor 
                  <span class="badge">function</span>
                  
                  <a href="#isMajor" class="anchor" title="Link to isMajor">#</a>
               </h3>
               
               <p>isMajor reports whether the versions allowed for mpath are compatible with
the major version(s) implied by pathMajor, or false if mpath has an invalid
version suffix.</p>
               
               <pre><code class="language-go">func isMajor(mpath string, pathMajor string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isValidSum" data-name="isValidSum">
               <h3>
                  isValidSum 
                  <span class="badge">function</span>
                  
                  <a href="#isValidSum" class="anchor" title="Link to isValidSum">#</a>
               </h3>
               
               <p>isValidSum returns true if data is the valid contents of a zip hash file.
Certain critical files are written to disk by first truncating
then writing the actual bytes, so that if the write fails
the corrupt file should contain at least one of the null
bytes written by the truncate operation.</p>
               
               <pre><code class="language-go">func isValidSum(data []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="latest" data-name="latest">
               <h3>
                  latest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#latest" class="anchor" title="Link to latest">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *proxyRepo) latest(ctx context.Context) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="latestFromList" data-name="latestFromList">
               <h3>
                  latestFromList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#latestFromList" class="anchor" title="Link to latestFromList">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *proxyRepo) latestFromList(ctx context.Context, allLine []string) (*RevInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lockVersion" data-name="lockVersion">
               <h3>
                  lockVersion 
                  <span class="badge">function</span>
                  
                  <a href="#lockVersion" class="anchor" title="Link to lockVersion">#</a>
               </h3>
               
               <p>lockVersion locks a file within the module cache that guards the downloading
and extraction of the zipfile for the given module version.</p>
               
               <pre><code class="language-go">func lockVersion(ctx context.Context, mod module.Version) (unlock func(), err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logCall" data-name="logCall">
               <h3>
                  logCall 
                  <span class="badge">function</span>
                  
                  <a href="#logCall" class="anchor" title="Link to logCall">#</a>
               </h3>
               
               <p>logCall prints a log message using format and args and then
also returns a function that will print the same message again,
along with the elapsed time.
Typical usage is:
defer logCall("hello %s", arg)()
Note the final ().</p>
               
               <pre><code class="language-go">func logCall(format string, args ...any) func()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookup" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge">function</span>
                  
                  <a href="#lookup" class="anchor" title="Link to lookup">#</a>
               </h3>
               
               <p>lookup returns the module with the given module path.</p>
               
               <pre><code class="language-go">func lookup(ctx context.Context, proxy string, path string) (r Repo, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupCodeRepo" data-name="lookupCodeRepo">
               <h3>
                  lookupCodeRepo 
                  <span class="badge">function</span>
                  
                  <a href="#lookupCodeRepo" class="anchor" title="Link to lookupCodeRepo">#</a>
               </h3>
               
               <pre><code class="language-go">func lookupCodeRepo(ctx context.Context, rr *vcs.RepoRoot, local bool) (codehost.Repo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupDirect" data-name="lookupDirect">
               <h3>
                  lookupDirect 
                  <span class="badge">function</span>
                  
                  <a href="#lookupDirect" class="anchor" title="Link to lookupDirect">#</a>
               </h3>
               
               <pre><code class="language-go">func lookupDirect(ctx context.Context, path string) (Repo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupSumDB" data-name="lookupSumDB">
               <h3>
                  lookupSumDB 
                  <span class="badge">function</span>
                  
                  <a href="#lookupSumDB" class="anchor" title="Link to lookupSumDB">#</a>
               </h3>
               
               <p>lookupSumDB returns the Go checksum database's go.sum lines for the given module,
along with the name of the database.</p>
               
               <pre><code class="language-go">func lookupSumDB(mod module.Version) (dbname string, lines []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupSumDB" data-name="lookupSumDB">
               <h3>
                  lookupSumDB 
                  <span class="badge">function</span>
                  
                  <a href="#lookupSumDB" class="anchor" title="Link to lookupSumDB">#</a>
               </h3>
               
               <pre><code class="language-go">func lookupSumDB(mod module.Version) (string, []string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeDirsReadOnly" data-name="makeDirsReadOnly">
               <h3>
                  makeDirsReadOnly 
                  <span class="badge">function</span>
                  
                  <a href="#makeDirsReadOnly" class="anchor" title="Link to makeDirsReadOnly">#</a>
               </h3>
               
               <p>makeDirsReadOnly makes a best-effort attempt to remove write permissions for dir
and its transitive contents.</p>
               
               <pre><code class="language-go">func makeDirsReadOnly(dir string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modPrefix" data-name="modPrefix">
               <h3>
                  modPrefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#modPrefix" class="anchor" title="Link to modPrefix">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *codeRepo) modPrefix(rev string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newCachingRepo" data-name="newCachingRepo">
               <h3>
                  newCachingRepo 
                  <span class="badge">function</span>
                  
                  <a href="#newCachingRepo" class="anchor" title="Link to newCachingRepo">#</a>
               </h3>
               
               <pre><code class="language-go">func newCachingRepo(ctx context.Context, path string, initRepo func(context.Context) (Repo, error)) *cachingRepo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newCodeRepo" data-name="newCodeRepo">
               <h3>
                  newCodeRepo 
                  <span class="badge">function</span>
                  
                  <a href="#newCodeRepo" class="anchor" title="Link to newCodeRepo">#</a>
               </h3>
               
               <p>newCodeRepo returns a Repo that reads the source code for the module with the
given path, from the repo stored in code, with the root of the repo
containing the path given by codeRoot.</p>
               
               <pre><code class="language-go">func newCodeRepo(code codehost.Repo, codeRoot string, path string) (Repo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newLoggingRepo" data-name="newLoggingRepo">
               <h3>
                  newLoggingRepo 
                  <span class="badge">function</span>
                  
                  <a href="#newLoggingRepo" class="anchor" title="Link to newLoggingRepo">#</a>
               </h3>
               
               <pre><code class="language-go">func newLoggingRepo(r Repo) *loggingRepo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newProxyRepo" data-name="newProxyRepo">
               <h3>
                  newProxyRepo 
                  <span class="badge">function</span>
                  
                  <a href="#newProxyRepo" class="anchor" title="Link to newProxyRepo">#</a>
               </h3>
               
               <pre><code class="language-go">func newProxyRepo(baseURL string, path string) (Repo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="notExistErrorf" data-name="notExistErrorf">
               <h3>
                  notExistErrorf 
                  <span class="badge">function</span>
                  
                  <a href="#notExistErrorf" class="anchor" title="Link to notExistErrorf">#</a>
               </h3>
               
               <pre><code class="language-go">func notExistErrorf(format string, args ...any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pathEscape" data-name="pathEscape">
               <h3>
                  pathEscape 
                  <span class="badge">function</span>
                  
                  <a href="#pathEscape" class="anchor" title="Link to pathEscape">#</a>
               </h3>
               
               <p>pathEscape escapes s so it can be used in a path.
That is, it escapes things like ? and # (which really shouldn't appear anyway).
It does not escape / to %2F: our REST API is designed so that / can be left as is.</p>
               
               <pre><code class="language-go">func pathEscape(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="proxyList" data-name="proxyList">
               <h3>
                  proxyList 
                  <span class="badge">function</span>
                  
                  <a href="#proxyList" class="anchor" title="Link to proxyList">#</a>
               </h3>
               
               <pre><code class="language-go">func proxyList() ([]proxySpec, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readDiskCache" data-name="readDiskCache">
               <h3>
                  readDiskCache 
                  <span class="badge">function</span>
                  
                  <a href="#readDiskCache" class="anchor" title="Link to readDiskCache">#</a>
               </h3>
               
               <p>readDiskCache is the generic "read from a cache file" implementation.
It takes the revision and an identifying suffix for the kind of data being cached.
It returns the name of the cache file and the content of the file.
If the read fails, the caller can use
writeDiskCache(file, data) to write a new cache entry.</p>
               
               <pre><code class="language-go">func readDiskCache(ctx context.Context, path string, rev string, suffix string) (file string, data []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readDiskGoMod" data-name="readDiskGoMod">
               <h3>
                  readDiskGoMod 
                  <span class="badge">function</span>
                  
                  <a href="#readDiskGoMod" class="anchor" title="Link to readDiskGoMod">#</a>
               </h3>
               
               <p>readDiskGoMod reads a cached go.mod file from disk,
returning the name of the cache file and the result.
If the read fails, the caller can use
writeDiskGoMod(file, data) to write a new cache entry.</p>
               
               <pre><code class="language-go">func readDiskGoMod(ctx context.Context, path string, rev string) (file string, data []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readDiskStat" data-name="readDiskStat">
               <h3>
                  readDiskStat 
                  <span class="badge">function</span>
                  
                  <a href="#readDiskStat" class="anchor" title="Link to readDiskStat">#</a>
               </h3>
               
               <p>readDiskStat reads a cached stat result from disk,
returning the name of the cache file and the result.
If the read fails, the caller can use
writeDiskStat(file, info) to write a new cache entry.</p>
               
               <pre><code class="language-go">func readDiskStat(ctx context.Context, path string, rev string) (file string, info *RevInfo, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readDiskStatByHash" data-name="readDiskStatByHash">
               <h3>
                  readDiskStatByHash 
                  <span class="badge">function</span>
                  
                  <a href="#readDiskStatByHash" class="anchor" title="Link to readDiskStatByHash">#</a>
               </h3>
               
               <p>readDiskStatByHash is a fallback for readDiskStat for the case
where rev is a commit hash instead of a proper semantic version.
In that case, we look for a cached pseudo-version that matches
the commit hash. If we find one, we use it.
This matters most for converting legacy package management
configs, when we are often looking up commits by full hash.
Without this check we'd be doing network I/O to the remote repo
just to find out about a commit we already know about
(and have cached under its pseudo-version).</p>
               
               <pre><code class="language-go">func readDiskStatByHash(ctx context.Context, path string, rev string) (file string, info *RevInfo, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readGoSum" data-name="readGoSum">
               <h3>
                  readGoSum 
                  <span class="badge">function</span>
                  
                  <a href="#readGoSum" class="anchor" title="Link to readGoSum">#</a>
               </h3>
               
               <p>readGoSum parses data, which is the content of file,
and adds it to goSum.m. The goSum lock must be held.</p>
               
               <pre><code class="language-go">func readGoSum(dst map[module.Version][]string, file string, data []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readGoSumFile" data-name="readGoSumFile">
               <h3>
                  readGoSumFile 
                  <span class="badge">function</span>
                  
                  <a href="#readGoSumFile" class="anchor" title="Link to readGoSumFile">#</a>
               </h3>
               
               <pre><code class="language-go">func readGoSumFile(dst map[module.Version][]string, file string) (bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="repo" data-name="repo">
               <h3>
                  repo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#repo" class="anchor" title="Link to repo">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *cachingRepo) repo(ctx context.Context) Repo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="retractedVersions" data-name="retractedVersions">
               <h3>
                  retractedVersions 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#retractedVersions" class="anchor" title="Link to retractedVersions">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *codeRepo) retractedVersions(ctx context.Context) (func(string) bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="revToRev" data-name="revToRev">
               <h3>
                  revToRev 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#revToRev" class="anchor" title="Link to revToRev">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *codeRepo) revToRev(rev string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rewriteVersionList" data-name="rewriteVersionList">
               <h3>
                  rewriteVersionList 
                  <span class="badge">function</span>
                  
                  <a href="#rewriteVersionList" class="anchor" title="Link to rewriteVersionList">#</a>
               </h3>
               
               <p>rewriteVersionList rewrites the version list in dir
after a new *.mod file has been written.</p>
               
               <pre><code class="language-go">func rewriteVersionList(ctx context.Context, dir string) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sumInWorkspaceModulesLocked" data-name="sumInWorkspaceModulesLocked">
               <h3>
                  sumInWorkspaceModulesLocked 
                  <span class="badge">function</span>
                  
                  <a href="#sumInWorkspaceModulesLocked" class="anchor" title="Link to sumInWorkspaceModulesLocked">#</a>
               </h3>
               
               <pre><code class="language-go">func sumInWorkspaceModulesLocked(m module.Version) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tempFile" data-name="tempFile">
               <h3>
                  tempFile 
                  <span class="badge">function</span>
                  
                  <a href="#tempFile" class="anchor" title="Link to tempFile">#</a>
               </h3>
               
               <p>tempFile creates a new temporary file with given permission bits.</p>
               
               <pre><code class="language-go">func tempFile(ctx context.Context, dir string, prefix string, perm fs.FileMode) (f *os.File, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tidyGoSum" data-name="tidyGoSum">
               <h3>
                  tidyGoSum 
                  <span class="badge">function</span>
                  
                  <a href="#tidyGoSum" class="anchor" title="Link to tidyGoSum">#</a>
               </h3>
               
               <p>tidyGoSum returns a tidy version of the go.sum file.
The goSum lock must be held.</p>
               
               <pre><code class="language-go">func tidyGoSum(data []byte, keep map[module.Version]bool) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unzip" data-name="unzip">
               <h3>
                  unzip 
                  <span class="badge">function</span>
                  
                  <a href="#unzip" class="anchor" title="Link to unzip">#</a>
               </h3>
               
               <pre><code class="language-go">func unzip(ctx context.Context, mod module.Version, zipfile string) (dir string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="useSumDB" data-name="useSumDB">
               <h3>
                  useSumDB 
                  <span class="badge">function</span>
                  
                  <a href="#useSumDB" class="anchor" title="Link to useSumDB">#</a>
               </h3>
               
               <p>useSumDB reports whether to use the Go checksum database for the given module.</p>
               
               <pre><code class="language-go">func useSumDB(mod module.Version) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="useSumDB" data-name="useSumDB">
               <h3>
                  useSumDB 
                  <span class="badge">function</span>
                  
                  <a href="#useSumDB" class="anchor" title="Link to useSumDB">#</a>
               </h3>
               
               <pre><code class="language-go">func useSumDB(mod module.Version) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validatePseudoVersion" data-name="validatePseudoVersion">
               <h3>
                  validatePseudoVersion 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#validatePseudoVersion" class="anchor" title="Link to validatePseudoVersion">#</a>
               </h3>
               
               <p>validatePseudoVersion checks that version has a major version compatible with
r.modPath and encodes a base version and commit metadata that agrees with
info.
Note that verifying a nontrivial base version in particular may be somewhat
expensive: in order to do so, r.code.DescendsFrom will need to fetch at least
enough of the commit history to find a path between version and its base.
Fortunately, many pseudo-versions — such as those for untagged repositories —
have trivial bases!</p>
               
               <pre><code class="language-go">func (r *codeRepo) validatePseudoVersion(ctx context.Context, info *codehost.RevInfo, version string) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="versionError" data-name="versionError">
               <h3>
                  versionError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#versionError" class="anchor" title="Link to versionError">#</a>
               </h3>
               
               <p>versionError returns err wrapped in a ModuleError for p.path.</p>
               
               <pre><code class="language-go">func (p *proxyRepo) versionError(version string, err error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="versionToRev" data-name="versionToRev">
               <h3>
                  versionToRev 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#versionToRev" class="anchor" title="Link to versionToRev">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *codeRepo) versionToRev(version string) (rev string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeDiskCache" data-name="writeDiskCache">
               <h3>
                  writeDiskCache 
                  <span class="badge">function</span>
                  
                  <a href="#writeDiskCache" class="anchor" title="Link to writeDiskCache">#</a>
               </h3>
               
               <p>writeDiskCache is the generic "write to a cache file" implementation.
The file must have been returned by a previous call to readDiskCache.</p>
               
               <pre><code class="language-go">func writeDiskCache(ctx context.Context, file string, data []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeDiskGoMod" data-name="writeDiskGoMod">
               <h3>
                  writeDiskGoMod 
                  <span class="badge">function</span>
                  
                  <a href="#writeDiskGoMod" class="anchor" title="Link to writeDiskGoMod">#</a>
               </h3>
               
               <p>writeDiskGoMod writes a go.mod cache entry.
The file name must have been returned by a previous call to readDiskGoMod.</p>
               
               <pre><code class="language-go">func writeDiskGoMod(ctx context.Context, file string, text []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeDiskStat" data-name="writeDiskStat">
               <h3>
                  writeDiskStat 
                  <span class="badge">function</span>
                  
                  <a href="#writeDiskStat" class="anchor" title="Link to writeDiskStat">#</a>
               </h3>
               
               <p>writeDiskStat writes a stat result cache entry.
The file name must have been returned by a previous call to readDiskStat.</p>
               
               <pre><code class="language-go">func writeDiskStat(ctx context.Context, file string, info *RevInfo) error</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>