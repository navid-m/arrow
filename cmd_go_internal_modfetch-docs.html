<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - modfetch</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="cmd_go_internal_modfetch_codehost-docs.html">codehost</a>
         <br />
         
         <a href="cmd_go_internal_modfetch_zip_sum_test-docs.html">zip_sum_test</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>modfetch</code>
         </h1>
         <hr />
         
         <article class="global" data-name="dbOnce">
            <h2>dbOnce</h2>
            <hr />
            
            <pre><code>dbOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="dbName">
            <h2>dbName</h2>
            <hr />
            
            <pre><code>dbName string</code></pre>
         </article>
         
         <article class="global" data-name="db">
            <h2>db</h2>
            <hr />
            
            <pre><code>db *sumdb.Client</code></pre>
         </article>
         
         <article class="global" data-name="dbErr">
            <h2>dbErr</h2>
            <hr />
            
            <pre><code>dbErr error</code></pre>
         </article>
         
         <article class="global" data-name="vgotest1git">
            <h2>vgotest1git</h2>
            <hr />
            
            <pre><code>vgotest1git</code></pre>
         </article>
         
         <article class="global" data-name="vgotest1hg">
            <h2>vgotest1hg</h2>
            <hr />
            
            <pre><code>vgotest1hg</code></pre>
         </article>
         
         <article class="global" data-name="altVgotests">
            <h2>altVgotests</h2>
            <hr />
            
            <pre><code>altVgotests</code></pre>
         </article>
         
         <article class="global" data-name="codeRepoTests">
            <h2>codeRepoTests</h2>
            <hr />
            
            <pre><code>codeRepoTests</code></pre>
         </article>
         
         <article class="global" data-name="hgmap">
            <h2>hgmap</h2>
            <hr />
            
            <pre><code>hgmap</code></pre>
         </article>
         
         <article class="global" data-name="codeRepoVersionsTests">
            <h2>codeRepoVersionsTests</h2>
            <hr />
            
            <pre><code>codeRepoVersionsTests</code></pre>
         </article>
         
         <article class="global" data-name="latestTests">
            <h2>latestTests</h2>
            <hr />
            
            <pre><code>latestTests</code></pre>
         </article>
         
         <article class="global" data-name="knownGOSUMDB">
            <h2>knownGOSUMDB</h2>
            <hr />
            
            <pre><code>knownGOSUMDB</code></pre>
         </article>
         
         <article class="global" data-name="HelpGoproxy">
            <h2>HelpGoproxy</h2>
            <hr />
            
            <pre><code>HelpGoproxy</code></pre>
         </article>
         
         <article class="global" data-name="proxyOnce">
            <h2>proxyOnce</h2>
            <hr />
            
            <pre><code>proxyOnce *ast.StructType</code></pre>
         </article>
         
         <article class="global" data-name="errProxyReuse">
            <h2>errProxyReuse</h2>
            <hr />
            
            <pre><code>errProxyReuse</code></pre>
         </article>
         
         <article class="global" data-name="errNotCached">
            <h2>errNotCached</h2>
            <hr />
            
            <pre><code>errNotCached</code></pre>
         </article>
         
         <article class="global" data-name="oldVgoPrefix">
            <h2>oldVgoPrefix</h2>
            <hr />
            
            <p>oldVgoPrefix is the prefix in the old auto-generated cached go.mod files.
We stopped trying to auto-generate the go.mod files. Now we use a trivial
go.mod with only a module line, and we've dropped the version prefix
entirely. If we see a version prefix, that means we're looking at an old copy
and should ignore it.</p>
            
            <pre><code>oldVgoPrefix</code></pre>
         </article>
         
         <article class="global" data-name="statCacheOnce">
            <h2>statCacheOnce</h2>
            <hr />
            
            <pre><code>statCacheOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="statCacheErr">
            <h2>statCacheErr</h2>
            <hr />
            
            <pre><code>statCacheErr error</code></pre>
         </article>
         
         <article class="global" data-name="counterErrorsGOMODCACHEEntryRelative">
            <h2>counterErrorsGOMODCACHEEntryRelative</h2>
            <hr />
            
            <pre><code>counterErrorsGOMODCACHEEntryRelative</code></pre>
         </article>
         
         <article class="global" data-name="downloadCache">
            <h2>downloadCache</h2>
            <hr />
            
            <pre><code>downloadCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="ErrToolchain">
            <h2>ErrToolchain</h2>
            <hr />
            
            <pre><code>ErrToolchain</code></pre>
         </article>
         
         <article class="global" data-name="downloadZipCache">
            <h2>downloadZipCache</h2>
            <hr />
            
            <pre><code>downloadZipCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="GoSumFile">
            <h2>GoSumFile</h2>
            <hr />
            
            <pre><code>GoSumFile string</code></pre>
         </article>
         
         <article class="global" data-name="WorkspaceGoSumFiles">
            <h2>WorkspaceGoSumFiles</h2>
            <hr />
            
            <pre><code>WorkspaceGoSumFiles []string</code></pre>
         </article>
         
         <article class="global" data-name="goSum">
            <h2>goSum</h2>
            <hr />
            
            <pre><code>goSum *ast.StructType</code></pre>
         </article>
         
         <article class="global" data-name="emptyGoModHash">
            <h2>emptyGoModHash</h2>
            <hr />
            
            <p>emptyGoModHash is the hash of a 1-file tree containing a 0-length go.mod.
A bug caused us to write these into go.sum files for non-modules.
We detect and remove them.</p>
            
            <pre><code>emptyGoModHash</code></pre>
         </article>
         
         <article class="global" data-name="ErrGoSumDirty">
            <h2>ErrGoSumDirty</h2>
            <hr />
            
            <pre><code>ErrGoSumDirty</code></pre>
         </article>
         
         <article class="global" data-name="goSumMismatch">
            <h2>goSumMismatch</h2>
            <hr />
            
            <pre><code>goSumMismatch</code></pre>
         </article>
         
         <article class="global" data-name="sumdbMismatch">
            <h2>sumdbMismatch</h2>
            <hr />
            
            <pre><code>sumdbMismatch</code></pre>
         </article>
         
         <article class="global" data-name="hashVersionMismatch">
            <h2>hashVersionMismatch</h2>
            <hr />
            
            <pre><code>hashVersionMismatch</code></pre>
         </article>
         
         <article class="global" data-name="HelpModuleAuth">
            <h2>HelpModuleAuth</h2>
            <hr />
            
            <pre><code>HelpModuleAuth</code></pre>
         </article>
         
         <article class="global" data-name="HelpPrivate">
            <h2>HelpPrivate</h2>
            <hr />
            
            <pre><code>HelpPrivate</code></pre>
         </article>
         
         <article class="global" data-name="traceRepo">
            <h2>traceRepo</h2>
            <hr />
            
            <pre><code>traceRepo</code></pre>
         </article>
         
         <article class="global" data-name="lookupCache">
            <h2>lookupCache</h2>
            <hr />
            
            <pre><code>lookupCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="lookupLocalCache">
            <h2>lookupLocalCache</h2>
            <hr />
            
            <pre><code>lookupLocalCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="errLookupDisabled">
            <h2>errLookupDisabled</h2>
            <hr />
            
            <pre><code>errLookupDisabled error</code></pre>
         </article>
         
         <article class="global" data-name="errProxyOff">
            <h2>errProxyOff</h2>
            <hr />
            
            <pre><code>errProxyOff</code></pre>
         </article>
         
         <article class="global" data-name="errNoproxy">
            <h2>errNoproxy</h2>
            <hr />
            
            <pre><code>errNoproxy error</code></pre>
         </article>
         
         <article class="global" data-name="errUseProxy">
            <h2>errUseProxy</h2>
            <hr />
            
            <pre><code>errUseProxy error</code></pre>
         </article>
          
         <article class="struct" data-name="dbClient">
            <h2>type dbClient struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">key string
name string
direct *url.URL
once sync.Once
base *url.URL
baseErr error</code></pre>
         </article>
         
         <article class="struct" data-name="codeRepo">
            <h2>type codeRepo struct</h2>
            <hr />
            
            <p>A codeRepo implements modfetch.Repo using an underlying codehost.Repo.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">modPath string
code codehost.Repo
codeRoot string
codeDir string
pathMajor string
pathPrefix string
pseudoMajor string</code></pre>
         </article>
         
         <article class="struct" data-name="zipFile">
            <h2>type zipFile struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
f *zip.File</code></pre>
         </article>
         
         <article class="struct" data-name="dataFile">
            <h2>type dataFile struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
data []byte</code></pre>
         </article>
         
         <article class="struct" data-name="dataFileInfo">
            <h2>type dataFileInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">f dataFile</code></pre>
         </article>
         
         <article class="struct" data-name="codeRepoTest">
            <h2>type codeRepoTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">vcs string
path string
mpath string
rev string
err string
version string
name string
short string
time time.Time
gomod string
gomodErr string
zip []string
zipErr string
zipSum string
zipFileHash string</code></pre>
         </article>
         
         <article class="struct" data-name="fixedTagsRepo">
            <h2>type fixedTagsRepo struct</h2>
            <hr />
            
            <p>fixedTagsRepo is a fake codehost.Repo that returns a fixed list of tags</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">tags []string
codehost.Repo</code></pre>
         </article>
         
         <article class="struct" data-name="proxySpec">
            <h2>type proxySpec struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">url string
fallBackOnError bool</code></pre>
         </article>
         
         <article class="struct" data-name="proxyRepo">
            <h2>type proxyRepo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">url *url.URL
path string
redactedBase string
listLatestOnce sync.Once
listLatest *RevInfo
listLatestErr error</code></pre>
         </article>
         
         <article class="struct" data-name="toolchainRepo">
            <h2>type toolchainRepo struct</h2>
            <hr />
            
            <p>A toolchainRepo is a synthesized repository reporting Go toolchain versions.
It has path "go" or "toolchain". The "go" repo reports versions like "1.2".
The "toolchain" repo reports versions like "go1.2".

Note that the repo ONLY reports versions. It does not actually support
downloading of the actual toolchains. Instead, that is done using
the regular repo code with "golang.org/toolchain".
The naming conflict is unfortunate: "golang.org/toolchain"
should perhaps have been "go.dev/dl", but it's too late.

For clarity, this file refers to golang.org/toolchain as the "DL" repo,
the one you can actually download.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string
repo Repo</code></pre>
         </article>
         
         <article class="struct" data-name="DownloadDirPartialError">
            <h2>type DownloadDirPartialError struct</h2>
            <hr />
            
            <p>DownloadDirPartialError is returned by DownloadDir if a module directory
exists but was not completely populated.

DownloadDirPartialError is equivalent to fs.ErrNotExist.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Dir string
Err error</code></pre>
         </article>
         
         <article class="struct" data-name="cachingRepo">
            <h2>type cachingRepo struct</h2>
            <hr />
            
            <p>A cachingRepo is a cache around an underlying Repo,
avoiding redundant calls to ModulePath, Versions, Stat, Latest, and GoMod (but not CheckReuse or Zip).
It is also safe for simultaneous use by multiple goroutines
(so that it can be returned from Lookup multiple times).
It serializes calls to the underlying Repo.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string
versionsCache *ast.IndexListExpr
statCache *ast.IndexListExpr
latestCache *ast.IndexListExpr
gomodCache *ast.IndexListExpr
once sync.Once
initRepo func
r Repo</code></pre>
         </article>
         
         <article class="struct" data-name="cachedInfo">
            <h2>type cachedInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">info *RevInfo
err error</code></pre>
         </article>
         
         <article class="struct" data-name="modSum">
            <h2>type modSum struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">mod module.Version
sum string</code></pre>
         </article>
         
         <article class="struct" data-name="modSumStatus">
            <h2>type modSumStatus struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">used bool
dirty bool</code></pre>
         </article>
         
         <article class="struct" data-name="Versions">
            <h2>type Versions struct</h2>
            <hr />
            
            <p>A Versions describes the available versions in a module repository.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Origin *codehost.Origin
List []string</code></pre>
         </article>
         
         <article class="struct" data-name="RevInfo">
            <h2>type RevInfo struct</h2>
            <hr />
            
            <p>A RevInfo describes a single revision in a module repository.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Version string
Time time.Time
Name string
Short string
Origin *codehost.Origin</code></pre>
         </article>
         
         <article class="struct" data-name="lookupCacheKey">
            <h2>type lookupCacheKey struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">proxy string
path string</code></pre>
         </article>
         
         <article class="struct" data-name="lookupDisabledError">
            <h2>type lookupDisabledError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="loggingRepo">
            <h2>type loggingRepo struct</h2>
            <hr />
            
            <p>A loggingRepo is a wrapper around an underlying Repo
that prints a log message at the start and end of each call.
It can be inserted when debugging.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">r Repo</code></pre>
         </article>
         
         <article class="struct" data-name="errRepo">
            <h2>type errRepo struct</h2>
            <hr />
            
            <p>errRepo is a Repo that returns the same error for all operations.

It is useful in conjunction with caching, since cache hits will not attempt
the prohibited operations.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">modulePath string
err error</code></pre>
         </article>
         
         <article class="struct" data-name="notExistError">
            <h2>type notExistError struct</h2>
            <hr />
            
            <p>A notExistError is like fs.ErrNotExist, but with a custom message</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">err error</code></pre>
         </article>
          
         <article class="function" data-name="useSumDB">
            <h2>useSumDB</h2>
            <hr />
            
            <p>useSumDB reports whether to use the Go checksum database for the given module.</p>
            
            <pre><code>func useSumDB(mod module.Version) bool</code></pre>
         </article>
         
         <article class="function" data-name="lookupSumDB">
            <h2>lookupSumDB</h2>
            <hr />
            
            <p>lookupSumDB returns the Go checksum database's go.sum lines for the given module,
along with the name of the database.</p>
            
            <pre><code>func lookupSumDB(mod module.Version) (dbname string, lines []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="dbDial">
            <h2>dbDial</h2>
            <hr />
            
            <pre><code>func dbDial() (dbName string, db *sumdb.Client, err error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadRemote">
            <h2>ReadRemote</h2>
            <hr />
            
            <pre><code>func ReadRemote(path string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="initBase">
            <h2>initBase</h2>
            <hr />
            
            <p>initBase determines the base URL for connecting to the database.
Determining the URL requires sending network traffic to proxies,
so this work is delayed until we need to download something from
the database. If everything we need is in the local cache and
c.ReadRemote is never called, we will never do this work.</p>
            
            <pre><code>func initBase()</code></pre>
         </article>
         
         <article class="function" data-name="ReadConfig">
            <h2>ReadConfig</h2>
            <hr />
            
            <p>ReadConfig reads the key from c.key
and otherwise reads the config (a latest tree head) from GOPATH/pkg/sumdb/<file>.</p>
            
            <pre><code>func ReadConfig(file string) (data []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteConfig">
            <h2>WriteConfig</h2>
            <hr />
            
            <p>WriteConfig rewrites the latest tree head.</p>
            
            <pre><code>func WriteConfig(file string, old []byte, new []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="ReadCache">
            <h2>ReadCache</h2>
            <hr />
            
            <p>ReadCache reads cached lookups or tiles from
GOPATH/pkg/mod/cache/download/sumdb,
which will be deleted by "go clean -modcache".</p>
            
            <pre><code>func ReadCache(file string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteCache">
            <h2>WriteCache</h2>
            <hr />
            
            <p>WriteCache updates cached lookups or tiles.</p>
            
            <pre><code>func WriteCache(file string, data []byte)</code></pre>
         </article>
         
         <article class="function" data-name="Log">
            <h2>Log</h2>
            <hr />
            
            <pre><code>func Log(msg string)</code></pre>
         </article>
         
         <article class="function" data-name="SecurityError">
            <h2>SecurityError</h2>
            <hr />
            
            <pre><code>func SecurityError(msg string)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriteDiskCache">
            <h2>TestWriteDiskCache</h2>
            <hr />
            
            <pre><code>func TestWriteDiskCache(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="newCodeRepo">
            <h2>newCodeRepo</h2>
            <hr />
            
            <p>newCodeRepo returns a Repo that reads the source code for the module with the
given path, from the repo stored in code, with the root of the repo
containing the path given by codeRoot.</p>
            
            <pre><code>func newCodeRepo(code codehost.Repo, codeRoot string, path string) (Repo, error)</code></pre>
         </article>
         
         <article class="function" data-name="ModulePath">
            <h2>ModulePath</h2>
            <hr />
            
            <pre><code>func ModulePath() string</code></pre>
         </article>
         
         <article class="function" data-name="CheckReuse">
            <h2>CheckReuse</h2>
            <hr />
            
            <pre><code>func CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
         </article>
         
         <article class="function" data-name="Versions">
            <h2>Versions</h2>
            <hr />
            
            <pre><code>func Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
         </article>
         
         <article class="function" data-name="appendIncompatibleVersions">
            <h2>appendIncompatibleVersions</h2>
            <hr />
            
            <p>appendIncompatibleVersions appends "+incompatible" versions to list if
appropriate, returning the final list.

The incompatible list contains candidate versions without the '+incompatible'
prefix.

Both list and incompatible must be sorted in semantic order.</p>
            
            <pre><code>func appendIncompatibleVersions(ctx context.Context, origin *codehost.Origin, list []string, incompatible []string) (*Versions, error)</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <pre><code>func Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Latest">
            <h2>Latest</h2>
            <hr />
            
            <pre><code>func Latest(ctx context.Context) (*RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="convert">
            <h2>convert</h2>
            <hr />
            
            <p>convert converts a version as reported by the code host to a version as
interpreted by the module system.

If statVers is a valid module version, it is used for the Version field.
Otherwise, the Version is derived from the passed-in info and recent tags.</p>
            
            <pre><code>func convert(ctx context.Context, info *codehost.RevInfo, statVers string) (revInfo *RevInfo, err error)</code></pre>
         </article>
         
         <article class="function" data-name="validatePseudoVersion">
            <h2>validatePseudoVersion</h2>
            <hr />
            
            <p>validatePseudoVersion checks that version has a major version compatible with
r.modPath and encodes a base version and commit metadata that agrees with
info.

Note that verifying a nontrivial base version in particular may be somewhat
expensive: in order to do so, r.code.DescendsFrom will need to fetch at least
enough of the commit history to find a path between version and its base.
Fortunately, many pseudo-versions — such as those for untagged repositories —
have trivial bases!</p>
            
            <pre><code>func validatePseudoVersion(ctx context.Context, info *codehost.RevInfo, version string) err error</code></pre>
         </article>
         
         <article class="function" data-name="revToRev">
            <h2>revToRev</h2>
            <hr />
            
            <pre><code>func revToRev(rev string) string</code></pre>
         </article>
         
         <article class="function" data-name="versionToRev">
            <h2>versionToRev</h2>
            <hr />
            
            <pre><code>func versionToRev(version string) (rev string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="findDir">
            <h2>findDir</h2>
            <hr />
            
            <p>findDir locates the directory within the repo containing the module.

If r.pathMajor is non-empty, this can be either r.codeDir or — if a go.mod
file exists — r.codeDir/r.pathMajor[1:].</p>
            
            <pre><code>func findDir(ctx context.Context, version string) (rev string, dir string, gomod []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="isMajor">
            <h2>isMajor</h2>
            <hr />
            
            <p>isMajor reports whether the versions allowed for mpath are compatible with
the major version(s) implied by pathMajor, or false if mpath has an invalid
version suffix.</p>
            
            <pre><code>func isMajor(mpath string, pathMajor string) bool</code></pre>
         </article>
         
         <article class="function" data-name="canReplaceMismatchedVersionDueToBug">
            <h2>canReplaceMismatchedVersionDueToBug</h2>
            <hr />
            
            <p>canReplaceMismatchedVersionDueToBug reports whether versions of r
could replace versions of mpath with otherwise-mismatched major versions
due to a historical bug in the Go command (golang.org/issue/34254).</p>
            
            <pre><code>func canReplaceMismatchedVersionDueToBug(mpath string) bool</code></pre>
         </article>
         
         <article class="function" data-name="GoMod">
            <h2>GoMod</h2>
            <hr />
            
            <pre><code>func GoMod(ctx context.Context, version string) (data []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="LegacyGoMod">
            <h2>LegacyGoMod</h2>
            <hr />
            
            <p>LegacyGoMod generates a fake go.mod file for a module that doesn't have one.
The go.mod file contains a module directive and nothing else: no go version,
no requirements.

We used to try to build a go.mod reflecting pre-existing
package management metadata files, but the conversion
was inherently imperfect (because those files don't have
exactly the same semantics as go.mod) and, when done
for dependencies in the middle of a build, impossible to
correct. So we stopped.</p>
            
            <pre><code>func LegacyGoMod(modPath string) []byte</code></pre>
         </article>
         
         <article class="function" data-name="modPrefix">
            <h2>modPrefix</h2>
            <hr />
            
            <pre><code>func modPrefix(rev string) string</code></pre>
         </article>
         
         <article class="function" data-name="retractedVersions">
            <h2>retractedVersions</h2>
            <hr />
            
            <pre><code>func retractedVersions(ctx context.Context) (func, error)</code></pre>
         </article>
         
         <article class="function" data-name="Zip">
            <h2>Zip</h2>
            <hr />
            
            <pre><code>func Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
         </article>
         
         <article class="function" data-name="Path">
            <h2>Path</h2>
            <hr />
            
            <pre><code>func Path() string</code></pre>
         </article>
         
         <article class="function" data-name="Lstat">
            <h2>Lstat</h2>
            <hr />
            
            <pre><code>func Lstat() (fs.FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <pre><code>func Open() (io.ReadCloser, error)</code></pre>
         </article>
         
         <article class="function" data-name="Path">
            <h2>Path</h2>
            <hr />
            
            <pre><code>func Path() string</code></pre>
         </article>
         
         <article class="function" data-name="Lstat">
            <h2>Lstat</h2>
            <hr />
            
            <pre><code>func Lstat() (fs.FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <pre><code>func Open() (io.ReadCloser, error)</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="Size">
            <h2>Size</h2>
            <hr />
            
            <pre><code>func Size() int64</code></pre>
         </article>
         
         <article class="function" data-name="Mode">
            <h2>Mode</h2>
            <hr />
            
            <pre><code>func Mode() fs.FileMode</code></pre>
         </article>
         
         <article class="function" data-name="ModTime">
            <h2>ModTime</h2>
            <hr />
            
            <pre><code>func ModTime() time.Time</code></pre>
         </article>
         
         <article class="function" data-name="IsDir">
            <h2>IsDir</h2>
            <hr />
            
            <pre><code>func IsDir() bool</code></pre>
         </article>
         
         <article class="function" data-name="Sys">
            <h2>Sys</h2>
            <hr />
            
            <pre><code>func Sys() any</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="hasPathPrefix">
            <h2>hasPathPrefix</h2>
            <hr />
            
            <p>hasPathPrefix reports whether the path s begins with the
elements in prefix.</p>
            
            <pre><code>func hasPathPrefix(s string, prefix string) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestMain">
            <h2>TestMain</h2>
            <hr />
            
            <pre><code>func TestMain(m *testing.M)</code></pre>
         </article>
         
         <article class="function" data-name="testMain">
            <h2>testMain</h2>
            <hr />
            
            <pre><code>func testMain(m *testing.M) err error</code></pre>
         </article>
         
         <article class="function" data-name="TestCodeRepo">
            <h2>TestCodeRepo</h2>
            <hr />
            
            <pre><code>func TestCodeRepo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="remap">
            <h2>remap</h2>
            <hr />
            
            <pre><code>func remap(name string, m *ast.MapType) string</code></pre>
         </article>
         
         <article class="function" data-name="TestCodeRepoVersions">
            <h2>TestCodeRepoVersions</h2>
            <hr />
            
            <pre><code>func TestCodeRepoVersions(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLatest">
            <h2>TestLatest</h2>
            <hr />
            
            <pre><code>func TestLatest(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Tags">
            <h2>Tags</h2>
            <hr />
            
            <pre><code>func Tags(ctx context.Context, prefix string) (*codehost.Tags, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestNonCanonicalSemver">
            <h2>TestNonCanonicalSemver</h2>
            <hr />
            
            <pre><code>func TestNonCanonicalSemver(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="proxyList">
            <h2>proxyList</h2>
            <hr />
            
            <pre><code>func proxyList() ([]proxySpec, error)</code></pre>
         </article>
         
         <article class="function" data-name="TryProxies">
            <h2>TryProxies</h2>
            <hr />
            
            <p>TryProxies iterates f over each configured proxy (including "noproxy" and
"direct" if applicable) until f returns no error or until f returns an
error that is not equivalent to fs.ErrNotExist on a proxy configured
not to fall back on errors.

TryProxies then returns that final error.

If GOPROXY is set to "off", TryProxies invokes f once with the argument
"off".</p>
            
            <pre><code>func TryProxies(f func) error</code></pre>
         </article>
         
         <article class="function" data-name="newProxyRepo">
            <h2>newProxyRepo</h2>
            <hr />
            
            <pre><code>func newProxyRepo(baseURL string, path string) (Repo, error)</code></pre>
         </article>
         
         <article class="function" data-name="ModulePath">
            <h2>ModulePath</h2>
            <hr />
            
            <pre><code>func ModulePath() string</code></pre>
         </article>
         
         <article class="function" data-name="CheckReuse">
            <h2>CheckReuse</h2>
            <hr />
            
            <pre><code>func CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
         </article>
         
         <article class="function" data-name="versionError">
            <h2>versionError</h2>
            <hr />
            
            <p>versionError returns err wrapped in a ModuleError for p.path.</p>
            
            <pre><code>func versionError(version string, err error) error</code></pre>
         </article>
         
         <article class="function" data-name="getBytes">
            <h2>getBytes</h2>
            <hr />
            
            <pre><code>func getBytes(ctx context.Context, path string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="getBody">
            <h2>getBody</h2>
            <hr />
            
            <pre><code>func getBody(ctx context.Context, path string) (r io.ReadCloser, redactedURL string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Versions">
            <h2>Versions</h2>
            <hr />
            
            <pre><code>func Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
         </article>
         
         <article class="function" data-name="latest">
            <h2>latest</h2>
            <hr />
            
            <pre><code>func latest(ctx context.Context) (*RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="latestFromList">
            <h2>latestFromList</h2>
            <hr />
            
            <pre><code>func latestFromList(ctx context.Context, allLine []string) (*RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <pre><code>func Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Latest">
            <h2>Latest</h2>
            <hr />
            
            <pre><code>func Latest(ctx context.Context) (*RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="GoMod">
            <h2>GoMod</h2>
            <hr />
            
            <pre><code>func GoMod(ctx context.Context, version string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="Zip">
            <h2>Zip</h2>
            <hr />
            
            <pre><code>func Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
         </article>
         
         <article class="function" data-name="pathEscape">
            <h2>pathEscape</h2>
            <hr />
            
            <p>pathEscape escapes s so it can be used in a path.
That is, it escapes things like ? and # (which really shouldn't appear anyway).
It does not escape / to %2F: our REST API is designed so that / can be left as is.</p>
            
            <pre><code>func pathEscape(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="ModulePath">
            <h2>ModulePath</h2>
            <hr />
            
            <pre><code>func ModulePath() string</code></pre>
         </article>
         
         <article class="function" data-name="Versions">
            <h2>Versions</h2>
            <hr />
            
            <pre><code>func Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <pre><code>func Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Latest">
            <h2>Latest</h2>
            <hr />
            
            <pre><code>func Latest(ctx context.Context) (*RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="GoMod">
            <h2>GoMod</h2>
            <hr />
            
            <pre><code>func GoMod(ctx context.Context, version string) (data []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Zip">
            <h2>Zip</h2>
            <hr />
            
            <pre><code>func Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
         </article>
         
         <article class="function" data-name="CheckReuse">
            <h2>CheckReuse</h2>
            <hr />
            
            <pre><code>func CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
         </article>
         
         <article class="function" data-name="goToDL">
            <h2>goToDL</h2>
            <hr />
            
            <p>goToDL converts a Go version like "1.2" to a DL module version like "v0.0.1-go1.2.linux-amd64".</p>
            
            <pre><code>func goToDL(v string, goos string, goarch string) string</code></pre>
         </article>
         
         <article class="function" data-name="dlToGo">
            <h2>dlToGo</h2>
            <hr />
            
            <p>dlToGo converts a DL module version like "v0.0.1-go1.2.linux-amd64" to a Go version like "1.2".</p>
            
            <pre><code>func dlToGo(v string) (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="useSumDB">
            <h2>useSumDB</h2>
            <hr />
            
            <pre><code>func useSumDB(mod module.Version) bool</code></pre>
         </article>
         
         <article class="function" data-name="lookupSumDB">
            <h2>lookupSumDB</h2>
            <hr />
            
            <pre><code>func lookupSumDB(mod module.Version) (string, []string, error)</code></pre>
         </article>
         
         <article class="function" data-name="cacheDir">
            <h2>cacheDir</h2>
            <hr />
            
            <pre><code>func cacheDir(ctx context.Context, path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="CachePath">
            <h2>CachePath</h2>
            <hr />
            
            <pre><code>func CachePath(ctx context.Context, m module.Version, suffix string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="DownloadDir">
            <h2>DownloadDir</h2>
            <hr />
            
            <p>DownloadDir returns the directory to which m should have been downloaded.
An error will be returned if the module path or version cannot be escaped.
An error satisfying errors.Is(err, fs.ErrNotExist) will be returned
along with the directory if the directory does not exist or if the directory
is not completely populated.</p>
            
            <pre><code>func DownloadDir(ctx context.Context, m module.Version) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Is">
            <h2>Is</h2>
            <hr />
            
            <pre><code>func Is(err error) bool</code></pre>
         </article>
         
         <article class="function" data-name="lockVersion">
            <h2>lockVersion</h2>
            <hr />
            
            <p>lockVersion locks a file within the module cache that guards the downloading
and extraction of the zipfile for the given module version.</p>
            
            <pre><code>func lockVersion(ctx context.Context, mod module.Version) (unlock func, err error)</code></pre>
         </article>
         
         <article class="function" data-name="SideLock">
            <h2>SideLock</h2>
            <hr />
            
            <p>SideLock locks a file within the module cache that previously guarded
edits to files outside the cache, such as go.sum and go.mod files in the
user's working directory.
If err is nil, the caller MUST eventually call the unlock function.</p>
            
            <pre><code>func SideLock(ctx context.Context) (unlock func, err error)</code></pre>
         </article>
         
         <article class="function" data-name="newCachingRepo">
            <h2>newCachingRepo</h2>
            <hr />
            
            <pre><code>func newCachingRepo(ctx context.Context, path string, initRepo func) *cachingRepo</code></pre>
         </article>
         
         <article class="function" data-name="repo">
            <h2>repo</h2>
            <hr />
            
            <pre><code>func repo(ctx context.Context) Repo</code></pre>
         </article>
         
         <article class="function" data-name="CheckReuse">
            <h2>CheckReuse</h2>
            <hr />
            
            <pre><code>func CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
         </article>
         
         <article class="function" data-name="ModulePath">
            <h2>ModulePath</h2>
            <hr />
            
            <pre><code>func ModulePath() string</code></pre>
         </article>
         
         <article class="function" data-name="Versions">
            <h2>Versions</h2>
            <hr />
            
            <pre><code>func Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <pre><code>func Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Latest">
            <h2>Latest</h2>
            <hr />
            
            <pre><code>func Latest(ctx context.Context) (*RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="GoMod">
            <h2>GoMod</h2>
            <hr />
            
            <pre><code>func GoMod(ctx context.Context, version string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="Zip">
            <h2>Zip</h2>
            <hr />
            
            <pre><code>func Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
         </article>
         
         <article class="function" data-name="InfoFile">
            <h2>InfoFile</h2>
            <hr />
            
            <p>InfoFile is like Lookup(ctx, path).Stat(version) but also returns the name of the file
containing the cached information.</p>
            
            <pre><code>func InfoFile(ctx context.Context, path string, version string) (*RevInfo, string, error)</code></pre>
         </article>
         
         <article class="function" data-name="GoMod">
            <h2>GoMod</h2>
            <hr />
            
            <p>GoMod is like Lookup(ctx, path).GoMod(rev) but avoids the
repository path resolution in Lookup if the result is
already cached on local disk.</p>
            
            <pre><code>func GoMod(ctx context.Context, path string, rev string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="GoModFile">
            <h2>GoModFile</h2>
            <hr />
            
            <p>GoModFile is like GoMod but returns the name of the file containing
the cached information.</p>
            
            <pre><code>func GoModFile(ctx context.Context, path string, version string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="GoModSum">
            <h2>GoModSum</h2>
            <hr />
            
            <p>GoModSum returns the go.sum entry for the module version's go.mod file.
(That is, it returns the entry listed in go.sum as "path version/go.mod".)</p>
            
            <pre><code>func GoModSum(ctx context.Context, path string, version string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="readDiskStat">
            <h2>readDiskStat</h2>
            <hr />
            
            <p>readDiskStat reads a cached stat result from disk,
returning the name of the cache file and the result.
If the read fails, the caller can use
writeDiskStat(file, info) to write a new cache entry.</p>
            
            <pre><code>func readDiskStat(ctx context.Context, path string, rev string) (file string, info *RevInfo, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readDiskStatByHash">
            <h2>readDiskStatByHash</h2>
            <hr />
            
            <p>readDiskStatByHash is a fallback for readDiskStat for the case
where rev is a commit hash instead of a proper semantic version.
In that case, we look for a cached pseudo-version that matches
the commit hash. If we find one, we use it.
This matters most for converting legacy package management
configs, when we are often looking up commits by full hash.
Without this check we'd be doing network I/O to the remote repo
just to find out about a commit we already know about
(and have cached under its pseudo-version).</p>
            
            <pre><code>func readDiskStatByHash(ctx context.Context, path string, rev string) (file string, info *RevInfo, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readDiskGoMod">
            <h2>readDiskGoMod</h2>
            <hr />
            
            <p>readDiskGoMod reads a cached go.mod file from disk,
returning the name of the cache file and the result.
If the read fails, the caller can use
writeDiskGoMod(file, data) to write a new cache entry.</p>
            
            <pre><code>func readDiskGoMod(ctx context.Context, path string, rev string) (file string, data []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readDiskCache">
            <h2>readDiskCache</h2>
            <hr />
            
            <p>readDiskCache is the generic "read from a cache file" implementation.
It takes the revision and an identifying suffix for the kind of data being cached.
It returns the name of the cache file and the content of the file.
If the read fails, the caller can use
writeDiskCache(file, data) to write a new cache entry.</p>
            
            <pre><code>func readDiskCache(ctx context.Context, path string, rev string, suffix string) (file string, data []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="writeDiskStat">
            <h2>writeDiskStat</h2>
            <hr />
            
            <p>writeDiskStat writes a stat result cache entry.
The file name must have been returned by a previous call to readDiskStat.</p>
            
            <pre><code>func writeDiskStat(ctx context.Context, file string, info *RevInfo) error</code></pre>
         </article>
         
         <article class="function" data-name="writeDiskGoMod">
            <h2>writeDiskGoMod</h2>
            <hr />
            
            <p>writeDiskGoMod writes a go.mod cache entry.
The file name must have been returned by a previous call to readDiskGoMod.</p>
            
            <pre><code>func writeDiskGoMod(ctx context.Context, file string, text []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="writeDiskCache">
            <h2>writeDiskCache</h2>
            <hr />
            
            <p>writeDiskCache is the generic "write to a cache file" implementation.
The file must have been returned by a previous call to readDiskCache.</p>
            
            <pre><code>func writeDiskCache(ctx context.Context, file string, data []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="tempFile">
            <h2>tempFile</h2>
            <hr />
            
            <p>tempFile creates a new temporary file with given permission bits.</p>
            
            <pre><code>func tempFile(ctx context.Context, dir string, prefix string, perm fs.FileMode) (f *os.File, err error)</code></pre>
         </article>
         
         <article class="function" data-name="rewriteVersionList">
            <h2>rewriteVersionList</h2>
            <hr />
            
            <p>rewriteVersionList rewrites the version list in dir
after a new *.mod file has been written.</p>
            
            <pre><code>func rewriteVersionList(ctx context.Context, dir string) err error</code></pre>
         </article>
         
         <article class="function" data-name="checkCacheDir">
            <h2>checkCacheDir</h2>
            <hr />
            
            <p>checkCacheDir checks if the directory specified by GOMODCACHE exists. An
error is returned if it does not.</p>
            
            <pre><code>func checkCacheDir(ctx context.Context) error</code></pre>
         </article>
         
         <article class="function" data-name="Download">
            <h2>Download</h2>
            <hr />
            
            <p>Download downloads the specific module version to the
local download cache and returns the name of the directory
corresponding to the root of the module's file tree.</p>
            
            <pre><code>func Download(ctx context.Context, mod module.Version) (dir string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Unzip">
            <h2>Unzip</h2>
            <hr />
            
            <p>Unzip is like Download but is given the explicit zip file to use,
rather than downloading it. This is used for the GOFIPS140 zip files,
which ship in the Go distribution itself.</p>
            
            <pre><code>func Unzip(ctx context.Context, mod module.Version, zipfile string) (dir string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="download">
            <h2>download</h2>
            <hr />
            
            <pre><code>func download(ctx context.Context, mod module.Version) (dir string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="unzip">
            <h2>unzip</h2>
            <hr />
            
            <pre><code>func unzip(ctx context.Context, mod module.Version, zipfile string) (dir string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="DownloadZip">
            <h2>DownloadZip</h2>
            <hr />
            
            <p>DownloadZip downloads the specific module version to the
local zip cache and returns the name of the zip file.</p>
            
            <pre><code>func DownloadZip(ctx context.Context, mod module.Version) (zipfile string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="downloadZip">
            <h2>downloadZip</h2>
            <hr />
            
            <pre><code>func downloadZip(ctx context.Context, mod module.Version, zipfile string) err error</code></pre>
         </article>
         
         <article class="function" data-name="hashZip">
            <h2>hashZip</h2>
            <hr />
            
            <p>hashZip reads the zip file opened in f, then writes the hash to ziphashfile,
overwriting that file if it exists.

If the hash does not match go.sum (or the sumdb if enabled), hashZip returns
an error and does not write ziphashfile.</p>
            
            <pre><code>func hashZip(mod module.Version, zipfile string, ziphashfile string) err error</code></pre>
         </article>
         
         <article class="function" data-name="makeDirsReadOnly">
            <h2>makeDirsReadOnly</h2>
            <hr />
            
            <p>makeDirsReadOnly makes a best-effort attempt to remove write permissions for dir
and its transitive contents.</p>
            
            <pre><code>func makeDirsReadOnly(dir string)</code></pre>
         </article>
         
         <article class="function" data-name="RemoveAll">
            <h2>RemoveAll</h2>
            <hr />
            
            <p>RemoveAll removes a directory written by Download or Unzip, first applying
any permission changes needed to do so.</p>
            
            <pre><code>func RemoveAll(dir string) error</code></pre>
         </article>
         
         <article class="function" data-name="Reset">
            <h2>Reset</h2>
            <hr />
            
            <p>Reset resets globals in the modfetch package, so previous loads don't affect
contents of go.sum files.</p>
            
            <pre><code>func Reset()</code></pre>
         </article>
         
         <article class="function" data-name="initGoSum">
            <h2>initGoSum</h2>
            <hr />
            
            <p>initGoSum initializes the go.sum data.
The boolean it returns reports whether the
use of go.sum is now enabled.
The goSum lock must be held.</p>
            
            <pre><code>func initGoSum() (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="readGoSumFile">
            <h2>readGoSumFile</h2>
            <hr />
            
            <pre><code>func readGoSumFile(dst *ast.MapType, file string) (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="readGoSum">
            <h2>readGoSum</h2>
            <hr />
            
            <p>readGoSum parses data, which is the content of file,
and adds it to goSum.m. The goSum lock must be held.</p>
            
            <pre><code>func readGoSum(dst *ast.MapType, file string, data []byte)</code></pre>
         </article>
         
         <article class="function" data-name="HaveSum">
            <h2>HaveSum</h2>
            <hr />
            
            <p>HaveSum returns true if the go.sum file contains an entry for mod.
The entry's hash must be generated with a known hash algorithm.
mod.Version may have a "/go.mod" suffix to distinguish sums for
.mod and .zip files.</p>
            
            <pre><code>func HaveSum(mod module.Version) bool</code></pre>
         </article>
         
         <article class="function" data-name="RecordedSum">
            <h2>RecordedSum</h2>
            <hr />
            
            <p>RecordedSum returns the sum if the go.sum file contains an entry for mod.
The boolean reports true if an entry was found or
false if no entry found or two conflicting sums are found.
The entry's hash must be generated with a known hash algorithm.
mod.Version may have a "/go.mod" suffix to distinguish sums for
.mod and .zip files.</p>
            
            <pre><code>func RecordedSum(mod module.Version) (sum string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="checkMod">
            <h2>checkMod</h2>
            <hr />
            
            <p>checkMod checks the given module's checksum and Go version.</p>
            
            <pre><code>func checkMod(ctx context.Context, mod module.Version)</code></pre>
         </article>
         
         <article class="function" data-name="goModSum">
            <h2>goModSum</h2>
            <hr />
            
            <p>goModSum returns the checksum for the go.mod contents.</p>
            
            <pre><code>func goModSum(data []byte) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="checkGoMod">
            <h2>checkGoMod</h2>
            <hr />
            
            <p>checkGoMod checks the given module's go.mod checksum;
data is the go.mod content.</p>
            
            <pre><code>func checkGoMod(path string, version string, data []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="checkModSum">
            <h2>checkModSum</h2>
            <hr />
            
            <p>checkModSum checks that the recorded checksum for mod is h.

mod.Version may have the additional suffix "/go.mod" to request the checksum
for the module's go.mod file only.</p>
            
            <pre><code>func checkModSum(mod module.Version, h string) error</code></pre>
         </article>
         
         <article class="function" data-name="haveModSumLocked">
            <h2>haveModSumLocked</h2>
            <hr />
            
            <p>haveModSumLocked reports whether the pair mod,h is already listed in go.sum.
If it finds a conflicting pair instead, it calls base.Fatalf.
goSum.mu must be locked.</p>
            
            <pre><code>func haveModSumLocked(mod module.Version, h string) bool</code></pre>
         </article>
         
         <article class="function" data-name="addModSumLocked">
            <h2>addModSumLocked</h2>
            <hr />
            
            <p>addModSumLocked adds the pair mod,h to go.sum.
goSum.mu must be locked.</p>
            
            <pre><code>func addModSumLocked(mod module.Version, h string)</code></pre>
         </article>
         
         <article class="function" data-name="checkSumDB">
            <h2>checkSumDB</h2>
            <hr />
            
            <p>checkSumDB checks the mod, h pair against the Go checksum database.
It calls base.Fatalf if the hash is to be rejected.</p>
            
            <pre><code>func checkSumDB(mod module.Version, h string) error</code></pre>
         </article>
         
         <article class="function" data-name="Sum">
            <h2>Sum</h2>
            <hr />
            
            <p>Sum returns the checksum for the downloaded copy of the given module,
if present in the download cache.</p>
            
            <pre><code>func Sum(ctx context.Context, mod module.Version) string</code></pre>
         </article>
         
         <article class="function" data-name="isValidSum">
            <h2>isValidSum</h2>
            <hr />
            
            <p>isValidSum returns true if data is the valid contents of a zip hash file.
Certain critical files are written to disk by first truncating
then writing the actual bytes, so that if the write fails
the corrupt file should contain at least one of the null
bytes written by the truncate operation.</p>
            
            <pre><code>func isValidSum(data []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="WriteGoSum">
            <h2>WriteGoSum</h2>
            <hr />
            
            <p>WriteGoSum writes the go.sum file if it needs to be updated.

keep is used to check whether a newly added sum should be saved in go.sum.
It should have entries for both module content sums and go.mod sums
(version ends with "/go.mod"). Existing sums will be preserved unless they
have been marked for deletion with TrimGoSum.</p>
            
            <pre><code>func WriteGoSum(ctx context.Context, keep *ast.MapType, readonly bool) error</code></pre>
         </article>
         
         <article class="function" data-name="TidyGoSum">
            <h2>TidyGoSum</h2>
            <hr />
            
            <p>TidyGoSum returns a tidy version of the go.sum file.
A missing go.sum file is treated as if empty.</p>
            
            <pre><code>func TidyGoSum(keep *ast.MapType) (before []byte, after []byte)</code></pre>
         </article>
         
         <article class="function" data-name="tidyGoSum">
            <h2>tidyGoSum</h2>
            <hr />
            
            <p>tidyGoSum returns a tidy version of the go.sum file.
The goSum lock must be held.</p>
            
            <pre><code>func tidyGoSum(data []byte, keep *ast.MapType) []byte</code></pre>
         </article>
         
         <article class="function" data-name="sumInWorkspaceModulesLocked">
            <h2>sumInWorkspaceModulesLocked</h2>
            <hr />
            
            <pre><code>func sumInWorkspaceModulesLocked(m module.Version) bool</code></pre>
         </article>
         
         <article class="function" data-name="TrimGoSum">
            <h2>TrimGoSum</h2>
            <hr />
            
            <p>TrimGoSum trims go.sum to contain only the modules needed for reproducible
builds.

keep is used to check whether a sum should be retained in go.mod. It should
have entries for both module content sums and go.mod sums (version ends
with "/go.mod").</p>
            
            <pre><code>func TrimGoSum(keep *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="Lookup">
            <h2>Lookup</h2>
            <hr />
            
            <p>Lookup returns the module with the given module path,
fetched through the given proxy.

The distinguished proxy "direct" indicates that the path should be fetched
from its origin, and "noproxy" indicates that the patch should be fetched
directly only if GONOPROXY matches the given path.

For the distinguished proxy "off", Lookup always returns a Repo that returns
a non-nil error for every method call.

A successful return does not guarantee that the module
has any defined versions.</p>
            
            <pre><code>func Lookup(ctx context.Context, proxy string, path string) Repo</code></pre>
         </article>
         
         <article class="function" data-name="LookupLocal">
            <h2>LookupLocal</h2>
            <hr />
            
            <p>LookupLocal will only use local VCS information to fetch the Repo.</p>
            
            <pre><code>func LookupLocal(ctx context.Context, path string) Repo</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup returns the module with the given module path.</p>
            
            <pre><code>func lookup(ctx context.Context, proxy string, path string) (r Repo, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="lookupDirect">
            <h2>lookupDirect</h2>
            <hr />
            
            <pre><code>func lookupDirect(ctx context.Context, path string) (Repo, error)</code></pre>
         </article>
         
         <article class="function" data-name="lookupCodeRepo">
            <h2>lookupCodeRepo</h2>
            <hr />
            
            <pre><code>func lookupCodeRepo(ctx context.Context, rr *vcs.RepoRoot, local bool) (codehost.Repo, error)</code></pre>
         </article>
         
         <article class="function" data-name="newLoggingRepo">
            <h2>newLoggingRepo</h2>
            <hr />
            
            <pre><code>func newLoggingRepo(r Repo) *loggingRepo</code></pre>
         </article>
         
         <article class="function" data-name="logCall">
            <h2>logCall</h2>
            <hr />
            
            <p>logCall prints a log message using format and args and then
also returns a function that will print the same message again,
along with the elapsed time.
Typical usage is:

	defer logCall("hello %s", arg)()

Note the final ().</p>
            
            <pre><code>func logCall(format string, args ...any) func</code></pre>
         </article>
         
         <article class="function" data-name="ModulePath">
            <h2>ModulePath</h2>
            <hr />
            
            <pre><code>func ModulePath() string</code></pre>
         </article>
         
         <article class="function" data-name="CheckReuse">
            <h2>CheckReuse</h2>
            <hr />
            
            <pre><code>func CheckReuse(ctx context.Context, old *codehost.Origin) err error</code></pre>
         </article>
         
         <article class="function" data-name="Versions">
            <h2>Versions</h2>
            <hr />
            
            <pre><code>func Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <pre><code>func Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Latest">
            <h2>Latest</h2>
            <hr />
            
            <pre><code>func Latest(ctx context.Context) (*RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="GoMod">
            <h2>GoMod</h2>
            <hr />
            
            <pre><code>func GoMod(ctx context.Context, version string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="Zip">
            <h2>Zip</h2>
            <hr />
            
            <pre><code>func Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
         </article>
         
         <article class="function" data-name="ModulePath">
            <h2>ModulePath</h2>
            <hr />
            
            <pre><code>func ModulePath() string</code></pre>
         </article>
         
         <article class="function" data-name="CheckReuse">
            <h2>CheckReuse</h2>
            <hr />
            
            <pre><code>func CheckReuse(ctx context.Context, old *codehost.Origin) error</code></pre>
         </article>
         
         <article class="function" data-name="Versions">
            <h2>Versions</h2>
            <hr />
            
            <pre><code>func Versions(ctx context.Context, prefix string) (*Versions, error)</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <pre><code>func Stat(ctx context.Context, rev string) (*RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Latest">
            <h2>Latest</h2>
            <hr />
            
            <pre><code>func Latest(ctx context.Context) (*RevInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="GoMod">
            <h2>GoMod</h2>
            <hr />
            
            <pre><code>func GoMod(ctx context.Context, version string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="Zip">
            <h2>Zip</h2>
            <hr />
            
            <pre><code>func Zip(ctx context.Context, dst io.Writer, version string) error</code></pre>
         </article>
         
         <article class="function" data-name="notExistErrorf">
            <h2>notExistErrorf</h2>
            <hr />
            
            <pre><code>func notExistErrorf(format string, args ...any) error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Is">
            <h2>Is</h2>
            <hr />
            
            <pre><code>func Is(target error) bool</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
