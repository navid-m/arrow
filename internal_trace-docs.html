<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - trace</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="internal_trace_event-docs.html">event</a></li>
               
               <li><a href="internal_trace_raw-docs.html">raw</a></li>
               
               <li><a href="internal_trace_testtrace-docs.html">testtrace</a></li>
               
               <li><a href="internal_trace_traceviewer-docs.html">traceviewer</a></li>
               
               <li><a href="internal_trace_version-docs.html">version</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>trace</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bytes"
"encoding/binary"
"fmt"
"io"
"internal/trace/event"
"internal/trace/event/go122"
"cmp"
"encoding/binary"
"fmt"
"internal/trace/event"
"internal/trace/event/go122"
"fmt"
"iter"
"math"
"strings"
"time"
"internal/trace/event"
"internal/trace/event/go122"
"internal/trace/version"
"errors"
"fmt"
"internal/trace/event"
"internal/trace/event/go122"
"internal/trace/internal/oldtrace"
"io"
"cmp"
"slices"
"strings"
"time"
"container/heap"
"math"
"sort"
"strings"
"time"
"bufio"
"bytes"
"cmp"
"encoding/binary"
"fmt"
"io"
"slices"
"strings"
"internal/trace/event"
"internal/trace/event/go122"
"cmp"
"math"
"slices"
"fmt"
"strings"
"internal/trace/event"
"internal/trace/event/go122"
"internal/trace/version"
"bufio"
"fmt"
"io"
"slices"
"strings"
"internal/trace/event/go122"
"internal/trace/internal/oldtrace"
"internal/trace/version"
"fmt"
"fmt"
"fmt"
"math"
"strings"
"internal/trace/event"
"internal/trace/event/go122"
"internal/trace/version"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="BackgroundTask">
               <h3>
                  BackgroundTask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>BackgroundTask is the global task that events are attached to if there was
no other task in the context at the point the event was emitted.</p>
               
               <pre><code>const BackgroundTask = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="EvBatch">
               <h3>
                  EvBatch 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvBatch = 1</code></pre>
            </article>
            
            <article class="global" data-name="EvCPUSample">
               <h3>
                  EvCPUSample 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvCPUSample = 49</code></pre>
            </article>
            
            <article class="global" data-name="EvCount">
               <h3>
                  EvCount 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvCount = 50</code></pre>
            </article>
            
            <article class="global" data-name="EvFrequency">
               <h3>
                  EvFrequency 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvFrequency = 2</code></pre>
            </article>
            
            <article class="global" data-name="EvFutileWakeup">
               <h3>
                  EvFutileWakeup 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvFutileWakeup = 36</code></pre>
            </article>
            
            <article class="global" data-name="EvGCDone">
               <h3>
                  EvGCDone 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGCDone = 8</code></pre>
            </article>
            
            <article class="global" data-name="EvGCMarkAssistDone">
               <h3>
                  EvGCMarkAssistDone 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGCMarkAssistDone = 44</code></pre>
            </article>
            
            <article class="global" data-name="EvGCMarkAssistStart">
               <h3>
                  EvGCMarkAssistStart 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGCMarkAssistStart = 43</code></pre>
            </article>
            
            <article class="global" data-name="EvGCStart">
               <h3>
                  EvGCStart 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGCStart = 7</code></pre>
            </article>
            
            <article class="global" data-name="EvGCSweepDone">
               <h3>
                  EvGCSweepDone 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGCSweepDone = 12</code></pre>
            </article>
            
            <article class="global" data-name="EvGCSweepStart">
               <h3>
                  EvGCSweepStart 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGCSweepStart = 11</code></pre>
            </article>
            
            <article class="global" data-name="EvGoBlock">
               <h3>
                  EvGoBlock 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoBlock = 20</code></pre>
            </article>
            
            <article class="global" data-name="EvGoBlockCond">
               <h3>
                  EvGoBlockCond 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoBlockCond = 26</code></pre>
            </article>
            
            <article class="global" data-name="EvGoBlockGC">
               <h3>
                  EvGoBlockGC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoBlockGC = 42</code></pre>
            </article>
            
            <article class="global" data-name="EvGoBlockNet">
               <h3>
                  EvGoBlockNet 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoBlockNet = 27</code></pre>
            </article>
            
            <article class="global" data-name="EvGoBlockRecv">
               <h3>
                  EvGoBlockRecv 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoBlockRecv = 23</code></pre>
            </article>
            
            <article class="global" data-name="EvGoBlockSelect">
               <h3>
                  EvGoBlockSelect 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoBlockSelect = 24</code></pre>
            </article>
            
            <article class="global" data-name="EvGoBlockSend">
               <h3>
                  EvGoBlockSend 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoBlockSend = 22</code></pre>
            </article>
            
            <article class="global" data-name="EvGoBlockSync">
               <h3>
                  EvGoBlockSync 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoBlockSync = 25</code></pre>
            </article>
            
            <article class="global" data-name="EvGoCreate">
               <h3>
                  EvGoCreate 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoCreate = 13</code></pre>
            </article>
            
            <article class="global" data-name="EvGoEnd">
               <h3>
                  EvGoEnd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoEnd = 15</code></pre>
            </article>
            
            <article class="global" data-name="EvGoInSyscall">
               <h3>
                  EvGoInSyscall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoInSyscall = 32</code></pre>
            </article>
            
            <article class="global" data-name="EvGoPreempt">
               <h3>
                  EvGoPreempt 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoPreempt = 18</code></pre>
            </article>
            
            <article class="global" data-name="EvGoSched">
               <h3>
                  EvGoSched 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoSched = 17</code></pre>
            </article>
            
            <article class="global" data-name="EvGoSleep">
               <h3>
                  EvGoSleep 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoSleep = 19</code></pre>
            </article>
            
            <article class="global" data-name="EvGoStart">
               <h3>
                  EvGoStart 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoStart = 14</code></pre>
            </article>
            
            <article class="global" data-name="EvGoStartLabel">
               <h3>
                  EvGoStartLabel 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoStartLabel = 41</code></pre>
            </article>
            
            <article class="global" data-name="EvGoStartLocal">
               <h3>
                  EvGoStartLocal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoStartLocal = 38</code></pre>
            </article>
            
            <article class="global" data-name="EvGoStop">
               <h3>
                  EvGoStop 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoStop = 16</code></pre>
            </article>
            
            <article class="global" data-name="EvGoSysBlock">
               <h3>
                  EvGoSysBlock 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoSysBlock = 30</code></pre>
            </article>
            
            <article class="global" data-name="EvGoSysCall">
               <h3>
                  EvGoSysCall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoSysCall = 28</code></pre>
            </article>
            
            <article class="global" data-name="EvGoSysExit">
               <h3>
                  EvGoSysExit 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoSysExit = 29</code></pre>
            </article>
            
            <article class="global" data-name="EvGoSysExitLocal">
               <h3>
                  EvGoSysExitLocal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoSysExitLocal = 40</code></pre>
            </article>
            
            <article class="global" data-name="EvGoUnblock">
               <h3>
                  EvGoUnblock 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoUnblock = 21</code></pre>
            </article>
            
            <article class="global" data-name="EvGoUnblockLocal">
               <h3>
                  EvGoUnblockLocal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoUnblockLocal = 39</code></pre>
            </article>
            
            <article class="global" data-name="EvGoWaiting">
               <h3>
                  EvGoWaiting 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGoWaiting = 31</code></pre>
            </article>
            
            <article class="global" data-name="EvGomaxprocs">
               <h3>
                  EvGomaxprocs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvGomaxprocs = 4</code></pre>
            </article>
            
            <article class="global" data-name="EvHeapAlloc">
               <h3>
                  EvHeapAlloc 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvHeapAlloc = 33</code></pre>
            </article>
            
            <article class="global" data-name="EvHeapGoal">
               <h3>
                  EvHeapGoal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvHeapGoal = 34</code></pre>
            </article>
            
            <article class="global" data-name="EvNone">
               <h3>
                  EvNone 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvNone = 0</code></pre>
            </article>
            
            <article class="global" data-name="EvProcStart">
               <h3>
                  EvProcStart 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvProcStart = 5</code></pre>
            </article>
            
            <article class="global" data-name="EvProcStop">
               <h3>
                  EvProcStop 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvProcStop = 6</code></pre>
            </article>
            
            <article class="global" data-name="EvSTWDone">
               <h3>
                  EvSTWDone 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvSTWDone = 10</code></pre>
            </article>
            
            <article class="global" data-name="EvSTWStart">
               <h3>
                  EvSTWStart 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvSTWStart = 9</code></pre>
            </article>
            
            <article class="global" data-name="EvStack">
               <h3>
                  EvStack 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvStack = 3</code></pre>
            </article>
            
            <article class="global" data-name="EvString">
               <h3>
                  EvString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvString = 37</code></pre>
            </article>
            
            <article class="global" data-name="EvTimerGoroutine">
               <h3>
                  EvTimerGoroutine 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvTimerGoroutine = 35</code></pre>
            </article>
            
            <article class="global" data-name="EvUserLog">
               <h3>
                  EvUserLog 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvUserLog = 48</code></pre>
            </article>
            
            <article class="global" data-name="EvUserRegion">
               <h3>
                  EvUserRegion 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvUserRegion = 47</code></pre>
            </article>
            
            <article class="global" data-name="EvUserTaskCreate">
               <h3>
                  EvUserTaskCreate 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvUserTaskCreate = 45</code></pre>
            </article>
            
            <article class="global" data-name="EvUserTaskEnd">
               <h3>
                  EvUserTaskEnd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Event types in the trace.
Verbatim copy from src/runtime/trace.go with the "trace" prefix removed.</p>
               
               <pre><code>const EvUserTaskEnd = 46</code></pre>
            </article>
            
            <article class="global" data-name="EventBad">
               <h3>
                  EventBad 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EventBad EventKind = iota</code></pre>
            </article>
            
            <article class="global" data-name="EventExperimental">
               <h3>
                  EventExperimental 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>EventExperimental is an experimental event that is unvalidated and exposed in a raw form.
Users are expected to understand the format and perform their own validation. These events
may always be safely ignored.</p>
               
               <pre><code>const EventExperimental</code></pre>
            </article>
            
            <article class="global" data-name="EventLabel">
               <h3>
                  EventLabel 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>EventLabel attaches a label to a resource.</p>
               
               <pre><code>const EventLabel</code></pre>
            </article>
            
            <article class="global" data-name="EventLog">
               <h3>
                  EventLog 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>EventLog represents a runtime/trace.Log call.</p>
               
               <pre><code>const EventLog</code></pre>
            </article>
            
            <article class="global" data-name="EventMetric">
               <h3>
                  EventMetric 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>EventMetric is an event that represents the value of a metric at
a particular point in time.</p>
               
               <pre><code>const EventMetric</code></pre>
            </article>
            
            <article class="global" data-name="EventRangeActive">
               <h3>
                  EventRangeActive 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EventRangeActive</code></pre>
            </article>
            
            <article class="global" data-name="EventRangeBegin">
               <h3>
                  EventRangeBegin 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>EventRangeBegin and EventRangeEnd are a pair of generic events representing
a special range of time. Ranges are named and scoped to some resource
(identified via ResourceKind). A range that has begun but has not ended
is considered active.
EvRangeBegin and EvRangeEnd will share the same name, and an End will always
follow a Begin on the same instance of the resource. The associated
resource ID can be obtained from the Event. ResourceNone indicates the
range is globally scoped. That is, any goroutine/proc/thread can start or
stop, but only one such range may be active at any given time.
EventRangeActive is like EventRangeBegin, but indicates that the range was
already active. In this case, the resource referenced may not be in the current
context.</p>
               
               <pre><code>const EventRangeBegin</code></pre>
            </article>
            
            <article class="global" data-name="EventRangeEnd">
               <h3>
                  EventRangeEnd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EventRangeEnd</code></pre>
            </article>
            
            <article class="global" data-name="EventRegionBegin">
               <h3>
                  EventRegionBegin 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>EventRegionBegin and EventRegionEnd are a pair of events represent a runtime/trace.Region.</p>
               
               <pre><code>const EventRegionBegin</code></pre>
            </article>
            
            <article class="global" data-name="EventRegionEnd">
               <h3>
                  EventRegionEnd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EventRegionEnd</code></pre>
            </article>
            
            <article class="global" data-name="EventStackSample">
               <h3>
                  EventStackSample 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>EventStackSample represents an execution sample, indicating what a
thread/proc/goroutine was doing at a particular point in time via
its backtrace.
Note: Samples should be considered a close approximation of
what a thread/proc/goroutine was executing at a given point in time.
These events may slightly contradict the situation StateTransitions
describe, so they should only be treated as a best-effort annotation.</p>
               
               <pre><code>const EventStackSample</code></pre>
            </article>
            
            <article class="global" data-name="EventStateTransition">
               <h3>
                  EventStateTransition 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>EventStateTransition represents a state change for some resource.</p>
               
               <pre><code>const EventStateTransition</code></pre>
            </article>
            
            <article class="global" data-name="EventSync">
               <h3>
                  EventSync 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>EventKindSync is an event that indicates a global synchronization
point in the trace. At the point of a sync event, the
trace reader can be certain that all resources (e.g. threads,
goroutines) that have existed until that point have been enumerated.</p>
               
               <pre><code>const EventSync</code></pre>
            </article>
            
            <article class="global" data-name="EventTaskBegin">
               <h3>
                  EventTaskBegin 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>EvTaskBegin and EvTaskEnd are a pair of events representing a runtime/trace.Task.</p>
               
               <pre><code>const EventTaskBegin</code></pre>
            </article>
            
            <article class="global" data-name="EventTaskEnd">
               <h3>
                  EventTaskEnd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EventTaskEnd</code></pre>
            </article>
            
            <article class="global" data-name="FakeP">
               <h3>
                  FakeP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Special P identifiers:</p>
               
               <pre><code>const FakeP = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="GCP">
               <h3>
                  GCP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const GCP</code></pre>
            </article>
            
            <article class="global" data-name="GoNotExist">
               <h3>
                  GoNotExist 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const GoNotExist</code></pre>
            </article>
            
            <article class="global" data-name="GoRunnable">
               <h3>
                  GoRunnable 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const GoRunnable</code></pre>
            </article>
            
            <article class="global" data-name="GoRunning">
               <h3>
                  GoRunning 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const GoRunning</code></pre>
            </article>
            
            <article class="global" data-name="GoSyscall">
               <h3>
                  GoSyscall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const GoSyscall</code></pre>
            </article>
            
            <article class="global" data-name="GoUndetermined">
               <h3>
                  GoUndetermined 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const GoUndetermined GoState = iota</code></pre>
            </article>
            
            <article class="global" data-name="GoWaiting">
               <h3>
                  GoWaiting 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const GoWaiting</code></pre>
            </article>
            
            <article class="global" data-name="NetpollP">
               <h3>
                  NetpollP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NetpollP</code></pre>
            </article>
            
            <article class="global" data-name="NoGoroutine">
               <h3>
                  NoGoroutine 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>NoGoroutine indicates that the relevant events don't correspond to any
goroutine in particular.</p>
               
               <pre><code>const NoGoroutine = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="NoProc">
               <h3>
                  NoProc 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>NoProc indicates that the relevant events don't correspond to any
P in particular.</p>
               
               <pre><code>const NoProc = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="NoStack">
               <h3>
                  NoStack 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>NoStack is a sentinel value that can be compared against any Stack value, indicating
a lack of a stack trace.</p>
               
               <pre><code>var NoStack = Stack{...}</code></pre>
            </article>
            
            <article class="global" data-name="NoTask">
               <h3>
                  NoTask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>NoTask indicates the lack of a task.</p>
               
               <pre><code>const NoTask = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="NoThread">
               <h3>
                  NoThread 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>NoThread indicates that the relevant events don't correspond to any
thread in particular.</p>
               
               <pre><code>const NoThread = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ProcIdle">
               <h3>
                  ProcIdle 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ProcIdle</code></pre>
            </article>
            
            <article class="global" data-name="ProcNotExist">
               <h3>
                  ProcNotExist 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ProcNotExist</code></pre>
            </article>
            
            <article class="global" data-name="ProcRunning">
               <h3>
                  ProcRunning 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ProcRunning</code></pre>
            </article>
            
            <article class="global" data-name="ProcUndetermined">
               <h3>
                  ProcUndetermined 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ProcUndetermined ProcState = iota</code></pre>
            </article>
            
            <article class="global" data-name="ProfileP">
               <h3>
                  ProfileP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ProfileP</code></pre>
            </article>
            
            <article class="global" data-name="ResourceGoroutine">
               <h3>
                  ResourceGoroutine 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ResourceGoroutine</code></pre>
            </article>
            
            <article class="global" data-name="ResourceNone">
               <h3>
                  ResourceNone 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ResourceNone ResourceKind = iota</code></pre>
            </article>
            
            <article class="global" data-name="ResourceProc">
               <h3>
                  ResourceProc 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ResourceProc</code></pre>
            </article>
            
            <article class="global" data-name="ResourceThread">
               <h3>
                  ResourceThread 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ResourceThread</code></pre>
            </article>
            
            <article class="global" data-name="SyscallP">
               <h3>
                  SyscallP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SyscallP</code></pre>
            </article>
            
            <article class="global" data-name="TimerP">
               <h3>
                  TimerP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TimerP</code></pre>
            </article>
            
            <article class="global" data-name="UtilAssist">
               <h3>
                  UtilAssist 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UtilAssist means utilization should account for mark
assists.</p>
               
               <pre><code>const UtilAssist</code></pre>
            </article>
            
            <article class="global" data-name="UtilBackground">
               <h3>
                  UtilBackground 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UtilBackground means utilization should account for
background mark workers.</p>
               
               <pre><code>const UtilBackground</code></pre>
            </article>
            
            <article class="global" data-name="UtilPerProc">
               <h3>
                  UtilPerProc 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UtilPerProc means each P should be given a separate
utilization function. Otherwise, there is a single function
and each P is given a fraction of the utilization.</p>
               
               <pre><code>const UtilPerProc</code></pre>
            </article>
            
            <article class="global" data-name="UtilSTW">
               <h3>
                  UtilSTW 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UtilSTW means utilization should account for STW events.
This includes non-GC STW events, which are typically user-requested.</p>
               
               <pre><code>const UtilSTW UtilFlags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="UtilSweep">
               <h3>
                  UtilSweep 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UtilSweep means utilization should account for sweeping.</p>
               
               <pre><code>const UtilSweep</code></pre>
            </article>
            
            <article class="global" data-name="ValueBad">
               <h3>
                  ValueBad 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ValueBad ValueKind = iota</code></pre>
            </article>
            
            <article class="global" data-name="ValueUint64">
               <h3>
                  ValueUint64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ValueUint64</code></pre>
            </article>
            
            <article class="global" data-name="bandsPerSeries">
               <h3>
                  bandsPerSeries 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>bandsPerSeries is the number of bands to divide each series into.
This is only changed by tests.</p>
               
               <pre><code>var bandsPerSeries = 1000</code></pre>
            </article>
            
            <article class="global" data-name="errSkip">
               <h3>
                  errSkip 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errSkip = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="evSync">
               <h3>
                  evSync 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const evSync = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="eventKindStrings">
               <h3>
                  eventKindStrings 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var eventKindStrings = [...]string{...}</code></pre>
            </article>
            
            <article class="global" data-name="gcNotRunning">
               <h3>
                  gcNotRunning 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gcNotRunning</code></pre>
            </article>
            
            <article class="global" data-name="gcRunning">
               <h3>
                  gcRunning 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gcRunning</code></pre>
            </article>
            
            <article class="global" data-name="gcUndetermined">
               <h3>
                  gcUndetermined 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gcUndetermined gcState = iota</code></pre>
            </article>
            
            <article class="global" data-name="go122GoStatus2GoState">
               <h3>
                  go122GoStatus2GoState 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var go122GoStatus2GoState = [...]GoState{...}</code></pre>
            </article>
            
            <article class="global" data-name="go122ProcStatus2ProcState">
               <h3>
                  go122ProcStatus2ProcState 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var go122ProcStatus2ProcState = [...]ProcState{...}</code></pre>
            </article>
            
            <article class="global" data-name="go122Type2Kind">
               <h3>
                  go122Type2Kind 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var go122Type2Kind = [...]EventKind{...}</code></pre>
            </article>
            
            <article class="global" data-name="maxArgs">
               <h3>
                  maxArgs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>maxArgs is the maximum number of arguments for "plain" events,
i.e. anything that could reasonably be represented as a baseEvent.</p>
               
               <pre><code>const maxArgs = 5</code></pre>
            </article>
            
            <article class="global" data-name="maxTime">
               <h3>
                  maxTime 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxTime = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="mudDegree">
               <h3>
                  mudDegree 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>mudDegree is the number of buckets in the MUD summary
histogram.</p>
               
               <pre><code>const mudDegree = 1024</code></pre>
            </article>
            
            <article class="global" data-name="orderingDispatch">
               <h3>
                  orderingDispatch 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var orderingDispatch = [256]orderingHandleFunc{...}</code></pre>
            </article>
            
            <article class="global" data-name="sChanRecv">
               <h3>
                  sChanRecv 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sChanRecv</code></pre>
            </article>
            
            <article class="global" data-name="sChanSend">
               <h3>
                  sChanSend 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sChanSend</code></pre>
            </article>
            
            <article class="global" data-name="sEmpty">
               <h3>
                  sEmpty 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sEmpty</code></pre>
            </article>
            
            <article class="global" data-name="sForever">
               <h3>
                  sForever 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Block reasons</p>
               
               <pre><code>const sForever = iota</code></pre>
            </article>
            
            <article class="global" data-name="sGosched">
               <h3>
                  sGosched 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sGosched</code></pre>
            </article>
            
            <article class="global" data-name="sLast">
               <h3>
                  sLast 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sLast</code></pre>
            </article>
            
            <article class="global" data-name="sMarkAssistWait">
               <h3>
                  sMarkAssistWait 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sMarkAssistWait</code></pre>
            </article>
            
            <article class="global" data-name="sNetwork">
               <h3>
                  sNetwork 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sNetwork</code></pre>
            </article>
            
            <article class="global" data-name="sPreempted">
               <h3>
                  sPreempted 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sPreempted</code></pre>
            </article>
            
            <article class="global" data-name="sSTWAllGoroutinesStackTrace">
               <h3>
                  sSTWAllGoroutinesStackTrace 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWAllGoroutinesStackTrace</code></pre>
            </article>
            
            <article class="global" data-name="sSTWAllThreadsSyscall">
               <h3>
                  sSTWAllThreadsSyscall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWAllThreadsSyscall</code></pre>
            </article>
            
            <article class="global" data-name="sSTWCountPagesInUse">
               <h3>
                  sSTWCountPagesInUse 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWCountPagesInUse</code></pre>
            </article>
            
            <article class="global" data-name="sSTWGCMarkTermination">
               <h3>
                  sSTWGCMarkTermination 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWGCMarkTermination</code></pre>
            </article>
            
            <article class="global" data-name="sSTWGCSweepTermination">
               <h3>
                  sSTWGCSweepTermination 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWGCSweepTermination</code></pre>
            </article>
            
            <article class="global" data-name="sSTWGOMAXPROCS">
               <h3>
                  sSTWGOMAXPROCS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWGOMAXPROCS</code></pre>
            </article>
            
            <article class="global" data-name="sSTWGoroutineProfile">
               <h3>
                  sSTWGoroutineProfile 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWGoroutineProfile</code></pre>
            </article>
            
            <article class="global" data-name="sSTWGoroutineProfileCleanup">
               <h3>
                  sSTWGoroutineProfileCleanup 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWGoroutineProfileCleanup</code></pre>
            </article>
            
            <article class="global" data-name="sSTWPageCachePagesLeaked">
               <h3>
                  sSTWPageCachePagesLeaked 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWPageCachePagesLeaked</code></pre>
            </article>
            
            <article class="global" data-name="sSTWReadMemStats">
               <h3>
                  sSTWReadMemStats 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWReadMemStats</code></pre>
            </article>
            
            <article class="global" data-name="sSTWReadMemStatsSlow">
               <h3>
                  sSTWReadMemStatsSlow 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWReadMemStatsSlow</code></pre>
            </article>
            
            <article class="global" data-name="sSTWReadMetricsSlow">
               <h3>
                  sSTWReadMetricsSlow 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWReadMetricsSlow</code></pre>
            </article>
            
            <article class="global" data-name="sSTWResetDebugLog">
               <h3>
                  sSTWResetDebugLog 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWResetDebugLog</code></pre>
            </article>
            
            <article class="global" data-name="sSTWStartTrace">
               <h3>
                  sSTWStartTrace 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWStartTrace</code></pre>
            </article>
            
            <article class="global" data-name="sSTWStopTrace">
               <h3>
                  sSTWStopTrace 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWStopTrace</code></pre>
            </article>
            
            <article class="global" data-name="sSTWUnknown">
               <h3>
                  sSTWUnknown 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>STW kinds</p>
               
               <pre><code>const sSTWUnknown</code></pre>
            </article>
            
            <article class="global" data-name="sSTWWriteHeapDump">
               <h3>
                  sSTWWriteHeapDump 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSTWWriteHeapDump</code></pre>
            </article>
            
            <article class="global" data-name="sSelect">
               <h3>
                  sSelect 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSelect</code></pre>
            </article>
            
            <article class="global" data-name="sSleep">
               <h3>
                  sSleep 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSleep</code></pre>
            </article>
            
            <article class="global" data-name="sSync">
               <h3>
                  sSync 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSync</code></pre>
            </article>
            
            <article class="global" data-name="sSyncCond">
               <h3>
                  sSyncCond 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const sSyncCond</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="EventKind">
               <h3>
                  EventKind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>EventKind indicates the kind of event this is.
Use this information to obtain a more specific event that
allows access to more detailed information.</p>
               
               <pre><code>type EventKind uint16</code></pre>
            </article>
            
            <article class="type" data-name="GoID">
               <h3>
                  GoID
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>GoID is the runtime-internal G structure's goid field. This is unique
for each goroutine.</p>
               
               <pre><code>type GoID int64</code></pre>
            </article>
            
            <article class="type" data-name="GoState">
               <h3>
                  GoState
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>GoState represents the state of a goroutine.
New GoStates may be added in the future. Users of this type must be robust
to that possibility.</p>
               
               <pre><code>type GoState uint8</code></pre>
            </article>
            
            <article class="type" data-name="ProcID">
               <h3>
                  ProcID
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>ProcID is the runtime-internal G structure's id field. This is unique
for each P.</p>
               
               <pre><code>type ProcID int64</code></pre>
            </article>
            
            <article class="type" data-name="ProcState">
               <h3>
                  ProcState
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>ProcState represents the state of a proc.
New ProcStates may be added in the future. Users of this type must be robust
to that possibility.</p>
               
               <pre><code>type ProcState uint8</code></pre>
            </article>
            
            <article class="type" data-name="ResourceKind">
               <h3>
                  ResourceKind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>ResourceKind indicates a kind of resource that has a state machine.
New ResourceKinds may be added in the future. Users of this type must be robust
to that possibility.</p>
               
               <pre><code>type ResourceKind uint8</code></pre>
            </article>
            
            <article class="type" data-name="TaskID">
               <h3>
                  TaskID
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>TaskID is the internal ID of a task used to disambiguate tasks (even if they
are of the same type).</p>
               
               <pre><code>type TaskID uint64</code></pre>
            </article>
            
            <article class="type" data-name="ThreadID">
               <h3>
                  ThreadID
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>ThreadID is the runtime-internal M structure's ID. This is unique
for each OS thread.</p>
               
               <pre><code>type ThreadID int64</code></pre>
            </article>
            
            <article class="type" data-name="Time">
               <h3>
                  Time
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Time is a timestamp in nanoseconds.
It corresponds to the monotonic clock on the platform that the
trace was taken, and so is possible to correlate with timestamps
for other traces taken on the same machine using the same clock
(i.e. no reboots in between).
The actual absolute value of the timestamp is only meaningful in
relation to other timestamps from the same clock.
BUG: Timestamps coming from traces on Windows platforms are
only comparable with timestamps from the same trace. Timestamps
across traces cannot be compared, because the system clock is
not used as of Go 1.22.
BUG: Traces produced by Go versions 1.21 and earlier cannot be
compared with timestamps from other traces taken on the same
machine. This is because the system clock was not used at all
to collect those timestamps.</p>
               
               <pre><code>type Time int64</code></pre>
            </article>
            
            <article class="type" data-name="UtilFlags">
               <h3>
                  UtilFlags
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>UtilFlags controls the behavior of MutatorUtilization.</p>
               
               <pre><code>type UtilFlags int</code></pre>
            </article>
            
            <article class="type" data-name="ValueKind">
               <h3>
                  ValueKind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>ValueKind is the type of a dynamically-typed value from a trace.</p>
               
               <pre><code>type ValueKind uint8</code></pre>
            </article>
            
            <article class="type" data-name="bandUtilHeap">
               <h3>
                  bandUtilHeap
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type bandUtilHeap []bandUtil</code></pre>
            </article>
            
            <article class="type" data-name="extraStringID">
               <h3>
                  extraStringID
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>extraStringID is an index into the extra string table for a generation.</p>
               
               <pre><code>type extraStringID uint64</code></pre>
            </article>
            
            <article class="type" data-name="frequency">
               <h3>
                  frequency
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>frequency is nanoseconds per timestamp unit.</p>
               
               <pre><code>type frequency float64</code></pre>
            </article>
            
            <article class="type" data-name="gcState">
               <h3>
                  gcState
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>gcState is a trinary variable for the current state of the GC.
The third state besides "enabled" and "disabled" is "undetermined."</p>
               
               <pre><code>type gcState uint8</code></pre>
            </article>
            
            <article class="type" data-name="orderingHandleFunc">
               <h3>
                  orderingHandleFunc
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type orderingHandleFunc func(o *ordering, ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="type" data-name="stackID">
               <h3>
                  stackID
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>stackID is an index into the stack table for a generation.</p>
               
               <pre><code>type stackID uint64</code></pre>
            </article>
            
            <article class="type" data-name="stringID">
               <h3>
                  stringID
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>stringID is an index into the string table for a generation.</p>
               
               <pre><code>type stringID uint64</code></pre>
            </article>
            
            <article class="type" data-name="timedEventArgs">
               <h3>
                  timedEventArgs
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>timedEventArgs is an array that is able to hold the arguments for any
timed event.</p>
               
               <pre><code>type timedEventArgs [*ast.BinaryExpr]uint64</code></pre>
            </article>
            
            <article class="type" data-name="timestamp">
               <h3>
                  timestamp
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>timestamp is an unprocessed timestamp.</p>
               
               <pre><code>type timestamp uint64</code></pre>
            </article>
            
            <article class="type" data-name="totalUtil">
               <h3>
                  totalUtil
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>totalUtil is total utilization, measured in nanoseconds. This is a
separate type primarily to distinguish it from mean utilization,
which is also a float64.</p>
               
               <pre><code>type totalUtil float64</code></pre>
            </article>
            
            <article class="type" data-name="utilHeap">
               <h3>
                  utilHeap
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type utilHeap []UtilWindow</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Event">
               <h3>
                  Event
                  <span class="badge">struct</span>
               </h3>
               
               <p>Event represents a single event in the trace.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Event struct {
table *evTable
ctx schedCtx
base baseEvent
}</code></pre>
            </article>
            
            <article class="struct" data-name="ExperimentalBatch">
               <h3>
                  ExperimentalBatch
                  <span class="badge">struct</span>
               </h3>
               
               <p>ExperimentalBatch represents a packet of unparsed data along with metadata about that packet.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ExperimentalBatch struct {
Thread ThreadID
Data []byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="ExperimentalData">
               <h3>
                  ExperimentalData
                  <span class="badge">struct</span>
               </h3>
               
               <p>ExperimentalData represents some raw and unparsed sidecar data present in the trace that is
associated with certain kinds of experimental events. For example, this data may contain
tables needed to interpret ExperimentalEvent arguments, or the ExperimentEvent could just be
a placeholder for a differently encoded event that's actually present in the experimental data.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ExperimentalData struct {
Batches []ExperimentalBatch
}</code></pre>
            </article>
            
            <article class="struct" data-name="ExperimentalEvent">
               <h3>
                  ExperimentalEvent
                  <span class="badge">struct</span>
               </h3>
               
               <p>ExperimentalEvent presents a raw view of an experimental event's arguments and their names.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ExperimentalEvent struct {
Name string
ArgNames []string
Args []uint64
Data *ExperimentalData
}</code></pre>
            </article>
            
            <article class="struct" data-name="Frame">
               <h3>
                  Frame
                  <span class="badge">struct</span>
               </h3>
               
               <p>Frame is a frame in stack traces.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Frame struct {
PC uint64
Fn string
File string
Line int
}</code></pre>
            </article>
            
            <article class="struct" data-name="GoroutineExecStats">
               <h3>
                  GoroutineExecStats
                  <span class="badge">struct</span>
               </h3>
               
               <p>GoroutineExecStats contains statistics about a goroutine's execution
during a period of time.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type GoroutineExecStats struct {
ExecTime time.Duration
SchedWaitTime time.Duration
BlockTimeByReason map[string]time.Duration
SyscallTime time.Duration
SyscallBlockTime time.Duration
TotalTime time.Duration
RangeTime map[string]time.Duration
}</code></pre>
            </article>
            
            <article class="struct" data-name="GoroutineSummary">
               <h3>
                  GoroutineSummary
                  <span class="badge">struct</span>
               </h3>
               
               <p>GoroutineSummary contains statistics and execution details of a single goroutine.
(For v2 traces.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type GoroutineSummary struct {
ID GoID
Name string
PC uint64
CreationTime Time
StartTime Time
EndTime Time
Regions []*UserRegionSummary
GoroutineExecStats
*goroutineSummary
}</code></pre>
            </article>
            
            <article class="struct" data-name="Label">
               <h3>
                  Label
                  <span class="badge">struct</span>
               </h3>
               
               <p>Label provides details about a Label event.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Label struct {
Label string
Resource ResourceID
}</code></pre>
            </article>
            
            <article class="struct" data-name="Log">
               <h3>
                  Log
                  <span class="badge">struct</span>
               </h3>
               
               <p>Log provides details about a Log event.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Log struct {
Task TaskID
Category string
Message string
}</code></pre>
            </article>
            
            <article class="struct" data-name="MMUCurve">
               <h3>
                  MMUCurve
                  <span class="badge">struct</span>
               </h3>
               
               <p>An MMUCurve is the minimum mutator utilization curve across
multiple window sizes.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MMUCurve struct {
series []mmuSeries
}</code></pre>
            </article>
            
            <article class="struct" data-name="Metric">
               <h3>
                  Metric
                  <span class="badge">struct</span>
               </h3>
               
               <p>Metric provides details about a Metric event.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Metric struct {
Name string
Value Value
}</code></pre>
            </article>
            
            <article class="struct" data-name="MutatorUtil">
               <h3>
                  MutatorUtil
                  <span class="badge">struct</span>
               </h3>
               
               <p>MutatorUtil is a change in mutator utilization at a particular
time. Mutator utilization functions are represented as a
time-ordered []MutatorUtil.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MutatorUtil struct {
Time int64
Util float64
}</code></pre>
            </article>
            
            <article class="struct" data-name="Range">
               <h3>
                  Range
                  <span class="badge">struct</span>
               </h3>
               
               <p>Range provides details about a Range event.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Range struct {
Name string
Scope ResourceID
}</code></pre>
            </article>
            
            <article class="struct" data-name="RangeAttribute">
               <h3>
                  RangeAttribute
                  <span class="badge">struct</span>
               </h3>
               
               <p>RangeAttributes provides attributes about a completed Range.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type RangeAttribute struct {
Name string
Value Value
}</code></pre>
            </article>
            
            <article class="struct" data-name="Reader">
               <h3>
                  Reader
                  <span class="badge">struct</span>
               </h3>
               
               <p>Reader reads a byte stream, validates it, and produces trace events.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Reader struct {
r *bufio.Reader
lastTs Time
gen *generation
spill *spilledBatch
spillErr error
frontier []*batchCursor
cpuSamples []cpuSample
order ordering
emittedSync bool
go121Events *oldTraceConverter
}</code></pre>
            </article>
            
            <article class="struct" data-name="Region">
               <h3>
                  Region
                  <span class="badge">struct</span>
               </h3>
               
               <p>Region provides details about a Region event.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Region struct {
Task TaskID
Type string
}</code></pre>
            </article>
            
            <article class="struct" data-name="ResourceID">
               <h3>
                  ResourceID
                  <span class="badge">struct</span>
               </h3>
               
               <p>ResourceID represents a generic resource ID.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ResourceID struct {
Kind ResourceKind
id int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="Stack">
               <h3>
                  Stack
                  <span class="badge">struct</span>
               </h3>
               
               <p>Stack represents a stack. It's really a handle to a stack and it's trivially comparable.
If two Stacks are equal then their Frames are guaranteed to be identical. If they are not
equal, however, their Frames may still be equal.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Stack struct {
table *evTable
id stackID
}</code></pre>
            </article>
            
            <article class="struct" data-name="StackFrame">
               <h3>
                  StackFrame
                  <span class="badge">struct</span>
               </h3>
               
               <p>StackFrame represents a single frame of a stack.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StackFrame struct {
PC uint64
Func string
File string
Line uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="StateTransition">
               <h3>
                  StateTransition
                  <span class="badge">struct</span>
               </h3>
               
               <p>StateTransition provides details about a StateTransition event.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StateTransition struct {
Resource ResourceID
Reason string
Stack Stack
id int64
oldState uint8
newState uint8
}</code></pre>
            </article>
            
            <article class="struct" data-name="Summarizer">
               <h3>
                  Summarizer
                  <span class="badge">struct</span>
               </h3>
               
               <p>Summarizer constructs per-goroutine time statistics for v2 traces.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Summarizer struct {
gs map[GoID]*GoroutineSummary
tasks map[TaskID]*UserTaskSummary
syscallingP map[ProcID]GoID
syscallingG map[GoID]ProcID
rangesP map[rangeP]GoID
lastTs Time
syncTs Time
}</code></pre>
            </article>
            
            <article class="struct" data-name="Summary">
               <h3>
                  Summary
                  <span class="badge">struct</span>
               </h3>
               
               <p>Summary is the analysis result produced by the summarizer.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Summary struct {
Goroutines map[GoID]*GoroutineSummary
Tasks map[TaskID]*UserTaskSummary
}</code></pre>
            </article>
            
            <article class="struct" data-name="Task">
               <h3>
                  Task
                  <span class="badge">struct</span>
               </h3>
               
               <p>Task provides details about a Task event.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Task struct {
ID TaskID
Parent TaskID
Type string
}</code></pre>
            </article>
            
            <article class="struct" data-name="UserRegionSummary">
               <h3>
                  UserRegionSummary
                  <span class="badge">struct</span>
               </h3>
               
               <p>UserRegionSummary represents a region and goroutine execution stats
while the region was active. (For v2 traces.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UserRegionSummary struct {
TaskID TaskID
Name string
Start *Event
End *Event
GoroutineExecStats
}</code></pre>
            </article>
            
            <article class="struct" data-name="UserTaskSummary">
               <h3>
                  UserTaskSummary
                  <span class="badge">struct</span>
               </h3>
               
               <p>UserTaskSummary represents a task in the trace.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UserTaskSummary struct {
ID TaskID
Name string
Parent *UserTaskSummary
Children []*UserTaskSummary
Start *Event
End *Event
Logs []*Event
Regions []*UserRegionSummary
Goroutines map[GoID]*GoroutineSummary
}</code></pre>
            </article>
            
            <article class="struct" data-name="UtilWindow">
               <h3>
                  UtilWindow
                  <span class="badge">struct</span>
               </h3>
               
               <p>UtilWindow is a specific window at Time.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UtilWindow struct {
Time int64
MutatorUtil float64
}</code></pre>
            </article>
            
            <article class="struct" data-name="Value">
               <h3>
                  Value
                  <span class="badge">struct</span>
               </h3>
               
               <p>Value is a dynamically-typed value obtained from a trace.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Value struct {
kind ValueKind
scalar uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="accumulator">
               <h3>
                  accumulator
                  <span class="badge">struct</span>
               </h3>
               
               <p>An accumulator takes a windowed mutator utilization function and
tracks various statistics for that function.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type accumulator struct {
mmu float64
bound float64
nWorst int
wHeap utilHeap
mud *mud
preciseMass float64
lastTime int64
lastMU float64
}</code></pre>
            </article>
            
            <article class="struct" data-name="bandUtil">
               <h3>
                  bandUtil
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type bandUtil struct {
series int
i int
utilBound float64
}</code></pre>
            </article>
            
            <article class="struct" data-name="baseEvent">
               <h3>
                  baseEvent
                  <span class="badge">struct</span>
               </h3>
               
               <p>baseEvent is the basic unprocessed event. This serves as a common
fundamental data structure across.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type baseEvent struct {
typ event.Type
time Time
args timedEventArgs
}</code></pre>
            </article>
            
            <article class="struct" data-name="batch">
               <h3>
                  batch
                  <span class="badge">struct</span>
               </h3>
               
               <p>batch represents a batch of trace events.
It is unparsed except for its header.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type batch struct {
m ThreadID
time timestamp
data []byte
exp event.Experiment
}</code></pre>
            </article>
            
            <article class="struct" data-name="batchCursor">
               <h3>
                  batchCursor
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type batchCursor struct {
m ThreadID
lastTs Time
idx int
dataOff int
ev baseEvent
}</code></pre>
            </article>
            
            <article class="struct" data-name="cpuSample">
               <h3>
                  cpuSample
                  <span class="badge">struct</span>
               </h3>
               
               <p>cpuSample represents a CPU profiling sample captured by the trace.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type cpuSample struct {
schedCtx
time Time
stack stackID
}</code></pre>
            </article>
            
            <article class="struct" data-name="dataTable">
               <h3>
                  dataTable
                  <span class="badge">struct</span>
               </h3>
               
               <p>dataTable is a mapping from EIs to Es.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dataTable struct {
present []uint8
dense []E
sparse map[EI]E
}</code></pre>
            </article>
            
            <article class="struct" data-name="edge">
               <h3>
                  edge
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type edge struct {
x float64
delta float64
dirac float64
}</code></pre>
            </article>
            
            <article class="struct" data-name="evTable">
               <h3>
                  evTable
                  <span class="badge">struct</span>
               </h3>
               
               <p>evTable contains the per-generation data necessary to
interpret an individual event.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type evTable struct {
freq frequency
strings *ast.IndexListExpr
stacks *ast.IndexListExpr
pcs map[uint64]frame
extraStrings []string
extraStringIDs map[string]extraStringID
nextExtra extraStringID
expData map[event.Experiment]*ExperimentalData
}</code></pre>
            </article>
            
            <article class="struct" data-name="frame">
               <h3>
                  frame
                  <span class="badge">struct</span>
               </h3>
               
               <p>frame represents a single stack frame.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type frame struct {
pc uint64
funcID stringID
fileID stringID
line uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="gState">
               <h3>
                  gState
                  <span class="badge">struct</span>
               </h3>
               
               <p>gState is the state of a goroutine at a point in the trace.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gState struct {
id GoID
status go122.GoStatus
seq seqCounter
regions []userRegion
rangeState
}</code></pre>
            </article>
            
            <article class="struct" data-name="generation">
               <h3>
                  generation
                  <span class="badge">struct</span>
               </h3>
               
               <p>generation contains all the trace data for a single
trace generation. It is purely data: it does not
track any parse state nor does it contain a cursor
into the generation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type generation struct {
gen uint64
batches map[ThreadID][]batch
batchMs []ThreadID
cpuSamples []cpuSample
*evTable
}</code></pre>
            </article>
            
            <article class="struct" data-name="goroutineSummary">
               <h3>
                  goroutineSummary
                  <span class="badge">struct</span>
               </h3>
               
               <p>goroutineSummary is a private part of GoroutineSummary that is required only during analysis.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type goroutineSummary struct {
lastStartTime Time
lastRunnableTime Time
lastBlockTime Time
lastBlockReason string
lastSyscallTime Time
lastSyscallBlockTime Time
lastRangeTime map[string]Time
activeRegions []*UserRegionSummary
}</code></pre>
            </article>
            
            <article class="struct" data-name="integrator">
               <h3>
                  integrator
                  <span class="badge">struct</span>
               </h3>
               
               <p>An integrator tracks a position in a utilization function and
integrates it.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type integrator struct {
u *mmuSeries
pos int
}</code></pre>
            </article>
            
            <article class="struct" data-name="mState">
               <h3>
                  mState
                  <span class="badge">struct</span>
               </h3>
               
               <p>mState is the state of a thread at a point in the trace.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mState struct {
g GoID
p ProcID
}</code></pre>
            </article>
            
            <article class="struct" data-name="mmuBand">
               <h3>
                  mmuBand
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mmuBand struct {
minUtil float64
cumUtil totalUtil
integrator integrator
}</code></pre>
            </article>
            
            <article class="struct" data-name="mmuSeries">
               <h3>
                  mmuSeries
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mmuSeries struct {
util []MutatorUtil
sums []totalUtil
bands []mmuBand
bandDur int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="mud">
               <h3>
                  mud
                  <span class="badge">struct</span>
               </h3>
               
               <p>mud is an updatable mutator utilization distribution.
This is a continuous distribution of duration over mutator
utilization. For example, the integral from mutator utilization a
to b is the total duration during which the mutator utilization was
in the range [a, b].
This distribution is *not* normalized (it is not a probability
distribution). This makes it easier to work with as it's being
updated.
It is represented as the sum of scaled uniform distribution
functions and Dirac delta functions (which are treated as
degenerate uniform distributions).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mud struct {
sorted []edge
unsorted []edge
trackMass float64
trackBucket int
trackSum float64
hist [mudDegree]float64
}</code></pre>
            </article>
            
            <article class="struct" data-name="oldTraceConverter">
               <h3>
                  oldTraceConverter
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type oldTraceConverter struct {
trace oldtrace.Trace
evt *evTable
preInit bool
createdPreInit map[GoID]struct{...}
events oldtrace.Events
extra []Event
extraArr [3]Event
tasks map[TaskID]taskState
seenProcs map[ProcID]struct{...}
lastTs Time
procMs map[ProcID]ThreadID
lastStwReason uint64
inlineToStringID []uint64
builtinToStringID []uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="ordering">
               <h3>
                  ordering
                  <span class="badge">struct</span>
               </h3>
               
               <p>ordering emulates Go scheduler state for both validation and
for putting events in the right order.
The interface to ordering consists of two methods: Advance
and Next. Advance is called to try and advance an event and
add completed events to the ordering. Next is used to pick
off events in the ordering.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ordering struct {
gStates map[GoID]*gState
pStates map[ProcID]*pState
mStates map[ThreadID]*mState
activeTasks map[TaskID]taskState
gcSeq uint64
gcState gcState
initialGen uint64
queue *ast.IndexExpr
}</code></pre>
            </article>
            
            <article class="struct" data-name="pState">
               <h3>
                  pState
                  <span class="badge">struct</span>
               </h3>
               
               <p>pState is the state of a proc at a point in the trace.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pState struct {
id ProcID
status go122.ProcStatus
seq seqCounter
rangeState
}</code></pre>
            </article>
            
            <article class="struct" data-name="queue">
               <h3>
                  queue
                  <span class="badge">struct</span>
               </h3>
               
               <p>queue implements a growable ring buffer with a queue API.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type queue struct {
start int
end int
buf []T
}</code></pre>
            </article>
            
            <article class="struct" data-name="rangeP">
               <h3>
                  rangeP
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type rangeP struct {
id ProcID
name string
}</code></pre>
            </article>
            
            <article class="struct" data-name="rangeState">
               <h3>
                  rangeState
                  <span class="badge">struct</span>
               </h3>
               
               <p>rangeState represents the state of special time ranges.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type rangeState struct {
inFlight []rangeType
}</code></pre>
            </article>
            
            <article class="struct" data-name="rangeType">
               <h3>
                  rangeType
                  <span class="badge">struct</span>
               </h3>
               
               <p>rangeType is a way to classify special ranges of time.
These typically correspond 1:1 with "Begin" events, but
they may have an optional subtype that describes the range
in more detail.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type rangeType struct {
typ event.Type
desc stringID
}</code></pre>
            </article>
            
            <article class="struct" data-name="schedCtx">
               <h3>
                  schedCtx
                  <span class="badge">struct</span>
               </h3>
               
               <p>schedCtx represents the scheduling resources associated with an event.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type schedCtx struct {
G GoID
P ProcID
M ThreadID
}</code></pre>
            </article>
            
            <article class="struct" data-name="seqCounter">
               <h3>
                  seqCounter
                  <span class="badge">struct</span>
               </h3>
               
               <p>seqCounter represents a global sequence counter for a resource.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type seqCounter struct {
gen uint64
seq uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="spilledBatch">
               <h3>
                  spilledBatch
                  <span class="badge">struct</span>
               </h3>
               
               <p>spilledBatch represents a batch that was read out for the next generation,
while reading the previous one. It's passed on when parsing the next
generation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type spilledBatch struct {
gen uint64
*batch
}</code></pre>
            </article>
            
            <article class="struct" data-name="stack">
               <h3>
                  stack
                  <span class="badge">struct</span>
               </h3>
               
               <p>stack represents a goroutine stack sample.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type stack struct {
pcs []uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="taskState">
               <h3>
                  taskState
                  <span class="badge">struct</span>
               </h3>
               
               <p>taskState represents an active task.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type taskState struct {
name string
parentID TaskID
}</code></pre>
            </article>
            
            <article class="struct" data-name="userRegion">
               <h3>
                  userRegion
                  <span class="badge">struct</span>
               </h3>
               
               <p>userRegion represents a unique user region when attached to some gState.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type userRegion struct {
taskID TaskID
name string
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Advance">
               <h3>
                  Advance 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Advance checks if it's valid to proceed with ev which came from thread m.
It assumes the gen value passed to it is monotonically increasing across calls.
If any error is returned, then the trace is broken and trace parsing must cease.
If it's not valid to advance with ev, but no error was encountered, the caller
should attempt to advance with other candidate events from other threads. If the
caller runs out of candidates, the trace is invalid.
If this returns true, Next is guaranteed to return a complete event. However,
multiple events may be added to the ordering, so the caller should (but is not
required to) continue to call Next until it is exhausted.</p>
               
               <pre><code>func (o *ordering) Advance(ev *baseEvent, evt *evTable, m ThreadID, gen uint64) (bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="Complete">
               <h3>
                  Complete 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Complete returns true if we have complete information about the task
from the trace: both a start and an end.</p>
               
               <pre><code>func (s *UserTaskSummary) Complete() bool</code></pre>
            </article>
            
            <article class="function" data-name="Descendents">
               <h3>
                  Descendents 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Descendents returns a slice consisting of itself (always the first task returned),
and the transitive closure of all of its children.</p>
               
               <pre><code>func (s *UserTaskSummary) Descendents() []*UserTaskSummary</code></pre>
            </article>
            
            <article class="function" data-name="Event">
               <h3>
                  Event 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Event feeds a single event into the stats summarizer.</p>
               
               <pre><code>func (s *Summarizer) Event(ev *Event)</code></pre>
            </article>
            
            <article class="function" data-name="Executing">
               <h3>
                  Executing 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Executing returns true if the state indicates that the proc is executing
and bound to its thread.</p>
               
               <pre><code>func (s ProcState) Executing() bool</code></pre>
            </article>
            
            <article class="function" data-name="Executing">
               <h3>
                  Executing 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Executing returns true if the state indicates that the goroutine is executing
and bound to its thread.</p>
               
               <pre><code>func (s GoState) Executing() bool</code></pre>
            </article>
            
            <article class="function" data-name="Experimental">
               <h3>
                  Experimental 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Experimental returns a view of the raw event for an experimental event.
Panics if Kind != EventExperimental.</p>
               
               <pre><code>func (e Event) Experimental() ExperimentalEvent</code></pre>
            </article>
            
            <article class="function" data-name="Finalize">
               <h3>
                  Finalize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Finalize indicates to the summarizer that we're done processing the trace.
It cleans up any remaining state and returns the full summary.</p>
               
               <pre><code>func (s *Summarizer) Finalize() *Summary</code></pre>
            </article>
            
            <article class="function" data-name="Frames">
               <h3>
                  Frames 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Frames is an iterator over the frames in a Stack.</p>
               
               <pre><code>func (s Stack) Frames() *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function" data-name="Goroutine">
               <h3>
                  Goroutine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Goroutine returns the state transition for a goroutine.
Transitions to and from states that are Executing are special in that
they change the future execution context. In other words, future events
on the same thread will feature the same goroutine until it stops running.
Panics if d.Resource.Kind is not ResourceGoroutine.</p>
               
               <pre><code>func (d StateTransition) Goroutine() (from GoState, to GoState)</code></pre>
            </article>
            
            <article class="function" data-name="Goroutine">
               <h3>
                  Goroutine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Goroutine obtains a GoID from the resource ID.
r.Kind must be ResourceGoroutine or this function will panic.</p>
               
               <pre><code>func (r ResourceID) Goroutine() GoID</code></pre>
            </article>
            
            <article class="function" data-name="Goroutine">
               <h3>
                  Goroutine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Goroutine returns the ID of the goroutine that was executing when
this event happened. It describes part of the execution context
for this event.
Note that for goroutine state transitions this always refers to the
state before the transition. For example, if a goroutine is just
starting to run on this thread and/or proc, then this will return
NoGoroutine. In this case, the goroutine starting to run will be
can be found at Event.StateTransition().Resource.</p>
               
               <pre><code>func (e Event) Goroutine() GoID</code></pre>
            </article>
            
            <article class="function" data-name="IsSystemGoroutine">
               <h3>
                  IsSystemGoroutine 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func IsSystemGoroutine(entryFn string) bool</code></pre>
            </article>
            
            <article class="function" data-name="Kind">
               <h3>
                  Kind 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Kind returns the kind of event that this is.</p>
               
               <pre><code>func (e Event) Kind() EventKind</code></pre>
            </article>
            
            <article class="function" data-name="Kind">
               <h3>
                  Kind 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Kind returns the ValueKind of the value.
It represents the underlying structure of the value.
New ValueKinds may be added in the future. Users of this type must be robust
to that possibility.</p>
               
               <pre><code>func (v Value) Kind() ValueKind</code></pre>
            </article>
            
            <article class="function" data-name="Label">
               <h3>
                  Label 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Label returns details about a Label event.
Panics if Kind != EventLabel.</p>
               
               <pre><code>func (e Event) Label() Label</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h bandUtilHeap) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h utilHeap) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h utilHeap) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h bandUtilHeap) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="Log">
               <h3>
                  Log 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Log returns details about a Log event.
Panics if Kind != EventLog.</p>
               
               <pre><code>func (e Event) Log() Log</code></pre>
            </article>
            
            <article class="function" data-name="MMU">
               <h3>
                  MMU 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MMU returns the minimum mutator utilization for the given time
window. This is the minimum utilization for all windows of this
duration across the execution. The returned value is in the range
[0, 1].</p>
               
               <pre><code>func (c *MMUCurve) MMU(window time.Duration) (mmu float64)</code></pre>
            </article>
            
            <article class="function" data-name="MUD">
               <h3>
                  MUD 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MUD returns mutator utilization distribution quantiles for the
given window size.
The mutator utilization distribution is the distribution of mean
mutator utilization across all windows of the given window size in
the trace.
The minimum mutator utilization is the minimum (0th percentile) of
this distribution. (However, if only the minimum is desired, it's
more efficient to use the MMU method.)</p>
               
               <pre><code>func (c *MMUCurve) MUD(window time.Duration, quantiles []float64) []float64</code></pre>
            </article>
            
            <article class="function" data-name="MakeResourceID">
               <h3>
                  MakeResourceID 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MakeResourceID creates a general resource ID from a specific resource's ID.</p>
               
               <pre><code>func MakeResourceID(id T) ResourceID</code></pre>
            </article>
            
            <article class="function" data-name="Metric">
               <h3>
                  Metric 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Metric returns details about a Metric event.
Panics if Kind != EventMetric.</p>
               
               <pre><code>func (e Event) Metric() Metric</code></pre>
            </article>
            
            <article class="function" data-name="MutatorUtilizationV2">
               <h3>
                  MutatorUtilizationV2 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MutatorUtilizationV2 returns a set of mutator utilization functions
for the given v2 trace, passed as an io.Reader. Each function will
always end with 0 utilization. The bounds of each function are implicit
in the first and last event; outside of these bounds each function is
undefined.
If the UtilPerProc flag is not given, this always returns a single
utilization function. Otherwise, it returns one function per P.</p>
               
               <pre><code>func MutatorUtilizationV2(events []Event, flags UtilFlags) [][]MutatorUtil</code></pre>
            </article>
            
            <article class="function" data-name="NewMMUCurve">
               <h3>
                  NewMMUCurve 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewMMUCurve returns an MMU curve for the given mutator utilization
function.</p>
               
               <pre><code>func NewMMUCurve(utils [][]MutatorUtil) *MMUCurve</code></pre>
            </article>
            
            <article class="function" data-name="NewReader">
               <h3>
                  NewReader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewReader creates a new trace reader.</p>
               
               <pre><code>func NewReader(r io.Reader) (*Reader, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewSummarizer">
               <h3>
                  NewSummarizer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewSummarizer creates a new struct to build goroutine stats from a trace.</p>
               
               <pre><code>func NewSummarizer() *Summarizer</code></pre>
            </article>
            
            <article class="function" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Next returns the next event in the ordering.</p>
               
               <pre><code>func (o *ordering) Next() (Event, bool)</code></pre>
            </article>
            
            <article class="function" data-name="NonOverlappingStats">
               <h3>
                  NonOverlappingStats 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s GoroutineExecStats) NonOverlappingStats() map[string]time.Duration</code></pre>
            </article>
            
            <article class="function" data-name="Pop">
               <h3>
                  Pop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *bandUtilHeap) Pop() any</code></pre>
            </article>
            
            <article class="function" data-name="Pop">
               <h3>
                  Pop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *utilHeap) Pop() any</code></pre>
            </article>
            
            <article class="function" data-name="Proc">
               <h3>
                  Proc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Proc returns the state transition for a proc.
Transitions to and from states that are Executing are special in that
they change the future execution context. In other words, future events
on the same thread will feature the same goroutine until it stops running.
Panics if d.Resource.Kind is not ResourceProc.</p>
               
               <pre><code>func (d StateTransition) Proc() (from ProcState, to ProcState)</code></pre>
            </article>
            
            <article class="function" data-name="Proc">
               <h3>
                  Proc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Proc returns the ID of the proc this event event pertains to.
Note that for proc state transitions this always refers to the
state before the transition. For example, if a proc is just
starting to run on this thread, then this will return NoProc.</p>
               
               <pre><code>func (e Event) Proc() ProcID</code></pre>
            </article>
            
            <article class="function" data-name="Proc">
               <h3>
                  Proc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Proc obtains a ProcID from the resource ID.
r.Kind must be ResourceProc or this function will panic.</p>
               
               <pre><code>func (r ResourceID) Proc() ProcID</code></pre>
            </article>
            
            <article class="function" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *bandUtilHeap) Push(x any)</code></pre>
            </article>
            
            <article class="function" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *utilHeap) Push(x any)</code></pre>
            </article>
            
            <article class="function" data-name="Range">
               <h3>
                  Range 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Range returns details about an EventRangeBegin, EventRangeActive, or EventRangeEnd event.
Panics if Kind != EventRangeBegin, Kind != EventRangeActive, and Kind != EventRangeEnd.</p>
               
               <pre><code>func (e Event) Range() Range</code></pre>
            </article>
            
            <article class="function" data-name="RangeAttributes">
               <h3>
                  RangeAttributes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RangeAttributes returns attributes for a completed range.
Panics if Kind != EventRangeEnd.</p>
               
               <pre><code>func (e Event) RangeAttributes() []RangeAttribute</code></pre>
            </article>
            
            <article class="function" data-name="ReadEvent">
               <h3>
                  ReadEvent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadEvent reads a single event from the stream.
If the stream has been exhausted, it returns an invalid
event and io.EOF.</p>
               
               <pre><code>func (r *Reader) ReadEvent() (e Event, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Region">
               <h3>
                  Region 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Region returns details about a RegionBegin or RegionEnd event.
Panics if Kind != EventRegionBegin and Kind != EventRegionEnd.</p>
               
               <pre><code>func (e Event) Region() Region</code></pre>
            </article>
            
            <article class="function" data-name="RelatedGoroutinesV2">
               <h3>
                  RelatedGoroutinesV2 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>RelatedGoroutinesV2 finds a set of goroutines related to goroutine goid for v2 traces.
The association is based on whether they have synchronized with each other in the Go
scheduler (one has unblocked another).</p>
               
               <pre><code>func RelatedGoroutinesV2(events []Event, goid GoID) map[GoID]struct{...}</code></pre>
            </article>
            
            <article class="function" data-name="Stack">
               <h3>
                  Stack 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Stack returns a handle to a stack associated with the event.
This represents a stack trace at the current moment in time for
the current execution context.</p>
               
               <pre><code>func (e Event) Stack() Stack</code></pre>
            </article>
            
            <article class="function" data-name="StateTransition">
               <h3>
                  StateTransition 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>StateTransition returns details about a StateTransition event.
Panics if Kind != EventStateTransition.</p>
               
               <pre><code>func (e Event) StateTransition() StateTransition</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a debug string representation of the seqCounter.</p>
               
               <pre><code>func (c seqCounter) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a human-readable string representation of the ResourceID.
This representation is subject to change and is intended primarily for debugging.</p>
               
               <pre><code>func (r ResourceID) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a human-readable representation of a ResourceKind.
The format of the returned string is for debugging purposes and is subject to change.</p>
               
               <pre><code>func (r ResourceKind) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a human-readable string for the GC state.</p>
               
               <pre><code>func (s gcState) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a string form of the EventKind.</p>
               
               <pre><code>func (e EventKind) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s stack) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the event as a human-readable string.
The format of the string is intended for debugging and is subject to change.</p>
               
               <pre><code>func (e Event) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a human-readable representation of a ProcState.
The format of the returned string is for debugging purposes and is subject to change.</p>
               
               <pre><code>func (s ProcState) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a human-readable representation of a GoState.
The format of the returned string is for debugging purposes and is subject to change.</p>
               
               <pre><code>func (s GoState) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Sub">
               <h3>
                  Sub 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Sub subtracts t0 from t, returning the duration in nanoseconds.</p>
               
               <pre><code>func (t Time) Sub(t0 Time) time.Duration</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h utilHeap) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h bandUtilHeap) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="Task">
               <h3>
                  Task 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Task returns details about a TaskBegin or TaskEnd event.
Panics if Kind != EventTaskBegin and Kind != EventTaskEnd.</p>
               
               <pre><code>func (e Event) Task() Task</code></pre>
            </article>
            
            <article class="function" data-name="Thread">
               <h3>
                  Thread 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Thread returns the ID of the thread this event pertains to.
Note that for thread state transitions this always refers to the
state before the transition. For example, if a thread is just
starting to run, then this will return NoThread.
Note: tracking thread state is not currently supported, so this
will always return a valid thread ID. However thread state transitions
may be tracked in the future, and callers must be robust to this
possibility.</p>
               
               <pre><code>func (e Event) Thread() ThreadID</code></pre>
            </article>
            
            <article class="function" data-name="Thread">
               <h3>
                  Thread 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Thread obtains a ThreadID from the resource ID.
r.Kind must be ResourceThread or this function will panic.</p>
               
               <pre><code>func (r ResourceID) Thread() ThreadID</code></pre>
            </article>
            
            <article class="function" data-name="Time">
               <h3>
                  Time 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Time returns the timestamp of the event.</p>
               
               <pre><code>func (e Event) Time() Time</code></pre>
            </article>
            
            <article class="function" data-name="Uint64">
               <h3>
                  Uint64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Uint64 returns the uint64 value for a MetricSampleUint64.
Panics if this metric sample's Kind is not MetricSampleUint64.</p>
               
               <pre><code>func (v Value) Uint64() uint64</code></pre>
            </article>
            
            <article class="function" data-name="UnknownTime">
               <h3>
                  UnknownTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnknownTime returns whatever isn't accounted for in TotalTime.</p>
               
               <pre><code>func (s GoroutineExecStats) UnknownTime() time.Duration</code></pre>
            </article>
            
            <article class="function" data-name="activeRange">
               <h3>
                  activeRange 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>activeRange marks special range in time on the goroutine as active in the
initial generation, or confirms that it is indeed active in later generations.</p>
               
               <pre><code>func (s *rangeState) activeRange(typ rangeType, isInitialGen bool) error</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>add adds a uniform function over [l, r] scaled so the total weight
of the uniform is area. If l==r, this adds a Dirac delta function.</p>
               
               <pre><code>func (d *mud) add(l float64, r float64, area float64)</code></pre>
            </article>
            
            <article class="function" data-name="addCPUSamples">
               <h3>
                  addCPUSamples 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addCPUSamples takes a batch whose first byte is an EvCPUSamples event
(indicating that the batch contains only CPU samples) and adds each
sample contained therein to the provided samples list.</p>
               
               <pre><code>func addCPUSamples(samples []cpuSample, b batch) ([]cpuSample, error)</code></pre>
            </article>
            
            <article class="function" data-name="addExperimentalData">
               <h3>
                  addExperimentalData 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addExperimentalData takes an experimental batch and adds it to the ExperimentalData
for the experiment its a part of.</p>
               
               <pre><code>func addExperimentalData(expData map[event.Experiment]*ExperimentalData, b batch) error</code></pre>
            </article>
            
            <article class="function" data-name="addExtraString">
               <h3>
                  addExtraString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addExtraString adds an extra string to the evTable and returns
a unique ID for the string in the table.</p>
               
               <pre><code>func (t *evTable) addExtraString(s string) extraStringID</code></pre>
            </article>
            
            <article class="function" data-name="addMU">
               <h3>
                  addMU 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addMU adds a point to the windowed mutator utilization function at
(time, mu). This must be called for monotonically increasing values
of time.
It returns true if further calls to addMU would be pointless.</p>
               
               <pre><code>func (acc *accumulator) addMU(time int64, mu float64, window time.Duration) bool</code></pre>
            </article>
            
            <article class="function" data-name="addStacks">
               <h3>
                  addStacks 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addStacks takes a batch whose first byte is an EvStacks event
(indicating that the batch contains only stacks) and adds each
string contained therein to the provided stacks map.</p>
               
               <pre><code>func addStacks(stackTable **ast.IndexListExpr, pcs map[uint64]frame, b batch) error</code></pre>
            </article>
            
            <article class="function" data-name="addStrings">
               <h3>
                  addStrings 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addStrings takes a batch whose first byte is an EvStrings event
(indicating that the batch contains only strings) and adds each
string contained therein to the provided strings map.</p>
               
               <pre><code>func addStrings(stringTable **ast.IndexListExpr, b batch) error</code></pre>
            </article>
            
            <article class="function" data-name="addUtil">
               <h3>
                  addUtil 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addUtil(util []MutatorUtil, mu MutatorUtil) []MutatorUtil</code></pre>
            </article>
            
            <article class="function" data-name="advance">
               <h3>
                  advance 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>advance returns the integral of the utilization function from 0 to
time. advance must be called on monotonically increasing values of
times.</p>
               
               <pre><code>func (in *integrator) advance(time int64) totalUtil</code></pre>
            </article>
            
            <article class="function" data-name="advanceAllocFree">
               <h3>
                  advanceAllocFree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceAllocFree(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceAnnotation">
               <h3>
                  advanceAnnotation 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceAnnotation(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGCActive">
               <h3>
                  advanceGCActive 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Handle the GC mark phase.
We have sequence numbers for both start and end because they
can happen on completely different threads. We want an explicit
partial order edge between start and end here, otherwise we're
relying entirely on timestamps to make sure we don't advance a
GCEnd for a _different_ GC cycle if timestamps are wildly broken.</p>
               
               <pre><code>func (o *ordering) advanceGCActive(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGCBegin">
               <h3>
                  advanceGCBegin 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGCBegin(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGCEnd">
               <h3>
                  advanceGCEnd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGCEnd(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGCSweepActive">
               <h3>
                  advanceGCSweepActive 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGCSweepActive(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGCSweepBegin">
               <h3>
                  advanceGCSweepBegin 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGCSweepBegin(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGCSweepEnd">
               <h3>
                  advanceGCSweepEnd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGCSweepEnd(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGoCreate">
               <h3>
                  advanceGoCreate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGoCreate(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGoCreateSyscall">
               <h3>
                  advanceGoCreateSyscall 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGoCreateSyscall(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGoDestroySyscall">
               <h3>
                  advanceGoDestroySyscall 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGoDestroySyscall(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGoRangeActive">
               <h3>
                  advanceGoRangeActive 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGoRangeActive(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGoRangeBegin">
               <h3>
                  advanceGoRangeBegin 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGoRangeBegin(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGoRangeEnd">
               <h3>
                  advanceGoRangeEnd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGoRangeEnd(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGoStart">
               <h3>
                  advanceGoStart 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGoStart(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGoStatus">
               <h3>
                  advanceGoStatus 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGoStatus(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGoStopExec">
               <h3>
                  advanceGoStopExec 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGoStopExec(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGoSwitch">
               <h3>
                  advanceGoSwitch 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGoSwitch(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGoSyscallBegin">
               <h3>
                  advanceGoSyscallBegin 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGoSyscallBegin(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGoSyscallEnd">
               <h3>
                  advanceGoSyscallEnd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGoSyscallEnd(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGoSyscallEndBlocked">
               <h3>
                  advanceGoSyscallEndBlocked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGoSyscallEndBlocked(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceGoUnblock">
               <h3>
                  advanceGoUnblock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceGoUnblock(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceHeapMetric">
               <h3>
                  advanceHeapMetric 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceHeapMetric(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceProcStart">
               <h3>
                  advanceProcStart 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceProcStart(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceProcStatus">
               <h3>
                  advanceProcStatus 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceProcStatus(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceProcSteal">
               <h3>
                  advanceProcSteal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceProcSteal(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceProcStop">
               <h3>
                  advanceProcStop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceProcStop(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceUserRegionBegin">
               <h3>
                  advanceUserRegionBegin 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceUserRegionBegin(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceUserRegionEnd">
               <h3>
                  advanceUserRegionEnd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceUserRegionEnd(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceUserTaskBegin">
               <h3>
                  advanceUserTaskBegin 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceUserTaskBegin(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="advanceUserTaskEnd">
               <h3>
                  advanceUserTaskEnd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (o *ordering) advanceUserTaskEnd(ev *baseEvent, evt *evTable, m ThreadID, gen uint64, curCtx schedCtx) (schedCtx, bool, error)</code></pre>
            </article>
            
            <article class="function" data-name="approxInvCumulativeSum">
               <h3>
                  approxInvCumulativeSum 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>approxInvCumulativeSum is like invCumulativeSum, but specifically
operates on the tracked mass and returns an upper and lower bound
approximation of the inverse cumulative sum.
The true inverse cumulative sum will be in the range [lower, upper).</p>
               
               <pre><code>func (d *mud) approxInvCumulativeSum() (float64, float64, bool)</code></pre>
            </article>
            
            <article class="function" data-name="asEvent">
               <h3>
                  asEvent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>asEvent produces a complete Event from a cpuSample. It needs
the evTable from the generation that created it.
We don't just store it as an Event in generation to minimize
the amount of pointer data floating around.</p>
               
               <pre><code>func (s cpuSample) asEvent(table *evTable) Event</code></pre>
            </article>
            
            <article class="function" data-name="bandMMU">
               <h3>
                  bandMMU 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>bandMMU computes the precise minimum mutator utilization for
windows with a left edge in band bandIdx.</p>
               
               <pre><code>func (c *mmuSeries) bandMMU(bandIdx int, window time.Duration, acc *accumulator)</code></pre>
            </article>
            
            <article class="function" data-name="bandTime">
               <h3>
                  bandTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *mmuSeries) bandTime(i int) (start int64, end int64)</code></pre>
            </article>
            
            <article class="function" data-name="beginRange">
               <h3>
                  beginRange 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>beginRange begins a special range in time on the goroutine.
Returns an error if the range is already in progress.</p>
               
               <pre><code>func (s *rangeState) beginRange(typ rangeType) error</code></pre>
            </article>
            
            <article class="function" data-name="beginRegion">
               <h3>
                  beginRegion 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>beginRegion starts a user region on the goroutine.</p>
               
               <pre><code>func (s *gState) beginRegion(r userRegion) error</code></pre>
            </article>
            
            <article class="function" data-name="clone">
               <h3>
                  clone 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s GoroutineExecStats) clone() (r GoroutineExecStats)</code></pre>
            </article>
            
            <article class="function" data-name="compactify">
               <h3>
                  compactify 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>compactify attempts to compact sparse into dense.
This is intended to be called only once after insertions are done.</p>
               
               <pre><code>func (d **ast.IndexListExpr) compactify()</code></pre>
            </article>
            
            <article class="function" data-name="compare">
               <h3>
                  compare 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batchCursor) compare(a *batchCursor) int</code></pre>
            </article>
            
            <article class="function" data-name="convertEvent">
               <h3>
                  convertEvent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>convertEvent converts an event from the old trace format to zero or more
events in the new format. Most events translate 1 to 1. Some events don't
result in an event right away, in which case convertEvent returns errSkip.
Some events result in more than one new event; in this case, convertEvent
returns the first event and stores additional events in it.extra. When
encountering events that oldtrace shouldn't be able to emit, ocnvertEvent
returns a descriptive error.</p>
               
               <pre><code>func (it *oldTraceConverter) convertEvent(ev *oldtrace.Event) (OUT Event, ERR error)</code></pre>
            </article>
            
            <article class="function" data-name="convertOldFormat">
               <h3>
                  convertOldFormat 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOldFormat takes a fully loaded trace in the old trace format and
returns an iterator over events in the new format.</p>
               
               <pre><code>func convertOldFormat(pr oldtrace.Trace) *oldTraceConverter</code></pre>
            </article>
            
            <article class="function" data-name="dumpFrontier">
               <h3>
                  dumpFrontier 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dumpFrontier(frontier []*batchCursor) string</code></pre>
            </article>
            
            <article class="function" data-name="dumpOrdering">
               <h3>
                  dumpOrdering 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dumpOrdering(order *ordering) string</code></pre>
            </article>
            
            <article class="function" data-name="endRange">
               <h3>
                  endRange 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>endRange ends a special range in time on the goroutine.
This must line up with the start event type  of the range the goroutine is currently in.</p>
               
               <pre><code>func (s *rangeState) endRange(typ event.Type) (stringID, error)</code></pre>
            </article>
            
            <article class="function" data-name="endRegion">
               <h3>
                  endRegion 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>endRegion ends a user region on the goroutine.</p>
               
               <pre><code>func (s *gState) endRegion(r userRegion) error</code></pre>
            </article>
            
            <article class="function" data-name="extra">
               <h3>
                  extra 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>extra returns a slice representing extra available space in args
that the parser can use to pass data up into Event.</p>
               
               <pre><code>func (e *baseEvent) extra(v version.Version) []uint64</code></pre>
            </article>
            
            <article class="function" data-name="finalize">
               <h3>
                  finalize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>finalize is called when processing a goroutine end event or at
the end of trace processing. This finalizes the execution stat
and any active regions in the goroutine, in which case trigger is nil.</p>
               
               <pre><code>func (g *GoroutineSummary) finalize(lastTs Time, trigger *Event)</code></pre>
            </article>
            
            <article class="function" data-name="forEach">
               <h3>
                  forEach 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>forEach iterates over all ID/value pairs in the data table.</p>
               
               <pre><code>func (d **ast.IndexListExpr) forEach(yield func(EI, E) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="get">
               <h3>
                  get 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>get returns the E for id or false if it doesn't
exist. This should be used for validation during parsing.</p>
               
               <pre><code>func (d **ast.IndexListExpr) get(id EI) (E, bool)</code></pre>
            </article>
            
            <article class="function" data-name="getExtraString">
               <h3>
                  getExtraString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>getExtraString returns the extra string for the provided ID.
The ID must have been produced by addExtraString for this evTable.</p>
               
               <pre><code>func (t *evTable) getExtraString(id extraStringID) string</code></pre>
            </article>
            
            <article class="function" data-name="getOrAddTask">
               <h3>
                  getOrAddTask 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Summarizer) getOrAddTask(id TaskID) *UserTaskSummary</code></pre>
            </article>
            
            <article class="function" data-name="goStateTransition">
               <h3>
                  goStateTransition 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func goStateTransition(id GoID, from GoState, to GoState) StateTransition</code></pre>
            </article>
            
            <article class="function" data-name="grow">
               <h3>
                  grow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>grow increases the size of the queue.</p>
               
               <pre><code>func (q **ast.IndexExpr) grow()</code></pre>
            </article>
            
            <article class="function" data-name="hasRange">
               <h3>
                  hasRange 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>hasRange returns true if a special time range on the goroutine as in progress.</p>
               
               <pre><code>func (s *rangeState) hasRange(typ rangeType) bool</code></pre>
            </article>
            
            <article class="function" data-name="heapInsert">
               <h3>
                  heapInsert 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func heapInsert(heap []*batchCursor, bc *batchCursor) []*batchCursor</code></pre>
            </article>
            
            <article class="function" data-name="heapRemove">
               <h3>
                  heapRemove 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func heapRemove(heap []*batchCursor, i int) []*batchCursor</code></pre>
            </article>
            
            <article class="function" data-name="heapSiftDown">
               <h3>
                  heapSiftDown 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func heapSiftDown(heap []*batchCursor, i int) int</code></pre>
            </article>
            
            <article class="function" data-name="heapSiftUp">
               <h3>
                  heapSiftUp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func heapSiftUp(heap []*batchCursor, i int) int</code></pre>
            </article>
            
            <article class="function" data-name="heapUpdate">
               <h3>
                  heapUpdate 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func heapUpdate(heap []*batchCursor, i int)</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (it *oldTraceConverter) init(pr oldtrace.Trace) error</code></pre>
            </article>
            
            <article class="function" data-name="insert">
               <h3>
                  insert 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>insert tries to add a mapping from id to s.
Returns an error if a mapping for id already exists, regardless
of whether or not s is the same in content. This should be used
for validation during parsing.</p>
               
               <pre><code>func (d **ast.IndexListExpr) insert(id EI, data E) error</code></pre>
            </article>
            
            <article class="function" data-name="invCumulativeSum">
               <h3>
                  invCumulativeSum 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>invCumulativeSum returns x such that the integral of d from -∞ to x
is y. If the total weight of d is less than y, it returns the
maximum of the distribution and false.
Specifically, y is a cumulative duration, and invCumulativeSum
returns the mutator utilization x such that at least y time has
been spent with mutator utilization <= x.</p>
               
               <pre><code>func (d *mud) invCumulativeSum(y float64) (float64, bool)</code></pre>
            </article>
            
            <article class="function" data-name="isCPUSamplesBatch">
               <h3>
                  isCPUSamplesBatch 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) isCPUSamplesBatch() bool</code></pre>
            </article>
            
            <article class="function" data-name="isFreqBatch">
               <h3>
                  isFreqBatch 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) isFreqBatch() bool</code></pre>
            </article>
            
            <article class="function" data-name="isGCMarkAssist">
               <h3>
                  isGCMarkAssist 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isGCMarkAssist(r Range) bool</code></pre>
            </article>
            
            <article class="function" data-name="isGCSTW">
               <h3>
                  isGCSTW 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isGCSTW(r Range) bool</code></pre>
            </article>
            
            <article class="function" data-name="isGCSweep">
               <h3>
                  isGCSweep 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isGCSweep(r Range) bool</code></pre>
            </article>
            
            <article class="function" data-name="isStacksBatch">
               <h3>
                  isStacksBatch 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) isStacksBatch() bool</code></pre>
            </article>
            
            <article class="function" data-name="isStringsBatch">
               <h3>
                  isStringsBatch 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batch) isStringsBatch() bool</code></pre>
            </article>
            
            <article class="function" data-name="makeEvent">
               <h3>
                  makeEvent 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeEvent creates an Event from the provided information.
It's just a convenience function; it's always OK to construct
an Event manually if this isn't quite the right way to express
the contents of the event.</p>
               
               <pre><code>func makeEvent(table *evTable, ctx schedCtx, typ event.Type, time Time, args ...uint64) Event</code></pre>
            </article>
            
            <article class="function" data-name="makeRangeType">
               <h3>
                  makeRangeType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeRangeType constructs a new rangeType.</p>
               
               <pre><code>func makeRangeType(typ event.Type, desc stringID) rangeType</code></pre>
            </article>
            
            <article class="function" data-name="makeSeq">
               <h3>
                  makeSeq 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeSeq creates a new seqCounter.</p>
               
               <pre><code>func makeSeq(gen uint64, seq uint64) seqCounter</code></pre>
            </article>
            
            <article class="function" data-name="mean">
               <h3>
                  mean 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mean returns the mean utilization over dur.</p>
               
               <pre><code>func (u totalUtil) mean(dur time.Duration) float64</code></pre>
            </article>
            
            <article class="function" data-name="min3">
               <h3>
                  min3 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func min3(b []*batchCursor, i0 int, i1 int, i2 int) int</code></pre>
            </article>
            
            <article class="function" data-name="mkBandUtil">
               <h3>
                  mkBandUtil 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *mmuSeries) mkBandUtil(series int, window time.Duration) []bandUtil</code></pre>
            </article>
            
            <article class="function" data-name="mmu">
               <h3>
                  mmu 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *MMUCurve) mmu(window time.Duration, acc *accumulator)</code></pre>
            </article>
            
            <article class="function" data-name="mul">
               <h3>
                  mul 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mul multiplies an unprocessed to produce a time in nanoseconds.</p>
               
               <pre><code>func (f frequency) mul(t timestamp) Time</code></pre>
            </article>
            
            <article class="function" data-name="mustGet">
               <h3>
                  mustGet 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mustGet returns the E for id or panics if it fails.
This should only be used if id has already been validated.</p>
               
               <pre><code>func (d **ast.IndexListExpr) mustGet(id EI) E</code></pre>
            </article>
            
            <article class="function" data-name="newMMUSeries">
               <h3>
                  newMMUSeries 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newMMUSeries(util []MutatorUtil) mmuSeries</code></pre>
            </article>
            
            <article class="function" data-name="next">
               <h3>
                  next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>next returns the smallest time t' > time of a change in the
utilization function.</p>
               
               <pre><code>func (in *integrator) next(time int64) int64</code></pre>
            </article>
            
            <article class="function" data-name="next">
               <h3>
                  next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>next returns the next event, io.EOF if there are no more events, or a
descriptive error for invalid events.</p>
               
               <pre><code>func (it *oldTraceConverter) next() (Event, error)</code></pre>
            </article>
            
            <article class="function" data-name="nextEvent">
               <h3>
                  nextEvent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *batchCursor) nextEvent(batches []batch, freq frequency) (ok bool, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseFreq">
               <h3>
                  parseFreq 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseFreq parses out a lone EvFrequency from a batch.</p>
               
               <pre><code>func parseFreq(b batch) (frequency, error)</code></pre>
            </article>
            
            <article class="function" data-name="pop">
               <h3>
                  pop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>pop removes an event from the front of the queue. If the
queue is empty, it returns an EventBad event.</p>
               
               <pre><code>func (q **ast.IndexExpr) pop() (T, bool)</code></pre>
            </article>
            
            <article class="function" data-name="procStateTransition">
               <h3>
                  procStateTransition 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func procStateTransition(id ProcID, from ProcState, to ProcState) StateTransition</code></pre>
            </article>
            
            <article class="function" data-name="processBatch">
               <h3>
                  processBatch 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>processBatch adds the batch to the generation.</p>
               
               <pre><code>func processBatch(g *generation, b batch) error</code></pre>
            </article>
            
            <article class="function" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>push adds a new event to the back of the queue.</p>
               
               <pre><code>func (q **ast.IndexExpr) push(value T)</code></pre>
            </article>
            
            <article class="function" data-name="readBatch">
               <h3>
                  readBatch 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readBatch reads the next full batch from r.</p>
               
               <pre><code>func readBatch(r interface{...}) (batch, uint64, error)</code></pre>
            </article>
            
            <article class="function" data-name="readGeneration">
               <h3>
                  readGeneration 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readGeneration buffers and decodes the structural elements of a trace generation
out of r. spill is the first batch of the new generation (already buffered and
parsed from reading the last generation). Returns the generation and the first
batch read of the next generation, if any.
If gen is non-nil, it is valid and must be processed before handling the returned
error.</p>
               
               <pre><code>func readGeneration(r *bufio.Reader, spill *spilledBatch) (*generation, *spilledBatch, error)</code></pre>
            </article>
            
            <article class="function" data-name="readTimedBaseEvent">
               <h3>
                  readTimedBaseEvent 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readTimedBaseEvent reads out the raw event data from b
into e. It does not try to interpret the arguments
but it does validate that the event is a regular
event with a timestamp (vs. a structural event).
It requires that the event its reading be timed, which must
be the case for every event in a plain EventBatch.</p>
               
               <pre><code>func readTimedBaseEvent(b []byte, e *baseEvent) (int, timestamp, error)</code></pre>
            </article>
            
            <article class="function" data-name="resetTime">
               <h3>
                  resetTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>resetTime declares a discontinuity in the windowed mutator
utilization function by resetting the current time.</p>
               
               <pre><code>func (acc *accumulator) resetTime()</code></pre>
            </article>
            
            <article class="function" data-name="setTrackMass">
               <h3>
                  setTrackMass 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setTrackMass sets the mass to track the inverse cumulative sum for.
Specifically, mass is a cumulative duration, and the mutator
utilization bounds for this duration can be queried using
approxInvCumulativeSum.</p>
               
               <pre><code>func (d *mud) setTrackMass(mass float64)</code></pre>
            </article>
            
            <article class="function" data-name="snapshotStat">
               <h3>
                  snapshotStat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>snapshotStat returns the snapshot of the goroutine execution statistics.
This is called as we process the ordered trace event stream. lastTs is used
to process pending statistics if this is called before any goroutine end event.</p>
               
               <pre><code>func (g *GoroutineSummary) snapshotStat(lastTs Time) (ret GoroutineExecStats)</code></pre>
            </article>
            
            <article class="function" data-name="sub">
               <h3>
                  sub 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>sub returns the stats v-s.</p>
               
               <pre><code>func (s GoroutineExecStats) sub(v GoroutineExecStats) (r GoroutineExecStats)</code></pre>
            </article>
            
            <article class="function" data-name="succeeds">
               <h3>
                  succeeds 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>succeeds returns true if a is the immediate successor of b.</p>
               
               <pre><code>func (a seqCounter) succeeds(b seqCounter) bool</code></pre>
            </article>
            
            <article class="function" data-name="syncEvent">
               <h3>
                  syncEvent 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func syncEvent(table *evTable, ts Time) Event</code></pre>
            </article>
            
            <article class="function" data-name="totalUtilOf">
               <h3>
                  totalUtilOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func totalUtilOf(meanUtil float64, dur int64) totalUtil</code></pre>
            </article>
            
            <article class="function" data-name="validateCtx">
               <h3>
                  validateCtx 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>validateCtx ensures that ctx conforms to some reqs, returning an error if
it doesn't.</p>
               
               <pre><code>func validateCtx(ctx schedCtx, reqs event.SchedReqs) error</code></pre>
            </article>
            
            <article class="function" data-name="validateStackStrings">
               <h3>
                  validateStackStrings 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>validateStackStrings makes sure all the string references in
the stack table are present in the string table.</p>
               
               <pre><code>func validateStackStrings(stacks **ast.IndexListExpr, strings **ast.IndexListExpr, frames map[uint64]frame) error</code></pre>
            </article>
            
            <article class="function" data-name="validateTableIDs">
               <h3>
                  validateTableIDs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>validateTableIDs checks to make sure lookups in e.table
will work.</p>
               
               <pre><code>func (e Event) validateTableIDs() error</code></pre>
            </article>
            
            <article class="function" data-name="valueAsString">
               <h3>
                  valueAsString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>valueAsString produces a debug string value.
This isn't just Value.String because we may want to use that to store
string values in the future.</p>
               
               <pre><code>func valueAsString(v Value) string</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
