<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - work</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>work</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bufio"
"bytes"
"cmd/internal/cov/covcmd"
"container/heap"
"context"
"debug/elf"
"encoding/json"
"fmt"
"internal/platform"
"os"
"path/filepath"
"strings"
"sync"
"time"
"cmd/go/internal/base"
"cmd/go/internal/cache"
"cmd/go/internal/cfg"
"cmd/go/internal/load"
"cmd/go/internal/str"
"cmd/go/internal/trace"
"cmd/internal/buildid"
"cmd/internal/robustio"
"context"
"errors"
"flag"
"fmt"
"go/build"
"os"
"path/filepath"
"runtime"
"strconv"
"strings"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/load"
"cmd/go/internal/modload"
"cmd/go/internal/search"
"cmd/go/internal/trace"
"cmd/internal/pathcache"
"bytes"
"fmt"
"os"
"os/exec"
"strings"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/cache"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/str"
"cmd/internal/buildid"
"cmd/internal/pathcache"
"cmd/internal/quoted"
"cmd/internal/telemetry/counter"
"bytes"
"cmd/internal/cov/covcmd"
"cmd/internal/pathcache"
"context"
"crypto/sha256"
"encoding/json"
"errors"
"fmt"
"go/token"
"internal/lazyregexp"
"io"
"io/fs"
"log"
"math/rand"
"os"
"os/exec"
"path/filepath"
"regexp"
"runtime"
"slices"
"sort"
"strconv"
"strings"
"sync"
"time"
"cmd/go/internal/base"
"cmd/go/internal/cache"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/load"
"cmd/go/internal/modload"
"cmd/go/internal/str"
"cmd/go/internal/trace"
"cmd/internal/buildid"
"cmd/internal/quoted"
"cmd/internal/sys"
"bufio"
"bytes"
"fmt"
"internal/buildcfg"
"internal/platform"
"io"
"log"
"os"
"path/filepath"
"runtime"
"strings"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fips140"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/load"
"cmd/go/internal/str"
"cmd/internal/quoted"
"crypto/sha1"
"bytes"
"fmt"
"os"
"os/exec"
"path/filepath"
"strings"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/load"
"cmd/go/internal/str"
"cmd/internal/pathcache"
"cmd/internal/pkgpath"
"bytes"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/modload"
"cmd/internal/quoted"
"fmt"
"internal/platform"
"os"
"os/exec"
"path/filepath"
"regexp"
"runtime"
"strconv"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/str"
"cmd/internal/cov/covcmd"
"context"
"encoding/json"
"fmt"
"internal/coverage"
"io"
"os"
"path/filepath"
"fmt"
"internal/lazyregexp"
"regexp"
"strings"
"cmd/go/internal/cfg"
"cmd/go/internal/load"
"bytes"
"cmd/go/internal/base"
"cmd/go/internal/cache"
"cmd/go/internal/cfg"
"cmd/go/internal/load"
"cmd/go/internal/str"
"cmd/internal/par"
"cmd/internal/pathcache"
"errors"
"fmt"
"internal/lazyregexp"
"io"
"io/fs"
"os"
"os/exec"
"path/filepath"
"runtime"
"strconv"
"strings"
"sync"
"time"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="AllowInstall">
               <h3>
                  AllowInstall 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>AllowInstall returns a non-nil error if this invocation of the go command is
allowed to install a.Target.
The build of cmd/go running under its own test is forbidden from installing
to its original GOROOT. The var is exported so it can be set by TestMain.</p>
               
               <pre><code>var AllowInstall = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global" data-name="BuildToolchain">
               <h3>
                  BuildToolchain 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var BuildToolchain toolchain = noToolchain{...}</code></pre>
            </article>
            
            <article class="global" data-name="CmdBuild">
               <h3>
                  CmdBuild 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var CmdBuild = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="CmdInstall">
               <h3>
                  CmdInstall 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var CmdInstall = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="DefaultBuildFlags">
               <h3>
                  DefaultBuildFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const DefaultBuildFlags BuildFlagMask = 0</code></pre>
            </article>
            
            <article class="global" data-name="DefaultCFlags">
               <h3>
                  DefaultCFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const DefaultCFlags = "-O2 -g"</code></pre>
            </article>
            
            <article class="global" data-name="ExecCmd">
               <h3>
                  ExecCmd 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ExecCmd is the command to use to run user binaries.
Normally it is empty, meaning run the binaries directly.
If cross-compiling and running on a remote system or
simulator, it is typically go_GOOS_GOARCH_exec, with
the target GOOS and GOARCH substituted.
The -exec flag overrides these defaults.</p>
               
               <pre><code>var ExecCmd []string</code></pre>
            </article>
            
            <article class="global" data-name="GccgoBin">
               <h3>
                  GccgoBin 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var GccgoBin string</code></pre>
            </article>
            
            <article class="global" data-name="GccgoName">
               <h3>
                  GccgoName 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var GccgoName string</code></pre>
            </article>
            
            <article class="global" data-name="ModeBuggyInstall">
               <h3>
                  ModeBuggyInstall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ModeBuggyInstall</code></pre>
            </article>
            
            <article class="global" data-name="ModeBuild">
               <h3>
                  ModeBuild 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ModeBuild BuildMode = iota</code></pre>
            </article>
            
            <article class="global" data-name="ModeInstall">
               <h3>
                  ModeInstall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ModeInstall</code></pre>
            </article>
            
            <article class="global" data-name="ModeVetOnly">
               <h3>
                  ModeVetOnly 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ModeVetOnly = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="OmitBuildOnlyFlags">
               <h3>
                  OmitBuildOnlyFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OmitBuildOnlyFlags</code></pre>
            </article>
            
            <article class="global" data-name="OmitJSONFlag">
               <h3>
                  OmitJSONFlag 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OmitJSONFlag</code></pre>
            </article>
            
            <article class="global" data-name="OmitModCommonFlags">
               <h3>
                  OmitModCommonFlags 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OmitModCommonFlags</code></pre>
            </article>
            
            <article class="global" data-name="OmitModFlag">
               <h3>
                  OmitModFlag 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OmitModFlag BuildFlagMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="OmitVFlag">
               <h3>
                  OmitVFlag 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OmitVFlag</code></pre>
            </article>
            
            <article class="global" data-name="ToolchainVersion">
               <h3>
                  ToolchainVersion 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Tests can override this by setting $TESTGO_TOOLCHAIN_VERSION.</p>
               
               <pre><code>var ToolchainVersion = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="VetExplicit">
               <h3>
                  VetExplicit 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>VetExplicit records whether the vet flags were set explicitly on the command line.</p>
               
               <pre><code>var VetExplicit bool</code></pre>
            </article>
            
            <article class="global" data-name="VetFlags">
               <h3>
                  VetFlags 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>VetFlags are the default flags to pass to vet.
The caller is expected to set them before executing any vet actions.</p>
               
               <pre><code>var VetFlags []string</code></pre>
            </article>
            
            <article class="global" data-name="VetTool">
               <h3>
                  VetTool 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>VetTool is the path to an alternate vet tool binary.
The caller is expected to set it (if needed) before executing any vet actions.</p>
               
               <pre><code>var VetTool string</code></pre>
            </article>
            
            <article class="global" data-name="buildIDSeparator">
               <h3>
                  buildIDSeparator 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const buildIDSeparator = "/"</code></pre>
            </article>
            
            <article class="global" data-name="buildInitStarted">
               <h3>
                  buildInitStarted 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var buildInitStarted = false</code></pre>
            </article>
            
            <article class="global" data-name="builderWorkDirs">
               <h3>
                  builderWorkDirs 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var builderWorkDirs sync.Map</code></pre>
            </article>
            
            <article class="global" data-name="cgoLine">
               <h3>
                  cgoLine 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var cgoLine = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="cgoRe">
               <h3>
                  cgoRe 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var cgoRe = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="cgoTypeSigRe">
               <h3>
                  cgoTypeSigRe 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var cgoTypeSigRe = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="compiler">
               <h3>
                  compiler 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var compiler struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="concurrentGCBackendCompilationEnabledByDefault">
               <h3>
                  concurrentGCBackendCompilationEnabledByDefault 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const concurrentGCBackendCompilationEnabledByDefault = true</code></pre>
            </article>
            
            <article class="global" data-name="counterCacheHit">
               <h3>
                  counterCacheHit 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var counterCacheHit = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="counterCacheMiss">
               <h3>
                  counterCacheMiss 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var counterCacheMiss = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="forcedAsmflags">
               <h3>
                  forcedAsmflags 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var forcedAsmflags []string</code></pre>
            </article>
            
            <article class="global" data-name="forcedGccgoflags">
               <h3>
                  forcedGccgoflags 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var forcedGccgoflags []string</code></pre>
            </article>
            
            <article class="global" data-name="forcedGcflags">
               <h3>
                  forcedGcflags 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var forcedGcflags []string</code></pre>
            </article>
            
            <article class="global" data-name="forcedLdflags">
               <h3>
                  forcedLdflags 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var forcedLdflags []string</code></pre>
            </article>
            
            <article class="global" data-name="gccgoErr">
               <h3>
                  gccgoErr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var gccgoErr error</code></pre>
            </article>
            
            <article class="global" data-name="gccgoSupportsCgoIncomplete">
               <h3>
                  gccgoSupportsCgoIncomplete 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var gccgoSupportsCgoIncomplete bool</code></pre>
            </article>
            
            <article class="global" data-name="gccgoSupportsCgoIncompleteCode">
               <h3>
                  gccgoSupportsCgoIncompleteCode 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoSupportsCgoIncompleteCode = `
package p

import "runtime/cgo"

type I cgo.Incomplete
`</code></pre>
            </article>
            
            <article class="global" data-name="gccgoSupportsCgoIncompleteOnce">
               <h3>
                  gccgoSupportsCgoIncompleteOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var gccgoSupportsCgoIncompleteOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="gccgoToSymbolFunc">
               <h3>
                  gccgoToSymbolFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var gccgoToSymbolFunc func(string) string</code></pre>
            </article>
            
            <article class="global" data-name="gccgoToSymbolFuncOnce">
               <h3>
                  gccgoToSymbolFuncOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var gccgoToSymbolFuncOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="invalidLinkerFlags">
               <h3>
                  invalidLinkerFlags 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var invalidLinkerFlags = []*lazyregexp.Regexp{...}</code></pre>
            </article>
            
            <article class="global" data-name="ldBuildmode">
               <h3>
                  ldBuildmode 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ldBuildmode string</code></pre>
            </article>
            
            <article class="global" data-name="needBuild">
               <h3>
                  needBuild 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const needBuild uint32 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="needCgoHdr">
               <h3>
                  needCgoHdr 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const needCgoHdr</code></pre>
            </article>
            
            <article class="global" data-name="needCompiledGoFiles">
               <h3>
                  needCompiledGoFiles 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const needCompiledGoFiles</code></pre>
            </article>
            
            <article class="global" data-name="needCovMetaFile">
               <h3>
                  needCovMetaFile 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const needCovMetaFile</code></pre>
            </article>
            
            <article class="global" data-name="needStale">
               <h3>
                  needStale 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const needStale</code></pre>
            </article>
            
            <article class="global" data-name="needVet">
               <h3>
                  needVet 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const needVet</code></pre>
            </article>
            
            <article class="global" data-name="objectMagic">
               <h3>
                  objectMagic 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var objectMagic = [][]byte{...}</code></pre>
            </article>
            
            <article class="global" data-name="pkgsFilter">
               <h3>
                  pkgsFilter 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var pkgsFilter = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global" data-name="re">
               <h3>
                  re 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var re = lazyregexp.New</code></pre>
            </article>
            
            <article class="global" data-name="stdlibRecompiled">
               <h3>
                  stdlibRecompiled 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var stdlibRecompiled = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="stdlibRecompiledIncOnce">
               <h3>
                  stdlibRecompiledIncOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var stdlibRecompiledIncOnce = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="swigCheck">
               <h3>
                  swigCheck 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Make sure SWIG is new enough.</p>
               
               <pre><code>var swigCheck error</code></pre>
            </article>
            
            <article class="global" data-name="swigCheckOnce">
               <h3>
                  swigCheckOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Make sure SWIG is new enough.</p>
               
               <pre><code>var swigCheckOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="swigIntSize">
               <h3>
                  swigIntSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Find the value to pass for the -intgosize option to swig.</p>
               
               <pre><code>var swigIntSize string</code></pre>
            </article>
            
            <article class="global" data-name="swigIntSizeCode">
               <h3>
                  swigIntSizeCode 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>This code fails to build if sizeof(int) <= 32</p>
               
               <pre><code>const swigIntSizeCode = `
package main
const i int = 1 << 32
`</code></pre>
            </article>
            
            <article class="global" data-name="swigIntSizeError">
               <h3>
                  swigIntSizeError 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Find the value to pass for the -intgosize option to swig.</p>
               
               <pre><code>var swigIntSizeError error</code></pre>
            </article>
            
            <article class="global" data-name="swigIntSizeOnce">
               <h3>
                  swigIntSizeOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Find the value to pass for the -intgosize option to swig.</p>
               
               <pre><code>var swigIntSizeOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="validCompilerFlags">
               <h3>
                  validCompilerFlags 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var validCompilerFlags = []*lazyregexp.Regexp{...}</code></pre>
            </article>
            
            <article class="global" data-name="validCompilerFlagsWithNextArg">
               <h3>
                  validCompilerFlagsWithNextArg 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var validCompilerFlagsWithNextArg = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="validLinkerFlags">
               <h3>
                  validLinkerFlags 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var validLinkerFlags = []*lazyregexp.Regexp{...}</code></pre>
            </article>
            
            <article class="global" data-name="validLinkerFlagsWithNextArg">
               <h3>
                  validLinkerFlagsWithNextArg 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var validLinkerFlagsWithNextArg = []string{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="ActorFunc">
               <h3>
                  ActorFunc
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An ActorFunc is an Actor that calls the function.</p>
               
               <pre><code>type ActorFunc func(*Builder, context.Context, *Action) error</code></pre>
            </article>
            
            <article class="type" data-name="BuildFlagMask">
               <h3>
                  BuildFlagMask
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type BuildFlagMask int</code></pre>
            </article>
            
            <article class="type" data-name="BuildMode">
               <h3>
                  BuildMode
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>BuildMode specifies the build mode:
are we just building things or also installing the results?</p>
               
               <pre><code>type BuildMode int</code></pre>
            </article>
            
            <article class="type" data-name="actionQueue">
               <h3>
                  actionQueue
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An actionQueue is a priority queue of actions.</p>
               
               <pre><code>type actionQueue []*Action</code></pre>
            </article>
            
            <article class="type" data-name="buildvcsFlag">
               <h3>
                  buildvcsFlag
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>buildvcsFlag is the implementation of the -buildvcs flag.</p>
               
               <pre><code>type buildvcsFlag string</code></pre>
            </article>
            
            <article class="type" data-name="coverModeFlag">
               <h3>
                  coverModeFlag
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type coverModeFlag string</code></pre>
            </article>
            
            <article class="type" data-name="tagsFlag">
               <h3>
                  tagsFlag
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>tagsFlag is the implementation of the -tags flag.</p>
               
               <pre><code>type tagsFlag []string</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Actor">
               <h3>
                  Actor
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>An Actor runs an action.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Actor interface {
Act(*Builder, context.Context, *Action) error
}</code></pre>
            </article>
            
            <article class="interface" data-name="toolchain">
               <h3>
                  toolchain
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type toolchain interface {
gc(b *Builder, a *Action, archive string, importcfg []byte, embedcfg []byte, symabis string, asmhdr bool, pgoProfile string, gofiles []string) (ofile string, out []byte, err error)
cc(b *Builder, a *Action, ofile string, cfile string) error
asm(b *Builder, a *Action, sfiles []string) ([]string, error)
symabis(b *Builder, a *Action, sfiles []string) (string, error)
pack(b *Builder, a *Action, afile string, ofiles []string) error
ld(b *Builder, root *Action, targetPath string, importcfg string, mainpkg string) error
ldShared(b *Builder, root *Action, toplevelactions []*Action, targetPath string, importcfg string, allactions []*Action) error
compiler() string
linker() string
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Action">
               <h3>
                  Action
                  <span class="badge">struct</span>
               </h3>
               
               <p>An Action represents a single action in the action graph.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Action struct {
Mode string
Package *load.Package
Deps []*Action
Actor Actor
IgnoreFail bool
TestOutput *bytes.Buffer
Args []string
triggers []*Action
buggyInstall bool
TryCache func(*Builder, *Action) bool
CacheExecutable bool
Objdir string
Target string
built string
actionID cache.ActionID
buildID string
VetxOnly bool
needVet bool
needBuild bool
vetCfg *vetConfig
output []byte
sh *Shell
pending int
priority int
Failed *Action
json *actionJSON
nonGoOverlay map[string]string
traceSpan *trace.Span
}</code></pre>
            </article>
            
            <article class="struct" data-name="Builder">
               <h3>
                  Builder
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Builder holds global state about a build.
It does not hold per-package state, because we
build packages in parallel, and the builder is shared.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Builder struct {
WorkDir string
actionCache map[cacheKey]*Action
flagCache map[[2]string]bool
gccCompilerIDCache map[string]cache.ActionID
IsCmdList bool
NeedError bool
NeedExport bool
NeedCompiledGoFiles bool
AllowErrors bool
objdirSeq int
pkgSeq int
backgroundSh *Shell
exec sync.Mutex
readySema chan bool
ready actionQueue
id sync.Mutex
toolIDCache map[string]string
buildIDCache map[string]string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Shell">
               <h3>
                  Shell
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Shell runs shell commands and performs shell-like file system operations.
Shell tracks context related to running commands, and form a tree much like
context.Context.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Shell struct {
action *Action
*shellShared
}</code></pre>
            </article>
            
            <article class="struct" data-name="actionJSON">
               <h3>
                  actionJSON
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type actionJSON struct {
ID int
Mode string
Package string
Deps []int `json:",omitempty"`
IgnoreFail bool `json:",omitempty"`
Args []string `json:",omitempty"`
Link bool `json:",omitempty"`
Objdir string `json:",omitempty"`
Target string `json:",omitempty"`
Priority int `json:",omitempty"`
Failed bool `json:",omitempty"`
Built string `json:",omitempty"`
VetxOnly bool `json:",omitempty"`
NeedVet bool `json:",omitempty"`
NeedBuild bool `json:",omitempty"`
ActionID string `json:",omitempty"`
BuildID string `json:",omitempty"`
TimeReady time.Time `json:",omitempty"`
TimeStart time.Time `json:",omitempty"`
TimeDone time.Time `json:",omitempty"`
Cmd []string
CmdReal time.Duration `json:",omitempty"`
CmdUser time.Duration `json:",omitempty"`
CmdSys time.Duration `json:",omitempty"`
}</code></pre>
            </article>
            
            <article class="struct" data-name="buildActor">
               <h3>
                  buildActor
                  <span class="badge">struct</span>
               </h3>
               
               <p>buildActor implements the Actor interface for package build
actions. For most package builds this simply means invoking th
*Builder.build method; in the case of "go test -cover" for
a package with no test files, we stores some additional state
information in the build actor to help with reporting.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type buildActor struct {
covMetaFileName string
}</code></pre>
            </article>
            
            <article class="struct" data-name="buildCompiler">
               <h3>
                  buildCompiler
                  <span class="badge">struct</span>
               </h3>
               
               <p>buildCompiler implements flag.Var.
It implements Set by updating both
BuildToolchain and buildContext.Compiler.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type buildCompiler struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="cacheKey">
               <h3>
                  cacheKey
                  <span class="badge">struct</span>
               </h3>
               
               <p>cacheKey is the key for the action cache.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type cacheKey struct {
mode string
p *load.Package
}</code></pre>
            </article>
            
            <article class="struct" data-name="cmdError">
               <h3>
                  cmdError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type cmdError struct {
desc string
text string
importPath string
needsPath bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="commaListFlag">
               <h3>
                  commaListFlag
                  <span class="badge">struct</span>
               </h3>
               
               <p>A commaListFlag is a flag.Value representing a comma-separated list.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type commaListFlag struct {
Vals *[]string
}</code></pre>
            </article>
            
            <article class="struct" data-name="coverFlag">
               <h3>
                  coverFlag
                  <span class="badge">struct</span>
               </h3>
               
               <p>A coverFlag is a flag.Value that also implies -cover.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type coverFlag struct {
V flag.Value
}</code></pre>
            </article>
            
            <article class="struct" data-name="gcToolchain">
               <h3>
                  gcToolchain
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gcToolchain struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="gccgoToolchain">
               <h3>
                  gccgoToolchain
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gccgoToolchain struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="noToolchain">
               <h3>
                  noToolchain
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type noToolchain struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="pgoActor">
               <h3>
                  pgoActor
                  <span class="badge">struct</span>
               </h3>
               
               <p>pgoActor implements the Actor interface for preprocessing PGO profiles.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pgoActor struct {
input string
}</code></pre>
            </article>
            
            <article class="struct" data-name="shellShared">
               <h3>
                  shellShared
                  <span class="badge">struct</span>
               </h3>
               
               <p>shellShared is Shell state shared across all Shells derived from a single
root shell (generally a single Builder).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type shellShared struct {
workDir string
printLock sync.Mutex
printer load.Printer
scriptDir string
mkdirCache *ast.IndexListExpr
}</code></pre>
            </article>
            
            <article class="struct" data-name="stringFlag">
               <h3>
                  stringFlag
                  <span class="badge">struct</span>
               </h3>
               
               <p>A stringFlag is a flag.Value representing a single string.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type stringFlag struct {
val *string
}</code></pre>
            </article>
            
            <article class="struct" data-name="version">
               <h3>
                  version
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type version struct {
name string
major int
minor int
}</code></pre>
            </article>
            
            <article class="struct" data-name="vetConfig">
               <h3>
                  vetConfig
                  <span class="badge">struct</span>
               </h3>
               
               <p>vetConfig is the configuration passed to vet describing a single package.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type vetConfig struct {
ID string
Compiler string
Dir string
ImportPath string
GoFiles []string
NonGoFiles []string
IgnoredFiles []string
ModulePath string
ModuleVersion string
ImportMap map[string]string
PackageFile map[string]string
Standard map[string]bool
PackageVetx map[string]string
VetxOnly bool
VetxOutput string
GoVersion string
SucceedOnTypecheckFailure bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Act">
               <h3>
                  Act 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ba *buildActor) Act(b *Builder, ctx context.Context, a *Action) error</code></pre>
            </article>
            
            <article class="function" data-name="Act">
               <h3>
                  Act 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f ActorFunc) Act(b *Builder, ctx context.Context, a *Action) error</code></pre>
            </article>
            
            <article class="function" data-name="Act">
               <h3>
                  Act 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *pgoActor) Act(b *Builder, ctx context.Context, a *Action) error</code></pre>
            </article>
            
            <article class="function" data-name="AddBuildFlags">
               <h3>
                  AddBuildFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AddBuildFlags adds the flags common to the build, clean, get,
install, list, run, and test commands.</p>
               
               <pre><code>func AddBuildFlags(cmd *base.Command, mask BuildFlagMask)</code></pre>
            </article>
            
            <article class="function" data-name="AddCoverFlags">
               <h3>
                  AddCoverFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AddCoverFlags adds coverage-related flags to "cmd". If the
CoverageRedesign experiment is enabled, we add -cover{mode,pkg} to
the build command and only -coverprofile to the test command. If
the CoverageRedesign experiment is disabled, -cover* flags are
added only to the test command.</p>
               
               <pre><code>func AddCoverFlags(cmd *base.Command, coverProfileFlag *string)</code></pre>
            </article>
            
            <article class="function" data-name="AutoAction">
               <h3>
                  AutoAction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AutoAction returns the "right" action for go build or go install of p.</p>
               
               <pre><code>func (b *Builder) AutoAction(mode BuildMode, depMode BuildMode, p *load.Package) *Action</code></pre>
            </article>
            
            <article class="function" data-name="BackgroundShell">
               <h3>
                  BackgroundShell 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BackgroundShell returns a Builder-wide Shell that's not bound to any Action.
Try not to use this unless there's really no sensible Action available.</p>
               
               <pre><code>func (b *Builder) BackgroundShell() *Shell</code></pre>
            </article>
            
            <article class="function" data-name="BuildActionCoverMetaFile">
               <h3>
                  BuildActionCoverMetaFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>BuildActionCoverMetaFile locates and returns the path of the
meta-data file written by the "go tool cover" step as part of the
build action for the "go test -cover" run action 'runAct'. Note
that if the package has no functions the meta-data file will exist
but will be empty; in this case the return is an empty string.</p>
               
               <pre><code>func BuildActionCoverMetaFile(runAct *Action) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="BuildActionID">
               <h3>
                  BuildActionID 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BuildActionID returns the action ID section of a's build ID.</p>
               
               <pre><code>func (a *Action) BuildActionID() string</code></pre>
            </article>
            
            <article class="function" data-name="BuildContentID">
               <h3>
                  BuildContentID 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BuildContentID returns the content ID section of a's build ID.</p>
               
               <pre><code>func (a *Action) BuildContentID() string</code></pre>
            </article>
            
            <article class="function" data-name="BuildID">
               <h3>
                  BuildID 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BuildID returns a's build ID.</p>
               
               <pre><code>func (a *Action) BuildID() string</code></pre>
            </article>
            
            <article class="function" data-name="BuildInit">
               <h3>
                  BuildInit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func BuildInit()</code></pre>
            </article>
            
            <article class="function" data-name="BuildInstallFunc">
               <h3>
                  BuildInstallFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>BuildInstallFunc is the action for installing a single package or executable.</p>
               
               <pre><code>func BuildInstallFunc(b *Builder, ctx context.Context, a *Action) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="BuiltTarget">
               <h3>
                  BuiltTarget 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BuiltTarget returns the actual file that was built. This differs
from Target when the result was cached.</p>
               
               <pre><code>func (a *Action) BuiltTarget() string</code></pre>
            </article>
            
            <article class="function" data-name="CFlags">
               <h3>
                  CFlags 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CFlags returns the flags to use when invoking the C, C++ or Fortran compilers, or cgo.</p>
               
               <pre><code>func (b *Builder) CFlags(p *load.Package) (cppflags []string, cflags []string, cxxflags []string, fflags []string, ldflags []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="CheckGOOSARCHPair">
               <h3>
                  CheckGOOSARCHPair 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func CheckGOOSARCHPair(goos string, goarch string) error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="CompileAction">
               <h3>
                  CompileAction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CompileAction returns the action for compiling and possibly installing
(according to mode) the given package. The resulting action is only
for building packages (archives), never for linking executables.
depMode is the action (build or install) to use when building dependencies.
To turn package main into an executable, call b.Link instead.</p>
               
               <pre><code>func (b *Builder) CompileAction(mode BuildMode, depMode BuildMode, p *load.Package) *Action</code></pre>
            </article>
            
            <article class="function" data-name="CopyFile">
               <h3>
                  CopyFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>copyFile is like 'cp src dst'.</p>
               
               <pre><code>func (sh *Shell) CopyFile(dst string, src string, perm fs.FileMode, force bool) error</code></pre>
            </article>
            
            <article class="function" data-name="CovData">
               <h3>
                  CovData 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CovData invokes "go tool covdata" with the specified arguments
as part of the execution of action 'a'.</p>
               
               <pre><code>func (b *Builder) CovData(a *Action, cmdargs ...any) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Do">
               <h3>
                  Do 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Do runs the action graph rooted at root.</p>
               
               <pre><code>func (b *Builder) Do(ctx context.Context, root *Action)</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *cmdError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Errorf">
               <h3>
                  Errorf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Errorf reports an error on sh's package and sets the process exit status to 1.</p>
               
               <pre><code>func (sh *Shell) Errorf(format string, a ...any)</code></pre>
            </article>
            
            <article class="function" data-name="FindExecCmd">
               <h3>
                  FindExecCmd 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FindExecCmd derives the value of ExecCmd to use.
It returns that value and leaves ExecCmd set for direct use.</p>
               
               <pre><code>func FindExecCmd() []string</code></pre>
            </article>
            
            <article class="function" data-name="GccCmd">
               <h3>
                  GccCmd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GccCmd returns a gcc command line prefix
defaultCC is defined in zdefaultcc.go, written by cmd/dist.</p>
               
               <pre><code>func (b *Builder) GccCmd(incdir string, workdir string) []string</code></pre>
            </article>
            
            <article class="function" data-name="GxxCmd">
               <h3>
                  GxxCmd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GxxCmd returns a g++ command line prefix
defaultCXX is defined in zdefaultcc.go, written by cmd/dist.</p>
               
               <pre><code>func (b *Builder) GxxCmd(incdir string, workdir string) []string</code></pre>
            </article>
            
            <article class="function" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *cmdError) ImportPath() string</code></pre>
            </article>
            
            <article class="function" data-name="InstallPackages">
               <h3>
                  InstallPackages 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func InstallPackages(ctx context.Context, patterns []string, pkgs []*load.Package)</code></pre>
            </article>
            
            <article class="function" data-name="IsBoolFlag">
               <h3>
                  IsBoolFlag 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *buildvcsFlag) IsBoolFlag() bool</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Implement heap.Interface</p>
               
               <pre><code>func (q *actionQueue) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (q *actionQueue) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="LinkAction">
               <h3>
                  LinkAction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LinkAction returns the action for linking p into an executable
and possibly installing the result (according to mode).
depMode is the action (build or install) to use when compiling dependencies.</p>
               
               <pre><code>func (b *Builder) LinkAction(mode BuildMode, depMode BuildMode, p *load.Package) *Action</code></pre>
            </article>
            
            <article class="function" data-name="Mkdir">
               <h3>
                  Mkdir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Mkdir makes the named directory.</p>
               
               <pre><code>func (sh *Shell) Mkdir(dir string) error</code></pre>
            </article>
            
            <article class="function" data-name="NewBuilder">
               <h3>
                  NewBuilder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewBuilder returns a new Builder ready for use.
If workDir is the empty string, NewBuilder creates a WorkDir if needed
and arranges for it to be removed in case of an unclean exit.
The caller must Close the builder explicitly to clean up the WorkDir
before a clean exit.</p>
               
               <pre><code>func NewBuilder(workDir string) *Builder</code></pre>
            </article>
            
            <article class="function" data-name="NewObjdir">
               <h3>
                  NewObjdir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NewObjdir returns the name of a fresh object directory under b.WorkDir.
It is up to the caller to call b.Mkdir on the result at an appropriate time.
The result ends in a slash, so that file names in that directory
can be constructed with direct string addition.
NewObjdir must be called only from a single goroutine at a time,
so it is safe to call during action graph construction, but it must not
be called during action graph execution.</p>
               
               <pre><code>func (b *Builder) NewObjdir() string</code></pre>
            </article>
            
            <article class="function" data-name="NewShell">
               <h3>
                  NewShell 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewShell returns a new Shell.
Shell will internally serialize calls to the printer.
If printer is nil, it uses load.DefaultPrinter.</p>
               
               <pre><code>func NewShell(workDir string, printer load.Printer) *Shell</code></pre>
            </article>
            
            <article class="function" data-name="PkgconfigCmd">
               <h3>
                  PkgconfigCmd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PkgconfigCmd returns a pkg-config binary name
defaultPkgConfig is defined in zdefaultcc.go, written by cmd/dist.</p>
               
               <pre><code>func (b *Builder) PkgconfigCmd() string</code></pre>
            </article>
            
            <article class="function" data-name="Pop">
               <h3>
                  Pop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (q *actionQueue) Pop() any</code></pre>
            </article>
            
            <article class="function" data-name="Printf">
               <h3>
                  Printf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Printf emits a to this Shell's output stream, formatting it like fmt.Printf.
It is safe to call concurrently.</p>
               
               <pre><code>func (sh *Shell) Printf(format string, a ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (q *actionQueue) Push(x any)</code></pre>
            </article>
            
            <article class="function" data-name="RemoveAll">
               <h3>
                  RemoveAll 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RemoveAll is like 'rm -rf'. It attempts to remove all paths even if there's
an error, and returns the first error.</p>
               
               <pre><code>func (sh *Shell) RemoveAll(paths ...string) error</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f commaListFlag) Set(value string) error</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *buildvcsFlag) Set(s string) error</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *coverModeFlag) Set(value string) error</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *tagsFlag) Set(s string) error</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f coverFlag) Set(value string) error</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c buildCompiler) Set(value string) error</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f stringFlag) Set(value string) error</code></pre>
            </article>
            
            <article class="function" data-name="Shell">
               <h3>
                  Shell 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Shell returns a shell for running commands on behalf of Action a.</p>
               
               <pre><code>func (b *Builder) Shell(a *Action) *Shell</code></pre>
            </article>
            
            <article class="function" data-name="ShowCmd">
               <h3>
                  ShowCmd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ShowCmd prints the given command to standard output
for the implementation of -n or -x.
ShowCmd also replaces the name of the current script directory with dot (.)
but only when it is at the beginning of a space-separated token.
If dir is not "" or "/" and not the current script directory, ShowCmd first
prints a "cd" command to switch to dir and updates the script directory.</p>
               
               <pre><code>func (sh *Shell) ShowCmd(dir string, format string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f stringFlag) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *tagsFlag) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c buildCompiler) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f coverFlag) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *coverModeFlag) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *buildvcsFlag) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f commaListFlag) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (q *actionQueue) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="Symlink">
               <h3>
                  Symlink 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Symlink creates a symlink newname -> oldname.</p>
               
               <pre><code>func (sh *Shell) Symlink(oldname string, newname string) error</code></pre>
            </article>
            
            <article class="function" data-name="VetAction">
               <h3>
                  VetAction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>VetAction returns the action for running go vet on package p.
It depends on the action for compiling p.
If the caller may be causing p to be installed, it is up to the caller
to make sure that the install depends on (runs after) vet.</p>
               
               <pre><code>func (b *Builder) VetAction(mode BuildMode, depMode BuildMode, p *load.Package) *Action</code></pre>
            </article>
            
            <article class="function" data-name="WithAction">
               <h3>
                  WithAction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WithAction returns a Shell identical to sh, but bound to Action a.</p>
               
               <pre><code>func (sh *Shell) WithAction(a *Action) *Shell</code></pre>
            </article>
            
            <article class="function" data-name="WriteCoverMetaFilesFile">
               <h3>
                  WriteCoverMetaFilesFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WriteCoverMetaFilesFile writes out a summary file ("meta-files
file") as part of the action function for the "writeCoverMeta"
pseudo action employed during "go test -coverpkg" runs where there
are multiple tests and multiple packages covered. It builds up a
table mapping package import path to meta-data file fragment and
writes it out to a file where it can be read by the various test
run actions. Note that this function has to be called A) after the
build actions are complete for all packages being tested, and B)
before any of the "run test" actions for those packages happen.
This requirement is enforced by adding making this action ("a")
dependent on all test package build actions, and making all test
run actions dependent on this action.</p>
               
               <pre><code>func WriteCoverMetaFilesFile(b *Builder, ctx context.Context, a *Action) error</code></pre>
            </article>
            
            <article class="function" data-name="WriteCoveragePercent">
               <h3>
                  WriteCoveragePercent 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WriteCoveragePercent writes out to the writer 'w' a "percent
statements covered" for the package whose test-run action is
'runAct', based on the meta-data file 'mf'. This helper is used in
cases where a user runs "go test -cover" on a package that has
functions but no tests; in the normal case (package has tests)
the percentage is written by the test binary when it runs.</p>
               
               <pre><code>func WriteCoveragePercent(b *Builder, runAct *Action, mf string, w io.Writer) error</code></pre>
            </article>
            
            <article class="function" data-name="WriteCoverageProfile">
               <h3>
                  WriteCoverageProfile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WriteCoverageProfile writes out a coverage profile fragment for the
package whose test-run action is 'runAct'; content is written to
the file 'outf' based on the coverage meta-data info found in
'mf'. This helper is used in cases where a user runs "go test
-cover" on a package that has functions but no tests.</p>
               
               <pre><code>func WriteCoverageProfile(b *Builder, runAct *Action, mf string, outf string, w io.Writer) error</code></pre>
            </article>
            
            <article class="function" data-name="actionGraphJSON">
               <h3>
                  actionGraphJSON 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func actionGraphJSON(a *Action) string</code></pre>
            </article>
            
            <article class="function" data-name="actionID">
               <h3>
                  actionID 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>actionID returns the action ID half of a build ID.</p>
               
               <pre><code>func actionID(buildID string) string</code></pre>
            </article>
            
            <article class="function" data-name="actionList">
               <h3>
                  actionList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>actionList returns the list of actions in the dag rooted at root
as visited in a depth-first post-order traversal.</p>
               
               <pre><code>func actionList(root *Action) []*Action</code></pre>
            </article>
            
            <article class="function" data-name="actualFiles">
               <h3>
                  actualFiles 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>actualFiles applies fsys.Actual to the list of files.</p>
               
               <pre><code>func actualFiles(files []string) []string</code></pre>
            </article>
            
            <article class="function" data-name="addInstallHeaderAction">
               <h3>
                  addInstallHeaderAction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addInstallHeaderAction adds an install header action to a, if needed.
The action a should be an install action as generated by either
b.CompileAction or b.LinkAction with mode=ModeInstall,
and so a.Deps[0] is the corresponding build action.</p>
               
               <pre><code>func (b *Builder) addInstallHeaderAction(a *Action)</code></pre>
            </article>
            
            <article class="function" data-name="addTransitiveLinkDeps">
               <h3>
                  addTransitiveLinkDeps 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addTransitiveLinkDeps adds to the link action a all packages
that are transitive dependencies of a1.Deps.
That is, if a is a link of package main, a1 is the compile of package main
and a1.Deps is the actions for building packages directly imported by
package main (what the compiler needs). The linker needs all packages
transitively imported by the whole program; addTransitiveLinkDeps
makes sure those are present in a.Deps.
If shlib is non-empty, then a corresponds to the build and installation of shlib,
so any rebuild of shlib should not be added as a dependency.</p>
               
               <pre><code>func (b *Builder) addTransitiveLinkDeps(a *Action, a1 *Action, shlib string)</code></pre>
            </article>
            
            <article class="function" data-name="allowedVersion">
               <h3>
                  allowedVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>allowedVersion reports whether the version v is an allowed version of go
(one that we can compile).
v is known to be of the form "1.23".</p>
               
               <pre><code>func allowedVersion(v string) bool</code></pre>
            </article>
            
            <article class="function" data-name="ar">
               <h3>
                  ar 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (gccgoToolchain) ar() []string</code></pre>
            </article>
            
            <article class="function" data-name="asm">
               <h3>
                  asm 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (noToolchain) asm(b *Builder, a *Action, sfiles []string) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="asm">
               <h3>
                  asm 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (tools gccgoToolchain) asm(b *Builder, a *Action, sfiles []string) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="asm">
               <h3>
                  asm 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (gcToolchain) asm(b *Builder, a *Action, sfiles []string) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="asmArgs">
               <h3>
                  asmArgs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func asmArgs(a *Action, p *load.Package) []any</code></pre>
            </article>
            
            <article class="function" data-name="assemblerIsGas">
               <h3>
                  assemblerIsGas 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Check if assembler used by gccgo is GNU as.</p>
               
               <pre><code>func assemblerIsGas() bool</code></pre>
            </article>
            
            <article class="function" data-name="build">
               <h3>
                  build 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>build is the action for building a single package.
Note that any new influence on this logic must be reported in b.buildActionID above as well.</p>
               
               <pre><code>func (b *Builder) build(ctx context.Context, a *Action) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="buildActionID">
               <h3>
                  buildActionID 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>buildActionID computes the action ID for a build action.</p>
               
               <pre><code>func (b *Builder) buildActionID(a *Action) cache.ActionID</code></pre>
            </article>
            
            <article class="function" data-name="buildFlags">
               <h3>
                  buildFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func buildFlags(name string, defaults string, fromPackage []string, check func(string, string, []string) error) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="buildID">
               <h3>
                  buildID 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>buildID returns the build ID found in the given file.
If no build ID is found, buildID returns the content hash of the file.</p>
               
               <pre><code>func (b *Builder) buildID(file string) string</code></pre>
            </article>
            
            <article class="function" data-name="buildImportcfgSymlinks">
               <h3>
                  buildImportcfgSymlinks 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>buildImportcfgSymlinks builds in root a tree of symlinks
implementing the directives from importcfg.
This serves as a temporary transition mechanism until
we can depend on gccgo reading an importcfg directly.
(The Go 1.9 and later gc compilers already do.)</p>
               
               <pre><code>func buildImportcfgSymlinks(sh *Shell, root string, importcfg []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="buildModeInit">
               <h3>
                  buildModeInit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func buildModeInit()</code></pre>
            </article>
            
            <article class="function" data-name="buildVetConfig">
               <h3>
                  buildVetConfig 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func buildVetConfig(a *Action, srcfiles []string)</code></pre>
            </article>
            
            <article class="function" data-name="buildmodeShared">
               <h3>
                  buildmodeShared 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>buildmodeShared takes the "go build" action a1 into the building of a shared library of a1.Deps.
That is, the input a1 represents "go build pkgs" and the result represents "go build -buildmode=shared pkgs".</p>
               
               <pre><code>func (b *Builder) buildmodeShared(mode BuildMode, depMode BuildMode, args []string, pkgs []*load.Package, a1 *Action) *Action</code></pre>
            </article>
            
            <article class="function" data-name="cCompilerEnv">
               <h3>
                  cCompilerEnv 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>cCompilerEnv returns environment variables to set when running the
C compiler. This is needed to disable escape codes in clang error
messages that confuse tools like cgo.</p>
               
               <pre><code>func (b *Builder) cCompilerEnv() []string</code></pre>
            </article>
            
            <article class="function" data-name="cacheAction">
               <h3>
                  cacheAction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>cacheAction looks up {mode, p} in the cache and returns the resulting action.
If the cache has no such action, f() is recorded and returned.
TODO(rsc): Change the second key from *load.Package to interface{},
to make the caching in linkShared less awkward?</p>
               
               <pre><code>func (b *Builder) cacheAction(mode string, p *load.Package, f func() *Action) *Action</code></pre>
            </article>
            
            <article class="function" data-name="cacheCgoHdr">
               <h3>
                  cacheCgoHdr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) cacheCgoHdr(a *Action)</code></pre>
            </article>
            
            <article class="function" data-name="cacheObjdirFile">
               <h3>
                  cacheObjdirFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) cacheObjdirFile(a *Action, c cache.Cache, name string) error</code></pre>
            </article>
            
            <article class="function" data-name="cacheSrcFiles">
               <h3>
                  cacheSrcFiles 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) cacheSrcFiles(a *Action, srcfiles []string)</code></pre>
            </article>
            
            <article class="function" data-name="cc">
               <h3>
                  cc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (gcToolchain) cc(b *Builder, a *Action, ofile string, cfile string) error</code></pre>
            </article>
            
            <article class="function" data-name="cc">
               <h3>
                  cc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (tools gccgoToolchain) cc(b *Builder, a *Action, ofile string, cfile string) error</code></pre>
            </article>
            
            <article class="function" data-name="cc">
               <h3>
                  cc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (noToolchain) cc(b *Builder, a *Action, ofile string, cfile string) error</code></pre>
            </article>
            
            <article class="function" data-name="ccExe">
               <h3>
                  ccExe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ccExe returns the CC compiler setting without all the extra flags we add implicitly.</p>
               
               <pre><code>func (b *Builder) ccExe() []string</code></pre>
            </article>
            
            <article class="function" data-name="ccompile">
               <h3>
                  ccompile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ccompile runs the given C or C++ compiler and creates an object from a single source file.</p>
               
               <pre><code>func (b *Builder) ccompile(a *Action, outfile string, flags []string, file string, compiler []string) error</code></pre>
            </article>
            
            <article class="function" data-name="cgo">
               <h3>
                  cgo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) cgo(a *Action, cgoExe string, objdir string, pcCFLAGS []string, pcLDFLAGS []string, cgofiles []string, gccfiles []string, gxxfiles []string, mfiles []string, ffiles []string) (outGo []string, outObj []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="checkCompilerFlags">
               <h3>
                  checkCompilerFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func checkCompilerFlags(name string, source string, list []string) error</code></pre>
            </article>
            
            <article class="function" data-name="checkCompilerFlagsForInternalLink">
               <h3>
                  checkCompilerFlagsForInternalLink 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkCompilerFlagsForInternalLink returns an error if 'list'
contains a flag or flags that may not be fully supported by
internal linking (meaning that we should punt the link to the
external linker).</p>
               
               <pre><code>func checkCompilerFlagsForInternalLink(name string, source string, list []string) error</code></pre>
            </article>
            
            <article class="function" data-name="checkDirectives">
               <h3>
                  checkDirectives 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) checkDirectives(a *Action) error</code></pre>
            </article>
            
            <article class="function" data-name="checkFlags">
               <h3>
                  checkFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func checkFlags(name string, source string, list []string, invalid []*lazyregexp.Regexp, valid []*lazyregexp.Regexp, validNext []string, checkOverrides bool) error</code></pre>
            </article>
            
            <article class="function" data-name="checkGccgoBin">
               <h3>
                  checkGccgoBin 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func checkGccgoBin()</code></pre>
            </article>
            
            <article class="function" data-name="checkLinkerFlags">
               <h3>
                  checkLinkerFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func checkLinkerFlags(name string, source string, list []string) error</code></pre>
            </article>
            
            <article class="function" data-name="cleanup">
               <h3>
                  cleanup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>cleanup removes a's object dir to keep the amount of
on-disk garbage down in a large build. On an operating system
with aggressive buffering, cleaning incrementally like
this keeps the intermediate objects from hitting the disk.</p>
               
               <pre><code>func (b *Builder) cleanup(a *Action)</code></pre>
            </article>
            
            <article class="function" data-name="closeBuilders">
               <h3>
                  closeBuilders 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func closeBuilders()</code></pre>
            </article>
            
            <article class="function" data-name="compiler">
               <h3>
                  compiler 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (gccgoToolchain) compiler() string</code></pre>
            </article>
            
            <article class="function" data-name="compiler">
               <h3>
                  compiler 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (gcToolchain) compiler() string</code></pre>
            </article>
            
            <article class="function" data-name="compiler">
               <h3>
                  compiler 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (noToolchain) compiler() string</code></pre>
            </article>
            
            <article class="function" data-name="compilerCmd">
               <h3>
                  compilerCmd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>compilerCmd returns a command line prefix for the given environment
variable and using the default command when the variable is empty.</p>
               
               <pre><code>func (b *Builder) compilerCmd(compiler []string, incdir string, workdir string) []string</code></pre>
            </article>
            
            <article class="function" data-name="compilerRequiredAsanVersion">
               <h3>
                  compilerRequiredAsanVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>compilerRequiredAsanVersion is a copy of the function defined in
cmd/cgo/internal/testsanitizers/cc_test.go
compilerRequiredAsanVersion reports whether the compiler is the version
required by Asan.</p>
               
               <pre><code>func compilerRequiredAsanVersion() error</code></pre>
            </article>
            
            <article class="function" data-name="compilerVersion">
               <h3>
                  compilerVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>compilerVersion detects the version of $(go env CC).
It returns a non-nil error if the compiler matches a known version schema but
the version could not be parsed, or if $(go env CC) could not be determined.</p>
               
               <pre><code>func compilerVersion() (version, error)</code></pre>
            </article>
            
            <article class="function" data-name="contentID">
               <h3>
                  contentID 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>contentID returns the content ID half of a build ID.</p>
               
               <pre><code>func contentID(buildID string) string</code></pre>
            </article>
            
            <article class="function" data-name="cover">
               <h3>
                  cover 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>cover runs, in effect,
go tool cover -mode=b.coverMode -var="varName" -o dst.go src.go</p>
               
               <pre><code>func (b *Builder) cover(a *Action, dst string, src string, varName string) error</code></pre>
            </article>
            
            <article class="function" data-name="cover2">
               <h3>
                  cover2 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>cover2 runs, in effect,
go tool cover -pkgcfg=<config file> -mode=b.coverMode -var="varName" -o <outfiles> <infiles>
Return value is an updated output files list; in addition to the
regular outputs (instrumented source files) the cover tool also
writes a separate file (appearing first in the list of outputs)
that will contain coverage counters and meta-data.</p>
               
               <pre><code>func (b *Builder) cover2(a *Action, infiles []string, outfiles []string, varName string, mode string) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="cxxExe">
               <h3>
                  cxxExe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>cxxExe returns the CXX compiler setting without all the extra flags we add implicitly.</p>
               
               <pre><code>func (b *Builder) cxxExe() []string</code></pre>
            </article>
            
            <article class="function" data-name="disableBuildID">
               <h3>
                  disableBuildID 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>disableBuildID adjusts a linker command line to avoid creating a
build ID when creating an object file rather than an executable or
shared library. Some systems, such as Ubuntu, always add
--build-id to every link, but we don't want a build ID when we are
producing an object file. On some of those system a plain -r (not
-Wl,-r) will turn off --build-id, but clang 3.0 doesn't support a
plain -r. I don't know how to turn off --build-id when using clang
other than passing a trailing --build-id=none. So that is what we
do, but only on systems likely to support it, which is to say,
systems that normally use gold or the GNU linker.</p>
               
               <pre><code>func (b *Builder) disableBuildID(ldflags []string) []string</code></pre>
            </article>
            
            <article class="function" data-name="dynimport">
               <h3>
                  dynimport 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>dynimport creates a Go source file named importGo containing
//go:cgo_import_dynamic directives for each symbol or library
dynamically imported by the object files outObj.
dynOutGo, if not empty, is a new Go file to build as part of the package.
dynOutObj, if not empty, is a new file to add to the generated archive.</p>
               
               <pre><code>func (b *Builder) dynimport(a *Action, objdir string, importGo string, cgoExe string, cflags []string, cgoLDFLAGS []string, outObj []string) (dynOutGo string, dynOutObj string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="encodeArg">
               <h3>
                  encodeArg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>encodeArg encodes an argument for response file writing.</p>
               
               <pre><code>func encodeArg(arg string) string</code></pre>
            </article>
            
            <article class="function" data-name="envList">
               <h3>
                  envList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>envList returns the value of the given environment variable broken
into fields, using the default value when the variable is empty.
The environment variable must be quoted correctly for
quoted.Split. This should be done before building
anything, for example, in BuildInit.</p>
               
               <pre><code>func envList(key string, def string) []string</code></pre>
            </article>
            
            <article class="function" data-name="fcExe">
               <h3>
                  fcExe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fcExe returns the FC compiler setting without all the extra flags we add implicitly.</p>
               
               <pre><code>func (b *Builder) fcExe() []string</code></pre>
            </article>
            
            <article class="function" data-name="fileExtSplit">
               <h3>
                  fileExtSplit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fileExtSplit expects a filename and returns the name
and ext (without the dot). If the file has no
extension, ext will be empty.</p>
               
               <pre><code>func fileExtSplit(file string) (name string, ext string)</code></pre>
            </article>
            
            <article class="function" data-name="fileHash">
               <h3>
                  fileHash 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fileHash returns the content hash of the named file.</p>
               
               <pre><code>func (b *Builder) fileHash(file string) string</code></pre>
            </article>
            
            <article class="function" data-name="findCachedObjdirFile">
               <h3>
                  findCachedObjdirFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) findCachedObjdirFile(a *Action, c cache.Cache, name string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="flagsNotCompatibleWithInternalLinking">
               <h3>
                  flagsNotCompatibleWithInternalLinking 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>flagsNotCompatibleWithInternalLinking scans the list of cgo
compiler flags (C/C++/Fortran) looking for flags that might cause
problems if the build in question uses internal linking. The
primary culprits are use of plugins or use of LTO, but we err on
the side of caution, supporting only those flags that are on the
allow-list for safe flags from security perspective. Return is TRUE
if a sensitive flag is found, FALSE otherwise.</p>
               
               <pre><code>func flagsNotCompatibleWithInternalLinking(sourceList []string, flagListList [][]string) bool</code></pre>
            </article>
            
            <article class="function" data-name="flushOutput">
               <h3>
                  flushOutput 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>flushOutput flushes the output being queued in a.</p>
               
               <pre><code>func (b *Builder) flushOutput(a *Action)</code></pre>
            </article>
            
            <article class="function" data-name="fmtCmd">
               <h3>
                  fmtCmd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fmtCmd formats a command in the manner of fmt.Sprintf but also:
fmtCmd replaces the value of b.WorkDir with $WORK.</p>
               
               <pre><code>func (sh *Shell) fmtCmd(dir string, format string, args ...any) string</code></pre>
            </article>
            
            <article class="function" data-name="fuzzInstrumentFlags">
               <h3>
                  fuzzInstrumentFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fuzzInstrumentFlags returns compiler flags that enable fuzzing instrumentation
on supported platforms.
On unsupported platforms, fuzzInstrumentFlags returns nil, meaning no
instrumentation is added. 'go test -fuzz' still works without coverage,
but it generates random inputs without guidance, so it's much less effective.</p>
               
               <pre><code>func fuzzInstrumentFlags() []string</code></pre>
            </article>
            
            <article class="function" data-name="gc">
               <h3>
                  gc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (tools gccgoToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, embedcfg []byte, symabis string, asmhdr bool, pgoProfile string, gofiles []string) (ofile string, output []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="gc">
               <h3>
                  gc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (noToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, embedcfg []byte, symabis string, asmhdr bool, pgoProfile string, gofiles []string) (ofile string, out []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="gc">
               <h3>
                  gc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, embedcfg []byte, symabis string, asmhdr bool, pgoProfile string, gofiles []string) (ofile string, output []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="gcBackendConcurrency">
               <h3>
                  gcBackendConcurrency 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>gcBackendConcurrency returns the backend compiler concurrency level for a package compilation.</p>
               
               <pre><code>func gcBackendConcurrency(gcflags []string) int</code></pre>
            </article>
            
            <article class="function" data-name="gcc">
               <h3>
                  gcc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>gcc runs the gcc C compiler to create an object from a single C file.</p>
               
               <pre><code>func (b *Builder) gcc(a *Action, workdir string, out string, flags []string, cfile string) error</code></pre>
            </article>
            
            <article class="function" data-name="gccArchArgs">
               <h3>
                  gccArchArgs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>gccArchArgs returns arguments to pass to gcc based on the architecture.</p>
               
               <pre><code>func (b *Builder) gccArchArgs() []string</code></pre>
            </article>
            
            <article class="function" data-name="gccCompilerID">
               <h3>
                  gccCompilerID 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>gccCompilerID returns a build cache key for the current gcc,
as identified by running 'compiler'.
The caller can use subkeys of the key.
Other parts of cmd/go can use the id as a hash
of the installed compiler version.</p>
               
               <pre><code>func (b *Builder) gccCompilerID(compiler string) (id cache.ActionID, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="gccNoPie">
               <h3>
                  gccNoPie 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>gccNoPie returns the flag to use to request non-PIE. On systems
with PIE (position independent executables) enabled by default,
-no-pie must be passed when doing a partial link with -Wl,-r.
But -no-pie is not supported by all compilers, and clang spells it -nopie.</p>
               
               <pre><code>func (b *Builder) gccNoPie(linker []string) string</code></pre>
            </article>
            
            <article class="function" data-name="gccSupportsFlag">
               <h3>
                  gccSupportsFlag 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>gccSupportsFlag checks to see if the compiler supports a flag.</p>
               
               <pre><code>func (b *Builder) gccSupportsFlag(compiler []string, flag string) bool</code></pre>
            </article>
            
            <article class="function" data-name="gccToolID">
               <h3>
                  gccToolID 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>gccToolID returns the unique ID to use for a tool that is invoked
by the GCC driver. This is used particularly for gccgo, but this can also
be used for gcc, g++, gfortran, etc.; those tools all use the GCC
driver under different names. The approach used here should also
work for sufficiently new versions of clang. Unlike toolID, the
name argument is the program to run. The language argument is the
type of input file as passed to the GCC driver's -x option.
For these tools we have no -V=full option to dump the build ID,
but we can run the tool with -v -### to reliably get the compiler proper
and hash that. That will work in the presence of -toolexec.
In order to get reproducible builds for released compilers, we
detect a released compiler by the absence of "experimental" in the
--version output, and in that case we just use the version string.
gccToolID also returns the underlying executable for the compiler.
The caller assumes that stat of the exe can be used, combined with the id,
to detect changes in the underlying compiler. The returned exe can be empty,
which means to rely only on the id.</p>
               
               <pre><code>func (b *Builder) gccToolID(name string, language string) (id string, exe string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="gccgoArchive">
               <h3>
                  gccgoArchive 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func gccgoArchive(basedir string, imp string) string</code></pre>
            </article>
            
            <article class="function" data-name="gccgoBuildIDFile">
               <h3>
                  gccgoBuildIDFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>gccgoBuildIDFile creates an assembler file that records the
action's build ID in an SHF_EXCLUDE section for ELF files or
in a CSECT in XCOFF files.</p>
               
               <pre><code>func (b *Builder) gccgoBuildIDFile(a *Action) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="gccgoCleanPkgpath">
               <h3>
                  gccgoCleanPkgpath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (tools gccgoToolchain) gccgoCleanPkgpath(b *Builder, p *load.Package) string</code></pre>
            </article>
            
            <article class="function" data-name="gccgoPkgpath">
               <h3>
                  gccgoPkgpath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func gccgoPkgpath(p *load.Package) string</code></pre>
            </article>
            
            <article class="function" data-name="gccld">
               <h3>
                  gccld 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>gccld runs the gcc linker to create an executable from a set of object files.</p>
               
               <pre><code>func (b *Builder) gccld(a *Action, objdir string, outfile string, flags []string, objs []string) error</code></pre>
            </article>
            
            <article class="function" data-name="getPkgConfigFlags">
               <h3>
                  getPkgConfigFlags 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Calls pkg-config if needed and returns the cflags/ldflags needed to build a's package.</p>
               
               <pre><code>func (b *Builder) getPkgConfigFlags(a *Action) (cflags []string, ldflags []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="gfortran">
               <h3>
                  gfortran 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>gfortran runs the gfortran Fortran compiler to create an object from a single Fortran file.</p>
               
               <pre><code>func (b *Builder) gfortran(a *Action, workdir string, out string, flags []string, ffile string) error</code></pre>
            </article>
            
            <article class="function" data-name="gfortranCmd">
               <h3>
                  gfortranCmd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>gfortranCmd returns a gfortran command line prefix.</p>
               
               <pre><code>func (b *Builder) gfortranCmd(incdir string, workdir string) []string</code></pre>
            </article>
            
            <article class="function" data-name="gxx">
               <h3>
                  gxx 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>gxx runs the g++ C++ compiler to create an object from a single C++ file.</p>
               
               <pre><code>func (b *Builder) gxx(a *Action, workdir string, out string, flags []string, cxxfile string) error</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="installAction">
               <h3>
                  installAction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>installAction returns the action for installing the result of a1.</p>
               
               <pre><code>func (b *Builder) installAction(a1 *Action, mode BuildMode) *Action</code></pre>
            </article>
            
            <article class="function" data-name="installHeader">
               <h3>
                  installHeader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Install the cgo export header file, if there is one.</p>
               
               <pre><code>func (b *Builder) installHeader(ctx context.Context, a *Action) error</code></pre>
            </article>
            
            <article class="function" data-name="installOutsideModule">
               <h3>
                  installOutsideModule 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>installOutsideModule implements 'go install pkg@version'. It builds and
installs one or more main packages in module mode while ignoring any go.mod
in the current directory or parent directories.
See golang.org/issue/40276 for details and rationale.</p>
               
               <pre><code>func installOutsideModule(ctx context.Context, args []string)</code></pre>
            </article>
            
            <article class="function" data-name="installShlibname">
               <h3>
                  installShlibname 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) installShlibname(ctx context.Context, a *Action) error</code></pre>
            </article>
            
            <article class="function" data-name="instrumentInit">
               <h3>
                  instrumentInit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func instrumentInit()</code></pre>
            </article>
            
            <article class="function" data-name="isObject">
               <h3>
                  isObject 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isObject(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="joinUnambiguously">
               <h3>
                  joinUnambiguously 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>joinUnambiguously prints the slice, quoting where necessary to make the
output unambiguous.
TODO: See issue 5279. The printing of commands needs a complete redo.</p>
               
               <pre><code>func joinUnambiguously(a []string) string</code></pre>
            </article>
            
            <article class="function" data-name="ld">
               <h3>
                  ld 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (noToolchain) ld(b *Builder, root *Action, targetPath string, importcfg string, mainpkg string) error</code></pre>
            </article>
            
            <article class="function" data-name="ld">
               <h3>
                  ld 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (gcToolchain) ld(b *Builder, root *Action, targetPath string, importcfg string, mainpkg string) error</code></pre>
            </article>
            
            <article class="function" data-name="ld">
               <h3>
                  ld 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (tools gccgoToolchain) ld(b *Builder, root *Action, targetPath string, importcfg string, mainpkg string) error</code></pre>
            </article>
            
            <article class="function" data-name="ldShared">
               <h3>
                  ldShared 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (gcToolchain) ldShared(b *Builder, root *Action, toplevelactions []*Action, targetPath string, importcfg string, allactions []*Action) error</code></pre>
            </article>
            
            <article class="function" data-name="ldShared">
               <h3>
                  ldShared 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (tools gccgoToolchain) ldShared(b *Builder, root *Action, toplevelactions []*Action, targetPath string, importcfg string, allactions []*Action) error</code></pre>
            </article>
            
            <article class="function" data-name="ldShared">
               <h3>
                  ldShared 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (noToolchain) ldShared(b *Builder, root *Action, toplevelactions []*Action, targetPath string, importcfg string, allactions []*Action) error</code></pre>
            </article>
            
            <article class="function" data-name="libname">
               <h3>
                  libname 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>libname returns the filename to use for the shared library when using
-buildmode=shared. The rules we use are:
Use arguments for special 'meta' packages:
std --> libstd.so
std cmd --> libstd,cmd.so
A single non-meta argument with trailing "/..." is special cased:
foo/... --> libfoo.so
(A relative path like "./..."  expands the "." first)
Use import paths for other cases, changing '/' to '-':
somelib --> libsubdir-somelib.so
./ or ../ --> libsubdir-somelib.so
gopkg.in/tomb.v2 -> libgopkg.in-tomb.v2.so
a/... b/... ---> liba/c,b/d.so - all matching import paths
Name parts are joined with ','.</p>
               
               <pre><code>func libname(args []string, pkgs []*load.Package) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="link">
               <h3>
                  link 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>link is the action for linking a single command.
Note that any new influence on this logic must be reported in b.linkActionID above as well.</p>
               
               <pre><code>func (b *Builder) link(ctx context.Context, a *Action) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="link">
               <h3>
                  link 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (tools gccgoToolchain) link(b *Builder, root *Action, out string, importcfg string, allactions []*Action, buildmode string, desc string) error</code></pre>
            </article>
            
            <article class="function" data-name="linkActionID">
               <h3>
                  linkActionID 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>linkActionID computes the action ID for a link action.</p>
               
               <pre><code>func (b *Builder) linkActionID(a *Action) cache.ActionID</code></pre>
            </article>
            
            <article class="function" data-name="linkShared">
               <h3>
                  linkShared 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) linkShared(ctx context.Context, a *Action) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="linkSharedAction">
               <h3>
                  linkSharedAction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>linkSharedAction takes a grouping action a1 corresponding to a list of built packages
and returns an action that links them together into a shared library with the name shlib.
If a1 is nil, shlib should be an absolute path to an existing shared library,
and then linkSharedAction reads that library to find out the package list.</p>
               
               <pre><code>func (b *Builder) linkSharedAction(mode BuildMode, depMode BuildMode, shlib string, a1 *Action) *Action</code></pre>
            </article>
            
            <article class="function" data-name="linkSharedActionID">
               <h3>
                  linkSharedActionID 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) linkSharedActionID(a *Action) cache.ActionID</code></pre>
            </article>
            
            <article class="function" data-name="linker">
               <h3>
                  linker 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (gccgoToolchain) linker() string</code></pre>
            </article>
            
            <article class="function" data-name="linker">
               <h3>
                  linker 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (noToolchain) linker() string</code></pre>
            </article>
            
            <article class="function" data-name="linker">
               <h3>
                  linker 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (gcToolchain) linker() string</code></pre>
            </article>
            
            <article class="function" data-name="loadCachedCgoHdr">
               <h3>
                  loadCachedCgoHdr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) loadCachedCgoHdr(a *Action) error</code></pre>
            </article>
            
            <article class="function" data-name="loadCachedCompiledGoFiles">
               <h3>
                  loadCachedCompiledGoFiles 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) loadCachedCompiledGoFiles(a *Action) error</code></pre>
            </article>
            
            <article class="function" data-name="loadCachedObjdirFile">
               <h3>
                  loadCachedObjdirFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) loadCachedObjdirFile(a *Action, c cache.Cache, name string) error</code></pre>
            </article>
            
            <article class="function" data-name="loadCachedVet">
               <h3>
                  loadCachedVet 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) loadCachedVet(a *Action) error</code></pre>
            </article>
            
            <article class="function" data-name="maybePIC">
               <h3>
                  maybePIC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>maybePIC adds -fPIC to the list of arguments if needed.</p>
               
               <pre><code>func (tools gccgoToolchain) maybePIC(args []string) []string</code></pre>
            </article>
            
            <article class="function" data-name="mayberemovefile">
               <h3>
                  mayberemovefile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>mayberemovefile removes a file only if it is a regular file
When running as a user with sufficient privileges, we may delete
even device files, for example, which is not intended.</p>
               
               <pre><code>func mayberemovefile(s string)</code></pre>
            </article>
            
            <article class="function" data-name="mkAbs">
               <h3>
                  mkAbs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>mkAbs returns an absolute path corresponding to
evaluating f in the directory dir.
We always pass absolute paths of source files so that
the error messages will include the full path to a file
in need of attention.</p>
               
               <pre><code>func mkAbs(dir string, f string) string</code></pre>
            </article>
            
            <article class="function" data-name="mkAbsFiles">
               <h3>
                  mkAbsFiles 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>mkAbsFiles converts files into a list of absolute files,
assuming they were originally relative to dir,
and returns that new list.</p>
               
               <pre><code>func mkAbsFiles(dir string, files []string) []string</code></pre>
            </article>
            
            <article class="function" data-name="moveOrCopyFile">
               <h3>
                  moveOrCopyFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>moveOrCopyFile is like 'mv src dst' or 'cp src dst'.</p>
               
               <pre><code>func (sh *Shell) moveOrCopyFile(dst string, src string, perm fs.FileMode, force bool) error</code></pre>
            </article>
            
            <article class="function" data-name="needCgoHdr">
               <h3>
                  needCgoHdr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>needCgoHdr reports whether the actions triggered by this one
expect to be able to access the cgo-generated header file.</p>
               
               <pre><code>func (b *Builder) needCgoHdr(a *Action) bool</code></pre>
            </article>
            
            <article class="function" data-name="newBuildActor">
               <h3>
                  newBuildActor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newBuildActor returns a new buildActor object, setting up the
covMetaFileName field if 'genCoverMeta' flag is set.</p>
               
               <pre><code>func newBuildActor(p *load.Package, genCoverMeta bool) *buildActor</code></pre>
            </article>
            
            <article class="function" data-name="noCompiler">
               <h3>
                  noCompiler 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func noCompiler() error</code></pre>
            </article>
            
            <article class="function" data-name="omitTestOnly">
               <h3>
                  omitTestOnly 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>omitTestOnly returns pkgs with test-only packages removed.</p>
               
               <pre><code>func omitTestOnly(pkgs []*load.Package) []*load.Package</code></pre>
            </article>
            
            <article class="function" data-name="oneMainPkg">
               <h3>
                  oneMainPkg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func oneMainPkg(pkgs []*load.Package) []*load.Package</code></pre>
            </article>
            
            <article class="function" data-name="pack">
               <h3>
                  pack 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (tools gccgoToolchain) pack(b *Builder, a *Action, afile string, ofiles []string) error</code></pre>
            </article>
            
            <article class="function" data-name="pack">
               <h3>
                  pack 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (gcToolchain) pack(b *Builder, a *Action, afile string, ofiles []string) error</code></pre>
            </article>
            
            <article class="function" data-name="pack">
               <h3>
                  pack 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (noToolchain) pack(b *Builder, a *Action, afile string, ofiles []string) error</code></pre>
            </article>
            
            <article class="function" data-name="packInternal">
               <h3>
                  packInternal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func packInternal(afile string, ofiles []string) error</code></pre>
            </article>
            
            <article class="function" data-name="passLongArgsInResponseFiles">
               <h3>
                  passLongArgsInResponseFiles 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>passLongArgsInResponseFiles modifies cmd such that, for
certain programs, long arguments are passed in "response files", a
file on disk with the arguments, with one arg per line. An actual
argument starting with '@' means that the rest of the argument is
a filename of arguments to expand.
See issues 18468 (Windows) and 37768 (Darwin).</p>
               
               <pre><code>func passLongArgsInResponseFiles(cmd *exec.Cmd) (cleanup func())</code></pre>
            </article>
            
            <article class="function" data-name="pgoActionID">
               <h3>
                  pgoActionID 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>pgoActionID computes the action ID for a preprocess PGO action.</p>
               
               <pre><code>func (b *Builder) pgoActionID(input string) cache.ActionID</code></pre>
            </article>
            
            <article class="function" data-name="pkg">
               <h3>
                  pkg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sh *Shell) pkg() *load.Package</code></pre>
            </article>
            
            <article class="function" data-name="pkgPath">
               <h3>
                  pkgPath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func pkgPath(a *Action) string</code></pre>
            </article>
            
            <article class="function" data-name="pkgsMain">
               <h3>
                  pkgsMain 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func pkgsMain(pkgs []*load.Package) (res []*load.Package)</code></pre>
            </article>
            
            <article class="function" data-name="pkgsNotMain">
               <h3>
                  pkgsNotMain 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func pkgsNotMain(pkgs []*load.Package) (res []*load.Package)</code></pre>
            </article>
            
            <article class="function" data-name="pluginPath">
               <h3>
                  pluginPath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>pluginPath computes the package path for a plugin main package.
This is typically the import path of the main package p, unless the
plugin is being built directly from source files. In that case we
combine the package build ID with the contents of the main package
source files. This allows us to identify two different plugins
built from two source files with the same name.</p>
               
               <pre><code>func pluginPath(a *Action) string</code></pre>
            </article>
            
            <article class="function" data-name="pop">
               <h3>
                  pop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (q *actionQueue) pop() *Action</code></pre>
            </article>
            
            <article class="function" data-name="printLinkerConfig">
               <h3>
                  printLinkerConfig 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>printLinkerConfig prints the linker config into the hash h,
as part of the computation of a linker-related action ID.</p>
               
               <pre><code>func (b *Builder) printLinkerConfig(h io.Writer, p *load.Package)</code></pre>
            </article>
            
            <article class="function" data-name="printfLocked">
               <h3>
                  printfLocked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sh *Shell) printfLocked(format string, a ...any)</code></pre>
            </article>
            
            <article class="function" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (q *actionQueue) push(a *Action)</code></pre>
            </article>
            
            <article class="function" data-name="readpkglist">
               <h3>
                  readpkglist 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readpkglist returns the list of packages that were built into the shared library
at shlibpath. For the native toolchain this list is stored, newline separated, in
an ELF note with name "Go\x00\x00" and type 1. For GCCGO it is extracted from the
.go_export section.</p>
               
               <pre><code>func readpkglist(shlibpath string) (pkgs []*load.Package)</code></pre>
            </article>
            
            <article class="function" data-name="replacePrefix">
               <h3>
                  replacePrefix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>replacePrefix is like strings.ReplaceAll, but only replaces instances of old
that are preceded by ' ', '\t', or appear at the beginning of a line.</p>
               
               <pre><code>func replacePrefix(s string, old string, new string) string</code></pre>
            </article>
            
            <article class="function" data-name="reportCmd">
               <h3>
                  reportCmd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>reportCmd reports the output and exit status of a command. The cmdOut and
cmdErr arguments are the output and exit error of the command, respectively.
The exact reporting behavior is as follows:
cmdOut  cmdErr  Result
""      nil     print nothing, return nil
!=""    nil     print output, return nil
""      !=nil   print nothing, return cmdErr (later printed)
!=""    !=nil   print nothing, ignore err, return output as error (later printed)
reportCmd returns a non-nil error if and only if cmdErr != nil. It assumes
that the command output, if non-empty, is more detailed than the command
error (which is usually just an exit status), so prefers using the output as
the ultimate error. Typically, the caller should return this error from an
Action, which it will be printed by the Builder.
reportCmd formats the output as "# desc" followed by the given output. The
output is expected to contain references to 'dir', usually the source
directory for the package that has failed to build. reportCmd rewrites
mentions of dir with a relative path to dir when the relative path is
shorter. This is usually more pleasant. For example, if fmt doesn't compile
and we are in src/html, the output is
$ go build
# fmt
../fmt/print.go:1090: undefined: asdf
$
instead of
$ go build
# fmt
/usr/gopher/go/src/fmt/print.go:1090: undefined: asdf
$
reportCmd also replaces references to the work directory with $WORK, replaces
cgo file paths with the original file path, and replaces cgo-mangled names
with "C.name".
desc is optional. If "", a.Package.Desc() is used.
dir is optional. If "", a.Package.Dir is used.</p>
               
               <pre><code>func (sh *Shell) reportCmd(desc string, dir string, cmdOut []byte, cmdErr error) error</code></pre>
            </article>
            
            <article class="function" data-name="run">
               <h3>
                  run 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>run runs the command given by cmdline in the directory dir.
If the command fails, run prints information about the failure
and returns a non-nil error.</p>
               
               <pre><code>func (sh *Shell) run(dir string, desc string, env []string, cmdargs ...any) error</code></pre>
            </article>
            
            <article class="function" data-name="runBuild">
               <h3>
                  runBuild 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runBuild(ctx context.Context, cmd *base.Command, args []string)</code></pre>
            </article>
            
            <article class="function" data-name="runInstall">
               <h3>
                  runInstall 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func runInstall(ctx context.Context, cmd *base.Command, args []string)</code></pre>
            </article>
            
            <article class="function" data-name="runOut">
               <h3>
                  runOut 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>runOut runs the command given by cmdline in the directory dir.
It returns the command output and any errors that occurred.
It accumulates execution time in a.</p>
               
               <pre><code>func (sh *Shell) runOut(dir string, env []string, cmdargs ...any) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="setextld">
               <h3>
                  setextld 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>setextld sets the appropriate linker flags for the specified compiler.</p>
               
               <pre><code>func setextld(ldflags []string, compiler []string) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="showStdout">
               <h3>
                  showStdout 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func showStdout(b *Builder, c cache.Cache, a *Action, key string) error</code></pre>
            </article>
            
            <article class="function" data-name="splitPkgConfigOutput">
               <h3>
                  splitPkgConfigOutput 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>splitPkgConfigOutput parses the pkg-config output into a slice of flags.
This implements the shell quoting semantics described in
https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02,
except that it does not support parameter or arithmetic expansion or command
substitution and hard-codes the <blank> delimiters instead of reading them
from LC_LOCALE.</p>
               
               <pre><code>func splitPkgConfigOutput(out []byte) ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="statString">
               <h3>
                  statString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>statString returns a string form of an os.FileInfo, for serializing and comparison.</p>
               
               <pre><code>func statString(info os.FileInfo) string</code></pre>
            </article>
            
            <article class="function" data-name="supportsCgoIncomplete">
               <h3>
                  supportsCgoIncomplete 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>supportsCgoIncomplete reports whether the gccgo/GoLLVM compiler
being used supports cgo.Incomplete, which was added in GCC 13.
This takes an Action only for output reporting purposes.
The result value is unrelated to the Action.</p>
               
               <pre><code>func (tools gccgoToolchain) supportsCgoIncomplete(b *Builder, a *Action) bool</code></pre>
            </article>
            
            <article class="function" data-name="swig">
               <h3>
                  swig 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Run SWIG on all SWIG input files.
TODO: Don't build a shared library, once SWIG emits the necessary
pragmas for external linking.</p>
               
               <pre><code>func (b *Builder) swig(a *Action, objdir string, pcCFLAGS []string) (outGo []string, outC []string, outCXX []string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="swigDoIntSize">
               <h3>
                  swigDoIntSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Determine the size of int on the target system for the -intgosize option
of swig >= 2.0.9. Run only once.</p>
               
               <pre><code>func (b *Builder) swigDoIntSize(objdir string) (intsize string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="swigDoVersionCheck">
               <h3>
                  swigDoVersionCheck 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) swigDoVersionCheck() error</code></pre>
            </article>
            
            <article class="function" data-name="swigIntSize">
               <h3>
                  swigIntSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Determine the size of int on the target system for the -intgosize option
of swig >= 2.0.9.</p>
               
               <pre><code>func (b *Builder) swigIntSize(objdir string) (intsize string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="swigOne">
               <h3>
                  swigOne 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Run SWIG on one SWIG input file.</p>
               
               <pre><code>func (b *Builder) swigOne(a *Action, file string, objdir string, pcCFLAGS []string, cxx bool, intgosize string) (outGo string, outC string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="swigVersionCheck">
               <h3>
                  swigVersionCheck 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) swigVersionCheck() error</code></pre>
            </article>
            
            <article class="function" data-name="symabis">
               <h3>
                  symabis 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (gccgoToolchain) symabis(b *Builder, a *Action, sfiles []string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="symabis">
               <h3>
                  symabis 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (gcToolchain) symabis(b *Builder, a *Action, sfiles []string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="symabis">
               <h3>
                  symabis 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (noToolchain) symabis(b *Builder, a *Action, sfiles []string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="toolID">
               <h3>
                  toolID 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>toolID returns the unique ID to use for the current copy of the
named tool (asm, compile, cover, link).
It is important that if the tool changes (for example a compiler bug is fixed
and the compiler reinstalled), toolID returns a different string, so that old
package archives look stale and are rebuilt (with the fixed compiler).
This suggests using a content hash of the tool binary, as stored in the build ID.
Unfortunately, we can't just open the tool binary, because the tool might be
invoked via a wrapper program specified by -toolexec and we don't know
what the wrapper program does. In particular, we want "-toolexec toolstash"
to continue working: it does no good if "-toolexec toolstash" is executing a
stashed copy of the compiler but the go command is acting as if it will run
the standard copy of the compiler. The solution is to ask the tool binary to tell
us its own build ID using the "-V=full" flag now supported by all tools.
Then we know we're getting the build ID of the compiler that will actually run
during the build. (How does the compiler binary know its own content hash?
We store it there using updateBuildID after the standard link step.)
A final twist is that we'd prefer to have reproducible builds for release toolchains.
It should be possible to cross-compile for Windows from either Linux or Mac
or Windows itself and produce the same binaries, bit for bit. If the tool ID,
which influences the action ID half of the build ID, is based on the content ID,
then the Linux compiler binary and Mac compiler binary will have different tool IDs
and therefore produce executables with different action IDs.
To avoid this problem, for releases we use the release version string instead
of the compiler binary's content hash. This assumes that all compilers built
on all different systems are semantically equivalent, which is of course only true
modulo bugs. (Producing the exact same executables also requires that the different
build setups agree on details like $GOROOT and file name paths, but at least the
tool IDs do not make it impossible.)</p>
               
               <pre><code>func (b *Builder) toolID(name string) string</code></pre>
            </article>
            
            <article class="function" data-name="toolVerify">
               <h3>
                  toolVerify 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>toolVerify checks that the command line args writes the same output file
if run using newTool instead.
Unused now but kept around for future use.</p>
               
               <pre><code>func toolVerify(a *Action, b *Builder, p *load.Package, newTool string, ofile string, args []any) error</code></pre>
            </article>
            
            <article class="function" data-name="trimpath">
               <h3>
                  trimpath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>trimpath returns the -trimpath argument to use
when compiling the action.</p>
               
               <pre><code>func (a *Action) trimpath() string</code></pre>
            </article>
            
            <article class="function" data-name="updateBuildID">
               <h3>
                  updateBuildID 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>updateBuildID updates the build ID in the target written by action a.
It requires that useCache was called for action a and returned false,
and that the build was then carried out and given the temporary
a.buildID to record as the build ID in the resulting package or binary.
updateBuildID computes the final content ID and updates the build IDs
in the binary.
Keep in sync with src/cmd/buildid/buildid.go</p>
               
               <pre><code>func (b *Builder) updateBuildID(a *Action, target string) error</code></pre>
            </article>
            
            <article class="function" data-name="useCache">
               <h3>
                  useCache 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>useCache tries to satisfy the action a, which has action ID actionHash,
by using a cached result from an earlier build.
If useCache decides that the cache can be used, it sets a.buildID
and a.built for use by parent actions and then returns true.
Otherwise it sets a.buildID to a temporary build ID for use in the build
and returns false. When useCache returns false the expectation is that
the caller will build the target and then call updateBuildID to finish the
build ID computation.
When useCache returns false, it may have initiated buffering of output
during a's work. The caller should defer b.flushOutput(a), to make sure
that flushOutput is eventually called regardless of whether the action
succeeds. The flushOutput call must happen after updateBuildID.</p>
               
               <pre><code>func (b *Builder) useCache(a *Action, actionHash cache.ActionID, target string, printOutput bool) (ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="useResponseFile">
               <h3>
                  useResponseFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func useResponseFile(path string, argLen int) bool</code></pre>
            </article>
            
            <article class="function" data-name="vet">
               <h3>
                  vet 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) vet(ctx context.Context, a *Action) error</code></pre>
            </article>
            
            <article class="function" data-name="vetAction">
               <h3>
                  vetAction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) vetAction(mode BuildMode, depMode BuildMode, p *load.Package) *Action</code></pre>
            </article>
            
            <article class="function" data-name="writeCoverPkgInputs">
               <h3>
                  writeCoverPkgInputs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) writeCoverPkgInputs(a *Action, pconfigfile string, covoutputsfile string, outfiles []string) error</code></pre>
            </article>
            
            <article class="function" data-name="writeFile">
               <h3>
                  writeFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeFile writes the text to file.</p>
               
               <pre><code>func (sh *Shell) writeFile(file string, text []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="writeLinkImportcfg">
               <h3>
                  writeLinkImportcfg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *Builder) writeLinkImportcfg(a *Action, file string) error</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
